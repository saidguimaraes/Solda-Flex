CCS PCH C Compiler, Version 5.015, 48515               24-mar-18 13:23

               Filename:   C:\Users\Artur_azevedo\Documents\Projetos_ICTS\ROBÔ_SOLDAGEM\CPU\SOFTWARE\main.lst

               ROM used:   46724 bytes (71%)
                           Largest free fragment is 18808
               RAM used:   392 (10%) at main() level
                           548 (14%) worst case
               Stack used: 20 locations (16 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   AF68
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  FF2.5
0004A:  GOTO   0054
0004E:  BTFSC  FF2.2
00050:  GOTO   1BD8
00054:  BTFSS  F9D.0
00056:  GOTO   0060
0005A:  BTFSC  F9E.0
0005C:  GOTO   1C2A
00060:  BTFSS  FA0.1
00062:  GOTO   006C
00066:  BTFSC  FA1.1
00068:  GOTO   1C32
0006C:  BTFSS  FF0.3
0006E:  GOTO   0078
00072:  BTFSC  FF0.0
00074:  GOTO   1C5A
00078:  MOVFF  0E,00
0007C:  MOVFF  0F,01
00080:  MOVFF  10,02
00084:  MOVFF  11,03
00088:  MOVFF  0C,FE9
0008C:  MOVFF  07,FEA
00090:  BSF    07.7
00092:  MOVFF  08,FE1
00096:  MOVFF  09,FE2
0009A:  MOVFF  0A,FD9
0009E:  MOVFF  0B,FDA
000A2:  MOVFF  12,FF3
000A6:  MOVFF  13,FF4
000AA:  MOVFF  14,FFA
000AE:  MOVF   04,W
000B0:  MOVFF  06,FE0
000B4:  MOVFF  05,FD8
000B8:  RETFIE 0
....................  
.................... #include <18F4620.h> 
.................... //////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
000BA:  DATA 65,72
000BC:  DATA 72,6F
000BE:  DATA 20,64
000C0:  DATA 65,20
000C2:  DATA 65,73
000C4:  DATA 63,72
000C6:  DATA 69,74
000C8:  DATA 61,20
000CA:  DATA 00,00
000CC:  DATA 20,20
000CE:  DATA 20,45
000D0:  DATA 45,50
000D2:  DATA 52,4F
000D4:  DATA 4D,20
000D6:  DATA 20,20
000D8:  DATA 20,20
000DA:  DATA 20,20
000DC:  DATA 00,00
000DE:  DATA 65,72
000E0:  DATA 72,6F
000E2:  DATA 20,64
000E4:  DATA 65,20
000E6:  DATA 6C,65
000E8:  DATA 69,74
000EA:  DATA 75,72
000EC:  DATA 61,20
000EE:  DATA 20,00
000F0:  DATA 20,20
000F2:  DATA 20,20
000F4:  DATA 20,45
000F6:  DATA 45,50
000F8:  DATA 52,4F
000FA:  DATA 4D,20
000FC:  DATA 20,20
000FE:  DATA 20,20
00100:  DATA 20,00
00102:  DATA 20,20
00104:  DATA 20,20
00106:  DATA 20,20
00108:  DATA 20,45
0010A:  DATA 49,58
0010C:  DATA 4F,20
0010E:  DATA 58,59
00110:  DATA 20,20
00112:  DATA 20,20
00114:  DATA 20,20
00116:  DATA 0A,0D
00118:  DATA 00,00
0011A:  DATA 58,3A
0011C:  DATA 30,30
0011E:  DATA 30,30
00120:  DATA 20,20
00122:  DATA 20,20
00124:  DATA 20,20
00126:  DATA 20,20
00128:  DATA 20,20
0012A:  DATA 20,20
0012C:  DATA 20,20
0012E:  DATA 0A,0D
00130:  DATA 00,00
00132:  DATA 59,3A
00134:  DATA 30,30
00136:  DATA 30,30
00138:  DATA 20,20
0013A:  DATA 20,20
0013C:  DATA 20,20
0013E:  DATA 20,20
00140:  DATA 20,20
00142:  DATA 20,20
00144:  DATA 20,20
00146:  DATA 0A,0D
00148:  DATA 00,00
0014A:  DATA 20,20
0014C:  DATA 45,49
0014E:  DATA 58,4F
00150:  DATA 20,52
00152:  DATA 4F,54
00154:  DATA 41,43
00156:  DATA 49,4F
00158:  DATA 4E,41
0015A:  DATA 4C,20
0015C:  DATA 20,20
0015E:  DATA 0A,0D
00160:  DATA 00,00
00162:  DATA 5A,3A
00164:  DATA 30,30
00166:  DATA 30,30
00168:  DATA 20,20
0016A:  DATA 20,20
0016C:  DATA 20,20
0016E:  DATA 20,20
00170:  DATA 20,20
00172:  DATA 20,20
00174:  DATA 20,20
00176:  DATA 0A,0D
00178:  DATA 00,00
0017A:  DATA 20,20
0017C:  DATA 20,20
0017E:  DATA 20,20
00180:  DATA 20,20
00182:  DATA 20,45
00184:  DATA 49,58
00186:  DATA 4F,20
00188:  DATA 5A,20
0018A:  DATA 20,20
0018C:  DATA 20,0A
0018E:  DATA 0D,00
00190:  DATA 52,3A
00192:  DATA 30,30
00194:  DATA 30,30
00196:  DATA 20,20
00198:  DATA 20,20
0019A:  DATA 20,20
0019C:  DATA 20,20
0019E:  DATA 20,20
001A0:  DATA 20,20
001A2:  DATA 20,20
001A4:  DATA 0A,0D
001A6:  DATA 00,00
001A8:  DATA 20,45
001AA:  DATA 4D,50
001AC:  DATA 55,52
001AE:  DATA 52,41
001B0:  DATA 44,4F
001B2:  DATA 52,20
001B4:  DATA 45,4E
001B6:  DATA 54,52
001B8:  DATA 41,44
001BA:  DATA 41,0A
001BC:  DATA 0D,00
001BE:  DATA 46,31
001C0:  DATA 3A,41
001C2:  DATA 56,41
001C4:  DATA 4E,43
001C6:  DATA 41,20
001C8:  DATA 20,20
001CA:  DATA 20,53
001CC:  DATA 5F,41
001CE:  DATA 3A,4F
001D0:  DATA 46,46
001D2:  DATA 0A,0D
001D4:  DATA 00,00
001D6:  DATA 46,32
001D8:  DATA 3A,52
001DA:  DATA 45,43
001DC:  DATA 55,41
001DE:  DATA 20,20
001E0:  DATA 20,20
001E2:  DATA 20,53
001E4:  DATA 5F,52
001E6:  DATA 3A,4F
001E8:  DATA 46,46
001EA:  DATA 0A,0D
001EC:  DATA 00,00
001EE:  DATA 20,20
001F0:  DATA 20,20
001F2:  DATA 20,20
001F4:  DATA 20,20
001F6:  DATA 20,53
001F8:  DATA 5F,50
001FA:  DATA 4C,41
001FC:  DATA 43,41
001FE:  DATA 3A,4F
00200:  DATA 46,46
00202:  DATA 0A,0D
00204:  DATA 00,00
00206:  DATA 4F,4E
00208:  DATA 20,00
0020A:  DATA 4F,46
0020C:  DATA 46,00
0020E:  DATA 4F,4E
00210:  DATA 20,00
00212:  DATA 4F,46
00214:  DATA 46,00
00216:  DATA 20,20
00218:  DATA 44,45
0021A:  DATA 44,4F
0021C:  DATA 53,20
0021E:  DATA 45,4E
00220:  DATA 54,52
00222:  DATA 41,44
00224:  DATA 41,0A
00226:  DATA 0D,00
00228:  DATA 46,31
0022A:  DATA 3A,41
0022C:  DATA 56,41
0022E:  DATA 4E,43
00230:  DATA 41,20
00232:  DATA 20,20
00234:  DATA 53,5F
00236:  DATA 41,31
00238:  DATA 3A,4F
0023A:  DATA 46,46
0023C:  DATA 0A,0D
0023E:  DATA 00,00
00240:  DATA 46,32
00242:  DATA 3A,52
00244:  DATA 45,43
00246:  DATA 55,41
00248:  DATA 20,20
0024A:  DATA 20,20
0024C:  DATA 53,5F
0024E:  DATA 41,32
00250:  DATA 3A,4F
00252:  DATA 46,46
00254:  DATA 0A,0D
00256:  DATA 00,00
00258:  DATA 4F,4E
0025A:  DATA 20,00
0025C:  DATA 4F,46
0025E:  DATA 46,00
00260:  DATA 4F,4E
00262:  DATA 20,00
00264:  DATA 4F,46
00266:  DATA 46,00
00268:  DATA 20,20
0026A:  DATA 20,20
0026C:  DATA 20,20
0026E:  DATA 20,20
00270:  DATA 50,52
00272:  DATA 45,53
00274:  DATA 53,4F
00276:  DATA 52,20
00278:  DATA 20,20
0027A:  DATA 20,20
0027C:  DATA 0A,0D
0027E:  DATA 00,00
00280:  DATA 46,31
00282:  DATA 3A,41
00284:  DATA 56,41
00286:  DATA 4E,43
00288:  DATA 41,20
0028A:  DATA 20,20
0028C:  DATA 20,53
0028E:  DATA 5F,41
00290:  DATA 3A,4F
00292:  DATA 46,46
00294:  DATA 0A,0D
00296:  DATA 00,00
00298:  DATA 46,32
0029A:  DATA 3A,52
0029C:  DATA 45,43
0029E:  DATA 55,41
002A0:  DATA 20,20
002A2:  DATA 20,20
002A4:  DATA 20,53
002A6:  DATA 5F,52
002A8:  DATA 3A,4F
002AA:  DATA 46,46
002AC:  DATA 0A,0D
002AE:  DATA 00,00
002B0:  DATA 4F,4E
002B2:  DATA 20,00
002B4:  DATA 4F,46
002B6:  DATA 46,00
002B8:  DATA 20,20
002BA:  DATA 20,44
002BC:  DATA 49,53
002BE:  DATA 50,45
002C0:  DATA 4E,53
002C2:  DATA 41,44
002C4:  DATA 4F,52
002C6:  DATA 20,20
002C8:  DATA 20,20
002CA:  DATA 20,0A
002CC:  DATA 0D,00
002CE:  DATA 46,31
002D0:  DATA 3A,41
002D2:  DATA 56,41
002D4:  DATA 4E,43
002D6:  DATA 41,20
002D8:  DATA 20,20
002DA:  DATA 20,53
002DC:  DATA 5F,41
002DE:  DATA 3A,4F
002E0:  DATA 46,46
002E2:  DATA 0A,0D
002E4:  DATA 00,00
002E6:  DATA 46,32
002E8:  DATA 3A,52
002EA:  DATA 45,43
002EC:  DATA 55,41
002EE:  DATA 20,20
002F0:  DATA 20,20
002F2:  DATA 20,53
002F4:  DATA 5F,52
002F6:  DATA 3A,4F
002F8:  DATA 46,46
002FA:  DATA 0A,0D
002FC:  DATA 00,00
002FE:  DATA 4F,4E
00300:  DATA 20,00
00302:  DATA 4F,46
00304:  DATA 46,00
00306:  DATA 4F,4E
00308:  DATA 20,00
0030A:  DATA 4F,46
0030C:  DATA 46,00
0030E:  DATA 20,20
00310:  DATA 20,20
00312:  DATA 20,44
00314:  DATA 45,44
00316:  DATA 4F,53
00318:  DATA 20,53
0031A:  DATA 41,49
0031C:  DATA 44,41
0031E:  DATA 20,20
00320:  DATA 20,20
00322:  DATA 0A,0D
00324:  DATA 00,00
00326:  DATA 46,31
00328:  DATA 3A,41
0032A:  DATA 56,41
0032C:  DATA 4E,43
0032E:  DATA 41,20
00330:  DATA 20,20
00332:  DATA 20,53
00334:  DATA 5F,41
00336:  DATA 3A,4F
00338:  DATA 46,46
0033A:  DATA 0A,0D
0033C:  DATA 00,00
0033E:  DATA 46,32
00340:  DATA 3A,52
00342:  DATA 45,43
00344:  DATA 55,41
00346:  DATA 20,20
00348:  DATA 20,20
0034A:  DATA 20,53
0034C:  DATA 5F,52
0034E:  DATA 3A,4F
00350:  DATA 46,46
00352:  DATA 0A,0D
00354:  DATA 00,00
00356:  DATA 4F,4E
00358:  DATA 20,00
0035A:  DATA 4F,46
0035C:  DATA 46,00
0035E:  DATA 4F,4E
00360:  DATA 20,00
00362:  DATA 4F,46
00364:  DATA 46,00
00366:  DATA 20,20
00368:  DATA 20,20
0036A:  DATA 20,20
0036C:  DATA 4C,49
0036E:  DATA 4D,50
00370:  DATA 41,44
00372:  DATA 4F,52
00374:  DATA 20,20
00376:  DATA 20,20
00378:  DATA 20,20
0037A:  DATA 0A,0D
0037C:  DATA 00,00
0037E:  DATA 46,31
00380:  DATA 3A,4C
00382:  DATA 49,47
00384:  DATA 41,20
00386:  DATA 20,20
00388:  DATA 20,20
0038A:  DATA 20,20
0038C:  DATA 20,20
0038E:  DATA 20,0A
00390:  DATA 0D,00
00392:  DATA 46,31
00394:  DATA 3A,44
00396:  DATA 45,53
00398:  DATA 4C,49
0039A:  DATA 47,41
0039C:  DATA 20,20
0039E:  DATA 20,20
003A0:  DATA 20,20
003A2:  DATA 20,0A
003A4:  DATA 0D,00
003A6:  DATA 20,20
003A8:  DATA 20,20
003AA:  DATA 20,45
003AC:  DATA 53,54
003AE:  DATA 45,49
003B0:  DATA 52,41
003B2:  DATA 20,20
003B4:  DATA 20,20
003B6:  DATA 20,20
003B8:  DATA 20,20
003BA:  DATA 0A,0D
003BC:  DATA 00,00
003BE:  DATA 46,31
003C0:  DATA 3A,41
003C2:  DATA 56,41
003C4:  DATA 4E,43
003C6:  DATA 41,20
003C8:  DATA 20,20
003CA:  DATA 20,53
003CC:  DATA 5F,41
003CE:  DATA 3A,4F
003D0:  DATA 46,46
003D2:  DATA 0A,0D
003D4:  DATA 00,00
003D6:  DATA 46,32
003D8:  DATA 3A,52
003DA:  DATA 45,43
003DC:  DATA 55,41
003DE:  DATA 20,20
003E0:  DATA 20,20
003E2:  DATA 20,20
003E4:  DATA 20,20
003E6:  DATA 20,20
003E8:  DATA 20,20
003EA:  DATA 0A,0D
003EC:  DATA 00,00
003EE:  DATA 4F,4E
003F0:  DATA 20,00
003F2:  DATA 4F,46
003F4:  DATA 46,00
003F6:  DATA 20,41
003F8:  DATA 4C,49
003FA:  DATA 4D,45
003FC:  DATA 4E,54
003FE:  DATA 41,44
00400:  DATA 4F,52
00402:  DATA 20,53
00404:  DATA 4F,4C
00406:  DATA 44,41
00408:  DATA 20,20
0040A:  DATA 0A,0D
0040C:  DATA 00,00
0040E:  DATA 46,31
00410:  DATA 3A,20
00412:  DATA 31,20
00414:  DATA 20,20
00416:  DATA 46,33
00418:  DATA 3A,20
0041A:  DATA 33,20
0041C:  DATA 20,20
0041E:  DATA 20,20
00420:  DATA 20,20
00422:  DATA 0A,0D
00424:  DATA 00,00
00426:  DATA 46,32
00428:  DATA 3A,20
0042A:  DATA 32,20
0042C:  DATA 20,20
0042E:  DATA 20,20
00430:  DATA 20,20
00432:  DATA 20,20
00434:  DATA 20,20
00436:  DATA 20,20
00438:  DATA 20,20
0043A:  DATA 0A,0D
0043C:  DATA 00,00
0043E:  DATA 20,20
00440:  DATA 46,45
00442:  DATA 52,52
00444:  DATA 4F,20
00446:  DATA 53,4F
00448:  DATA 4C,44
0044A:  DATA 41,20
0044C:  DATA 31,20
0044E:  DATA 20,20
00450:  DATA 0A,0D
00452:  DATA 00,00
00454:  DATA 46,31
00456:  DATA 3A,41
00458:  DATA 56,41
0045A:  DATA 4E,43
0045C:  DATA 41,20
0045E:  DATA 20,20
00460:  DATA 20,53
00462:  DATA 5F,41
00464:  DATA 3A,4F
00466:  DATA 46,46
00468:  DATA 0A,0D
0046A:  DATA 00,00
0046C:  DATA 46,32
0046E:  DATA 3A,52
00470:  DATA 45,43
00472:  DATA 55,41
00474:  DATA 20,20
00476:  DATA 20,20
00478:  DATA 20,53
0047A:  DATA 5F,52
0047C:  DATA 3A,4F
0047E:  DATA 46,46
00480:  DATA 0A,0D
00482:  DATA 00,00
00484:  DATA 4F,4E
00486:  DATA 20,00
00488:  DATA 4F,46
0048A:  DATA 46,00
0048C:  DATA 20,20
0048E:  DATA 46,45
00490:  DATA 52,52
00492:  DATA 4F,20
00494:  DATA 53,4F
00496:  DATA 4C,44
00498:  DATA 41,20
0049A:  DATA 32,20
0049C:  DATA 20,20
0049E:  DATA 0A,0D
004A0:  DATA 00,00
004A2:  DATA 46,31
004A4:  DATA 3A,41
004A6:  DATA 56,41
004A8:  DATA 4E,43
004AA:  DATA 41,20
004AC:  DATA 20,20
004AE:  DATA 20,53
004B0:  DATA 5F,41
004B2:  DATA 3A,4F
004B4:  DATA 46,46
004B6:  DATA 0A,0D
004B8:  DATA 00,00
004BA:  DATA 46,32
004BC:  DATA 3A,52
004BE:  DATA 45,43
004C0:  DATA 55,41
004C2:  DATA 20,20
004C4:  DATA 20,20
004C6:  DATA 20,53
004C8:  DATA 5F,52
004CA:  DATA 3A,4F
004CC:  DATA 46,46
004CE:  DATA 0A,0D
004D0:  DATA 00,00
004D2:  DATA 4F,4E
004D4:  DATA 20,00
004D6:  DATA 4F,46
004D8:  DATA 46,00
004DA:  DATA 53,5F
004DC:  DATA 44,45
004DE:  DATA 44,4F
004E0:  DATA 5F,49
004E2:  DATA 4E,5F
004E4:  DATA 4C,53
004E6:  DATA 31,20
004E8:  DATA 09,20
004EA:  DATA 20,20
004EC:  DATA 20,20
004EE:  DATA 00,00
004F0:  DATA 53,5F
004F2:  DATA 44,45
004F4:  DATA 44,4F
004F6:  DATA 5F,49
004F8:  DATA 4E,5F
004FA:  DATA 4C,53
004FC:  DATA 32,20
004FE:  DATA 09,20
00500:  DATA 20,20
00502:  DATA 20,20
00504:  DATA 00,00
00506:  DATA 53,5F
00508:  DATA 45,4D
0050A:  DATA 50,55
0050C:  DATA 52,52
0050E:  DATA 41,44
00510:  DATA 4F,52
00512:  DATA 5F,49
00514:  DATA 4E,5F
00516:  DATA 4C,53
00518:  DATA 31,09
0051A:  DATA 20,00
0051C:  DATA 53,5F
0051E:  DATA 45,4D
00520:  DATA 50,55
00522:  DATA 52,52
00524:  DATA 41,44
00526:  DATA 4F,52
00528:  DATA 5F,49
0052A:  DATA 4E,5F
0052C:  DATA 4C,53
0052E:  DATA 32,20
00530:  DATA 20,00
00532:  DATA 53,5F
00534:  DATA 50,52
00536:  DATA 45,53
00538:  DATA 53,4F
0053A:  DATA 52,5F
0053C:  DATA 4C,53
0053E:  DATA 31,20
00540:  DATA 20,20
00542:  DATA 20,09
00544:  DATA 20,00
00546:  DATA 20,53
00548:  DATA 5F,58
0054A:  DATA 5F,44
0054C:  DATA 49,52
0054E:  DATA 45,49
00550:  DATA 54,41
00552:  DATA 20,20
00554:  DATA 20,20
00556:  DATA 09,20
00558:  DATA 00,00
0055A:  DATA 53,5F
0055C:  DATA 58,5F
0055E:  DATA 45,53
00560:  DATA 51,55
00562:  DATA 45,52
00564:  DATA 44,41
00566:  DATA 20,20
00568:  DATA 20,20
0056A:  DATA 20,20
0056C:  DATA 20,09
0056E:  DATA 20,00
00570:  DATA 53,5F
00572:  DATA 59,5F
00574:  DATA 46,52
00576:  DATA 45,4E
00578:  DATA 54,45
0057A:  DATA 20,20
0057C:  DATA 20,20
0057E:  DATA 20,20
00580:  DATA 20,20
00582:  DATA 09,20
00584:  DATA 00,00
00586:  DATA 53,5F
00588:  DATA 59,5F
0058A:  DATA 41,54
0058C:  DATA 52,41
0058E:  DATA 53,20
00590:  DATA 20,20
00592:  DATA 20,20
00594:  DATA 20,20
00596:  DATA 09,20
00598:  DATA 00,00
0059A:  DATA 50,52
0059C:  DATA 4F,54
0059E:  DATA 45,43
005A0:  DATA 41,4F
005A2:  DATA 31,09
005A4:  DATA 20,20
005A6:  DATA 20,20
005A8:  DATA 20,09
005AA:  DATA 20,00
005AC:  DATA 50,52
005AE:  DATA 4F,54
005B0:  DATA 45,43
005B2:  DATA 41,4F
005B4:  DATA 31,20
005B6:  DATA 20,20
005B8:  DATA 20,20
005BA:  DATA 20,09
005BC:  DATA 20,00
005BE:  DATA 53,5F
005C0:  DATA 52,4F
005C2:  DATA 54,41
005C4:  DATA 43,41
005C6:  DATA 4F,5F
005C8:  DATA 4C,53
005CA:  DATA 31,20
005CC:  DATA 20,20
005CE:  DATA 20,20
005D0:  DATA 09,20
005D2:  DATA 00,00
005D4:  DATA 53,5F
005D6:  DATA 46,45
005D8:  DATA 52,52
005DA:  DATA 4F,5F
005DC:  DATA 53,4F
005DE:  DATA 4C,44
005E0:  DATA 41,31
005E2:  DATA 20,20
005E4:  DATA 20,09
005E6:  DATA 20,00
005E8:  DATA 53,5F
005EA:  DATA 5A,5F
005EC:  DATA 54,4F
005EE:  DATA 50,20
005F0:  DATA 20,20
005F2:  DATA 20,20
005F4:  DATA 20,20
005F6:  DATA 20,09
005F8:  DATA 20,00
005FA:  DATA 53,5F
005FC:  DATA 5A,5F
005FE:  DATA 42,4F
00600:  DATA 54,54
00602:  DATA 4F,4D
00604:  DATA 20,20
00606:  DATA 20,20
00608:  DATA 20,20
0060A:  DATA 20,20
0060C:  DATA 09,20
0060E:  DATA 00,00
00610:  DATA 53,5F
00612:  DATA 46,45
00614:  DATA 52,52
00616:  DATA 4F,5F
00618:  DATA 53,4F
0061A:  DATA 4C,44
0061C:  DATA 41,32
0061E:  DATA 20,20
00620:  DATA 09,20
00622:  DATA 00,00
00624:  DATA 53,5F
00626:  DATA 44,45
00628:  DATA 44,4F
0062A:  DATA 5F,4F
0062C:  DATA 55,54
0062E:  DATA 5F,31
00630:  DATA 20,20
00632:  DATA 20,20
00634:  DATA 20,20
00636:  DATA 20,20
00638:  DATA 00,00
0063A:  DATA 53,5F
0063C:  DATA 44,45
0063E:  DATA 44,4F
00640:  DATA 5F,4F
00642:  DATA 55,54
00644:  DATA 5F,32
00646:  DATA 09,20
00648:  DATA 20,20
0064A:  DATA 20,20
0064C:  DATA 00,00
0064E:  DATA 53,5F
00650:  DATA 45,4D
00652:  DATA 50,55
00654:  DATA 52,52
00656:  DATA 41,44
00658:  DATA 4F,52
0065A:  DATA 5F,4F
0065C:  DATA 55,54
0065E:  DATA 5F,4C
00660:  DATA 53,31
00662:  DATA 00,00
00664:  DATA 53,5F
00666:  DATA 45,4D
00668:  DATA 50,55
0066A:  DATA 52,52
0066C:  DATA 41,44
0066E:  DATA 4F,52
00670:  DATA 5F,4F
00672:  DATA 55,54
00674:  DATA 5F,4C
00676:  DATA 53,32
00678:  DATA 00,00
0067A:  DATA 20,53
0067C:  DATA 5F,58
0067E:  DATA 5F,43
00680:  DATA 45,4E
00682:  DATA 54,52
00684:  DATA 4F,20
00686:  DATA 20,20
00688:  DATA 20,20
0068A:  DATA 20,20
0068C:  DATA 09,20
0068E:  DATA 00,00
00690:  DATA 20,53
00692:  DATA 5F,59
00694:  DATA 5F,43
00696:  DATA 45,4E
00698:  DATA 54,52
0069A:  DATA 4F,20
0069C:  DATA 20,20
0069E:  DATA 20,20
006A0:  DATA 20,20
006A2:  DATA 20,20
006A4:  DATA 00,00
006A6:  DATA 20,53
006A8:  DATA 5F,46
006AA:  DATA 49,4F
006AC:  DATA 5F,53
006AE:  DATA 4F,4C
006B0:  DATA 44,41
006B2:  DATA 31,20
006B4:  DATA 20,20
006B6:  DATA 20,20
006B8:  DATA 20,20
006BA:  DATA 00,00
006BC:  DATA 20,53
006BE:  DATA 5F,46
006C0:  DATA 49,4F
006C2:  DATA 5F,53
006C4:  DATA 4F,4C
006C6:  DATA 44,41
006C8:  DATA 32,09
006CA:  DATA 20,20
006CC:  DATA 20,20
006CE:  DATA 20,00
006D0:  DATA 20,53
006D2:  DATA 5F,46
006D4:  DATA 49,4F
006D6:  DATA 5F,53
006D8:  DATA 4F,4C
006DA:  DATA 44,41
006DC:  DATA 33,20
006DE:  DATA 20,20
006E0:  DATA 20,20
006E2:  DATA 20,20
006E4:  DATA 00,00
006E6:  DATA 20,20
006E8:  DATA 44,45
006EA:  DATA 42,55
006EC:  DATA 47,20
006EE:  DATA 53,45
006F0:  DATA 4E,53
006F2:  DATA 4F,52
006F4:  DATA 45,53
006F6:  DATA 0A,0D
006F8:  DATA 00,00
006FA:  DATA 20,20
006FC:  DATA 44,45
006FE:  DATA 42,55
00700:  DATA 47,20
00702:  DATA 53,41
00704:  DATA 49,44
00706:  DATA 41,53
00708:  DATA 0A,0D
0070A:  DATA 00,00
0070C:  DATA 50,4F
0070E:  DATA 53,49
00710:  DATA 43,4F
00712:  DATA 45,53
00714:  DATA 20,4D
00716:  DATA 41,51
00718:  DATA 55,49
0071A:  DATA 4E,41
0071C:  DATA 0A,0D
0071E:  DATA 00,00
00720:  DATA 20,20
00722:  DATA 20,20
00724:  DATA 20,20
00726:  DATA 20,20
00728:  DATA 20,20
0072A:  DATA 20,20
0072C:  DATA 20,20
0072E:  DATA 20,20
00730:  DATA 0A,0D
00732:  DATA 00,00
00734:  DATA 50,4F
00736:  DATA 53,49
00738:  DATA 43,41
0073A:  DATA 4F,20
0073C:  DATA 48,4F
0073E:  DATA 4D,45
00740:  DATA 31,20
00742:  DATA 20,20
00744:  DATA 20,20
00746:  DATA 20,0A
00748:  DATA 0D,00
0074A:  DATA 20,20
0074C:  DATA 20,20
0074E:  DATA 20,20
00750:  DATA 20,20
00752:  DATA 20,20
00754:  DATA 20,20
00756:  DATA 20,20
00758:  DATA 20,20
0075A:  DATA 20,20
0075C:  DATA 20,0A
0075E:  DATA 0D,00
00760:  DATA 50,4F
00762:  DATA 53,49
00764:  DATA 43,41
00766:  DATA 4F,20
00768:  DATA 48,4F
0076A:  DATA 4D,45
0076C:  DATA 32,20
0076E:  DATA 20,20
00770:  DATA 20,20
00772:  DATA 20,0A
00774:  DATA 0D,00
00776:  DATA 20,20
00778:  DATA 20,20
0077A:  DATA 20,20
0077C:  DATA 20,20
0077E:  DATA 20,20
00780:  DATA 20,20
00782:  DATA 20,20
00784:  DATA 20,20
00786:  DATA 20,20
00788:  DATA 20,0A
0078A:  DATA 0D,00
0078C:  DATA 50,4F
0078E:  DATA 53,49
00790:  DATA 43,41
00792:  DATA 4F,20
00794:  DATA 41,4C
00796:  DATA 49,4D
00798:  DATA 45,4E
0079A:  DATA 54,41
0079C:  DATA 44,4F
0079E:  DATA 52,0A
007A0:  DATA 0D,00
007A2:  DATA 20,20
007A4:  DATA 20,20
007A6:  DATA 20,20
007A8:  DATA 20,20
007AA:  DATA 20,20
007AC:  DATA 20,20
007AE:  DATA 20,20
007B0:  DATA 20,20
007B2:  DATA 20,20
007B4:  DATA 20,0A
007B6:  DATA 0D,00
007B8:  DATA 50,4F
007BA:  DATA 53,49
007BC:  DATA 43,41
007BE:  DATA 4F,20
007C0:  DATA 53,4F
007C2:  DATA 4C,44
007C4:  DATA 41,20
007C6:  DATA 20,20
007C8:  DATA 20,20
007CA:  DATA 20,0A
007CC:  DATA 0D,00
007CE:  DATA 20,45
007D0:  DATA 53,54
007D2:  DATA 41,47
007D4:  DATA 49,4F
007D6:  DATA 31,20
007D8:  DATA 20,20
007DA:  DATA 20,20
007DC:  DATA 20,20
007DE:  DATA 20,20
007E0:  DATA 20,0A
007E2:  DATA 0D,00
007E4:  DATA 50,4F
007E6:  DATA 53,49
007E8:  DATA 43,41
007EA:  DATA 4F,20
007EC:  DATA 53,4F
007EE:  DATA 4C,44
007F0:  DATA 41,20
007F2:  DATA 20,20
007F4:  DATA 20,20
007F6:  DATA 20,0A
007F8:  DATA 0D,00
007FA:  DATA 20,45
007FC:  DATA 53,54
007FE:  DATA 41,47
00800:  DATA 49,4F
00802:  DATA 32,20
00804:  DATA 20,20
00806:  DATA 20,20
00808:  DATA 20,20
0080A:  DATA 20,20
0080C:  DATA 20,0A
0080E:  DATA 0D,00
00810:  DATA 50,4F
00812:  DATA 53,49
00814:  DATA 43,41
00816:  DATA 4F,20
00818:  DATA 44,49
0081A:  DATA 53,50
0081C:  DATA 45,4E
0081E:  DATA 53,41
00820:  DATA 44,4F
00822:  DATA 52,0A
00824:  DATA 0D,00
00826:  DATA 20,20
00828:  DATA 20,20
0082A:  DATA 20,20
0082C:  DATA 20,20
0082E:  DATA 20,20
00830:  DATA 20,20
00832:  DATA 20,20
00834:  DATA 20,20
00836:  DATA 20,20
00838:  DATA 20,0A
0083A:  DATA 0D,00
0083C:  DATA 50,4F
0083E:  DATA 53,49
00840:  DATA 43,41
00842:  DATA 4F,20
00844:  DATA 48,4F
00846:  DATA 4D,45
00848:  DATA 20,33
0084A:  DATA 20,20
0084C:  DATA 20,20
0084E:  DATA 20,0A
00850:  DATA 0D,00
00852:  DATA 20,20
00854:  DATA 20,20
00856:  DATA 20,20
00858:  DATA 20,20
0085A:  DATA 20,20
0085C:  DATA 20,20
0085E:  DATA 20,20
00860:  DATA 20,20
00862:  DATA 20,20
00864:  DATA 20,0A
00866:  DATA 0D,00
00868:  DATA 20,20
0086A:  DATA 20,20
0086C:  DATA 20,20
0086E:  DATA 20,20
00870:  DATA 20,53
00872:  DATA 54,4F
00874:  DATA 50,20
00876:  DATA 20,20
00878:  DATA 20,20
0087A:  DATA 20,0A
0087C:  DATA 0D,00
0087E:  DATA 20,20
00880:  DATA 20,20
00882:  DATA 20,20
00884:  DATA 20,20
00886:  DATA 20,20
00888:  DATA 20,20
0088A:  DATA 20,20
0088C:  DATA 20,20
0088E:  DATA 20,20
00890:  DATA 20,0A
00892:  DATA 0D,00
00894:  DATA 31,3A
00896:  DATA 48,4F
00898:  DATA 4D,45
0089A:  DATA 31,20
0089C:  DATA 20,20
0089E:  DATA 35,3A
008A0:  DATA 45,53
008A2:  DATA 54,41
008A4:  DATA 47,32
008A6:  DATA 20,0A
008A8:  DATA 0D,00
008AA:  DATA 32,3A
008AC:  DATA 48,4F
008AE:  DATA 4D,45
008B0:  DATA 32,20
008B2:  DATA 20,20
008B4:  DATA 36,3A
008B6:  DATA 44,49
008B8:  DATA 53,50
008BA:  DATA 2E,20
008BC:  DATA 20,0A
008BE:  DATA 0D,00
008C0:  DATA 33,3A
008C2:  DATA 41,4C
008C4:  DATA 49,4D
008C6:  DATA 45,4E
008C8:  DATA 54,20
008CA:  DATA 37,3A
008CC:  DATA 49,4E
008CE:  DATA 44,45
008D0:  DATA 54,45
008D2:  DATA 52,0A
008D4:  DATA 0D,00
008D6:  DATA 34,3A
008D8:  DATA 45,53
008DA:  DATA 54,41
008DC:  DATA 47,31
008DE:  DATA 20,20
008E0:  DATA 38,3A
008E2:  DATA 53,54
008E4:  DATA 4F,50
008E6:  DATA 20,20
008E8:  DATA 20,0A
008EA:  DATA 0D,00
008EC:  DATA 50,4F
008EE:  DATA 53,49
008F0:  DATA 43,41
008F2:  DATA 4F,20
008F4:  DATA 48,4F
008F6:  DATA 4D,45
008F8:  DATA 31,20
008FA:  DATA 20,20
008FC:  DATA 20,20
008FE:  DATA 20,0A
00900:  DATA 0D,00
00902:  DATA 20,20
00904:  DATA 20,20
00906:  DATA 20,20
00908:  DATA 20,20
0090A:  DATA 20,20
0090C:  DATA 20,20
0090E:  DATA 20,20
00910:  DATA 20,20
00912:  DATA 20,20
00914:  DATA 20,0A
00916:  DATA 0D,00
00918:  DATA 50,4F
0091A:  DATA 53,49
0091C:  DATA 43,41
0091E:  DATA 4F,20
00920:  DATA 48,4F
00922:  DATA 4D,45
00924:  DATA 32,20
00926:  DATA 20,20
00928:  DATA 20,20
0092A:  DATA 20,0A
0092C:  DATA 0D,00
0092E:  DATA 20,20
00930:  DATA 20,20
00932:  DATA 20,20
00934:  DATA 20,20
00936:  DATA 20,20
00938:  DATA 20,20
0093A:  DATA 20,20
0093C:  DATA 20,20
0093E:  DATA 20,20
00940:  DATA 20,0A
00942:  DATA 0D,00
00944:  DATA 50,4F
00946:  DATA 53,49
00948:  DATA 43,41
0094A:  DATA 4F,20
0094C:  DATA 41,4C
0094E:  DATA 49,4D
00950:  DATA 45,4E
00952:  DATA 54,41
00954:  DATA 44,4F
00956:  DATA 52,0A
00958:  DATA 0D,00
0095A:  DATA 20,20
0095C:  DATA 20,20
0095E:  DATA 20,20
00960:  DATA 20,20
00962:  DATA 20,20
00964:  DATA 20,20
00966:  DATA 20,20
00968:  DATA 20,20
0096A:  DATA 20,20
0096C:  DATA 20,0A
0096E:  DATA 0D,00
00970:  DATA 50,4F
00972:  DATA 53,49
00974:  DATA 43,41
00976:  DATA 4F,20
00978:  DATA 53,4F
0097A:  DATA 4C,44
0097C:  DATA 41,20
0097E:  DATA 20,20
00980:  DATA 20,20
00982:  DATA 20,0A
00984:  DATA 0D,00
00986:  DATA 20,45
00988:  DATA 53,54
0098A:  DATA 41,47
0098C:  DATA 49,4F
0098E:  DATA 31,20
00990:  DATA 20,20
00992:  DATA 20,20
00994:  DATA 20,20
00996:  DATA 20,20
00998:  DATA 20,0A
0099A:  DATA 0D,00
0099C:  DATA 50,4F
0099E:  DATA 53,49
009A0:  DATA 43,41
009A2:  DATA 4F,20
009A4:  DATA 53,4F
009A6:  DATA 4C,44
009A8:  DATA 41,20
009AA:  DATA 20,20
009AC:  DATA 20,20
009AE:  DATA 20,0A
009B0:  DATA 0D,00
009B2:  DATA 20,45
009B4:  DATA 53,54
009B6:  DATA 41,47
009B8:  DATA 49,4F
009BA:  DATA 32,20
009BC:  DATA 20,20
009BE:  DATA 20,20
009C0:  DATA 20,20
009C2:  DATA 20,20
009C4:  DATA 20,0A
009C6:  DATA 0D,00
009C8:  DATA 50,4F
009CA:  DATA 53,49
009CC:  DATA 43,41
009CE:  DATA 4F,20
009D0:  DATA 44,49
009D2:  DATA 53,50
009D4:  DATA 45,4E
009D6:  DATA 53,41
009D8:  DATA 44,4F
009DA:  DATA 52,0A
009DC:  DATA 0D,00
009DE:  DATA 20,20
009E0:  DATA 20,20
009E2:  DATA 20,20
009E4:  DATA 20,20
009E6:  DATA 20,20
009E8:  DATA 20,20
009EA:  DATA 20,20
009EC:  DATA 20,20
009EE:  DATA 20,20
009F0:  DATA 20,0A
009F2:  DATA 0D,00
009F4:  DATA 50,4F
009F6:  DATA 53,49
009F8:  DATA 43,41
009FA:  DATA 4F,20
009FC:  DATA 48,4F
009FE:  DATA 4D,45
00A00:  DATA 33,20
00A02:  DATA 20,20
00A04:  DATA 20,20
00A06:  DATA 20,0A
00A08:  DATA 0D,00
00A0A:  DATA 20,20
00A0C:  DATA 20,20
00A0E:  DATA 20,20
00A10:  DATA 20,20
00A12:  DATA 20,20
00A14:  DATA 20,20
00A16:  DATA 20,20
00A18:  DATA 20,20
00A1A:  DATA 20,20
00A1C:  DATA 20,0A
00A1E:  DATA 0D,00
00A20:  DATA 20,20
00A22:  DATA 20,20
00A24:  DATA 20,20
00A26:  DATA 20,20
00A28:  DATA 20,53
00A2A:  DATA 54,4F
00A2C:  DATA 50,20
00A2E:  DATA 20,20
00A30:  DATA 20,20
00A32:  DATA 20,0A
00A34:  DATA 0D,00
00A36:  DATA 20,20
00A38:  DATA 20,20
00A3A:  DATA 20,20
00A3C:  DATA 20,20
00A3E:  DATA 20,20
00A40:  DATA 20,20
00A42:  DATA 20,20
00A44:  DATA 20,20
00A46:  DATA 20,20
00A48:  DATA 20,0A
00A4A:  DATA 0D,00
00A4C:  DATA 31,3A
00A4E:  DATA 48,4F
00A50:  DATA 4D,45
00A52:  DATA 31,20
00A54:  DATA 20,20
00A56:  DATA 35,3A
00A58:  DATA 45,53
00A5A:  DATA 54,41
00A5C:  DATA 47,32
00A5E:  DATA 20,0A
00A60:  DATA 0D,00
00A62:  DATA 32,3A
00A64:  DATA 48,4F
00A66:  DATA 4D,45
00A68:  DATA 32,20
00A6A:  DATA 20,20
00A6C:  DATA 36,3A
00A6E:  DATA 44,49
00A70:  DATA 53,50
00A72:  DATA 2E,20
00A74:  DATA 20,0A
00A76:  DATA 0D,00
00A78:  DATA 33,3A
00A7A:  DATA 41,4C
00A7C:  DATA 49,4D
00A7E:  DATA 45,4E
00A80:  DATA 54,20
00A82:  DATA 37,3A
00A84:  DATA 49,4E
00A86:  DATA 44,45
00A88:  DATA 54,45
00A8A:  DATA 52,0A
00A8C:  DATA 0D,00
00A8E:  DATA 34,3A
00A90:  DATA 45,53
00A92:  DATA 54,41
00A94:  DATA 47,31
00A96:  DATA 20,20
00A98:  DATA 38,3A
00A9A:  DATA 53,54
00A9C:  DATA 4F,50
00A9E:  DATA 20,20
00AA0:  DATA 20,0A
00AA2:  DATA 0D,00
00AA4:  DATA 53,4F
00AA6:  DATA 4C,44
00AA8:  DATA 41,44
00AAA:  DATA 4F,52
00AAC:  DATA 20,41
00AAE:  DATA 55,54
00AB0:  DATA 4F,4D
00AB2:  DATA 41,54
00AB4:  DATA 49,43
00AB6:  DATA 4F,20
00AB8:  DATA 0A,0D
00ABA:  DATA 00,00
00ABC:  DATA 50,52
00ABE:  DATA 4F,47
00AC0:  DATA 3A,20
00AC2:  DATA 20,20
00AC4:  DATA 20,4D
00AC6:  DATA 41,51
00AC8:  DATA 55,49
00ACA:  DATA 4E,41
00ACC:  DATA 3A,20
00ACE:  DATA 20,20
00AD0:  DATA 0A,0D
00AD2:  DATA 00,00
00AD4:  DATA 4D,4F
00AD6:  DATA 44,3A
00AD8:  DATA 20,20
00ADA:  DATA 20,20
00ADC:  DATA 20,20
00ADE:  DATA 20,20
00AE0:  DATA 20,20
00AE2:  DATA 20,20
00AE4:  DATA 20,20
00AE6:  DATA 20,20
00AE8:  DATA 0A,0D
00AEA:  DATA 00,00
00AEC:  DATA 20,20
00AEE:  DATA 20,00
00AF0:  DATA 3C,2D
00AF2:  DATA 2D,00
00AF4:  DATA 4E,45
00AF6:  DATA 57,00
00AF8:  DATA 20,20
00AFA:  DATA 20,20
00AFC:  DATA 20,20
00AFE:  DATA 20,20
00B00:  DATA 00,00
00B02:  DATA 46,31
00B04:  DATA 3A,45
00B06:  DATA 44,49
00B08:  DATA 54,20
00B0A:  DATA 00,00
00B0C:  DATA 45,53
00B0E:  DATA 43,3A
00B10:  DATA 53,41
00B12:  DATA 49,20
00B14:  DATA 00,00
00B16:  DATA 50,4F
00B18:  DATA 4E,54
00B1A:  DATA 4F,3A
00B1C:  DATA 20,20
00B1E:  DATA 20,20
00B20:  DATA 20,20
00B22:  DATA 20,20
00B24:  DATA 20,20
00B26:  DATA 20,20
00B28:  DATA 20,20
00B2A:  DATA 0A,0D
00B2C:  DATA 00,00
00B2E:  DATA 58,3A
00B30:  DATA 30,30
00B32:  DATA 30,30
00B34:  DATA 20,20
00B36:  DATA 20,20
00B38:  DATA 20,20
00B3A:  DATA 20,20
00B3C:  DATA 20,20
00B3E:  DATA 20,20
00B40:  DATA 20,20
00B42:  DATA 0A,0D
00B44:  DATA 00,00
00B46:  DATA 59,3A
00B48:  DATA 30,30
00B4A:  DATA 30,30
00B4C:  DATA 20,20
00B4E:  DATA 20,45
00B50:  DATA 4E,54
00B52:  DATA 45,52
00B54:  DATA 3A,53
00B56:  DATA 41,4C
00B58:  DATA 56,41
00B5A:  DATA 0A,0D
00B5C:  DATA 00,00
00B5E:  DATA 5A,3A
00B60:  DATA 30,30
00B62:  DATA 30,30
00B64:  DATA 20,20
00B66:  DATA 20,45
00B68:  DATA 53,43
00B6A:  DATA 3A,53
00B6C:  DATA 41,49
00B6E:  DATA 20,20
00B70:  DATA 20,20
00B72:  DATA 0A,0D
00B74:  DATA 00,00
00B76:  DATA 20,20
00B78:  DATA 20,20
00B7A:  DATA 20,20
00B7C:  DATA 20,20
00B7E:  DATA 20,45
00B80:  DATA 4E,54
00B82:  DATA 45,52
00B84:  DATA 3A,45
00B86:  DATA 44,49
00B88:  DATA 54,41
00B8A:  DATA 0A,0D
00B8C:  DATA 00,00
00B8E:  DATA 20,20
00B90:  DATA 20,20
00B92:  DATA 20,20
00B94:  DATA 20,20
00B96:  DATA 20,46
00B98:  DATA 32,3A
00B9A:  DATA 43,52
00B9C:  DATA 49,41
00B9E:  DATA 20,20
00BA0:  DATA 20,20
00BA2:  DATA 0A,0D
00BA4:  DATA 00,00
00BA6:  DATA 20,20
00BA8:  DATA 20,20
00BAA:  DATA 20,20
00BAC:  DATA 20,20
00BAE:  DATA 20,46
00BB0:  DATA 33,3A
00BB2:  DATA 44,45
00BB4:  DATA 4C,20
00BB6:  DATA 20,20
00BB8:  DATA 20,20
00BBA:  DATA 0A,0D
00BBC:  DATA 00,00
00BBE:  DATA 20,20
00BC0:  DATA 20,20
00BC2:  DATA 20,20
00BC4:  DATA 20,20
00BC6:  DATA 20,46
00BC8:  DATA 34,3A
00BCA:  DATA 53,4F
00BCC:  DATA 4C,44
00BCE:  DATA 41,20
00BD0:  DATA 50,2E
00BD2:  DATA 0A,0D
00BD4:  DATA 00,00
00BD6:  DATA 54,45
00BD8:  DATA 4D,20
00BDA:  DATA 43,45
00BDC:  DATA 52,54
00BDE:  DATA 45,5A
00BE0:  DATA 41,3F
00BE2:  DATA 00,00
00BE4:  DATA 46,31
00BE6:  DATA 3D,53
00BE8:  DATA 49,4D
00BEA:  DATA 00,00
00BEC:  DATA 46,32
00BEE:  DATA 3D,4E
00BF0:  DATA 41,4F
00BF2:  DATA 00,00
00BF4:  DATA 43,4F
00BF6:  DATA 4F,52
00BF8:  DATA 44,2E
00BFA:  DATA 20,46
00BFC:  DATA 4F,52
00BFE:  DATA 41,4D
00C00:  DATA 20,53
00C02:  DATA 41,4C
00C04:  DATA 56,41
00C06:  DATA 53,00
00C08:  DATA 50,4F
00C0A:  DATA 53,49
00C0C:  DATA 43,49
00C0E:  DATA 4F,4E
00C10:  DATA 45,20
00C12:  DATA 41,20
00C14:  DATA 50,4C
00C16:  DATA 41,43
00C18:  DATA 41,20
00C1A:  DATA 20,20
00C1C:  DATA 0A,0D
00C1E:  DATA 00,00
00C20:  DATA 45,20
00C22:  DATA 50,52
00C24:  DATA 45,53
00C26:  DATA 53,20
00C28:  DATA 45,4E
00C2A:  DATA 54,45
00C2C:  DATA 52,20
00C2E:  DATA 20,20
00C30:  DATA 20,20
00C32:  DATA 20,20
00C34:  DATA 0A,0D
00C36:  DATA 00,00
00C38:  DATA 50,41
00C3A:  DATA 52,41
00C3C:  DATA 20,41
00C3E:  DATA 4C,49
00C40:  DATA 4D,45
00C42:  DATA 4E,54
00C44:  DATA 41,52
00C46:  DATA 20,20
00C48:  DATA 20,20
00C4A:  DATA 20,20
00C4C:  DATA 0A,0D
00C4E:  DATA 00,00
00C50:  DATA 20,20
00C52:  DATA 20,20
00C54:  DATA 20,20
00C56:  DATA 20,20
00C58:  DATA 20,20
00C5A:  DATA 20,20
00C5C:  DATA 20,20
00C5E:  DATA 20,20
00C60:  DATA 20,20
00C62:  DATA 20,20
00C64:  DATA 0A,0D
00C66:  DATA 00,00
00C68:  DATA 45,53
00C6A:  DATA 50,45
00C6C:  DATA 52,41
00C6E:  DATA 4E,44
00C70:  DATA 4F,20
00C72:  DATA 20,4D
00C74:  DATA 41,51
00C76:  DATA 55,49
00C78:  DATA 4E,41
00C7A:  DATA 31,0A
00C7C:  DATA 0D,00
00C7E:  DATA 49,52
00C80:  DATA 20,50
00C82:  DATA 41,52
00C84:  DATA 41,20
00C86:  DATA 48,4F
00C88:  DATA 4D,45
00C8A:  DATA 31,20
00C8C:  DATA 20,20
00C8E:  DATA 20,20
00C90:  DATA 20,00
00C92:  DATA 50,4F
00C94:  DATA 53,49
00C96:  DATA 43,49
00C98:  DATA 4F,4E
00C9A:  DATA 45,20
00C9C:  DATA 41,20
00C9E:  DATA 50,4C
00CA0:  DATA 41,43
00CA2:  DATA 41,20
00CA4:  DATA 20,20
00CA6:  DATA 0A,0D
00CA8:  DATA 00,00
00CAA:  DATA 45,20
00CAC:  DATA 50,52
00CAE:  DATA 45,53
00CB0:  DATA 53,20
00CB2:  DATA 45,4E
00CB4:  DATA 54,45
00CB6:  DATA 52,20
00CB8:  DATA 20,20
00CBA:  DATA 20,20
00CBC:  DATA 20,20
00CBE:  DATA 0A,0D
00CC0:  DATA 00,00
00CC2:  DATA 50,41
00CC4:  DATA 52,41
00CC6:  DATA 20,41
00CC8:  DATA 4C,49
00CCA:  DATA 4D,45
00CCC:  DATA 4E,54
00CCE:  DATA 41,52
00CD0:  DATA 20,20
00CD2:  DATA 20,20
00CD4:  DATA 20,20
00CD6:  DATA 0A,0D
00CD8:  DATA 00,00
00CDA:  DATA 20,20
00CDC:  DATA 20,20
00CDE:  DATA 20,20
00CE0:  DATA 20,20
00CE2:  DATA 20,20
00CE4:  DATA 20,20
00CE6:  DATA 20,20
00CE8:  DATA 20,20
00CEA:  DATA 20,20
00CEC:  DATA 20,20
00CEE:  DATA 0A,0D
00CF0:  DATA 00,00
00CF2:  DATA 3C,2D
00CF4:  DATA 2D,00
00CF6:  DATA 3C,2D
00CF8:  DATA 2D,00
00CFA:  DATA 20,20
00CFC:  DATA 20,00
00CFE:  DATA 3C,2D
00D00:  DATA 2D,00
00D02:  DATA 20,20
00D04:  DATA 20,00
00D06:  DATA 3C,2D
00D08:  DATA 2D,00
00D0A:  DATA 49,4E
00D0C:  DATA 44,4F
00D0E:  DATA 20,50
00D10:  DATA 41,52
00D12:  DATA 41,20
00D14:  DATA 50,4F
00D16:  DATA 53,49
00D18:  DATA 43,41
00D1A:  DATA 4F,20
00D1C:  DATA 20,20
00D1E:  DATA 0A,0D
00D20:  DATA 00,00
00D22:  DATA 44,45
00D24:  DATA 20,41
00D26:  DATA 4C,49
00D28:  DATA 4D,45
00D2A:  DATA 4E,54
00D2C:  DATA 41,43
00D2E:  DATA 41,4F
00D30:  DATA 20,20
00D32:  DATA 20,20
00D34:  DATA 20,20
00D36:  DATA 0A,0D
00D38:  DATA 00,00
00D3A:  DATA 49,4E
00D3C:  DATA 44,4F
00D3E:  DATA 20,50
00D40:  DATA 41,52
00D42:  DATA 41,20
00D44:  DATA 50,4F
00D46:  DATA 53,49
00D48:  DATA 43,41
00D4A:  DATA 4F,20
00D4C:  DATA 20,20
00D4E:  DATA 0A,0D
00D50:  DATA 00,00
00D52:  DATA 20,20
00D54:  DATA 20,20
00D56:  DATA 20,20
00D58:  DATA 48,4F
00D5A:  DATA 4D,45
00D5C:  DATA 31,20
00D5E:  DATA 20,20
00D60:  DATA 20,20
00D62:  DATA 20,20
00D64:  DATA 20,20
00D66:  DATA 0A,0D
00D68:  DATA 00,00
00D6A:  DATA 45,49
00D6C:  DATA 58,4F
00D6E:  DATA 20,58
00D70:  DATA 2C,59
00D72:  DATA 20,20
00D74:  DATA 20,20
00D76:  DATA 20,20
00D78:  DATA 20,20
00D7A:  DATA 20,20
00D7C:  DATA 20,20
00D7E:  DATA 0A,0D
00D80:  DATA 00,00
00D82:  DATA 45,49
00D84:  DATA 58,4F
00D86:  DATA 20,20
00D88:  DATA 5A,20
00D8A:  DATA 20,20
00D8C:  DATA 20,20
00D8E:  DATA 20,20
00D90:  DATA 20,20
00D92:  DATA 20,20
00D94:  DATA 20,20
00D96:  DATA 0A,0D
00D98:  DATA 00,00
00D9A:  DATA 45,49
00D9C:  DATA 58,4F
00D9E:  DATA 20,52
00DA0:  DATA 4F,54
00DA2:  DATA 41,43
00DA4:  DATA 49,4F
00DA6:  DATA 4E,41
00DA8:  DATA 4C,20
00DAA:  DATA 20,20
00DAC:  DATA 20,20
00DAE:  DATA 0A,0D
00DB0:  DATA 00,00
00DB2:  DATA 45,4D
00DB4:  DATA 50,55
00DB6:  DATA 52,52
00DB8:  DATA 41,44
00DBA:  DATA 4F,52
00DBC:  DATA 20,45
00DBE:  DATA 4E,54
00DC0:  DATA 2E,20
00DC2:  DATA 20,20
00DC4:  DATA 20,20
00DC6:  DATA 0A,0D
00DC8:  DATA 00,00
00DCA:  DATA 44,45
00DCC:  DATA 44,4F
00DCE:  DATA 53,20
00DD0:  DATA 45,4E
00DD2:  DATA 54,52
00DD4:  DATA 41,44
00DD6:  DATA 41,20
00DD8:  DATA 20,20
00DDA:  DATA 20,20
00DDC:  DATA 20,20
00DDE:  DATA 0A,0D
00DE0:  DATA 00,00
00DE2:  DATA 50,52
00DE4:  DATA 45,53
00DE6:  DATA 53,4F
00DE8:  DATA 52,20
00DEA:  DATA 20,20
00DEC:  DATA 20,20
00DEE:  DATA 20,20
00DF0:  DATA 20,20
00DF2:  DATA 20,20
00DF4:  DATA 20,20
00DF6:  DATA 0A,0D
00DF8:  DATA 00,00
00DFA:  DATA 45,4D
00DFC:  DATA 50,55
00DFE:  DATA 52,52
00E00:  DATA 41,44
00E02:  DATA 4F,52
00E04:  DATA 20,53
00E06:  DATA 41,49
00E08:  DATA 44,41
00E0A:  DATA 20,20
00E0C:  DATA 20,20
00E0E:  DATA 0A,0D
00E10:  DATA 00,00
00E12:  DATA 44,45
00E14:  DATA 44,4F
00E16:  DATA 53,20
00E18:  DATA 53,41
00E1A:  DATA 49,44
00E1C:  DATA 41,20
00E1E:  DATA 20,20
00E20:  DATA 20,20
00E22:  DATA 20,20
00E24:  DATA 20,20
00E26:  DATA 0A,0D
00E28:  DATA 00,00
00E2A:  DATA 4C,49
00E2C:  DATA 4D,50
00E2E:  DATA 41,44
00E30:  DATA 4F,52
00E32:  DATA 20,20
00E34:  DATA 20,20
00E36:  DATA 20,20
00E38:  DATA 20,20
00E3A:  DATA 20,20
00E3C:  DATA 20,20
00E3E:  DATA 0A,0D
00E40:  DATA 00,00
00E42:  DATA 41,4C
00E44:  DATA 49,4D
00E46:  DATA 45,4E
00E48:  DATA 54,2E
00E4A:  DATA 20,53
00E4C:  DATA 4F,4C
00E4E:  DATA 44,41
00E50:  DATA 20,20
00E52:  DATA 20,20
00E54:  DATA 20,20
00E56:  DATA 0A,0D
00E58:  DATA 00,00
00E5A:  DATA 46,45
00E5C:  DATA 52,52
00E5E:  DATA 4F,20
00E60:  DATA 44,45
00E62:  DATA 20,53
00E64:  DATA 4F,4C
00E66:  DATA 44,41
00E68:  DATA 20,31
00E6A:  DATA 20,20
00E6C:  DATA 20,20
00E6E:  DATA 0A,0D
00E70:  DATA 00,00
00E72:  DATA 46,45
00E74:  DATA 52,52
00E76:  DATA 4F,20
00E78:  DATA 44,45
00E7A:  DATA 20,53
00E7C:  DATA 4F,4C
00E7E:  DATA 44,41
00E80:  DATA 20,32
00E82:  DATA 20,20
00E84:  DATA 20,20
00E86:  DATA 0A,0D
00E88:  DATA 00,00
00E8A:  DATA 44,45
00E8C:  DATA 42,55
00E8E:  DATA 47,20
00E90:  DATA 20,53
00E92:  DATA 45,4E
00E94:  DATA 53,4F
00E96:  DATA 52,45
00E98:  DATA 53,20
00E9A:  DATA 20,20
00E9C:  DATA 20,20
00E9E:  DATA 0A,0D
00EA0:  DATA 00,00
00EA2:  DATA 44,45
00EA4:  DATA 42,55
00EA6:  DATA 47,20
00EA8:  DATA 20,53
00EAA:  DATA 41,49
00EAC:  DATA 44,41
00EAE:  DATA 53,20
00EB0:  DATA 20,20
00EB2:  DATA 20,20
00EB4:  DATA 20,20
00EB6:  DATA 0A,0D
00EB8:  DATA 00,00
00EBA:  DATA 53,54
00EBC:  DATA 41,54
00EBE:  DATA 55,53
00EC0:  DATA 20,50
00EC2:  DATA 4F,53
00EC4:  DATA 49,43
00EC6:  DATA 4F,45
00EC8:  DATA 53,20
00ECA:  DATA 20,20
00ECC:  DATA 20,20
00ECE:  DATA 0A,0D
00ED0:  DATA 00,00
00ED2:  DATA 45,4E
00ED4:  DATA 56,49
00ED6:  DATA 41,20
00ED8:  DATA 50,4F
00EDA:  DATA 53,49
00EDC:  DATA 43,4F
00EDE:  DATA 45,53
00EE0:  DATA 20,20
00EE2:  DATA 20,20
00EE4:  DATA 20,20
00EE6:  DATA 0A,0D
00EE8:  DATA 00,00
00EEA:  DATA 44,45
00EEC:  DATA 42,55
00EEE:  DATA 47,20
00EF0:  DATA 53,4F
00EF2:  DATA 4C,44
00EF4:  DATA 41,47
00EF6:  DATA 45,4D
00EF8:  DATA 20,20
00EFA:  DATA 20,20
00EFC:  DATA 20,20
00EFE:  DATA 0A,0D
00F00:  DATA 00,00
00F02:  DATA 44,45
00F04:  DATA 42,55
00F06:  DATA 47,20
00F08:  DATA 45,53
00F0A:  DATA 54,45
00F0C:  DATA 49,52
00F0E:  DATA 41,20
00F10:  DATA 20,20
00F12:  DATA 20,20
00F14:  DATA 20,20
00F16:  DATA 0A,0D
00F18:  DATA 00,00
00F1A:  DATA 3C,2D
00F1C:  DATA 2D,00
00F1E:  DATA 3C,2D
00F20:  DATA 2D,00
00F22:  DATA 20,20
00F24:  DATA 20,00
00F26:  DATA 3C,2D
00F28:  DATA 2D,00
00F2A:  DATA 20,20
00F2C:  DATA 20,00
00F2E:  DATA 3C,2D
00F30:  DATA 2D,00
00F32:  DATA 46,31
00F34:  DATA 3A,45
00F36:  DATA 44,49
00F38:  DATA 54,41
00F3A:  DATA 20,50
00F3C:  DATA 4F,4E
00F3E:  DATA 54,4F
00F40:  DATA 20,20
00F42:  DATA 20,20
00F44:  DATA 20,20
00F46:  DATA 0A,0D
00F48:  DATA 00,00
00F4A:  DATA 46,32
00F4C:  DATA 3A,4D
00F4E:  DATA 41,4E
00F50:  DATA 55,54
00F52:  DATA 45,4E
00F54:  DATA 43,41
00F56:  DATA 4F,20
00F58:  DATA 20,20
00F5A:  DATA 20,20
00F5C:  DATA 20,20
00F5E:  DATA 0A,0D
00F60:  DATA 00,00
00F62:  DATA 20,20
00F64:  DATA 20,20
00F66:  DATA 20,20
00F68:  DATA 20,20
00F6A:  DATA 20,20
00F6C:  DATA 20,20
00F6E:  DATA 20,20
00F70:  DATA 20,20
00F72:  DATA 20,20
00F74:  DATA 20,20
00F76:  DATA 0A,0D
00F78:  DATA 00,00
00F7A:  DATA 20,20
00F7C:  DATA 20,20
00F7E:  DATA 20,20
00F80:  DATA 20,20
00F82:  DATA 20,20
00F84:  DATA 20,20
00F86:  DATA 20,20
00F88:  DATA 20,20
00F8A:  DATA 20,20
00F8C:  DATA 20,00
00F8E:  DATA 4D,4F
00F90:  DATA 44,45
00F92:  DATA 4C,4F
00F94:  DATA 31,20
00F96:  DATA 20,00
00F98:  DATA 4D,4F
00F9A:  DATA 44,45
00F9C:  DATA 4C,4F
00F9E:  DATA 32,20
00FA0:  DATA 20,00
00FA2:  DATA 4D,4F
00FA4:  DATA 44,45
00FA6:  DATA 4C,4F
00FA8:  DATA 33,20
00FAA:  DATA 20,00
00FAC:  DATA 4D,4F
00FAE:  DATA 44,45
00FB0:  DATA 4C,4F
00FB2:  DATA 34,20
00FB4:  DATA 20,00
00FB6:  DATA 4D,4F
00FB8:  DATA 44,45
00FBA:  DATA 4C,4F
00FBC:  DATA 35,20
00FBE:  DATA 20,00
00FC0:  DATA 4D,4F
00FC2:  DATA 44,45
00FC4:  DATA 4C,4F
00FC6:  DATA 36,20
00FC8:  DATA 20,00
00FCA:  DATA 4D,4F
00FCC:  DATA 44,45
00FCE:  DATA 4C,4F
00FD0:  DATA 37,20
00FD2:  DATA 20,00
00FD4:  DATA 4D,4F
00FD6:  DATA 44,45
00FD8:  DATA 4C,4F
00FDA:  DATA 38,20
00FDC:  DATA 20,00
00FDE:  DATA 4D,4F
00FE0:  DATA 44,45
00FE2:  DATA 4C,4F
00FE4:  DATA 39,20
00FE6:  DATA 20,00
00FE8:  DATA 4D,4F
00FEA:  DATA 44,45
00FEC:  DATA 4C,4F
00FEE:  DATA 31,30
00FF0:  DATA 20,00
00FF2:  DATA 4D,4F
00FF4:  DATA 44,45
00FF6:  DATA 4C,4F
00FF8:  DATA 31,31
00FFA:  DATA 20,00
00FFC:  DATA 4D,4F
00FFE:  DATA 44,45
01000:  DATA 4C,4F
01002:  DATA 31,32
01004:  DATA 00,00
01006:  DATA 4D,4F
01008:  DATA 44,45
0100A:  DATA 4C,4F
0100C:  DATA 31,33
0100E:  DATA 00,00
01010:  DATA 4D,4F
01012:  DATA 44,45
01014:  DATA 4C,4F
01016:  DATA 31,34
01018:  DATA 00,00
0101A:  DATA 4D,4F
0101C:  DATA 44,45
0101E:  DATA 4C,4F
01020:  DATA 31,35
01022:  DATA 00,00
01024:  DATA 50,4C
01026:  DATA 41,43
01028:  DATA 41,31
0102A:  DATA 20,00
0102C:  DATA 50,4C
0102E:  DATA 41,43
01030:  DATA 41,32
01032:  DATA 20,00
01034:  DATA 50,4C
01036:  DATA 41,43
01038:  DATA 41,33
0103A:  DATA 20,00
0103C:  DATA 50,4C
0103E:  DATA 41,43
01040:  DATA 41,34
01042:  DATA 20,00
01044:  DATA 50,4C
01046:  DATA 41,43
01048:  DATA 41,35
0104A:  DATA 20,00
0104C:  DATA 4D,4F
0104E:  DATA 56,49
01050:  DATA 4D,45
01052:  DATA 4E,54
01054:  DATA 41,4E
01056:  DATA 44,4F
01058:  DATA 20,50
0105A:  DATA 4F,53
0105C:  DATA 49,43
0105E:  DATA 41,4F
01060:  DATA 0A,0D
01062:  DATA 00,00
01064:  DATA 41,4C
01066:  DATA 49,4D
01068:  DATA 45,4E
0106A:  DATA 54,41
0106C:  DATA 43,41
0106E:  DATA 4F,20
01070:  DATA 50,4C
01072:  DATA 41,43
01074:  DATA 41,20
01076:  DATA 20,20
01078:  DATA 00,00
0107A:  DATA 4D,4F
0107C:  DATA 56,49
0107E:  DATA 4D,45
01080:  DATA 4E,54
01082:  DATA 41,4E
01084:  DATA 44,4F
01086:  DATA 20,50
01088:  DATA 4F,53
0108A:  DATA 49,43
0108C:  DATA 41,4F
0108E:  DATA 0A,0D
01090:  DATA 00,00
01092:  DATA 41,4C
01094:  DATA 49,4D
01096:  DATA 45,4E
01098:  DATA 54,41
0109A:  DATA 43,41
0109C:  DATA 4F,20
0109E:  DATA 50,4C
010A0:  DATA 41,43
010A2:  DATA 41,20
010A4:  DATA 20,20
010A6:  DATA 00,00
010A8:  DATA 4D,4F
010AA:  DATA 56,49
010AC:  DATA 4D,45
010AE:  DATA 4E,54
010B0:  DATA 41,4E
010B2:  DATA 44,4F
010B4:  DATA 20,50
010B6:  DATA 4F,53
010B8:  DATA 49,43
010BA:  DATA 41,4F
010BC:  DATA 0A,0D
010BE:  DATA 00,00
010C0:  DATA 20,20
010C2:  DATA 20,20
010C4:  DATA 20,44
010C6:  DATA 45,20
010C8:  DATA 53,4F
010CA:  DATA 4C,44
010CC:  DATA 41,47
010CE:  DATA 45,4D
010D0:  DATA 20,20
010D2:  DATA 20,20
010D4:  DATA 00,00
010D6:  DATA 50,3A
010D8:  DATA 20,20
010DA:  DATA 20,20
010DC:  DATA 20,20
010DE:  DATA 20,20
010E0:  DATA 20,20
010E2:  DATA 20,20
010E4:  DATA 20,20
010E6:  DATA 20,20
010E8:  DATA 20,20
010EA:  DATA 0A,0D
010EC:  DATA 00,00
010EE:  DATA 20,20
010F0:  DATA 20,20
010F2:  DATA 20,20
010F4:  DATA 20,20
010F6:  DATA 20,20
010F8:  DATA 20,20
010FA:  DATA 20,20
010FC:  DATA 20,20
010FE:  DATA 20,20
01100:  DATA 20,20
01102:  DATA 0A,0D
01104:  DATA 00,00
01106:  DATA 20,20
01108:  DATA 20,20
0110A:  DATA 20,53
0110C:  DATA 4F,4C
0110E:  DATA 44,41
01110:  DATA 4E,44
01112:  DATA 4F,20
01114:  DATA 20,20
01116:  DATA 20,20
01118:  DATA 20,20
0111A:  DATA 0A,0D
0111C:  DATA 00,00
0111E:  DATA 20,20
01120:  DATA 20,20
01122:  DATA 20,45
01124:  DATA 53,54
01126:  DATA 41,47
01128:  DATA 49,4F
0112A:  DATA 32,20
0112C:  DATA 20,20
0112E:  DATA 20,20
01130:  DATA 20,20
01132:  DATA 00,00
01134:  DATA 50,3A
01136:  DATA 20,20
01138:  DATA 20,20
0113A:  DATA 20,20
0113C:  DATA 20,20
0113E:  DATA 20,20
01140:  DATA 20,20
01142:  DATA 20,20
01144:  DATA 20,20
01146:  DATA 20,20
01148:  DATA 0A,0D
0114A:  DATA 00,00
0114C:  DATA 20,20
0114E:  DATA 20,20
01150:  DATA 20,20
01152:  DATA 20,20
01154:  DATA 20,20
01156:  DATA 20,20
01158:  DATA 20,20
0115A:  DATA 20,20
0115C:  DATA 20,20
0115E:  DATA 20,20
01160:  DATA 0A,0D
01162:  DATA 00,00
01164:  DATA 20,20
01166:  DATA 20,20
01168:  DATA 20,53
0116A:  DATA 4F,4C
0116C:  DATA 44,41
0116E:  DATA 4E,44
01170:  DATA 4F,20
01172:  DATA 20,20
01174:  DATA 20,20
01176:  DATA 20,20
01178:  DATA 0A,0D
0117A:  DATA 00,00
0117C:  DATA 20,20
0117E:  DATA 20,20
01180:  DATA 20,45
01182:  DATA 53,54
01184:  DATA 41,47
01186:  DATA 49,4F
01188:  DATA 31,20
0118A:  DATA 20,20
0118C:  DATA 20,20
0118E:  DATA 20,20
01190:  DATA 00,00
01192:  DATA 20,20
01194:  DATA 20,20
01196:  DATA 20,20
01198:  DATA 20,20
0119A:  DATA 20,20
0119C:  DATA 20,20
0119E:  DATA 20,20
011A0:  DATA 20,20
011A2:  DATA 20,20
011A4:  DATA 20,20
011A6:  DATA 0A,0D
011A8:  DATA 00,00
011AA:  DATA 20,20
011AC:  DATA 20,20
011AE:  DATA 20,20
011B0:  DATA 20,20
011B2:  DATA 20,20
011B4:  DATA 20,20
011B6:  DATA 20,20
011B8:  DATA 20,20
011BA:  DATA 20,20
011BC:  DATA 20,20
011BE:  DATA 0A,0D
011C0:  DATA 00,00
011C2:  DATA 4D,4F
011C4:  DATA 56,49
011C6:  DATA 4D,45
011C8:  DATA 4E,54
011CA:  DATA 41,4E
011CC:  DATA 44,4F
011CE:  DATA 20,50
011D0:  DATA 4F,53
011D2:  DATA 49,43
011D4:  DATA 41,4F
011D6:  DATA 0A,0D
011D8:  DATA 00,00
011DA:  DATA 20,20
011DC:  DATA 20,20
011DE:  DATA 20,20
011E0:  DATA 20,48
011E2:  DATA 4F,4D
011E4:  DATA 45,32
011E6:  DATA 20,20
011E8:  DATA 20,20
011EA:  DATA 20,20
011EC:  DATA 20,00
011EE:  DATA 4D,4F
011F0:  DATA 56,49
011F2:  DATA 4D,45
011F4:  DATA 4E,54
011F6:  DATA 41,4E
011F8:  DATA 44,4F
011FA:  DATA 20,50
011FC:  DATA 4F,53
011FE:  DATA 49,43
01200:  DATA 41,4F
01202:  DATA 0A,0D
01204:  DATA 00,00
01206:  DATA 44,49
01208:  DATA 53,50
0120A:  DATA 45,4E
0120C:  DATA 53,41
0120E:  DATA 44,4F
01210:  DATA 52,20
01212:  DATA 50,4C
01214:  DATA 41,43
01216:  DATA 41,20
01218:  DATA 20,20
0121A:  DATA 00,00
0121C:  DATA 4D,4F
0121E:  DATA 56,49
01220:  DATA 4D,45
01222:  DATA 4E,54
01224:  DATA 41,4E
01226:  DATA 44,4F
01228:  DATA 20,50
0122A:  DATA 4F,53
0122C:  DATA 49,43
0122E:  DATA 41,4F
01230:  DATA 0A,0D
01232:  DATA 00,00
01234:  DATA 20,20
01236:  DATA 20,20
01238:  DATA 20,20
0123A:  DATA 20,48
0123C:  DATA 4F,4D
0123E:  DATA 45,31
01240:  DATA 20,20
01242:  DATA 20,20
01244:  DATA 20,20
01246:  DATA 20,00
01248:  DATA 41,43
0124A:  DATA 49,4F
0124C:  DATA 4E,41
0124E:  DATA 4E,44
01250:  DATA 4F,20
01252:  DATA 44,45
01254:  DATA 44,4F
01256:  DATA 53,20
01258:  DATA 20,20
0125A:  DATA 20,20
0125C:  DATA 0A,0D
0125E:  DATA 00,00
01260:  DATA 20,20
01262:  DATA 44,45
01264:  DATA 20,45
01266:  DATA 4E,54
01268:  DATA 52,41
0126A:  DATA 44,41
0126C:  DATA 20,20
0126E:  DATA 20,20
01270:  DATA 20,20
01272:  DATA 20,20
01274:  DATA 00,00
01276:  DATA 20,20
01278:  DATA 20,20
0127A:  DATA 41,43
0127C:  DATA 49,4F
0127E:  DATA 4E,41
01280:  DATA 4E,44
01282:  DATA 4F,20
01284:  DATA 20,20
01286:  DATA 20,20
01288:  DATA 20,20
0128A:  DATA 0A,0D
0128C:  DATA 00,00
0128E:  DATA 41,4C
01290:  DATA 49,4D
01292:  DATA 45,4E
01294:  DATA 54,41
01296:  DATA 44,4F
01298:  DATA 52,20
0129A:  DATA 50,4C
0129C:  DATA 41,43
0129E:  DATA 41,20
012A0:  DATA 20,20
012A2:  DATA 00,00
012A4:  DATA 41,43
012A6:  DATA 49,4F
012A8:  DATA 4E,41
012AA:  DATA 4E,44
012AC:  DATA 4F,20
012AE:  DATA 50,52
012B0:  DATA 45,53
012B2:  DATA 53,4F
012B4:  DATA 52,20
012B6:  DATA 20,20
012B8:  DATA 0A,0D
012BA:  DATA 00,00
012BC:  DATA 20,20
012BE:  DATA 20,20
012C0:  DATA 20,20
012C2:  DATA 20,20
012C4:  DATA 20,20
012C6:  DATA 20,20
012C8:  DATA 20,20
012CA:  DATA 20,20
012CC:  DATA 20,20
012CE:  DATA 20,20
012D0:  DATA 00,00
012D2:  DATA 44,45
012D4:  DATA 53,41
012D6:  DATA 43,49
012D8:  DATA 4F,4E
012DA:  DATA 2E,20
012DC:  DATA 50,52
012DE:  DATA 45,53
012E0:  DATA 53,4F
012E2:  DATA 52,20
012E4:  DATA 20,0A
012E6:  DATA 0D,00
012E8:  DATA 20,20
012EA:  DATA 20,20
012EC:  DATA 20,20
012EE:  DATA 20,20
012F0:  DATA 20,20
012F2:  DATA 20,20
012F4:  DATA 20,20
012F6:  DATA 20,20
012F8:  DATA 20,20
012FA:  DATA 20,20
012FC:  DATA 00,00
012FE:  DATA 41,43
01300:  DATA 49,4F
01302:  DATA 4E,41
01304:  DATA 4E,44
01306:  DATA 4F,20
01308:  DATA 44,45
0130A:  DATA 44,4F
0130C:  DATA 53,20
0130E:  DATA 20,20
01310:  DATA 20,20
01312:  DATA 0A,0D
01314:  DATA 00,00
01316:  DATA 20,20
01318:  DATA 20,20
0131A:  DATA 20,53
0131C:  DATA 41,49
0131E:  DATA 44,41
01320:  DATA 20,20
01322:  DATA 20,20
01324:  DATA 20,20
01326:  DATA 20,20
01328:  DATA 20,20
0132A:  DATA 00,00
0132C:  DATA 44,45
0132E:  DATA 53,41
01330:  DATA 43,49
01332:  DATA 4F,4E
01334:  DATA 41,4E
01336:  DATA 44,4F
01338:  DATA 20,44
0133A:  DATA 45,44
0133C:  DATA 4F,53
0133E:  DATA 20,0A
01340:  DATA 0D,00
01342:  DATA 20,20
01344:  DATA 20,20
01346:  DATA 20,53
01348:  DATA 41,49
0134A:  DATA 44,41
0134C:  DATA 20,20
0134E:  DATA 20,20
01350:  DATA 20,20
01352:  DATA 20,20
01354:  DATA 20,00
01356:  DATA 20,20
01358:  DATA 20,41
0135A:  DATA 43,49
0135C:  DATA 4F,4E
0135E:  DATA 41,4E
01360:  DATA 44,4F
01362:  DATA 20,20
01364:  DATA 20,20
01366:  DATA 20,20
01368:  DATA 20,20
0136A:  DATA 0A,0D
0136C:  DATA 00,00
0136E:  DATA 20,44
01370:  DATA 49,53
01372:  DATA 50,45
01374:  DATA 4E,53
01376:  DATA 41,44
01378:  DATA 4F,52
0137A:  DATA 20,50
0137C:  DATA 4C,41
0137E:  DATA 43,41
01380:  DATA 20,20
01382:  DATA 00,00
01384:  DATA 45,53
01386:  DATA 50,45
01388:  DATA 52,41
0138A:  DATA 4E,44
0138C:  DATA 4F,20
0138E:  DATA 4D,41
01390:  DATA 51,55
01392:  DATA 49,4E
01394:  DATA 41,20
01396:  DATA 32,0A
01398:  DATA 0D,00
0139A:  DATA 53,41
0139C:  DATA 49,52
0139E:  DATA 20,45
013A0:  DATA 53,54
013A2:  DATA 41,47
013A4:  DATA 49,4F
013A6:  DATA 31,20
013A8:  DATA 20,20
013AA:  DATA 20,20
013AC:  DATA 20,00
013AE:  DATA 45,53
013B0:  DATA 50,45
013B2:  DATA 52,41
013B4:  DATA 4E,44
013B6:  DATA 4F,20
013B8:  DATA 4D,41
013BA:  DATA 51,55
013BC:  DATA 49,4E
013BE:  DATA 41,20
013C0:  DATA 32,0A
013C2:  DATA 0D,00
013C4:  DATA 53,41
013C6:  DATA 49,52
013C8:  DATA 20,44
013CA:  DATA 49,53
013CC:  DATA 50,45
013CE:  DATA 4E,53
013D0:  DATA 41,44
013D2:  DATA 4F,52
013D4:  DATA 20,20
013D6:  DATA 20,00
013D8:  DATA 45,53
013DA:  DATA 50,45
013DC:  DATA 52,41
013DE:  DATA 4E,44
013E0:  DATA 4F,20
013E2:  DATA 4D,41
013E4:  DATA 51,55
013E6:  DATA 49,4E
013E8:  DATA 41,20
013EA:  DATA 32,0A
013EC:  DATA 0D,00
013EE:  DATA 53,41
013F0:  DATA 49,52
013F2:  DATA 20,44
013F4:  DATA 49,53
013F6:  DATA 50,45
013F8:  DATA 4E,53
013FA:  DATA 41,44
013FC:  DATA 4F,52
013FE:  DATA 20,20
01400:  DATA 20,00
01402:  DATA 45,53
01404:  DATA 50,45
01406:  DATA 52,41
01408:  DATA 4E,44
0140A:  DATA 4F,20
0140C:  DATA 4D,41
0140E:  DATA 51,55
01410:  DATA 49,4E
01412:  DATA 41,20
01414:  DATA 32,0A
01416:  DATA 0D,00
01418:  DATA 53,41
0141A:  DATA 49,52
0141C:  DATA 20,45
0141E:  DATA 53,54
01420:  DATA 41,47
01422:  DATA 49,4F
01424:  DATA 20,31
01426:  DATA 20,20
01428:  DATA 20,20
0142A:  DATA 00,00
0142C:  DATA 45,53
0142E:  DATA 50,45
01430:  DATA 52,41
01432:  DATA 4E,44
01434:  DATA 4F,20
01436:  DATA 4D,41
01438:  DATA 51,55
0143A:  DATA 49,4E
0143C:  DATA 41,20
0143E:  DATA 32,0A
01440:  DATA 0D,00
01442:  DATA 53,41
01444:  DATA 49,52
01446:  DATA 20,41
01448:  DATA 4C,49
0144A:  DATA 4D,45
0144C:  DATA 4E,54
0144E:  DATA 41,44
01450:  DATA 4F,52
01452:  DATA 20,20
01454:  DATA 20,00
01456:  DATA 45,53
01458:  DATA 50,45
0145A:  DATA 52,41
0145C:  DATA 4E,44
0145E:  DATA 4F,20
01460:  DATA 4D,41
01462:  DATA 51,55
01464:  DATA 49,4E
01466:  DATA 41,20
01468:  DATA 32,0A
0146A:  DATA 0D,00
0146C:  DATA 53,41
0146E:  DATA 49,52
01470:  DATA 20,44
01472:  DATA 49,53
01474:  DATA 50,45
01476:  DATA 4E,53
01478:  DATA 41,44
0147A:  DATA 4F,52
0147C:  DATA 20,20
0147E:  DATA 20,00
01480:  DATA 45,53
01482:  DATA 50,45
01484:  DATA 52,41
01486:  DATA 4E,44
01488:  DATA 4F,20
0148A:  DATA 4D,41
0148C:  DATA 51,55
0148E:  DATA 49,4E
01490:  DATA 41,20
01492:  DATA 32,0A
01494:  DATA 0D,00
01496:  DATA 20,20
01498:  DATA 20,20
0149A:  DATA 53,41
0149C:  DATA 49,52
0149E:  DATA 20,53
014A0:  DATA 54,4F
014A2:  DATA 50,20
014A4:  DATA 20,20
014A6:  DATA 20,20
014A8:  DATA 20,20
014AA:  DATA 20,20
014AC:  DATA 20,00
014AE:  DATA 45,53
014B0:  DATA 50,45
014B2:  DATA 52,41
014B4:  DATA 4E,44
014B6:  DATA 4F,20
014B8:  DATA 20,4D
014BA:  DATA 41,51
014BC:  DATA 55,49
014BE:  DATA 4E,41
014C0:  DATA 32,0A
014C2:  DATA 0D,00
014C4:  DATA 49,52
014C6:  DATA 20,50
014C8:  DATA 41,52
014CA:  DATA 41,20
014CC:  DATA 48,4F
014CE:  DATA 4D,45
014D0:  DATA 31,20
014D2:  DATA 20,20
014D4:  DATA 20,20
014D6:  DATA 20,00
014D8:  DATA 45,53
014DA:  DATA 50,45
014DC:  DATA 52,41
014DE:  DATA 4E,44
014E0:  DATA 4F,20
014E2:  DATA 20,4D
014E4:  DATA 41,51
014E6:  DATA 55,49
014E8:  DATA 4E,41
014EA:  DATA 31,0A
014EC:  DATA 0D,00
014EE:  DATA 49,52
014F0:  DATA 20,50
014F2:  DATA 41,52
014F4:  DATA 41,20
014F6:  DATA 41,4C
014F8:  DATA 49,4D
014FA:  DATA 45,4E
014FC:  DATA 54,41
014FE:  DATA 43,41
01500:  DATA 4F,00
01502:  DATA 20,20
01504:  DATA 20,20
01506:  DATA 20,20
01508:  DATA 20,45
0150A:  DATA 52,52
0150C:  DATA 4F,20
0150E:  DATA 20,20
01510:  DATA 20,20
01512:  DATA 20,20
01514:  DATA 20,0A
01516:  DATA 0D,00
01518:  DATA 50,4F
0151A:  DATA 53,49
0151C:  DATA 43,41
0151E:  DATA 4F,20
01520:  DATA 41,4C
01522:  DATA 49,4D
01524:  DATA 45,4E
01526:  DATA 54,41
01528:  DATA 43,41
0152A:  DATA 4F,0A
0152C:  DATA 0D,00
0152E:  DATA 44,49
01530:  DATA 56,45
01532:  DATA 52,47
01534:  DATA 45,4E
01536:  DATA 43,49
01538:  DATA 41,20
0153A:  DATA 50,4F
0153C:  DATA 53,49
0153E:  DATA 43,41
01540:  DATA 4F,0A
01542:  DATA 0D,00
01544:  DATA 20,20
01546:  DATA 53,5F
01548:  DATA 59,5F
0154A:  DATA 44,49
0154C:  DATA 52,45
0154E:  DATA 49,54
01550:  DATA 41,20
01552:  DATA 50,52
01554:  DATA 4F,54
01556:  DATA 20,0A
01558:  DATA 0D,00
0155A:  DATA 4D,4F
0155C:  DATA 56,2E
0155E:  DATA 20,50
01560:  DATA 4F,53
01562:  DATA 49,43
01564:  DATA 41,4F
01566:  DATA 20,53
01568:  DATA 4F,4C
0156A:  DATA 44,41
0156C:  DATA 52,0A
0156E:  DATA 0D,00
01570:  DATA 44,49
01572:  DATA 56,45
01574:  DATA 52,47
01576:  DATA 45,4E
01578:  DATA 43,49
0157A:  DATA 41,20
0157C:  DATA 50,4F
0157E:  DATA 53,49
01580:  DATA 43,41
01582:  DATA 4F,0A
01584:  DATA 0D,00
01586:  DATA 20,20
01588:  DATA 20,20
0158A:  DATA 53,5F
0158C:  DATA 59,5F
0158E:  DATA 46,52
01590:  DATA 45,4E
01592:  DATA 54,45
01594:  DATA 20,20
01596:  DATA 20,20
01598:  DATA 20,0A
0159A:  DATA 0D,00
0159C:  DATA 50,4F
0159E:  DATA 53,49
015A0:  DATA 43,41
015A2:  DATA 4F,20
015A4:  DATA 53,4F
015A6:  DATA 4C,44
015A8:  DATA 41,52
015AA:  DATA 20,20
015AC:  DATA 20,20
015AE:  DATA 20,0A
015B0:  DATA 0D,00
015B2:  DATA 43,4F
015B4:  DATA 4F,52
015B6:  DATA 44,45
015B8:  DATA 4E,41
015BA:  DATA 44,41
015BC:  DATA 20,46
015BE:  DATA 4F,52
015C0:  DATA 41,20
015C2:  DATA 44,41
015C4:  DATA 20,0A
015C6:  DATA 0D,00
015C8:  DATA 50,4F
015CA:  DATA 53,49
015CC:  DATA 43,41
015CE:  DATA 4F,20
015D0:  DATA 45,53
015D2:  DATA 54,41
015D4:  DATA 47,49
015D6:  DATA 4F,20
015D8:  DATA 32,20
015DA:  DATA 20,0A
015DC:  DATA 0D,00
015DE:  DATA 50,4F
015E0:  DATA 53,49
015E2:  DATA 43,41
015E4:  DATA 4F,20
015E6:  DATA 48,4F
015E8:  DATA 4D,45
015EA:  DATA 32,20
015EC:  DATA 20,20
015EE:  DATA 20,20
015F0:  DATA 20,0A
015F2:  DATA 0D,00
015F4:  DATA 44,49
015F6:  DATA 56,45
015F8:  DATA 52,47
015FA:  DATA 45,4E
015FC:  DATA 43,49
015FE:  DATA 41,20
01600:  DATA 50,4F
01602:  DATA 53,49
01604:  DATA 43,41
01606:  DATA 4F,0A
01608:  DATA 0D,00
0160A:  DATA 20,20
0160C:  DATA 20,20
0160E:  DATA 53,5F
01610:  DATA 59,5F
01612:  DATA 41,54
01614:  DATA 52,41
01616:  DATA 53,20
01618:  DATA 20,20
0161A:  DATA 20,20
0161C:  DATA 20,0A
0161E:  DATA 0D,00
01620:  DATA 50,4F
01622:  DATA 53,49
01624:  DATA 43,41
01626:  DATA 4F,20
01628:  DATA 48,4F
0162A:  DATA 4D,45
0162C:  DATA 32,20
0162E:  DATA 20,20
01630:  DATA 20,20
01632:  DATA 20,0A
01634:  DATA 0D,00
01636:  DATA 44,49
01638:  DATA 56,45
0163A:  DATA 52,47
0163C:  DATA 45,4E
0163E:  DATA 43,49
01640:  DATA 41,20
01642:  DATA 50,4F
01644:  DATA 53,49
01646:  DATA 43,41
01648:  DATA 4F,0A
0164A:  DATA 0D,00
0164C:  DATA 20,20
0164E:  DATA 20,53
01650:  DATA 5F,58
01652:  DATA 5F,45
01654:  DATA 53,51
01656:  DATA 55,45
01658:  DATA 52,44
0165A:  DATA 41,20
0165C:  DATA 20,20
0165E:  DATA 20,20
01660:  DATA 0A,0D
01662:  DATA 00,00
01664:  DATA 20,20
01666:  DATA 20,53
01668:  DATA 5F,58
0166A:  DATA 5F,44
0166C:  DATA 49,52
0166E:  DATA 45,49
01670:  DATA 54,41
01672:  DATA 20,20
01674:  DATA 20,20
01676:  DATA 20,0A
01678:  DATA 0D,00
0167A:  DATA 50,4F
0167C:  DATA 53,49
0167E:  DATA 43,41
01680:  DATA 4F,20
01682:  DATA 44,49
01684:  DATA 53,50
01686:  DATA 45,4E
01688:  DATA 53,41
0168A:  DATA 44,4F
0168C:  DATA 52,0A
0168E:  DATA 0D,00
01690:  DATA 44,49
01692:  DATA 56,45
01694:  DATA 52,47
01696:  DATA 45,4E
01698:  DATA 43,49
0169A:  DATA 41,20
0169C:  DATA 50,4F
0169E:  DATA 53,49
016A0:  DATA 43,41
016A2:  DATA 4F,0A
016A4:  DATA 0D,00
016A6:  DATA 20,20
016A8:  DATA 20,53
016AA:  DATA 5F,58
016AC:  DATA 5F,44
016AE:  DATA 49,52
016B0:  DATA 45,49
016B2:  DATA 54,41
016B4:  DATA 20,20
016B6:  DATA 20,20
016B8:  DATA 20,0A
016BA:  DATA 0D,00
016BC:  DATA 20,20
016BE:  DATA 20,53
016C0:  DATA 5F,58
016C2:  DATA 5F,45
016C4:  DATA 53,51
016C6:  DATA 55,45
016C8:  DATA 52,44
016CA:  DATA 41,20
016CC:  DATA 20,20
016CE:  DATA 20,0A
016D0:  DATA 0D,00
016D2:  DATA 50,4F
016D4:  DATA 53,49
016D6:  DATA 43,41
016D8:  DATA 4F,20
016DA:  DATA 48,4F
016DC:  DATA 4D,45
016DE:  DATA 20,33
016E0:  DATA 20,20
016E2:  DATA 20,20
016E4:  DATA 20,0A
016E6:  DATA 0D,00
016E8:  DATA 44,49
016EA:  DATA 56,45
016EC:  DATA 52,47
016EE:  DATA 45,4E
016F0:  DATA 43,49
016F2:  DATA 41,20
016F4:  DATA 50,4F
016F6:  DATA 53,49
016F8:  DATA 43,41
016FA:  DATA 4F,0A
016FC:  DATA 0D,00
016FE:  DATA 20,20
01700:  DATA 53,5F
01702:  DATA 59,5F
01704:  DATA 41,54
01706:  DATA 52,41
01708:  DATA 53,20
0170A:  DATA 20,20
0170C:  DATA 20,20
0170E:  DATA 20,20
01710:  DATA 20,0A
01712:  DATA 0D,00
01714:  DATA 50,4F
01716:  DATA 53,49
01718:  DATA 43,41
0171A:  DATA 4F,20
0171C:  DATA 48,4F
0171E:  DATA 4D,45
01720:  DATA 20,31
01722:  DATA 20,20
01724:  DATA 20,20
01726:  DATA 20,0A
01728:  DATA 0D,00
0172A:  DATA 44,49
0172C:  DATA 56,45
0172E:  DATA 52,47
01730:  DATA 45,4E
01732:  DATA 43,49
01734:  DATA 41,20
01736:  DATA 50,4F
01738:  DATA 53,49
0173A:  DATA 43,41
0173C:  DATA 4F,0A
0173E:  DATA 0D,00
01740:  DATA 20,20
01742:  DATA 53,5F
01744:  DATA 59,5F
01746:  DATA 46,52
01748:  DATA 45,4E
0174A:  DATA 54,45
0174C:  DATA 20,20
0174E:  DATA 20,20
01750:  DATA 20,20
01752:  DATA 20,0A
01754:  DATA 0D,00
01756:  DATA 50,4F
01758:  DATA 53,49
0175A:  DATA 43,41
0175C:  DATA 4F,20
0175E:  DATA 48,4F
01760:  DATA 4D,45
01762:  DATA 20,31
01764:  DATA 20,20
01766:  DATA 20,20
01768:  DATA 20,0A
0176A:  DATA 0D,00
0176C:  DATA 44,49
0176E:  DATA 56,45
01770:  DATA 52,47
01772:  DATA 45,4E
01774:  DATA 43,49
01776:  DATA 41,20
01778:  DATA 50,4F
0177A:  DATA 53,49
0177C:  DATA 43,41
0177E:  DATA 4F,0A
01780:  DATA 0D,00
01782:  DATA 20,20
01784:  DATA 53,5F
01786:  DATA 58,5F
01788:  DATA 45,53
0178A:  DATA 51,55
0178C:  DATA 45,52
0178E:  DATA 44,41
01790:  DATA 20,20
01792:  DATA 20,20
01794:  DATA 20,0A
01796:  DATA 0D,00
01798:  DATA 20,20
0179A:  DATA 53,5F
0179C:  DATA 58,5F
0179E:  DATA 44,49
017A0:  DATA 52,45
017A2:  DATA 49,54
017A4:  DATA 41,20
017A6:  DATA 20,20
017A8:  DATA 20,20
017AA:  DATA 20,0A
017AC:  DATA 0D,00
017AE:  DATA 4C,45
017B0:  DATA 49,54
017B2:  DATA 55,52
017B4:  DATA 41,20
017B6:  DATA 44,45
017B8:  DATA 20,50
017BA:  DATA 4F,53
017BC:  DATA 49,43
017BE:  DATA 41,4F
017C0:  DATA 20,0A
017C2:  DATA 0D,00
017C4:  DATA 49,4E
017C6:  DATA 43,4F
017C8:  DATA 45,52
017CA:  DATA 45,4E
017CC:  DATA 54,45
017CE:  DATA 20,20
017D0:  DATA 20,20
017D2:  DATA 20,20
017D4:  DATA 20,20
017D6:  DATA 20,0A
017D8:  DATA 0D,00
017DA:  DATA 50,4F
017DC:  DATA 53,49
017DE:  DATA 43,41
017E0:  DATA 4F,20
017E2:  DATA 50,52
017E4:  DATA 4F,49
017E6:  DATA 42,49
017E8:  DATA 44,41
017EA:  DATA 20,20
017EC:  DATA 20,0A
017EE:  DATA 0D,00
017F0:  DATA 50,41
017F2:  DATA 52,41
017F4:  DATA 20,47
017F6:  DATA 49,52
017F8:  DATA 41,52
017FA:  DATA 20,42
017FC:  DATA 41,4E
017FE:  DATA 44,45
01800:  DATA 4A,41
01802:  DATA 20,0A
01804:  DATA 0D,00
01806:  DATA 20,20
01808:  DATA 20,54
0180A:  DATA 49,4D
0180C:  DATA 45,20
0180E:  DATA 4F,55
01810:  DATA 54,20
01812:  DATA 20,20
01814:  DATA 20,20
01816:  DATA 20,20
01818:  DATA 20,0A
0181A:  DATA 0D,00
0181C:  DATA 20,53
0181E:  DATA 5F,44
01820:  DATA 45,44
01822:  DATA 4F,5F
01824:  DATA 49,4E
01826:  DATA 5F,4C
01828:  DATA 53,31
0182A:  DATA 20,20
0182C:  DATA 20,20
0182E:  DATA 20,0A
01830:  DATA 0D,00
01832:  DATA 20,20
01834:  DATA 20,54
01836:  DATA 49,4D
01838:  DATA 45,20
0183A:  DATA 4F,55
0183C:  DATA 54,20
0183E:  DATA 20,20
01840:  DATA 20,20
01842:  DATA 20,20
01844:  DATA 20,0A
01846:  DATA 0D,00
01848:  DATA 20,53
0184A:  DATA 5F,44
0184C:  DATA 45,44
0184E:  DATA 4F,5F
01850:  DATA 49,4E
01852:  DATA 5F,4C
01854:  DATA 53,32
01856:  DATA 20,20
01858:  DATA 20,20
0185A:  DATA 20,0A
0185C:  DATA 0D,00
0185E:  DATA 20,20
01860:  DATA 20,54
01862:  DATA 49,4D
01864:  DATA 45,20
01866:  DATA 4F,55
01868:  DATA 54,20
0186A:  DATA 20,20
0186C:  DATA 20,20
0186E:  DATA 20,20
01870:  DATA 20,0A
01872:  DATA 0D,00
01874:  DATA 53,5F
01876:  DATA 45,4D
01878:  DATA 50,55
0187A:  DATA 52,52
0187C:  DATA 41,44
0187E:  DATA 4F,52
01880:  DATA 5F,49
01882:  DATA 4E,5F
01884:  DATA 4C,53
01886:  DATA 32,0A
01888:  DATA 0D,00
0188A:  DATA 20,20
0188C:  DATA 20,54
0188E:  DATA 49,4D
01890:  DATA 45,20
01892:  DATA 4F,55
01894:  DATA 54,20
01896:  DATA 20,20
01898:  DATA 20,20
0189A:  DATA 20,20
0189C:  DATA 20,0A
0189E:  DATA 0D,00
018A0:  DATA 20,53
018A2:  DATA 5F,44
018A4:  DATA 45,44
018A6:  DATA 4F,5F
018A8:  DATA 4F,55
018AA:  DATA 54,5F
018AC:  DATA 4C,53
018AE:  DATA 31,20
018B0:  DATA 20,20
018B2:  DATA 20,0A
018B4:  DATA 0D,00
018B6:  DATA 20,20
018B8:  DATA 20,54
018BA:  DATA 49,4D
018BC:  DATA 45,20
018BE:  DATA 4F,55
018C0:  DATA 54,20
018C2:  DATA 20,20
018C4:  DATA 20,20
018C6:  DATA 20,20
018C8:  DATA 20,0A
018CA:  DATA 0D,00
018CC:  DATA 53,5F
018CE:  DATA 44,45
018D0:  DATA 44,4F
018D2:  DATA 5F,4F
018D4:  DATA 55,54
018D6:  DATA 5F,4C
018D8:  DATA 53,32
018DA:  DATA 20,20
018DC:  DATA 20,20
018DE:  DATA 20,0A
018E0:  DATA 0D,00
018E2:  DATA 20,20
018E4:  DATA 20,54
018E6:  DATA 49,4D
018E8:  DATA 45,20
018EA:  DATA 4F,55
018EC:  DATA 54,20
018EE:  DATA 20,20
018F0:  DATA 20,20
018F2:  DATA 20,20
018F4:  DATA 20,0A
018F6:  DATA 0D,00
018F8:  DATA 53,5F
018FA:  DATA 50,52
018FC:  DATA 45,53
018FE:  DATA 53,4F
01900:  DATA 52,5F
01902:  DATA 4C,53
01904:  DATA 32,20
01906:  DATA 20,20
01908:  DATA 20,20
0190A:  DATA 20,0A
0190C:  DATA 0D,00
0190E:  DATA 20,20
01910:  DATA 20,54
01912:  DATA 49,4D
01914:  DATA 45,20
01916:  DATA 4F,55
01918:  DATA 54,20
0191A:  DATA 20,20
0191C:  DATA 20,20
0191E:  DATA 20,20
01920:  DATA 20,0A
01922:  DATA 0D,00
01924:  DATA 53,5F
01926:  DATA 45,4D
01928:  DATA 50,55
0192A:  DATA 52,52
0192C:  DATA 41,44
0192E:  DATA 4F,52
01930:  DATA 5F,49
01932:  DATA 4E,5F
01934:  DATA 4C,53
01936:  DATA 31,0A
01938:  DATA 0D,00
0193A:  DATA 20,20
0193C:  DATA 20,54
0193E:  DATA 49,4D
01940:  DATA 45,20
01942:  DATA 4F,55
01944:  DATA 54,20
01946:  DATA 20,20
01948:  DATA 20,20
0194A:  DATA 20,20
0194C:  DATA 20,0A
0194E:  DATA 0D,00
01950:  DATA 53,5F
01952:  DATA 45,4D
01954:  DATA 50,55
01956:  DATA 52,52
01958:  DATA 41,44
0195A:  DATA 4F,52
0195C:  DATA 5F,49
0195E:  DATA 4E,5F
01960:  DATA 4C,53
01962:  DATA 32,0A
01964:  DATA 0D,00
01966:  DATA 20,20
01968:  DATA 20,4F
0196A:  DATA 55,54
0196C:  DATA 20,4F
0196E:  DATA 46,20
01970:  DATA 52,41
01972:  DATA 4E,47
01974:  DATA 45,20
01976:  DATA 58,20
01978:  DATA 20,20
0197A:  DATA 0A,0D
0197C:  DATA 00,00
0197E:  DATA 20,20
01980:  DATA 20,20
01982:  DATA 20,20
01984:  DATA 20,20
01986:  DATA 4D,41
01988:  DATA 58,20
0198A:  DATA 20,20
0198C:  DATA 20,20
0198E:  DATA 20,20
01990:  DATA 20,20
01992:  DATA 0A,0D
01994:  DATA 00,00
01996:  DATA 20,20
01998:  DATA 20,4F
0199A:  DATA 55,54
0199C:  DATA 20,4F
0199E:  DATA 46,20
019A0:  DATA 52,41
019A2:  DATA 4E,47
019A4:  DATA 45,20
019A6:  DATA 59,20
019A8:  DATA 20,20
019AA:  DATA 0A,0D
019AC:  DATA 00,00
019AE:  DATA 20,20
019B0:  DATA 20,20
019B2:  DATA 20,20
019B4:  DATA 20,20
019B6:  DATA 4D,41
019B8:  DATA 58,20
019BA:  DATA 20,20
019BC:  DATA 20,20
019BE:  DATA 20,20
019C0:  DATA 20,20
019C2:  DATA 0A,0D
019C4:  DATA 00,00
019C6:  DATA 20,20
019C8:  DATA 20,4F
019CA:  DATA 55,54
019CC:  DATA 20,4F
019CE:  DATA 46,20
019D0:  DATA 52,41
019D2:  DATA 4E,47
019D4:  DATA 45,20
019D6:  DATA 5A,20
019D8:  DATA 20,20
019DA:  DATA 0A,0D
019DC:  DATA 00,00
019DE:  DATA 20,20
019E0:  DATA 20,20
019E2:  DATA 20,20
019E4:  DATA 20,20
019E6:  DATA 4D,41
019E8:  DATA 58,20
019EA:  DATA 20,20
019EC:  DATA 20,20
019EE:  DATA 20,20
019F0:  DATA 20,20
019F2:  DATA 0A,0D
019F4:  DATA 00,00
019F6:  DATA 20,20
019F8:  DATA 20,4F
019FA:  DATA 55,54
019FC:  DATA 20,4F
019FE:  DATA 46,20
01A00:  DATA 52,41
01A02:  DATA 4E,47
01A04:  DATA 45,20
01A06:  DATA 58,20
01A08:  DATA 20,20
01A0A:  DATA 0A,0D
01A0C:  DATA 00,00
01A0E:  DATA 20,20
01A10:  DATA 20,20
01A12:  DATA 20,20
01A14:  DATA 20,20
01A16:  DATA 4D,49
01A18:  DATA 4E,20
01A1A:  DATA 20,20
01A1C:  DATA 20,20
01A1E:  DATA 20,20
01A20:  DATA 20,20
01A22:  DATA 0A,0D
01A24:  DATA 00,00
01A26:  DATA 20,20
01A28:  DATA 20,4F
01A2A:  DATA 55,54
01A2C:  DATA 20,4F
01A2E:  DATA 46,20
01A30:  DATA 52,41
01A32:  DATA 4E,47
01A34:  DATA 45,20
01A36:  DATA 59,20
01A38:  DATA 20,20
01A3A:  DATA 0A,0D
01A3C:  DATA 00,00
01A3E:  DATA 20,20
01A40:  DATA 20,20
01A42:  DATA 20,20
01A44:  DATA 20,20
01A46:  DATA 4D,49
01A48:  DATA 4E,20
01A4A:  DATA 20,20
01A4C:  DATA 20,20
01A4E:  DATA 20,20
01A50:  DATA 20,20
01A52:  DATA 0A,0D
01A54:  DATA 00,00
01A56:  DATA 20,20
01A58:  DATA 20,4F
01A5A:  DATA 55,54
01A5C:  DATA 20,4F
01A5E:  DATA 46,20
01A60:  DATA 52,41
01A62:  DATA 4E,47
01A64:  DATA 45,20
01A66:  DATA 5A,20
01A68:  DATA 20,20
01A6A:  DATA 0A,0D
01A6C:  DATA 00,00
01A6E:  DATA 20,20
01A70:  DATA 20,20
01A72:  DATA 20,20
01A74:  DATA 20,20
01A76:  DATA 4D,49
01A78:  DATA 4E,20
01A7A:  DATA 20,20
01A7C:  DATA 20,20
01A7E:  DATA 20,20
01A80:  DATA 20,20
01A82:  DATA 0A,0D
01A84:  DATA 00,00
01A86:  DATA 20,20
01A88:  DATA 20,54
01A8A:  DATA 49,4D
01A8C:  DATA 45,5F
01A8E:  DATA 4F,55
01A90:  DATA 54,20
01A92:  DATA 20,20
01A94:  DATA 20,20
01A96:  DATA 20,20
01A98:  DATA 20,0A
01A9A:  DATA 0D,00
01A9C:  DATA 20,20
01A9E:  DATA 20,53
01AA0:  DATA 2E,20
01AA2:  DATA 42,41
01AA4:  DATA 4E,44
01AA6:  DATA 45,4A
01AA8:  DATA 41,20
01AAA:  DATA 20,20
01AAC:  DATA 20,20
01AAE:  DATA 20,0A
01AB0:  DATA 0D,00
01AB2:  DATA 20,20
01AB4:  DATA 20,54
01AB6:  DATA 49,4D
01AB8:  DATA 45,5F
01ABA:  DATA 4F,55
01ABC:  DATA 54,20
01ABE:  DATA 20,20
01AC0:  DATA 20,20
01AC2:  DATA 20,20
01AC4:  DATA 20,0A
01AC6:  DATA 0D,00
01AC8:  DATA 20,53
01ACA:  DATA 5F,45
01ACC:  DATA 4D,50
01ACE:  DATA 55,52
01AD0:  DATA 52,41
01AD2:  DATA 44,4F
01AD4:  DATA 52,5F
01AD6:  DATA 52,45
01AD8:  DATA 43,55
01ADA:  DATA 4F,20
01ADC:  DATA 0A,0D
01ADE:  DATA 00,00
01AE0:  DATA 41,47
01AE2:  DATA 55,41
01AE4:  DATA 52,44
01AE6:  DATA 41,4E
01AE8:  DATA 44,4F
01AEA:  DATA 20,50
01AEC:  DATA 4C,41
01AEE:  DATA 43,41
01AF0:  DATA 20,20
01AF2:  DATA 20,20
01AF4:  DATA 0A,0D
01AF6:  DATA 00,00
01AF8:  DATA 41,47
01AFA:  DATA 55,41
01AFC:  DATA 52,44
01AFE:  DATA 41,4E
01B00:  DATA 44,4F
01B02:  DATA 20,50
01B04:  DATA 4C,41
01B06:  DATA 43,41
01B08:  DATA 20,20
01B0A:  DATA 20,20
01B0C:  DATA 0A,0D
01B0E:  DATA 00,00
01B10:  DATA 41,47
01B12:  DATA 55,41
01B14:  DATA 52,44
01B16:  DATA 41,4E
01B18:  DATA 44,4F
01B1A:  DATA 20,50
01B1C:  DATA 4C,41
01B1E:  DATA 43,41
01B20:  DATA 20,20
01B22:  DATA 20,20
01B24:  DATA 0A,0D
01B26:  DATA 00,00
*
01C92:  DATA 20,56
01C94:  DATA 41,4C
01C96:  DATA 4F,52
01C98:  DATA 45,53
01C9A:  DATA 20,44
01C9C:  DATA 45,46
01C9E:  DATA 41,55
01CA0:  DATA 4C,54
01CA2:  DATA 20,20
01CA4:  DATA 20,0A
01CA6:  DATA 0D,00
01CA8:  DATA 20,20
01CAA:  DATA 20,52
01CAC:  DATA 45,53
01CAE:  DATA 54,41
01CB0:  DATA 55,52
01CB2:  DATA 41,44
01CB4:  DATA 4F,53
01CB6:  DATA 20,20
01CB8:  DATA 20,20
01CBA:  DATA 20,0A
01CBC:  DATA 0D,00
01CBE:  DATA 49,4E
01CC0:  DATA 53,54
01CC2:  DATA 49,54
01CC4:  DATA 55,54
01CC6:  DATA 4F,20
01CC8:  DATA 20,49
01CCA:  DATA 43,54
01CCC:  DATA 53,20
01CCE:  DATA 20,20
01CD0:  DATA 0A,0D
01CD2:  DATA 00,00
01CD4:  DATA 54,45
01CD6:  DATA 43,4E
01CD8:  DATA 4F,4C
01CDA:  DATA 4F,47
01CDC:  DATA 49,41
01CDE:  DATA 20,20
01CE0:  DATA 20,45
01CE2:  DATA 4D,20
01CE4:  DATA 20,20
01CE6:  DATA 0A,0D
01CE8:  DATA 00,00
01CEA:  DATA 20,20
01CEC:  DATA 20,20
01CEE:  DATA 53,4F
01CF0:  DATA 46,54
01CF2:  DATA 57,41
01CF4:  DATA 52,45
01CF6:  DATA 20,20
01CF8:  DATA 20,20
01CFA:  DATA 20,20
01CFC:  DATA 0A,0D
01CFE:  DATA 00,00
*
01FF2:  TBLRD*+
01FF4:  MOVF   FF5,F
01FF6:  BZ    2010
01FF8:  MOVFF  FF6,199
01FFC:  MOVFF  FF7,19A
02000:  MOVFF  FF5,1A5
02004:  RCALL  1FE6
02006:  MOVFF  199,FF6
0200A:  MOVFF  19A,FF7
0200E:  BRA    1FF2
02010:  RETURN 0
*
025DA:  TBLRD*+
025DC:  MOVF   FF5,F
025DE:  BZ    25F8
025E0:  MOVFF  FF6,1A1
025E4:  MOVFF  FF7,1A2
025E8:  MOVFF  FF5,1A4
025EC:  RCALL  2586
025EE:  MOVFF  1A1,FF6
025F2:  MOVFF  1A2,FF7
025F6:  BRA    25DA
025F8:  RETURN 0
025FA:  MOVLB  1
025FC:  MOVF   x9D,W
025FE:  CLRF   01
02600:  SUBWF  x9C,W
02602:  BC    260A
02604:  MOVFF  19C,00
02608:  BRA    2622
0260A:  CLRF   00
0260C:  MOVLW  08
0260E:  MOVWF  x9E
02610:  RLCF   x9C,F
02612:  RLCF   00,F
02614:  MOVF   x9D,W
02616:  SUBWF  00,W
02618:  BTFSC  FD8.0
0261A:  MOVWF  00
0261C:  RLCF   01,F
0261E:  DECFSZ x9E,F
02620:  BRA    2610
02622:  MOVLB  0
02624:  RETURN 0
02626:  MOVF   01,W
02628:  MOVFF  19A,19C
0262C:  MOVLW  64
0262E:  MOVLB  1
02630:  MOVWF  x9D
02632:  MOVLB  0
02634:  RCALL  25FA
02636:  MOVFF  00,19A
0263A:  MOVF   01,W
0263C:  MOVLW  30
0263E:  BNZ   2650
02640:  MOVLB  1
02642:  BTFSS  x9B.1
02644:  BRA    2664
02646:  BTFSC  x9B.3
02648:  BRA    2664
0264A:  BTFSC  x9B.4
0264C:  MOVLW  20
0264E:  BRA    2658
02650:  MOVLB  1
02652:  BCF    x9B.3
02654:  BCF    x9B.4
02656:  BSF    x9B.0
02658:  ADDWF  01,F
0265A:  MOVFF  01,1A4
0265E:  MOVLB  0
02660:  RCALL  2586
02662:  MOVLB  1
02664:  MOVFF  19A,19C
02668:  MOVLW  0A
0266A:  MOVWF  x9D
0266C:  MOVLB  0
0266E:  RCALL  25FA
02670:  MOVFF  00,19A
02674:  MOVF   01,W
02676:  MOVLW  30
02678:  BNZ   268A
0267A:  MOVLB  1
0267C:  BTFSC  x9B.3
0267E:  BRA    2694
02680:  BTFSS  x9B.0
02682:  BRA    2694
02684:  BTFSC  x9B.4
02686:  MOVLW  20
02688:  MOVLB  0
0268A:  ADDWF  01,F
0268C:  MOVFF  01,1A4
02690:  RCALL  2586
02692:  MOVLB  1
02694:  MOVLW  30
02696:  ADDWF  x9A,F
02698:  MOVFF  19A,1A4
0269C:  MOVLB  0
0269E:  RCALL  2586
026A0:  RETURN 0
*
027BE:  MOVLB  2
027C0:  MOVF   x14,W
027C2:  MULWF  x16
027C4:  MOVFF  FF3,01
027C8:  MOVFF  FF4,00
027CC:  MULWF  x17
027CE:  MOVF   FF3,W
027D0:  ADDWF  00,F
027D2:  MOVF   x15,W
027D4:  MULWF  x16
027D6:  MOVF   FF3,W
027D8:  ADDWFC 00,W
027DA:  MOVWF  02
027DC:  MOVLB  0
027DE:  RETURN 0
*
02E5E:  MOVFF  FF2,0D
02E62:  BCF    FF2.7
02E64:  ADDWF  FE8,W
02E66:  CLRF   FF7
02E68:  RLCF   FF7,F
02E6A:  ADDLW  83
02E6C:  MOVWF  FF6
02E6E:  MOVLW  2E
02E70:  ADDWFC FF7,F
02E72:  TBLRD*-
02E74:  MOVF   FF5,W
02E76:  MOVWF  FFA
02E78:  TBLRD*
02E7A:  MOVF   FF5,W
02E7C:  BTFSC  0D.7
02E7E:  BSF    FF2.7
02E80:  MOVWF  FF9
02E82:  DATA 70,2D
02E84:  DATA AA,2D
02E86:  DATA E4,2D
02E88:  DATA 1E,2E
*
03540:  MOVLB  1
03542:  MOVF   x9B,W
03544:  ANDLW  07
03546:  MOVWF  00
03548:  RRCF   x9B,W
0354A:  MOVWF  01
0354C:  RRCF   01,F
0354E:  RRCF   01,F
03550:  MOVLW  1F
03552:  ANDWF  01,F
03554:  MOVF   01,W
03556:  ADDWF  x9D,W
03558:  MOVWF  FE9
0355A:  MOVLW  00
0355C:  ADDWFC x9E,W
0355E:  MOVWF  FEA
03560:  CLRF   01
03562:  INCF   01,F
03564:  INCF   00,F
03566:  BRA    356A
03568:  RLCF   01,F
0356A:  DECFSZ 00,F
0356C:  BRA    3568
0356E:  MOVF   x9C,F
03570:  BZ    3578
03572:  MOVF   01,W
03574:  IORWF  FEF,F
03576:  BRA    357E
03578:  COMF   01,F
0357A:  MOVF   01,W
0357C:  ANDWF  FEF,F
0357E:  MOVLB  0
03580:  RETURN 0
03582:  MOVLB  1
03584:  MOVF   x9B,W
03586:  ANDLW  07
03588:  MOVWF  00
0358A:  RRCF   x9B,W
0358C:  MOVWF  01
0358E:  RRCF   01,F
03590:  RRCF   01,F
03592:  MOVLW  1F
03594:  ANDWF  01,F
03596:  MOVF   01,W
03598:  ADDWF  x9C,W
0359A:  MOVWF  FE9
0359C:  MOVLW  00
0359E:  ADDWFC x9D,W
035A0:  MOVWF  FEA
035A2:  MOVFF  FEF,01
035A6:  INCF   00,F
035A8:  BRA    35AC
035AA:  RRCF   01,F
035AC:  DECFSZ 00,F
035AE:  BRA    35AA
035B0:  MOVLB  0
035B2:  RETURN 0
*
03F58:  CLRF   01
03F5A:  CLRF   02
03F5C:  CLRF   00
03F5E:  CLRF   03
03F60:  MOVLB  1
03F62:  MOVF   xC5,W
03F64:  BNZ   3F6A
03F66:  MOVF   xC4,W
03F68:  BZ    3F9A
03F6A:  MOVLW  10
03F6C:  MOVWF  xC6
03F6E:  BCF    FD8.0
03F70:  RLCF   xC2,F
03F72:  RLCF   xC3,F
03F74:  RLCF   00,F
03F76:  RLCF   03,F
03F78:  MOVF   xC5,W
03F7A:  SUBWF  03,W
03F7C:  BNZ   3F82
03F7E:  MOVF   xC4,W
03F80:  SUBWF  00,W
03F82:  BNC   3F92
03F84:  MOVF   xC4,W
03F86:  SUBWF  00,F
03F88:  BTFSS  FD8.0
03F8A:  DECF   03,F
03F8C:  MOVF   xC5,W
03F8E:  SUBWF  03,F
03F90:  BSF    FD8.0
03F92:  RLCF   01,F
03F94:  RLCF   02,F
03F96:  DECFSZ xC6,F
03F98:  BRA    3F6E
03F9A:  MOVLB  0
03F9C:  RETURN 0
03F9E:  MOVLB  1
03FA0:  MOVF   xC3,W
03FA2:  XORWF  xC5,W
03FA4:  ANDLW  80
03FA6:  MOVWF  xC7
03FA8:  BTFSS  xC3.7
03FAA:  BRA    3FB6
03FAC:  COMF   xC2,F
03FAE:  COMF   xC3,F
03FB0:  INCF   xC2,F
03FB2:  BTFSC  FD8.2
03FB4:  INCF   xC3,F
03FB6:  BTFSS  xC5.7
03FB8:  BRA    3FC4
03FBA:  COMF   xC4,F
03FBC:  COMF   xC5,F
03FBE:  INCF   xC4,F
03FC0:  BTFSC  FD8.2
03FC2:  INCF   xC5,F
03FC4:  MOVF   xC2,W
03FC6:  MULWF  xC4
03FC8:  MOVFF  FF3,01
03FCC:  MOVFF  FF4,00
03FD0:  MULWF  xC5
03FD2:  MOVF   FF3,W
03FD4:  ADDWF  00,F
03FD6:  MOVF   xC3,W
03FD8:  MULWF  xC4
03FDA:  MOVF   FF3,W
03FDC:  ADDWFC 00,W
03FDE:  MOVWF  02
03FE0:  BTFSS  xC7.7
03FE2:  BRA    3FEE
03FE4:  COMF   01,F
03FE6:  COMF   02,F
03FE8:  INCF   01,F
03FEA:  BTFSC  FD8.2
03FEC:  INCF   02,F
03FEE:  MOVLB  0
03FF0:  RETURN 0
*
05744:  MOVFF  FEA,1A3
05748:  MOVFF  FE9,1A2
0574C:  MOVLB  1
0574E:  SWAPF  x9C,W
05750:  IORLW  F0
05752:  MOVWF  x9E
05754:  ADDWF  x9E,F
05756:  ADDLW  E2
05758:  MOVWF  x9F
0575A:  ADDLW  32
0575C:  MOVWF  xA1
0575E:  MOVF   x9C,W
05760:  ANDLW  0F
05762:  ADDWF  x9F,F
05764:  ADDWF  x9F,F
05766:  ADDWF  xA1,F
05768:  ADDLW  E9
0576A:  MOVWF  xA0
0576C:  ADDWF  xA0,F
0576E:  ADDWF  xA0,F
05770:  SWAPF  x9B,W
05772:  ANDLW  0F
05774:  ADDWF  xA0,F
05776:  ADDWF  xA1,F
05778:  RLCF   xA0,F
0577A:  RLCF   xA1,F
0577C:  COMF   xA1,F
0577E:  RLCF   xA1,F
05780:  MOVF   x9B,W
05782:  ANDLW  0F
05784:  ADDWF  xA1,F
05786:  RLCF   x9E,F
05788:  MOVLW  07
0578A:  MOVWF  x9D
0578C:  MOVLW  0A
0578E:  DECF   xA0,F
05790:  ADDWF  xA1,F
05792:  BNC   578E
05794:  DECF   x9F,F
05796:  ADDWF  xA0,F
05798:  BNC   5794
0579A:  DECF   x9E,F
0579C:  ADDWF  x9F,F
0579E:  BNC   579A
057A0:  DECF   x9D,F
057A2:  ADDWF  x9E,F
057A4:  BNC   57A0
057A6:  MOVLW  01
057A8:  MOVWF  FEA
057AA:  MOVLW  9D
057AC:  MOVWF  FE9
057AE:  MOVLW  07
057B0:  ANDWF  xA2,W
057B2:  BCF    xA2.6
057B4:  ADDWF  FE9,F
057B6:  MOVLW  00
057B8:  ADDWFC FEA,F
057BA:  MOVF   FE9,W
057BC:  SUBLW  A1
057BE:  BNZ   57C6
057C0:  DECFSZ FEA,W
057C2:  BRA    57C6
057C4:  BSF    xA2.6
057C6:  MOVF   FEF,W
057C8:  MOVWF  00
057CA:  BNZ   57DC
057CC:  BTFSC  xA2.6
057CE:  BRA    57DC
057D0:  BTFSC  xA2.4
057D2:  BRA    5800
057D4:  BTFSC  xA2.3
057D6:  BRA    57DC
057D8:  MOVLW  20
057DA:  BRA    57E2
057DC:  BSF    xA2.3
057DE:  BCF    xA2.4
057E0:  MOVLW  30
057E2:  ADDWF  00,F
057E4:  MOVFF  FEA,19C
057E8:  MOVFF  FE9,19B
057EC:  MOVFF  00,1A4
057F0:  MOVLB  0
057F2:  CALL   2586
057F6:  MOVFF  19C,FEA
057FA:  MOVFF  19B,FE9
057FE:  MOVLB  1
05800:  MOVF   FEE,W
05802:  BTFSS  xA2.6
05804:  BRA    57BA
05806:  MOVLB  0
05808:  RETURN 0
*
09E66:  MOVLB  1
09E68:  BTFSC  x9C.7
09E6A:  BRA    9E90
09E6C:  MOVLW  0F
09E6E:  MOVWF  00
09E70:  SWAPF  x9B,W
09E72:  ANDWF  00,F
09E74:  MOVLW  0A
09E76:  SUBWF  00,W
09E78:  BC    9E80
09E7A:  MOVLW  30
09E7C:  ADDWF  00,F
09E7E:  BRA    9E84
09E80:  MOVF   x9C,W
09E82:  ADDWF  00,F
09E84:  MOVFF  00,1A4
09E88:  MOVLB  0
09E8A:  CALL   2586
09E8E:  MOVLB  1
09E90:  MOVLW  0F
09E92:  ANDWF  x9B,F
09E94:  MOVLW  0A
09E96:  SUBWF  x9B,W
09E98:  BC    9E9E
09E9A:  MOVLW  30
09E9C:  BRA    9EA2
09E9E:  BCF    x9C.7
09EA0:  MOVF   x9C,W
09EA2:  ADDWF  x9B,F
09EA4:  MOVFF  19B,1A4
09EA8:  MOVLB  0
09EAA:  CALL   2586
09EAE:  RETURN 0
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "main.h" 
.................... #fuses HS,NOWDT,PROTECT,NOLVP,NODEBUG,MCLR 
.................... #use delay(clock=20000000) 
*
01C3A:  MOVLW  03
01C3C:  MOVLB  2
01C3E:  SUBWF  x1B,F
01C40:  BNC   1C56
01C42:  MOVLW  02
01C44:  MOVWF  FEA
01C46:  MOVLW  1B
01C48:  MOVWF  FE9
01C4A:  MOVF   FEF,W
01C4C:  BZ    1C56
01C4E:  BRA    1C52
01C50:  BRA    1C52
01C52:  DECFSZ FEF,F
01C54:  BRA    1C50
01C56:  MOVLB  0
01C58:  RETURN 0
*
01D50:  MOVLW  02
01D52:  MOVWF  FEA
01D54:  MOVLW  17
01D56:  MOVWF  FE9
01D58:  MOVF   FEF,W
01D5A:  BZ    1D76
01D5C:  MOVLW  06
01D5E:  MOVWF  01
01D60:  CLRF   00
01D62:  DECFSZ 00,F
01D64:  BRA    1D62
01D66:  DECFSZ 01,F
01D68:  BRA    1D60
01D6A:  MOVLW  7B
01D6C:  MOVWF  00
01D6E:  DECFSZ 00,F
01D70:  BRA    1D6E
01D72:  DECFSZ FEF,F
01D74:  BRA    1D5C
01D76:  RETURN 0
.................... #use i2c(master,sda = pin_C4,scl = pin_C3,force_hw) 
*
01B28:  BCF    FC6.7
01B2A:  BCF    F9E.3
01B2C:  MOVFF  223,FC9
01B30:  MOVLW  02
01B32:  BTFSC  FC6.7
01B34:  BRA    1B40
01B36:  BTFSS  F9E.3
01B38:  BRA    1B36
01B3A:  MOVLW  00
01B3C:  BTFSC  FC5.6
01B3E:  MOVLW  01
01B40:  MOVWF  01
01B42:  RETURN 0
*
02012:  BCF    FC6.6
02014:  BSF    FC5.3
02016:  BTFSC  FC5.3
02018:  BRA    2016
0201A:  BTFSC  00.0
0201C:  BCF    FC5.5
0201E:  BTFSS  00.0
02020:  BSF    FC5.5
02022:  BSF    FC5.4
02024:  BTFSC  FC5.4
02026:  BRA    2024
02028:  MOVFF  FC9,01
0202C:  RETURN 0
....................  
.................... #use 		standard_io(a) 
.................... #use 		standard_io(b) 
.................... #use 		standard_io(c) 
.................... #use 		standard_io(d) 
.................... #use 		standard_io(e) 
....................  
....................  
.................... #DEFINE   	RS    pin_B5			 
.................... #DEFINE	  	E	  pin_A0 
....................  
....................  
.................... #DEFINE		EEPROM_SCL	    	pin_C3 
.................... #DEFINE 	EEPROM_SDA		    pin_C4 
....................  
....................  
.................... #DEFINE     in24_bit			pin_B0 
.................... #DEFINE     in25_bit			pin_B1 
.................... #DEFINE     in26_bit			pin_B3 
.................... #DEFINE     in27_bit			pin_B4 
....................  
.................... #DEFINE     H0					pin_D7 
.................... #DEFINE     H1					pin_D6 
.................... #DEFINE     H2					pin_D5 
....................  
.................... #DEFINE     H3					pin_D4 
.................... #DEFINE     H4					pin_C7	 
.................... #DEFINE     H5					pin_C6 
....................  
.................... #DEFINE TEMPO_1200us	(65535 - (1200 * 5)) 
.................... #DEFINE TEMPO_900us		(65535 - (900 * 5))	 
.................... #DEFINE	TEMPO_10000_MS	(65535 - (10000 * 5)) 
.................... #DEFINE	TEMPO_9000_MS	(65535 - (9000 * 5)) 
.................... #DEFINE	TEMPO_8000_MS	(65535 - (8000 * 5)) 
.................... #DEFINE	TEMPO_7000_MS	(65535 - (7000 * 5)) 
.................... #DEFINE	TEMPO_6000_MS	(65535 - (6000 * 5)) 
.................... #DEFINE	TEMPO_5000_MS	(65535 - (5000 * 5)) 
.................... #DEFINE	TEMPO_4000_MS	(65535 - (4000 * 5)) 
.................... #DEFINE TEMPO_3000_MS	(65535 - (3000 * 5)) 
.................... #DEFINE TEMPO_2000_MS	(65535 - (2000 * 5)) 
.................... #DEFINE TEMPO_1000_MS	(65535 - (1000 * 5)) 
....................  
.................... #DEFINE POSICAO_HOME1                   0 // 000          
.................... #DEFINE POSICAO_HOME2                   1 // 001 
.................... #DEFINE POSICAO_ALIMENTADOR            	2 // 010 
.................... #DEFINE POSICAO_SOLDA_ESTAGIO1          3 // 011 
.................... #DEFINE POSICAO_SOLDA_ESTAGIO2          4 // 100 
.................... #DEFINE POSICAO_DISPENSADOR             5 // 101 
.................... #DEFINE POSICAO_HOME3                   6 // 110 
.................... #DEFINE STOP                            7 // 111 
....................  
.................... #DEFINE FAROL_VERMELHO					0 
.................... #DEFINE FAROL_VERDE						1 
.................... #DEFINE MAQUINA1						1 
.................... #DEFINE MAQUINA2						2 
.................... #DEFINE velocity_x                      300 
.................... #DEFINE velocity_y                      300 
.................... #DEFINE velocity_flip                   1000 
.................... #DEFINE velocity_z                      2000 
....................  
.................... #DEFINE FAROL_POSICAO_SOLDAGEM			  1 
.................... #DEFINE FAROL_SOLDAR					  2 
.................... #DEFINE FAROL_DISPENSAR_PLACA             3 
.................... #DEFINE FAROL_ALIMENTACAO_PLACA_ESTAGIO1  4  
.................... #DEFINE FAROL_POSICAO_ALIMENTACAO_PLACA   5  
....................  
.................... #DEFINE LIMTE_MAX_X_1					  4300						    
.................... #DEFINE LIMTE_MAX_Y_1					  5540 
.................... #DEFINE LIMTE_MAX_Z_1                      500 
....................  
.................... #DEFINE LIMTE_MIN_X_1					  1300						    
.................... #DEFINE LIMTE_MIN_Y_1					  1000 
.................... #DEFINE LIMTE_MIN_Z_1                      0 
....................  
.................... #DEFINE LIMTE_MAX_X_2					  1400						    
.................... #DEFINE LIMTE_MAX_Y_2					  4247 
.................... #DEFINE LIMTE_MAX_Z_2                      300 
....................  
.................... #DEFINE LIMTE_MIN_X_2					  0						    
.................... #DEFINE LIMTE_MIN_Y_2					  0 
.................... #DEFINE LIMTE_MIN_Z_2                     0 
.................... #DEFINE MODO_SOLDAR						  0 
.................... #DEFINE MODO_EDITA_PONTOS                 1 
....................  
.................... int        n_maquina = 1; 
.................... short int  I2C_OCUPADA = FALSE; 
.................... short int  TEM_PLACA = FALSE; 
.................... short int trata_timer_zero_modo = 0; 
.................... long int  contador_tempo = 0; 
.................... long int  tempo = 0 ; 
.................... long int  tempo_aplicacao; 
.................... int       n_programas = 20; 
.................... int       numero_pontos = 16;	 
.................... int       enable_checa_farol = 1; 
.................... int       n_placas; 
.................... short int first_time;    
.................... int       programa; 
.................... short int estouro_timer1; 
.................... short int estouro_timer3; 
.................... short int estouro_timer0; 
.................... long int  coordenada_x_armazenado; 
.................... long int  coordenada_y_armazenado; 
.................... long int  coordenada_z_armazenado; 
.................... int       steps_armazenados; 
.................... int	      tem_programa; 
.................... int       dado; 
.................... int       valor; 
.................... long int  velocidade_x; 
.................... long int  velocidade_y;   
.................... long int  velocidade_flip;  
.................... long int  velocidade_z; 
.................... long int  contador_step_x_inicial; 
.................... long int  contador_step_y_inicial; 
.................... long int  contador_step_flip_inicial; 
.................... long int  contador_step_z_inicial; 
.................... long int  contador_rampa_subida_x; 
.................... long int  contador_rampa_descida_x; 
.................... long int  contador_rampa_subida_y; 
.................... long int  contador_rampa_descida_y; 
.................... long int  contador_rampa_subida_flip; 
.................... long int  contador_rampa_descida_flip; 
.................... long int  contador_rampa_subida_z; 
.................... long int  contador_rampa_descida_z; 
....................  
.................... int       passo=0; 
.................... long int  addr; 
.................... int       numero_de_passos; 
.................... long int  posicao_x[20]={3519,3550,3692,3728,3663,3744,3383,3325,4003,4041,4183,4214,4150,4231,3876,3811,4128,3603,3603,3603};   
.................... long int  posicao_y[20]={4402,4402,2549,2549,2493,2493,2493,2493,4402,4402,2549,2549,2493,2493,2493,2493,4493,4493,4493,3493};  
.................... long int  posicao_z[20]={300,300,300,300,300,300,300,300,300,300,300,300,300,300,300,300,300,300,300,300}; 
.................... long int  posicao_x_2[20]={766,800,935,974,898,979,635,552,274,302,443,478,410,480,133,76,640,105,50,50};   
.................... long int  posicao_y_2[20]={3719,3719,1862,1862,1810,1810,1810,1810,3719,3719,1867,1867,1810,1810,1810,1810,3624,3624,3624,2900};  
.................... long int  posicao_z_2[20]={292,292,292,292,292,292,292,292,292,292,292,292,292,292,292,292,292,292,292,292}; 
.................... long int  z_soldar_home = 250; 
.................... long int  z_soldar_home_2 = 150; 
.................... //396 
....................  
.................... int       tipo_soldagem[20]={0,0,0,0,1,2,1,2,0,0,0,0,0,0,0,0,0,0,0};//0=solda terminal led e capacitor, 1= mola grande ,2 = mola pequena 
.................... int       tipo_soldagem_2[20]={0,0,0,0,1,2,1,2,0,0,0,0,0,0,0,0,0,0,0,0};//0=solda terminal led e capacitor, 1= mola grande ,2 = mola pequena 
....................  
....................  
.................... int le_posicao_da_maquina2(void); 
.................... int le_posicao_da_maquina1(void); 
.................... void envia_posicao_para_maquina1(int n_posicao); 
.................... void envia_posicao_para_maquina2(int n_posicao); 
.................... int desaciona_mecanismo_de_entrada(void); 
.................... int desaciona_mecanismo_de_saida(void); 
.................... int acionar_pressor(void); 
.................... int checa_farol_1(int n_step); 
.................... int posicao_soldagem(int n_maquina); 
.................... void erro_rot(int n_erro); 
.................... int home_maquina_1(void); 
.................... int home_maquina_2(void); 
.................... void grava_coordenada_na_eeprom(int passo,long int coordenada_x,long int coordenada_y,long int coordenada_z); 
.................... void  pega_data_eeprom(int passo); 
.................... void erro_rot(int n_erro); 
.................... void aciona_alimentador_solda(long int t_aplicacao,int estagio); 
.................... void	solda_placa_default(void); 
.................... void alinha_bandeja1_x(void); 
.................... void maquina_estados1(int modo);  
.................... void maquina_estados2(int modo);  
.................... int posicao_alimentacao_placa(int n_maquina); 
....................  
.................... #include "pcf8574.c" 
....................  
.................... short int ack; 
.................... int	lcdcoluna = 1; 
.................... int	lcdlinha  = 1; 
....................  
....................  
.................... void escreve_pcf8574(int dispositivo,int data) { 
....................  
....................    I2C_OCUPADA == TRUE; 
....................    i2c_start(); 
*
01D00:  BSF    FC5.0
01D02:  BTFSC  FC5.0
01D04:  BRA    1D02
....................    ack=i2c_write(0x40 |(dispositivo << 1)); 
01D06:  BCF    FD8.0
01D08:  MOVLB  1
01D0A:  RLCF   xAA,W
01D0C:  IORLW  40
01D0E:  MOVWF  xAC
01D10:  CLRF   16
01D12:  BTFSC  FF2.7
01D14:  BSF    16.7
01D16:  BCF    FF2.7
01D18:  MOVFF  FE8,223
01D1C:  MOVLB  0
01D1E:  RCALL  1B28
01D20:  BTFSC  16.7
01D22:  BSF    FF2.7
01D24:  MOVF   01,W
01D26:  BCF    1E.7
01D28:  BTFSC  01.0
01D2A:  BSF    1E.7
01D2C:  CLRF   16
01D2E:  BTFSC  FF2.7
01D30:  BSF    16.7
01D32:  BCF    FF2.7
....................    ack=i2c_write(data); 
01D34:  MOVFF  1AB,223
01D38:  RCALL  1B28
01D3A:  BTFSC  16.7
01D3C:  BSF    FF2.7
01D3E:  MOVF   01,W
01D40:  BCF    1E.7
01D42:  BTFSC  01.0
01D44:  BSF    1E.7
....................    i2c_stop(); 
01D46:  BSF    FC5.2
01D48:  BTFSC  FC5.2
01D4A:  BRA    1D48
....................    ack=!ack; 
01D4C:  BTG    1E.7
....................    I2C_OCUPADA == FALSE; 
01D4E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... int le_pcf8574(int dispositivo) { 
....................    int data; 
....................  
....................    I2C_OCUPADA == TRUE; 
....................    i2c_start(); 
....................    i2c_write(0x41 |(dispositivo << 1)); 
....................    data=i2c_read(0); 
....................    i2c_stop(); 
....................    ack=!ack; 
....................    I2C_OCUPADA == FALSE; 
.................... 	return(data); 
....................     
.................... } 
....................  
....................  
.................... int le_pcf8574A(int dispositivo) { 
....................    int data; 
....................  
....................    I2C_OCUPADA == TRUE; 
....................    i2c_start(); 
*
02C12:  BSF    FC5.0
02C14:  BTFSC  FC5.0
02C16:  BRA    2C14
....................    i2c_write(0x71 |(dispositivo << 1)); 
02C18:  BCF    FD8.0
02C1A:  MOVLB  1
02C1C:  RLCF   xA1,W
02C1E:  IORLW  71
02C20:  MOVWF  xA3
02C22:  CLRF   16
02C24:  BTFSC  FF2.7
02C26:  BSF    16.7
02C28:  BCF    FF2.7
02C2A:  MOVFF  FE8,223
02C2E:  MOVLB  0
02C30:  CALL   1B28
02C34:  BTFSC  16.7
02C36:  BSF    FF2.7
....................    data=i2c_read(0); 
02C38:  CLRF   00
02C3A:  CALL   2012
02C3E:  MOVFF  01,1A2
....................    i2c_stop(); 
02C42:  BSF    FC5.2
02C44:  BTFSC  FC5.2
02C46:  BRA    2C44
....................    ack=!ack; 
02C48:  BTG    1E.7
....................     
....................     I2C_OCUPADA == FALSE; 
.................... 	return(data); 
02C4A:  MOVLB  1
02C4C:  MOVFF  1A2,01
02C50:  MOVLB  0
02C52:  RETURN 0
.................... } 
....................  
....................  
.................... #include "pca9555.c" 
....................  
....................  
....................  
.................... void escreve_PCA9555(int dispositivo,int comando,int data1,int data2) { 
....................  
....................    I2C_OCUPADA == TRUE; 
....................  
....................    i2c_start(); 
*
01B44:  BSF    FC5.0
01B46:  BTFSC  FC5.0
01B48:  BRA    1B46
....................    ack=i2c_write(0x40 |(dispositivo << 1)); 
01B4A:  BCF    FD8.0
01B4C:  MOVLB  2
01B4E:  RLCF   x1E,W
01B50:  IORLW  40
01B52:  MOVWF  x22
01B54:  MOVWF  x23
01B56:  MOVLB  0
01B58:  RCALL  1B28
01B5A:  MOVF   01,W
01B5C:  BCF    1E.7
01B5E:  BTFSC  01.0
01B60:  BSF    1E.7
....................    ack=i2c_write(comando); 
01B62:  MOVFF  21F,223
01B66:  RCALL  1B28
01B68:  MOVF   01,W
01B6A:  BCF    1E.7
01B6C:  BTFSC  01.0
01B6E:  BSF    1E.7
....................    ack=i2c_write(data2); 
01B70:  MOVFF  221,223
01B74:  RCALL  1B28
01B76:  MOVF   01,W
01B78:  BCF    1E.7
01B7A:  BTFSC  01.0
01B7C:  BSF    1E.7
....................    ack=i2c_write(data1); 
01B7E:  MOVFF  220,223
01B82:  RCALL  1B28
01B84:  MOVF   01,W
01B86:  BCF    1E.7
01B88:  BTFSC  01.0
01B8A:  BSF    1E.7
....................    i2c_stop(); 
01B8C:  BSF    FC5.2
01B8E:  BTFSC  FC5.2
01B90:  BRA    1B8E
....................    ack=!ack; 
01B92:  BTG    1E.7
....................  
....................   I2C_OCUPADA == FALSE; 
01B94:  RETURN 0
....................  
.................... }   
....................  
....................  
.................... unsigned long  int le_PCA9555(int dispositivo,int comando) { 
*
021FE:  MOVLB  1
02200:  CLRF   xA8
02202:  CLRF   xA7
02204:  CLRF   xA9
....................      
....................    unsigned long int data1 = 0x0000;  
....................    int data2= 0x00; 
....................  
....................    I2C_OCUPADA == TRUE; 
....................  
....................    i2c_start(); 	 
02206:  BSF    FC5.0
02208:  BTFSC  FC5.0
0220A:  BRA    2208
....................    ack=i2c_write(0x40 |(dispositivo << 1));  
0220C:  BCF    FD8.0
0220E:  RLCF   xA5,W
02210:  IORLW  40
02212:  MOVWF  xAA
02214:  CLRF   16
02216:  BTFSC  FF2.7
02218:  BSF    16.7
0221A:  BCF    FF2.7
0221C:  MOVFF  FE8,223
02220:  MOVLB  0
02222:  RCALL  1B28
02224:  BTFSC  16.7
02226:  BSF    FF2.7
02228:  MOVF   01,W
0222A:  BCF    1E.7
0222C:  BTFSC  01.0
0222E:  BSF    1E.7
02230:  CLRF   16
02232:  BTFSC  FF2.7
02234:  BSF    16.7
02236:  BCF    FF2.7
....................    ack=i2c_write(comando); 
02238:  MOVFF  1A6,223
0223C:  RCALL  1B28
0223E:  BTFSC  16.7
02240:  BSF    FF2.7
02242:  MOVF   01,W
02244:  BCF    1E.7
02246:  BTFSC  01.0
02248:  BSF    1E.7
....................    i2c_start(); 
0224A:  BSF    FC5.1
0224C:  BTFSC  FC5.1
0224E:  BRA    224C
....................    ack=i2c_write(0x41 |(dispositivo << 1)); 
02250:  BCF    FD8.0
02252:  MOVLB  1
02254:  RLCF   xA5,W
02256:  IORLW  41
02258:  MOVWF  xAA
0225A:  CLRF   16
0225C:  BTFSC  FF2.7
0225E:  BSF    16.7
02260:  BCF    FF2.7
02262:  MOVFF  FE8,223
02266:  MOVLB  0
02268:  RCALL  1B28
0226A:  BTFSC  16.7
0226C:  BSF    FF2.7
0226E:  MOVF   01,W
02270:  BCF    1E.7
02272:  BTFSC  01.0
02274:  BSF    1E.7
....................    data2=i2c_read(1);            // acknoledgment 
02276:  MOVLW  01
02278:  MOVWF  00
0227A:  RCALL  2012
0227C:  MOVFF  01,1A9
....................    data1=i2c_read(0) << 8;      // no  acknoledgment 
02280:  CLRF   00
02282:  RCALL  2012
02284:  MOVFF  01,1A8
02288:  MOVLB  1
0228A:  CLRF   xA7
....................    i2c_stop(); 
0228C:  BSF    FC5.2
0228E:  BTFSC  FC5.2
02290:  BRA    228E
....................    ack=!ack; 
02292:  BTG    1E.7
....................    data1|=data2; 
02294:  MOVF   xA9,W
02296:  IORWF  xA7,F
....................    I2C_OCUPADA == FALSE;	 
....................    
....................    return(data1); 
02298:  MOVFF  1A7,01
0229C:  MOVFF  1A8,02
022A0:  MOVLB  0
022A2:  RETURN 0
....................  
.................... }     
....................  
.................... #include "display.c"  
....................  
....................  
....................  
....................  
....................  
.................... void  write ( char  dado) 
.................... { 
.................... 	 
....................  
.................... 	delay_us(30); 
*
01D78:  MOVLW  31
01D7A:  MOVWF  00
01D7C:  DECFSZ 00,F
01D7E:  BRA    1D7C
01D80:  BRA    1D82
.................... 	escreve_pcf8574(0x00,dado); 
01D82:  MOVLB  1
01D84:  CLRF   xAA
01D86:  MOVFF  1A9,1AB
01D8A:  MOVLB  0
01D8C:  RCALL  1D00
.................... 	delay_us(30); 
01D8E:  MOVLW  31
01D90:  MOVWF  00
01D92:  DECFSZ 00,F
01D94:  BRA    1D92
01D96:  BRA    1D98
.................... 	output_high (E); 
01D98:  BCF    F92.0
01D9A:  BSF    F89.0
.................... 	delay_us(30); 
01D9C:  MOVLW  31
01D9E:  MOVWF  00
01DA0:  DECFSZ 00,F
01DA2:  BRA    1DA0
01DA4:  BRA    1DA6
.................... 	output_low  (E) ; 
01DA6:  BCF    F92.0
01DA8:  BCF    F89.0
.................... 	delay_us(30); 
01DAA:  MOVLW  31
01DAC:  MOVWF  00
01DAE:  DECFSZ 00,F
01DB0:  BRA    1DAE
01DB2:  BRA    1DB4
01DB4:  RETURN 0
....................  
....................  
....................  
.................... } 
....................  
....................  
.................... void  displayprog (int valor) 
.................... { 
.................... 	output_low (RS); 
01DB6:  BCF    F93.5
01DB8:  BCF    F8A.5
.................... 	write      (valor); 
01DBA:  MOVFF  1A8,1A9
01DBE:  RCALL  1D78
01DC0:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... void limpa_display (void) 
.................... { 
....................  	displayprog (0x1); 
*
01F7C:  MOVLW  01
01F7E:  MOVLB  1
01F80:  MOVWF  xA8
01F82:  MOVLB  0
01F84:  RCALL  1DB6
.................... 	delay_ms(5); 
01F86:  MOVLW  05
01F88:  MOVLB  2
01F8A:  MOVWF  x17
01F8C:  MOVLB  0
01F8E:  RCALL  1D50
01F90:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... void inicializa_display(void) 
.................... { 
....................  
....................     escreve_pcf8574(0x00,0Xff); //;output_b(0xff);				//	porta_display (0XFF); 
*
01DC2:  MOVLB  1
01DC4:  CLRF   xAA
01DC6:  SETF   xAB
01DC8:  MOVLB  0
01DCA:  RCALL  1D00
.................... 	output_low(E); 
01DCC:  BCF    F92.0
01DCE:  BCF    F89.0
.................... 	output_high(RS); 
01DD0:  BCF    F93.5
01DD2:  BSF    F8A.5
.................... 	delay_ms(15); 
01DD4:  MOVLW  0F
01DD6:  MOVLB  2
01DD8:  MOVWF  x17
01DDA:  MOVLB  0
01DDC:  RCALL  1D50
.................... 	displayprog(0x38);      // 2 linha / 5x7 /8 bit 
01DDE:  MOVLW  38
01DE0:  MOVLB  1
01DE2:  MOVWF  xA8
01DE4:  MOVLB  0
01DE6:  RCALL  1DB6
.................... 	delay_ms(15); 
01DE8:  MOVLW  0F
01DEA:  MOVLB  2
01DEC:  MOVWF  x17
01DEE:  MOVLB  0
01DF0:  RCALL  1D50
.................... 	displayprog(0x0c);		// display aceso s/ cursor 
01DF2:  MOVLW  0C
01DF4:  MOVLB  1
01DF6:  MOVWF  xA8
01DF8:  MOVLB  0
01DFA:  RCALL  1DB6
.................... 	delay_ms(15); 
01DFC:  MOVLW  0F
01DFE:  MOVLB  2
01E00:  MOVWF  x17
01E02:  MOVLB  0
01E04:  RCALL  1D50
.................... 	displayprog(0x06);      // escreve deslocando o cursor para direita 
01E06:  MOVLW  06
01E08:  MOVLB  1
01E0A:  MOVWF  xA8
01E0C:  MOVLB  0
01E0E:  RCALL  1DB6
.................... 	delay_ms(15); 
01E10:  MOVLW  0F
01E12:  MOVLB  2
01E14:  MOVWF  x17
01E16:  MOVLB  0
01E18:  RCALL  1D50
.................... 	lcdcoluna = 1; 
01E1A:  MOVLW  01
01E1C:  MOVLB  1
01E1E:  MOVWF  x74
.................... 	lcdlinha = 1; 
01E20:  MOVWF  x75
01E22:  MOVLB  0
01E24:  GOTO   B15A (RETURN)
.................... } 
....................  
....................  
.................... void	posiciona_cursor (int linha,int coluna) 
.................... { 
....................  
.................... 	lcdcoluna = coluna; 
*
01F92:  MOVFF  1A6,174
.................... 	lcdlinha  = linha; 
01F96:  MOVFF  1A5,175
....................  
.................... 	int	x; 
.................... 	if (linha == 1)	x=(0x00 + coluna) - 1; 
01F9A:  MOVLB  1
01F9C:  DECFSZ xA5,W
01F9E:  BRA    1FA6
01FA0:  MOVLW  01
01FA2:  SUBWF  xA6,W
01FA4:  MOVWF  xA7
.................... 	if (linha == 2) x=(0x40 + coluna) - 1;  
01FA6:  MOVF   xA5,W
01FA8:  SUBLW  02
01FAA:  BNZ   1FB4
01FAC:  MOVLW  40
01FAE:  ADDWF  xA6,W
01FB0:  ADDLW  FF
01FB2:  MOVWF  xA7
....................     if (linha == 3) x=(0x14 + coluna) - 1; 
01FB4:  MOVF   xA5,W
01FB6:  SUBLW  03
01FB8:  BNZ   1FC2
01FBA:  MOVLW  14
01FBC:  ADDWF  xA6,W
01FBE:  ADDLW  FF
01FC0:  MOVWF  xA7
.................... 	if (linha == 4) x=(0x54 + coluna) - 1; 
01FC2:  MOVF   xA5,W
01FC4:  SUBLW  04
01FC6:  BNZ   1FD0
01FC8:  MOVLW  54
01FCA:  ADDWF  xA6,W
01FCC:  ADDLW  FF
01FCE:  MOVWF  xA7
.................... 	x =x | 0x80; 
01FD0:  BSF    xA7.7
.................... 	displayprog (x); 
01FD2:  MOVFF  1A7,1A8
01FD6:  MOVLB  0
01FD8:  RCALL  1DB6
.................... 	delay_us(100); 
01FDA:  MOVLW  A6
01FDC:  MOVWF  00
01FDE:  DECFSZ 00,F
01FE0:  BRA    1FDE
01FE2:  NOP   
01FE4:  RETURN 0
.................... } 
....................  
....................  
.................... void display	(char  c) 
.................... { 
....................  
.................... 	output_high (RS); 
01FE6:  BCF    F93.5
01FE8:  BSF    F8A.5
.................... 	write (c); 
01FEA:  MOVFF  1A5,1A9
01FEE:  RCALL  1D78
01FF0:  RETURN 0
....................  
.................... } 
....................  
....................  
....................  
.................... void lcd_putc( char c) { 
.................... 	// \n nova linha muda o cursor para uma linha abaixo 
....................     // \r retorno 
....................     // \f limpa display 
....................  
....................  
....................    switch (c) { 
*
02586:  MOVLB  1
02588:  MOVF   xA4,W
0258A:  XORLW  0C
0258C:  MOVLB  0
0258E:  BZ    259A
02590:  XORLW  06
02592:  BZ    25A6
02594:  XORLW  07
02596:  BZ    25BA
02598:  BRA    25CE
....................      case '\f'   : limpa_display(); 
0259A:  RCALL  1F7C
....................                    lcdlinha = 1; 
0259C:  MOVLW  01
0259E:  MOVLB  1
025A0:  MOVWF  x75
.................... 				   lcdcoluna= 1; 
025A2:  MOVWF  x74
....................                    break; 
025A4:  BRA    25D6
....................  
....................      case '\n'   : posiciona_cursor(++lcdlinha,lcdcoluna);  
025A6:  MOVLB  1
025A8:  INCF   x75,F
025AA:  MOVFF  175,1A5
025AE:  MOVFF  174,1A6
025B2:  MOVLB  0
025B4:  RCALL  1F92
.................... 			       break; 
025B6:  MOVLB  1
025B8:  BRA    25D6
....................  
....................      case '\r'   : posiciona_cursor(lcdlinha,1);  
025BA:  MOVFF  175,1A5
025BE:  MOVLW  01
025C0:  MOVLB  1
025C2:  MOVWF  xA6
025C4:  MOVLB  0
025C6:  RCALL  1F92
....................                    break; 
025C8:  MOVLB  1
025CA:  BRA    25D6
025CC:  MOVLB  0
....................  
....................      default     : display(c);   
025CE:  MOVFF  1A4,1A5
025D2:  RCALL  1FE6
....................                    break; 
025D4:  MOVLB  1
....................    } 
025D6:  MOVLB  0
025D8:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... void Show_String(char matriz[]) 
.................... { 
.................... 	int result; 
.................... 	int	a; 
.................... 	char x1[21]; 
....................  
.................... 	strcpy (x1,matriz); 
.................... 	result = strlen(x1); 
.................... 	for (a=0;a < result;a++) 
....................   { 
.................... 	display(x1[a]); 
....................   } 
.................... } 
....................  
.................... #include "24c64.c" 
....................  
....................  
.................... void write_ext_eeprom(long int address,int data) { 
....................  
....................    disable_interrupts(GLOBAL); 
*
01EE0:  BCF    FF2.6
01EE2:  BCF    FF2.7
01EE4:  BTFSC  FF2.7
01EE6:  BRA    1EE2
....................    i2c_start(); 
01EE8:  BSF    FC5.0
01EEA:  BTFSC  FC5.0
01EEC:  BRA    1EEA
01EEE:  CLRF   16
01EF0:  BTFSC  FF2.7
01EF2:  BSF    16.7
01EF4:  BCF    FF2.7
....................    ack=i2c_write(0xa0); 
01EF6:  MOVLW  A0
01EF8:  MOVLB  2
01EFA:  MOVWF  x23
01EFC:  MOVLB  0
01EFE:  RCALL  1B28
01F00:  BTFSC  16.7
01F02:  BSF    FF2.7
01F04:  MOVF   01,W
01F06:  BCF    1E.7
01F08:  BTFSC  01.0
01F0A:  BSF    1E.7
....................    ack=i2c_write(address >> 8); 
01F0C:  MOVFF  215,217
01F10:  MOVLB  2
01F12:  CLRF   x18
01F14:  CLRF   16
01F16:  BTFSC  FF2.7
01F18:  BSF    16.7
01F1A:  BCF    FF2.7
01F1C:  MOVFF  215,223
01F20:  MOVLB  0
01F22:  RCALL  1B28
01F24:  BTFSC  16.7
01F26:  BSF    FF2.7
01F28:  MOVF   01,W
01F2A:  BCF    1E.7
01F2C:  BTFSC  01.0
01F2E:  BSF    1E.7
01F30:  CLRF   16
01F32:  BTFSC  FF2.7
01F34:  BSF    16.7
01F36:  BCF    FF2.7
....................    ack=i2c_write(address); 
01F38:  MOVFF  214,223
01F3C:  RCALL  1B28
01F3E:  BTFSC  16.7
01F40:  BSF    FF2.7
01F42:  MOVF   01,W
01F44:  BCF    1E.7
01F46:  BTFSC  01.0
01F48:  BSF    1E.7
01F4A:  CLRF   16
01F4C:  BTFSC  FF2.7
01F4E:  BSF    16.7
01F50:  BCF    FF2.7
....................    ack=i2c_write(data); 
01F52:  MOVFF  216,223
01F56:  RCALL  1B28
01F58:  BTFSC  16.7
01F5A:  BSF    FF2.7
01F5C:  MOVF   01,W
01F5E:  BCF    1E.7
01F60:  BTFSC  01.0
01F62:  BSF    1E.7
....................    i2c_stop(); 
01F64:  BSF    FC5.2
01F66:  BTFSC  FC5.2
01F68:  BRA    1F66
....................    ack=!ack; 
01F6A:  BTG    1E.7
....................    delay_ms(5); 
01F6C:  MOVLW  05
01F6E:  MOVLB  2
01F70:  MOVWF  x17
01F72:  MOVLB  0
01F74:  RCALL  1D50
....................    enable_interrupts(GLOBAL); 
01F76:  MOVLW  C0
01F78:  IORWF  FF2,F
01F7A:  RETURN 0
....................  
.................... } 
....................  
....................  
....................  
.................... int read_ext_eeprom(long int address) { 
....................    int data; 
....................  
....................    disable_interrupts(GLOBAL); 
*
0202E:  BCF    FF2.6
02030:  BCF    FF2.7
02032:  BTFSC  FF2.7
02034:  BRA    2030
....................    i2c_start(); 
02036:  BSF    FC5.0
02038:  BTFSC  FC5.0
0203A:  BRA    2038
0203C:  CLRF   16
0203E:  BTFSC  FF2.7
02040:  BSF    16.7
02042:  BCF    FF2.7
....................    i2c_write(0xa0); 
02044:  MOVLW  A0
02046:  MOVLB  2
02048:  MOVWF  x23
0204A:  MOVLB  0
0204C:  RCALL  1B28
0204E:  BTFSC  16.7
02050:  BSF    FF2.7
....................    i2c_write(address >> 8); 
02052:  MOVFF  18D,18F
02056:  MOVLB  1
02058:  CLRF   x90
0205A:  CLRF   16
0205C:  BTFSC  FF2.7
0205E:  BSF    16.7
02060:  BCF    FF2.7
02062:  MOVFF  18D,223
02066:  MOVLB  0
02068:  RCALL  1B28
0206A:  BTFSC  16.7
0206C:  BSF    FF2.7
0206E:  CLRF   16
02070:  BTFSC  FF2.7
02072:  BSF    16.7
02074:  BCF    FF2.7
....................    i2c_write(address); 
02076:  MOVFF  18C,223
0207A:  RCALL  1B28
0207C:  BTFSC  16.7
0207E:  BSF    FF2.7
....................    i2c_start(); 
02080:  BSF    FC5.1
02082:  BTFSC  FC5.1
02084:  BRA    2082
02086:  CLRF   16
02088:  BTFSC  FF2.7
0208A:  BSF    16.7
0208C:  BCF    FF2.7
....................    i2c_write(0xa1); 
0208E:  MOVLW  A1
02090:  MOVLB  2
02092:  MOVWF  x23
02094:  MOVLB  0
02096:  RCALL  1B28
02098:  BTFSC  16.7
0209A:  BSF    FF2.7
....................    data=i2c_read(0); 
0209C:  CLRF   00
0209E:  RCALL  2012
020A0:  MOVFF  01,18E
....................    i2c_stop(); 
020A4:  BSF    FC5.2
020A6:  BTFSC  FC5.2
020A8:  BRA    20A6
....................    ack=!ack; 
020AA:  BTG    1E.7
....................    delay_ms(5); 
020AC:  MOVLW  05
020AE:  MOVLB  2
020B0:  MOVWF  x17
020B2:  MOVLB  0
020B4:  RCALL  1D50
....................    enable_interrupts(GLOBAL); 
020B6:  MOVLW  C0
020B8:  IORWF  FF2,F
....................  
....................    return(data); 
020BA:  MOVLB  1
020BC:  MOVFF  18E,01
020C0:  MOVLB  0
020C2:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... void init_ext_eeprom() { 
.................... 	int a; 
....................  
....................     output_float(EEPROM_SCL); 
020C4:  BSF    F94.3
....................     output_float(EEPROM_SDA); 
020C6:  BSF    F94.4
....................  
.................... 	write_ext_eeprom(0x00ff,0xAA); 
020C8:  MOVLB  2
020CA:  CLRF   x15
020CC:  SETF   x14
020CE:  MOVLW  AA
020D0:  MOVWF  x16
020D2:  MOVLB  0
020D4:  RCALL  1EE0
.................... 	if (ack == false) 
020D6:  BTFSC  1E.7
020D8:  BRA    210C
.................... 	{ 
.................... 	limpa_display(); 
020DA:  RCALL  1F7C
.................... 	posiciona_cursor(1,1); 
020DC:  MOVLW  01
020DE:  MOVLB  1
020E0:  MOVWF  xA5
020E2:  MOVWF  xA6
020E4:  MOVLB  0
020E6:  RCALL  1F92
.................... 	display("erro de escrita "); 
020E8:  MOVLW  BA
020EA:  MOVWF  FF6
020EC:  MOVLW  00
020EE:  MOVWF  FF7
020F0:  RCALL  1FF2
.................... 	posiciona_cursor(2,1); 
020F2:  MOVLW  02
020F4:  MOVLB  1
020F6:  MOVWF  xA5
020F8:  MOVLW  01
020FA:  MOVWF  xA6
020FC:  MOVLB  0
020FE:  RCALL  1F92
.................... 	display("   EEPROM       "); 
02100:  MOVLW  CC
02102:  MOVWF  FF6
02104:  MOVLW  00
02106:  MOVWF  FF7
02108:  RCALL  1FF2
.................... 	while(true){} 
0210A:  BRA    210A
.................... 	} 
.................... 	 
.................... 	delay_ms(5);	 
0210C:  MOVLW  05
0210E:  MOVLB  2
02110:  MOVWF  x17
02112:  MOVLB  0
02114:  RCALL  1D50
....................  
.................... 	a = read_ext_eeprom(0x00ff); 
02116:  MOVLB  1
02118:  CLRF   x8D
0211A:  SETF   x8C
0211C:  MOVLB  0
0211E:  RCALL  202E
02120:  MOVFF  01,18B
.................... 	if (a != 0xAA) 
02124:  MOVLB  1
02126:  MOVF   x8B,W
02128:  SUBLW  AA
0212A:  BZ    2162
.................... 	{ 
.................... 	limpa_display(); 
0212C:  MOVLB  0
0212E:  RCALL  1F7C
.................... 	posiciona_cursor(1,1); 
02130:  MOVLW  01
02132:  MOVLB  1
02134:  MOVWF  xA5
02136:  MOVWF  xA6
02138:  MOVLB  0
0213A:  RCALL  1F92
.................... 	display("erro de leitura  "); 
0213C:  MOVLW  DE
0213E:  MOVWF  FF6
02140:  MOVLW  00
02142:  MOVWF  FF7
02144:  RCALL  1FF2
.................... 	posiciona_cursor(2,1); 
02146:  MOVLW  02
02148:  MOVLB  1
0214A:  MOVWF  xA5
0214C:  MOVLW  01
0214E:  MOVWF  xA6
02150:  MOVLB  0
02152:  RCALL  1F92
.................... 	display("     EEPROM      "); 
02154:  MOVLW  F0
02156:  MOVWF  FF6
02158:  MOVLW  00
0215A:  MOVWF  FF7
0215C:  RCALL  1FF2
.................... 	while(true){} 
0215E:  BRA    215E
02160:  MOVLB  1
.................... 	} 
02162:  MOVLB  0
02164:  GOTO   B16E (RETURN)
....................  
....................  
....................      
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
.................... #include "teclado_21_teclas.c" 
....................  
....................  
....................  
.................... #define		F1					10 
.................... #define		F2					11 
.................... #define     F3					12 
.................... #define		F4					13 
.................... #define     SETA_SUPERIOR   	14 
.................... #define     SETA_INFERIOR   	15  
.................... #define		SETA_DIREITA    	16  
.................... #define     SETA_ESQUERDA  	    17 
.................... #define     ESC					18 
.................... #define     ENTER				19	 
.................... #define     MENU				20 
....................  
....................  
....................  
....................  
.................... void Init_Keyboard(void) 
*
01E28:  CLRF   16
01E2A:  BTFSC  FF2.7
01E2C:  BSF    16.7
01E2E:  BCF    FF2.7
.................... { 
....................  
.................... 	escreve_PCA9555(0X01,0X06,0Xff,0xf8);// programa bit 0,bit 1,bit 2  como saida e os demais como entrada 
01E30:  MOVLW  01
01E32:  MOVLB  2
01E34:  MOVWF  x1E
01E36:  MOVLW  06
01E38:  MOVWF  x1F
01E3A:  SETF   x20
01E3C:  MOVLW  F8
01E3E:  MOVWF  x21
01E40:  MOVLB  0
01E42:  RCALL  1B44
01E44:  BTFSC  16.7
01E46:  BSF    FF2.7
01E48:  CLRF   16
01E4A:  BTFSC  FF2.7
01E4C:  BSF    16.7
01E4E:  BCF    FF2.7
....................  	escreve_PCA9555(0X01,0X02,0X00,0X07);//coloca colunas em  high level 
01E50:  MOVLW  01
01E52:  MOVLB  2
01E54:  MOVWF  x1E
01E56:  MOVLW  02
01E58:  MOVWF  x1F
01E5A:  CLRF   x20
01E5C:  MOVLW  07
01E5E:  MOVWF  x21
01E60:  MOVLB  0
01E62:  RCALL  1B44
01E64:  BTFSC  16.7
01E66:  BSF    FF2.7
01E68:  GOTO   B15E (RETURN)
....................  
....................  
.................... } 
....................  
.................... unsigned long int  Get_Key(void) 
*
022A4:  MOVLB  1
022A6:  CLRF   xA0
022A8:  CLRF   x9F
022AA:  MOVLW  06
022AC:  MOVWF  xA1
022AE:  MOVLW  7F
022B0:  MOVWF  xA2
.................... {	 
.................... 	long int dado = 0x0000; 
.................... 	int    coluna = 0x06; 
....................     int    mascara = 0x7f; 
.................... 	long int i; 
....................  
.................... 	for (i = 0 ; i < 3 ; i++) 
022B2:  CLRF   xA4
022B4:  CLRF   xA3
022B6:  MOVF   xA4,F
022B8:  BNZ   2336
022BA:  MOVF   xA3,W
022BC:  SUBLW  02
022BE:  BNC   2336
.................... 	{ 
....................     	coluna -= i; 
022C0:  MOVF   xA3,W
022C2:  SUBWF  xA1,F
022C4:  CLRF   16
022C6:  BTFSC  FF2.7
022C8:  BSF    16.7
022CA:  BCF    FF2.7
.................... 		escreve_PCA9555(0X01,0X02,0X00,coluna);     // coloca coluna  em  low level 
022CC:  MOVLW  01
022CE:  MOVLB  2
022D0:  MOVWF  x1E
022D2:  MOVLW  02
022D4:  MOVWF  x1F
022D6:  CLRF   x20
022D8:  MOVFF  1A1,221
022DC:  MOVLB  0
022DE:  RCALL  1B44
022E0:  BTFSC  16.7
022E2:  BSF    FF2.7
.................... 		dado =  le_PCA9555(0X01,0X00) >> 3;         // desloca bits 
022E4:  MOVLW  01
022E6:  MOVLB  1
022E8:  MOVWF  xA5
022EA:  CLRF   xA6
022EC:  MOVLB  0
022EE:  RCALL  21FE
022F0:  MOVLB  1
022F2:  RRCF   02,W
022F4:  MOVWF  xA0
022F6:  RRCF   01,W
022F8:  MOVWF  x9F
022FA:  RRCF   xA0,F
022FC:  RRCF   x9F,F
022FE:  RRCF   xA0,F
02300:  RRCF   x9F,F
02302:  MOVLW  1F
02304:  ANDWF  xA0,F
.................... 		dado &= mascara;  							// mascara bits 
02306:  MOVF   xA2,W
02308:  ANDWF  x9F,F
0230A:  CLRF   xA0
....................         dado = 127 - dado;                            
0230C:  MOVLW  7F
0230E:  BSF    FD8.0
02310:  SUBFWB x9F,F
02312:  MOVLW  00
02314:  SUBFWB xA0,F
.................... 		if(dado != 0) 
02316:  MOVF   x9F,F
02318:  BNZ   231E
0231A:  MOVF   xA0,F
0231C:  BZ    232E
.................... 			{ 
.................... 				i = i << 8; 
0231E:  MOVFF  1A3,1A4
02322:  CLRF   xA3
.................... 				dado |= i ; 
02324:  MOVF   xA3,W
02326:  IORWF  x9F,F
02328:  MOVF   xA4,W
0232A:  IORWF  xA0,F
.................... 		 		break; 
0232C:  BRA    2336
....................  
.................... 			}		 
0232E:  INCF   xA3,F
02330:  BTFSC  FD8.2
02332:  INCF   xA4,F
02334:  BRA    22B6
.................... 	} 
....................  
.................... 		 
....................     return(dado); 
02336:  MOVFF  19F,01
0233A:  MOVFF  1A0,02
0233E:  MOVLB  0
02340:  GOTO   2350 (RETURN)
.................... } 
....................  
.................... int Teclado(void) 
02344:  MOVLB  1
02346:  CLRF   x9D
02348:  CLRF   x9C
0234A:  CLRF   x9E
.................... {// lê o teclado 
....................  // se nenhuma tecla acionada retorna 0xff 
....................  // se acionada retorna o codigo da tecla 
....................  
....................    unsigned long int codigo_teclado = 0x0000; 
....................    int key_code = 0x00; 
....................  
....................    codigo_teclado = Get_Key(); 
0234C:  MOVLB  0
0234E:  BRA    22A4
02350:  MOVFF  02,19D
02354:  MOVFF  01,19C
....................    if(codigo_teclado == 0x00) return( key_code =0xff);	 
02358:  MOVLB  1
0235A:  MOVF   x9C,F
0235C:  BNZ   236A
0235E:  MOVF   x9D,F
02360:  BNZ   236A
02362:  SETF   x9E
02364:  MOVFF  19E,01
02368:  BRA    2582
....................  
.................... 	 
.................... 	switch(codigo_teclado){ 
0236A:  MOVF   x9C,W
0236C:  MOVWF  00
0236E:  MOVF   x9D,W
02370:  MOVWF  03
02372:  MOVLW  01
02374:  SUBWF  03,W
02376:  BNZ   2384
02378:  MOVLW  40
0237A:  SUBWF  00,W
0237C:  MOVLB  0
0237E:  BTFSC  FD8.2
02380:  BRA    24D8
02382:  MOVLB  1
02384:  MOVF   03,W
02386:  BNZ   2394
02388:  MOVLW  08
0238A:  SUBWF  00,W
0238C:  MOVLB  0
0238E:  BTFSC  FD8.2
02390:  BRA    24DE
02392:  MOVLB  1
02394:  MOVLW  01
02396:  SUBWF  03,W
02398:  BNZ   23A6
0239A:  MOVLW  08
0239C:  SUBWF  00,W
0239E:  MOVLB  0
023A0:  BTFSC  FD8.2
023A2:  BRA    24E6
023A4:  MOVLB  1
023A6:  MOVLW  02
023A8:  SUBWF  03,W
023AA:  BNZ   23B8
023AC:  MOVLW  08
023AE:  SUBWF  00,W
023B0:  MOVLB  0
023B2:  BTFSC  FD8.2
023B4:  BRA    24EE
023B6:  MOVLB  1
023B8:  MOVF   03,W
023BA:  BNZ   23C8
023BC:  MOVLW  10
023BE:  SUBWF  00,W
023C0:  MOVLB  0
023C2:  BTFSC  FD8.2
023C4:  BRA    24F6
023C6:  MOVLB  1
023C8:  MOVLW  01
023CA:  SUBWF  03,W
023CC:  BNZ   23DA
023CE:  MOVLW  10
023D0:  SUBWF  00,W
023D2:  MOVLB  0
023D4:  BTFSC  FD8.2
023D6:  BRA    24FE
023D8:  MOVLB  1
023DA:  MOVLW  02
023DC:  SUBWF  03,W
023DE:  BNZ   23EC
023E0:  MOVLW  10
023E2:  SUBWF  00,W
023E4:  MOVLB  0
023E6:  BTFSC  FD8.2
023E8:  BRA    2506
023EA:  MOVLB  1
023EC:  MOVF   03,W
023EE:  BNZ   23FC
023F0:  MOVLW  20
023F2:  SUBWF  00,W
023F4:  MOVLB  0
023F6:  BTFSC  FD8.2
023F8:  BRA    250E
023FA:  MOVLB  1
023FC:  MOVLW  01
023FE:  SUBWF  03,W
02400:  BNZ   240E
02402:  MOVLW  20
02404:  SUBWF  00,W
02406:  MOVLB  0
02408:  BTFSC  FD8.2
0240A:  BRA    2516
0240C:  MOVLB  1
0240E:  MOVLW  02
02410:  SUBWF  03,W
02412:  BNZ   2420
02414:  MOVLW  20
02416:  SUBWF  00,W
02418:  MOVLB  0
0241A:  BTFSC  FD8.2
0241C:  BRA    251E
0241E:  MOVLB  1
02420:  MOVF   03,W
02422:  BNZ   2430
02424:  MOVLW  01
02426:  SUBWF  00,W
02428:  MOVLB  0
0242A:  BTFSC  FD8.2
0242C:  BRA    2526
0242E:  MOVLB  1
02430:  MOVLW  02
02432:  SUBWF  03,W
02434:  BNZ   2442
02436:  MOVLW  01
02438:  SUBWF  00,W
0243A:  MOVLB  0
0243C:  BTFSC  FD8.2
0243E:  BRA    252E
02440:  MOVLB  1
02442:  MOVF   03,W
02444:  BNZ   2452
02446:  MOVLW  04
02448:  SUBWF  00,W
0244A:  MOVLB  0
0244C:  BTFSC  FD8.2
0244E:  BRA    2536
02450:  MOVLB  1
02452:  MOVLW  02
02454:  SUBWF  03,W
02456:  BNZ   2464
02458:  MOVLW  04
0245A:  SUBWF  00,W
0245C:  MOVLB  0
0245E:  BTFSC  FD8.2
02460:  BRA    253E
02462:  MOVLB  1
02464:  MOVF   03,W
02466:  BNZ   2474
02468:  MOVLW  40
0246A:  SUBWF  00,W
0246C:  MOVLB  0
0246E:  BTFSC  FD8.2
02470:  BRA    2546
02472:  MOVLB  1
02474:  MOVLW  02
02476:  SUBWF  03,W
02478:  BNZ   2486
0247A:  MOVLW  40
0247C:  SUBWF  00,W
0247E:  MOVLB  0
02480:  BTFSC  FD8.2
02482:  BRA    254E
02484:  MOVLB  1
02486:  MOVLW  01
02488:  SUBWF  03,W
0248A:  BNZ   2498
0248C:  MOVLW  01
0248E:  SUBWF  00,W
02490:  MOVLB  0
02492:  BTFSC  FD8.2
02494:  BRA    2556
02496:  MOVLB  1
02498:  MOVF   03,W
0249A:  BNZ   24A6
0249C:  MOVLW  02
0249E:  SUBWF  00,W
024A0:  MOVLB  0
024A2:  BZ    255E
024A4:  MOVLB  1
024A6:  MOVLW  02
024A8:  SUBWF  03,W
024AA:  BNZ   24B6
024AC:  MOVLW  02
024AE:  SUBWF  00,W
024B0:  MOVLB  0
024B2:  BZ    2566
024B4:  MOVLB  1
024B6:  MOVLW  01
024B8:  SUBWF  03,W
024BA:  BNZ   24C6
024BC:  MOVLW  04
024BE:  SUBWF  00,W
024C0:  MOVLB  0
024C2:  BZ    256E
024C4:  MOVLB  1
024C6:  MOVLW  01
024C8:  SUBWF  03,W
024CA:  BNZ   24D6
024CC:  MOVLW  02
024CE:  SUBWF  00,W
024D0:  MOVLB  0
024D2:  BZ    2576
024D4:  MOVLB  1
024D6:  BRA    257E
....................  
....................  
.................... 		case 320:key_code=0; 
024D8:  MOVLB  1
024DA:  CLRF   x9E
.................... 				break; 
024DC:  BRA    257E
....................  
.................... 		case 8:	key_code=1; 
024DE:  MOVLW  01
024E0:  MOVLB  1
024E2:  MOVWF  x9E
.................... 				break; 
024E4:  BRA    257E
....................  
.................... 		case 264:key_code=2; 
024E6:  MOVLW  02
024E8:  MOVLB  1
024EA:  MOVWF  x9E
.................... 				break; 
024EC:  BRA    257E
....................  
.................... 		case 520:key_code=3; 
024EE:  MOVLW  03
024F0:  MOVLB  1
024F2:  MOVWF  x9E
.................... 				break;	 
024F4:  BRA    257E
.................... 	 
.................... 		case 16: key_code=4; 
024F6:  MOVLW  04
024F8:  MOVLB  1
024FA:  MOVWF  x9E
.................... 				break; 
024FC:  BRA    257E
....................  
....................  
.................... 		case 272:key_code=5; 
024FE:  MOVLW  05
02500:  MOVLB  1
02502:  MOVWF  x9E
.................... 				break; 
02504:  BRA    257E
....................  
....................  
.................... 		case 528:key_code=6; 
02506:  MOVLW  06
02508:  MOVLB  1
0250A:  MOVWF  x9E
.................... 				break; 
0250C:  BRA    257E
....................  
....................  
.................... 		case 32:key_code=7; 
0250E:  MOVLW  07
02510:  MOVLB  1
02512:  MOVWF  x9E
.................... 				break; 
02514:  BRA    257E
....................  
....................  
.................... 		case 288:key_code=8; 
02516:  MOVLW  08
02518:  MOVLB  1
0251A:  MOVWF  x9E
.................... 				break; 
0251C:  BRA    257E
....................  
.................... 		case 544:key_code=9; 
0251E:  MOVLW  09
02520:  MOVLB  1
02522:  MOVWF  x9E
....................                 break; 
02524:  BRA    257E
....................  
.................... 		case 1:	key_code=F1; 
02526:  MOVLW  0A
02528:  MOVLB  1
0252A:  MOVWF  x9E
....................                 break; 
0252C:  BRA    257E
....................  
.................... 		case 513:key_code=F2; 
0252E:  MOVLW  0B
02530:  MOVLB  1
02532:  MOVWF  x9E
....................                 break; 
02534:  BRA    257E
....................  
.................... 		case 4:	key_code=F3; 
02536:  MOVLW  0C
02538:  MOVLB  1
0253A:  MOVWF  x9E
....................                 break; 
0253C:  BRA    257E
....................  
.................... 		case 516:key_code=F4; 
0253E:  MOVLW  0D
02540:  MOVLB  1
02542:  MOVWF  x9E
....................                 	break; 
02544:  BRA    257E
....................  
.................... 		case 64:key_code=ESC; 
02546:  MOVLW  12
02548:  MOVLB  1
0254A:  MOVWF  x9E
....................                 break; 
0254C:  BRA    257E
....................  
.................... 		case 576:key_code=ENTER; 
0254E:  MOVLW  13
02550:  MOVLB  1
02552:  MOVWF  x9E
....................                 break; 
02554:  BRA    257E
....................  
.................... 		case 257:key_code=SETA_SUPERIOR ; 
02556:  MOVLW  0E
02558:  MOVLB  1
0255A:  MOVWF  x9E
....................                 break; 
0255C:  BRA    257E
....................  
.................... 		case 2:	key_code=SETA_ESQUERDA ; 
0255E:  MOVLW  11
02560:  MOVLB  1
02562:  MOVWF  x9E
....................                 break; 
02564:  BRA    257E
....................  
.................... 		case 514:key_code=SETA_DIREITA ; 
02566:  MOVLW  10
02568:  MOVLB  1
0256A:  MOVWF  x9E
....................                 break; 
0256C:  BRA    257E
....................  
.................... 		case 260:key_code=SETA_INFERIOR; 
0256E:  MOVLW  0F
02570:  MOVLB  1
02572:  MOVWF  x9E
....................                 break; 
02574:  BRA    257E
....................  
.................... 		case 258:key_code=MENU; 
02576:  MOVLW  14
02578:  MOVLB  1
0257A:  MOVWF  x9E
....................                 break; 
0257C:  BRA    257E
....................  
....................  
.................... 	    default: 
.................... 				break; 
....................  
....................  	 
....................  
.................... 	} 
....................  
.................... 	return( key_code ); 
0257E:  MOVFF  19E,01
02582:  MOVLB  0
02584:  RETURN 0
....................  
....................  
.................... } 
....................  
....................  
.................... void	espera_desacionar_teclas(void) 
*
07FCA:  MOVLB  1
07FCC:  CLRF   x9B
.................... { 
....................   int   key_code = 0x00; 
....................   key_code = Teclado();	 
07FCE:  MOVLB  0
07FD0:  CALL   2344
07FD4:  MOVFF  01,19B
....................  
....................  
....................   while(key_code != 0xff) 
07FD8:  MOVLB  1
07FDA:  INCFSZ x9B,W
07FDC:  BRA    7FE0
07FDE:  BRA    7FEE
....................     { 
....................  
.................... 	     key_code = Teclado();		 
07FE0:  MOVLB  0
07FE2:  CALL   2344
07FE6:  MOVFF  01,19B
07FEA:  BRA    7FD8
07FEC:  MOVLB  1
....................  
.................... 	 
.................... 	}  
07FEE:  MOVLB  0
07FF0:  RETURN 0
....................    
....................  
.................... } 
....................  
.................... #include "stepper_motor.c" 
....................  
....................  
.................... #DEFINE     step_y			    pin_C2 
.................... #DEFINE     dir_y				pin_C1 
.................... #DEFINE     enable_y			pin_C0 
.................... #DEFINE     step_x 		        pin_D2 
.................... #DEFINE     dir_x				pin_D1 
.................... #DEFINE     enable_x			pin_D0 
.................... #DEFINE     step_z              pin_A5              
.................... #DEFINE     dir_z               pin_A4 
.................... #DEFINE     enable_z            pin_A3 
.................... #DEFINE     step_flip           pin_E2 
.................... #DEFINE     dir_flip            pin_E1  
.................... #DEFINE     enable_flip         pin_E0 
....................  
....................  
.................... long int buffer_saida; 
.................... long int contador_step_x; 
.................... long int contador_step_y; 
.................... long int contador_step_flip; 
.................... long int contador_step_z; 
.................... short int direita_flag; 
.................... short int esquerda_flag; 
.................... short int frente_flag; 
.................... short int atras_flag; 
.................... short int sobe_flag; 
.................... short int desce_flag; 
.................... short int sentido_horario_flag; 
.................... short int sentido_antihorario_flag; 
....................  
....................  
.................... void	one_step_x(void) 
.................... { 
....................  
.................... 	output_high(step_x); 
*
032D2:  BCF    F95.2
032D4:  BSF    F8C.2
.................... 	delay_us(10); 
032D6:  MOVLW  10
032D8:  MOVWF  00
032DA:  DECFSZ 00,F
032DC:  BRA    32DA
032DE:  NOP   
.................... 	output_low(step_x); 
032E0:  BCF    F95.2
032E2:  BCF    F8C.2
....................  
....................  
.................... 				if(esquerda_flag == true) 
032E4:  MOVLB  1
032E6:  BTFSS  x80.1
032E8:  BRA    32F2
.................... 										{ 
....................  
.................... 									 		contador_step_x ++ ; 
032EA:  INCF   x78,F
032EC:  BTFSC  FD8.2
032EE:  INCF   x79,F
....................  
.................... 										} 
032F0:  BRA    3302
.................... 											else 
.................... 												{	  
....................  
.................... 													if(contador_step_x != 0000)	contador_step_x -- ; 
032F2:  MOVF   x78,F
032F4:  BNZ   32FA
032F6:  MOVF   x79,F
032F8:  BZ    3302
032FA:  MOVF   x78,W
032FC:  BTFSC  FD8.2
032FE:  DECF   x79,F
03300:  DECF   x78,F
.................... 					 
.................... 												} 
03302:  MOVLB  0
03304:  RETURN 0
....................  
.................... 		 
.................... } 
....................  
.................... void	one_step_y(void) 
.................... { 
.................... //	posiciona_cursor(2,12); 
....................  
.................... 	output_high(step_y); 
*
03166:  BCF    F94.2
03168:  BSF    F8B.2
....................  	delay_us(10); 
0316A:  MOVLW  10
0316C:  MOVWF  00
0316E:  DECFSZ 00,F
03170:  BRA    316E
03172:  NOP   
.................... 	output_low(step_y); 
03174:  BCF    F94.2
03176:  BCF    F8B.2
....................  
....................  
....................  
.................... 					if(atras_flag == true) 
03178:  MOVLB  1
0317A:  BTFSS  x80.3
0317C:  BRA    3186
.................... 								{ 
....................  
.................... 							 		contador_step_y ++ ; 
0317E:  INCF   x7A,F
03180:  BTFSC  FD8.2
03182:  INCF   x7B,F
.................... 							 
....................  
....................  
.................... 								} 
03184:  BRA    3196
.................... 									else 
.................... 									{	  
.................... 											if(contador_step_y != 0000)	contador_step_y -- ; 
03186:  MOVF   x7A,F
03188:  BNZ   318E
0318A:  MOVF   x7B,F
0318C:  BZ    3196
0318E:  MOVF   x7A,W
03190:  BTFSC  FD8.2
03192:  DECF   x7B,F
03194:  DECF   x7A,F
.................... 									 
.................... 									 
....................  
.................... 													 
.................... 									} 
03196:  MOVLB  0
03198:  RETURN 0
.................... 								 
.................... 							 
.................... 						 
....................  
.................... //	print_long_int(contador_step_y); 
.................... } 
....................  
.................... void	one_step_y_negativo(void) 
.................... { 
.................... //	posiciona_cursor(2,12); 
....................  
.................... 	output_high(step_y); 
*
04E34:  BCF    F94.2
04E36:  BSF    F8B.2
....................  	delay_us(10); 
04E38:  MOVLW  10
04E3A:  MOVWF  00
04E3C:  DECFSZ 00,F
04E3E:  BRA    4E3C
04E40:  NOP   
.................... 	output_low(step_y); 
04E42:  BCF    F94.2
04E44:  BCF    F8B.2
....................  
....................  
....................  
.................... 					if(frente_flag == true) 
04E46:  MOVLB  1
04E48:  BTFSS  x80.2
04E4A:  BRA    4E54
.................... 								{ 
....................  
.................... 							 		contador_step_y ++ ; 
04E4C:  INCF   x7A,F
04E4E:  BTFSC  FD8.2
04E50:  INCF   x7B,F
.................... 							 
....................  
....................  
.................... 								} 
04E52:  BRA    4E64
.................... 									else 
.................... 									{	  
.................... 											if(contador_step_y != 0000)	contador_step_y -- ; 
04E54:  MOVF   x7A,F
04E56:  BNZ   4E5C
04E58:  MOVF   x7B,F
04E5A:  BZ    4E64
04E5C:  MOVF   x7A,W
04E5E:  BTFSC  FD8.2
04E60:  DECF   x7B,F
04E62:  DECF   x7A,F
.................... 									 
.................... 									 
....................  
.................... 													 
.................... 									} 
04E64:  MOVLB  0
04E66:  GOTO   502E (RETURN)
.................... 								 
.................... 							 
.................... 						 
....................  
.................... //	print_long_int(contador_step_y); 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... void one_step_flip(void) 
.................... { 
....................  
....................  
.................... 	output_high(step_flip); 
*
037BA:  BCF    F96.2
037BC:  BSF    F8D.2
....................  	delay_us(10); 
037BE:  MOVLW  10
037C0:  MOVWF  00
037C2:  DECFSZ 00,F
037C4:  BRA    37C2
037C6:  NOP   
.................... 	output_low(step_flip); 
037C8:  BCF    F96.2
037CA:  BCF    F8D.2
....................  
....................  
....................  
.................... 					if(sentido_horario_flag == true) 
037CC:  MOVLB  1
037CE:  BTFSS  x80.6
037D0:  BRA    37DA
.................... 								{ 
....................  
.................... 							 		contador_step_flip ++ ; 
037D2:  INCF   x7C,F
037D4:  BTFSC  FD8.2
037D6:  INCF   x7D,F
.................... 							 
....................  
....................  
.................... 								} 
037D8:  BRA    37EA
.................... 									else 
.................... 									{	  
.................... 											if(contador_step_flip != 0000)	contador_step_flip -- ; 
037DA:  MOVF   x7C,F
037DC:  BNZ   37E2
037DE:  MOVF   x7D,F
037E0:  BZ    37EA
037E2:  MOVF   x7C,W
037E4:  BTFSC  FD8.2
037E6:  DECF   x7D,F
037E8:  DECF   x7C,F
.................... 													 
.................... 									} 
037EA:  MOVLB  0
037EC:  RETURN 0
....................  
....................  
.................... } 
....................  
....................  
.................... void	one_step_z(void) 
.................... { 
....................  
.................... 	output_high(step_z); 
*
02E98:  BCF    F92.5
02E9A:  BSF    F89.5
....................  	delay_us(10); 
02E9C:  MOVLW  10
02E9E:  MOVWF  00
02EA0:  DECFSZ 00,F
02EA2:  BRA    2EA0
02EA4:  NOP   
.................... 	output_low(step_z); 
02EA6:  BCF    F92.5
02EA8:  BCF    F89.5
....................  
....................  
.................... 					if(desce_flag == true) 
02EAA:  MOVLB  1
02EAC:  BTFSS  x80.5
02EAE:  BRA    2EB8
.................... 								{ 
....................  
.................... 							 		contador_step_z ++ ; 
02EB0:  INCF   x7E,F
02EB2:  BTFSC  FD8.2
02EB4:  INCF   x7F,F
....................  
.................... 								}else 
02EB6:  BRA    2EC8
.................... 									{ 
.................... 	  
.................... 											if(contador_step_z != 0000)	contador_step_z -- ; 
02EB8:  MOVF   x7E,F
02EBA:  BNZ   2EC0
02EBC:  MOVF   x7F,F
02EBE:  BZ    2EC8
02EC0:  MOVF   x7E,W
02EC2:  BTFSC  FD8.2
02EC4:  DECF   x7F,F
02EC6:  DECF   x7E,F
.................... 	 
.................... 													 
.................... 									} 
02EC8:  MOVLB  0
02ECA:  RETURN 0
....................  
....................  
.................... } 
....................  
....................  
....................  
.................... void	one_step_x_y(void) 
.................... { 
....................  
.................... 	output_high(step_x); 
.................... 	output_high(step_y); 
....................  	delay_ms(1); 
.................... 	output_low(step_x); 
.................... 	output_low(step_y); 
.................... } 
....................  
....................  
.................... void	direita(void) 
.................... { 
.................... 	direita_flag=true; 
*
032C4:  MOVLB  1
032C6:  BSF    x80.0
.................... 	esquerda_flag=false; 
032C8:  BCF    x80.1
.................... 	output_low(dir_x); 
032CA:  BCF    F95.1
032CC:  BCF    F8C.1
032CE:  MOVLB  0
032D0:  RETURN 0
.................... 	//output_high(enable_x); 
....................  
....................  
.................... } 
....................  
....................  
.................... void	esquerda(void) 
.................... { 
.................... 	direita_flag=false; 
*
03306:  MOVLB  1
03308:  BCF    x80.0
.................... 	esquerda_flag=true; 
0330A:  BSF    x80.1
.................... 	output_high(dir_x);  
0330C:  BCF    F95.1
0330E:  BSF    F8C.1
03310:  MOVLB  0
03312:  RETURN 0
.................... 	//output_high(enable_x); 
....................  
....................  
.................... } 
....................  
.................... void	frente(void) 
.................... { 
.................... 	frente_flag=true; 
*
03158:  MOVLB  1
0315A:  BSF    x80.2
.................... 	atras_flag=false; 
0315C:  BCF    x80.3
.................... 	output_low(dir_y); 
0315E:  BCF    F94.1
03160:  BCF    F8B.1
03162:  MOVLB  0
03164:  RETURN 0
.................... 	//output_high(enable_y); 
....................  
.................... } 
....................  
.................... void	atras(void) 
.................... { 
.................... 	frente_flag=false; 
*
0319A:  MOVLB  1
0319C:  BCF    x80.2
.................... 	atras_flag=true; 
0319E:  BSF    x80.3
.................... 	output_high(dir_y); 
031A0:  BCF    F94.1
031A2:  BSF    F8B.1
031A4:  MOVLB  0
031A6:  RETURN 0
.................... 	//output_high(enable_y); 
....................  
.................... } 
....................  
.................... void	sentido_horario(void) 
.................... { 
....................  
....................     sentido_horario_flag = true; 
*
037AC:  MOVLB  1
037AE:  BSF    x80.6
....................     sentido_antihorario_flag = false ; 
037B0:  BCF    x80.7
.................... 	output_low(dir_flip); 
037B2:  BCF    F96.1
037B4:  BCF    F8D.1
037B6:  MOVLB  0
037B8:  RETURN 0
.................... 	//output_high(enable_y); 
....................  
.................... } 
....................  
....................  
.................... void	sobe(void) 
.................... { 
.................... 	sobe_flag=true; 
*
02ECC:  MOVLB  1
02ECE:  BSF    x80.4
.................... 	desce_flag=false; 
02ED0:  BCF    x80.5
.................... 	output_low(dir_z); 
02ED2:  BCF    F92.4
02ED4:  BCF    F89.4
02ED6:  MOVLB  0
02ED8:  RETURN 0
.................... 	//output_high(enable_y); 
....................  
.................... } 
....................  
.................... void	desce(void) 
.................... { 
.................... 	sobe_flag=false; 
*
02E8A:  MOVLB  1
02E8C:  BCF    x80.4
.................... 	desce_flag=true; 
02E8E:  BSF    x80.5
.................... 	output_high(dir_z); 
02E90:  BCF    F92.4
02E92:  BSF    F89.4
02E94:  MOVLB  0
02E96:  RETURN 0
.................... 	//output_high(enable_y); 
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void	sentido_antihorario(void) 
.................... { 
....................     sentido_horario_flag = false; 
*
037EE:  MOVLB  1
037F0:  BCF    x80.6
....................     sentido_antihorario_flag = true; 
037F2:  BSF    x80.7
.................... 	output_high(dir_flip); 
037F4:  BCF    F96.1
037F6:  BSF    F8D.1
037F8:  MOVLB  0
037FA:  RETURN 0
.................... 	//output_high(enable_y); 
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... void chopper_x(void) 
.................... { 
....................  
.................... 	output_low(enable_x); 
*
032BE:  BCF    F95.0
032C0:  BCF    F8C.0
032C2:  RETURN 0
....................  
.................... } 
....................  
....................  
....................  
.................... void chopper_y(void) 
.................... { 
....................  
.................... 	output_low(enable_y); 
*
03152:  BCF    F94.0
03154:  BCF    F8B.0
03156:  RETURN 0
....................  
....................  
.................... } 
....................  
.................... void chopper_flip(void) 
.................... { 
....................  
.................... 	output_low(enable_flip); 
*
037A6:  BCF    F96.0
037A8:  BCF    F8D.0
037AA:  RETURN 0
....................  
....................  
.................... } 
....................  
.................... void chopper_z(void) 
.................... { 
....................  
.................... 	output_low(enable_z); 
*
02C0C:  BCF    F92.3
02C0E:  BCF    F89.3
02C10:  RETURN 0
....................  
....................  
.................... } 
....................  
....................  
.................... void	stop_x(void) 
.................... { 
....................  
.................... 		output_low(enable_x); 
*
03314:  BCF    F95.0
03316:  BCF    F8C.0
03318:  RETURN 0
....................  
....................  
.................... } 
....................  
.................... void	stop_y(void) 
.................... { 
....................  
.................... 		output_low(enable_y); 
*
031A8:  BCF    F94.0
031AA:  BCF    F8B.0
031AC:  RETURN 0
....................  
....................  
.................... } 
....................  
.................... void	stop_flip(void) 
.................... { 
....................  
.................... 		output_low(enable_flip); 
*
0925E:  BCF    F96.0
09260:  BCF    F8D.0
09262:  GOTO   93D4 (RETURN)
....................  
....................  
.................... } 
....................  
.................... void	stop_z(void) 
.................... { 
....................  
.................... 		output_low(enable_z); 
*
02EDA:  BCF    F92.3
02EDC:  BCF    F89.3
02EDE:  RETURN 0
....................  
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "I_O.c" 
....................  
....................  
.................... #define     IN0				0 
.................... #define     IN1				1 
.................... #define     IN2				2 
.................... #define     IN3				3 
.................... #define     IN4				4 
.................... #define     IN5				5 
.................... #define     IN6				6 
.................... #define     IN7				7 
.................... #define     IN8				8 
.................... #define     IN9				9 
.................... #define     IN10			10 
.................... #define     IN11			11 
.................... #define     IN12			12 
.................... #define     IN13			13 
.................... #define     IN14			14 
.................... #define     IN15			15 
.................... #define     IN16			16 
.................... #define     IN17			17 
.................... #define     IN18			18 
.................... #define     IN19			19 
.................... #define     IN20			20 
.................... #define     IN21			21	 
.................... #define     IN22			22 
.................... #define     IN23			23 
.................... #define     IN24			24 
.................... #define     IN25			25 
.................... #define     IN26    		26 
.................... #define     IN27	    	27 
.................... 	 
.................... #define     S_DEDO_IN_LS1      	    IN0  	//SENSOR AVANÇO CILINRO  1		 
.................... #define     S_DEDO_IN_LS2      	    IN1	 	//SENSOR AVANÇO CILINDRO 2			 
.................... #define     S_EMPURRADOR_IN_LS1	    IN2	 	//NT 
.................... #define     S_EMPURRADOR_IN_LS2     IN3	 	//SENSOR RECUO  CLP1			 
.................... #define     S_PRESSOR_LS2           IN4	 	//SENSOR AVANCO 
.................... #define     S_X_DIREITA			    IN5	 	//LIMITE DIREITA			 
.................... #define     S_X_ESQUERDA		    IN6	 	//LIMITE ESQUERDA			 
.................... #define     S_Y_FRENTE   		    IN7  	//LIMITE FRENTE			 
.................... #define     S_Y_ATRAS               IN8  	//LIMITE ATRAS	 
.................... #define     S_Y_DIREITA_PROT  	    IN9  	//LIMITE DIREITA DA OUTRA PLACA			 
.................... #define     S_Y_ESQUERDA_PROT       IN10 	//LIMITE ESQUERDA DA OUTRA PLACA	 
.................... #define     S_ROTACAO_LS1           IN11 	//SENSOR LIMITE GIRO HORARIO			 
.................... #define     S_FERRO_SOLDA1          IN12 	//SENSOR FERRO DE SOLDA 1 			 
.................... #define     S_Z_TOP	    		    IN13 	//SENSOR LIMITE  SUPEIOR			 
.................... #define     S_Z_BOTTOM			    IN14 	//SENSOR LIMITE  INFERIOR			 
.................... #define     S_FERRO_SOLDA2          IN15 	//SENSOR FERRO DE SOLDA 2			 
.................... #define     S_DEDO_OUT_LS1		    IN16 	//SENSOR AVANÇO 
.................... #define     S_DEDO_OUT_LS2	        IN17 	//SENSOR AVANÇO 
.................... #define     S_EMPURRADOR_OUT_LS1    IN18 	//SENSOR AVANÇO 			 
.................... #define     S_EMPURRADOR_OUT_LS2    IN19 	//SENSOR recuo	 
.................... #define     SENSOR_BOARD   			IN20 	 
.................... #define     S_BANDEJA               IN21 	//SENSOR BANDEJA CLP1 & CLP2 
.................... #define     S_FIO_SOLDA1	        IN22 	//SENSOR FIO DE SOLDA 1 
.................... #define     S_FIO_SOLDA2	        IN23 	//SENSOR FIO DE SOLDA 2 
.................... #define     S_FIO_SOLDA3	        IN24 	//SENSOR FIO DE SOLDA 3 
.................... #define     S_ESTEIRA               IN25 	//SENSOR DESLIGA ESTEIRA 
.................... #define     RESERVADO2 				IN26 	 
.................... #define     RESERVADO3              IN27    //RESET 
....................    	  
.................... // definição das saidas de comandos 
.................... #define     DEDO_ENTRADA				     7  //OUT 0 
.................... #define     EMPURRADOR_ENTRADA_SOL_EMPURRA   6  //OUT 1 
.................... #define     EMPURRADOR_ENTRADA_SOL_RETORNA 	 5  //OUT 2 
.................... #define     PRESSOR						     4  //OUT 3 
.................... #define     FERRO_SOLDA1				     3  //OUT 4 
.................... #define     FERRO_SOLDA2				     2  //OUT 5 
.................... #define     DEDO_SAIDA					     1  //OUT 6 
.................... #define     EMPURRADOR_SAIDA_SOL_EMPURRA     0  //OUT 7 
.................... #define     EMPURRADOR_SAIDA_SOL_RETORNA     15 //OUT 8 
.................... #define     ALIMENTADOR1					 14 //OUT 9  RL2 
.................... #define     ALIMENTADOR2					 13 //OUT 10 RL3 
.................... #define     ALIMENTADOR3					 12	//OUT 11 RL4  
.................... #define     LIMPADOR					     11	//OUT 12 RL5 
.................... #define     RELE_ESTEIRA                     10 //OUT 13  
....................  
....................  
.................... short int le_Input(int input_number) 
*
02C54:  MOVLB  1
02C56:  CLRF   x9F
02C58:  CLRF   x9E
02C5A:  CLRF   xA0
.................... { 
....................  
.................... 	short int retorno; 
....................     long int  data_sensores  = 0x0000; 
.................... 	int		  data_sensores2 = 0x00;			   
....................  
.................... 	 
.................... 	if(input_number < 16) 
02C5C:  MOVF   x9C,W
02C5E:  SUBLW  0F
02C60:  BNC   2CD8
.................... 	{ 
.................... 	 	data_sensores = le_PCA9555(0X03,0X00); 
02C62:  MOVLW  03
02C64:  MOVWF  xA5
02C66:  CLRF   xA6
02C68:  MOVLB  0
02C6A:  CALL   21FE
02C6E:  MOVFF  02,19F
02C72:  MOVFF  01,19E
.................... 		if(bit_test (data_sensores,input_number) == 0) 
02C76:  MOVFF  19F,03
02C7A:  MOVLB  1
02C7C:  MOVFF  19E,02
02C80:  MOVF   x9C,W
02C82:  MOVWF  00
02C84:  BZ    2C90
02C86:  BCF    FD8.0
02C88:  RRCF   03,F
02C8A:  RRCF   02,F
02C8C:  DECFSZ 00,F
02C8E:  BRA    2C86
02C90:  MOVF   02,W
02C92:  BTFSC  02.0
02C94:  BRA    2CD0
.................... 		{ 
.................... 			delay_us(30); 
02C96:  MOVLW  31
02C98:  MOVWF  00
02C9A:  DECFSZ 00,F
02C9C:  BRA    2C9A
02C9E:  BRA    2CA0
.................... 			if(bit_test (data_sensores,input_number) == 0) return retorno = true; 
02CA0:  MOVFF  19F,03
02CA4:  MOVFF  19E,02
02CA8:  MOVF   x9C,W
02CAA:  MOVWF  00
02CAC:  BZ    2CB8
02CAE:  BCF    FD8.0
02CB0:  RRCF   03,F
02CB2:  RRCF   02,F
02CB4:  DECFSZ 00,F
02CB6:  BRA    2CAE
02CB8:  MOVF   02,W
02CBA:  BTFSC  02.0
02CBC:  BRA    2CC6
02CBE:  BSF    x9D.0
02CC0:  MOVLW  01
02CC2:  MOVWF  01
02CC4:  BRA    2E5A
.................... 			return  retorno = false; 
02CC6:  BCF    x9D.0
02CC8:  MOVLW  00
02CCA:  MOVWF  01
02CCC:  BRA    2E5A
.................... 		}else return  retorno = false; 
02CCE:  BRA    2CD8
02CD0:  BCF    x9D.0
02CD2:  MOVLW  00
02CD4:  MOVWF  01
02CD6:  BRA    2E5A
.................... 	} 
.................... 		 
.................... 	if((input_number >= 16) && (input_number < 24))  
02CD8:  MOVF   x9C,W
02CDA:  SUBLW  0F
02CDC:  BC    2D4E
02CDE:  MOVF   x9C,W
02CE0:  SUBLW  17
02CE2:  BNC   2D4E
.................... 	{ 
.................... 		data_sensores2 = le_pcf8574A(0x04); 
02CE4:  MOVLW  04
02CE6:  MOVWF  xA1
02CE8:  MOVLB  0
02CEA:  RCALL  2C12
02CEC:  MOVFF  01,1A0
.................... 		if(bit_test (data_sensores2,input_number - 16) == 0) 
02CF0:  MOVLW  10
02CF2:  MOVLB  1
02CF4:  SUBWF  x9C,W
02CF6:  MOVWF  xA1
02CF8:  MOVFF  1A0,00
02CFC:  MOVF   xA1,W
02CFE:  MOVWF  01
02D00:  BZ    2D0A
02D02:  BCF    FD8.0
02D04:  RRCF   00,F
02D06:  DECFSZ 01,F
02D08:  BRA    2D02
02D0A:  BTFSC  00.0
02D0C:  BRA    2D46
.................... 		{ 
.................... 			delay_us(30); 
02D0E:  MOVLW  31
02D10:  MOVWF  00
02D12:  DECFSZ 00,F
02D14:  BRA    2D12
02D16:  BRA    2D18
.................... 			if(bit_test (data_sensores2,input_number - 16) == 0) return retorno = true; 
02D18:  MOVLW  10
02D1A:  SUBWF  x9C,W
02D1C:  MOVWF  xA1
02D1E:  MOVFF  1A0,00
02D22:  MOVF   xA1,W
02D24:  MOVWF  01
02D26:  BZ    2D30
02D28:  BCF    FD8.0
02D2A:  RRCF   00,F
02D2C:  DECFSZ 01,F
02D2E:  BRA    2D28
02D30:  BTFSC  00.0
02D32:  BRA    2D3C
02D34:  BSF    x9D.0
02D36:  MOVLW  01
02D38:  MOVWF  01
02D3A:  BRA    2E5A
.................... 			return    retorno = false; 
02D3C:  BCF    x9D.0
02D3E:  MOVLW  00
02D40:  MOVWF  01
02D42:  BRA    2E5A
.................... 		}else return  retorno = false;				 
02D44:  BRA    2D4E
02D46:  BCF    x9D.0
02D48:  MOVLW  00
02D4A:  MOVWF  01
02D4C:  BRA    2E5A
....................  
....................  
.................... 	} 
....................  
....................  
.................... 	if((input_number >= 24) && (input_number <= 27))  
02D4E:  MOVF   x9C,W
02D50:  SUBLW  17
02D52:  BTFSC  FD8.0
02D54:  BRA    2E5A
02D56:  MOVF   x9C,W
02D58:  SUBLW  1B
02D5A:  BTFSS  FD8.0
02D5C:  BRA    2E5A
.................... 	{	 
.................... 		switch(input_number)  
02D5E:  MOVLW  18
02D60:  SUBWF  x9C,W
02D62:  ADDLW  FC
02D64:  BTFSC  FD8.0
02D66:  BRA    2E5A
02D68:  ADDLW  04
02D6A:  MOVLB  0
02D6C:  GOTO   2E5E
.................... 		{ 
....................  
.................... 			case 24:if(input(in24_bit) == 0) 
02D70:  BSF    F93.0
02D72:  BTFSC  F81.0
02D74:  BRA    2D9E
.................... 					{ 
.................... 					   	delay_us(30); 
02D76:  MOVLW  31
02D78:  MOVWF  00
02D7A:  DECFSZ 00,F
02D7C:  BRA    2D7A
02D7E:  BRA    2D80
.................... 					    if(input(in24_bit) == 0) return retorno	= true;		 
02D80:  BSF    F93.0
02D82:  BTFSC  F81.0
02D84:  BRA    2D92
02D86:  MOVLB  1
02D88:  BSF    x9D.0
02D8A:  MOVLW  01
02D8C:  MOVWF  01
02D8E:  BRA    2E5A
02D90:  MOVLB  0
.................... 						return retorno	= false;	 
02D92:  MOVLB  1
02D94:  BCF    x9D.0
02D96:  MOVLW  00
02D98:  MOVWF  01
02D9A:  BRA    2E5A
.................... 			        }else 	return retorno	= false;	 
02D9C:  BRA    2DA8
02D9E:  MOVLB  1
02DA0:  BCF    x9D.0
02DA2:  MOVLW  00
02DA4:  MOVWF  01
02DA6:  BRA    2E5A
....................  
.................... 					break; 
02DA8:  BRA    2E5A
....................  
.................... 			case 25:if(input(in25_bit) == 0) 
02DAA:  BSF    F93.1
02DAC:  BTFSC  F81.1
02DAE:  BRA    2DD8
.................... 					{ 
.................... 					   	delay_us(30); 
02DB0:  MOVLW  31
02DB2:  MOVWF  00
02DB4:  DECFSZ 00,F
02DB6:  BRA    2DB4
02DB8:  BRA    2DBA
.................... 					    if(input(in25_bit) == 0) return retorno	= true;		 
02DBA:  BSF    F93.1
02DBC:  BTFSC  F81.1
02DBE:  BRA    2DCC
02DC0:  MOVLB  1
02DC2:  BSF    x9D.0
02DC4:  MOVLW  01
02DC6:  MOVWF  01
02DC8:  BRA    2E5A
02DCA:  MOVLB  0
.................... 						return retorno	= false;	 
02DCC:  MOVLB  1
02DCE:  BCF    x9D.0
02DD0:  MOVLW  00
02DD2:  MOVWF  01
02DD4:  BRA    2E5A
.................... 			        }else 	return retorno	= false; 
02DD6:  BRA    2DE2
02DD8:  MOVLB  1
02DDA:  BCF    x9D.0
02DDC:  MOVLW  00
02DDE:  MOVWF  01
02DE0:  BRA    2E5A
....................  
.................... 					break; 
02DE2:  BRA    2E5A
....................  
.................... 			case 26:if(input(in26_bit) == 0) 
02DE4:  BSF    F93.3
02DE6:  BTFSC  F81.3
02DE8:  BRA    2E12
.................... 					{ 
.................... 					   	delay_us(30); 
02DEA:  MOVLW  31
02DEC:  MOVWF  00
02DEE:  DECFSZ 00,F
02DF0:  BRA    2DEE
02DF2:  BRA    2DF4
.................... 					    if(input(in26_bit) == 0) return retorno	= true;		 
02DF4:  BSF    F93.3
02DF6:  BTFSC  F81.3
02DF8:  BRA    2E06
02DFA:  MOVLB  1
02DFC:  BSF    x9D.0
02DFE:  MOVLW  01
02E00:  MOVWF  01
02E02:  BRA    2E5A
02E04:  MOVLB  0
.................... 						return retorno	= false;	 
02E06:  MOVLB  1
02E08:  BCF    x9D.0
02E0A:  MOVLW  00
02E0C:  MOVWF  01
02E0E:  BRA    2E5A
.................... 			        }else 	return retorno	= false; 
02E10:  BRA    2E1C
02E12:  MOVLB  1
02E14:  BCF    x9D.0
02E16:  MOVLW  00
02E18:  MOVWF  01
02E1A:  BRA    2E5A
....................  
.................... 					break; 
02E1C:  BRA    2E5A
....................  
.................... 			case 27:if(input(in27_bit) == 0) 
02E1E:  BSF    F93.4
02E20:  BTFSC  F81.4
02E22:  BRA    2E4C
.................... 					{ 
.................... 					   	delay_us(30); 
02E24:  MOVLW  31
02E26:  MOVWF  00
02E28:  DECFSZ 00,F
02E2A:  BRA    2E28
02E2C:  BRA    2E2E
.................... 					    if(input(in27_bit) == 0) return retorno	= true;		 
02E2E:  BSF    F93.4
02E30:  BTFSC  F81.4
02E32:  BRA    2E40
02E34:  MOVLB  1
02E36:  BSF    x9D.0
02E38:  MOVLW  01
02E3A:  MOVWF  01
02E3C:  BRA    2E5A
02E3E:  MOVLB  0
.................... 						return retorno	= false;	 
02E40:  MOVLB  1
02E42:  BCF    x9D.0
02E44:  MOVLW  00
02E46:  MOVWF  01
02E48:  BRA    2E5A
.................... 			        }else 	return retorno	= false; 
02E4A:  BRA    2E56
02E4C:  MOVLB  1
02E4E:  BCF    x9D.0
02E50:  MOVLW  00
02E52:  MOVWF  01
02E54:  BRA    2E5A
.................... 					break; 
02E56:  BRA    2E5A
02E58:  MOVLB  1
....................  
.................... 	 	}  			 
....................  
....................  
.................... 	} 
02E5A:  MOVLB  0
02E5C:  RETURN 0
....................  
....................  
.................... } 
....................  
....................  
.................... void	aciona_saida(long int output_word) 
.................... { 
.................... 	int valor_lsb; 
.................... 	int valor_msb; 
....................  
.................... 	bit_clear(buffer_saida,output_word); 
*
02FD2:  CLRF   03
02FD4:  MOVLW  01
02FD6:  MOVWF  02
02FD8:  MOVLB  1
02FDA:  MOVF   xA0,W
02FDC:  MOVWF  00
02FDE:  BZ    2FEA
02FE0:  BCF    FD8.0
02FE2:  RLCF   02,F
02FE4:  RLCF   03,F
02FE6:  DECFSZ 00,F
02FE8:  BRA    2FE0
02FEA:  MOVF   02,W
02FEC:  XORLW  FF
02FEE:  MOVWF  00
02FF0:  MOVLW  FF
02FF2:  XORWF  03,F
02FF4:  MOVF   00,W
02FF6:  ANDWF  x76,F
02FF8:  MOVF   03,W
02FFA:  ANDWF  x77,F
.................... 	valor_lsb = make8(buffer_saida,0);   
02FFC:  MOVFF  176,1A2
.................... 	valor_msb = make8(buffer_saida,1); 
03000:  MOVFF  177,1A3
03004:  CLRF   16
03006:  BTFSC  FF2.7
03008:  BSF    16.7
0300A:  BCF    FF2.7
.................... 	escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
0300C:  MOVLW  02
0300E:  MOVLB  2
03010:  MOVWF  x1E
03012:  MOVWF  x1F
03014:  MOVFF  1A3,220
03018:  MOVFF  1A2,221
0301C:  MOVLB  0
0301E:  CALL   1B44
03022:  BTFSC  16.7
03024:  BSF    FF2.7
03026:  RETURN 0
....................  
....................  
.................... } 
....................  
.................... void	desaciona_saida(long int output_word) 
.................... { 
....................  
.................... 	int valor_lsb; 
.................... 	int valor_msb; 
....................  
.................... 	bit_set(buffer_saida,output_word); 
*
01B96:  CLRF   03
01B98:  MOVLW  01
01B9A:  MOVWF  02
01B9C:  MOVLB  2
01B9E:  MOVF   x1A,W
01BA0:  MOVWF  00
01BA2:  BZ    1BAE
01BA4:  BCF    FD8.0
01BA6:  RLCF   02,F
01BA8:  RLCF   03,F
01BAA:  DECFSZ 00,F
01BAC:  BRA    1BA4
01BAE:  MOVF   02,W
01BB0:  MOVLB  1
01BB2:  IORWF  x76,F
01BB4:  MOVF   03,W
01BB6:  IORWF  x77,F
.................... 	valor_lsb = make8(buffer_saida,0);   
01BB8:  MOVFF  176,21C
01BBC:  MOVLB  2
.................... 	valor_msb = make8(buffer_saida,1); 
01BBE:  MOVFF  177,21D
01BC2:  MOVLB  2
.................... 	escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
01BC4:  MOVLW  02
01BC6:  MOVWF  x1E
01BC8:  MOVWF  x1F
01BCA:  MOVFF  21D,220
01BCE:  MOVFF  21C,221
01BD2:  MOVLB  0
01BD4:  RCALL  1B44
01BD6:  RETURN 0
....................  
....................  
.................... } 
....................  
....................  
.................... void	desaciona_todas_saidas(void) 
.................... { 
.................... 	int valor_lsb; 
.................... 	int valor_msb; 
....................  
.................... 	buffer_saida = 0x0ffff; 
*
01EB0:  MOVLB  1
01EB2:  SETF   x77
01EB4:  SETF   x76
.................... 	valor_lsb = make8(buffer_saida,0);   
01EB6:  MOVFF  176,194
.................... 	valor_msb = make8(buffer_saida,1); 
01EBA:  MOVFF  177,195
01EBE:  CLRF   16
01EC0:  BTFSC  FF2.7
01EC2:  BSF    16.7
01EC4:  BCF    FF2.7
....................  
.................... 	escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
01EC6:  MOVLW  02
01EC8:  MOVLB  2
01ECA:  MOVWF  x1E
01ECC:  MOVWF  x1F
01ECE:  MOVFF  195,220
01ED2:  MOVFF  194,221
01ED6:  MOVLB  0
01ED8:  RCALL  1B44
01EDA:  BTFSC  16.7
01EDC:  BSF    FF2.7
01EDE:  RETURN 0
....................  
....................  
.................... } 
....................  
....................  
.................... void Init_Sensores_porta1(void) 
*
01E6C:  CLRF   16
01E6E:  BTFSC  FF2.7
01E70:  BSF    16.7
01E72:  BCF    FF2.7
.................... { 
....................  
.................... 	escreve_PCA9555(0X03,0X06,0Xff,0xff);	// programa bits entradas  
01E74:  MOVLW  03
01E76:  MOVLB  2
01E78:  MOVWF  x1E
01E7A:  MOVLW  06
01E7C:  MOVWF  x1F
01E7E:  SETF   x20
01E80:  SETF   x21
01E82:  MOVLB  0
01E84:  RCALL  1B44
01E86:  BTFSC  16.7
01E88:  BSF    FF2.7
01E8A:  GOTO   B162 (RETURN)
.................... 										 	//como saida e os demais como entrada 
....................   
....................  
.................... } 
....................  
.................... void Init_saidas(void) 
01E8E:  CLRF   16
01E90:  BTFSC  FF2.7
01E92:  BSF    16.7
01E94:  BCF    FF2.7
.................... { 
....................  
.................... 	escreve_PCA9555(0X02,0X06,0X00,0x00);	// programa bits saidas //como saida e os demais como entrada 
01E96:  MOVLW  02
01E98:  MOVLB  2
01E9A:  MOVWF  x1E
01E9C:  MOVLW  06
01E9E:  MOVWF  x1F
01EA0:  CLRF   x20
01EA2:  CLRF   x21
01EA4:  MOVLB  0
01EA6:  RCALL  1B44
01EA8:  BTFSC  16.7
01EAA:  BSF    FF2.7
01EAC:  GOTO   B166 (RETURN)
....................   
....................      
.................... } 
....................  
.................... #include "movimentos.c" 
....................  
....................  
....................  
....................  
.................... void	go_x(long int x_posicao,int speed_x_x) 
.................... { 
....................  
....................  
.................... 		direita_flag = false; 
*
056FC:  MOVLB  1
056FE:  BCF    x80.0
....................  		esquerda_flag = false; 
05700:  BCF    x80.1
.................... 	 
.................... 		if (x_posicao > contador_step_x) 
05702:  MOVF   x79,W
05704:  SUBWF  x9E,W
05706:  BNC   571A
05708:  BNZ   5710
0570A:  MOVF   x9D,W
0570C:  SUBWF  x78,W
0570E:  BC    571A
.................... 			   { 
....................  
.................... 				//direita();   
.................... 		        esquerda(); 
05710:  MOVLB  0
05712:  CALL   3306
.................... 		 
....................  
.................... 				}			 
05716:  BRA    5720
05718:  MOVLB  1
.................... 					else 
.................... 						{ 
.................... 							//esquerda(); 
.................... 	 					    direita(); 
0571A:  MOVLB  0
0571C:  CALL   32C4
.................... 					 
.................... 						} 
....................  
.................... 		 
.................... 				while(x_posicao != contador_step_x) 
05720:  MOVLB  1
05722:  MOVF   x78,W
05724:  SUBWF  x9D,W
05726:  BNZ   572E
05728:  MOVF   x79,W
0572A:  SUBWF  x9E,W
0572C:  BZ    5740
.................... 				{ 
.................... 					one_step_x(); 
0572E:  MOVLB  0
05730:  CALL   32D2
.................... 					delay_ms(speed_x_x); 
05734:  MOVFF  19F,217
05738:  CALL   1D50
0573C:  BRA    5720
0573E:  MOVLB  1
.................... 				 
.................... 					 
.................... 				} 
05740:  MOVLB  0
05742:  RETURN 0
.................... 	 
....................  
.................... 			 
....................  
.................... } 
....................  
.................... void	go_y(long int y_posicao,int speed_y_y) 
.................... { 
.................... 	 
.................... 		frente_flag = false; 
....................  		atras_flag = false; 
.................... 		 
.................... 	if (y_posicao != contador_step_y) 
.................... 	{ 
.................... 		if (y_posicao > contador_step_y) 
.................... 			   { 
....................  
.................... 				frente();   
.................... 			 
.................... 		 
....................  
.................... 				}			 
.................... 					else 
.................... 						{ 
.................... 							atras(); 
.................... 	 				 
.................... 						 
.................... 						} 
....................  
.................... 	} 
....................  
.................... 				while(y_posicao != contador_step_y) 
.................... 				{ 
.................... 					one_step_y(); 
.................... 					delay_ms(speed_y_y); 
....................  
.................... 				 
....................  
.................... 				} 
....................  
.................... 	 
.................... } 
....................  
....................  
.................... void	go_z(long int z_posicao,long int speed_z_z) 
.................... { 
.................... 	 
.................... 		desce_flag = false; 
*
055F6:  MOVLB  1
055F8:  BCF    x80.5
....................  		sobe_flag = false; 
055FA:  BCF    x80.4
.................... 		 
.................... 	if (z_posicao != contador_step_z) 
055FC:  MOVF   x7E,W
055FE:  SUBWF  x9B,W
05600:  BNZ   5608
05602:  MOVF   x7F,W
05604:  SUBWF  x9C,W
05606:  BZ    5628
.................... 	{ 
.................... 		if (z_posicao > contador_step_z) 
05608:  MOVF   x7F,W
0560A:  SUBWF  x9C,W
0560C:  BNC   5620
0560E:  BNZ   5616
05610:  MOVF   x9B,W
05612:  SUBWF  x7E,W
05614:  BC    5620
.................... 			   { 
....................  
.................... 				desce();   
05616:  MOVLB  0
05618:  CALL   2E8A
.................... 			 
.................... 		 
....................  
.................... 				}			 
0561C:  BRA    5626
0561E:  MOVLB  1
.................... 					else 
.................... 						{ 
.................... 							sobe(); 
05620:  MOVLB  0
05622:  CALL   2ECC
05626:  MOVLB  1
.................... 	 				 
.................... 						 
.................... 						} 
....................  
.................... 	} 
....................  
.................... 				while(z_posicao != contador_step_z) 
05628:  MOVF   x7E,W
0562A:  SUBWF  x9B,W
0562C:  BNZ   5634
0562E:  MOVF   x7F,W
05630:  SUBWF  x9C,W
05632:  BZ    567C
.................... 				{ 
.................... 					one_step_z(); 
05634:  MOVLB  0
05636:  CALL   2E98
.................... 					delay_us(speed_z_z); 
0563A:  MOVFF  19E,19F
0563E:  MOVLB  1
05640:  INCF   x9F,F
05642:  DECF   x9F,F
05644:  BTFSC  FD8.2
05646:  BRA    5662
05648:  CLRF   16
0564A:  BTFSC  FF2.7
0564C:  BSF    16.7
0564E:  BCF    FF2.7
05650:  MOVLB  2
05652:  SETF   x1B
05654:  MOVLB  0
05656:  CALL   1C3A
0565A:  BTFSC  16.7
0565C:  BSF    FF2.7
0565E:  MOVLB  1
05660:  BRA    5642
05662:  CLRF   16
05664:  BTFSC  FF2.7
05666:  BSF    16.7
05668:  BCF    FF2.7
0566A:  MOVFF  19D,21B
0566E:  MOVLB  0
05670:  CALL   1C3A
05674:  BTFSC  16.7
05676:  BSF    FF2.7
05678:  MOVLB  1
0567A:  BRA    5628
....................  
.................... 				 
....................  
.................... 				} 
0567C:  MOVLB  0
0567E:  RETURN 0
....................  
.................... 	 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... void rampa_xx(long int speed_x,long int speed_inicial_final_x,long int x_posicao,int rampa_x) 
.................... { 
.................... 	long int tempo;	 
.................... 	signed long int steps_percorridos; 
.................... 	signed long int steps_faltam; 
.................... 	long int degrau_x; 
.................... 	degrau_x=(speed_inicial_final_x - speed_x); 
*
03FF2:  MOVLB  1
03FF4:  MOVF   xB3,W
03FF6:  SUBWF  xB5,W
03FF8:  MOVWF  xC0
03FFA:  MOVF   xB4,W
03FFC:  SUBWFB xB6,W
03FFE:  MOVWF  xC1
.................... 	degrau_x=degrau_x/rampa_x; 
04000:  MOVFF  1C1,1C3
04004:  MOVFF  1C0,1C2
04008:  CLRF   xC5
0400A:  MOVFF  1B9,1C4
0400E:  MOVLB  0
04010:  RCALL  3F58
04012:  MOVFF  02,1C1
04016:  MOVFF  01,1C0
....................  
.................... 	steps_percorridos=contador_step_x_inicial - contador_step_x; 
0401A:  MOVLB  1
0401C:  MOVF   x78,W
0401E:  SUBWF  3C,W
04020:  MOVWF  00
04022:  MOVF   x79,W
04024:  SUBWFB 3D,W
04026:  MOVFF  00,1BC
0402A:  MOVWF  xBD
.................... 	if(steps_percorridos < 0) steps_percorridos=steps_percorridos * (-1); 
0402C:  BTFSS  xBD.7
0402E:  BRA    404A
04030:  MOVFF  1BD,1C3
04034:  MOVFF  1BC,1C2
04038:  SETF   xC5
0403A:  SETF   xC4
0403C:  MOVLB  0
0403E:  RCALL  3F9E
04040:  MOVFF  02,1BD
04044:  MOVFF  01,1BC
04048:  MOVLB  1
....................  
.................... 	steps_faltam=x_posicao - contador_step_x; 
0404A:  MOVF   x78,W
0404C:  SUBWF  xB7,W
0404E:  MOVWF  00
04050:  MOVF   x79,W
04052:  SUBWFB xB8,W
04054:  MOVFF  00,1BE
04058:  MOVWF  xBF
.................... 	if(steps_faltam < 0) 	steps_faltam=steps_faltam * (-1); 
0405A:  BTFSS  xBF.7
0405C:  BRA    4078
0405E:  MOVFF  1BF,1C3
04062:  MOVFF  1BE,1C2
04066:  SETF   xC5
04068:  SETF   xC4
0406A:  MOVLB  0
0406C:  RCALL  3F9E
0406E:  MOVFF  02,1BF
04072:  MOVFF  01,1BE
04076:  MOVLB  1
.................... 	 
.................... 		if(steps_percorridos <= rampa_x) 
04078:  BTFSC  xBD.7
0407A:  BRA    4086
0407C:  MOVF   xBD,F
0407E:  BNZ   40DE
04080:  MOVF   xBC,W
04082:  SUBWF  xB9,W
04084:  BNC   40DE
.................... 			{ 
.................... 				tempo=(speed_inicial_final_x -(contador_rampa_subida_x * degrau_x)); 
04086:  MOVFF  45,215
0408A:  MOVFF  44,214
0408E:  MOVFF  1C1,217
04092:  MOVFF  1C0,216
04096:  MOVLB  0
04098:  CALL   27BE
0409C:  MOVF   01,W
0409E:  MOVLB  1
040A0:  SUBWF  xB5,W
040A2:  MOVWF  xBA
040A4:  MOVF   02,W
040A6:  SUBWFB xB6,W
040A8:  MOVWF  xBB
.................... 				tempo =(65535 - (tempo * 5)); 
040AA:  MOVFF  1BB,215
040AE:  MOVFF  1BA,214
040B2:  MOVLB  2
040B4:  CLRF   x17
040B6:  MOVLW  05
040B8:  MOVWF  x16
040BA:  MOVLB  0
040BC:  CALL   27BE
040C0:  MOVF   01,W
040C2:  SUBLW  FF
040C4:  MOVLB  1
040C6:  MOVWF  xBA
040C8:  MOVLW  FF
040CA:  SUBFWB 02,W
040CC:  MOVWF  xBB
.................... 				set_timer1(tempo);                                  
040CE:  MOVFF  1BB,FCF
040D2:  MOVFF  1BA,FCE
.................... 				contador_rampa_subida_x++; 
040D6:  INCF   44,F
040D8:  BTFSC  FD8.2
040DA:  INCF   45,F
....................  
.................... 			} 
040DC:  BRA    4170
.................... 				else{ 
.................... 						 
.................... 							if(steps_faltam <= rampa_x)	 
040DE:  BTFSC  xBF.7
040E0:  BRA    40EC
040E2:  MOVF   xBF,F
040E4:  BNZ   4144
040E6:  MOVF   xBE,W
040E8:  SUBWF  xB9,W
040EA:  BNC   4144
.................... 								{ 
.................... 									tempo=(speed_x +(contador_rampa_descida_x * degrau_x)); 
040EC:  MOVFF  47,215
040F0:  MOVFF  46,214
040F4:  MOVFF  1C1,217
040F8:  MOVFF  1C0,216
040FC:  MOVLB  0
040FE:  CALL   27BE
04102:  MOVF   01,W
04104:  MOVLB  1
04106:  ADDWF  xB3,W
04108:  MOVWF  xBA
0410A:  MOVF   02,W
0410C:  ADDWFC xB4,W
0410E:  MOVWF  xBB
.................... 									tempo =(65535 - (tempo * 5)); 
04110:  MOVFF  1BB,215
04114:  MOVFF  1BA,214
04118:  MOVLB  2
0411A:  CLRF   x17
0411C:  MOVLW  05
0411E:  MOVWF  x16
04120:  MOVLB  0
04122:  CALL   27BE
04126:  MOVF   01,W
04128:  SUBLW  FF
0412A:  MOVLB  1
0412C:  MOVWF  xBA
0412E:  MOVLW  FF
04130:  SUBFWB 02,W
04132:  MOVWF  xBB
.................... 									set_timer1(tempo);  
04134:  MOVFF  1BB,FCF
04138:  MOVFF  1BA,FCE
....................  									contador_rampa_descida_x++;  
0413C:  INCF   46,F
0413E:  BTFSC  FD8.2
04140:  INCF   47,F
....................        						    }                  		 
04142:  BRA    4170
.................... 									else 
.................... 											{ 
.................... 																								 
.................... 												tempo =(65535 - (speed_x * 5)); 
04144:  MOVFF  1B4,215
04148:  MOVFF  1B3,214
0414C:  MOVLB  2
0414E:  CLRF   x17
04150:  MOVLW  05
04152:  MOVWF  x16
04154:  MOVLB  0
04156:  CALL   27BE
0415A:  MOVF   01,W
0415C:  SUBLW  FF
0415E:  MOVLB  1
04160:  MOVWF  xBA
04162:  MOVLW  FF
04164:  SUBFWB 02,W
04166:  MOVWF  xBB
.................... 												set_timer1(tempo);   
04168:  MOVFF  1BB,FCF
0416C:  MOVFF  1BA,FCE
....................  
.................... 											} 
....................  
.................... 						 
....................  
.................... 				    }	 
04170:  MOVLB  0
04172:  RETURN 0
....................  
.................... } 
....................  
....................  
....................  
.................... void rampa_yy(long int speed_y,long int speed_inicial_final_y,long int y_posicao,int rampa_y) 
.................... { 
.................... 	long int tempo;	 
.................... 	signed long int steps_percorridos; 
.................... 	signed long int steps_faltam; 
.................... 	long int degrau_y; 
.................... 	degrau_y=(speed_inicial_final_y - speed_y); 
04174:  MOVLB  1
04176:  MOVF   xB3,W
04178:  SUBWF  xB5,W
0417A:  MOVWF  xC0
0417C:  MOVF   xB4,W
0417E:  SUBWFB xB6,W
04180:  MOVWF  xC1
.................... 	degrau_y=degrau_y/rampa_y; 
04182:  MOVFF  1C1,1C3
04186:  MOVFF  1C0,1C2
0418A:  CLRF   xC5
0418C:  MOVFF  1B9,1C4
04190:  MOVLB  0
04192:  RCALL  3F58
04194:  MOVFF  02,1C1
04198:  MOVFF  01,1C0
....................  
.................... 	steps_percorridos=contador_step_y_inicial - contador_step_y; 
0419C:  MOVLB  1
0419E:  MOVF   x7A,W
041A0:  SUBWF  3E,W
041A2:  MOVWF  00
041A4:  MOVF   x7B,W
041A6:  SUBWFB 3F,W
041A8:  MOVFF  00,1BC
041AC:  MOVWF  xBD
.................... 	if(steps_percorridos < 0) steps_percorridos=steps_percorridos * (-1); 
041AE:  BTFSS  xBD.7
041B0:  BRA    41CC
041B2:  MOVFF  1BD,1C3
041B6:  MOVFF  1BC,1C2
041BA:  SETF   xC5
041BC:  SETF   xC4
041BE:  MOVLB  0
041C0:  RCALL  3F9E
041C2:  MOVFF  02,1BD
041C6:  MOVFF  01,1BC
041CA:  MOVLB  1
....................  
.................... 	steps_faltam=y_posicao - contador_step_y; 
041CC:  MOVF   x7A,W
041CE:  SUBWF  xB7,W
041D0:  MOVWF  00
041D2:  MOVF   x7B,W
041D4:  SUBWFB xB8,W
041D6:  MOVFF  00,1BE
041DA:  MOVWF  xBF
.................... 	if(steps_faltam < 0) 	steps_faltam=steps_faltam * (-1); 
041DC:  BTFSS  xBF.7
041DE:  BRA    41FA
041E0:  MOVFF  1BF,1C3
041E4:  MOVFF  1BE,1C2
041E8:  SETF   xC5
041EA:  SETF   xC4
041EC:  MOVLB  0
041EE:  RCALL  3F9E
041F0:  MOVFF  02,1BF
041F4:  MOVFF  01,1BE
041F8:  MOVLB  1
.................... 	 
.................... 		if(steps_percorridos <= rampa_y) 
041FA:  BTFSC  xBD.7
041FC:  BRA    4208
041FE:  MOVF   xBD,F
04200:  BNZ   4260
04202:  MOVF   xBC,W
04204:  SUBWF  xB9,W
04206:  BNC   4260
.................... 			{ 
.................... 				tempo=(speed_inicial_final_y -(contador_rampa_subida_y * degrau_y)); 
04208:  MOVFF  49,215
0420C:  MOVFF  48,214
04210:  MOVFF  1C1,217
04214:  MOVFF  1C0,216
04218:  MOVLB  0
0421A:  CALL   27BE
0421E:  MOVF   01,W
04220:  MOVLB  1
04222:  SUBWF  xB5,W
04224:  MOVWF  xBA
04226:  MOVF   02,W
04228:  SUBWFB xB6,W
0422A:  MOVWF  xBB
.................... 				tempo =(65535 - (tempo * 5)); 
0422C:  MOVFF  1BB,215
04230:  MOVFF  1BA,214
04234:  MOVLB  2
04236:  CLRF   x17
04238:  MOVLW  05
0423A:  MOVWF  x16
0423C:  MOVLB  0
0423E:  CALL   27BE
04242:  MOVF   01,W
04244:  SUBLW  FF
04246:  MOVLB  1
04248:  MOVWF  xBA
0424A:  MOVLW  FF
0424C:  SUBFWB 02,W
0424E:  MOVWF  xBB
.................... 				set_timer3(tempo);                                  
04250:  MOVFF  1BB,FB3
04254:  MOVFF  1BA,FB2
.................... 				contador_rampa_subida_y++; 
04258:  INCF   48,F
0425A:  BTFSC  FD8.2
0425C:  INCF   49,F
....................  
.................... 			} 
0425E:  BRA    42F2
.................... 				else{ 
.................... 						 
.................... 							if(steps_faltam <= rampa_y)	 
04260:  BTFSC  xBF.7
04262:  BRA    426E
04264:  MOVF   xBF,F
04266:  BNZ   42C6
04268:  MOVF   xBE,W
0426A:  SUBWF  xB9,W
0426C:  BNC   42C6
.................... 								{ 
.................... 									tempo=(speed_y +(contador_rampa_descida_y * degrau_y)); 
0426E:  MOVFF  4B,215
04272:  MOVFF  4A,214
04276:  MOVFF  1C1,217
0427A:  MOVFF  1C0,216
0427E:  MOVLB  0
04280:  CALL   27BE
04284:  MOVF   01,W
04286:  MOVLB  1
04288:  ADDWF  xB3,W
0428A:  MOVWF  xBA
0428C:  MOVF   02,W
0428E:  ADDWFC xB4,W
04290:  MOVWF  xBB
.................... 									tempo =(65535 - (tempo * 5)); 
04292:  MOVFF  1BB,215
04296:  MOVFF  1BA,214
0429A:  MOVLB  2
0429C:  CLRF   x17
0429E:  MOVLW  05
042A0:  MOVWF  x16
042A2:  MOVLB  0
042A4:  CALL   27BE
042A8:  MOVF   01,W
042AA:  SUBLW  FF
042AC:  MOVLB  1
042AE:  MOVWF  xBA
042B0:  MOVLW  FF
042B2:  SUBFWB 02,W
042B4:  MOVWF  xBB
.................... 									set_timer3(tempo);  
042B6:  MOVFF  1BB,FB3
042BA:  MOVFF  1BA,FB2
....................  									contador_rampa_descida_y++;  
042BE:  INCF   4A,F
042C0:  BTFSC  FD8.2
042C2:  INCF   4B,F
....................        						    }                  		 
042C4:  BRA    42F2
.................... 									else 
.................... 											{ 
.................... 																								 
.................... 												tempo =(65535 - (speed_y * 5)); 
042C6:  MOVFF  1B4,215
042CA:  MOVFF  1B3,214
042CE:  MOVLB  2
042D0:  CLRF   x17
042D2:  MOVLW  05
042D4:  MOVWF  x16
042D6:  MOVLB  0
042D8:  CALL   27BE
042DC:  MOVF   01,W
042DE:  SUBLW  FF
042E0:  MOVLB  1
042E2:  MOVWF  xBA
042E4:  MOVLW  FF
042E6:  SUBFWB 02,W
042E8:  MOVWF  xBB
.................... 												set_timer3(tempo);   
042EA:  MOVFF  1BB,FB3
042EE:  MOVFF  1BA,FB2
....................  
.................... 											} 
....................  
.................... 						 
....................  
.................... 				    }	 
042F2:  MOVLB  0
042F4:  RETURN 0
....................  
.................... } 
....................  
....................  
....................  
.................... void rampa__flip(long int speed_flip,long int speed_inicial_final_flip,long int flip_posicao,int rampa_flip) 
.................... { 
.................... 	long int tempo;	 
.................... 	signed long int steps_percorridos; 
.................... 	signed long int steps_faltam; 
.................... 	long int degrau_flip; 
.................... 	degrau_flip=(speed_inicial_final_flip - speed_flip); 
*
04964:  MOVLB  1
04966:  MOVF   xB3,W
04968:  SUBWF  xB5,W
0496A:  MOVWF  xC0
0496C:  MOVF   xB4,W
0496E:  SUBWFB xB6,W
04970:  MOVWF  xC1
.................... 	degrau_flip=degrau_flip/rampa_flip; 
04972:  MOVFF  1C1,1C3
04976:  MOVFF  1C0,1C2
0497A:  CLRF   xC5
0497C:  MOVFF  1B9,1C4
04980:  MOVLB  0
04982:  CALL   3F58
04986:  MOVFF  02,1C1
0498A:  MOVFF  01,1C0
....................  
.................... 	steps_percorridos=contador_step_flip_inicial - contador_step_flip; 
0498E:  MOVLB  1
04990:  MOVF   x7C,W
04992:  SUBWF  40,W
04994:  MOVWF  00
04996:  MOVF   x7D,W
04998:  SUBWFB 41,W
0499A:  MOVFF  00,1BC
0499E:  MOVWF  xBD
.................... 	if(steps_percorridos < 0) steps_percorridos=steps_percorridos * (-1); 
049A0:  BTFSS  xBD.7
049A2:  BRA    49C0
049A4:  MOVFF  1BD,1C3
049A8:  MOVFF  1BC,1C2
049AC:  SETF   xC5
049AE:  SETF   xC4
049B0:  MOVLB  0
049B2:  CALL   3F9E
049B6:  MOVFF  02,1BD
049BA:  MOVFF  01,1BC
049BE:  MOVLB  1
....................  
.................... 	steps_faltam=flip_posicao - contador_step_flip; 
049C0:  MOVF   x7C,W
049C2:  SUBWF  xB7,W
049C4:  MOVWF  00
049C6:  MOVF   x7D,W
049C8:  SUBWFB xB8,W
049CA:  MOVFF  00,1BE
049CE:  MOVWF  xBF
.................... 	if(steps_faltam < 0) 	steps_faltam=steps_faltam * (-1); 
049D0:  BTFSS  xBF.7
049D2:  BRA    49F0
049D4:  MOVFF  1BF,1C3
049D8:  MOVFF  1BE,1C2
049DC:  SETF   xC5
049DE:  SETF   xC4
049E0:  MOVLB  0
049E2:  CALL   3F9E
049E6:  MOVFF  02,1BF
049EA:  MOVFF  01,1BE
049EE:  MOVLB  1
.................... 	 
.................... 		if(steps_percorridos <= rampa_flip) 
049F0:  BTFSC  xBD.7
049F2:  BRA    49FE
049F4:  MOVF   xBD,F
049F6:  BNZ   4A56
049F8:  MOVF   xBC,W
049FA:  SUBWF  xB9,W
049FC:  BNC   4A56
.................... 			{ 
.................... 				tempo=(speed_inicial_final_flip -(contador_rampa_subida_flip * degrau_flip)); 
049FE:  MOVFF  4D,215
04A02:  MOVFF  4C,214
04A06:  MOVFF  1C1,217
04A0A:  MOVFF  1C0,216
04A0E:  MOVLB  0
04A10:  CALL   27BE
04A14:  MOVF   01,W
04A16:  MOVLB  1
04A18:  SUBWF  xB5,W
04A1A:  MOVWF  xBA
04A1C:  MOVF   02,W
04A1E:  SUBWFB xB6,W
04A20:  MOVWF  xBB
.................... 				tempo =(65535 - (tempo * 5)); 
04A22:  MOVFF  1BB,215
04A26:  MOVFF  1BA,214
04A2A:  MOVLB  2
04A2C:  CLRF   x17
04A2E:  MOVLW  05
04A30:  MOVWF  x16
04A32:  MOVLB  0
04A34:  CALL   27BE
04A38:  MOVF   01,W
04A3A:  SUBLW  FF
04A3C:  MOVLB  1
04A3E:  MOVWF  xBA
04A40:  MOVLW  FF
04A42:  SUBFWB 02,W
04A44:  MOVWF  xBB
.................... 				set_timer0(tempo);                                  
04A46:  MOVFF  1BB,FD7
04A4A:  MOVFF  1BA,FD6
.................... 				contador_rampa_subida_flip++; 
04A4E:  INCF   4C,F
04A50:  BTFSC  FD8.2
04A52:  INCF   4D,F
....................  
.................... 			} 
04A54:  BRA    4AE8
.................... 				else{ 
.................... 						 
.................... 							if(steps_faltam <= rampa_flip)	 
04A56:  BTFSC  xBF.7
04A58:  BRA    4A64
04A5A:  MOVF   xBF,F
04A5C:  BNZ   4ABC
04A5E:  MOVF   xBE,W
04A60:  SUBWF  xB9,W
04A62:  BNC   4ABC
.................... 								{ 
.................... 									tempo=(speed_flip +(contador_rampa_descida_flip * degrau_flip)); 
04A64:  MOVFF  4F,215
04A68:  MOVFF  4E,214
04A6C:  MOVFF  1C1,217
04A70:  MOVFF  1C0,216
04A74:  MOVLB  0
04A76:  CALL   27BE
04A7A:  MOVF   01,W
04A7C:  MOVLB  1
04A7E:  ADDWF  xB3,W
04A80:  MOVWF  xBA
04A82:  MOVF   02,W
04A84:  ADDWFC xB4,W
04A86:  MOVWF  xBB
.................... 									tempo =(65535 - (tempo * 5)); 
04A88:  MOVFF  1BB,215
04A8C:  MOVFF  1BA,214
04A90:  MOVLB  2
04A92:  CLRF   x17
04A94:  MOVLW  05
04A96:  MOVWF  x16
04A98:  MOVLB  0
04A9A:  CALL   27BE
04A9E:  MOVF   01,W
04AA0:  SUBLW  FF
04AA2:  MOVLB  1
04AA4:  MOVWF  xBA
04AA6:  MOVLW  FF
04AA8:  SUBFWB 02,W
04AAA:  MOVWF  xBB
.................... 									set_timer0(tempo);  
04AAC:  MOVFF  1BB,FD7
04AB0:  MOVFF  1BA,FD6
....................  									contador_rampa_descida_flip++;  
04AB4:  INCF   4E,F
04AB6:  BTFSC  FD8.2
04AB8:  INCF   4F,F
....................        						    }                  		 
04ABA:  BRA    4AE8
.................... 									else 
.................... 											{ 
.................... 																								 
.................... 												tempo =(65535 - (speed_flip * 5)); 
04ABC:  MOVFF  1B4,215
04AC0:  MOVFF  1B3,214
04AC4:  MOVLB  2
04AC6:  CLRF   x17
04AC8:  MOVLW  05
04ACA:  MOVWF  x16
04ACC:  MOVLB  0
04ACE:  CALL   27BE
04AD2:  MOVF   01,W
04AD4:  SUBLW  FF
04AD6:  MOVLB  1
04AD8:  MOVWF  xBA
04ADA:  MOVLW  FF
04ADC:  SUBFWB 02,W
04ADE:  MOVWF  xBB
.................... 												set_timer0(tempo);   
04AE0:  MOVFF  1BB,FD7
04AE4:  MOVFF  1BA,FD6
....................  
.................... 											} 
....................  
.................... 						 
....................  
.................... 				    }	 
04AE8:  MOVLB  0
04AEA:  GOTO   4DDE (RETURN)
....................  
.................... } 
....................  
....................  
.................... void rampa__z(long int speed_z,long int speed_inicial_final_z,long int z_posicao,int rampa_z) 
.................... { 
.................... 	long int tempo;	 
.................... 	signed long int steps_percorridos; 
.................... 	signed long int steps_faltam; 
.................... 	long int degrau_z; 
.................... 	degrau_z=(speed_inicial_final_z - speed_z); 
.................... 	degrau_z=degrau_z/rampa_z; 
....................  
.................... 	steps_percorridos=contador_step_flip_inicial - contador_step_flip; 
.................... 	if(steps_percorridos < 0) steps_percorridos=steps_percorridos * (-1); 
....................  
.................... 	steps_faltam=z_posicao - contador_step_z; 
.................... 	if(steps_faltam < 0) 	steps_faltam=steps_faltam * (-1); 
.................... 	 
.................... 		if(steps_percorridos <= rampa_z) 
.................... 			{ 
.................... 				tempo=(speed_inicial_final_z -(contador_rampa_subida_z * degrau_z)); 
.................... 				tempo =(65535 - (tempo * 5)); 
.................... 				set_timer0(tempo);                                  
.................... 				contador_rampa_subida_z++; 
....................  
.................... 			} 
.................... 				else{ 
.................... 						 
.................... 							if(steps_faltam <= rampa_z)	 
.................... 								{ 
.................... 									tempo=(speed_z +(contador_rampa_descida_z * degrau_z)); 
.................... 									tempo =(65535 - (tempo * 5)); 
.................... 									set_timer0(tempo);  
....................  									contador_rampa_descida_z++;  
....................        						    }                  		 
.................... 									else 
.................... 											{ 
.................... 																								 
.................... 												tempo =(65535 - (speed_z * 5)); 
.................... 												set_timer0(tempo);   
....................  
.................... 											} 
....................  
.................... 						 
....................  
.................... 				    }	 
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... void	go_x_y(long int x_posicao,long int y_posicao,long int speed_x,long int speed_y,long int velocidade_inicial_final_x,long int velocidade_inicial_final_y,int step1,int step2,short int rampa_x,short int rampa_y,short int dedo,short int delay_x_y ) 
*
042F6:  MOVLB  1
042F8:  CLRF   xAF
042FA:  CLRF   xAE
042FC:  MOVLW  27
042FE:  MOVWF  xB1
04300:  MOVLW  10
04302:  MOVWF  xB0
.................... { 
.................... 		//signed long int steps_faltam;	 
.................... 	    long int time_out = 0; 
....................         long int time_out_max = 10000; 
.................... 	    contador_step_x_inicial = contador_step_x; 
04304:  MOVFF  179,3D
04308:  MOVFF  178,3C
.................... 		contador_step_y_inicial = contador_step_y; 
0430C:  MOVFF  17B,3F
04310:  MOVFF  17A,3E
.................... 		velocidade_x =   (65535 - (speed_x * 5)); 
04314:  MOVFF  1A1,215
04318:  MOVFF  1A0,214
0431C:  MOVLB  2
0431E:  CLRF   x17
04320:  MOVLW  05
04322:  MOVWF  x16
04324:  MOVLB  0
04326:  CALL   27BE
0432A:  MOVF   01,W
0432C:  SUBLW  FF
0432E:  MOVWF  34
04330:  MOVLW  FF
04332:  SUBFWB 02,W
04334:  MOVWF  35
.................... 		velocidade_y =   (65535 - (speed_y * 5)); 
04336:  MOVFF  1A3,215
0433A:  MOVFF  1A2,214
0433E:  MOVLB  2
04340:  CLRF   x17
04342:  MOVLW  05
04344:  MOVWF  x16
04346:  MOVLB  0
04348:  CALL   27BE
0434C:  MOVF   01,W
0434E:  SUBLW  FF
04350:  MOVWF  36
04352:  MOVLW  FF
04354:  SUBFWB 02,W
04356:  MOVWF  37
....................  
....................  
.................... 		contador_rampa_subida_x =  0;  
04358:  CLRF   45
0435A:  CLRF   44
....................         contador_rampa_descida_x = 0;   
0435C:  CLRF   47
0435E:  CLRF   46
.................... 		contador_rampa_subida_y =  0;  
04360:  CLRF   49
04362:  CLRF   48
.................... 		contador_rampa_descida_y = 0;  
04364:  CLRF   4B
04366:  CLRF   4A
....................  
.................... 		estouro_timer1 = true; 
04368:  BSF    1E.4
.................... 		estouro_timer3 = true; 
0436A:  BSF    1E.5
....................  
....................  
.................... 		if(x_posicao !=  contador_step_x) 
0436C:  MOVLB  1
0436E:  MOVF   x78,W
04370:  SUBWF  x9C,W
04372:  BNZ   437A
04374:  MOVF   x79,W
04376:  SUBWF  x9D,W
04378:  BZ    43CE
.................... 		{ 
.................... 			 
.................... 		 
.................... 							if (x_posicao > contador_step_x) 
0437A:  MOVF   x79,W
0437C:  SUBWF  x9D,W
0437E:  BNC   43AC
04380:  BNZ   4388
04382:  MOVF   x9C,W
04384:  SUBWF  x78,W
04386:  BC    43AC
.................... 								   {  
.................... 										if(direita_flag==true) 
04388:  BTFSS  x80.0
0438A:  BRA    4396
.................... 											{	 
.................... 												esquerda();    
0438C:  MOVLB  0
0438E:  CALL   3306
....................  
.................... 											} else 
04392:  BRA    43A8
04394:  MOVLB  1
.................... 													{ 
.................... 														esquerda();   
04396:  MOVLB  0
04398:  CALL   3306
.................... 														delay_ms(20); 
0439C:  MOVLW  14
0439E:  MOVLB  2
043A0:  MOVWF  x17
043A2:  MOVLB  0
043A4:  CALL   1D50
....................  
.................... 													}  
.................... 									}else{ 
043A8:  BRA    43CC
043AA:  MOVLB  1
.................... 											 	if(esquerda_flag==true) 
043AC:  BTFSS  x80.1
043AE:  BRA    43BA
.................... 												{	 
....................  
.................... 													direita();    
043B0:  MOVLB  0
043B2:  CALL   32C4
....................  
.................... 												}else 
043B6:  BRA    43CC
043B8:  MOVLB  1
.................... 														{ 
.................... 															direita();      
043BA:  MOVLB  0
043BC:  CALL   32C4
.................... 															delay_ms(20); 
043C0:  MOVLW  14
043C2:  MOVLB  2
043C4:  MOVWF  x17
043C6:  MOVLB  0
043C8:  CALL   1D50
043CC:  MOVLB  1
.................... 	 
.................... 														}  
.................... 											 
.................... 						 
.................... 										} 
....................  
.................... 						     
....................  
.................... 		} 
....................  
....................  
.................... 						if(y_posicao !=  contador_step_y) 
043CE:  MOVF   x7A,W
043D0:  SUBWF  x9E,W
043D2:  BNZ   43DA
043D4:  MOVF   x7B,W
043D6:  SUBWF  x9F,W
043D8:  BZ    442E
.................... 						{						 
.................... 								if (y_posicao > contador_step_y) 
043DA:  MOVF   x7B,W
043DC:  SUBWF  x9F,W
043DE:  BNC   440C
043E0:  BNZ   43E8
043E2:  MOVF   x9E,W
043E4:  SUBWF  x7A,W
043E6:  BC    440C
.................... 			   						{ 
.................... 										if(atras_flag==true) 
043E8:  BTFSS  x80.3
043EA:  BRA    43F6
.................... 										{	 
....................  
.................... 											atras();   
043EC:  MOVLB  0
043EE:  CALL   319A
....................  
.................... 										} 								 
043F2:  BRA    4408
043F4:  MOVLB  1
.................... 										else 
.................... 											{ 
.................... 	 
.................... 												atras();   
043F6:  MOVLB  0
043F8:  CALL   319A
.................... 												delay_ms(40);	 
043FC:  MOVLW  28
043FE:  MOVLB  2
04400:  MOVWF  x17
04402:  MOVLB  0
04404:  CALL   1D50
.................... 											}  
....................  
....................  
.................... 									 
.................... 									}			 
04408:  BRA    442C
0440A:  MOVLB  1
.................... 										else 
.................... 											{ 
.................... 												if(frente_flag==true) 
0440C:  BTFSS  x80.2
0440E:  BRA    441A
.................... 												{ 
.................... 													frente(); 
04410:  MOVLB  0
04412:  CALL   3158
....................  
.................... 	 											} 
04416:  BRA    442C
04418:  MOVLB  1
.................... 												else{ 
.................... 													 
.................... 													frente(); 
0441A:  MOVLB  0
0441C:  CALL   3158
.................... 													delay_ms(40); 
04420:  MOVLW  28
04422:  MOVLB  2
04424:  MOVWF  x17
04426:  MOVLB  0
04428:  CALL   1D50
0442C:  MOVLB  1
.................... 													}	 
.................... 											} 
....................  
.................... 						} 
.................... 				  
....................  						contador_tempo = 0000; 
0442E:  CLRF   20
04430:  CLRF   1F
.................... 		 
....................  
.................... 	while((x_posicao != contador_step_x) || (y_posicao != contador_step_y))	 
04432:  MOVF   x78,W
04434:  SUBWF  x9C,W
04436:  BNZ   444C
04438:  MOVF   x79,W
0443A:  SUBWF  x9D,W
0443C:  BNZ   444C
0443E:  MOVF   x7A,W
04440:  SUBWF  x9E,W
04442:  BNZ   444C
04444:  MOVF   x7B,W
04446:  SUBWF  x9F,W
04448:  BTFSC  FD8.2
0444A:  BRA    4522
.................... 	{ 
....................  
.................... 					if(estouro_timer1 == true)		 
0444C:  BTFSS  1E.4
0444E:  BRA    44A4
.................... 					{ 
.................... 							 
.................... 						if(x_posicao != contador_step_x) 
04450:  MOVF   x78,W
04452:  SUBWF  x9C,W
04454:  BNZ   445C
04456:  MOVF   x79,W
04458:  SUBWF  x9D,W
0445A:  BZ    44A4
.................... 						{ 
.................... 							 
.................... 									one_step_x(); 
0445C:  MOVLB  0
0445E:  CALL   32D2
.................... 									estouro_timer1 = false; 
04462:  BCF    1E.4
.................... 									setup_timer_1(T1_INTERNAL | T1_DIV_BY_1 ); 
04464:  MOVLW  85
04466:  MOVWF  FCD
.................... 									enable_interrupts(INT_TIMER1); 
04468:  BSF    F9D.0
....................  
.................... 									if(rampa_x == true) 
0446A:  MOVLB  1
0446C:  DECFSZ xAA,W
0446E:  BRA    4494
.................... 									{ 
.................... 										 rampa_xx(speed_x,velocidade_inicial_final_x,x_posicao,step1); 
04470:  MOVFF  1A1,1B4
04474:  MOVFF  1A0,1B3
04478:  MOVFF  1A5,1B6
0447C:  MOVFF  1A4,1B5
04480:  MOVFF  19D,1B8
04484:  MOVFF  19C,1B7
04488:  MOVFF  1A8,1B9
0448C:  MOVLB  0
0448E:  RCALL  3FF2
....................  
.................... 									} 
04490:  BRA    449E
04492:  MOVLB  1
.................... 										else 
.................... 											{ 
....................  
.................... 												set_timer1(velocidade_x); 
04494:  MOVFF  35,FCF
04498:  MOVFF  34,FCE
0449C:  MOVLB  0
.................... 											} 
....................  
.................... 												enable_interrupts(GLOBAL);																 
0449E:  MOVLW  C0
044A0:  IORWF  FF2,F
044A2:  MOVLB  1
.................... 								 
.................... 						}				  
.................... 													 
....................  
.................... 				  } 
.................... 				 
....................  
.................... 			if(estouro_timer3 == true)		 
044A4:  BTFSS  1E.5
044A6:  BRA    44FC
.................... 				{ 
....................  
.................... 						if(y_posicao != contador_step_y) 
044A8:  MOVF   x7A,W
044AA:  SUBWF  x9E,W
044AC:  BNZ   44B4
044AE:  MOVF   x7B,W
044B0:  SUBWF  x9F,W
044B2:  BZ    44FC
.................... 							{ 
.................... 								 
.................... 	 
.................... 							            
.................... 										one_step_y(); 
044B4:  MOVLB  0
044B6:  CALL   3166
.................... 							 
....................  
.................... 										estouro_timer3 = false; 
044BA:  BCF    1E.5
.................... 										setup_timer_3(T3_INTERNAL | T3_DIV_BY_1 ); 
044BC:  MOVLW  85
044BE:  MOVWF  FB1
.................... 										enable_interrupts(INT_TIMER3); 
044C0:  BSF    FA0.1
....................  
.................... 											if(rampa_y == true) 
044C2:  MOVLB  1
044C4:  DECFSZ xAB,W
044C6:  BRA    44EC
.................... 												{ 
.................... 										 			rampa_yy(speed_y,velocidade_inicial_final_y,y_posicao,step2); 
044C8:  MOVFF  1A3,1B4
044CC:  MOVFF  1A2,1B3
044D0:  MOVFF  1A7,1B6
044D4:  MOVFF  1A6,1B5
044D8:  MOVFF  19F,1B8
044DC:  MOVFF  19E,1B7
044E0:  MOVFF  1A9,1B9
044E4:  MOVLB  0
044E6:  RCALL  4174
....................  
.................... 												} 
044E8:  BRA    44F6
044EA:  MOVLB  1
.................... 													else 
.................... 													{ 
....................  
.................... 														set_timer3(velocidade_y); 
044EC:  MOVFF  37,FB3
044F0:  MOVFF  36,FB2
044F4:  MOVLB  0
.................... 													} 
....................  
....................  
....................  
.................... 									 
.................... 										enable_interrupts(GLOBAL); 
044F6:  MOVLW  C0
044F8:  IORWF  FF2,F
044FA:  MOVLB  1
.................... 								 
.................... 							 
.................... 							} 
....................  
.................... 				} 
.................... 							 
.................... 									 
.................... 									while((estouro_timer1 || estouro_timer3) == false){} 
044FC:  BTFSC  1E.4
044FE:  BRA    4508
04500:  BTFSC  1E.5
04502:  BRA    4508
04504:  MOVLW  00
04506:  BRA    450A
04508:  MOVLW  01
0450A:  XORLW  00
0450C:  BTFSC  FD8.2
0450E:  BRA    44FC
....................                                     
.................... 	 										if(estouro_timer1 == true) 
04510:  BTFSS  1E.4
04512:  BRA    4518
.................... 												{ 
.................... 													disable_interrupts(INT_TIMER1); 
04514:  BCF    F9D.0
.................... 													setup_timer_1	(t1_disabled); 
04516:  CLRF   FCD
....................  
....................  
.................... 												} 
....................  
.................... 											if(estouro_timer3 == true) 
04518:  BTFSS  1E.5
0451A:  BRA    4520
.................... 												{ 
....................  
.................... 													disable_interrupts(INT_TIMER3); 
0451C:  BCF    FA0.1
.................... 													setup_timer_3	(t3_disabled); 
0451E:  CLRF   FB1
....................  
....................  
.................... 												} 
04520:  BRA    4432
.................... 											 
.................... 										 
.................... 										 
....................  
.................... 					  
.................... 									 
.................... 	} 
.................... 							 
.................... 							 
.................... 					disable_interrupts(INT_TIMER1); 
04522:  BCF    F9D.0
.................... 					setup_timer_1	(t1_disabled); 
04524:  CLRF   FCD
.................... 					disable_interrupts(INT_TIMER3); 
04526:  BCF    FA0.1
.................... 					setup_timer_3	(t3_disabled); 
04528:  CLRF   FB1
0452A:  MOVLB  0
0452C:  RETURN 0
.................... 					//disable_interrupts(GLOBAL); 
....................  
.................... } 
....................  
....................  
....................  
.................... void	go_x_y_negativo(long int x_posicao,long int y_posicao,long int speed_x,long int speed_y,long int velocidade_inicial_final_x,long int velocidade_inicial_final_y,int step1,int step2,short int rampa_x,short int rampa_y,short int dedo,short int delay_x_y ) 
*
04E6A:  MOVLB  1
04E6C:  CLRF   xAA
04E6E:  CLRF   xA9
04E70:  MOVLW  27
04E72:  MOVWF  xAC
04E74:  MOVLW  10
04E76:  MOVWF  xAB
.................... { 
.................... 		//signed long int steps_faltam;	 
.................... 	    long int time_out = 0; 
....................         long int time_out_max = 10000; 
....................  
.................... 	    contador_step_x_inicial = contador_step_x; 
04E78:  MOVFF  179,3D
04E7C:  MOVFF  178,3C
.................... 		contador_step_y_inicial = contador_step_y; 
04E80:  MOVFF  17B,3F
04E84:  MOVFF  17A,3E
.................... 		velocidade_x =   (65535 - (speed_x * 5)); 
04E88:  MOVFF  19C,215
04E8C:  MOVFF  19B,214
04E90:  MOVLB  2
04E92:  CLRF   x17
04E94:  MOVLW  05
04E96:  MOVWF  x16
04E98:  MOVLB  0
04E9A:  CALL   27BE
04E9E:  MOVF   01,W
04EA0:  SUBLW  FF
04EA2:  MOVWF  34
04EA4:  MOVLW  FF
04EA6:  SUBFWB 02,W
04EA8:  MOVWF  35
.................... 		velocidade_y =   (65535 - (speed_y * 5)); 
04EAA:  MOVFF  19E,215
04EAE:  MOVFF  19D,214
04EB2:  MOVLB  2
04EB4:  CLRF   x17
04EB6:  MOVLW  05
04EB8:  MOVWF  x16
04EBA:  MOVLB  0
04EBC:  CALL   27BE
04EC0:  MOVF   01,W
04EC2:  SUBLW  FF
04EC4:  MOVWF  36
04EC6:  MOVLW  FF
04EC8:  SUBFWB 02,W
04ECA:  MOVWF  37
....................  
....................  
.................... 		contador_rampa_subida_x =  0;  
04ECC:  CLRF   45
04ECE:  CLRF   44
....................         contador_rampa_descida_x = 0;   
04ED0:  CLRF   47
04ED2:  CLRF   46
.................... 		contador_rampa_subida_y =  0;  
04ED4:  CLRF   49
04ED6:  CLRF   48
.................... 		contador_rampa_descida_y = 0;  
04ED8:  CLRF   4B
04EDA:  CLRF   4A
....................  
.................... 		estouro_timer1 = true; 
04EDC:  BSF    1E.4
.................... 		estouro_timer3 = true; 
04EDE:  BSF    1E.5
....................  
....................  
.................... 		if(x_posicao !=  contador_step_x) 
04EE0:  MOVLB  1
04EE2:  MOVF   x78,W
04EE4:  SUBWF  x97,W
04EE6:  BNZ   4EEE
04EE8:  MOVF   x79,W
04EEA:  SUBWF  x98,W
04EEC:  BZ    4F42
.................... 		{ 
.................... 			 
.................... 		 
.................... 							if (x_posicao > contador_step_x) 
04EEE:  MOVF   x79,W
04EF0:  SUBWF  x98,W
04EF2:  BNC   4F20
04EF4:  BNZ   4EFC
04EF6:  MOVF   x97,W
04EF8:  SUBWF  x78,W
04EFA:  BC    4F20
.................... 								   {  
.................... 										if(direita_flag==true) 
04EFC:  BTFSS  x80.0
04EFE:  BRA    4F0A
.................... 											{	 
.................... 												esquerda();    
04F00:  MOVLB  0
04F02:  CALL   3306
....................  
.................... 											} else 
04F06:  BRA    4F1C
04F08:  MOVLB  1
.................... 													{ 
.................... 														esquerda();   
04F0A:  MOVLB  0
04F0C:  CALL   3306
.................... 														delay_ms(20); 
04F10:  MOVLW  14
04F12:  MOVLB  2
04F14:  MOVWF  x17
04F16:  MOVLB  0
04F18:  CALL   1D50
....................  
.................... 													}  
.................... 									}else{ 
04F1C:  BRA    4F40
04F1E:  MOVLB  1
.................... 											 	if(esquerda_flag==true) 
04F20:  BTFSS  x80.1
04F22:  BRA    4F2E
.................... 												{	 
....................  
.................... 													direita();    
04F24:  MOVLB  0
04F26:  CALL   32C4
....................  
.................... 												}else 
04F2A:  BRA    4F40
04F2C:  MOVLB  1
.................... 														{ 
.................... 															direita();      
04F2E:  MOVLB  0
04F30:  CALL   32C4
.................... 															delay_ms(20); 
04F34:  MOVLW  14
04F36:  MOVLB  2
04F38:  MOVWF  x17
04F3A:  MOVLB  0
04F3C:  CALL   1D50
04F40:  MOVLB  1
.................... 	 
.................... 														}  
.................... 											 
.................... 						 
.................... 										} 
....................  
.................... 						     
....................  
.................... 		} 
....................  
....................  
.................... 						if(y_posicao !=  contador_step_y) 
04F42:  MOVF   x7A,W
04F44:  SUBWF  x99,W
04F46:  BNZ   4F4E
04F48:  MOVF   x7B,W
04F4A:  SUBWF  x9A,W
04F4C:  BZ    4FA2
.................... 						{						 
.................... 								if (y_posicao > contador_step_y) 
04F4E:  MOVF   x7B,W
04F50:  SUBWF  x9A,W
04F52:  BNC   4F80
04F54:  BNZ   4F5C
04F56:  MOVF   x99,W
04F58:  SUBWF  x7A,W
04F5A:  BC    4F80
.................... 			   						{ 
.................... 										if(frente_flag==true) 
04F5C:  BTFSS  x80.2
04F5E:  BRA    4F6A
.................... 										{	 
....................  
.................... 											frente();   
04F60:  MOVLB  0
04F62:  CALL   3158
....................  
.................... 										} 								 
04F66:  BRA    4F7C
04F68:  MOVLB  1
.................... 										else 
.................... 											{ 
.................... 	 
.................... 												frente();   
04F6A:  MOVLB  0
04F6C:  CALL   3158
.................... 												delay_ms(40);	 
04F70:  MOVLW  28
04F72:  MOVLB  2
04F74:  MOVWF  x17
04F76:  MOVLB  0
04F78:  CALL   1D50
.................... 											}  
....................  
....................  
.................... 									 
.................... 									}			 
04F7C:  BRA    4FA0
04F7E:  MOVLB  1
.................... 										else 
.................... 											{ 
.................... 												if(atras_flag==true) 
04F80:  BTFSS  x80.3
04F82:  BRA    4F8E
.................... 												{ 
.................... 													atras(); 
04F84:  MOVLB  0
04F86:  CALL   319A
....................  
.................... 	 											} 
04F8A:  BRA    4FA0
04F8C:  MOVLB  1
.................... 												else{ 
.................... 													 
.................... 													atras(); 
04F8E:  MOVLB  0
04F90:  CALL   319A
.................... 													delay_ms(40); 
04F94:  MOVLW  28
04F96:  MOVLB  2
04F98:  MOVWF  x17
04F9A:  MOVLB  0
04F9C:  CALL   1D50
04FA0:  MOVLB  1
.................... 													}	 
.................... 											} 
....................  
.................... 						} 
.................... 				  
....................  						contador_tempo = 0000; 
04FA2:  CLRF   20
04FA4:  CLRF   1F
.................... 		 
....................  
.................... 	while((x_posicao != contador_step_x) || (y_posicao != contador_step_y))	 
04FA6:  MOVF   x78,W
04FA8:  SUBWF  x97,W
04FAA:  BNZ   4FC0
04FAC:  MOVF   x79,W
04FAE:  SUBWF  x98,W
04FB0:  BNZ   4FC0
04FB2:  MOVF   x7A,W
04FB4:  SUBWF  x99,W
04FB6:  BNZ   4FC0
04FB8:  MOVF   x7B,W
04FBA:  SUBWF  x9A,W
04FBC:  BTFSC  FD8.2
04FBE:  BRA    5098
.................... 	{ 
....................  
.................... 					if(estouro_timer1 == true)		 
04FC0:  BTFSS  1E.4
04FC2:  BRA    501A
.................... 					{ 
.................... 							 
.................... 						if(x_posicao != contador_step_x) 
04FC4:  MOVF   x78,W
04FC6:  SUBWF  x97,W
04FC8:  BNZ   4FD0
04FCA:  MOVF   x79,W
04FCC:  SUBWF  x98,W
04FCE:  BZ    501A
.................... 						{ 
.................... 							 
.................... 									one_step_x(); 
04FD0:  MOVLB  0
04FD2:  CALL   32D2
.................... 									estouro_timer1 = false; 
04FD6:  BCF    1E.4
.................... 									setup_timer_1(T1_INTERNAL | T1_DIV_BY_1 ); 
04FD8:  MOVLW  85
04FDA:  MOVWF  FCD
.................... 									enable_interrupts(INT_TIMER1); 
04FDC:  BSF    F9D.0
....................  
.................... 									if(rampa_x == true) 
04FDE:  MOVLB  1
04FE0:  DECFSZ xA5,W
04FE2:  BRA    500A
.................... 									{ 
.................... 										 rampa_xx(speed_x,velocidade_inicial_final_x,x_posicao,step1); 
04FE4:  MOVFF  19C,1B4
04FE8:  MOVFF  19B,1B3
04FEC:  MOVFF  1A0,1B6
04FF0:  MOVFF  19F,1B5
04FF4:  MOVFF  198,1B8
04FF8:  MOVFF  197,1B7
04FFC:  MOVFF  1A3,1B9
05000:  MOVLB  0
05002:  CALL   3FF2
....................  
.................... 									} 
05006:  BRA    5014
05008:  MOVLB  1
.................... 										else 
.................... 											{ 
....................  
.................... 												set_timer1(velocidade_x); 
0500A:  MOVFF  35,FCF
0500E:  MOVFF  34,FCE
05012:  MOVLB  0
.................... 											} 
....................  
.................... 												enable_interrupts(GLOBAL);																 
05014:  MOVLW  C0
05016:  IORWF  FF2,F
05018:  MOVLB  1
.................... 								 
.................... 						}				  
.................... 													 
....................  
.................... 				  } 
.................... 				 
....................  
.................... 			if(estouro_timer3 == true)		 
0501A:  BTFSS  1E.5
0501C:  BRA    5072
.................... 				{ 
....................  
.................... 						if(y_posicao != contador_step_y) 
0501E:  MOVF   x7A,W
05020:  SUBWF  x99,W
05022:  BNZ   502A
05024:  MOVF   x7B,W
05026:  SUBWF  x9A,W
05028:  BZ    5072
.................... 							{ 
.................... 								 
.................... 	 
.................... 							            
.................... 										one_step_y_negativo(); 
0502A:  MOVLB  0
0502C:  BRA    4E34
.................... 							 
....................  
.................... 										estouro_timer3 = false; 
0502E:  BCF    1E.5
.................... 										setup_timer_3(T3_INTERNAL | T3_DIV_BY_1 ); 
05030:  MOVLW  85
05032:  MOVWF  FB1
.................... 										enable_interrupts(INT_TIMER3); 
05034:  BSF    FA0.1
....................  
.................... 											if(rampa_y == true) 
05036:  MOVLB  1
05038:  DECFSZ xA6,W
0503A:  BRA    5062
.................... 												{ 
.................... 										 			rampa_yy(speed_y,velocidade_inicial_final_y,y_posicao,step2); 
0503C:  MOVFF  19E,1B4
05040:  MOVFF  19D,1B3
05044:  MOVFF  1A2,1B6
05048:  MOVFF  1A1,1B5
0504C:  MOVFF  19A,1B8
05050:  MOVFF  199,1B7
05054:  MOVFF  1A4,1B9
05058:  MOVLB  0
0505A:  CALL   4174
....................  
.................... 												} 
0505E:  BRA    506C
05060:  MOVLB  1
.................... 													else 
.................... 													{ 
....................  
.................... 														set_timer3(velocidade_y); 
05062:  MOVFF  37,FB3
05066:  MOVFF  36,FB2
0506A:  MOVLB  0
.................... 													} 
....................  
....................  
....................  
.................... 									 
.................... 										enable_interrupts(GLOBAL); 
0506C:  MOVLW  C0
0506E:  IORWF  FF2,F
05070:  MOVLB  1
.................... 								 
.................... 							 
.................... 							} 
....................  
.................... 				} 
.................... 							 
.................... 									 
.................... 									while((estouro_timer1 || estouro_timer3) == false){}	 
05072:  BTFSC  1E.4
05074:  BRA    507E
05076:  BTFSC  1E.5
05078:  BRA    507E
0507A:  MOVLW  00
0507C:  BRA    5080
0507E:  MOVLW  01
05080:  XORLW  00
05082:  BTFSC  FD8.2
05084:  BRA    5072
....................                                    								 
.................... 	 										if(estouro_timer1 == true) 
05086:  BTFSS  1E.4
05088:  BRA    508E
.................... 												{ 
.................... 													disable_interrupts(INT_TIMER1); 
0508A:  BCF    F9D.0
.................... 													setup_timer_1	(t1_disabled); 
0508C:  CLRF   FCD
....................  
....................  
.................... 												} 
....................  
.................... 											if(estouro_timer3 == true) 
0508E:  BTFSS  1E.5
05090:  BRA    5096
.................... 												{ 
....................  
.................... 													disable_interrupts(INT_TIMER3); 
05092:  BCF    FA0.1
.................... 													setup_timer_3	(t3_disabled); 
05094:  CLRF   FB1
....................  
....................  
.................... 												} 
05096:  BRA    4FA6
.................... 											 
.................... 										 
.................... 										 
....................  
.................... 					  
.................... 									 
.................... 	} 
.................... 							 
.................... 							 
.................... 					disable_interrupts(INT_TIMER1); 
05098:  BCF    F9D.0
.................... 					setup_timer_1	(t1_disabled); 
0509A:  CLRF   FCD
.................... 					disable_interrupts(INT_TIMER3); 
0509C:  BCF    FA0.1
.................... 					setup_timer_3	(t3_disabled); 
0509E:  CLRF   FB1
050A0:  MOVLB  0
050A2:  RETURN 0
.................... 				   //disable_interrupts(GLOBAL); 
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... void	go_x_y_flip(long int x_posicao,long int y_posicao,long int flip_posicao,long int speed_x, 
.................... long int speed_y,long int speed_flip,long int velocidade_inicial_final_x,long int velocidade_inicial_final_y, 
.................... long int velocidade_inicial_final_flip,int step1,int step2,int step3,short int rampa_x,short int rampa_y,short int rampa_flip) 
*
04AEE:  MOVLB  1
04AF0:  CLRF   xB0
04AF2:  CLRF   xAF
04AF4:  MOVLW  27
04AF6:  MOVWF  xB2
04AF8:  MOVLW  10
04AFA:  MOVWF  xB1
.................... { 
.................... 		long int time_out = 0; 
....................         long int time_out_max = 10000; 
.................... 	 
.................... 	    contador_step_x_inicial = contador_step_x; 
04AFC:  MOVFF  179,3D
04B00:  MOVFF  178,3C
.................... 		contador_step_y_inicial = contador_step_y; 
04B04:  MOVFF  17B,3F
04B08:  MOVFF  17A,3E
.................... 		contador_step_flip_inicial = contador_step_flip; 
04B0C:  MOVFF  17D,41
04B10:  MOVFF  17C,40
....................  
.................... 		velocidade_x    =   (65535 - (speed_x * 5)); 
04B14:  MOVFF  19E,215
04B18:  MOVFF  19D,214
04B1C:  MOVLB  2
04B1E:  CLRF   x17
04B20:  MOVLW  05
04B22:  MOVWF  x16
04B24:  MOVLB  0
04B26:  CALL   27BE
04B2A:  MOVF   01,W
04B2C:  SUBLW  FF
04B2E:  MOVWF  34
04B30:  MOVLW  FF
04B32:  SUBFWB 02,W
04B34:  MOVWF  35
.................... 		velocidade_y    =   (65535 - (speed_y * 5)); 
04B36:  MOVFF  1A0,215
04B3A:  MOVFF  19F,214
04B3E:  MOVLB  2
04B40:  CLRF   x17
04B42:  MOVLW  05
04B44:  MOVWF  x16
04B46:  MOVLB  0
04B48:  CALL   27BE
04B4C:  MOVF   01,W
04B4E:  SUBLW  FF
04B50:  MOVWF  36
04B52:  MOVLW  FF
04B54:  SUBFWB 02,W
04B56:  MOVWF  37
.................... 		velocidade_flip =   (65535 - (speed_flip * 5)); 
04B58:  MOVFF  1A2,215
04B5C:  MOVFF  1A1,214
04B60:  MOVLB  2
04B62:  CLRF   x17
04B64:  MOVLW  05
04B66:  MOVWF  x16
04B68:  MOVLB  0
04B6A:  CALL   27BE
04B6E:  MOVF   01,W
04B70:  SUBLW  FF
04B72:  MOVWF  38
04B74:  MOVLW  FF
04B76:  SUBFWB 02,W
04B78:  MOVWF  39
....................  
....................      
....................  
.................... 		contador_rampa_subida_x =     0;  
04B7A:  CLRF   45
04B7C:  CLRF   44
....................         contador_rampa_descida_x =    0;   
04B7E:  CLRF   47
04B80:  CLRF   46
.................... 		contador_rampa_subida_y =     0;  
04B82:  CLRF   49
04B84:  CLRF   48
.................... 		contador_rampa_descida_y =    0;  
04B86:  CLRF   4B
04B88:  CLRF   4A
.................... 	    contador_rampa_subida_flip =  0;  
04B8A:  CLRF   4D
04B8C:  CLRF   4C
.................... 		contador_rampa_descida_flip = 0;  
04B8E:  CLRF   4F
04B90:  CLRF   4E
....................  
.................... 		estouro_timer0 = true; 
04B92:  BSF    1E.6
.................... 		estouro_timer1 = true; 
04B94:  BSF    1E.4
.................... 		estouro_timer3 = true; 
04B96:  BSF    1E.5
....................         trata_timer_zero_modo = 0; 
04B98:  BCF    1E.2
....................  
.................... 		if(x_posicao !=  contador_step_x) 
04B9A:  MOVLB  1
04B9C:  MOVF   x78,W
04B9E:  SUBWF  x97,W
04BA0:  BNZ   4BA8
04BA2:  MOVF   x79,W
04BA4:  SUBWF  x98,W
04BA6:  BZ    4BFC
.................... 		{ 
.................... 			 
.................... 		 
.................... 							if (x_posicao > contador_step_x) 
04BA8:  MOVF   x79,W
04BAA:  SUBWF  x98,W
04BAC:  BNC   4BDA
04BAE:  BNZ   4BB6
04BB0:  MOVF   x97,W
04BB2:  SUBWF  x78,W
04BB4:  BC    4BDA
.................... 								   {  
.................... 										if(direita_flag==true) 
04BB6:  BTFSS  x80.0
04BB8:  BRA    4BC4
.................... 											{	 
.................... 												esquerda();    
04BBA:  MOVLB  0
04BBC:  CALL   3306
....................  
.................... 											} else 
04BC0:  BRA    4BD6
04BC2:  MOVLB  1
.................... 													{ 
.................... 														esquerda();   
04BC4:  MOVLB  0
04BC6:  CALL   3306
.................... 														delay_ms(20); 
04BCA:  MOVLW  14
04BCC:  MOVLB  2
04BCE:  MOVWF  x17
04BD0:  MOVLB  0
04BD2:  CALL   1D50
....................  
.................... 													}  
.................... 									}else{ 
04BD6:  BRA    4BFA
04BD8:  MOVLB  1
.................... 											 	if(esquerda_flag==true) 
04BDA:  BTFSS  x80.1
04BDC:  BRA    4BE8
.................... 												{	 
....................  
.................... 													direita();    
04BDE:  MOVLB  0
04BE0:  CALL   32C4
....................  
.................... 												}else 
04BE4:  BRA    4BFA
04BE6:  MOVLB  1
.................... 														{ 
.................... 															direita();      
04BE8:  MOVLB  0
04BEA:  CALL   32C4
.................... 															delay_ms(20); 
04BEE:  MOVLW  14
04BF0:  MOVLB  2
04BF2:  MOVWF  x17
04BF4:  MOVLB  0
04BF6:  CALL   1D50
04BFA:  MOVLB  1
.................... 	 
.................... 														}  
.................... 											 
.................... 						 
.................... 										} 
....................  
.................... 						     
....................  
.................... 		} 
....................  
....................  
.................... 						if(y_posicao !=  contador_step_y) 
04BFC:  MOVF   x7A,W
04BFE:  SUBWF  x99,W
04C00:  BNZ   4C08
04C02:  MOVF   x7B,W
04C04:  SUBWF  x9A,W
04C06:  BZ    4C5C
.................... 						{						 
.................... 								if (y_posicao > contador_step_y) 
04C08:  MOVF   x7B,W
04C0A:  SUBWF  x9A,W
04C0C:  BNC   4C3A
04C0E:  BNZ   4C16
04C10:  MOVF   x99,W
04C12:  SUBWF  x7A,W
04C14:  BC    4C3A
.................... 			   						{ 
.................... 										if(atras_flag==true) 
04C16:  BTFSS  x80.3
04C18:  BRA    4C24
.................... 										{	 
....................  
.................... 											atras();   
04C1A:  MOVLB  0
04C1C:  CALL   319A
....................  
.................... 										} 								 
04C20:  BRA    4C36
04C22:  MOVLB  1
.................... 										else 
.................... 											{ 
.................... 	 
.................... 												atras();   
04C24:  MOVLB  0
04C26:  CALL   319A
.................... 												delay_ms(40);	 
04C2A:  MOVLW  28
04C2C:  MOVLB  2
04C2E:  MOVWF  x17
04C30:  MOVLB  0
04C32:  CALL   1D50
.................... 											}  
....................  
....................  
.................... 									 
.................... 									}			 
04C36:  BRA    4C5A
04C38:  MOVLB  1
.................... 										else 
.................... 											{ 
.................... 												if(frente_flag==true) 
04C3A:  BTFSS  x80.2
04C3C:  BRA    4C48
.................... 												{ 
.................... 													frente(); 
04C3E:  MOVLB  0
04C40:  CALL   3158
....................  
.................... 	 											} 
04C44:  BRA    4C5A
04C46:  MOVLB  1
.................... 												else{ 
.................... 													 
.................... 													frente(); 
04C48:  MOVLB  0
04C4A:  CALL   3158
.................... 													delay_ms(40); 
04C4E:  MOVLW  28
04C50:  MOVLB  2
04C52:  MOVWF  x17
04C54:  MOVLB  0
04C56:  CALL   1D50
04C5A:  MOVLB  1
.................... 													}	 
.................... 											} 
....................  
.................... 						} 
....................  
....................  
.................... 						if(flip_posicao !=  contador_step_flip) 
04C5C:  MOVF   x7C,W
04C5E:  SUBWF  x9B,W
04C60:  BNZ   4C68
04C62:  MOVF   x7D,W
04C64:  SUBWF  x9C,W
04C66:  BZ    4CBC
.................... 						{						 
.................... 								if (flip_posicao > contador_step_flip) 
04C68:  MOVF   x7D,W
04C6A:  SUBWF  x9C,W
04C6C:  BNC   4C9A
04C6E:  BNZ   4C76
04C70:  MOVF   x9B,W
04C72:  SUBWF  x7C,W
04C74:  BC    4C9A
.................... 			   						{ 
.................... 										if(sentido_horario_flag == true) 
04C76:  BTFSS  x80.6
04C78:  BRA    4C84
.................... 										{	 
....................  
.................... 											sentido_horario(); 
04C7A:  MOVLB  0
04C7C:  CALL   37AC
.................... 											   
....................  
.................... 										} 								 
04C80:  BRA    4C96
04C82:  MOVLB  1
.................... 										else 
.................... 											{ 
.................... 	 
.................... 											   sentido_horario(); 
04C84:  MOVLB  0
04C86:  CALL   37AC
.................... 												delay_ms(40);	 
04C8A:  MOVLW  28
04C8C:  MOVLB  2
04C8E:  MOVWF  x17
04C90:  MOVLB  0
04C92:  CALL   1D50
.................... 											}  
....................  
....................  
.................... 									 
.................... 									}			 
04C96:  BRA    4CBA
04C98:  MOVLB  1
.................... 										else 
.................... 											{ 
.................... 												if(sentido_antihorario_flag==true) 
04C9A:  BTFSS  x80.7
04C9C:  BRA    4CA8
.................... 												{ 
.................... 													sentido_antihorario(); 
04C9E:  MOVLB  0
04CA0:  CALL   37EE
....................  
.................... 	 											} 
04CA4:  BRA    4CBA
04CA6:  MOVLB  1
.................... 												else{ 
.................... 													 
.................... 													sentido_antihorario(); 
04CA8:  MOVLB  0
04CAA:  CALL   37EE
.................... 													delay_ms(40); 
04CAE:  MOVLW  28
04CB0:  MOVLB  2
04CB2:  MOVWF  x17
04CB4:  MOVLB  0
04CB6:  CALL   1D50
04CBA:  MOVLB  1
.................... 													}	 
.................... 											} 
....................  
.................... 						} 
....................  
....................  
.................... 				  
....................  						contador_tempo = 0000; 
04CBC:  CLRF   20
04CBE:  CLRF   1F
.................... 		 
....................  
.................... 	while((x_posicao != contador_step_x) || (y_posicao != contador_step_y) || (flip_posicao != contador_step_flip)) 
04CC0:  MOVF   x78,W
04CC2:  SUBWF  x97,W
04CC4:  BNZ   4CE6
04CC6:  MOVF   x79,W
04CC8:  SUBWF  x98,W
04CCA:  BNZ   4CE6
04CCC:  MOVF   x7A,W
04CCE:  SUBWF  x99,W
04CD0:  BNZ   4CE6
04CD2:  MOVF   x7B,W
04CD4:  SUBWF  x9A,W
04CD6:  BNZ   4CE6
04CD8:  MOVF   x7C,W
04CDA:  SUBWF  x9B,W
04CDC:  BNZ   4CE6
04CDE:  MOVF   x7D,W
04CE0:  SUBWF  x9C,W
04CE2:  BTFSC  FD8.2
04CE4:  BRA    4E24
.................... 	{ 
....................  
.................... 					if(estouro_timer1 == true)		 
04CE6:  BTFSS  1E.4
04CE8:  BRA    4D40
.................... 					{ 
.................... 							 
.................... 						if(x_posicao != contador_step_x) 
04CEA:  MOVF   x78,W
04CEC:  SUBWF  x97,W
04CEE:  BNZ   4CF6
04CF0:  MOVF   x79,W
04CF2:  SUBWF  x98,W
04CF4:  BZ    4D40
.................... 						{ 
.................... 							 
.................... 									one_step_x(); 
04CF6:  MOVLB  0
04CF8:  CALL   32D2
.................... 									estouro_timer1 = false; 
04CFC:  BCF    1E.4
.................... 									setup_timer_1(T1_INTERNAL | T1_DIV_BY_1 ); 
04CFE:  MOVLW  85
04D00:  MOVWF  FCD
.................... 									enable_interrupts(INT_TIMER1); 
04D02:  BSF    F9D.0
....................  
.................... 									if(rampa_x == true) 
04D04:  MOVLB  1
04D06:  DECFSZ xAC,W
04D08:  BRA    4D30
.................... 									{ 
.................... 										 rampa_xx(speed_x,velocidade_inicial_final_x,x_posicao,step1); 
04D0A:  MOVFF  19E,1B4
04D0E:  MOVFF  19D,1B3
04D12:  MOVFF  1A4,1B6
04D16:  MOVFF  1A3,1B5
04D1A:  MOVFF  198,1B8
04D1E:  MOVFF  197,1B7
04D22:  MOVFF  1A9,1B9
04D26:  MOVLB  0
04D28:  CALL   3FF2
....................  
.................... 									} 
04D2C:  BRA    4D3A
04D2E:  MOVLB  1
.................... 										else 
.................... 											{ 
....................  
.................... 												set_timer1(velocidade_x); 
04D30:  MOVFF  35,FCF
04D34:  MOVFF  34,FCE
04D38:  MOVLB  0
.................... 											} 
....................  
.................... 												enable_interrupts(GLOBAL);																 
04D3A:  MOVLW  C0
04D3C:  IORWF  FF2,F
04D3E:  MOVLB  1
.................... 								 
.................... 						}				  
.................... 													 
....................  
.................... 				  } 
.................... 				 
....................  
.................... 			if(estouro_timer3 == true)		 
04D40:  BTFSS  1E.5
04D42:  BRA    4D9A
.................... 				{ 
....................  
.................... 						if(y_posicao != contador_step_y) 
04D44:  MOVF   x7A,W
04D46:  SUBWF  x99,W
04D48:  BNZ   4D50
04D4A:  MOVF   x7B,W
04D4C:  SUBWF  x9A,W
04D4E:  BZ    4D9A
.................... 							{ 
.................... 							            
.................... 										one_step_y(); 
04D50:  MOVLB  0
04D52:  CALL   3166
.................... 							 
....................  
.................... 										estouro_timer3 = false; 
04D56:  BCF    1E.5
.................... 										setup_timer_3(T3_INTERNAL | T3_DIV_BY_1 ); 
04D58:  MOVLW  85
04D5A:  MOVWF  FB1
.................... 										enable_interrupts(INT_TIMER3); 
04D5C:  BSF    FA0.1
....................  
.................... 											if(rampa_y == true) 
04D5E:  MOVLB  1
04D60:  DECFSZ xAD,W
04D62:  BRA    4D8A
.................... 												{ 
.................... 										 			rampa_yy(speed_y,velocidade_inicial_final_y,y_posicao,step2); 
04D64:  MOVFF  1A0,1B4
04D68:  MOVFF  19F,1B3
04D6C:  MOVFF  1A6,1B6
04D70:  MOVFF  1A5,1B5
04D74:  MOVFF  19A,1B8
04D78:  MOVFF  199,1B7
04D7C:  MOVFF  1AA,1B9
04D80:  MOVLB  0
04D82:  CALL   4174
....................  
.................... 												} 
04D86:  BRA    4D94
04D88:  MOVLB  1
.................... 													else 
.................... 													{ 
....................  
.................... 														set_timer3(velocidade_y); 
04D8A:  MOVFF  37,FB3
04D8E:  MOVFF  36,FB2
04D92:  MOVLB  0
.................... 													} 
....................  
....................  
....................  
.................... 									 
.................... 										enable_interrupts(GLOBAL); 
04D94:  MOVLW  C0
04D96:  IORWF  FF2,F
04D98:  MOVLB  1
.................... 								 
.................... 							 
.................... 							} 
....................  
.................... 				} 
.................... 					 
.................... 			 
.................... 				if(estouro_timer0 == true)		 
04D9A:  BTFSS  1E.6
04D9C:  BRA    4DF2
.................... 				{ 
....................  
.................... 						if(flip_posicao != contador_step_flip) 
04D9E:  MOVF   x7C,W
04DA0:  SUBWF  x9B,W
04DA2:  BNZ   4DAA
04DA4:  MOVF   x7D,W
04DA6:  SUBWF  x9C,W
04DA8:  BZ    4DF2
.................... 							{ 
.................... 								 
.................... 				            
.................... 										one_step_flip(); 
04DAA:  MOVLB  0
04DAC:  CALL   37BA
.................... 							 
....................  
.................... 										estouro_timer0 = false; 
04DB0:  BCF    1E.6
.................... 									    SETUP_TIMER_0(T0_INTERNAL | T0_DIV_1 ); 
04DB2:  MOVLW  88
04DB4:  MOVWF  FD5
.................... 										enable_interrupts(INT_TIMER0); 
04DB6:  BSF    FF2.5
....................  
.................... 											if(rampa_flip == true) 
04DB8:  MOVLB  1
04DBA:  DECFSZ xAE,W
04DBC:  BRA    4DE2
.................... 												{ 
.................... 										 			rampa__flip(speed_flip,velocidade_inicial_final_flip,flip_posicao,step3); 
04DBE:  MOVFF  1A2,1B4
04DC2:  MOVFF  1A1,1B3
04DC6:  MOVFF  1A8,1B6
04DCA:  MOVFF  1A7,1B5
04DCE:  MOVFF  19C,1B8
04DD2:  MOVFF  19B,1B7
04DD6:  MOVFF  1AB,1B9
04DDA:  MOVLB  0
04DDC:  BRA    4964
....................  												 
.................... 												} 
04DDE:  BRA    4DEC
04DE0:  MOVLB  1
.................... 													else 
.................... 													{ 
.................... 														 
.................... 														 SET_TIMER0(velocidade_flip); 
04DE2:  MOVFF  39,FD7
04DE6:  MOVFF  38,FD6
04DEA:  MOVLB  0
.................... 													} 
....................  
....................  
....................  
.................... 									 
.................... 										enable_interrupts(GLOBAL); 
04DEC:  MOVLW  C0
04DEE:  IORWF  FF2,F
04DF0:  MOVLB  1
.................... 								 
.................... 							 
.................... 							} 
....................  
.................... 				} 
....................  
.................... 			 
.................... 									 
.................... 									while((estouro_timer1 || estouro_timer3 || estouro_timer0 ) == false){}; 
04DF2:  BTFSC  1E.4
04DF4:  BRA    4E02
04DF6:  BTFSC  1E.5
04DF8:  BRA    4E02
04DFA:  BTFSC  1E.6
04DFC:  BRA    4E02
04DFE:  MOVLW  00
04E00:  BRA    4E04
04E02:  MOVLW  01
04E04:  XORLW  00
04E06:  BTFSC  FD8.2
04E08:  BRA    4DF2
.................... 	                                 
.................... 	 										if(estouro_timer1 == true) 
04E0A:  BTFSS  1E.4
04E0C:  BRA    4E12
.................... 												{ 
.................... 													disable_interrupts(INT_TIMER1); 
04E0E:  BCF    F9D.0
.................... 													setup_timer_1	(t1_disabled); 
04E10:  CLRF   FCD
....................  
....................  
.................... 												} 
....................  
.................... 											if(estouro_timer3 == true) 
04E12:  BTFSS  1E.5
04E14:  BRA    4E1A
.................... 												{ 
....................  
.................... 													disable_interrupts(INT_TIMER3); 
04E16:  BCF    FA0.1
.................... 													setup_timer_3	(t3_disabled); 
04E18:  CLRF   FB1
....................  
....................  
.................... 												} 
.................... 											 
.................... 						 					if(estouro_timer0 == true) 
04E1A:  BTFSS  1E.6
04E1C:  BRA    4E22
.................... 												{ 
....................  
.................... 													disable_interrupts(INT_TIMER0); 
04E1E:  BCF    FF2.5
.................... 													setup_timer_0	(T0_OFF); 
04E20:  CLRF   FD5
....................  
....................  
.................... 												} 
04E22:  BRA    4CC0
.................... 									       
.................... 	} 
.................... 							 
.................... 							 
.................... 					disable_interrupts(INT_TIMER1); 
04E24:  BCF    F9D.0
.................... 					setup_timer_1	(t1_disabled); 
04E26:  CLRF   FCD
.................... 					disable_interrupts(INT_TIMER3); 
04E28:  BCF    FA0.1
.................... 					setup_timer_3	(t3_disabled); 
04E2A:  CLRF   FB1
.................... 					disable_interrupts(INT_TIMER0); 
04E2C:  BCF    FF2.5
.................... 					setup_timer_0	(T0_OFF); 
04E2E:  CLRF   FD5
04E30:  MOVLB  0
04E32:  RETURN 0
....................  
.................... 					//disable_interrupts(GLOBAL); 
....................  
.................... } 
....................  
....................  
....................  
.................... void	go_x_y_z(long int x_posicao,long int y_posicao,long int z_posicao,long int speed_x, 
.................... long int speed_y,long int speed_z,long int velocidade_inicial_final_x,long int velocidade_inicial_final_y, 
.................... long int velocidade_inicial_final_z,int step1,int step2,int step3,short int rampa_x,short int rampa_y,short int rampa_z) 
.................... { 
.................... 		//signed long int steps_faltam;	 
.................... 	 
.................... 	    contador_step_x_inicial = contador_step_x; 
.................... 		contador_step_y_inicial = contador_step_y; 
.................... 		contador_step_z_inicial = contador_step_z; 
....................  
.................... 		velocidade_x    =   (65535 - (speed_x * 5)); 
.................... 		velocidade_y    =   (65535 - (speed_y * 5)); 
.................... 		velocidade_z =   (65535 - (speed_z * 5)); 
....................  
.................... 		contador_rampa_subida_x =     0;  
....................         contador_rampa_descida_x =    0;   
.................... 		contador_rampa_subida_y =     0;  
.................... 		contador_rampa_descida_y =    0;  
.................... 	    contador_rampa_subida_z =  0;  
.................... 		contador_rampa_descida_z = 0;  
....................  
.................... 		estouro_timer0 = true; 
.................... 		estouro_timer1 = true; 
.................... 		estouro_timer3 = true; 
....................  
....................  
.................... 		if(x_posicao !=  contador_step_x) 
.................... 		{ 
.................... 			 
.................... 		 
.................... 							if (x_posicao > contador_step_x) 
.................... 								   {  
.................... 										if(direita_flag==true) 
.................... 											{	 
.................... 												esquerda();    
....................  
.................... 											} else 
.................... 													{ 
.................... 														esquerda();   
.................... 														delay_ms(20); 
....................  
.................... 													}  
.................... 									}else{ 
.................... 											 	if(esquerda_flag==true) 
.................... 												{	 
....................  
.................... 													direita();    
....................  
.................... 												}else 
.................... 														{ 
.................... 															direita();      
.................... 															delay_ms(20); 
.................... 	 
.................... 														}  
.................... 											 
.................... 						 
.................... 										} 
....................  
.................... 						     
....................  
.................... 		} 
....................  
....................  
.................... 						if(y_posicao !=  contador_step_y) 
.................... 						{						 
.................... 								if (y_posicao > contador_step_y) 
.................... 			   						{ 
.................... 										if(atras_flag==true) 
.................... 										{	 
....................  
.................... 											atras();   
....................  
.................... 										} 								 
.................... 										else 
.................... 											{ 
.................... 	 
.................... 												atras();   
.................... 												delay_ms(40);	 
.................... 											}  
....................  
....................  
.................... 									 
.................... 									}			 
.................... 										else 
.................... 											{ 
.................... 												if(frente_flag==true) 
.................... 												{ 
.................... 													frente(); 
....................  
.................... 	 											} 
.................... 												else{ 
.................... 													 
.................... 													frente(); 
.................... 													delay_ms(40); 
.................... 													}	 
.................... 											} 
....................  
.................... 						} 
....................  
....................  
.................... 						if(z_posicao !=  contador_step_z) 
.................... 						{						 
.................... 								if (z_posicao > contador_step_z) 
.................... 			   						{ 
.................... 										if(sobe_flag == true) 
.................... 										{	 
....................  
.................... 											sobe(); 
.................... 											   
....................  
.................... 										} 								 
.................... 										else 
.................... 											{ 
.................... 	 
.................... 											    sobe(); 
.................... 												delay_ms(40);	 
.................... 											}  
....................  
....................  
.................... 									 
.................... 									}			 
.................... 										else 
.................... 											{ 
.................... 												if(desce_flag==true) 
.................... 												{ 
.................... 													desce(); 
....................  
.................... 	 											} 
.................... 												else{ 
.................... 													 
.................... 													desce(); 
.................... 													delay_ms(40); 
.................... 													}	 
.................... 											} 
....................  
.................... 						} 
....................  
....................  
.................... 				  
....................  						contador_tempo = 0000; 
.................... 		 
....................  
.................... 	while((x_posicao != contador_step_x) || (y_posicao != contador_step_y) || (z_posicao != contador_step_z)) 
.................... 	{ 
....................  
.................... 					if(estouro_timer1 == true)		 
.................... 					{ 
.................... 							 
.................... 						if(x_posicao != contador_step_x) 
.................... 						{ 
.................... 							 
.................... 									one_step_x(); 
.................... 									estouro_timer1 = false; 
.................... 									setup_timer_1(T1_INTERNAL | T1_DIV_BY_1 ); 
.................... 									enable_interrupts(INT_TIMER1); 
....................  
.................... 									if(rampa_x == true) 
.................... 									{ 
.................... 										 rampa_xx(speed_x,velocidade_inicial_final_x,x_posicao,step1); 
....................  
.................... 									} 
.................... 										else 
.................... 											{ 
....................  
.................... 												set_timer1(velocidade_x); 
.................... 											} 
....................  
.................... 												enable_interrupts(GLOBAL);																 
.................... 								 
.................... 						}				  
.................... 													 
....................  
.................... 				  } 
.................... 				 
....................  
.................... 			if(estouro_timer3 == true)		 
.................... 				{ 
....................  
.................... 						if(y_posicao != contador_step_y) 
.................... 							{ 
.................... 							            
.................... 										one_step_y(); 
.................... 							 
....................  
.................... 										estouro_timer3 = false; 
.................... 										setup_timer_3(T3_INTERNAL | T3_DIV_BY_1 ); 
.................... 										enable_interrupts(INT_TIMER3); 
....................  
.................... 											if(rampa_y == true) 
.................... 												{ 
.................... 										 			rampa_yy(speed_y,velocidade_inicial_final_y,y_posicao,step2); 
....................  
.................... 												} 
.................... 													else 
.................... 													{ 
....................  
.................... 														set_timer3(velocidade_y); 
.................... 													} 
....................  
....................  
....................  
.................... 									 
.................... 										enable_interrupts(GLOBAL); 
.................... 								 
.................... 							 
.................... 							} 
....................  
.................... 				} 
.................... 					 
.................... 			 
.................... 				if(estouro_timer0 == true)		 
.................... 				{ 
....................  
.................... 						if(z_posicao != contador_step_z) 
.................... 							{ 
.................... 								 
.................... 				            
.................... 										one_step_z(); 
.................... 							 
....................  
.................... 										estouro_timer0 = false; 
.................... 									    SETUP_TIMER_0(T0_INTERNAL | T0_DIV_1 ); 
.................... 										enable_interrupts(INT_TIMER0); 
....................  
.................... 											if(rampa_z == true) 
.................... 												{ 
.................... 										 			rampa__z(speed_z,velocidade_inicial_final_z,z_posicao,step3); 
....................  												 
.................... 												} 
.................... 													else 
.................... 													{ 
.................... 														 
.................... 														 SET_TIMER0(velocidade_z); 
.................... 													} 
....................  
....................  
....................  
.................... 									 
.................... 										enable_interrupts(GLOBAL); 
.................... 								 
.................... 							 
.................... 							} 
....................  
.................... 				} 
....................  
.................... 			 
.................... 									 
.................... 									while((estouro_timer1 || estouro_timer3 || estouro_timer0 ) == false){};	 
.................... 								 
.................... 									 
.................... 	 										if(estouro_timer1 == true) 
.................... 												{ 
.................... 													disable_interrupts(INT_TIMER1); 
.................... 													setup_timer_1	(t1_disabled); 
....................  
....................  
.................... 												} 
....................  
.................... 											if(estouro_timer3 == true) 
.................... 												{ 
....................  
.................... 													disable_interrupts(INT_TIMER3); 
.................... 													setup_timer_3	(t3_disabled); 
....................  
....................  
.................... 												} 
.................... 											 
.................... 						 					if(estouro_timer0 == true) 
.................... 												{ 
....................  
.................... 													disable_interrupts(INT_TIMER0); 
.................... 													setup_timer_0	(T0_OFF); 
....................  
....................  
.................... 												} 
.................... 									       
.................... 	} 
.................... 							 
.................... 							 
.................... 					disable_interrupts(INT_TIMER1); 
.................... 					setup_timer_1	(t1_disabled); 
.................... 					disable_interrupts(INT_TIMER3); 
.................... 					setup_timer_3	(t3_disabled); 
.................... 					disable_interrupts(INT_TIMER0); 
.................... 					setup_timer_0	(T0_OFF); 
....................  
.................... 					//disable_interrupts(GLOBAL); 
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... int  fliP_home(void) 
*
037FC:  MOVLB  1
037FE:  CLRF   x98
.................... { 
.................... 	int i; 
....................     int erro=0; 
.................... 	chopper_flip(); 
03800:  MOVLB  0
03802:  RCALL  37A6
.................... 	delay_ms(50); 
03804:  MOVLW  32
03806:  MOVLB  2
03808:  MOVWF  x17
0380A:  MOVLB  0
0380C:  CALL   1D50
.................... 	 
.................... 	if(le_Input(S_ROTACAO_LS1) == true) 
03810:  MOVLW  0B
03812:  MOVLB  1
03814:  MOVWF  x9C
03816:  MOVLB  0
03818:  CALL   2C54
0381C:  DECFSZ 01,W
0381E:  BRA    38B0
.................... 	{ 
.................... 		sentido_horario(); 
03820:  RCALL  37AC
.................... 		delay_ms(50); 
03822:  MOVLW  32
03824:  MOVLB  2
03826:  MOVWF  x17
03828:  MOVLB  0
0382A:  CALL   1D50
.................... 	    for(i=0;i<=140;i++) 
0382E:  MOVLB  1
03830:  CLRF   x97
03832:  MOVF   x97,W
03834:  SUBLW  8C
03836:  BNC   384E
.................... 		{ 
.................... 							 
.................... 		    one_step_flip(); 
03838:  MOVLB  0
0383A:  RCALL  37BA
.................... 			delay_us(4000); 
0383C:  MOVLW  04
0383E:  MOVLB  2
03840:  MOVWF  x17
03842:  MOVLB  0
03844:  CALL   1D50
03848:  MOVLB  1
0384A:  INCF   x97,F
0384C:  BRA    3832
....................  
.................... 		} 
....................  
.................... 		sentido_antihorario(); 
0384E:  MOVLB  0
03850:  RCALL  37EE
.................... 		delay_ms(100); 
03852:  MOVLW  64
03854:  MOVLB  2
03856:  MOVWF  x17
03858:  MOVLB  0
0385A:  CALL   1D50
....................  
.................... 	    while(le_Input(S_ROTACAO_LS1) == false) 
0385E:  MOVLW  0B
03860:  MOVLB  1
03862:  MOVWF  x9C
03864:  MOVLB  0
03866:  CALL   2C54
0386A:  MOVF   01,F
0386C:  BNZ   387E
.................... 			{ 
.................... 				 
.................... 			    one_step_flip(); 
0386E:  RCALL  37BA
.................... 				delay_us(4000); 
03870:  MOVLW  04
03872:  MOVLB  2
03874:  MOVWF  x17
03876:  MOVLB  0
03878:  CALL   1D50
0387C:  BRA    385E
....................  
.................... 			} 
....................  
.................... 				 
.................... 				for(i=0;i<=36;i++) 
0387E:  MOVLB  1
03880:  CLRF   x97
03882:  MOVF   x97,W
03884:  SUBLW  24
03886:  BNC   389E
.................... 					{ 
.................... 							 
.................... 					    one_step_flip(); 
03888:  MOVLB  0
0388A:  RCALL  37BA
.................... 						delay_us(4000); 
0388C:  MOVLW  04
0388E:  MOVLB  2
03890:  MOVWF  x17
03892:  MOVLB  0
03894:  CALL   1D50
03898:  MOVLB  1
0389A:  INCF   x97,F
0389C:  BRA    3882
....................  
....................  
....................  
.................... 					} 
....................  
.................... 				sentido_horario(); 
0389E:  MOVLB  0
038A0:  RCALL  37AC
.................... 		        delay_ms(50); 
038A2:  MOVLW  32
038A4:  MOVLB  2
038A6:  MOVWF  x17
038A8:  MOVLB  0
038AA:  CALL   1D50
....................  
.................... 		 
.................... 	}else{ 
038AE:  BRA    3942
.................... 			 
.................... 			if(n_maquina == 1)	 
038B0:  DECFSZ 1D,W
038B2:  BRA    38D0
.................... 			{  
.................... 			   if(le_Input(S_X_DIREITA) == false) return erro = 11;//POSICA0 INADEQUADA P/ FLIP 
038B4:  MOVLW  05
038B6:  MOVLB  1
038B8:  MOVWF  x9C
038BA:  MOVLB  0
038BC:  CALL   2C54
038C0:  MOVF   01,F
038C2:  BNZ   38D0
038C4:  MOVLW  0B
038C6:  MOVLB  1
038C8:  MOVWF  x98
038CA:  MOVWF  01
038CC:  BRA    39A8
038CE:  MOVLB  0
.................... 			 
.................... 		   
.................... 	        }	 
....................  
.................... 			if(n_maquina == 2) 
038D0:  MOVF   1D,W
038D2:  SUBLW  02
038D4:  BNZ   38F2
.................... 			{  
....................  
.................... 			   if(le_Input(S_X_ESQUERDA) == false) return erro = 11;// POSICAO INADEQUADA P/ FLIP 
038D6:  MOVLW  06
038D8:  MOVLB  1
038DA:  MOVWF  x9C
038DC:  MOVLB  0
038DE:  CALL   2C54
038E2:  MOVF   01,F
038E4:  BNZ   38F2
038E6:  MOVLW  0B
038E8:  MOVLB  1
038EA:  MOVWF  x98
038EC:  MOVWF  01
038EE:  BRA    39A8
038F0:  MOVLB  0
.................... 			 
.................... 		   
.................... 	        }	 
....................  
.................... 			sentido_antihorario(); 
038F2:  RCALL  37EE
.................... 		    delay_ms(50); 
038F4:  MOVLW  32
038F6:  MOVLB  2
038F8:  MOVWF  x17
038FA:  MOVLB  0
038FC:  CALL   1D50
.................... 			while(le_Input(S_ROTACAO_LS1) == false) 
03900:  MOVLW  0B
03902:  MOVLB  1
03904:  MOVWF  x9C
03906:  MOVLB  0
03908:  CALL   2C54
0390C:  MOVF   01,F
0390E:  BNZ   3920
.................... 			{ 
.................... 				 
.................... 				one_step_flip(); 
03910:  RCALL  37BA
.................... 				delay_us(2000); 
03912:  MOVLW  02
03914:  MOVLB  2
03916:  MOVWF  x17
03918:  MOVLB  0
0391A:  CALL   1D50
0391E:  BRA    3900
....................  
.................... 			} 
....................  
.................... 				 
.................... 				for(i=0;i<=36;i++) 
03920:  MOVLB  1
03922:  CLRF   x97
03924:  MOVF   x97,W
03926:  SUBLW  24
03928:  BNC   3940
.................... 					{ 
.................... 							 
.................... 						one_step_flip(); 
0392A:  MOVLB  0
0392C:  RCALL  37BA
.................... 						delay_us(4000); 
0392E:  MOVLW  04
03930:  MOVLB  2
03932:  MOVWF  x17
03934:  MOVLB  0
03936:  CALL   1D50
0393A:  MOVLB  1
0393C:  INCF   x97,F
0393E:  BRA    3924
03940:  MOVLB  0
....................  
....................  
....................  
.................... 					} 
....................  
.................... 		 
....................  
.................... 	     }	  
.................... 			sentido_horario(); 
03942:  RCALL  37AC
.................... 		    delay_ms(50);// 
03944:  MOVLW  32
03946:  MOVLB  2
03948:  MOVWF  x17
0394A:  MOVLB  0
0394C:  CALL   1D50
.................... 			if(n_maquina == 1) 
03950:  DECFSZ 1D,W
03952:  BRA    3976
.................... 				{ 
.................... 				  for(i=0;i<=81;i++) 
03954:  MOVLB  1
03956:  CLRF   x97
03958:  MOVF   x97,W
0395A:  SUBLW  51
0395C:  BNC   3974
.................... 					{ 
.................... 							 
.................... 						one_step_flip(); 
0395E:  MOVLB  0
03960:  RCALL  37BA
.................... 						delay_us(4000); 
03962:  MOVLW  04
03964:  MOVLB  2
03966:  MOVWF  x17
03968:  MOVLB  0
0396A:  CALL   1D50
0396E:  MOVLB  1
03970:  INCF   x97,F
03972:  BRA    3958
03974:  MOVLB  0
....................  
....................  
....................  
.................... 					} 
.................... 				} 
....................  
....................  
.................... 			if(n_maquina == 2) 
03976:  MOVF   1D,W
03978:  SUBLW  02
0397A:  BNZ   399E
.................... 				{ 
.................... 				  for(i=0;i<=58;i++) 
0397C:  MOVLB  1
0397E:  CLRF   x97
03980:  MOVF   x97,W
03982:  SUBLW  3A
03984:  BNC   399C
.................... 					{ 
.................... 							 
.................... 						one_step_flip(); 
03986:  MOVLB  0
03988:  RCALL  37BA
.................... 						delay_us(4000); 
0398A:  MOVLW  04
0398C:  MOVLB  2
0398E:  MOVWF  x17
03990:  MOVLB  0
03992:  CALL   1D50
03996:  MOVLB  1
03998:  INCF   x97,F
0399A:  BRA    3980
0399C:  MOVLB  0
....................  
....................  
....................  
.................... 					} 
.................... 				} 
....................  
....................  
....................             contador_step_flip = 0; 
0399E:  MOVLB  1
039A0:  CLRF   x7D
039A2:  CLRF   x7C
.................... 			 
....................      return erro; 
039A4:  MOVFF  198,01
039A8:  MOVLB  0
039AA:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... void  x_home_esquerda() 
.................... { 
.................... 	int i; 
.................... 	chopper_x(); 
*
0331A:  RCALL  32BE
.................... 	delay_ms(50); 
0331C:  MOVLW  32
0331E:  MOVLB  2
03320:  MOVWF  x17
03322:  MOVLB  0
03324:  CALL   1D50
.................... 	 
.................... 	if(le_Input(S_X_ESQUERDA) == true) 
03328:  MOVLW  06
0332A:  MOVLB  1
0332C:  MOVWF  x9C
0332E:  MOVLB  0
03330:  RCALL  2C54
03332:  DECFSZ 01,W
03334:  BRA    33D4
.................... 	{ 
.................... 		direita(); 
03336:  RCALL  32C4
.................... 		delay_ms(50); 
03338:  MOVLW  32
0333A:  MOVLB  2
0333C:  MOVWF  x17
0333E:  MOVLB  0
03340:  CALL   1D50
.................... 			while(le_Input(S_X_ESQUERDA) == true) 
03344:  MOVLW  06
03346:  MOVLB  1
03348:  MOVWF  x9C
0334A:  MOVLB  0
0334C:  RCALL  2C54
0334E:  DECFSZ 01,W
03350:  BRA    3362
.................... 					{ 
.................... 							 
.................... 					    one_step_x(); 
03352:  RCALL  32D2
.................... 						delay_us(2000); 
03354:  MOVLW  02
03356:  MOVLB  2
03358:  MOVWF  x17
0335A:  MOVLB  0
0335C:  CALL   1D50
03360:  BRA    3344
....................  
.................... 					} 
....................  
.................... 			for(i=0;i<=40;i++) 
03362:  MOVLB  1
03364:  CLRF   x97
03366:  MOVF   x97,W
03368:  SUBLW  28
0336A:  BNC   3382
.................... 					{ 
.................... 			 
.................... 					    one_step_x(); 
0336C:  MOVLB  0
0336E:  RCALL  32D2
.................... 						delay_us(2000); 
03370:  MOVLW  02
03372:  MOVLB  2
03374:  MOVWF  x17
03376:  MOVLB  0
03378:  CALL   1D50
0337C:  MOVLB  1
0337E:  INCF   x97,F
03380:  BRA    3366
....................  
....................  
.................... 					} 
....................  
....................  
....................  
.................... 		esquerda(); 
03382:  MOVLB  0
03384:  RCALL  3306
.................... 		delay_ms(50); 
03386:  MOVLW  32
03388:  MOVLB  2
0338A:  MOVWF  x17
0338C:  MOVLB  0
0338E:  CALL   1D50
....................  
.................... 	while(le_Input(S_X_ESQUERDA) == false) 
03392:  MOVLW  06
03394:  MOVLB  1
03396:  MOVWF  x9C
03398:  MOVLB  0
0339A:  RCALL  2C54
0339C:  MOVF   01,F
0339E:  BNZ   33B0
.................... 			{ 
.................... 				 
.................... 			    one_step_x(); 
033A0:  RCALL  32D2
.................... 				delay_us(2000); 
033A2:  MOVLW  02
033A4:  MOVLB  2
033A6:  MOVWF  x17
033A8:  MOVLB  0
033AA:  CALL   1D50
033AE:  BRA    3392
....................  
.................... 			} 
....................  
.................... 				 
.................... 				for(i=0;i<=40;i++) 
033B0:  MOVLB  1
033B2:  CLRF   x97
033B4:  MOVF   x97,W
033B6:  SUBLW  28
033B8:  BNC   33D0
.................... 					{ 
.................... 							 
.................... 					    one_step_x(); 
033BA:  MOVLB  0
033BC:  RCALL  32D2
.................... 						delay_us(2000); 
033BE:  MOVLW  02
033C0:  MOVLB  2
033C2:  MOVWF  x17
033C4:  MOVLB  0
033C6:  CALL   1D50
033CA:  MOVLB  1
033CC:  INCF   x97,F
033CE:  BRA    33B4
....................  
....................  
....................  
.................... 					} 
....................  
....................  
....................  
.................... 	}else{ 
033D0:  BRA    3420
033D2:  MOVLB  0
.................... 			 
.................... 			 
....................  
.................... 			esquerda(); 
033D4:  RCALL  3306
.................... 		    delay_ms(50); 
033D6:  MOVLW  32
033D8:  MOVLB  2
033DA:  MOVWF  x17
033DC:  MOVLB  0
033DE:  CALL   1D50
.................... 			while(le_Input(S_X_ESQUERDA) == false) 
033E2:  MOVLW  06
033E4:  MOVLB  1
033E6:  MOVWF  x9C
033E8:  MOVLB  0
033EA:  RCALL  2C54
033EC:  MOVF   01,F
033EE:  BNZ   3400
.................... 			{ 
.................... 				 
.................... 				one_step_x(); 
033F0:  RCALL  32D2
.................... 				delay_us(2000); 
033F2:  MOVLW  02
033F4:  MOVLB  2
033F6:  MOVWF  x17
033F8:  MOVLB  0
033FA:  CALL   1D50
033FE:  BRA    33E2
....................  
.................... 			} 
....................  
.................... 				 
.................... 				for(i=0;i<=40;i++) 
03400:  MOVLB  1
03402:  CLRF   x97
03404:  MOVF   x97,W
03406:  SUBLW  28
03408:  BNC   3420
.................... 					{ 
.................... 							 
.................... 						one_step_x(); 
0340A:  MOVLB  0
0340C:  RCALL  32D2
.................... 						delay_us(2000); 
0340E:  MOVLW  02
03410:  MOVLB  2
03412:  MOVWF  x17
03414:  MOVLB  0
03416:  CALL   1D50
0341A:  MOVLB  1
0341C:  INCF   x97,F
0341E:  BRA    3404
....................  
....................  
....................  
.................... 					} 
....................  
....................  
....................  
.................... 	     }	 
....................             contador_step_x = 0;  
03420:  CLRF   x79
03422:  CLRF   x78
.................... 			stop_x(); 
03424:  MOVLB  0
03426:  RCALL  3314
03428:  RETURN 0
.................... 			 
.................... } 
....................  
....................  
.................... void  y_home_frente() 
.................... { 
.................... 	int i; 
.................... 	chopper_y(); 
0342A:  RCALL  3152
.................... 	delay_ms(50); 
0342C:  MOVLW  32
0342E:  MOVLB  2
03430:  MOVWF  x17
03432:  MOVLB  0
03434:  CALL   1D50
.................... 	 
.................... 	if(le_Input(S_Y_FRENTE) == true) 
03438:  MOVLW  07
0343A:  MOVLB  1
0343C:  MOVWF  x9C
0343E:  MOVLB  0
03440:  RCALL  2C54
03442:  DECFSZ 01,W
03444:  BRA    34E8
.................... 	{ 
.................... 		atras(); 
03446:  RCALL  319A
.................... 		delay_ms(50); 
03448:  MOVLW  32
0344A:  MOVLB  2
0344C:  MOVWF  x17
0344E:  MOVLB  0
03450:  CALL   1D50
.................... 				while(le_Input(S_Y_FRENTE) == true) 
03454:  MOVLW  07
03456:  MOVLB  1
03458:  MOVWF  x9C
0345A:  MOVLB  0
0345C:  CALL   2C54
03460:  DECFSZ 01,W
03462:  BRA    3474
.................... 					{ 
.................... 							 
.................... 					    one_step_y(); 
03464:  RCALL  3166
.................... 						delay_us(2000); 
03466:  MOVLW  02
03468:  MOVLB  2
0346A:  MOVWF  x17
0346C:  MOVLB  0
0346E:  CALL   1D50
03472:  BRA    3454
.................... 					} 
....................  
.................... 				for(i=0;i<=40;i++)//para sair do histerese do sensor dando maior precisao 
03474:  MOVLB  1
03476:  CLRF   x97
03478:  MOVF   x97,W
0347A:  SUBLW  28
0347C:  BNC   3494
.................... 					{ 
.................... 							 
.................... 					    one_step_y(); 
0347E:  MOVLB  0
03480:  RCALL  3166
.................... 						delay_us(2000); 
03482:  MOVLW  02
03484:  MOVLB  2
03486:  MOVWF  x17
03488:  MOVLB  0
0348A:  CALL   1D50
0348E:  MOVLB  1
03490:  INCF   x97,F
03492:  BRA    3478
....................  
....................  
....................  
.................... 					} 
....................  
....................  
....................  
.................... 		frente(); 
03494:  MOVLB  0
03496:  RCALL  3158
.................... 		delay_ms(50); 
03498:  MOVLW  32
0349A:  MOVLB  2
0349C:  MOVWF  x17
0349E:  MOVLB  0
034A0:  CALL   1D50
....................  
.................... 	while(le_Input(S_Y_FRENTE) == false) 
034A4:  MOVLW  07
034A6:  MOVLB  1
034A8:  MOVWF  x9C
034AA:  MOVLB  0
034AC:  CALL   2C54
034B0:  MOVF   01,F
034B2:  BNZ   34C4
.................... 			{ 
.................... 				 
.................... 			    one_step_y(); 
034B4:  RCALL  3166
.................... 				delay_us(2000); 
034B6:  MOVLW  02
034B8:  MOVLB  2
034BA:  MOVWF  x17
034BC:  MOVLB  0
034BE:  CALL   1D50
034C2:  BRA    34A4
....................  
.................... 			} 
....................  
.................... 				 
.................... 				for(i=0;i<=40;i++) 
034C4:  MOVLB  1
034C6:  CLRF   x97
034C8:  MOVF   x97,W
034CA:  SUBLW  28
034CC:  BNC   34E4
.................... 					{ 
.................... 							 
.................... 					    one_step_y(); 
034CE:  MOVLB  0
034D0:  RCALL  3166
.................... 						delay_us(2000); 
034D2:  MOVLW  02
034D4:  MOVLB  2
034D6:  MOVWF  x17
034D8:  MOVLB  0
034DA:  CALL   1D50
034DE:  MOVLB  1
034E0:  INCF   x97,F
034E2:  BRA    34C8
....................  
....................  
....................  
.................... 					} 
....................  
....................  
....................  
.................... 	}else{ 
034E4:  BRA    3536
034E6:  MOVLB  0
.................... 			 
.................... 			 
....................  
.................... 			frente(); 
034E8:  RCALL  3158
.................... 		    delay_ms(50); 
034EA:  MOVLW  32
034EC:  MOVLB  2
034EE:  MOVWF  x17
034F0:  MOVLB  0
034F2:  CALL   1D50
.................... 			while(le_Input(S_Y_FRENTE) == false) 
034F6:  MOVLW  07
034F8:  MOVLB  1
034FA:  MOVWF  x9C
034FC:  MOVLB  0
034FE:  CALL   2C54
03502:  MOVF   01,F
03504:  BNZ   3516
.................... 			{ 
.................... 				 
.................... 				one_step_y(); 
03506:  RCALL  3166
.................... 				delay_us(2000); 
03508:  MOVLW  02
0350A:  MOVLB  2
0350C:  MOVWF  x17
0350E:  MOVLB  0
03510:  CALL   1D50
03514:  BRA    34F6
....................  
.................... 			} 
....................  
.................... 				 
.................... 				for(i=0;i<=40;i++) 
03516:  MOVLB  1
03518:  CLRF   x97
0351A:  MOVF   x97,W
0351C:  SUBLW  28
0351E:  BNC   3536
.................... 					{ 
.................... 							 
.................... 						one_step_y(); 
03520:  MOVLB  0
03522:  RCALL  3166
.................... 						delay_us(2000); 
03524:  MOVLW  02
03526:  MOVLB  2
03528:  MOVWF  x17
0352A:  MOVLB  0
0352C:  CALL   1D50
03530:  MOVLB  1
03532:  INCF   x97,F
03534:  BRA    351A
....................  
....................  
....................  
.................... 					} 
....................  
....................  
....................  
.................... 	     }	contador_step_y = 0;   
03536:  CLRF   x7B
03538:  CLRF   x7A
.................... 			stop_y(); 
0353A:  MOVLB  0
0353C:  RCALL  31A8
0353E:  RETURN 0
.................... 			 
.................... } 
....................  
.................... void  y_home_atras() 
.................... { 
.................... 	int i; 
.................... 	chopper_y(); 
*
031AE:  RCALL  3152
.................... 	delay_ms(50); 
031B0:  MOVLW  32
031B2:  MOVLB  2
031B4:  MOVWF  x17
031B6:  MOVLB  0
031B8:  CALL   1D50
.................... 	 
.................... 	if(le_Input(S_Y_ATRAS) == true) 
031BC:  MOVLW  08
031BE:  MOVLB  1
031C0:  MOVWF  x9C
031C2:  MOVLB  0
031C4:  RCALL  2C54
031C6:  DECFSZ 01,W
031C8:  BRA    3268
.................... 	{ 
.................... 		frente(); 
031CA:  RCALL  3158
.................... 		delay_ms(50); 
031CC:  MOVLW  32
031CE:  MOVLB  2
031D0:  MOVWF  x17
031D2:  MOVLB  0
031D4:  CALL   1D50
.................... 				while(le_Input(S_Y_ATRAS) == true) 
031D8:  MOVLW  08
031DA:  MOVLB  1
031DC:  MOVWF  x9C
031DE:  MOVLB  0
031E0:  RCALL  2C54
031E2:  DECFSZ 01,W
031E4:  BRA    31F6
.................... 					{ 
.................... 							 
.................... 					    one_step_y(); 
031E6:  RCALL  3166
.................... 						delay_us(2000); 
031E8:  MOVLW  02
031EA:  MOVLB  2
031EC:  MOVWF  x17
031EE:  MOVLB  0
031F0:  CALL   1D50
031F4:  BRA    31D8
.................... 					} 
....................  
.................... 				for(i=0;i<=40;i++)//para sair do histerese do sensor dando maior precisao 
031F6:  MOVLB  1
031F8:  CLRF   x97
031FA:  MOVF   x97,W
031FC:  SUBLW  28
031FE:  BNC   3216
.................... 					{ 
.................... 							 
.................... 					    one_step_y(); 
03200:  MOVLB  0
03202:  RCALL  3166
.................... 						delay_us(2000); 
03204:  MOVLW  02
03206:  MOVLB  2
03208:  MOVWF  x17
0320A:  MOVLB  0
0320C:  CALL   1D50
03210:  MOVLB  1
03212:  INCF   x97,F
03214:  BRA    31FA
....................  
....................  
....................  
.................... 					} 
....................  
....................  
....................  
.................... 		atras(); 
03216:  MOVLB  0
03218:  RCALL  319A
.................... 		delay_ms(50); 
0321A:  MOVLW  32
0321C:  MOVLB  2
0321E:  MOVWF  x17
03220:  MOVLB  0
03222:  CALL   1D50
....................  
.................... 	while(le_Input(S_Y_ATRAS) == false) 
03226:  MOVLW  08
03228:  MOVLB  1
0322A:  MOVWF  x9C
0322C:  MOVLB  0
0322E:  RCALL  2C54
03230:  MOVF   01,F
03232:  BNZ   3244
.................... 			{ 
.................... 				 
.................... 			    one_step_y(); 
03234:  RCALL  3166
.................... 				delay_us(2000); 
03236:  MOVLW  02
03238:  MOVLB  2
0323A:  MOVWF  x17
0323C:  MOVLB  0
0323E:  CALL   1D50
03242:  BRA    3226
....................  
.................... 			} 
....................  
.................... 				 
.................... 				for(i=0;i<=40;i++) 
03244:  MOVLB  1
03246:  CLRF   x97
03248:  MOVF   x97,W
0324A:  SUBLW  28
0324C:  BNC   3264
.................... 					{ 
.................... 							 
.................... 					    one_step_y(); 
0324E:  MOVLB  0
03250:  RCALL  3166
.................... 						delay_us(2000); 
03252:  MOVLW  02
03254:  MOVLB  2
03256:  MOVWF  x17
03258:  MOVLB  0
0325A:  CALL   1D50
0325E:  MOVLB  1
03260:  INCF   x97,F
03262:  BRA    3248
....................  
....................  
....................  
.................... 					} 
....................  
....................  
....................  
.................... 	}else{ 
03264:  BRA    32B4
03266:  MOVLB  0
.................... 			 
.................... 			 
....................  
.................... 			atras(); 
03268:  RCALL  319A
.................... 		    delay_ms(50); 
0326A:  MOVLW  32
0326C:  MOVLB  2
0326E:  MOVWF  x17
03270:  MOVLB  0
03272:  CALL   1D50
.................... 			while(le_Input(S_Y_ATRAS) == false) 
03276:  MOVLW  08
03278:  MOVLB  1
0327A:  MOVWF  x9C
0327C:  MOVLB  0
0327E:  RCALL  2C54
03280:  MOVF   01,F
03282:  BNZ   3294
.................... 			{ 
.................... 				 
.................... 				one_step_y(); 
03284:  RCALL  3166
.................... 				delay_us(2000); 
03286:  MOVLW  02
03288:  MOVLB  2
0328A:  MOVWF  x17
0328C:  MOVLB  0
0328E:  CALL   1D50
03292:  BRA    3276
....................  
.................... 			} 
....................  
.................... 				 
.................... 				for(i=0;i<=40;i++) 
03294:  MOVLB  1
03296:  CLRF   x97
03298:  MOVF   x97,W
0329A:  SUBLW  28
0329C:  BNC   32B4
.................... 					{ 
.................... 							 
.................... 						one_step_y(); 
0329E:  MOVLB  0
032A0:  RCALL  3166
.................... 						delay_us(2000); 
032A2:  MOVLW  02
032A4:  MOVLB  2
032A6:  MOVWF  x17
032A8:  MOVLB  0
032AA:  CALL   1D50
032AE:  MOVLB  1
032B0:  INCF   x97,F
032B2:  BRA    3298
....................  
....................  
....................  
.................... 					} 
....................  
....................  
....................  
.................... 	     }	contador_step_y = 0;    
032B4:  CLRF   x7B
032B6:  CLRF   x7A
.................... 			stop_y(); 
032B8:  MOVLB  0
032BA:  RCALL  31A8
032BC:  RETURN 0
.................... 			 
.................... } 
....................  
....................  
....................  
....................  void  x_home_direita() 
.................... { 
.................... 	int i; 
.................... 	chopper_x(); 
*
0368E:  RCALL  32BE
.................... 	delay_ms(50); 
03690:  MOVLW  32
03692:  MOVLB  2
03694:  MOVWF  x17
03696:  MOVLB  0
03698:  CALL   1D50
.................... 	 
.................... 	if(le_Input(S_X_DIREITA) == true) 
0369C:  MOVLW  05
0369E:  MOVLB  1
036A0:  MOVWF  x9C
036A2:  MOVLB  0
036A4:  CALL   2C54
036A8:  DECFSZ 01,W
036AA:  BRA    374E
.................... 	{ 
.................... 		esquerda(); 
036AC:  RCALL  3306
.................... 		delay_ms(50); 
036AE:  MOVLW  32
036B0:  MOVLB  2
036B2:  MOVWF  x17
036B4:  MOVLB  0
036B6:  CALL   1D50
.................... 			while(le_Input(S_X_DIREITA) == true) 
036BA:  MOVLW  05
036BC:  MOVLB  1
036BE:  MOVWF  x9C
036C0:  MOVLB  0
036C2:  CALL   2C54
036C6:  DECFSZ 01,W
036C8:  BRA    36DA
.................... 					{ 
.................... 							 
.................... 					    one_step_x(); 
036CA:  RCALL  32D2
.................... 						delay_us(2000); 
036CC:  MOVLW  02
036CE:  MOVLB  2
036D0:  MOVWF  x17
036D2:  MOVLB  0
036D4:  CALL   1D50
036D8:  BRA    36BA
.................... 					} 
....................  
.................... 			for(i=0;i<=40;i++) //para sair do histerese do sensor dando maior precisao 
036DA:  MOVLB  1
036DC:  CLRF   x97
036DE:  MOVF   x97,W
036E0:  SUBLW  28
036E2:  BNC   36FA
.................... 					{ 
.................... 							 
.................... 					    one_step_x(); 
036E4:  MOVLB  0
036E6:  RCALL  32D2
.................... 						delay_us(2000); 
036E8:  MOVLW  02
036EA:  MOVLB  2
036EC:  MOVWF  x17
036EE:  MOVLB  0
036F0:  CALL   1D50
036F4:  MOVLB  1
036F6:  INCF   x97,F
036F8:  BRA    36DE
....................  
....................  
....................  
.................... 					} 
....................  
....................  
....................  
.................... 		direita(); 
036FA:  MOVLB  0
036FC:  RCALL  32C4
.................... 		delay_ms(50); 
036FE:  MOVLW  32
03700:  MOVLB  2
03702:  MOVWF  x17
03704:  MOVLB  0
03706:  CALL   1D50
....................  
.................... 	while(le_Input(S_X_DIREITA) == false) 
0370A:  MOVLW  05
0370C:  MOVLB  1
0370E:  MOVWF  x9C
03710:  MOVLB  0
03712:  CALL   2C54
03716:  MOVF   01,F
03718:  BNZ   372A
.................... 			{ 
.................... 				 
.................... 			    one_step_x(); 
0371A:  RCALL  32D2
.................... 				delay_us(2000); 
0371C:  MOVLW  02
0371E:  MOVLB  2
03720:  MOVWF  x17
03722:  MOVLB  0
03724:  CALL   1D50
03728:  BRA    370A
....................  
.................... 			} 
....................  
.................... 				 
.................... 				for(i=0;i<=40;i++) 
0372A:  MOVLB  1
0372C:  CLRF   x97
0372E:  MOVF   x97,W
03730:  SUBLW  28
03732:  BNC   374A
.................... 					{ 
.................... 							 
.................... 					    one_step_x(); 
03734:  MOVLB  0
03736:  RCALL  32D2
.................... 						delay_us(2000); 
03738:  MOVLW  02
0373A:  MOVLB  2
0373C:  MOVWF  x17
0373E:  MOVLB  0
03740:  CALL   1D50
03744:  MOVLB  1
03746:  INCF   x97,F
03748:  BRA    372E
....................  
....................  
....................  
.................... 					} 
....................  
....................  
....................  
.................... 	}else{ 
0374A:  BRA    379C
0374C:  MOVLB  0
.................... 			 
.................... 			direita(); 
0374E:  RCALL  32C4
.................... 		    delay_ms(50); 
03750:  MOVLW  32
03752:  MOVLB  2
03754:  MOVWF  x17
03756:  MOVLB  0
03758:  CALL   1D50
.................... 			while(le_Input(S_X_DIREITA) == false) 
0375C:  MOVLW  05
0375E:  MOVLB  1
03760:  MOVWF  x9C
03762:  MOVLB  0
03764:  CALL   2C54
03768:  MOVF   01,F
0376A:  BNZ   377C
.................... 			{ 
.................... 				 
.................... 				one_step_x(); 
0376C:  RCALL  32D2
.................... 				delay_us(2000); 
0376E:  MOVLW  02
03770:  MOVLB  2
03772:  MOVWF  x17
03774:  MOVLB  0
03776:  CALL   1D50
0377A:  BRA    375C
....................  
.................... 			} 
....................  
.................... 				 
.................... 				for(i=0;i<=40;i++) 
0377C:  MOVLB  1
0377E:  CLRF   x97
03780:  MOVF   x97,W
03782:  SUBLW  28
03784:  BNC   379C
.................... 					{ 
.................... 							 
.................... 						one_step_x(); 
03786:  MOVLB  0
03788:  RCALL  32D2
.................... 						delay_us(2000); 
0378A:  MOVLW  02
0378C:  MOVLB  2
0378E:  MOVWF  x17
03790:  MOVLB  0
03792:  CALL   1D50
03796:  MOVLB  1
03798:  INCF   x97,F
0379A:  BRA    3780
....................  
....................  
....................  
.................... 					} 
....................  
....................  
....................  
.................... 	     } 
.................... 	        
....................  
.................... 		    contador_step_x = 0;    
0379C:  CLRF   x79
0379E:  CLRF   x78
.................... 			stop_x(); 
037A0:  MOVLB  0
037A2:  RCALL  3314
037A4:  RETURN 0
.................... 			 
.................... } 
....................  
....................  
.................... void  z_home() 
.................... { 
.................... 	int i; 
.................... 	chopper_z(); 
*
02EE0:  RCALL  2C0C
.................... 	delay_ms(50); 
02EE2:  MOVLW  32
02EE4:  MOVLB  2
02EE6:  MOVWF  x17
02EE8:  MOVLB  0
02EEA:  CALL   1D50
.................... 	 
.................... 	if(le_Input(S_Z_TOP) == true) 
02EEE:  MOVLW  0D
02EF0:  MOVLB  1
02EF2:  MOVWF  x9C
02EF4:  MOVLB  0
02EF6:  RCALL  2C54
02EF8:  DECFSZ 01,W
02EFA:  BRA    2F7C
.................... 	{ 
.................... 		desce(); 
02EFC:  RCALL  2E8A
.................... 		delay_ms(50); 
02EFE:  MOVLW  32
02F00:  MOVLB  2
02F02:  MOVWF  x17
02F04:  MOVLB  0
02F06:  CALL   1D50
....................  
.................... 			for(i=0;i<=50;i++) 
02F0A:  MOVLB  1
02F0C:  CLRF   x9A
02F0E:  MOVF   x9A,W
02F10:  SUBLW  32
02F12:  BNC   2F2A
.................... 					{ 
.................... 							 
.................... 					    one_step_z(); 
02F14:  MOVLB  0
02F16:  RCALL  2E98
.................... 						delay_us(2000); 
02F18:  MOVLW  02
02F1A:  MOVLB  2
02F1C:  MOVWF  x17
02F1E:  MOVLB  0
02F20:  CALL   1D50
02F24:  MOVLB  1
02F26:  INCF   x9A,F
02F28:  BRA    2F0E
....................  
.................... 					} 
....................  
.................... 		sobe(); 
02F2A:  MOVLB  0
02F2C:  RCALL  2ECC
.................... 		delay_ms(50); 
02F2E:  MOVLW  32
02F30:  MOVLB  2
02F32:  MOVWF  x17
02F34:  MOVLB  0
02F36:  CALL   1D50
....................  
.................... 	while(le_Input(S_Z_TOP) == false) 
02F3A:  MOVLW  0D
02F3C:  MOVLB  1
02F3E:  MOVWF  x9C
02F40:  MOVLB  0
02F42:  RCALL  2C54
02F44:  MOVF   01,F
02F46:  BNZ   2F58
.................... 			{ 
.................... 				 
.................... 			    one_step_z(); 
02F48:  RCALL  2E98
.................... 				delay_us(2000); 
02F4A:  MOVLW  02
02F4C:  MOVLB  2
02F4E:  MOVWF  x17
02F50:  MOVLB  0
02F52:  CALL   1D50
02F56:  BRA    2F3A
....................  
.................... 			} 
....................  
.................... 				 
.................... 				for(i=0;i<=18;i++) 
02F58:  MOVLB  1
02F5A:  CLRF   x9A
02F5C:  MOVF   x9A,W
02F5E:  SUBLW  12
02F60:  BNC   2F78
.................... 					{ 
.................... 							 
.................... 					    one_step_z(); 
02F62:  MOVLB  0
02F64:  RCALL  2E98
.................... 						delay_us(2000); 
02F66:  MOVLW  02
02F68:  MOVLB  2
02F6A:  MOVWF  x17
02F6C:  MOVLB  0
02F6E:  CALL   1D50
02F72:  MOVLB  1
02F74:  INCF   x9A,F
02F76:  BRA    2F5C
....................  
....................  
....................  
.................... 					} 
....................  
....................  
....................  
.................... 	}else{ 
02F78:  BRA    2FC8
02F7A:  MOVLB  0
.................... 			 
.................... 			 
....................  
.................... 			sobe(); 
02F7C:  RCALL  2ECC
.................... 		    delay_ms(50); 
02F7E:  MOVLW  32
02F80:  MOVLB  2
02F82:  MOVWF  x17
02F84:  MOVLB  0
02F86:  CALL   1D50
.................... 			while(le_Input(S_Z_TOP) == false) 
02F8A:  MOVLW  0D
02F8C:  MOVLB  1
02F8E:  MOVWF  x9C
02F90:  MOVLB  0
02F92:  RCALL  2C54
02F94:  MOVF   01,F
02F96:  BNZ   2FA8
.................... 			{ 
.................... 				 
.................... 				one_step_z(); 
02F98:  RCALL  2E98
.................... 				delay_us(2000); 
02F9A:  MOVLW  02
02F9C:  MOVLB  2
02F9E:  MOVWF  x17
02FA0:  MOVLB  0
02FA2:  CALL   1D50
02FA6:  BRA    2F8A
....................  
.................... 			} 
....................  
.................... 				 
.................... 				for(i=0;i<=18;i++) 
02FA8:  MOVLB  1
02FAA:  CLRF   x9A
02FAC:  MOVF   x9A,W
02FAE:  SUBLW  12
02FB0:  BNC   2FC8
.................... 					{ 
.................... 							 
.................... 						one_step_z(); 
02FB2:  MOVLB  0
02FB4:  RCALL  2E98
.................... 						delay_us(2000); 
02FB6:  MOVLW  02
02FB8:  MOVLB  2
02FBA:  MOVWF  x17
02FBC:  MOVLB  0
02FBE:  CALL   1D50
02FC2:  MOVLB  1
02FC4:  INCF   x9A,F
02FC6:  BRA    2FAC
....................  
....................  
....................  
.................... 					} 
....................  
....................  
....................  
.................... 	     }	 contador_step_z = 0;    
02FC8:  CLRF   x7F
02FCA:  CLRF   x7E
.................... 			stop_z(); 
02FCC:  MOVLB  0
02FCE:  RCALL  2EDA
02FD0:  RETURN 0
.................... 			 
.................... } 
....................  
....................  
....................  
....................  
.................... void  bandeja_posicao_soldagem(void) 
.................... { 
....................   			 
....................    chopper_x(); 
....................    chopper_y(); 
....................    chopper_flip(); 
....................    direita(); 
....................    atras(); 
....................    sentido_horario();           
.................... 		 
....................    go_x_y_flip(9000,9000,1000,100,100,200,4000,4000,4000,300,300,200,true,true,true); 
.................... 	       	 
....................  
.................... } 
....................  
.................... void bandeja_posicao_saida(void) 
.................... { 
....................  
....................  	chopper_x(); 
....................     chopper_y(); 
....................     chopper_flip(); 
....................     direita(); 
....................     atras(); 
....................     sentido_horario();           
.................... 	 
....................     go_x_y_flip(9000,9000,1000,100,100,200,4000,4000,4000,300,300,200,true,true,true); 
....................  
.................... } 
....................  
.................... #include "manutencao.c" 
....................  
....................  
....................  
....................  
....................  
.................... void Debug_eixo_XY(void) 
*
08E1E:  MOVLB  1
08E20:  CLRF   x93
.................... { 
.................... 	int key_code = 0; 
.................... 	printf(lcd_putc,"\f"); 
08E22:  MOVLW  0C
08E24:  MOVWF  xA4
08E26:  MOVLB  0
08E28:  CALL   2586
.................... 	printf(lcd_putc,"       EIXO XY      \n\r"); 
08E2C:  MOVLW  02
08E2E:  MOVWF  FF6
08E30:  MOVLW  01
08E32:  MOVWF  FF7
08E34:  CALL   25DA
.................... 	printf(lcd_putc,"X:0000              \n\r");   
08E38:  MOVLW  1A
08E3A:  MOVWF  FF6
08E3C:  MOVLW  01
08E3E:  MOVWF  FF7
08E40:  CALL   25DA
....................     printf(lcd_putc,"Y:0000              \n\r"); 
08E44:  MOVLW  32
08E46:  MOVWF  FF6
08E48:  MOVLW  01
08E4A:  MOVWF  FF7
08E4C:  CALL   25DA
.................... 	contador_step_x = 0x0000; 
08E50:  MOVLB  1
08E52:  CLRF   x79
08E54:  CLRF   x78
.................... 	posiciona_cursor(2,3); 
08E56:  MOVLW  02
08E58:  MOVWF  xA5
08E5A:  MOVLW  03
08E5C:  MOVWF  xA6
08E5E:  MOVLB  0
08E60:  CALL   1F92
.................... 	printf(lcd_putc,"%4Lu",contador_step_x); 
08E64:  MOVLW  01
08E66:  MOVWF  FE9
08E68:  MOVFF  179,19C
08E6C:  MOVFF  178,19B
08E70:  CALL   5744
....................  
.................... 	while(true){	 
.................... 	key_code = Teclado(); 
08E74:  CALL   2344
08E78:  MOVFF  01,193
.................... 	 
.................... 	switch(key_code){ 
08E7C:  MOVLB  1
08E7E:  MOVF   x93,W
08E80:  XORLW  10
08E82:  MOVLB  0
08E84:  BZ    8E98
08E86:  XORLW  01
08E88:  BZ    8F18
08E8A:  XORLW  1E
08E8C:  BTFSC  FD8.2
08E8E:  BRA    8F98
08E90:  XORLW  01
08E92:  BTFSC  FD8.2
08E94:  BRA    9016
08E96:  BRA    9094
....................  
....................  
.................... 	case SETA_DIREITA:  
.................... 							direita(); 
08E98:  CALL   32C4
.................... 							chopper_x(); 
08E9C:  CALL   32BE
.................... 							delay_ms(100); 
08EA0:  MOVLW  64
08EA2:  MOVLB  2
08EA4:  MOVWF  x17
08EA6:  MOVLB  0
08EA8:  CALL   1D50
.................... 				 			while(Teclado()== SETA_DIREITA ) //S_X_DIREITA	 
08EAC:  CALL   2344
08EB0:  MOVF   01,W
08EB2:  SUBLW  10
08EB4:  BNZ   8EFE
.................... 							{ 
.................... 								//if(le_Input(S_X_DIREITA) == false) 
.................... 								//{ 
....................  
.................... 								  one_step_x(); 
08EB6:  CALL   32D2
....................  
.................... 								//} 
.................... 								delay_us(500); 
08EBA:  MOVLW  02
08EBC:  MOVLB  1
08EBE:  MOVWF  x94
08EC0:  CLRF   16
08EC2:  BTFSC  FF2.7
08EC4:  BSF    16.7
08EC6:  BCF    FF2.7
08EC8:  MOVLW  F9
08ECA:  MOVLB  2
08ECC:  MOVWF  x1B
08ECE:  MOVLB  0
08ED0:  CALL   1C3A
08ED4:  BTFSC  16.7
08ED6:  BSF    FF2.7
08ED8:  MOVLB  1
08EDA:  DECFSZ x94,F
08EDC:  BRA    8EC0
.................... 								posiciona_cursor(2,3); 
08EDE:  MOVLW  02
08EE0:  MOVWF  xA5
08EE2:  MOVLW  03
08EE4:  MOVWF  xA6
08EE6:  MOVLB  0
08EE8:  CALL   1F92
.................... 							    printf(lcd_putc,"%4Lu",contador_step_x); 
08EEC:  MOVLW  01
08EEE:  MOVWF  FE9
08EF0:  MOVFF  179,19C
08EF4:  MOVFF  178,19B
08EF8:  CALL   5744
08EFC:  BRA    8EAC
.................... 	 
.................... 							}  
.................... 			 
.................... 	 						while(Teclado() != 0Xff){} 
08EFE:  CALL   2344
08F02:  INCFSZ 01,W
08F04:  BRA    8F08
08F06:  BRA    8F0A
08F08:  BRA    8EFE
.................... 							//stop_x(); 
.................... 							delay_ms(50); 
08F0A:  MOVLW  32
08F0C:  MOVLB  2
08F0E:  MOVWF  x17
08F10:  MOVLB  0
08F12:  CALL   1D50
.................... 	 
.................... 						    break; 
08F16:  BRA    9094
....................  
.................... 	case SETA_ESQUERDA:     esquerda(); 
08F18:  CALL   3306
.................... 							chopper_x(); 
08F1C:  CALL   32BE
.................... 							delay_ms(100); 
08F20:  MOVLW  64
08F22:  MOVLB  2
08F24:  MOVWF  x17
08F26:  MOVLB  0
08F28:  CALL   1D50
.................... 				 			while(Teclado() == SETA_ESQUERDA ) 
08F2C:  CALL   2344
08F30:  MOVF   01,W
08F32:  SUBLW  11
08F34:  BNZ   8F7E
.................... 							{ 
.................... 								//if(le_Input(S_X_ESQUERDA) == false) 
.................... 								//{ 
....................  
.................... 								   one_step_x(); 
08F36:  CALL   32D2
....................  
.................... 								//} 
.................... 						 
.................... 								delay_us(500); 
08F3A:  MOVLW  02
08F3C:  MOVLB  1
08F3E:  MOVWF  x94
08F40:  CLRF   16
08F42:  BTFSC  FF2.7
08F44:  BSF    16.7
08F46:  BCF    FF2.7
08F48:  MOVLW  F9
08F4A:  MOVLB  2
08F4C:  MOVWF  x1B
08F4E:  MOVLB  0
08F50:  CALL   1C3A
08F54:  BTFSC  16.7
08F56:  BSF    FF2.7
08F58:  MOVLB  1
08F5A:  DECFSZ x94,F
08F5C:  BRA    8F40
.................... 								posiciona_cursor(2,3); 
08F5E:  MOVLW  02
08F60:  MOVWF  xA5
08F62:  MOVLW  03
08F64:  MOVWF  xA6
08F66:  MOVLB  0
08F68:  CALL   1F92
.................... 							    printf(lcd_putc,"%4Lu",contador_step_x); 
08F6C:  MOVLW  01
08F6E:  MOVWF  FE9
08F70:  MOVFF  179,19C
08F74:  MOVFF  178,19B
08F78:  CALL   5744
08F7C:  BRA    8F2C
.................... 	 
....................  
....................  
.................... 							}  
.................... 			 
.................... 	 						while(Teclado() != 0xff){} 
08F7E:  CALL   2344
08F82:  INCFSZ 01,W
08F84:  BRA    8F88
08F86:  BRA    8F8A
08F88:  BRA    8F7E
.................... 							//stop_x(); 
.................... 							delay_ms(50); 
08F8A:  MOVLW  32
08F8C:  MOVLB  2
08F8E:  MOVWF  x17
08F90:  MOVLB  0
08F92:  CALL   1D50
....................  
.................... 						    break;  
08F96:  BRA    9094
....................  
....................  
.................... 	case SETA_INFERIOR:  
.................... 							frente(); 
08F98:  CALL   3158
.................... 							chopper_y(); 
08F9C:  CALL   3152
.................... 							delay_ms(100); 
08FA0:  MOVLW  64
08FA2:  MOVLB  2
08FA4:  MOVWF  x17
08FA6:  MOVLB  0
08FA8:  CALL   1D50
.................... 				 			while(Teclado()== SETA_INFERIOR) 	 
08FAC:  CALL   2344
08FB0:  MOVF   01,W
08FB2:  SUBLW  0F
08FB4:  BNZ   8FFC
.................... 							{ 
.................... 								//if(le_Input(S_Y_FRENTE) == false) 
.................... 								//{ 
....................  
.................... 								  one_step_Y(); 
08FB6:  CALL   3166
....................  
.................... 								//} 
.................... 								delay_us(500); 
08FBA:  MOVLW  02
08FBC:  MOVLB  1
08FBE:  MOVWF  x94
08FC0:  CLRF   16
08FC2:  BTFSC  FF2.7
08FC4:  BSF    16.7
08FC6:  BCF    FF2.7
08FC8:  MOVLW  F9
08FCA:  MOVLB  2
08FCC:  MOVWF  x1B
08FCE:  MOVLB  0
08FD0:  CALL   1C3A
08FD4:  BTFSC  16.7
08FD6:  BSF    FF2.7
08FD8:  MOVLB  1
08FDA:  DECFSZ x94,F
08FDC:  BRA    8FC0
.................... 								posiciona_cursor(3,3); 
08FDE:  MOVLW  03
08FE0:  MOVWF  xA5
08FE2:  MOVWF  xA6
08FE4:  MOVLB  0
08FE6:  CALL   1F92
.................... 							    printf(lcd_putc,"%4Lu",contador_step_Y); 
08FEA:  MOVLW  01
08FEC:  MOVWF  FE9
08FEE:  MOVFF  17B,19C
08FF2:  MOVFF  17A,19B
08FF6:  CALL   5744
08FFA:  BRA    8FAC
.................... 	 
.................... 							}  
.................... 			 
.................... 	 						while(Teclado() != 0Xff){} 
08FFC:  CALL   2344
09000:  INCFSZ 01,W
09002:  BRA    9006
09004:  BRA    9008
09006:  BRA    8FFC
.................... 							//stop_Y(); 
.................... 							delay_ms(50); 
09008:  MOVLW  32
0900A:  MOVLB  2
0900C:  MOVWF  x17
0900E:  MOVLB  0
09010:  CALL   1D50
....................  
.................... 						break; 
09014:  BRA    9094
....................  
.................... 	case SETA_SUPERIOR:  
.................... 							atras(); 
09016:  CALL   319A
.................... 							chopper_y(); 
0901A:  CALL   3152
.................... 							delay_ms(100); 
0901E:  MOVLW  64
09020:  MOVLB  2
09022:  MOVWF  x17
09024:  MOVLB  0
09026:  CALL   1D50
.................... 				 			while(Teclado()== SETA_SUPERIOR) //S_X_DIREITA	 
0902A:  CALL   2344
0902E:  MOVF   01,W
09030:  SUBLW  0E
09032:  BNZ   907A
.................... 							{ 
.................... 								//if(le_Input(S_Y_ATRAS) == false) 
.................... 								//{ 
....................  
.................... 								  one_step_Y(); 
09034:  CALL   3166
....................  
.................... 								//} 
.................... 								delay_us(500); 
09038:  MOVLW  02
0903A:  MOVLB  1
0903C:  MOVWF  x94
0903E:  CLRF   16
09040:  BTFSC  FF2.7
09042:  BSF    16.7
09044:  BCF    FF2.7
09046:  MOVLW  F9
09048:  MOVLB  2
0904A:  MOVWF  x1B
0904C:  MOVLB  0
0904E:  CALL   1C3A
09052:  BTFSC  16.7
09054:  BSF    FF2.7
09056:  MOVLB  1
09058:  DECFSZ x94,F
0905A:  BRA    903E
.................... 								posiciona_cursor(3,3); 
0905C:  MOVLW  03
0905E:  MOVWF  xA5
09060:  MOVWF  xA6
09062:  MOVLB  0
09064:  CALL   1F92
.................... 							    printf(lcd_putc,"%4Lu",contador_step_Y); 
09068:  MOVLW  01
0906A:  MOVWF  FE9
0906C:  MOVFF  17B,19C
09070:  MOVFF  17A,19B
09074:  CALL   5744
09078:  BRA    902A
.................... 	 
.................... 							}  
.................... 			 
.................... 	 						while(Teclado() != 0Xff){} 
0907A:  CALL   2344
0907E:  INCFSZ 01,W
09080:  BRA    9084
09082:  BRA    9086
09084:  BRA    907A
.................... 							//stop_Y(); 
.................... 							delay_ms(50); 
09086:  MOVLW  32
09088:  MOVLB  2
0908A:  MOVWF  x17
0908C:  MOVLB  0
0908E:  CALL   1D50
.................... 							 
....................  
.................... 						break; 
09092:  BRA    9094
....................  
....................  
.................... 	default : 
....................  
.................... 		    break; 
....................  
.................... 	} 
....................  
.................... 			 if(key_code == ESC) break;	 
09094:  MOVLB  1
09096:  MOVF   x93,W
09098:  SUBLW  12
0909A:  BTFSC  FD8.2
0909C:  BRA    90A4
0909E:  MOVLB  0
090A0:  BRA    8E74
090A2:  MOVLB  1
....................  } 
.................... 		espera_desacionar_teclas(); 
090A4:  MOVLB  0
090A6:  CALL   7FCA
.................... 		stop_x(); 
090AA:  CALL   3314
.................... 		stop_Y(); 
090AE:  CALL   31A8
.................... 		delay_ms(100); 
090B2:  MOVLW  64
090B4:  MOVLB  2
090B6:  MOVWF  x17
090B8:  MOVLB  0
090BA:  CALL   1D50
090BE:  GOTO   A844 (RETURN)
....................  
....................  
.................... } 
....................  
.................... void Debug_eixo_flip(void) 
*
09266:  MOVLB  1
09268:  CLRF   x93
.................... { 
.................... 	 
.................... 	int key_code = 0; 
.................... 	printf(lcd_putc,"\f"); 
0926A:  MOVLW  0C
0926C:  MOVWF  xA4
0926E:  MOVLB  0
09270:  CALL   2586
.................... 	printf(lcd_putc,"  EIXO ROTACIONAL   \n\r"); 
09274:  MOVLW  4A
09276:  MOVWF  FF6
09278:  MOVLW  01
0927A:  MOVWF  FF7
0927C:  CALL   25DA
.................... 	printf(lcd_putc,"\n\r"); 
09280:  MOVLW  0A
09282:  MOVLB  1
09284:  MOVWF  xA4
09286:  MOVLB  0
09288:  CALL   2586
0928C:  MOVLW  0D
0928E:  MOVLB  1
09290:  MOVWF  xA4
09292:  MOVLB  0
09294:  CALL   2586
.................... 	printf(lcd_putc,"Z:0000              \n\r"); 
09298:  MOVLW  62
0929A:  MOVWF  FF6
0929C:  MOVLW  01
0929E:  MOVWF  FF7
092A0:  CALL   25DA
....................       
.................... 	posiciona_cursor(3,3); 
092A4:  MOVLW  03
092A6:  MOVLB  1
092A8:  MOVWF  xA5
092AA:  MOVWF  xA6
092AC:  MOVLB  0
092AE:  CALL   1F92
.................... 	printf(lcd_putc,"%4Lu",contador_step_flip); 
092B2:  MOVLW  01
092B4:  MOVWF  FE9
092B6:  MOVFF  17D,19C
092BA:  MOVFF  17C,19B
092BE:  CALL   5744
....................  
.................... 	while(true){	 
.................... 	key_code = Teclado(); 
092C2:  CALL   2344
092C6:  MOVFF  01,193
.................... 	 
.................... 	switch(key_code){ 
092CA:  MOVLB  1
092CC:  MOVF   x93,W
092CE:  XORLW  10
092D0:  MOVLB  0
092D2:  BZ    92DA
092D4:  XORLW  01
092D6:  BZ    9342
092D8:  BRA    93BC
....................  
.................... 	case  SETA_DIREITA: 	sentido_horario(); 
092DA:  CALL   37AC
.................... 							chopper_flip(); 
092DE:  CALL   37A6
.................... 							delay_ms(100); 
092E2:  MOVLW  64
092E4:  MOVLB  2
092E6:  MOVWF  x17
092E8:  MOVLB  0
092EA:  CALL   1D50
.................... 				 			while(Teclado()== SETA_DIREITA ) 
092EE:  CALL   2344
092F2:  MOVF   01,W
092F4:  SUBLW  10
092F6:  BNZ   9328
.................... 							{ 
.................... 							 
....................  
.................... 								one_step_flip(); 
092F8:  CALL   37BA
.................... 								delay_us(7000); 
092FC:  MOVLW  07
092FE:  MOVLB  2
09300:  MOVWF  x17
09302:  MOVLB  0
09304:  CALL   1D50
.................... 								posiciona_cursor(3,3); 
09308:  MOVLW  03
0930A:  MOVLB  1
0930C:  MOVWF  xA5
0930E:  MOVWF  xA6
09310:  MOVLB  0
09312:  CALL   1F92
.................... 							    printf(lcd_putc,"%4Lu",contador_step_flip); 
09316:  MOVLW  01
09318:  MOVWF  FE9
0931A:  MOVFF  17D,19C
0931E:  MOVFF  17C,19B
09322:  CALL   5744
09326:  BRA    92EE
....................  
.................... 	 
.................... 							}  
.................... 			 
.................... 	 						while(Teclado() != 0Xff){} 
09328:  CALL   2344
0932C:  INCFSZ 01,W
0932E:  BRA    9332
09330:  BRA    9334
09332:  BRA    9328
.................... 							//stop_flip(); 
.................... 							delay_ms(50); 
09334:  MOVLW  32
09336:  MOVLB  2
09338:  MOVWF  x17
0933A:  MOVLB  0
0933C:  CALL   1D50
....................  
.................... 						     
.................... 						  break; 
09340:  BRA    93BC
....................  
.................... 	case  SETA_ESQUERDA: 	sentido_antihorario(); 
09342:  CALL   37EE
.................... 							chopper_flip(); 
09346:  CALL   37A6
.................... 							delay_ms(100); 
0934A:  MOVLW  64
0934C:  MOVLB  2
0934E:  MOVWF  x17
09350:  MOVLB  0
09352:  CALL   1D50
.................... 				 			while(Teclado()== SETA_ESQUERDA ) 
09356:  CALL   2344
0935A:  MOVF   01,W
0935C:  SUBLW  11
0935E:  BNZ   93A0
.................... 							{ 
....................  
.................... 								if(le_Input(S_ROTACAO_LS1) == false) 
09360:  MOVLW  0B
09362:  MOVLB  1
09364:  MOVWF  x9C
09366:  MOVLB  0
09368:  CALL   2C54
0936C:  MOVF   01,F
0936E:  BNZ   9374
.................... 								{  
....................  
.................... 									one_step_flip(); 
09370:  CALL   37BA
....................  
.................... 								} 
....................  
.................... 								delay_us(7000); 
09374:  MOVLW  07
09376:  MOVLB  2
09378:  MOVWF  x17
0937A:  MOVLB  0
0937C:  CALL   1D50
.................... 								posiciona_cursor(3,3); 
09380:  MOVLW  03
09382:  MOVLB  1
09384:  MOVWF  xA5
09386:  MOVWF  xA6
09388:  MOVLB  0
0938A:  CALL   1F92
.................... 							    printf(lcd_putc,"%4Lu",contador_step_flip); 
0938E:  MOVLW  01
09390:  MOVWF  FE9
09392:  MOVFF  17D,19C
09396:  MOVFF  17C,19B
0939A:  CALL   5744
0939E:  BRA    9356
.................... 	 
.................... 							}  
.................... 			 
.................... 	 						while(Teclado() != 0Xff){} 
093A0:  CALL   2344
093A4:  INCFSZ 01,W
093A6:  BRA    93AA
093A8:  BRA    93AC
093AA:  BRA    93A0
.................... 							//stop_flip(); 
.................... 							delay_ms(50); 
093AC:  MOVLW  32
093AE:  MOVLB  2
093B0:  MOVWF  x17
093B2:  MOVLB  0
093B4:  CALL   1D50
....................  
.................... 						     
.................... 						  break; 
093B8:  BRA    93BC
....................  
....................  
....................  
....................  
....................  
.................... 						break; 
093BA:  BRA    93BC
....................  
....................  
.................... 	default : 
....................  
.................... 		    break; 
....................  
.................... 	} 
....................  
.................... 			 if(key_code == ESC) break;	 
093BC:  MOVLB  1
093BE:  MOVF   x93,W
093C0:  SUBLW  12
093C2:  BTFSC  FD8.2
093C4:  BRA    93CC
093C6:  MOVLB  0
093C8:  BRA    92C2
093CA:  MOVLB  1
....................  } 
.................... 		espera_desacionar_teclas(); 
093CC:  MOVLB  0
093CE:  CALL   7FCA
.................... 		stop_flip(); 
093D2:  BRA    925E
.................... 		delay_ms(100); 
093D4:  MOVLW  64
093D6:  MOVLB  2
093D8:  MOVWF  x17
093DA:  MOVLB  0
093DC:  CALL   1D50
093E0:  GOTO   A844 (RETURN)
....................  
....................  
.................... } 
....................  
....................  
....................  
.................... void Debug_eixo_z(void) 
*
090C2:  MOVLB  1
090C4:  CLRF   x93
.................... { 
.................... 	 
.................... 	int key_code = 0; 
.................... 	printf(lcd_putc,"\f"); 
090C6:  MOVLW  0C
090C8:  MOVWF  xA4
090CA:  MOVLB  0
090CC:  CALL   2586
.................... 	printf(lcd_putc,"         EIXO Z    \n\r"); 
090D0:  MOVLW  7A
090D2:  MOVWF  FF6
090D4:  MOVLW  01
090D6:  MOVWF  FF7
090D8:  CALL   25DA
.................... 	printf(lcd_putc,"\n\r"); 
090DC:  MOVLW  0A
090DE:  MOVLB  1
090E0:  MOVWF  xA4
090E2:  MOVLB  0
090E4:  CALL   2586
090E8:  MOVLW  0D
090EA:  MOVLB  1
090EC:  MOVWF  xA4
090EE:  MOVLB  0
090F0:  CALL   2586
.................... 	printf(lcd_putc,"R:0000              \n\r"); 
090F4:  MOVLW  90
090F6:  MOVWF  FF6
090F8:  MOVLW  01
090FA:  MOVWF  FF7
090FC:  CALL   25DA
....................       
....................  
.................... 	while(true){	 
.................... 	key_code = Teclado(); 
09100:  CALL   2344
09104:  MOVFF  01,193
.................... 	 
.................... 	switch(key_code){ 
09108:  MOVLB  1
0910A:  MOVF   x93,W
0910C:  XORLW  0E
0910E:  MOVLB  0
09110:  BZ    9118
09112:  XORLW  01
09114:  BZ    91A6
09116:  BRA    9234
....................  
.................... 	case  SETA_SUPERIOR:    sobe(); 
09118:  CALL   2ECC
.................... 							chopper_z(); 
0911C:  CALL   2C0C
.................... 							delay_ms(100); 
09120:  MOVLW  64
09122:  MOVLB  2
09124:  MOVWF  x17
09126:  MOVLB  0
09128:  CALL   1D50
.................... 				 			while(Teclado()== SETA_SUPERIOR ) 
0912C:  CALL   2344
09130:  MOVF   01,W
09132:  SUBLW  0E
09134:  BNZ   918C
.................... 							{ 
.................... 									if(le_Input(S_Z_TOP) == false) 
09136:  MOVLW  0D
09138:  MOVLB  1
0913A:  MOVWF  x9C
0913C:  MOVLB  0
0913E:  CALL   2C54
09142:  MOVF   01,F
09144:  BNZ   914A
.................... 								{ 
....................   
....................  									one_step_z(); 
09146:  CALL   2E98
....................  
....................  
.................... 								} 
.................... 								 
.................... 								delay_us(500); 
0914A:  MOVLW  02
0914C:  MOVLB  1
0914E:  MOVWF  x94
09150:  CLRF   16
09152:  BTFSC  FF2.7
09154:  BSF    16.7
09156:  BCF    FF2.7
09158:  MOVLW  F9
0915A:  MOVLB  2
0915C:  MOVWF  x1B
0915E:  MOVLB  0
09160:  CALL   1C3A
09164:  BTFSC  16.7
09166:  BSF    FF2.7
09168:  MOVLB  1
0916A:  DECFSZ x94,F
0916C:  BRA    9150
.................... 								posiciona_cursor(3,3); 
0916E:  MOVLW  03
09170:  MOVWF  xA5
09172:  MOVWF  xA6
09174:  MOVLB  0
09176:  CALL   1F92
.................... 							    printf(lcd_putc,"%4LU",contador_step_z); 
0917A:  MOVLW  01
0917C:  MOVWF  FE9
0917E:  MOVFF  17F,19C
09182:  MOVFF  17E,19B
09186:  CALL   5744
0918A:  BRA    912C
.................... 	 
.................... 							}  
.................... 			 
.................... 	 						while(Teclado() != 0Xff){} 
0918C:  CALL   2344
09190:  INCFSZ 01,W
09192:  BRA    9196
09194:  BRA    9198
09196:  BRA    918C
.................... 							//stop_z(); 
.................... 							delay_ms(50); 
09198:  MOVLW  32
0919A:  MOVLB  2
0919C:  MOVWF  x17
0919E:  MOVLB  0
091A0:  CALL   1D50
....................  
.................... 						     
.................... 						   
.................... 						break; 
091A4:  BRA    9234
....................  
.................... 	case  SETA_INFERIOR:    desce(); 
091A6:  CALL   2E8A
.................... 							chopper_z(); 
091AA:  CALL   2C0C
.................... 							delay_ms(100); 
091AE:  MOVLW  64
091B0:  MOVLB  2
091B2:  MOVWF  x17
091B4:  MOVLB  0
091B6:  CALL   1D50
.................... 				 			while(Teclado()== SETA_INFERIOR ) 
091BA:  CALL   2344
091BE:  MOVF   01,W
091C0:  SUBLW  0F
091C2:  BNZ   921A
.................... 							{ 
....................  
.................... 									if(le_Input(S_Z_BOTTOM) == false) 
091C4:  MOVLW  0E
091C6:  MOVLB  1
091C8:  MOVWF  x9C
091CA:  MOVLB  0
091CC:  CALL   2C54
091D0:  MOVF   01,F
091D2:  BNZ   91D8
.................... 									{ 
....................   
....................  									    one_step_z(); 
091D4:  CALL   2E98
....................  
....................  
.................... 								    } 
.................... 								 
.................... 								delay_us(500); 
091D8:  MOVLW  02
091DA:  MOVLB  1
091DC:  MOVWF  x94
091DE:  CLRF   16
091E0:  BTFSC  FF2.7
091E2:  BSF    16.7
091E4:  BCF    FF2.7
091E6:  MOVLW  F9
091E8:  MOVLB  2
091EA:  MOVWF  x1B
091EC:  MOVLB  0
091EE:  CALL   1C3A
091F2:  BTFSC  16.7
091F4:  BSF    FF2.7
091F6:  MOVLB  1
091F8:  DECFSZ x94,F
091FA:  BRA    91DE
.................... 								posiciona_cursor(3,3); 
091FC:  MOVLW  03
091FE:  MOVWF  xA5
09200:  MOVWF  xA6
09202:  MOVLB  0
09204:  CALL   1F92
.................... 							    printf(lcd_putc,"%4LU",contador_step_z); 
09208:  MOVLW  01
0920A:  MOVWF  FE9
0920C:  MOVFF  17F,19C
09210:  MOVFF  17E,19B
09214:  CALL   5744
09218:  BRA    91BA
.................... 	 
.................... 							}  
.................... 			 
.................... 	 						while(Teclado() != 0Xff){} 
0921A:  CALL   2344
0921E:  INCFSZ 01,W
09220:  BRA    9224
09222:  BRA    9226
09224:  BRA    921A
.................... 							//stop_z(); 
.................... 							delay_ms(50); 
09226:  MOVLW  32
09228:  MOVLB  2
0922A:  MOVWF  x17
0922C:  MOVLB  0
0922E:  CALL   1D50
....................  
.................... 							 
.................... 						break; 
09232:  BRA    9234
....................  
....................  
.................... 	default : 
....................  
.................... 		    break; 
....................  
.................... 	} 
....................  
.................... 			 if(key_code == ESC) break;	 
09234:  MOVLB  1
09236:  MOVF   x93,W
09238:  SUBLW  12
0923A:  BTFSC  FD8.2
0923C:  BRA    9244
0923E:  MOVLB  0
09240:  BRA    9100
09242:  MOVLB  1
....................  } 
.................... 		espera_desacionar_teclas(); 
09244:  MOVLB  0
09246:  CALL   7FCA
.................... 		stop_z(); 
0924A:  CALL   2EDA
.................... 		delay_ms(100); 
0924E:  MOVLW  64
09250:  MOVLB  2
09252:  MOVWF  x17
09254:  MOVLB  0
09256:  CALL   1D50
0925A:  GOTO   A844 (RETURN)
....................  
....................  
.................... } 
....................  
.................... void Debug_Empurrador_Entrada(void) 
*
093E4:  MOVLB  1
093E6:  CLRF   x93
.................... { 
.................... 	int key_code = 0; 
.................... 	printf(lcd_putc,"\f"); 
093E8:  MOVLW  0C
093EA:  MOVWF  xA4
093EC:  MOVLB  0
093EE:  CALL   2586
.................... 	printf(lcd_putc," EMPURRADOR ENTRADA\n\r"); 
093F2:  MOVLW  A8
093F4:  MOVWF  FF6
093F6:  MOVLW  01
093F8:  MOVWF  FF7
093FA:  CALL   25DA
.................... 	printf(lcd_putc,"F1:AVANCA    S_A:OFF\n\r"); 
093FE:  MOVLW  BE
09400:  MOVWF  FF6
09402:  MOVLW  01
09404:  MOVWF  FF7
09406:  CALL   25DA
.................... 	printf(lcd_putc,"F2:RECUA     S_R:OFF\n\r"); 
0940A:  MOVLW  D6
0940C:  MOVWF  FF6
0940E:  MOVLW  01
09410:  MOVWF  FF7
09412:  CALL   25DA
.................... 	printf(lcd_putc,"         S_PLACA:OFF\n\r"); 
09416:  MOVLW  EE
09418:  MOVWF  FF6
0941A:  MOVLW  01
0941C:  MOVWF  FF7
0941E:  CALL   25DA
....................  
.................... 	while(true){	 
.................... 	key_code = Teclado(); 
09422:  CALL   2344
09426:  MOVFF  01,193
.................... 	 
.................... 	switch(key_code){ 
0942A:  MOVLB  1
0942C:  MOVF   x93,W
0942E:  XORLW  0A
09430:  MOVLB  0
09432:  BZ    943A
09434:  XORLW  01
09436:  BZ    9464
09438:  BRA    948E
....................  
.................... 	case  F1:  
0943A:  CLRF   16
0943C:  BTFSC  FF2.7
0943E:  BSF    16.7
09440:  BCF    FF2.7
.................... 						desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
09442:  MOVLB  2
09444:  CLRF   x1B
09446:  MOVLW  05
09448:  MOVWF  x1A
0944A:  MOVLB  0
0944C:  CALL   1B96
09450:  BTFSC  16.7
09452:  BSF    FF2.7
....................                         aciona_saida( EMPURRADOR_ENTRADA_SOL_EMPURRA); 
09454:  MOVLB  1
09456:  CLRF   xA1
09458:  MOVLW  06
0945A:  MOVWF  xA0
0945C:  MOVLB  0
0945E:  CALL   2FD2
.................... 						break; 
09462:  BRA    948E
....................  
.................... 	case  F2: 			desaciona_saida( EMPURRADOR_ENTRADA_SOL_EMPURRA); 
09464:  CLRF   16
09466:  BTFSC  FF2.7
09468:  BSF    16.7
0946A:  BCF    FF2.7
0946C:  MOVLB  2
0946E:  CLRF   x1B
09470:  MOVLW  06
09472:  MOVWF  x1A
09474:  MOVLB  0
09476:  CALL   1B96
0947A:  BTFSC  16.7
0947C:  BSF    FF2.7
....................           				aciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
0947E:  MOVLB  1
09480:  CLRF   xA1
09482:  MOVLW  05
09484:  MOVWF  xA0
09486:  MOVLB  0
09488:  CALL   2FD2
.................... 						break; 
0948C:  BRA    948E
.................... 					 
....................  
.................... 	default : 
....................  
.................... 		    break; 
....................  
.................... 	} 
.................... 			 
.................... 	 		 if(le_Input(S_BANDEJA) == true) 
0948E:  MOVLW  15
09490:  MOVLB  1
09492:  MOVWF  x9C
09494:  MOVLB  0
09496:  CALL   2C54
0949A:  DECFSZ 01,W
0949C:  BRA    94BC
.................... 			 { 
.................... 				posiciona_cursor(2,18); 
0949E:  MOVLW  02
094A0:  MOVLB  1
094A2:  MOVWF  xA5
094A4:  MOVLW  12
094A6:  MOVWF  xA6
094A8:  MOVLB  0
094AA:  CALL   1F92
.................... 				printf(lcd_putc,"ON "); 
094AE:  MOVLW  06
094B0:  MOVWF  FF6
094B2:  MOVLW  02
094B4:  MOVWF  FF7
094B6:  CALL   25DA
....................  
.................... 			 }else 
094BA:  BRA    94D8
.................... 				 {   
.................... 					posiciona_cursor(2,18); 
094BC:  MOVLW  02
094BE:  MOVLB  1
094C0:  MOVWF  xA5
094C2:  MOVLW  12
094C4:  MOVWF  xA6
094C6:  MOVLB  0
094C8:  CALL   1F92
.................... 					printf(lcd_putc,"OFF"); 
094CC:  MOVLW  0A
094CE:  MOVWF  FF6
094D0:  MOVLW  02
094D2:  MOVWF  FF7
094D4:  CALL   25DA
....................  
.................... 				 } 
....................  
....................  			 if(le_Input(S_EMPURRADOR_IN_LS2) == true) 
094D8:  MOVLW  03
094DA:  MOVLB  1
094DC:  MOVWF  x9C
094DE:  MOVLB  0
094E0:  CALL   2C54
094E4:  DECFSZ 01,W
094E6:  BRA    9506
.................... 			 { 
.................... 				posiciona_cursor(3,18); 
094E8:  MOVLW  03
094EA:  MOVLB  1
094EC:  MOVWF  xA5
094EE:  MOVLW  12
094F0:  MOVWF  xA6
094F2:  MOVLB  0
094F4:  CALL   1F92
.................... 				printf(lcd_putc,"ON "); 
094F8:  MOVLW  0E
094FA:  MOVWF  FF6
094FC:  MOVLW  02
094FE:  MOVWF  FF7
09500:  CALL   25DA
....................  
.................... 			 }else 
09504:  BRA    9522
.................... 				 {  posiciona_cursor(3,18); 
09506:  MOVLW  03
09508:  MOVLB  1
0950A:  MOVWF  xA5
0950C:  MOVLW  12
0950E:  MOVWF  xA6
09510:  MOVLB  0
09512:  CALL   1F92
.................... 					printf(lcd_putc,"OFF"); 
09516:  MOVLW  12
09518:  MOVWF  FF6
0951A:  MOVLW  02
0951C:  MOVWF  FF7
0951E:  CALL   25DA
....................  
.................... 				 } 
....................  
.................... 	  
.................... 	 
.................... 			 if(key_code == ESC) break;	 
09522:  MOVLB  1
09524:  MOVF   x93,W
09526:  SUBLW  12
09528:  BTFSC  FD8.2
0952A:  BRA    9532
0952C:  MOVLB  0
0952E:  BRA    9422
09530:  MOVLB  1
....................  } 
....................  
.................... 		espera_desacionar_teclas(); 
09532:  MOVLB  0
09534:  CALL   7FCA
.................... 		delay_ms(100); 
09538:  MOVLW  64
0953A:  MOVLB  2
0953C:  MOVWF  x17
0953E:  MOVLB  0
09540:  CALL   1D50
09544:  GOTO   A844 (RETURN)
....................  
.................... } 
....................  
....................  
.................... void Debug_Dedos_Entrada(void) 
09548:  MOVLB  1
0954A:  CLRF   x93
.................... { 
.................... 	int key_code = 0; 
.................... 	printf(lcd_putc,"\f"); 
0954C:  MOVLW  0C
0954E:  MOVWF  xA4
09550:  MOVLB  0
09552:  CALL   2586
.................... 	printf(lcd_putc,"  DEDOS ENTRADA\n\r"); 
09556:  MOVLW  16
09558:  MOVWF  FF6
0955A:  MOVLW  02
0955C:  MOVWF  FF7
0955E:  CALL   25DA
.................... 	printf(lcd_putc,"\n\r"); 
09562:  MOVLW  0A
09564:  MOVLB  1
09566:  MOVWF  xA4
09568:  MOVLB  0
0956A:  CALL   2586
0956E:  MOVLW  0D
09570:  MOVLB  1
09572:  MOVWF  xA4
09574:  MOVLB  0
09576:  CALL   2586
.................... 	printf(lcd_putc,"F1:AVANCA   S_A1:OFF\n\r"); 
0957A:  MOVLW  28
0957C:  MOVWF  FF6
0957E:  MOVLW  02
09580:  MOVWF  FF7
09582:  CALL   25DA
.................... 	printf(lcd_putc,"F2:RECUA    S_A2:OFF\n\r"); 
09586:  MOVLW  40
09588:  MOVWF  FF6
0958A:  MOVLW  02
0958C:  MOVWF  FF7
0958E:  CALL   25DA
.................... 	 
.................... 	while(true){	 
.................... 	key_code = Teclado(); 
09592:  CALL   2344
09596:  MOVFF  01,193
.................... 	 
.................... 	switch(key_code){ 
0959A:  MOVLB  1
0959C:  MOVF   x93,W
0959E:  XORLW  0A
095A0:  MOVLB  0
095A2:  BZ    95AA
095A4:  XORLW  01
095A6:  BZ    95BA
095A8:  BRA    95D6
....................  
.................... 	case  F1:	 	 aciona_saida(DEDO_ENTRADA);	 
095AA:  MOVLB  1
095AC:  CLRF   xA1
095AE:  MOVLW  07
095B0:  MOVWF  xA0
095B2:  MOVLB  0
095B4:  CALL   2FD2
.................... 					 break; 
095B8:  BRA    95D6
....................  
.................... 	case  F2: 		 desaciona_saida(DEDO_ENTRADA);	 
095BA:  CLRF   16
095BC:  BTFSC  FF2.7
095BE:  BSF    16.7
095C0:  BCF    FF2.7
095C2:  MOVLB  2
095C4:  CLRF   x1B
095C6:  MOVLW  07
095C8:  MOVWF  x1A
095CA:  MOVLB  0
095CC:  CALL   1B96
095D0:  BTFSC  16.7
095D2:  BSF    FF2.7
.................... 					 break; 
095D4:  BRA    95D6
....................  
.................... 	default : 
....................  
.................... 		    break; 
....................  
.................... 	} 
....................  
.................... 	 if(le_Input(S_DEDO_IN_LS1) == true) 
095D6:  MOVLB  1
095D8:  CLRF   x9C
095DA:  MOVLB  0
095DC:  CALL   2C54
095E0:  DECFSZ 01,W
095E2:  BRA    9602
.................... 			 { 
.................... 				posiciona_cursor(3,18); 
095E4:  MOVLW  03
095E6:  MOVLB  1
095E8:  MOVWF  xA5
095EA:  MOVLW  12
095EC:  MOVWF  xA6
095EE:  MOVLB  0
095F0:  CALL   1F92
.................... 				printf(lcd_putc,"ON "); 
095F4:  MOVLW  58
095F6:  MOVWF  FF6
095F8:  MOVLW  02
095FA:  MOVWF  FF7
095FC:  CALL   25DA
....................  
.................... 			 }else 
09600:  BRA    961E
.................... 				 { 
.................... 					posiciona_cursor(3,18); 
09602:  MOVLW  03
09604:  MOVLB  1
09606:  MOVWF  xA5
09608:  MOVLW  12
0960A:  MOVWF  xA6
0960C:  MOVLB  0
0960E:  CALL   1F92
.................... 					printf(lcd_putc,"OFF"); 
09612:  MOVLW  5C
09614:  MOVWF  FF6
09616:  MOVLW  02
09618:  MOVWF  FF7
0961A:  CALL   25DA
....................  
.................... 				 } 
....................  
....................  
.................... 	if(le_Input(S_DEDO_IN_LS2) == true) 
0961E:  MOVLW  01
09620:  MOVLB  1
09622:  MOVWF  x9C
09624:  MOVLB  0
09626:  CALL   2C54
0962A:  DECFSZ 01,W
0962C:  BRA    964C
.................... 			 { 
.................... 				posiciona_cursor(4,18); 
0962E:  MOVLW  04
09630:  MOVLB  1
09632:  MOVWF  xA5
09634:  MOVLW  12
09636:  MOVWF  xA6
09638:  MOVLB  0
0963A:  CALL   1F92
.................... 				printf(lcd_putc,"ON "); 
0963E:  MOVLW  60
09640:  MOVWF  FF6
09642:  MOVLW  02
09644:  MOVWF  FF7
09646:  CALL   25DA
....................  
.................... 			 }else 
0964A:  BRA    9668
.................... 				 { 
.................... 					posiciona_cursor(4,18); 
0964C:  MOVLW  04
0964E:  MOVLB  1
09650:  MOVWF  xA5
09652:  MOVLW  12
09654:  MOVWF  xA6
09656:  MOVLB  0
09658:  CALL   1F92
.................... 					printf(lcd_putc,"OFF"); 
0965C:  MOVLW  64
0965E:  MOVWF  FF6
09660:  MOVLW  02
09662:  MOVWF  FF7
09664:  CALL   25DA
....................  
.................... 				 } 
....................  
....................  
....................  
....................  
.................... 			 if(key_code == ESC) break;	 
09668:  MOVLB  1
0966A:  MOVF   x93,W
0966C:  SUBLW  12
0966E:  BTFSC  FD8.2
09670:  BRA    9678
09672:  MOVLB  0
09674:  BRA    9592
09676:  MOVLB  1
....................  } 
....................  
.................... 		espera_desacionar_teclas(); 
09678:  MOVLB  0
0967A:  CALL   7FCA
.................... 		delay_ms(100); 
0967E:  MOVLW  64
09680:  MOVLB  2
09682:  MOVWF  x17
09684:  MOVLB  0
09686:  CALL   1D50
0968A:  GOTO   A844 (RETURN)
....................  
.................... } 
....................  
....................  
.................... void  Debug_pressor(void) 
0968E:  MOVLB  1
09690:  CLRF   x93
.................... { 
.................... 	int key_code = 0; 
.................... 	printf(lcd_putc,"\f"); 
09692:  MOVLW  0C
09694:  MOVWF  xA4
09696:  MOVLB  0
09698:  CALL   2586
.................... 	printf(lcd_putc,"        PRESSOR     \n\r"); 
0969C:  MOVLW  68
0969E:  MOVWF  FF6
096A0:  MOVLW  02
096A2:  MOVWF  FF7
096A4:  CALL   25DA
.................... 	printf(lcd_putc,"\n\r"); 
096A8:  MOVLW  0A
096AA:  MOVLB  1
096AC:  MOVWF  xA4
096AE:  MOVLB  0
096B0:  CALL   2586
096B4:  MOVLW  0D
096B6:  MOVLB  1
096B8:  MOVWF  xA4
096BA:  MOVLB  0
096BC:  CALL   2586
.................... 	printf(lcd_putc,"F1:AVANCA    S_A:OFF\n\r"); 
096C0:  MOVLW  80
096C2:  MOVWF  FF6
096C4:  MOVLW  02
096C6:  MOVWF  FF7
096C8:  CALL   25DA
.................... 	printf(lcd_putc,"F2:RECUA     S_R:OFF\n\r"); 
096CC:  MOVLW  98
096CE:  MOVWF  FF6
096D0:  MOVLW  02
096D2:  MOVWF  FF7
096D4:  CALL   25DA
.................... 	 
.................... 	while(true){	 
.................... 	key_code = Teclado(); 
096D8:  CALL   2344
096DC:  MOVFF  01,193
.................... 	 
.................... 	switch(key_code){ 
096E0:  MOVLB  1
096E2:  MOVF   x93,W
096E4:  XORLW  0A
096E6:  MOVLB  0
096E8:  BZ    96F0
096EA:  XORLW  01
096EC:  BZ    9700
096EE:  BRA    971C
....................  
.................... 	case  F1:	 aciona_saida(PRESSOR);	 
096F0:  MOVLB  1
096F2:  CLRF   xA1
096F4:  MOVLW  04
096F6:  MOVWF  xA0
096F8:  MOVLB  0
096FA:  CALL   2FD2
.................... 				 break; 
096FE:  BRA    971C
....................  
.................... 	case  F2:    desaciona_saida(PRESSOR); 
09700:  CLRF   16
09702:  BTFSC  FF2.7
09704:  BSF    16.7
09706:  BCF    FF2.7
09708:  MOVLB  2
0970A:  CLRF   x1B
0970C:  MOVLW  04
0970E:  MOVWF  x1A
09710:  MOVLB  0
09712:  CALL   1B96
09716:  BTFSC  16.7
09718:  BSF    FF2.7
.................... 				 break; 
0971A:  BRA    971C
....................  
....................  
.................... 	default : 
....................  
.................... 		    break; 
....................  
.................... 	} 
.................... 		 
.................... 	 
....................  
.................... 		 if(le_Input(S_PRESSOR_LS2) == true) 
0971C:  MOVLW  04
0971E:  MOVLB  1
09720:  MOVWF  x9C
09722:  MOVLB  0
09724:  CALL   2C54
09728:  DECFSZ 01,W
0972A:  BRA    974A
.................... 			 { 
.................... 				posiciona_cursor(4,18); 
0972C:  MOVLW  04
0972E:  MOVLB  1
09730:  MOVWF  xA5
09732:  MOVLW  12
09734:  MOVWF  xA6
09736:  MOVLB  0
09738:  CALL   1F92
.................... 				printf(lcd_putc,"ON "); 
0973C:  MOVLW  B0
0973E:  MOVWF  FF6
09740:  MOVLW  02
09742:  MOVWF  FF7
09744:  CALL   25DA
....................  
.................... 			 }else 
09748:  BRA    9766
.................... 				 { 
.................... 					posiciona_cursor(4,18); 
0974A:  MOVLW  04
0974C:  MOVLB  1
0974E:  MOVWF  xA5
09750:  MOVLW  12
09752:  MOVWF  xA6
09754:  MOVLB  0
09756:  CALL   1F92
.................... 					printf(lcd_putc,"OFF"); 
0975A:  MOVLW  B4
0975C:  MOVWF  FF6
0975E:  MOVLW  02
09760:  MOVWF  FF7
09762:  CALL   25DA
....................  
.................... 				 } 
....................  
.................... 			 
.................... 			 if(key_code == ESC) break;	 
09766:  MOVLB  1
09768:  MOVF   x93,W
0976A:  SUBLW  12
0976C:  BTFSC  FD8.2
0976E:  BRA    9776
09770:  MOVLB  0
09772:  BRA    96D8
09774:  MOVLB  1
....................  } 
....................  
.................... 		espera_desacionar_teclas(); 
09776:  MOVLB  0
09778:  CALL   7FCA
.................... 		delay_ms(100); 
0977C:  MOVLW  64
0977E:  MOVLB  2
09780:  MOVWF  x17
09782:  MOVLB  0
09784:  CALL   1D50
09788:  GOTO   A844 (RETURN)
....................  
....................  
.................... } 
....................  
.................... void Debug_Empurrador_Saida(void) 
0978C:  MOVLB  1
0978E:  CLRF   x93
.................... { 
....................  
.................... 	int key_code = 0; 
.................... 	printf(lcd_putc,"\f"); 
09790:  MOVLW  0C
09792:  MOVWF  xA4
09794:  MOVLB  0
09796:  CALL   2586
.................... 	printf(lcd_putc,"   DISPENSADOR     \n\r"); 
0979A:  MOVLW  B8
0979C:  MOVWF  FF6
0979E:  MOVLW  02
097A0:  MOVWF  FF7
097A2:  CALL   25DA
.................... 	printf(lcd_putc,"\n\r"); 
097A6:  MOVLW  0A
097A8:  MOVLB  1
097AA:  MOVWF  xA4
097AC:  MOVLB  0
097AE:  CALL   2586
097B2:  MOVLW  0D
097B4:  MOVLB  1
097B6:  MOVWF  xA4
097B8:  MOVLB  0
097BA:  CALL   2586
.................... 	printf(lcd_putc,"F1:AVANCA    S_A:OFF\n\r"); 
097BE:  MOVLW  CE
097C0:  MOVWF  FF6
097C2:  MOVLW  02
097C4:  MOVWF  FF7
097C6:  CALL   25DA
.................... 	printf(lcd_putc,"F2:RECUA     S_R:OFF\n\r"); 
097CA:  MOVLW  E6
097CC:  MOVWF  FF6
097CE:  MOVLW  02
097D0:  MOVWF  FF7
097D2:  CALL   25DA
.................... 	 
.................... 	while(true){	 
.................... 	key_code = Teclado(); 
097D6:  CALL   2344
097DA:  MOVFF  01,193
.................... 	 
.................... 	switch(key_code){ 
097DE:  MOVLB  1
097E0:  MOVF   x93,W
097E2:  XORLW  0A
097E4:  MOVLB  0
097E6:  BZ    97EE
097E8:  XORLW  01
097EA:  BZ    9816
097EC:  BRA    983E
.................... 						 
....................  
.................... 	case  F1: 			desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
097EE:  CLRF   16
097F0:  BTFSC  FF2.7
097F2:  BSF    16.7
097F4:  BCF    FF2.7
097F6:  MOVLB  2
097F8:  CLRF   x1B
097FA:  MOVLW  0F
097FC:  MOVWF  x1A
097FE:  MOVLB  0
09800:  CALL   1B96
09804:  BTFSC  16.7
09806:  BSF    FF2.7
.................... 						aciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
09808:  MOVLB  1
0980A:  CLRF   xA1
0980C:  CLRF   xA0
0980E:  MOVLB  0
09810:  CALL   2FD2
.................... 						break; 
09814:  BRA    983E
....................  
.................... 	case  F2: 			desaciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
09816:  CLRF   16
09818:  BTFSC  FF2.7
0981A:  BSF    16.7
0981C:  BCF    FF2.7
0981E:  MOVLB  2
09820:  CLRF   x1B
09822:  CLRF   x1A
09824:  MOVLB  0
09826:  CALL   1B96
0982A:  BTFSC  16.7
0982C:  BSF    FF2.7
.................... 						aciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
0982E:  MOVLB  1
09830:  CLRF   xA1
09832:  MOVLW  0F
09834:  MOVWF  xA0
09836:  MOVLB  0
09838:  CALL   2FD2
.................... 						break; 
0983C:  BRA    983E
....................  
....................  
.................... 	default : 
....................  
.................... 		    break; 
....................  
.................... 	} 
....................  
.................... 			 if(le_Input(S_EMPURRADOR_OUT_LS1) == true) 
0983E:  MOVLW  12
09840:  MOVLB  1
09842:  MOVWF  x9C
09844:  MOVLB  0
09846:  CALL   2C54
0984A:  DECFSZ 01,W
0984C:  BRA    986C
.................... 			 { 
.................... 				posiciona_cursor(3,18); 
0984E:  MOVLW  03
09850:  MOVLB  1
09852:  MOVWF  xA5
09854:  MOVLW  12
09856:  MOVWF  xA6
09858:  MOVLB  0
0985A:  CALL   1F92
.................... 				printf(lcd_putc,"ON "); 
0985E:  MOVLW  FE
09860:  MOVWF  FF6
09862:  MOVLW  02
09864:  MOVWF  FF7
09866:  CALL   25DA
....................  
.................... 			 }else 
0986A:  BRA    9888
.................... 				 {   
.................... 					posiciona_cursor(3,18); 
0986C:  MOVLW  03
0986E:  MOVLB  1
09870:  MOVWF  xA5
09872:  MOVLW  12
09874:  MOVWF  xA6
09876:  MOVLB  0
09878:  CALL   1F92
.................... 					printf(lcd_putc,"OFF"); 
0987C:  MOVLW  02
0987E:  MOVWF  FF6
09880:  MOVLW  03
09882:  MOVWF  FF7
09884:  CALL   25DA
....................  
.................... 				 } 
....................  
....................  			 if(le_Input(S_EMPURRADOR_OUT_LS2) == true) 
09888:  MOVLW  13
0988A:  MOVLB  1
0988C:  MOVWF  x9C
0988E:  MOVLB  0
09890:  CALL   2C54
09894:  DECFSZ 01,W
09896:  BRA    98B6
.................... 			 { 
.................... 				posiciona_cursor(4,18); 
09898:  MOVLW  04
0989A:  MOVLB  1
0989C:  MOVWF  xA5
0989E:  MOVLW  12
098A0:  MOVWF  xA6
098A2:  MOVLB  0
098A4:  CALL   1F92
.................... 				printf(lcd_putc,"ON "); 
098A8:  MOVLW  06
098AA:  MOVWF  FF6
098AC:  MOVLW  03
098AE:  MOVWF  FF7
098B0:  CALL   25DA
....................  
.................... 			 }else 
098B4:  BRA    98D2
.................... 				 {  posiciona_cursor(4,18); 
098B6:  MOVLW  04
098B8:  MOVLB  1
098BA:  MOVWF  xA5
098BC:  MOVLW  12
098BE:  MOVWF  xA6
098C0:  MOVLB  0
098C2:  CALL   1F92
.................... 					printf(lcd_putc,"OFF"); 
098C6:  MOVLW  0A
098C8:  MOVWF  FF6
098CA:  MOVLW  03
098CC:  MOVWF  FF7
098CE:  CALL   25DA
....................  
.................... 				 } 
....................  
.................... 			 if(key_code == ESC) break;	 
098D2:  MOVLB  1
098D4:  MOVF   x93,W
098D6:  SUBLW  12
098D8:  BTFSC  FD8.2
098DA:  BRA    98E2
098DC:  MOVLB  0
098DE:  BRA    97D6
098E0:  MOVLB  1
....................  } 
....................  
.................... 		espera_desacionar_teclas(); 
098E2:  MOVLB  0
098E4:  CALL   7FCA
.................... 		delay_ms(100); 
098E8:  MOVLW  64
098EA:  MOVLB  2
098EC:  MOVWF  x17
098EE:  MOVLB  0
098F0:  CALL   1D50
098F4:  GOTO   A844 (RETURN)
....................  
....................    }		 
....................  
....................  
.................... void Debug_Dedos_Saida(void) 
098F8:  MOVLB  1
098FA:  CLRF   x93
.................... { 
.................... 	int key_code = 0; 
.................... 	printf(lcd_putc,"\f"); 
098FC:  MOVLW  0C
098FE:  MOVWF  xA4
09900:  MOVLB  0
09902:  CALL   2586
.................... 	printf(lcd_putc,"     DEDOS SAIDA    \n\r"); 
09906:  MOVLW  0E
09908:  MOVWF  FF6
0990A:  MOVLW  03
0990C:  MOVWF  FF7
0990E:  CALL   25DA
.................... 	printf(lcd_putc,"\n\r"); 
09912:  MOVLW  0A
09914:  MOVLB  1
09916:  MOVWF  xA4
09918:  MOVLB  0
0991A:  CALL   2586
0991E:  MOVLW  0D
09920:  MOVLB  1
09922:  MOVWF  xA4
09924:  MOVLB  0
09926:  CALL   2586
.................... 	printf(lcd_putc,"F1:AVANCA    S_A:OFF\n\r"); 
0992A:  MOVLW  26
0992C:  MOVWF  FF6
0992E:  MOVLW  03
09930:  MOVWF  FF7
09932:  CALL   25DA
.................... 	printf(lcd_putc,"F2:RECUA     S_R:OFF\n\r"); 
09936:  MOVLW  3E
09938:  MOVWF  FF6
0993A:  MOVLW  03
0993C:  MOVWF  FF7
0993E:  CALL   25DA
.................... 	 
.................... 	while(true){	 
.................... 	key_code = Teclado(); 
09942:  CALL   2344
09946:  MOVFF  01,193
.................... 	 
.................... 	switch(key_code){ 
0994A:  MOVLB  1
0994C:  MOVF   x93,W
0994E:  XORLW  0A
09950:  MOVLB  0
09952:  BZ    995A
09954:  XORLW  01
09956:  BZ    996A
09958:  BRA    9986
....................  
.................... 	case  F1:  		aciona_saida(DEDO_SAIDA); 
0995A:  MOVLB  1
0995C:  CLRF   xA1
0995E:  MOVLW  01
09960:  MOVWF  xA0
09962:  MOVLB  0
09964:  CALL   2FD2
.................... 						break; 
09968:  BRA    9986
....................  
.................... 	case  F2: 	    desaciona_saida(DEDO_SAIDA); 
0996A:  CLRF   16
0996C:  BTFSC  FF2.7
0996E:  BSF    16.7
09970:  BCF    FF2.7
09972:  MOVLB  2
09974:  CLRF   x1B
09976:  MOVLW  01
09978:  MOVWF  x1A
0997A:  MOVLB  0
0997C:  CALL   1B96
09980:  BTFSC  16.7
09982:  BSF    FF2.7
.................... 						break; 
09984:  BRA    9986
....................  
....................  
.................... 	default : 
....................  
.................... 		    break; 
....................  
.................... 	} 
....................  
....................  
.................... 		 if(le_Input(S_DEDO_OUT_LS1) == true) 
09986:  MOVLW  10
09988:  MOVLB  1
0998A:  MOVWF  x9C
0998C:  MOVLB  0
0998E:  CALL   2C54
09992:  DECFSZ 01,W
09994:  BRA    99B4
.................... 			 { 
.................... 				posiciona_cursor(3,18); 
09996:  MOVLW  03
09998:  MOVLB  1
0999A:  MOVWF  xA5
0999C:  MOVLW  12
0999E:  MOVWF  xA6
099A0:  MOVLB  0
099A2:  CALL   1F92
.................... 				printf(lcd_putc,"ON "); 
099A6:  MOVLW  56
099A8:  MOVWF  FF6
099AA:  MOVLW  03
099AC:  MOVWF  FF7
099AE:  CALL   25DA
....................  
.................... 			 }else 
099B2:  BRA    99D0
.................... 				 { 
.................... 					posiciona_cursor(3,18); 
099B4:  MOVLW  03
099B6:  MOVLB  1
099B8:  MOVWF  xA5
099BA:  MOVLW  12
099BC:  MOVWF  xA6
099BE:  MOVLB  0
099C0:  CALL   1F92
.................... 					printf(lcd_putc,"OFF"); 
099C4:  MOVLW  5A
099C6:  MOVWF  FF6
099C8:  MOVLW  03
099CA:  MOVWF  FF7
099CC:  CALL   25DA
....................  
.................... 				 } 
....................  
....................  
.................... 	     if(le_Input(S_DEDO_OUT_LS2) == true) 
099D0:  MOVLW  11
099D2:  MOVLB  1
099D4:  MOVWF  x9C
099D6:  MOVLB  0
099D8:  CALL   2C54
099DC:  DECFSZ 01,W
099DE:  BRA    99FE
.................... 			 { 
.................... 				posiciona_cursor(4,18); 
099E0:  MOVLW  04
099E2:  MOVLB  1
099E4:  MOVWF  xA5
099E6:  MOVLW  12
099E8:  MOVWF  xA6
099EA:  MOVLB  0
099EC:  CALL   1F92
.................... 				printf(lcd_putc,"ON "); 
099F0:  MOVLW  5E
099F2:  MOVWF  FF6
099F4:  MOVLW  03
099F6:  MOVWF  FF7
099F8:  CALL   25DA
....................  
.................... 			 }else 
099FC:  BRA    9A1A
.................... 				 { 
.................... 					posiciona_cursor(4,18); 
099FE:  MOVLW  04
09A00:  MOVLB  1
09A02:  MOVWF  xA5
09A04:  MOVLW  12
09A06:  MOVWF  xA6
09A08:  MOVLB  0
09A0A:  CALL   1F92
.................... 					printf(lcd_putc,"OFF"); 
09A0E:  MOVLW  62
09A10:  MOVWF  FF6
09A12:  MOVLW  03
09A14:  MOVWF  FF7
09A16:  CALL   25DA
....................  
.................... 				 } 
....................  
....................  
....................  
.................... 			 if(key_code == ESC) break;	 
09A1A:  MOVLB  1
09A1C:  MOVF   x93,W
09A1E:  SUBLW  12
09A20:  BTFSC  FD8.2
09A22:  BRA    9A2A
09A24:  MOVLB  0
09A26:  BRA    9942
09A28:  MOVLB  1
....................  } 
....................  
.................... 		espera_desacionar_teclas(); 
09A2A:  MOVLB  0
09A2C:  CALL   7FCA
.................... 		delay_ms(100); 
09A30:  MOVLW  64
09A32:  MOVLB  2
09A34:  MOVWF  x17
09A36:  MOVLB  0
09A38:  CALL   1D50
09A3C:  GOTO   A844 (RETURN)
....................  
.................... }		 
....................  
....................  
.................... void Debug_Limpador(void) 
09A40:  MOVLB  1
09A42:  CLRF   x93
.................... { 
....................  
.................... 	int key_code = 0; 
.................... 	printf(lcd_putc,"\f"); 
09A44:  MOVLW  0C
09A46:  MOVWF  xA4
09A48:  MOVLB  0
09A4A:  CALL   2586
.................... 	printf(lcd_putc,"      LIMPADOR      \n\r"); 
09A4E:  MOVLW  66
09A50:  MOVWF  FF6
09A52:  MOVLW  03
09A54:  MOVWF  FF7
09A56:  CALL   25DA
.................... 	printf(lcd_putc,"\n\r"); 
09A5A:  MOVLW  0A
09A5C:  MOVLB  1
09A5E:  MOVWF  xA4
09A60:  MOVLB  0
09A62:  CALL   2586
09A66:  MOVLW  0D
09A68:  MOVLB  1
09A6A:  MOVWF  xA4
09A6C:  MOVLB  0
09A6E:  CALL   2586
.................... 	printf(lcd_putc,"F1:LIGA          \n\r"); 
09A72:  MOVLW  7E
09A74:  MOVWF  FF6
09A76:  MOVLW  03
09A78:  MOVWF  FF7
09A7A:  CALL   25DA
.................... 	printf(lcd_putc,"F1:DESLIGA       \n\r"); 
09A7E:  MOVLW  92
09A80:  MOVWF  FF6
09A82:  MOVLW  03
09A84:  MOVWF  FF7
09A86:  CALL   25DA
.................... 	 
.................... 	while(true){	 
.................... 	key_code = Teclado(); 
09A8A:  CALL   2344
09A8E:  MOVFF  01,193
.................... 	 
.................... 	switch(key_code){ 
09A92:  MOVLB  1
09A94:  MOVF   x93,W
09A96:  XORLW  0A
09A98:  MOVLB  0
09A9A:  BZ    9AA2
09A9C:  XORLW  01
09A9E:  BZ    9AB2
09AA0:  BRA    9ACE
....................  
.................... 	case  F1: 		aciona_saida(LIMPADOR);	 
09AA2:  MOVLB  1
09AA4:  CLRF   xA1
09AA6:  MOVLW  0B
09AA8:  MOVWF  xA0
09AAA:  MOVLB  0
09AAC:  CALL   2FD2
.................... 						break; 
09AB0:  BRA    9ACE
....................  
.................... 	case  F2: 		desaciona_saida(LIMPADOR); 
09AB2:  CLRF   16
09AB4:  BTFSC  FF2.7
09AB6:  BSF    16.7
09AB8:  BCF    FF2.7
09ABA:  MOVLB  2
09ABC:  CLRF   x1B
09ABE:  MOVLW  0B
09AC0:  MOVWF  x1A
09AC2:  MOVLB  0
09AC4:  CALL   1B96
09AC8:  BTFSC  16.7
09ACA:  BSF    FF2.7
.................... 						break; 
09ACC:  BRA    9ACE
....................  
....................  
.................... 	default : 
....................  
.................... 		    break; 
....................  
.................... 	} 
....................  
.................... 			 if(key_code == ESC) break;	 
09ACE:  MOVLB  1
09AD0:  MOVF   x93,W
09AD2:  SUBLW  12
09AD4:  BTFSC  FD8.2
09AD6:  BRA    9ADE
09AD8:  MOVLB  0
09ADA:  BRA    9A8A
09ADC:  MOVLB  1
09ADE:  CLRF   16
09AE0:  BTFSC  FF2.7
09AE2:  BSF    16.7
09AE4:  BCF    FF2.7
....................  } 
.................... 	    desaciona_saida(LIMPADOR); 
09AE6:  MOVLB  2
09AE8:  CLRF   x1B
09AEA:  MOVLW  0B
09AEC:  MOVWF  x1A
09AEE:  MOVLB  0
09AF0:  CALL   1B96
09AF4:  BTFSC  16.7
09AF6:  BSF    FF2.7
.................... 		espera_desacionar_teclas(); 
09AF8:  CALL   7FCA
.................... 		delay_ms(100); 
09AFC:  MOVLW  64
09AFE:  MOVLB  2
09B00:  MOVWF  x17
09B02:  MOVLB  0
09B04:  CALL   1D50
09B08:  GOTO   A844 (RETURN)
....................  
....................   
.................... } 
....................  
.................... void debug_esteira(void) 
*
0A692:  MOVLB  1
0A694:  CLRF   x93
.................... { 
.................... 		int key_code = 0; 
.................... 	printf(lcd_putc,"\f"); 
0A696:  MOVLW  0C
0A698:  MOVWF  xA4
0A69A:  MOVLB  0
0A69C:  CALL   2586
.................... 	printf(lcd_putc,"     ESTEIRA        \n\r"); 
0A6A0:  MOVLW  A6
0A6A2:  MOVWF  FF6
0A6A4:  MOVLW  03
0A6A6:  MOVWF  FF7
0A6A8:  CALL   25DA
.................... 	printf(lcd_putc,"\n\r"); 
0A6AC:  MOVLW  0A
0A6AE:  MOVLB  1
0A6B0:  MOVWF  xA4
0A6B2:  MOVLB  0
0A6B4:  CALL   2586
0A6B8:  MOVLW  0D
0A6BA:  MOVLB  1
0A6BC:  MOVWF  xA4
0A6BE:  MOVLB  0
0A6C0:  CALL   2586
.................... 	printf(lcd_putc,"F1:AVANCA    S_A:OFF\n\r"); 
0A6C4:  MOVLW  BE
0A6C6:  MOVWF  FF6
0A6C8:  MOVLW  03
0A6CA:  MOVWF  FF7
0A6CC:  CALL   25DA
.................... 	printf(lcd_putc,"F2:RECUA            \n\r"); 
0A6D0:  MOVLW  D6
0A6D2:  MOVWF  FF6
0A6D4:  MOVLW  03
0A6D6:  MOVWF  FF7
0A6D8:  CALL   25DA
.................... 	 
.................... 	while(true){	 
.................... 	key_code = Teclado(); 
0A6DC:  CALL   2344
0A6E0:  MOVFF  01,193
.................... 	 
.................... 	switch(key_code){ 
0A6E4:  MOVLB  1
0A6E6:  MOVF   x93,W
0A6E8:  XORLW  0A
0A6EA:  MOVLB  0
0A6EC:  BZ    A6F4
0A6EE:  XORLW  01
0A6F0:  BZ    A704
0A6F2:  BRA    A720
....................  
.................... 	case  F1: 		aciona_saida(RELE_ESTEIRA);	 
0A6F4:  MOVLB  1
0A6F6:  CLRF   xA1
0A6F8:  MOVLW  0A
0A6FA:  MOVWF  xA0
0A6FC:  MOVLB  0
0A6FE:  CALL   2FD2
.................... 						break; 
0A702:  BRA    A720
....................  
.................... 	case  F2: 		desaciona_saida(RELE_ESTEIRA); 
0A704:  CLRF   16
0A706:  BTFSC  FF2.7
0A708:  BSF    16.7
0A70A:  BCF    FF2.7
0A70C:  MOVLB  2
0A70E:  CLRF   x1B
0A710:  MOVLW  0A
0A712:  MOVWF  x1A
0A714:  MOVLB  0
0A716:  CALL   1B96
0A71A:  BTFSC  16.7
0A71C:  BSF    FF2.7
.................... 						break; 
0A71E:  BRA    A720
....................  
....................  
.................... 	default : 
....................  
.................... 		    break; 
....................  
.................... 	} 
.................... 			if(le_Input(S_ESTEIRA) == true) 
0A720:  MOVLW  19
0A722:  MOVLB  1
0A724:  MOVWF  x9C
0A726:  MOVLB  0
0A728:  CALL   2C54
0A72C:  DECFSZ 01,W
0A72E:  BRA    A74E
.................... 			 { 
.................... 				posiciona_cursor(3,18); 
0A730:  MOVLW  03
0A732:  MOVLB  1
0A734:  MOVWF  xA5
0A736:  MOVLW  12
0A738:  MOVWF  xA6
0A73A:  MOVLB  0
0A73C:  CALL   1F92
.................... 				printf(lcd_putc,"ON "); 
0A740:  MOVLW  EE
0A742:  MOVWF  FF6
0A744:  MOVLW  03
0A746:  MOVWF  FF7
0A748:  CALL   25DA
....................  
.................... 			 }else 
0A74C:  BRA    A76A
.................... 				 { 
.................... 					posiciona_cursor(3,18); 
0A74E:  MOVLW  03
0A750:  MOVLB  1
0A752:  MOVWF  xA5
0A754:  MOVLW  12
0A756:  MOVWF  xA6
0A758:  MOVLB  0
0A75A:  CALL   1F92
.................... 					printf(lcd_putc,"OFF"); 
0A75E:  MOVLW  F2
0A760:  MOVWF  FF6
0A762:  MOVLW  03
0A764:  MOVWF  FF7
0A766:  CALL   25DA
....................  
.................... 				 } 
....................  
.................... 			 if(key_code == ESC) break;	 
0A76A:  MOVLB  1
0A76C:  MOVF   x93,W
0A76E:  SUBLW  12
0A770:  BTFSC  FD8.2
0A772:  BRA    A77A
0A774:  MOVLB  0
0A776:  BRA    A6DC
0A778:  MOVLB  1
....................  } 
.................... 	   
.................... 		espera_desacionar_teclas(); 
0A77A:  MOVLB  0
0A77C:  CALL   7FCA
.................... 		delay_ms(100); 
0A780:  MOVLW  64
0A782:  MOVLB  2
0A784:  MOVWF  x17
0A786:  MOVLB  0
0A788:  CALL   1D50
0A78C:  GOTO   A844 (RETURN)
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
....................  
.................... void Debug_Alimentador_Solda(void) 
*
09B0C:  MOVLB  1
09B0E:  CLRF   x93
.................... { 
....................  
.................... 	int key_code = 0; 
.................... 	printf(lcd_putc,"\f"); 
09B10:  MOVLW  0C
09B12:  MOVWF  xA4
09B14:  MOVLB  0
09B16:  CALL   2586
.................... 	printf(lcd_putc," ALIMENTADOR SOLDA  \n\r"); 
09B1A:  MOVLW  F6
09B1C:  MOVWF  FF6
09B1E:  MOVLW  03
09B20:  MOVWF  FF7
09B22:  CALL   25DA
.................... 	printf(lcd_putc,"F1: 1   F3: 3       \n\r"); 
09B26:  MOVLW  0E
09B28:  MOVWF  FF6
09B2A:  MOVLW  04
09B2C:  MOVWF  FF7
09B2E:  CALL   25DA
.................... 	printf(lcd_putc,"F2: 2               \n\r"); 
09B32:  MOVLW  26
09B34:  MOVWF  FF6
09B36:  MOVLW  04
09B38:  MOVWF  FF7
09B3A:  CALL   25DA
.................... 	 
.................... 	while(true){	 
.................... 	key_code = Teclado(); 
09B3E:  CALL   2344
09B42:  MOVFF  01,193
.................... 	 
.................... 	switch(key_code){ 
09B46:  MOVLB  1
09B48:  MOVF   x93,W
09B4A:  XORLW  0A
09B4C:  MOVLB  0
09B4E:  BZ    9B5A
09B50:  XORLW  01
09B52:  BZ    9BA8
09B54:  XORLW  07
09B56:  BZ    9BF6
09B58:  BRA    9C44
....................  
....................  
....................  
.................... 	case  F1:    
.................... 				 while(Teclado() == F1 ) 	 
09B5A:  CALL   2344
09B5E:  MOVF   01,W
09B60:  SUBLW  0A
09B62:  BNZ   9B74
.................... 				{ 
....................  
....................  
.................... 	    			 aciona_saida(ALIMENTADOR1); 
09B64:  MOVLB  1
09B66:  CLRF   xA1
09B68:  MOVLW  0E
09B6A:  MOVWF  xA0
09B6C:  MOVLB  0
09B6E:  CALL   2FD2
09B72:  BRA    9B5A
....................  
....................  
.................... 				}  
.................... 			 
.................... 	 			while(Teclado() != 0Xff){} 
09B74:  CALL   2344
09B78:  INCFSZ 01,W
09B7A:  BRA    9B7E
09B7C:  BRA    9B80
09B7E:  BRA    9B74
.................... 				delay_ms(50); 
09B80:  MOVLW  32
09B82:  MOVLB  2
09B84:  MOVWF  x17
09B86:  MOVLB  0
09B88:  CALL   1D50
09B8C:  CLRF   16
09B8E:  BTFSC  FF2.7
09B90:  BSF    16.7
09B92:  BCF    FF2.7
....................      			desaciona_saida(ALIMENTADOR1); 
09B94:  MOVLB  2
09B96:  CLRF   x1B
09B98:  MOVLW  0E
09B9A:  MOVWF  x1A
09B9C:  MOVLB  0
09B9E:  CALL   1B96
09BA2:  BTFSC  16.7
09BA4:  BSF    FF2.7
....................  
.................... 				break; 
09BA6:  BRA    9C44
....................  
.................... 	case  F2:    
.................... 				while(Teclado() == F2 ) 	 
09BA8:  CALL   2344
09BAC:  MOVF   01,W
09BAE:  SUBLW  0B
09BB0:  BNZ   9BC2
.................... 				{ 
....................  
....................  
.................... 	    			 aciona_saida(ALIMENTADOR2); 
09BB2:  MOVLB  1
09BB4:  CLRF   xA1
09BB6:  MOVLW  0D
09BB8:  MOVWF  xA0
09BBA:  MOVLB  0
09BBC:  CALL   2FD2
09BC0:  BRA    9BA8
....................  
....................  
.................... 				}  
.................... 			 
.................... 	 			while(Teclado() != 0Xff){} 
09BC2:  CALL   2344
09BC6:  INCFSZ 01,W
09BC8:  BRA    9BCC
09BCA:  BRA    9BCE
09BCC:  BRA    9BC2
.................... 				delay_ms(50); 
09BCE:  MOVLW  32
09BD0:  MOVLB  2
09BD2:  MOVWF  x17
09BD4:  MOVLB  0
09BD6:  CALL   1D50
09BDA:  CLRF   16
09BDC:  BTFSC  FF2.7
09BDE:  BSF    16.7
09BE0:  BCF    FF2.7
....................      			desaciona_saida(ALIMENTADOR2); 
09BE2:  MOVLB  2
09BE4:  CLRF   x1B
09BE6:  MOVLW  0D
09BE8:  MOVWF  x1A
09BEA:  MOVLB  0
09BEC:  CALL   1B96
09BF0:  BTFSC  16.7
09BF2:  BSF    FF2.7
....................  
.................... 				break; 
09BF4:  BRA    9C44
....................  
.................... 	case  F3:    
.................... 				while(Teclado() == F3 ) 	 
09BF6:  CALL   2344
09BFA:  MOVF   01,W
09BFC:  SUBLW  0C
09BFE:  BNZ   9C10
.................... 				{ 
....................  
....................  
.................... 	    			 aciona_saida(ALIMENTADOR3); 
09C00:  MOVLB  1
09C02:  CLRF   xA1
09C04:  MOVLW  0C
09C06:  MOVWF  xA0
09C08:  MOVLB  0
09C0A:  CALL   2FD2
09C0E:  BRA    9BF6
....................  
....................  
.................... 				}  
.................... 			 
.................... 	 			while(Teclado() != 0Xff){} 
09C10:  CALL   2344
09C14:  INCFSZ 01,W
09C16:  BRA    9C1A
09C18:  BRA    9C1C
09C1A:  BRA    9C10
.................... 				delay_ms(50); 
09C1C:  MOVLW  32
09C1E:  MOVLB  2
09C20:  MOVWF  x17
09C22:  MOVLB  0
09C24:  CALL   1D50
09C28:  CLRF   16
09C2A:  BTFSC  FF2.7
09C2C:  BSF    16.7
09C2E:  BCF    FF2.7
....................      			desaciona_saida(ALIMENTADOR3); 
09C30:  MOVLB  2
09C32:  CLRF   x1B
09C34:  MOVLW  0C
09C36:  MOVWF  x1A
09C38:  MOVLB  0
09C3A:  CALL   1B96
09C3E:  BTFSC  16.7
09C40:  BSF    FF2.7
....................  
.................... 				break; 
09C42:  BRA    9C44
....................  
....................  	 
.................... 	default : 
....................  
.................... 		    break; 
....................  
.................... 	} 
....................  
.................... 			 if(key_code == ESC) break;	 
09C44:  MOVLB  1
09C46:  MOVF   x93,W
09C48:  SUBLW  12
09C4A:  BTFSC  FD8.2
09C4C:  BRA    9C54
09C4E:  MOVLB  0
09C50:  BRA    9B3E
09C52:  MOVLB  1
....................  } 
....................  
.................... 		espera_desacionar_teclas(); 
09C54:  MOVLB  0
09C56:  CALL   7FCA
.................... 		delay_ms(100); 
09C5A:  MOVLW  64
09C5C:  MOVLB  2
09C5E:  MOVWF  x17
09C60:  MOVLB  0
09C62:  CALL   1D50
09C66:  GOTO   A844 (RETURN)
....................  
....................  
.................... }  
....................  
.................... void Debug_Ferro_Solda_1(void) 
09C6A:  MOVLB  1
09C6C:  CLRF   x93
.................... { 
....................  
.................... 	int key_code = 0; 
.................... 	printf(lcd_putc,"\f"); 
09C6E:  MOVLW  0C
09C70:  MOVWF  xA4
09C72:  MOVLB  0
09C74:  CALL   2586
.................... 	printf(lcd_putc,"  FERRO SOLDA 1   \n\r"); 
09C78:  MOVLW  3E
09C7A:  MOVWF  FF6
09C7C:  MOVLW  04
09C7E:  MOVWF  FF7
09C80:  CALL   25DA
.................... 	printf(lcd_putc,"\n\r"); 
09C84:  MOVLW  0A
09C86:  MOVLB  1
09C88:  MOVWF  xA4
09C8A:  MOVLB  0
09C8C:  CALL   2586
09C90:  MOVLW  0D
09C92:  MOVLB  1
09C94:  MOVWF  xA4
09C96:  MOVLB  0
09C98:  CALL   2586
.................... 	printf(lcd_putc,"F1:AVANCA    S_A:OFF\n\r"); 
09C9C:  MOVLW  54
09C9E:  MOVWF  FF6
09CA0:  MOVLW  04
09CA2:  MOVWF  FF7
09CA4:  CALL   25DA
.................... 	printf(lcd_putc,"F2:RECUA     S_R:OFF\n\r"); 
09CA8:  MOVLW  6C
09CAA:  MOVWF  FF6
09CAC:  MOVLW  04
09CAE:  MOVWF  FF7
09CB0:  CALL   25DA
.................... 	 
.................... 	while(true){	 
.................... 	key_code = Teclado(); 
09CB4:  CALL   2344
09CB8:  MOVFF  01,193
.................... 	 
.................... 	switch(key_code){ 
09CBC:  MOVLB  1
09CBE:  MOVF   x93,W
09CC0:  XORLW  0A
09CC2:  MOVLB  0
09CC4:  BZ    9CCC
09CC6:  XORLW  01
09CC8:  BZ    9CDC
09CCA:  BRA    9CF8
....................  
.................... 	case  F1: 			aciona_saida(FERRO_SOLDA1); 
09CCC:  MOVLB  1
09CCE:  CLRF   xA1
09CD0:  MOVLW  03
09CD2:  MOVWF  xA0
09CD4:  MOVLB  0
09CD6:  CALL   2FD2
.................... 						break; 
09CDA:  BRA    9CF8
....................  
.................... 	case  F2: 			desaciona_saida(FERRO_SOLDA1); 
09CDC:  CLRF   16
09CDE:  BTFSC  FF2.7
09CE0:  BSF    16.7
09CE2:  BCF    FF2.7
09CE4:  MOVLB  2
09CE6:  CLRF   x1B
09CE8:  MOVLW  03
09CEA:  MOVWF  x1A
09CEC:  MOVLB  0
09CEE:  CALL   1B96
09CF2:  BTFSC  16.7
09CF4:  BSF    FF2.7
.................... 						break; 
09CF6:  BRA    9CF8
....................  
....................  
.................... 	default : 
....................  
.................... 		    break; 
....................  
.................... 	} 
....................  
.................... 		 
.................... 		 if(le_Input(S_FERRO_SOLDA1) == true) 
09CF8:  MOVLW  0C
09CFA:  MOVLB  1
09CFC:  MOVWF  x9C
09CFE:  MOVLB  0
09D00:  CALL   2C54
09D04:  DECFSZ 01,W
09D06:  BRA    9D26
.................... 			 { 
.................... 				posiciona_cursor(3,18); 
09D08:  MOVLW  03
09D0A:  MOVLB  1
09D0C:  MOVWF  xA5
09D0E:  MOVLW  12
09D10:  MOVWF  xA6
09D12:  MOVLB  0
09D14:  CALL   1F92
.................... 				printf(lcd_putc,"ON "); 
09D18:  MOVLW  84
09D1A:  MOVWF  FF6
09D1C:  MOVLW  04
09D1E:  MOVWF  FF7
09D20:  CALL   25DA
....................  
.................... 			 }else 
09D24:  BRA    9D42
.................... 				 { 
.................... 					posiciona_cursor(3,18); 
09D26:  MOVLW  03
09D28:  MOVLB  1
09D2A:  MOVWF  xA5
09D2C:  MOVLW  12
09D2E:  MOVWF  xA6
09D30:  MOVLB  0
09D32:  CALL   1F92
.................... 					printf(lcd_putc,"OFF"); 
09D36:  MOVLW  88
09D38:  MOVWF  FF6
09D3A:  MOVLW  04
09D3C:  MOVWF  FF7
09D3E:  CALL   25DA
....................  
.................... 				 } 
....................  
....................  
.................... 	  
....................  
.................... 			 if(key_code == ESC) break;	 
09D42:  MOVLB  1
09D44:  MOVF   x93,W
09D46:  SUBLW  12
09D48:  BTFSC  FD8.2
09D4A:  BRA    9D52
09D4C:  MOVLB  0
09D4E:  BRA    9CB4
09D50:  MOVLB  1
....................  } 
....................         //desaciona_saida(FERRO_SOLDA1); 
.................... 		espera_desacionar_teclas(); 
09D52:  MOVLB  0
09D54:  CALL   7FCA
.................... 		delay_ms(100); 
09D58:  MOVLW  64
09D5A:  MOVLB  2
09D5C:  MOVWF  x17
09D5E:  MOVLB  0
09D60:  CALL   1D50
09D64:  GOTO   A844 (RETURN)
....................  
....................  
.................... } 
....................  
....................  
.................... void Debug_Ferro_Solda_2(void) 
09D68:  MOVLB  1
09D6A:  CLRF   x93
.................... { 
....................  
.................... 	int key_code = 0; 
.................... 	printf(lcd_putc,"\f"); 
09D6C:  MOVLW  0C
09D6E:  MOVWF  xA4
09D70:  MOVLB  0
09D72:  CALL   2586
.................... 	printf(lcd_putc,"  FERRO SOLDA 2   \n\r"); 
09D76:  MOVLW  8C
09D78:  MOVWF  FF6
09D7A:  MOVLW  04
09D7C:  MOVWF  FF7
09D7E:  CALL   25DA
.................... 	printf(lcd_putc,"\n\r"); 
09D82:  MOVLW  0A
09D84:  MOVLB  1
09D86:  MOVWF  xA4
09D88:  MOVLB  0
09D8A:  CALL   2586
09D8E:  MOVLW  0D
09D90:  MOVLB  1
09D92:  MOVWF  xA4
09D94:  MOVLB  0
09D96:  CALL   2586
.................... 	printf(lcd_putc,"F1:AVANCA    S_A:OFF\n\r"); 
09D9A:  MOVLW  A2
09D9C:  MOVWF  FF6
09D9E:  MOVLW  04
09DA0:  MOVWF  FF7
09DA2:  CALL   25DA
.................... 	printf(lcd_putc,"F2:RECUA     S_R:OFF\n\r"); 
09DA6:  MOVLW  BA
09DA8:  MOVWF  FF6
09DAA:  MOVLW  04
09DAC:  MOVWF  FF7
09DAE:  CALL   25DA
.................... 	 
.................... 	while(true){	 
.................... 	key_code = Teclado(); 
09DB2:  CALL   2344
09DB6:  MOVFF  01,193
.................... 	 
.................... 	switch(key_code){ 
09DBA:  MOVLB  1
09DBC:  MOVF   x93,W
09DBE:  XORLW  0A
09DC0:  MOVLB  0
09DC2:  BZ    9DCA
09DC4:  XORLW  01
09DC6:  BZ    9DDA
09DC8:  BRA    9DF6
....................  
.................... 	case  F1: 			aciona_saida(FERRO_SOLDA2); 
09DCA:  MOVLB  1
09DCC:  CLRF   xA1
09DCE:  MOVLW  02
09DD0:  MOVWF  xA0
09DD2:  MOVLB  0
09DD4:  CALL   2FD2
.................... 						break; 
09DD8:  BRA    9DF6
....................  
.................... 	case  F2: 			desaciona_saida(FERRO_SOLDA2); 
09DDA:  CLRF   16
09DDC:  BTFSC  FF2.7
09DDE:  BSF    16.7
09DE0:  BCF    FF2.7
09DE2:  MOVLB  2
09DE4:  CLRF   x1B
09DE6:  MOVLW  02
09DE8:  MOVWF  x1A
09DEA:  MOVLB  0
09DEC:  CALL   1B96
09DF0:  BTFSC  16.7
09DF2:  BSF    FF2.7
.................... 						break; 
09DF4:  BRA    9DF6
....................  
....................  
.................... 	default : 
....................  
.................... 		    break; 
....................  
.................... 	} 
....................  
.................... 		 
.................... 		 if(le_Input(S_FERRO_SOLDA2) == true) 
09DF6:  MOVLW  0F
09DF8:  MOVLB  1
09DFA:  MOVWF  x9C
09DFC:  MOVLB  0
09DFE:  CALL   2C54
09E02:  DECFSZ 01,W
09E04:  BRA    9E24
.................... 			 { 
.................... 				posiciona_cursor(3,18); 
09E06:  MOVLW  03
09E08:  MOVLB  1
09E0A:  MOVWF  xA5
09E0C:  MOVLW  12
09E0E:  MOVWF  xA6
09E10:  MOVLB  0
09E12:  CALL   1F92
.................... 				printf(lcd_putc,"ON "); 
09E16:  MOVLW  D2
09E18:  MOVWF  FF6
09E1A:  MOVLW  04
09E1C:  MOVWF  FF7
09E1E:  CALL   25DA
....................  
.................... 			 }else 
09E22:  BRA    9E40
.................... 				 { 
.................... 					posiciona_cursor(3,18); 
09E24:  MOVLW  03
09E26:  MOVLB  1
09E28:  MOVWF  xA5
09E2A:  MOVLW  12
09E2C:  MOVWF  xA6
09E2E:  MOVLB  0
09E30:  CALL   1F92
.................... 					printf(lcd_putc,"OFF"); 
09E34:  MOVLW  D6
09E36:  MOVWF  FF6
09E38:  MOVLW  04
09E3A:  MOVWF  FF7
09E3C:  CALL   25DA
....................  
.................... 				 } 
....................  
....................  
.................... 	  
....................  
.................... 			 if(key_code == ESC) break;	 
09E40:  MOVLB  1
09E42:  MOVF   x93,W
09E44:  SUBLW  12
09E46:  BTFSC  FD8.2
09E48:  BRA    9E50
09E4A:  MOVLB  0
09E4C:  BRA    9DB2
09E4E:  MOVLB  1
....................  } 
....................         //desaciona_saida(FERRO_SOLDA2); 
.................... 		espera_desacionar_teclas(); 
09E50:  MOVLB  0
09E52:  CALL   7FCA
.................... 		delay_ms(100); 
09E56:  MOVLW  64
09E58:  MOVLB  2
09E5A:  MOVWF  x17
09E5C:  MOVLB  0
09E5E:  CALL   1D50
09E62:  GOTO   A844 (RETURN)
....................  
....................  
.................... } 
....................  
....................  
....................  
.................... void Show_Sensor(numero) 
.................... { 
.................... 	switch(numero){ 
....................  
.................... 				 
.................... 	case 0:	printf(lcd_putc,"S_DEDO_IN_LS1 	     "); 
.................... 			break; 
....................  
.................... 	case 1:printf(lcd_putc,"S_DEDO_IN_LS2 	     ");	 
.................... 			break; 
....................  
.................... 	case 2:printf(lcd_putc,"S_EMPURRADOR_IN_LS1	 ");	 
....................  
.................... 			break; 
.................... 	case 3:printf(lcd_putc,"S_EMPURRADOR_IN_LS2  ");		 
....................  
.................... 			break;				 
.................... 	case 4:printf(lcd_putc,"S_PRESSOR_LS1    	 ");		 
....................  
.................... 			break; 
.................... 	case 5:printf(lcd_putc," S_X_DIREITA    	 ");		 
....................  
.................... 			break; 
.................... 	case 6:printf(lcd_putc,"S_X_ESQUERDA       	 ");	 
....................  
.................... 			break; 
.................... 	case 7:printf(lcd_putc,"S_Y_FRENTE        	 ");		 
....................  
.................... 			break;				 
.................... 	case 8:printf(lcd_putc,"S_Y_ATRAS       	 ");		 
....................  
.................... 			break; 
.................... 	case 9:printf(lcd_putc,"PROTECAO1	     	 ");		 
....................  
.................... 			break; 
.................... 	case 10:printf(lcd_putc,"PROTECAO1      	 ");	 
....................  
.................... 			break; 
.................... 	case 11:printf(lcd_putc,"S_ROTACAO_LS1     	 ");		 
....................  
.................... 			break;				 
.................... 	case 12:printf(lcd_putc,"S_FERRO_SOLDA1   	 ");		 
....................  
.................... 			break; 
.................... 	case 13:printf(lcd_putc,"S_Z_TOP        	 ");		 
....................  
.................... 			break; 
.................... 	case 14:printf(lcd_putc,"S_Z_BOTTOM        	 ");	 
....................  
.................... 			break; 
.................... 			 
....................     case 15:printf(lcd_putc,"S_FERRO_SOLDA2  	 ");	 
....................  
.................... 			break; 
.................... 	case 16:printf(lcd_putc,"S_DEDO_OUT_1        ");		 
....................  
.................... 			break;				 
.................... 	case 17:printf(lcd_putc,"S_DEDO_OUT_2	     ");		 
....................  
.................... 			break; 
.................... 	case 18:printf(lcd_putc,"S_EMPURRADOR_OUT_LS1");		 
....................  
.................... 			break; 
.................... 	case 19:printf(lcd_putc,"S_EMPURRADOR_OUT_LS2");	 
....................  
.................... 			break; 
.................... 	case 20:printf(lcd_putc," S_X_CENTRO       	 ");		 
....................  
.................... 			break;				 
.................... 	case 21:printf(lcd_putc," S_Y_CENTRO         ");		 
....................  
.................... 			break; 
.................... 	case 22:printf(lcd_putc," S_FIO_SOLDA1       ");		 
....................  
.................... 			break; 
.................... 	case 23:printf(lcd_putc," S_FIO_SOLDA2	     ");	 
....................  
.................... 			break; 
.................... 	case 24:printf(lcd_putc," S_FIO_SOLDA3       ");		 
....................  
.................... 			break;				 
.................... 	case 25://printf(lcd_putc,"	");		 
....................  
.................... 			break; 
.................... 	case 26://printf(lcd_putc," 	");		 
....................  
.................... 			break; 
.................... 	default: 
....................  
.................... 			break;      
....................  
....................  }  
....................  
....................  
.................... } 
....................  
.................... void Debug_Sensores(void) 
*
09EB0:  MOVLB  1
09EB2:  CLRF   x93
09EB4:  CLRF   x95
09EB6:  CLRF   x94
09EB8:  CLRF   x96
.................... {    
.................... 	int key_code = 0; 
.................... 	unsigned long int data_sensores = 0x0000; 
....................     int data_sensores2 = 0x00; 
.................... 	printf(lcd_putc,"\f"); 
09EBA:  MOVLW  0C
09EBC:  MOVWF  xA4
09EBE:  MOVLB  0
09EC0:  CALL   2586
.................... 	printf(lcd_putc,"  DEBUG SENSORES\n\r"); 
09EC4:  MOVLW  E6
09EC6:  MOVWF  FF6
09EC8:  MOVLW  06
09ECA:  MOVWF  FF7
09ECC:  CALL   25DA
....................  
.................... 	while(true) 
.................... 	{	  
.................... 		 key_code = Teclado(); 
09ED0:  CALL   2344
09ED4:  MOVFF  01,193
.................... 		 posiciona_cursor(2,5); 
09ED8:  MOVLW  02
09EDA:  MOVLB  1
09EDC:  MOVWF  xA5
09EDE:  MOVLW  05
09EE0:  MOVWF  xA6
09EE2:  MOVLB  0
09EE4:  CALL   1F92
.................... 		 data_sensores = le_PCA9555(0X03,0X00); 
09EE8:  MOVLW  03
09EEA:  MOVLB  1
09EEC:  MOVWF  xA5
09EEE:  CLRF   xA6
09EF0:  MOVLB  0
09EF2:  CALL   21FE
09EF6:  MOVFF  02,195
09EFA:  MOVFF  01,194
....................          printf(lcd_putc,"%LX",data_sensores); 
09EFE:  MOVFF  195,19B
09F02:  MOVLW  37
09F04:  MOVLB  1
09F06:  MOVWF  x9C
09F08:  MOVLB  0
09F0A:  RCALL  9E66
09F0C:  MOVFF  194,19B
09F10:  MOVLW  37
09F12:  MOVLB  1
09F14:  MOVWF  x9C
09F16:  MOVLB  0
09F18:  RCALL  9E66
.................... 		 data_sensores2 = le_pcf8574A(0x04); 
09F1A:  MOVLW  04
09F1C:  MOVLB  1
09F1E:  MOVWF  xA1
09F20:  MOVLB  0
09F22:  CALL   2C12
09F26:  MOVFF  01,196
.................... 		 posiciona_cursor(3,5); 
09F2A:  MOVLW  03
09F2C:  MOVLB  1
09F2E:  MOVWF  xA5
09F30:  MOVLW  05
09F32:  MOVWF  xA6
09F34:  MOVLB  0
09F36:  CALL   1F92
.................... 	     printf(lcd_putc,"%X",data_sensores2); 
09F3A:  MOVFF  196,19B
09F3E:  MOVLW  37
09F40:  MOVLB  1
09F42:  MOVWF  x9C
09F44:  MOVLB  0
09F46:  RCALL  9E66
.................... 		 delay_ms(10); 
09F48:  MOVLW  0A
09F4A:  MOVLB  2
09F4C:  MOVWF  x17
09F4E:  MOVLB  0
09F50:  CALL   1D50
.................... 		 if(key_code == ESC) break; 
09F54:  MOVLB  1
09F56:  MOVF   x93,W
09F58:  SUBLW  12
09F5A:  BTFSC  FD8.2
09F5C:  BRA    9F64
09F5E:  MOVLB  0
09F60:  BRA    9ED0
09F62:  MOVLB  1
.................... 	     //printf(lcd_putc 
.................... 	 
.................... 	} 
....................  
.................... 	espera_desacionar_teclas(); 
09F64:  MOVLB  0
09F66:  CALL   7FCA
.................... 	delay_ms(100); 
09F6A:  MOVLW  64
09F6C:  MOVLB  2
09F6E:  MOVWF  x17
09F70:  MOVLB  0
09F72:  CALL   1D50
09F76:  GOTO   A844 (RETURN)
....................  
....................   
....................  
.................... } 
....................  
.................... void Debug_saidas(void) 
09F7A:  MOVLB  1
09F7C:  CLRF   x93
09F7E:  CLRF   x95
09F80:  CLRF   x94
.................... { 
....................  
.................... 	int key_code = 0; 
.................... 	unsigned long int data_sensores = 0x0000; 
.................... 	int valor_lsb; 
....................     int valor_msb; 
.................... 	int n_bit1; 
....................     int n_bit2; 
....................     int value; 
....................  
.................... 	printf(lcd_putc,"\f"); 
09F82:  MOVLW  0C
09F84:  MOVWF  xA4
09F86:  MOVLB  0
09F88:  CALL   2586
.................... 	printf(lcd_putc,"  DEBUG SAIDAS\n\r"); 
09F8C:  MOVLW  FA
09F8E:  MOVWF  FF6
09F90:  MOVLW  06
09F92:  MOVWF  FF7
09F94:  CALL   25DA
....................  
.................... 	while(true) 
.................... 	{ 
.................... 	 	 key_code = Teclado(); 
09F98:  CALL   2344
09F9C:  MOVFF  01,193
.................... 		 posiciona_cursor(2,5); 
09FA0:  MOVLW  02
09FA2:  MOVLB  1
09FA4:  MOVWF  xA5
09FA6:  MOVLW  05
09FA8:  MOVWF  xA6
09FAA:  MOVLB  0
09FAC:  CALL   1F92
.................... 		 data_sensores =  le_PCA9555(0X03,0X00); 
09FB0:  MOVLW  03
09FB2:  MOVLB  1
09FB4:  MOVWF  xA5
09FB6:  CLRF   xA6
09FB8:  MOVLB  0
09FBA:  CALL   21FE
09FBE:  MOVFF  02,195
09FC2:  MOVFF  01,194
.................... 	     printf(lcd_putc,"%LX",data_sensores); 
09FC6:  MOVFF  195,19B
09FCA:  MOVLW  37
09FCC:  MOVLB  1
09FCE:  MOVWF  x9C
09FD0:  MOVLB  0
09FD2:  RCALL  9E66
09FD4:  MOVFF  194,19B
09FD8:  MOVLW  37
09FDA:  MOVLB  1
09FDC:  MOVWF  x9C
09FDE:  MOVLB  0
09FE0:  RCALL  9E66
....................      	 valor_lsb = make8(data_sensores,0);   
09FE2:  MOVLB  1
09FE4:  MOVFF  194,196
.................... 	     valor_msb = make8(data_sensores,1); 
09FE8:  MOVFF  195,197
.................... 		 n_bit2 = 7; 
09FEC:  MOVLW  07
09FEE:  MOVWF  x99
....................  
.................... 		 for(n_bit1 = 0; n_bit1 < 8 ; n_bit1++) 
09FF0:  CLRF   x98
09FF2:  MOVF   x98,W
09FF4:  SUBLW  07
09FF6:  BNC   A046
.................... 		 { 
....................  
.................... 			 if((bit_test (valor_lsb,n_bit1)) == 1) 
09FF8:  MOVFF  196,00
09FFC:  MOVF   x98,W
09FFE:  MOVWF  01
0A000:  BZ    A00A
0A002:  BCF    FD8.0
0A004:  RRCF   00,F
0A006:  DECFSZ 01,F
0A008:  BRA    A002
0A00A:  BTFSS  00.0
0A00C:  BRA    A028
.................... 			 { 
.................... 				bit_set(value,n_bit2); 
0A00E:  MOVLW  01
0A010:  MOVWF  00
0A012:  MOVF   x99,W
0A014:  MOVWF  01
0A016:  BZ    A020
0A018:  BCF    FD8.0
0A01A:  RLCF   00,F
0A01C:  DECFSZ 01,F
0A01E:  BRA    A018
0A020:  MOVF   00,W
0A022:  IORWF  x9A,F
....................                 n_bit2--; 
0A024:  DECF   x99,F
....................  
.................... 			 }else { 
0A026:  BRA    A042
.................... 					 bit_clear(value,n_bit2); 
0A028:  MOVLW  01
0A02A:  MOVWF  00
0A02C:  MOVF   x99,W
0A02E:  MOVWF  01
0A030:  BZ    A03A
0A032:  BCF    FD8.0
0A034:  RLCF   00,F
0A036:  DECFSZ 01,F
0A038:  BRA    A032
0A03A:  MOVF   00,W
0A03C:  XORLW  FF
0A03E:  ANDWF  x9A,F
....................                      n_bit2--; 
0A040:  DECF   x99,F
.................... 			       }  
0A042:  INCF   x98,F
0A044:  BRA    9FF2
....................       
.................... 		  
.................... 		 } 
....................  
....................  
.................... 		valor_lsb = value; 
0A046:  MOVFF  19A,196
....................  
.................... 		 n_bit2 = 7; 
0A04A:  MOVLW  07
0A04C:  MOVWF  x99
.................... 		 for(n_bit1 = 0; n_bit1 < 8 ; n_bit1++) 
0A04E:  CLRF   x98
0A050:  MOVF   x98,W
0A052:  SUBLW  07
0A054:  BNC   A0A4
.................... 		 { 
....................  
.................... 			 if((bit_test (valor_msb,n_bit1)) == 1) 
0A056:  MOVFF  197,00
0A05A:  MOVF   x98,W
0A05C:  MOVWF  01
0A05E:  BZ    A068
0A060:  BCF    FD8.0
0A062:  RRCF   00,F
0A064:  DECFSZ 01,F
0A066:  BRA    A060
0A068:  BTFSS  00.0
0A06A:  BRA    A086
.................... 			 { 
.................... 				bit_set(value,n_bit2); 
0A06C:  MOVLW  01
0A06E:  MOVWF  00
0A070:  MOVF   x99,W
0A072:  MOVWF  01
0A074:  BZ    A07E
0A076:  BCF    FD8.0
0A078:  RLCF   00,F
0A07A:  DECFSZ 01,F
0A07C:  BRA    A076
0A07E:  MOVF   00,W
0A080:  IORWF  x9A,F
....................                 n_bit2--; 
0A082:  DECF   x99,F
....................  
.................... 			 }else { 
0A084:  BRA    A0A0
.................... 					 bit_clear(value,n_bit2); 
0A086:  MOVLW  01
0A088:  MOVWF  00
0A08A:  MOVF   x99,W
0A08C:  MOVWF  01
0A08E:  BZ    A098
0A090:  BCF    FD8.0
0A092:  RLCF   00,F
0A094:  DECFSZ 01,F
0A096:  BRA    A090
0A098:  MOVF   00,W
0A09A:  XORLW  FF
0A09C:  ANDWF  x9A,F
....................                      n_bit2--; 
0A09E:  DECF   x99,F
.................... 			       }  
0A0A0:  INCF   x98,F
0A0A2:  BRA    A050
....................       	 
....................  
.................... 		 } 
....................  
.................... 	     valor_msb = value; 
0A0A4:  MOVFF  19A,197
0A0A8:  CLRF   16
0A0AA:  BTFSC  FF2.7
0A0AC:  BSF    16.7
0A0AE:  BCF    FF2.7
....................   
.................... 	     escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
0A0B0:  MOVLW  02
0A0B2:  MOVLB  2
0A0B4:  MOVWF  x1E
0A0B6:  MOVWF  x1F
0A0B8:  MOVFF  197,220
0A0BC:  MOVFF  196,221
0A0C0:  MOVLB  0
0A0C2:  CALL   1B44
0A0C6:  BTFSC  16.7
0A0C8:  BSF    FF2.7
.................... 			 
....................  
.................... 		 delay_ms(10); 
0A0CA:  MOVLW  0A
0A0CC:  MOVLB  2
0A0CE:  MOVWF  x17
0A0D0:  MOVLB  0
0A0D2:  CALL   1D50
.................... 		 if(key_code == ESC) break; 
0A0D6:  MOVLB  1
0A0D8:  MOVF   x93,W
0A0DA:  SUBLW  12
0A0DC:  BTFSC  FD8.2
0A0DE:  BRA    A0E6
0A0E0:  MOVLB  0
0A0E2:  BRA    9F98
0A0E4:  MOVLB  1
.................... 	 
.................... 	} 
....................  
.................... 	espera_desacionar_teclas(); 
0A0E6:  MOVLB  0
0A0E8:  CALL   7FCA
.................... 	delay_ms(100); 
0A0EC:  MOVLW  64
0A0EE:  MOVLB  2
0A0F0:  MOVWF  x17
0A0F2:  MOVLB  0
0A0F4:  CALL   1D50
0A0F8:  GOTO   A844 (RETURN)
....................  
....................  
.................... } 
....................  
.................... void Debug_posicoes_outra_maquina(void) 
0A0FC:  MOVLB  1
0A0FE:  CLRF   x93
.................... { 
....................     int  dado = 0; 
....................     int  key_code; 
....................  
.................... 	printf(lcd_putc,"\f"); 
0A100:  MOVLW  0C
0A102:  MOVWF  xA4
0A104:  MOVLB  0
0A106:  CALL   2586
.................... 	printf(lcd_putc,"POSICOES MAQUINA\n\r"); 
0A10A:  MOVLW  0C
0A10C:  MOVWF  FF6
0A10E:  MOVLW  07
0A110:  MOVWF  FF7
0A112:  CALL   25DA
....................     printf(lcd_putc,"                \n\r"); 
0A116:  MOVLW  20
0A118:  MOVWF  FF6
0A11A:  MOVLW  07
0A11C:  MOVWF  FF7
0A11E:  CALL   25DA
....................  
.................... 	while(true) 
.................... 	{ 
....................  
.................... 		key_code = Teclado(); 
0A122:  CALL   2344
0A126:  MOVFF  01,194
....................  
....................  
....................     	if(n_maquina == 1) 
0A12A:  DECFSZ 1D,W
0A12C:  BRA    A138
.................... 		{ 
.................... 	 
.................... 			dado=le_posicao_da_maquina2(); 
0A12E:  CALL   363A
0A132:  MOVFF  01,193
....................  
....................  
.................... 		}else{ 
0A136:  BRA    A140
....................  
....................  
.................... 			dado=le_posicao_da_maquina1(); 
0A138:  CALL   7C1C
0A13C:  MOVFF  01,193
....................  
....................  
....................  
.................... 			 } 
.................... 	 
.................... 		 	 posiciona_cursor(3,1); 
0A140:  MOVLW  03
0A142:  MOVLB  1
0A144:  MOVWF  xA5
0A146:  MOVLW  01
0A148:  MOVWF  xA6
0A14A:  MOVLB  0
0A14C:  CALL   1F92
.................... 	 		//printf(lcd_putc,"%X",dado); 
.................... 			//posiciona_cursor(4,1); 
....................  
.................... 	switch(dado){ 
0A150:  MOVLB  1
0A152:  MOVF   x93,W
0A154:  XORLW  00
0A156:  MOVLB  0
0A158:  BZ    A178
0A15A:  XORLW  01
0A15C:  BZ    A192
0A15E:  XORLW  03
0A160:  BZ    A1AC
0A162:  XORLW  01
0A164:  BZ    A1C6
0A166:  XORLW  07
0A168:  BZ    A1E0
0A16A:  XORLW  01
0A16C:  BZ    A1FA
0A16E:  XORLW  03
0A170:  BZ    A214
0A172:  XORLW  01
0A174:  BZ    A22E
0A176:  BRA    A248
....................  
.................... 		case(POSICAO_HOME1):		  printf(lcd_putc,"POSICAO HOME1      \n\r"); 
0A178:  MOVLW  34
0A17A:  MOVWF  FF6
0A17C:  MOVLW  07
0A17E:  MOVWF  FF7
0A180:  CALL   25DA
.................... 									  printf(lcd_putc,"                   \n\r");	 
0A184:  MOVLW  4A
0A186:  MOVWF  FF6
0A188:  MOVLW  07
0A18A:  MOVWF  FF7
0A18C:  CALL   25DA
.................... 							    	  break; 
0A190:  BRA    A248
....................  
.................... 		case(POSICAO_HOME2):    	  printf(lcd_putc,"POSICAO HOME2      \n\r"); 
0A192:  MOVLW  60
0A194:  MOVWF  FF6
0A196:  MOVLW  07
0A198:  MOVWF  FF7
0A19A:  CALL   25DA
....................   									  printf(lcd_putc,"                   \n\r");	 
0A19E:  MOVLW  76
0A1A0:  MOVWF  FF6
0A1A2:  MOVLW  07
0A1A4:  MOVWF  FF7
0A1A6:  CALL   25DA
.................... 							   		  break;  
0A1AA:  BRA    A248
....................    
.................... 		case(POSICAO_ALIMENTADOR):	  printf(lcd_putc,"POSICAO ALIMENTADOR\n\r"); 
0A1AC:  MOVLW  8C
0A1AE:  MOVWF  FF6
0A1B0:  MOVLW  07
0A1B2:  MOVWF  FF7
0A1B4:  CALL   25DA
....................  									  printf(lcd_putc,"                   \n\r"); 
0A1B8:  MOVLW  A2
0A1BA:  MOVWF  FF6
0A1BC:  MOVLW  07
0A1BE:  MOVWF  FF7
0A1C0:  CALL   25DA
.................... 									  break; 
0A1C4:  BRA    A248
....................     
.................... 		case(POSICAO_SOLDA_ESTAGIO1): printf(lcd_putc,"POSICAO SOLDA      \n\r"); 
0A1C6:  MOVLW  B8
0A1C8:  MOVWF  FF6
0A1CA:  MOVLW  07
0A1CC:  MOVWF  FF7
0A1CE:  CALL   25DA
.................... 									  printf(lcd_putc," ESTAGIO1          \n\r"); 
0A1D2:  MOVLW  CE
0A1D4:  MOVWF  FF6
0A1D6:  MOVLW  07
0A1D8:  MOVWF  FF7
0A1DA:  CALL   25DA
.................... 							          break;  
0A1DE:  BRA    A248
....................  
.................... 		case(POSICAO_SOLDA_ESTAGIO2): printf(lcd_putc,"POSICAO SOLDA      \n\r"); 
0A1E0:  MOVLW  E4
0A1E2:  MOVWF  FF6
0A1E4:  MOVLW  07
0A1E6:  MOVWF  FF7
0A1E8:  CALL   25DA
.................... 									  printf(lcd_putc," ESTAGIO2          \n\r"); 
0A1EC:  MOVLW  FA
0A1EE:  MOVWF  FF6
0A1F0:  MOVLW  07
0A1F2:  MOVWF  FF7
0A1F4:  CALL   25DA
.................... 							          break;	 
0A1F8:  BRA    A248
....................   
.................... 		case(POSICAO_DISPENSADOR):    printf(lcd_putc,"POSICAO DISPENSADOR\n\r"); 
0A1FA:  MOVLW  10
0A1FC:  MOVWF  FF6
0A1FE:  MOVLW  08
0A200:  MOVWF  FF7
0A202:  CALL   25DA
....................  									  printf(lcd_putc,"                   \n\r"); 
0A206:  MOVLW  26
0A208:  MOVWF  FF6
0A20A:  MOVLW  08
0A20C:  MOVWF  FF7
0A20E:  CALL   25DA
.................... 									  break;  
0A212:  BRA    A248
....................  
.................... 		case(POSICAO_HOME3):		  printf(lcd_putc,"POSICAO HOME 3     \n\r"); 
0A214:  MOVLW  3C
0A216:  MOVWF  FF6
0A218:  MOVLW  08
0A21A:  MOVWF  FF7
0A21C:  CALL   25DA
....................  									  printf(lcd_putc,"                   \n\r"); 
0A220:  MOVLW  52
0A222:  MOVWF  FF6
0A224:  MOVLW  08
0A226:  MOVWF  FF7
0A228:  CALL   25DA
.................... 					                  break; 
0A22C:  BRA    A248
....................     
.................... 		case(STOP):                   printf(lcd_putc,"         STOP      \n\r"); 
0A22E:  MOVLW  68
0A230:  MOVWF  FF6
0A232:  MOVLW  08
0A234:  MOVWF  FF7
0A236:  CALL   25DA
....................  									  printf(lcd_putc,"                   \n\r"); 
0A23A:  MOVLW  7E
0A23C:  MOVWF  FF6
0A23E:  MOVLW  08
0A240:  MOVWF  FF7
0A242:  CALL   25DA
.................... 									  break;  
0A246:  BRA    A248
.................... 						 
....................  
.................... 		default:			    	  break;   
.................... 					  
....................  
....................  
....................  
.................... 	    }	 
....................  
.................... 		 delay_ms(10); 
0A248:  MOVLW  0A
0A24A:  MOVLB  2
0A24C:  MOVWF  x17
0A24E:  MOVLB  0
0A250:  CALL   1D50
.................... 		 if(key_code == ESC) break; 
0A254:  MOVLB  1
0A256:  MOVF   x94,W
0A258:  SUBLW  12
0A25A:  BTFSC  FD8.2
0A25C:  BRA    A264
0A25E:  MOVLB  0
0A260:  BRA    A122
0A262:  MOVLB  1
....................  
.................... 	}	 
....................  
.................... 		 espera_desacionar_teclas(); 
0A264:  MOVLB  0
0A266:  CALL   7FCA
.................... 		 delay_ms(100); 
0A26A:  MOVLW  64
0A26C:  MOVLB  2
0A26E:  MOVWF  x17
0A270:  MOVLB  0
0A272:  CALL   1D50
0A276:  GOTO   A844 (RETURN)
....................  
....................  
.................... } 
....................  
....................  
.................... void envia_posicoes(void) 
0A27A:  MOVLW  01
0A27C:  MOVLB  1
0A27E:  MOVWF  x93
0A280:  CLRF   x94
.................... { 
.................... 	 int n_menu = 1;  
....................      int key_code = 0; 
....................  
.................... 		printf(lcd_putc,"\f"); 
0A282:  MOVLW  0C
0A284:  MOVWF  xA4
0A286:  MOVLB  0
0A288:  CALL   2586
.................... 		printf(lcd_putc,"1:HOME1   5:ESTAG2 \n\r"); 
0A28C:  MOVLW  94
0A28E:  MOVWF  FF6
0A290:  MOVLW  08
0A292:  MOVWF  FF7
0A294:  CALL   25DA
....................     	printf(lcd_putc,"2:HOME2   6:DISP.  \n\r");	 
0A298:  MOVLW  AA
0A29A:  MOVWF  FF6
0A29C:  MOVLW  08
0A29E:  MOVWF  FF7
0A2A0:  CALL   25DA
.................... 		printf(lcd_putc,"3:ALIMENT 7:INDETER\n\r"); 
0A2A4:  MOVLW  C0
0A2A6:  MOVWF  FF6
0A2A8:  MOVLW  08
0A2AA:  MOVWF  FF7
0A2AC:  CALL   25DA
.................... 		printf(lcd_putc,"4:ESTAG1  8:STOP   \n\r"); 
0A2B0:  MOVLW  D6
0A2B2:  MOVWF  FF6
0A2B4:  MOVLW  08
0A2B6:  MOVWF  FF7
0A2B8:  CALL   25DA
....................  
....................  
.................... 	while(true) 
.................... 	{ 
....................  
.................... 		key_code = Teclado(); 
0A2BC:  CALL   2344
0A2C0:  MOVFF  01,194
....................  
....................  
.................... 		switch(key_code){ 
0A2C4:  MOVLB  1
0A2C6:  MOVF   x94,W
0A2C8:  XORLW  01
0A2CA:  MOVLB  0
0A2CC:  BZ    A2FE
0A2CE:  XORLW  03
0A2D0:  BZ    A35E
0A2D2:  XORLW  01
0A2D4:  BTFSC  FD8.2
0A2D6:  BRA    A3C2
0A2D8:  XORLW  07
0A2DA:  BTFSC  FD8.2
0A2DC:  BRA    A426
0A2DE:  XORLW  01
0A2E0:  BTFSC  FD8.2
0A2E2:  BRA    A48A
0A2E4:  XORLW  03
0A2E6:  BTFSC  FD8.2
0A2E8:  BRA    A4EE
0A2EA:  XORLW  01
0A2EC:  BTFSC  FD8.2
0A2EE:  BRA    A552
0A2F0:  XORLW  0F
0A2F2:  BTFSC  FD8.2
0A2F4:  BRA    A5B6
0A2F6:  XORLW  1A
0A2F8:  BTFSC  FD8.2
0A2FA:  BRA    A61A
0A2FC:  BRA    A688
....................  
.................... 		case(1):             		  n_menu = 2;  
0A2FE:  MOVLW  02
0A300:  MOVLB  1
0A302:  MOVWF  x93
.................... 									  printf(lcd_putc,"\f"); 
0A304:  MOVLW  0C
0A306:  MOVWF  xA4
0A308:  MOVLB  0
0A30A:  CALL   2586
.................... 									  printf(lcd_putc,"POSICAO HOME1      \n\r"); 
0A30E:  MOVLW  EC
0A310:  MOVWF  FF6
0A312:  MOVLW  08
0A314:  MOVWF  FF7
0A316:  CALL   25DA
.................... 									  printf(lcd_putc,"                   \n\r"); 
0A31A:  MOVLW  02
0A31C:  MOVWF  FF6
0A31E:  MOVLW  09
0A320:  MOVWF  FF7
0A322:  CALL   25DA
.................... 									  if(n_maquina == 1)  envia_posicao_para_maquina2(POSICAO_HOME1); 
0A326:  DECFSZ 1D,W
0A328:  BRA    A334
0A32A:  MOVLB  1
0A32C:  CLRF   x9A
0A32E:  MOVLB  0
0A330:  CALL   39AC
.................... 									  if(n_maquina == 2)  envia_posicao_para_maquina1(POSICAO_HOME1); 
0A334:  MOVF   1D,W
0A336:  SUBLW  02
0A338:  BNZ   A344
0A33A:  MOVLB  1
0A33C:  CLRF   x9A
0A33E:  MOVLB  0
0A340:  CALL   50A4
.................... 									  while(Teclado() != 0Xff){} 
0A344:  CALL   2344
0A348:  INCFSZ 01,W
0A34A:  BRA    A34E
0A34C:  BRA    A350
0A34E:  BRA    A344
.................... 							          delay_ms(50);	 
0A350:  MOVLW  32
0A352:  MOVLB  2
0A354:  MOVWF  x17
0A356:  MOVLB  0
0A358:  CALL   1D50
.................... 							    	  break; 
0A35C:  BRA    A688
....................  
.................... 		case(2):    	              n_menu = 2;  
0A35E:  MOVLW  02
0A360:  MOVLB  1
0A362:  MOVWF  x93
.................... 									  printf(lcd_putc,"\f"); 
0A364:  MOVLW  0C
0A366:  MOVWF  xA4
0A368:  MOVLB  0
0A36A:  CALL   2586
.................... 									  printf(lcd_putc,"POSICAO HOME2      \n\r"); 
0A36E:  MOVLW  18
0A370:  MOVWF  FF6
0A372:  MOVLW  09
0A374:  MOVWF  FF7
0A376:  CALL   25DA
....................   									  printf(lcd_putc,"                   \n\r"); 
0A37A:  MOVLW  2E
0A37C:  MOVWF  FF6
0A37E:  MOVLW  09
0A380:  MOVWF  FF7
0A382:  CALL   25DA
.................... 									  if(n_maquina == 1)  envia_posicao_para_maquina2(POSICAO_HOME2); 
0A386:  DECFSZ 1D,W
0A388:  BRA    A396
0A38A:  MOVLW  01
0A38C:  MOVLB  1
0A38E:  MOVWF  x9A
0A390:  MOVLB  0
0A392:  CALL   39AC
.................... 									  if(n_maquina == 2)  envia_posicao_para_maquina1(POSICAO_HOME2); 
0A396:  MOVF   1D,W
0A398:  SUBLW  02
0A39A:  BNZ   A3A8
0A39C:  MOVLW  01
0A39E:  MOVLB  1
0A3A0:  MOVWF  x9A
0A3A2:  MOVLB  0
0A3A4:  CALL   50A4
.................... 									  while(Teclado() != 0Xff){} 
0A3A8:  CALL   2344
0A3AC:  INCFSZ 01,W
0A3AE:  BRA    A3B2
0A3B0:  BRA    A3B4
0A3B2:  BRA    A3A8
.................... 							          delay_ms(50);	 
0A3B4:  MOVLW  32
0A3B6:  MOVLB  2
0A3B8:  MOVWF  x17
0A3BA:  MOVLB  0
0A3BC:  CALL   1D50
.................... 							   		  break;  
0A3C0:  BRA    A688
....................    
.................... 		case(3):                	  n_menu = 2;  
0A3C2:  MOVLW  02
0A3C4:  MOVLB  1
0A3C6:  MOVWF  x93
.................... 									  printf(lcd_putc,"\f"); 
0A3C8:  MOVLW  0C
0A3CA:  MOVWF  xA4
0A3CC:  MOVLB  0
0A3CE:  CALL   2586
.................... 									  printf(lcd_putc,"POSICAO ALIMENTADOR\n\r"); 
0A3D2:  MOVLW  44
0A3D4:  MOVWF  FF6
0A3D6:  MOVLW  09
0A3D8:  MOVWF  FF7
0A3DA:  CALL   25DA
....................  									  printf(lcd_putc,"                   \n\r"); 
0A3DE:  MOVLW  5A
0A3E0:  MOVWF  FF6
0A3E2:  MOVLW  09
0A3E4:  MOVWF  FF7
0A3E6:  CALL   25DA
.................... 									  if(n_maquina == 1)  envia_posicao_para_maquina2(POSICAO_ALIMENTADOR); 
0A3EA:  DECFSZ 1D,W
0A3EC:  BRA    A3FA
0A3EE:  MOVLW  02
0A3F0:  MOVLB  1
0A3F2:  MOVWF  x9A
0A3F4:  MOVLB  0
0A3F6:  CALL   39AC
.................... 									  if(n_maquina == 2)  envia_posicao_para_maquina1(POSICAO_ALIMENTADOR); 
0A3FA:  MOVF   1D,W
0A3FC:  SUBLW  02
0A3FE:  BNZ   A40C
0A400:  MOVLW  02
0A402:  MOVLB  1
0A404:  MOVWF  x9A
0A406:  MOVLB  0
0A408:  CALL   50A4
.................... 						              while(Teclado() != 0Xff){} 
0A40C:  CALL   2344
0A410:  INCFSZ 01,W
0A412:  BRA    A416
0A414:  BRA    A418
0A416:  BRA    A40C
.................... 							          delay_ms(50);	 
0A418:  MOVLW  32
0A41A:  MOVLB  2
0A41C:  MOVWF  x17
0A41E:  MOVLB  0
0A420:  CALL   1D50
.................... 									  break; 
0A424:  BRA    A688
....................     
.................... 		case(4):                      n_menu = 2;  
0A426:  MOVLW  02
0A428:  MOVLB  1
0A42A:  MOVWF  x93
.................... 									  printf(lcd_putc,"\f"); 
0A42C:  MOVLW  0C
0A42E:  MOVWF  xA4
0A430:  MOVLB  0
0A432:  CALL   2586
.................... 									  printf(lcd_putc,"POSICAO SOLDA      \n\r"); 
0A436:  MOVLW  70
0A438:  MOVWF  FF6
0A43A:  MOVLW  09
0A43C:  MOVWF  FF7
0A43E:  CALL   25DA
.................... 									  printf(lcd_putc," ESTAGIO1          \n\r"); 
0A442:  MOVLW  86
0A444:  MOVWF  FF6
0A446:  MOVLW  09
0A448:  MOVWF  FF7
0A44A:  CALL   25DA
.................... 						              if(n_maquina == 1)  envia_posicao_para_maquina2(POSICAO_SOLDA_ESTAGIO1); 
0A44E:  DECFSZ 1D,W
0A450:  BRA    A45E
0A452:  MOVLW  03
0A454:  MOVLB  1
0A456:  MOVWF  x9A
0A458:  MOVLB  0
0A45A:  CALL   39AC
.................... 									  if(n_maquina == 2)  envia_posicao_para_maquina1(POSICAO_SOLDA_ESTAGIO1); 
0A45E:  MOVF   1D,W
0A460:  SUBLW  02
0A462:  BNZ   A470
0A464:  MOVLW  03
0A466:  MOVLB  1
0A468:  MOVWF  x9A
0A46A:  MOVLB  0
0A46C:  CALL   50A4
....................                                       while(Teclado() != 0Xff){} 
0A470:  CALL   2344
0A474:  INCFSZ 01,W
0A476:  BRA    A47A
0A478:  BRA    A47C
0A47A:  BRA    A470
.................... 							          delay_ms(50);	 
0A47C:  MOVLW  32
0A47E:  MOVLB  2
0A480:  MOVWF  x17
0A482:  MOVLB  0
0A484:  CALL   1D50
.................... 							          break;  
0A488:  BRA    A688
....................  
.................... 		case(5):                      n_menu = 2;  
0A48A:  MOVLW  02
0A48C:  MOVLB  1
0A48E:  MOVWF  x93
.................... 									  printf(lcd_putc,"\f"); 
0A490:  MOVLW  0C
0A492:  MOVWF  xA4
0A494:  MOVLB  0
0A496:  CALL   2586
.................... 									  printf(lcd_putc,"POSICAO SOLDA      \n\r"); 
0A49A:  MOVLW  9C
0A49C:  MOVWF  FF6
0A49E:  MOVLW  09
0A4A0:  MOVWF  FF7
0A4A2:  CALL   25DA
.................... 									  printf(lcd_putc," ESTAGIO2          \n\r"); 
0A4A6:  MOVLW  B2
0A4A8:  MOVWF  FF6
0A4AA:  MOVLW  09
0A4AC:  MOVWF  FF7
0A4AE:  CALL   25DA
.................... 			                          if(n_maquina == 1)  envia_posicao_para_maquina2(POSICAO_SOLDA_ESTAGIO2); 
0A4B2:  DECFSZ 1D,W
0A4B4:  BRA    A4C2
0A4B6:  MOVLW  04
0A4B8:  MOVLB  1
0A4BA:  MOVWF  x9A
0A4BC:  MOVLB  0
0A4BE:  CALL   39AC
.................... 									  if(n_maquina == 2)  envia_posicao_para_maquina1(POSICAO_SOLDA_ESTAGIO2); 
0A4C2:  MOVF   1D,W
0A4C4:  SUBLW  02
0A4C6:  BNZ   A4D4
0A4C8:  MOVLW  04
0A4CA:  MOVLB  1
0A4CC:  MOVWF  x9A
0A4CE:  MOVLB  0
0A4D0:  CALL   50A4
....................                                       while(Teclado() != 0Xff){} 
0A4D4:  CALL   2344
0A4D8:  INCFSZ 01,W
0A4DA:  BRA    A4DE
0A4DC:  BRA    A4E0
0A4DE:  BRA    A4D4
.................... 							          delay_ms(50);	 
0A4E0:  MOVLW  32
0A4E2:  MOVLB  2
0A4E4:  MOVWF  x17
0A4E6:  MOVLB  0
0A4E8:  CALL   1D50
.................... 							          break;	 
0A4EC:  BRA    A688
....................   
.................... 		case(6):                      n_menu = 2;  
0A4EE:  MOVLW  02
0A4F0:  MOVLB  1
0A4F2:  MOVWF  x93
.................... 									  printf(lcd_putc,"\f"); 
0A4F4:  MOVLW  0C
0A4F6:  MOVWF  xA4
0A4F8:  MOVLB  0
0A4FA:  CALL   2586
.................... 									  printf(lcd_putc,"POSICAO DISPENSADOR\n\r"); 
0A4FE:  MOVLW  C8
0A500:  MOVWF  FF6
0A502:  MOVLW  09
0A504:  MOVWF  FF7
0A506:  CALL   25DA
....................  									  printf(lcd_putc,"                   \n\r"); 
0A50A:  MOVLW  DE
0A50C:  MOVWF  FF6
0A50E:  MOVLW  09
0A510:  MOVWF  FF7
0A512:  CALL   25DA
....................                                       if(n_maquina == 1)  envia_posicao_para_maquina2(POSICAO_DISPENSADOR); 
0A516:  DECFSZ 1D,W
0A518:  BRA    A526
0A51A:  MOVLW  05
0A51C:  MOVLB  1
0A51E:  MOVWF  x9A
0A520:  MOVLB  0
0A522:  CALL   39AC
.................... 									  if(n_maquina == 2)  envia_posicao_para_maquina1(POSICAO_DISPENSADOR); 
0A526:  MOVF   1D,W
0A528:  SUBLW  02
0A52A:  BNZ   A538
0A52C:  MOVLW  05
0A52E:  MOVLB  1
0A530:  MOVWF  x9A
0A532:  MOVLB  0
0A534:  CALL   50A4
....................                                       while(Teclado() != 0Xff){} 
0A538:  CALL   2344
0A53C:  INCFSZ 01,W
0A53E:  BRA    A542
0A540:  BRA    A544
0A542:  BRA    A538
.................... 							          delay_ms(50);	 
0A544:  MOVLW  32
0A546:  MOVLB  2
0A548:  MOVWF  x17
0A54A:  MOVLB  0
0A54C:  CALL   1D50
.................... 									  break;  
0A550:  BRA    A688
....................  
.................... 		case(7):            		  n_menu = 2;  
0A552:  MOVLW  02
0A554:  MOVLB  1
0A556:  MOVWF  x93
.................... 									  printf(lcd_putc,"\f"); 
0A558:  MOVLW  0C
0A55A:  MOVWF  xA4
0A55C:  MOVLB  0
0A55E:  CALL   2586
.................... 									  printf(lcd_putc,"POSICAO HOME3      \n\r"); 
0A562:  MOVLW  F4
0A564:  MOVWF  FF6
0A566:  MOVLW  09
0A568:  MOVWF  FF7
0A56A:  CALL   25DA
....................  									  printf(lcd_putc,"                   \n\r"); 
0A56E:  MOVLW  0A
0A570:  MOVWF  FF6
0A572:  MOVLW  0A
0A574:  MOVWF  FF7
0A576:  CALL   25DA
....................                                       if(n_maquina == 1)  envia_posicao_para_maquina2(POSICAO_HOME3); 
0A57A:  DECFSZ 1D,W
0A57C:  BRA    A58A
0A57E:  MOVLW  06
0A580:  MOVLB  1
0A582:  MOVWF  x9A
0A584:  MOVLB  0
0A586:  CALL   39AC
.................... 									  if(n_maquina == 2)  envia_posicao_para_maquina1(POSICAO_HOME3); 
0A58A:  MOVF   1D,W
0A58C:  SUBLW  02
0A58E:  BNZ   A59C
0A590:  MOVLW  06
0A592:  MOVLB  1
0A594:  MOVWF  x9A
0A596:  MOVLB  0
0A598:  CALL   50A4
....................                                       while(Teclado() != 0Xff){} 
0A59C:  CALL   2344
0A5A0:  INCFSZ 01,W
0A5A2:  BRA    A5A6
0A5A4:  BRA    A5A8
0A5A6:  BRA    A59C
.................... 							          delay_ms(50);	 
0A5A8:  MOVLW  32
0A5AA:  MOVLB  2
0A5AC:  MOVWF  x17
0A5AE:  MOVLB  0
0A5B0:  CALL   1D50
.................... 					                  break; 
0A5B4:  BRA    A688
....................     
.................... 		case(8):                      n_menu = 2;  
0A5B6:  MOVLW  02
0A5B8:  MOVLB  1
0A5BA:  MOVWF  x93
.................... 									  printf(lcd_putc,"\f"); 
0A5BC:  MOVLW  0C
0A5BE:  MOVWF  xA4
0A5C0:  MOVLB  0
0A5C2:  CALL   2586
.................... 								      printf(lcd_putc,"         STOP      \n\r"); 
0A5C6:  MOVLW  20
0A5C8:  MOVWF  FF6
0A5CA:  MOVLW  0A
0A5CC:  MOVWF  FF7
0A5CE:  CALL   25DA
....................  									  printf(lcd_putc,"                   \n\r"); 
0A5D2:  MOVLW  36
0A5D4:  MOVWF  FF6
0A5D6:  MOVLW  0A
0A5D8:  MOVWF  FF7
0A5DA:  CALL   25DA
....................                                       if(n_maquina == 1)  envia_posicao_para_maquina2(STOP); 
0A5DE:  DECFSZ 1D,W
0A5E0:  BRA    A5EE
0A5E2:  MOVLW  07
0A5E4:  MOVLB  1
0A5E6:  MOVWF  x9A
0A5E8:  MOVLB  0
0A5EA:  CALL   39AC
.................... 									  if(n_maquina == 2)  envia_posicao_para_maquina1(STOP); 
0A5EE:  MOVF   1D,W
0A5F0:  SUBLW  02
0A5F2:  BNZ   A600
0A5F4:  MOVLW  07
0A5F6:  MOVLB  1
0A5F8:  MOVWF  x9A
0A5FA:  MOVLB  0
0A5FC:  CALL   50A4
....................                                       while(Teclado() != 0Xff){} 
0A600:  CALL   2344
0A604:  INCFSZ 01,W
0A606:  BRA    A60A
0A608:  BRA    A60C
0A60A:  BRA    A600
.................... 							          delay_ms(50);	 
0A60C:  MOVLW  32
0A60E:  MOVLB  2
0A610:  MOVWF  x17
0A612:  MOVLB  0
0A614:  CALL   1D50
.................... 									  break;  
0A618:  BRA    A688
.................... 						 
.................... 		case(ESC):					  if(n_menu == 2) 
0A61A:  MOVLB  1
0A61C:  MOVF   x93,W
0A61E:  SUBLW  02
0A620:  BNZ   A680
.................... 									  { 
.................... 									     printf(lcd_putc,"\f"); 
0A622:  MOVLW  0C
0A624:  MOVWF  xA4
0A626:  MOVLB  0
0A628:  CALL   2586
.................... 									     printf(lcd_putc,"1:HOME1   5:ESTAG2 \n\r"); 
0A62C:  MOVLW  4C
0A62E:  MOVWF  FF6
0A630:  MOVLW  0A
0A632:  MOVWF  FF7
0A634:  CALL   25DA
....................     								     printf(lcd_putc,"2:HOME2   6:DISP.  \n\r");	 
0A638:  MOVLW  62
0A63A:  MOVWF  FF6
0A63C:  MOVLW  0A
0A63E:  MOVWF  FF7
0A640:  CALL   25DA
.................... 		                                 printf(lcd_putc,"3:ALIMENT 7:INDETER\n\r"); 
0A644:  MOVLW  78
0A646:  MOVWF  FF6
0A648:  MOVLW  0A
0A64A:  MOVWF  FF7
0A64C:  CALL   25DA
.................... 		                                 printf(lcd_putc,"4:ESTAG1  8:STOP   \n\r"); 
0A650:  MOVLW  8E
0A652:  MOVWF  FF6
0A654:  MOVLW  0A
0A656:  MOVWF  FF7
0A658:  CALL   25DA
.................... 										 n_menu = 1; 
0A65C:  MOVLW  01
0A65E:  MOVLB  1
0A660:  MOVWF  x93
.................... 										 while(Teclado() != 0Xff){} 
0A662:  MOVLB  0
0A664:  CALL   2344
0A668:  INCFSZ 01,W
0A66A:  BRA    A66E
0A66C:  BRA    A670
0A66E:  BRA    A664
.................... 							             delay_ms(50); 
0A670:  MOVLW  32
0A672:  MOVLB  2
0A674:  MOVWF  x17
0A676:  MOVLB  0
0A678:  CALL   1D50
....................  
.................... 									     break; 
0A67C:  BRA    A688
0A67E:  MOVLB  1
.................... 									  } 
.................... 									if(n_menu == 1) return;		 
0A680:  DECFSZ x93,W
0A682:  BRA    A686
0A684:  BRA    A68C
0A686:  MOVLB  0
....................  
....................  
....................  
....................  
.................... 		default:			    	  break;   
.................... 					  
....................  
....................  
....................  
.................... 	    }	 
0A688:  BRA    A2BC
0A68A:  MOVLB  1
....................  
....................  
.................... 	 //if(key_code == ESC) break;	 
....................  
....................  
....................     }   
0A68C:  MOVLB  0
0A68E:  GOTO   A844 (RETURN)
....................   
....................   
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "menus_solda_automatica.c" 
....................  
....................  
....................  
.................... void Tela_Inicial(void) 
.................... {  
.................... 	// atualiza o display com a tela inicial 
....................  
.................... 	printf(lcd_putc,"\f");// limpa display 
*
026A2:  MOVLW  0C
026A4:  MOVLB  1
026A6:  MOVWF  xA4
026A8:  MOVLB  0
026AA:  RCALL  2586
....................  	printf(lcd_putc,"SOLDADOR AUTOMATICO \n\r"); 
026AC:  MOVLW  A4
026AE:  MOVWF  FF6
026B0:  MOVLW  0A
026B2:  MOVWF  FF7
026B4:  RCALL  25DA
....................     printf(lcd_putc,"PROG:    MAQUINA:   \n\r");	 
026B6:  MOVLW  BC
026B8:  MOVWF  FF6
026BA:  MOVLW  0A
026BC:  MOVWF  FF7
026BE:  RCALL  25DA
....................     printf(lcd_putc,"MOD:                \n\r"); 
026C0:  MOVLW  D4
026C2:  MOVWF  FF6
026C4:  MOVLW  0A
026C6:  MOVWF  FF7
026C8:  RCALL  25DA
....................     posiciona_cursor (2,6); 
026CA:  MOVLW  02
026CC:  MOVLB  1
026CE:  MOVWF  xA5
026D0:  MOVLW  06
026D2:  MOVWF  xA6
026D4:  MOVLB  0
026D6:  RCALL  1F92
....................     printf(lcd_putc,"%2u",programa+1); 
026D8:  MOVLW  01
026DA:  ADDWF  29,W
026DC:  MOVLB  1
026DE:  MOVWF  x8C
026E0:  MOVWF  x9A
026E2:  MOVLW  11
026E4:  MOVWF  x9B
026E6:  MOVLB  0
026E8:  RCALL  2626
....................  	posiciona_cursor (2,18); 
026EA:  MOVLW  02
026EC:  MOVLB  1
026EE:  MOVWF  xA5
026F0:  MOVLW  12
026F2:  MOVWF  xA6
026F4:  MOVLB  0
026F6:  RCALL  1F92
....................     printf(lcd_putc,"%2u",n_maquina); 
026F8:  MOVFF  1D,19A
026FC:  MOVLW  11
026FE:  MOVLB  1
02700:  MOVWF  x9B
02702:  MOVLB  0
02704:  RCALL  2626
02706:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... void atualiza_pontos(int indexador_ponto) 
*
07F32:  MOVLW  01
07F34:  MOVLB  1
07F36:  MOVWF  x96
.................... { 
.................... 	int i; 
....................     int n_linha = 1; 
....................     int n_ponto; 
....................  
.................... 	posiciona_cursor(n_linha,1); 
07F38:  MOVFF  196,1A5
07F3C:  MOVWF  xA6
07F3E:  MOVLB  0
07F40:  CALL   1F92
....................     n_ponto = indexador_ponto + 1;  
07F44:  MOVLW  01
07F46:  MOVLB  1
07F48:  ADDWF  x94,W
07F4A:  MOVWF  x97
....................  
.................... 	for(i = 0; i < 4 ; i++) 
07F4C:  CLRF   x95
07F4E:  MOVF   x95,W
07F50:  SUBLW  03
07F52:  BNC   7F88
.................... 	{ 
.................... 		 
.................... 		printf(lcd_putc,"P"); 
07F54:  MOVLW  50
07F56:  MOVWF  xA4
07F58:  MOVLB  0
07F5A:  CALL   2586
.................... 	    printf(lcd_putc,"%2u",n_ponto); 
07F5E:  MOVFF  197,19A
07F62:  MOVLW  11
07F64:  MOVLB  1
07F66:  MOVWF  x9B
07F68:  MOVLB  0
07F6A:  CALL   2626
.................... 		n_ponto++;	 
07F6E:  MOVLB  1
07F70:  INCF   x97,F
.................... 		n_linha++;																 
07F72:  INCF   x96,F
.................... 		posiciona_cursor(n_linha,1); 
07F74:  MOVFF  196,1A5
07F78:  MOVLW  01
07F7A:  MOVWF  xA6
07F7C:  MOVLB  0
07F7E:  CALL   1F92
07F82:  MOVLB  1
07F84:  INCF   x95,F
07F86:  BRA    7F4E
....................  
....................  
.................... 	}	 
07F88:  MOVLB  0
07F8A:  RETURN 0
....................  
.................... } 
....................  
.................... void cria_ponto(cursor_line,indexador_ponto) 
.................... { 
.................... 	int n_ponto; 
....................      
.................... 	if(cursor_line == 4) 
.................... 								{ 
.................... 									 
.................... 											indexador_ponto++;	            //  se nao for 4 incrementa e atualiza a tela do display 
.................... 											atualiza_pontos(indexador_ponto); 
.................... 									  
.................... 										  
.................... 								 
.................... 								}else{ 
....................  
.................... 										posiciona_cursor(cursor_line,4); 
.................... 										printf(lcd_putc,"   "); 			// apaga cursor da linha anterior 
.................... 										cursor_line++; 
.................... 										posiciona_cursor(cursor_line,4);   // atualiza cursor 
.................... 										printf(lcd_putc,"<--"); 
.................... 																		 
....................  
.................... 								    } 
....................  
.................... 					posiciona_cursor(cursor_line,1);   
.................... 					printf(lcd_putc,"NEW"); 
.................... 					posiciona_cursor(1,13); 
.................... 					printf(lcd_putc,"        "); 
.................... 					posiciona_cursor(2,13); 
.................... 					printf(lcd_putc,"F1:EDIT "); 
.................... 					posiciona_cursor(3,13); 
.................... 					printf(lcd_putc,"ESC:SAI "); 
.................... 					cursor_line++; 
....................  
.................... 					/* 
.................... 					for(cursor_line;cursor_line =< 4;cursor_line++) 
.................... 					{ 
.................... 						posiciona_cursor(cursor_line,1); 
.................... 						n_ponto = (cursor_line + indexador_ponto) - 1; 
.................... 						printf(lcd_putc,"P"); 
.................... 	    				printf(lcd_putc,"%2u",n_ponto); 
....................  
.................... 					} 
.................... 					*/ 
....................  
.................... } 
....................  
.................... void display_edita_ponto(void) 
.................... { 
....................  
.................... 	printf(lcd_putc,"\f"); 						  //limpa display 
07F8C:  MOVLW  0C
07F8E:  MOVLB  1
07F90:  MOVWF  xA4
07F92:  MOVLB  0
07F94:  CALL   2586
....................    	printf(lcd_putc,"PONTO:              \n\r"); 
07F98:  MOVLW  16
07F9A:  MOVWF  FF6
07F9C:  MOVLW  0B
07F9E:  MOVWF  FF7
07FA0:  CALL   25DA
.................... 	printf(lcd_putc,"X:0000              \n\r"); 
07FA4:  MOVLW  2E
07FA6:  MOVWF  FF6
07FA8:  MOVLW  0B
07FAA:  MOVWF  FF7
07FAC:  CALL   25DA
.................... 	printf(lcd_putc,"Y:0000   ENTER:SALVA\n\r"); 
07FB0:  MOVLW  46
07FB2:  MOVWF  FF6
07FB4:  MOVLW  0B
07FB6:  MOVWF  FF7
07FB8:  CALL   25DA
.................... 	printf(lcd_putc,"Z:0000   ESC:SAI    \n\r"); 
07FBC:  MOVLW  5E
07FBE:  MOVWF  FF6
07FC0:  MOVLW  0B
07FC2:  MOVWF  FF7
07FC4:  CALL   25DA
07FC8:  RETURN 0
....................  
....................  
.................... } 
....................  
....................  
.................... void display_menu_edita_pontos(void) 
.................... { 
....................  
....................     printf(lcd_putc,"\f"); 						  //limpa display 
*
07EF4:  MOVLW  0C
07EF6:  MOVLB  1
07EF8:  MOVWF  xA4
07EFA:  MOVLB  0
07EFC:  CALL   2586
....................    	printf(lcd_putc,"         ENTER:EDITA\n\r"); 
07F00:  MOVLW  76
07F02:  MOVWF  FF6
07F04:  MOVLW  0B
07F06:  MOVWF  FF7
07F08:  CALL   25DA
.................... 	printf(lcd_putc,"         F2:CRIA    \n\r"); 
07F0C:  MOVLW  8E
07F0E:  MOVWF  FF6
07F10:  MOVLW  0B
07F12:  MOVWF  FF7
07F14:  CALL   25DA
.................... 	printf(lcd_putc,"         F3:DEL     \n\r"); 
07F18:  MOVLW  A6
07F1A:  MOVWF  FF6
07F1C:  MOVLW  0B
07F1E:  MOVWF  FF7
07F20:  CALL   25DA
.................... 	printf(lcd_putc,"         F4:SOLDA P.\n\r"); 
07F24:  MOVLW  BE
07F26:  MOVWF  FF6
07F28:  MOVLW  0B
07F2A:  MOVWF  FF7
07F2C:  CALL   25DA
07F30:  RETURN 0
....................  
.................... } 
....................  
.................... void checa_limites(long int x,long int y,long int z) 
.................... { 
....................  
.................... 	if(n_maquina == 1) 
*
0550A:  DECFSZ 1D,W
0550C:  BRA    5596
....................     { 
.................... 		if(x > LIMTE_MAX_X_1) erro_rot(20); 
0550E:  MOVLB  1
05510:  MOVF   x9B,W
05512:  SUBLW  0F
05514:  BC    552C
05516:  XORLW  FF
05518:  BNZ   5520
0551A:  MOVF   x9A,W
0551C:  SUBLW  CC
0551E:  BC    552C
05520:  MOVLW  14
05522:  MOVWF  xA0
05524:  MOVLB  0
05526:  CALL   3B1C
0552A:  MOVLB  1
....................     	if(y > LIMTE_MAX_Y_1) erro_rot(21); 
0552C:  MOVF   x9D,W
0552E:  SUBLW  14
05530:  BC    5548
05532:  XORLW  FF
05534:  BNZ   553C
05536:  MOVF   x9C,W
05538:  SUBLW  A4
0553A:  BC    5548
0553C:  MOVLW  15
0553E:  MOVWF  xA0
05540:  MOVLB  0
05542:  CALL   3B1C
05546:  MOVLB  1
.................... 		if(z > LIMTE_MAX_Z_1) erro_rot(22); 
05548:  MOVF   x9F,W
0554A:  SUBLW  00
0554C:  BC    5564
0554E:  XORLW  FF
05550:  BNZ   5558
05552:  MOVF   x9E,W
05554:  SUBLW  F4
05556:  BC    5564
05558:  MOVLW  16
0555A:  MOVWF  xA0
0555C:  MOVLB  0
0555E:  CALL   3B1C
05562:  MOVLB  1
.................... 	 
.................... 		if(x < LIMTE_MIN_X_1) erro_rot(23); 
05564:  MOVF   x9B,W
05566:  SUBLW  05
05568:  BNC   557E
0556A:  BNZ   5572
0556C:  MOVF   x9A,W
0556E:  SUBLW  13
05570:  BNC   557E
05572:  MOVLW  17
05574:  MOVWF  xA0
05576:  MOVLB  0
05578:  CALL   3B1C
0557C:  MOVLB  1
....................     	if(y < LIMTE_MIN_Y_1) erro_rot(24); 
0557E:  MOVF   x9D,W
05580:  SUBLW  03
05582:  BNC   5598
05584:  BNZ   558C
05586:  MOVF   x9C,W
05588:  SUBLW  E7
0558A:  BNC   5598
0558C:  MOVLW  18
0558E:  MOVWF  xA0
05590:  MOVLB  0
05592:  CALL   3B1C
05596:  MOVLB  1
.................... 		if(z < LIMTE_MIN_Z_1) erro_rot(25);																			 
.................... 	}  
....................  
....................    if(n_maquina == 2) 
05598:  MOVF   1D,W
0559A:  SUBLW  02
0559C:  BNZ   55F2
....................     { 
.................... 		if(x > LIMTE_MAX_X_2) erro_rot(20); 
0559E:  MOVF   x9B,W
055A0:  SUBLW  04
055A2:  BC    55BA
055A4:  XORLW  FF
055A6:  BNZ   55AE
055A8:  MOVF   x9A,W
055AA:  SUBLW  78
055AC:  BC    55BA
055AE:  MOVLW  14
055B0:  MOVWF  xA0
055B2:  MOVLB  0
055B4:  CALL   3B1C
055B8:  MOVLB  1
....................     	if(y > LIMTE_MAX_Y_2) erro_rot(21); 
055BA:  MOVF   x9D,W
055BC:  SUBLW  0F
055BE:  BC    55D6
055C0:  XORLW  FF
055C2:  BNZ   55CA
055C4:  MOVF   x9C,W
055C6:  SUBLW  97
055C8:  BC    55D6
055CA:  MOVLW  15
055CC:  MOVWF  xA0
055CE:  MOVLB  0
055D0:  CALL   3B1C
055D4:  MOVLB  1
.................... 		if(z > LIMTE_MAX_Z_2) erro_rot(22); 
055D6:  MOVF   x9F,W
055D8:  SUBLW  00
055DA:  BC    55F2
055DC:  XORLW  FF
055DE:  BNZ   55E6
055E0:  MOVF   x9E,W
055E2:  SUBLW  2C
055E4:  BC    55F2
055E6:  MOVLW  16
055E8:  MOVWF  xA0
055EA:  MOVLB  0
055EC:  CALL   3B1C
055F0:  MOVLB  1
.................... 	 
.................... 																			 
.................... 	}  
055F2:  MOVLB  0
055F4:  RETURN 0
....................  
....................  
....................  
.................... } 
....................  
....................  
.................... /* 
.................... void	solda_terminal(void) 
.................... { 
.................... 	//SOLDA TERMINAL DOS LEDS,CAPACITORES E TERMINAL PEQUENO DA MOLA 
....................  
....................         go_z(250,velocity_z); 
....................         go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false);	  
.................... 		go_z(coordenada_z_armazenado,velocity_z); 
.................... 		delay_ms(1000);   
.................... 		aciona_saida(ALIMENTADOR1); 
.................... 	  	aciona_saida(ALIMENTADOR2); 
.................... 	    aciona_saida(ALIMENTADOR3); 
.................... 		if(passo == 0)  
....................         { 
....................  
.................... 			delay_ms(300); 
....................  
....................  
.................... 		}else delay_ms(300); 
....................  
.................... 		desaciona_saida(ALIMENTADOR1); 
.................... 	  	desaciona_saida(ALIMENTADOR2); 
.................... 	  	desaciona_saida(ALIMENTADOR3); 
.................... 		delay_ms(2500);   
.................... 	 	//go_z(coordenada_z_armazenado - 10,8000); 
.................... 		//go_x_y(coordenada_x_armazenado,coordenada_y_armazenado - 40,velocity_x,velocity_y,2000,2000,200,200,false,false,false,false); 
.................... 	 	go_z(250,velocity_z);	 
.................... 		//go_x_y(coordenada_x_armazenado,coordenada_y_armazenado ,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
.................... 		posiciona_cursor(4,3); 
.................... 		printf(lcd_putc,"%4LU",contador_step_z); 
.................... 		 
.................... }    
....................  
.................... */ 
.................... /* 
.................... void	solda_terminal(int tipo) 
.................... { 
.................... 	//SOLDA TERMINAL DOS LEDS,CAPACITORES E TERMINAL PEQUENO DA MOLA 
....................  
....................          
....................         go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,5000,5000,2000,2000,200,200,true,true,false,false);	  
.................... 	    go_z(270,5000); 
.................... 		aciona_saida(ALIMENTADOR1); 
.................... 	  	aciona_saida(ALIMENTADOR2); 
.................... 	    aciona_saida(ALIMENTADOR3); 
.................... 		delay_ms(300); 
....................         desaciona_saida(ALIMENTADOR1); 
.................... 	  	desaciona_saida(ALIMENTADOR2); 
.................... 	  	desaciona_saida(ALIMENTADOR3); 
....................  		go_z(coordenada_z_armazenado,5000); 
.................... 		delay_ms(2000);   
.................... 	    if(tipo == 0) go_z(250,velocity_z);	 
.................... 		posiciona_cursor(4,3); 
.................... 		printf(lcd_putc,"%4LU",contador_step_z); 
.................... 		 
....................  
.................... }  
....................  
.................... */ 
.................... /* 
.................... void    solda_mola(void) 
.................... { 
....................   // SOLDA TERMINAL GRANDE DA MOLA 
....................  
....................    go_z(200,velocity_z); 
....................    go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
....................    go_z(coordenada_z_armazenado,5000); 
....................    delay_ms(3500); 
....................    aciona_saida(ALIMENTADOR1); 
....................    aciona_saida(ALIMENTADOR2); 
....................    aciona_saida(ALIMENTADOR3); 
....................    delay_ms(600); 
....................    desaciona_saida(ALIMENTADOR1); 
....................    desaciona_saida(ALIMENTADOR2); 
....................    desaciona_saida(ALIMENTADOR3); 
....................    delay_ms(3000); 
....................    go_x(coordenada_x_armazenado + 60,30); 
....................    go_x(coordenada_x_armazenado + 80,1); 
....................    go_z(200,velocity_z); 
....................    posiciona_cursor(4,3); 
....................    printf(lcd_putc,"%4LU",contador_step_z); 
....................  
....................  
.................... } 
.................... */ 
....................  
.................... void aciona_alimentador_solda(long int t_aplicacao,int estagio) 
*
05680:  MOVLB  1
05682:  CLRF   x9F
05684:  CLRF   x9E
.................... { 
.................... 		 
....................     long int ix = 0; 
....................  
....................     tempo_aplicacao = t_aplicacao ; 
05686:  MOVFF  19C,24
0568A:  MOVFF  19B,23
....................  
....................      contador_tempo = 0; 
0568E:  CLRF   20
05690:  CLRF   1F
.................... 	  
.................... 	 if(estagio == 1) 
05692:  DECFSZ x9D,W
05694:  BRA    56B4
....................      { 
....................         aciona_saida(ALIMENTADOR2); 
05696:  CLRF   xA1
05698:  MOVLW  0D
0569A:  MOVWF  xA0
0569C:  MOVLB  0
0569E:  CALL   2FD2
.................... 	    aciona_saida(ALIMENTADOR3); 
056A2:  MOVLB  1
056A4:  CLRF   xA1
056A6:  MOVLW  0C
056A8:  MOVWF  xA0
056AA:  MOVLB  0
056AC:  CALL   2FD2
....................  
.................... 	 }else{ 
056B0:  BRA    56DC
056B2:  MOVLB  1
....................  
.................... 		aciona_saida(ALIMENTADOR1);	 
056B4:  CLRF   xA1
056B6:  MOVLW  0E
056B8:  MOVWF  xA0
056BA:  MOVLB  0
056BC:  CALL   2FD2
.................... 		aciona_saida(ALIMENTADOR2); 
056C0:  MOVLB  1
056C2:  CLRF   xA1
056C4:  MOVLW  0D
056C6:  MOVWF  xA0
056C8:  MOVLB  0
056CA:  CALL   2FD2
.................... 	    aciona_saida(ALIMENTADOR3); 
056CE:  MOVLB  1
056D0:  CLRF   xA1
056D2:  MOVLW  0C
056D4:  MOVWF  xA0
056D6:  MOVLB  0
056D8:  CALL   2FD2
....................  
....................  
.................... 		  }   
....................  
....................         //for(ix = 0 ; ix < tempo_aplicacao; ix++) 
....................         //{ 
.................... 			 trata_timer_zero_modo = 1; 
056DC:  BSF    1E.2
.................... 			 tempo =  (65535 - (1000 * 5)); 
056DE:  MOVLW  EC
056E0:  MOVWF  22
056E2:  MOVLW  77
056E4:  MOVWF  21
.................... 			 estouro_timer0 = false; 
056E6:  BCF    1E.6
.................... 	    	 SETUP_TIMER_0(T0_INTERNAL | T0_DIV_1 ); 
056E8:  MOVLW  88
056EA:  MOVWF  FD5
.................... 	         enable_interrupts(INT_TIMER0); 
056EC:  BSF    FF2.5
.................... 		 	 SET_TIMER0(tempo); 
056EE:  MOVFF  22,FD7
056F2:  MOVFF  21,FD6
.................... 	         enable_interrupts(GLOBAL); 
056F6:  MOVLW  C0
056F8:  IORWF  FF2,F
056FA:  RETURN 0
....................  
....................         //}		 
....................  
.................... } 
....................  
....................  
.................... void    solda_mola(int estagio) 
.................... { 
....................   // SOLDA TERMINAL GRANDE DA MOLA 
....................  
....................    go_z(200,velocity_z); 
*
0580A:  MOVLB  1
0580C:  CLRF   x9C
0580E:  MOVLW  C8
05810:  MOVWF  x9B
05812:  MOVLW  07
05814:  MOVWF  x9E
05816:  MOVLW  D0
05818:  MOVWF  x9D
0581A:  MOVLB  0
0581C:  RCALL  55F6
....................    go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
0581E:  MOVFF  2B,19D
05822:  MOVFF  2A,19C
05826:  MOVFF  2D,19F
0582A:  MOVFF  2C,19E
0582E:  MOVLW  01
05830:  MOVLB  1
05832:  MOVWF  xA1
05834:  MOVLW  2C
05836:  MOVWF  xA0
05838:  MOVLW  01
0583A:  MOVWF  xA3
0583C:  MOVLW  2C
0583E:  MOVWF  xA2
05840:  MOVLW  07
05842:  MOVWF  xA5
05844:  MOVLW  D0
05846:  MOVWF  xA4
05848:  MOVLW  07
0584A:  MOVWF  xA7
0584C:  MOVLW  D0
0584E:  MOVWF  xA6
05850:  MOVLW  C8
05852:  MOVWF  xA8
05854:  MOVWF  xA9
05856:  MOVLW  01
05858:  MOVWF  xAA
0585A:  MOVWF  xAB
0585C:  CLRF   xAC
0585E:  CLRF   xAD
05860:  MOVLB  0
05862:  CALL   42F6
....................    go_z(coordenada_z_armazenado,velocity_z); 
05866:  MOVFF  2F,19C
0586A:  MOVFF  2E,19B
0586E:  MOVLW  07
05870:  MOVLB  1
05872:  MOVWF  x9E
05874:  MOVLW  D0
05876:  MOVWF  x9D
05878:  MOVLB  0
0587A:  RCALL  55F6
....................    //delay_ms(1000); 
....................    if(estagio == 1) 
0587C:  MOVLB  1
0587E:  DECFSZ x9A,W
05880:  BRA    58A0
....................    {		 
....................       
....................      aciona_saida(ALIMENTADOR2); 
05882:  CLRF   xA1
05884:  MOVLW  0D
05886:  MOVWF  xA0
05888:  MOVLB  0
0588A:  CALL   2FD2
....................      aciona_saida(ALIMENTADOR3); 
0588E:  MOVLB  1
05890:  CLRF   xA1
05892:  MOVLW  0C
05894:  MOVWF  xA0
05896:  MOVLB  0
05898:  CALL   2FD2
....................  
....................    }else{ 
0589C:  BRA    58C8
0589E:  MOVLB  1
....................  
....................      aciona_saida(ALIMENTADOR1); 
058A0:  CLRF   xA1
058A2:  MOVLW  0E
058A4:  MOVWF  xA0
058A6:  MOVLB  0
058A8:  CALL   2FD2
....................      aciona_saida(ALIMENTADOR2); 
058AC:  MOVLB  1
058AE:  CLRF   xA1
058B0:  MOVLW  0D
058B2:  MOVWF  xA0
058B4:  MOVLB  0
058B6:  CALL   2FD2
....................      aciona_saida(ALIMENTADOR3); 
058BA:  MOVLB  1
058BC:  CLRF   xA1
058BE:  MOVLW  0C
058C0:  MOVWF  xA0
058C2:  MOVLB  0
058C4:  CALL   2FD2
....................  
....................  
.................... 	} 
....................  
....................  
....................    delay_ms(300); 
058C8:  MOVLW  02
058CA:  MOVLB  1
058CC:  MOVWF  x9B
058CE:  MOVLW  96
058D0:  MOVLB  2
058D2:  MOVWF  x17
058D4:  MOVLB  0
058D6:  CALL   1D50
058DA:  MOVLB  1
058DC:  DECFSZ x9B,F
058DE:  BRA    58CE
058E0:  CLRF   16
058E2:  BTFSC  FF2.7
058E4:  BSF    16.7
058E6:  BCF    FF2.7
....................    desaciona_saida(ALIMENTADOR1); 
058E8:  MOVLB  2
058EA:  CLRF   x1B
058EC:  MOVLW  0E
058EE:  MOVWF  x1A
058F0:  MOVLB  0
058F2:  CALL   1B96
058F6:  BTFSC  16.7
058F8:  BSF    FF2.7
058FA:  CLRF   16
058FC:  BTFSC  FF2.7
058FE:  BSF    16.7
05900:  BCF    FF2.7
....................    desaciona_saida(ALIMENTADOR2); 
05902:  MOVLB  2
05904:  CLRF   x1B
05906:  MOVLW  0D
05908:  MOVWF  x1A
0590A:  MOVLB  0
0590C:  CALL   1B96
05910:  BTFSC  16.7
05912:  BSF    FF2.7
05914:  CLRF   16
05916:  BTFSC  FF2.7
05918:  BSF    16.7
0591A:  BCF    FF2.7
....................    desaciona_saida(ALIMENTADOR3); 
0591C:  MOVLB  2
0591E:  CLRF   x1B
05920:  MOVLW  0C
05922:  MOVWF  x1A
05924:  MOVLB  0
05926:  CALL   1B96
0592A:  BTFSC  16.7
0592C:  BSF    FF2.7
....................    delay_ms(3000);// tempo de aquecimento da mola 
0592E:  MOVLW  0C
05930:  MOVLB  1
05932:  MOVWF  x9B
05934:  MOVLW  FA
05936:  MOVLB  2
05938:  MOVWF  x17
0593A:  MOVLB  0
0593C:  CALL   1D50
05940:  MOVLB  1
05942:  DECFSZ x9B,F
05944:  BRA    5934
....................    aciona_alimentador_solda(300,estagio); 
05946:  MOVLW  01
05948:  MOVWF  x9C
0594A:  MOVLW  2C
0594C:  MOVWF  x9B
0594E:  MOVFF  19A,19D
05952:  MOVLB  0
05954:  RCALL  5680
....................    go_x(coordenada_x_armazenado + 60,20); 
05956:  MOVLW  3C
05958:  ADDWF  2A,W
0595A:  MOVLB  1
0595C:  MOVWF  x9B
0595E:  MOVLW  00
05960:  ADDWFC 2B,W
05962:  MOVWF  x9C
05964:  MOVWF  x9E
05966:  MOVFF  19B,19D
0596A:  MOVLW  14
0596C:  MOVWF  x9F
0596E:  MOVLB  0
05970:  RCALL  56FC
....................    go_x(coordenada_x_armazenado + 90,5); 
05972:  MOVLW  5A
05974:  ADDWF  2A,W
05976:  MOVLB  1
05978:  MOVWF  x9B
0597A:  MOVLW  00
0597C:  ADDWFC 2B,W
0597E:  MOVWF  x9C
05980:  MOVWF  x9E
05982:  MOVFF  19B,19D
05986:  MOVLW  05
05988:  MOVWF  x9F
0598A:  MOVLB  0
0598C:  RCALL  56FC
....................    posiciona_cursor(4,3); 
0598E:  MOVLW  04
05990:  MOVLB  1
05992:  MOVWF  xA5
05994:  MOVLW  03
05996:  MOVWF  xA6
05998:  MOVLB  0
0599A:  CALL   1F92
....................    printf(lcd_putc,"%4LU",contador_step_z); 
0599E:  MOVLW  01
059A0:  MOVWF  FE9
059A2:  MOVFF  17F,19C
059A6:  MOVFF  17E,19B
059AA:  RCALL  5744
059AC:  RETURN 0
....................  
.................... } 
....................  
.................... void    solda_mola_2(int estagio) 
.................... { 
....................   // SOLDA TERMINAL GRANDE DA MOLA 
....................  
....................    go_z(200,velocity_z); 
059AE:  MOVLB  1
059B0:  CLRF   x9C
059B2:  MOVLW  C8
059B4:  MOVWF  x9B
059B6:  MOVLW  07
059B8:  MOVWF  x9E
059BA:  MOVLW  D0
059BC:  MOVWF  x9D
059BE:  MOVLB  0
059C0:  RCALL  55F6
....................    go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
059C2:  MOVFF  2B,19D
059C6:  MOVFF  2A,19C
059CA:  MOVFF  2D,19F
059CE:  MOVFF  2C,19E
059D2:  MOVLW  01
059D4:  MOVLB  1
059D6:  MOVWF  xA1
059D8:  MOVLW  2C
059DA:  MOVWF  xA0
059DC:  MOVLW  01
059DE:  MOVWF  xA3
059E0:  MOVLW  2C
059E2:  MOVWF  xA2
059E4:  MOVLW  07
059E6:  MOVWF  xA5
059E8:  MOVLW  D0
059EA:  MOVWF  xA4
059EC:  MOVLW  07
059EE:  MOVWF  xA7
059F0:  MOVLW  D0
059F2:  MOVWF  xA6
059F4:  MOVLW  C8
059F6:  MOVWF  xA8
059F8:  MOVWF  xA9
059FA:  MOVLW  01
059FC:  MOVWF  xAA
059FE:  MOVWF  xAB
05A00:  CLRF   xAC
05A02:  CLRF   xAD
05A04:  MOVLB  0
05A06:  CALL   42F6
....................    go_z(coordenada_z_armazenado,velocity_z); 
05A0A:  MOVFF  2F,19C
05A0E:  MOVFF  2E,19B
05A12:  MOVLW  07
05A14:  MOVLB  1
05A16:  MOVWF  x9E
05A18:  MOVLW  D0
05A1A:  MOVWF  x9D
05A1C:  MOVLB  0
05A1E:  RCALL  55F6
....................    //delay_ms(1000); 
....................    if(estagio == 1) 
05A20:  MOVLB  1
05A22:  DECFSZ x9A,W
05A24:  BRA    5A44
....................    { 
....................  
....................    aciona_saida(ALIMENTADOR2); 
05A26:  CLRF   xA1
05A28:  MOVLW  0D
05A2A:  MOVWF  xA0
05A2C:  MOVLB  0
05A2E:  CALL   2FD2
....................    aciona_saida(ALIMENTADOR3); 
05A32:  MOVLB  1
05A34:  CLRF   xA1
05A36:  MOVLW  0C
05A38:  MOVWF  xA0
05A3A:  MOVLB  0
05A3C:  CALL   2FD2
....................  
....................    }else{ 
05A40:  BRA    5A6C
05A42:  MOVLB  1
....................  
....................  		aciona_saida(ALIMENTADOR1); 
05A44:  CLRF   xA1
05A46:  MOVLW  0E
05A48:  MOVWF  xA0
05A4A:  MOVLB  0
05A4C:  CALL   2FD2
....................    		aciona_saida(ALIMENTADOR2); 
05A50:  MOVLB  1
05A52:  CLRF   xA1
05A54:  MOVLW  0D
05A56:  MOVWF  xA0
05A58:  MOVLB  0
05A5A:  CALL   2FD2
....................    		aciona_saida(ALIMENTADOR3); 
05A5E:  MOVLB  1
05A60:  CLRF   xA1
05A62:  MOVLW  0C
05A64:  MOVWF  xA0
05A66:  MOVLB  0
05A68:  CALL   2FD2
....................  
....................  
.................... 		} 
.................... 	 
....................    delay_ms(300); 
05A6C:  MOVLW  02
05A6E:  MOVLB  1
05A70:  MOVWF  x9B
05A72:  MOVLW  96
05A74:  MOVLB  2
05A76:  MOVWF  x17
05A78:  MOVLB  0
05A7A:  CALL   1D50
05A7E:  MOVLB  1
05A80:  DECFSZ x9B,F
05A82:  BRA    5A72
05A84:  CLRF   16
05A86:  BTFSC  FF2.7
05A88:  BSF    16.7
05A8A:  BCF    FF2.7
....................    desaciona_saida(ALIMENTADOR1); 
05A8C:  MOVLB  2
05A8E:  CLRF   x1B
05A90:  MOVLW  0E
05A92:  MOVWF  x1A
05A94:  MOVLB  0
05A96:  CALL   1B96
05A9A:  BTFSC  16.7
05A9C:  BSF    FF2.7
05A9E:  CLRF   16
05AA0:  BTFSC  FF2.7
05AA2:  BSF    16.7
05AA4:  BCF    FF2.7
....................    desaciona_saida(ALIMENTADOR2); 
05AA6:  MOVLB  2
05AA8:  CLRF   x1B
05AAA:  MOVLW  0D
05AAC:  MOVWF  x1A
05AAE:  MOVLB  0
05AB0:  CALL   1B96
05AB4:  BTFSC  16.7
05AB6:  BSF    FF2.7
05AB8:  CLRF   16
05ABA:  BTFSC  FF2.7
05ABC:  BSF    16.7
05ABE:  BCF    FF2.7
....................    desaciona_saida(ALIMENTADOR3); 
05AC0:  MOVLB  2
05AC2:  CLRF   x1B
05AC4:  MOVLW  0C
05AC6:  MOVWF  x1A
05AC8:  MOVLB  0
05ACA:  CALL   1B96
05ACE:  BTFSC  16.7
05AD0:  BSF    FF2.7
....................    delay_ms(3000);      //tempo de aquecimento da mola 
05AD2:  MOVLW  0C
05AD4:  MOVLB  1
05AD6:  MOVWF  x9B
05AD8:  MOVLW  FA
05ADA:  MOVLB  2
05ADC:  MOVWF  x17
05ADE:  MOVLB  0
05AE0:  CALL   1D50
05AE4:  MOVLB  1
05AE6:  DECFSZ x9B,F
05AE8:  BRA    5AD8
....................    aciona_alimentador_solda(300,estagio); 
05AEA:  MOVLW  01
05AEC:  MOVWF  x9C
05AEE:  MOVLW  2C
05AF0:  MOVWF  x9B
05AF2:  MOVFF  19A,19D
05AF6:  MOVLB  0
05AF8:  RCALL  5680
....................    go_x(coordenada_x_armazenado + 60,20); 
05AFA:  MOVLW  3C
05AFC:  ADDWF  2A,W
05AFE:  MOVLB  1
05B00:  MOVWF  x9B
05B02:  MOVLW  00
05B04:  ADDWFC 2B,W
05B06:  MOVWF  x9C
05B08:  MOVWF  x9E
05B0A:  MOVFF  19B,19D
05B0E:  MOVLW  14
05B10:  MOVWF  x9F
05B12:  MOVLB  0
05B14:  RCALL  56FC
....................    go_x(coordenada_x_armazenado + 100,5); 
05B16:  MOVLW  64
05B18:  ADDWF  2A,W
05B1A:  MOVLB  1
05B1C:  MOVWF  x9B
05B1E:  MOVLW  00
05B20:  ADDWFC 2B,W
05B22:  MOVWF  x9C
05B24:  MOVWF  x9E
05B26:  MOVFF  19B,19D
05B2A:  MOVLW  05
05B2C:  MOVWF  x9F
05B2E:  MOVLB  0
05B30:  RCALL  56FC
....................    posiciona_cursor(4,3); 
05B32:  MOVLW  04
05B34:  MOVLB  1
05B36:  MOVWF  xA5
05B38:  MOVLW  03
05B3A:  MOVWF  xA6
05B3C:  MOVLB  0
05B3E:  CALL   1F92
....................    printf(lcd_putc,"%4LU",contador_step_z); 
05B42:  MOVLW  01
05B44:  MOVWF  FE9
05B46:  MOVFF  17F,19C
05B4A:  MOVFF  17E,19B
05B4E:  RCALL  5744
05B50:  RETURN 0
....................  
....................  
.................... } 
....................  
....................  
.................... void	soldar_teste(void) 
.................... { 
.................... 	 
....................    for(passo = 0;passo <  numero_pontos;passo++) 
....................    { 
.................... 	pega_data_eeprom(passo); 
.................... 	switch 	(passo){ 
....................  
.................... 	case 0:  
.................... 			checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
.................... 			go_x_y(coordenada_x_armazenado - 30,coordenada_y_armazenado,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false);	  
.................... 	        go_z(coordenada_z_armazenado,velocity_z); 
.................... 			aciona_alimentador_solda(300,1); 
.................... 		    go_x(coordenada_x_armazenado,5);  
.................... 	       	delay_ms(500);  
.................... 	        posiciona_cursor(4,3); 
.................... 		    printf(lcd_putc,"%4LU",contador_step_z); 
.................... 			break; 
....................  
.................... 	case 1:  
.................... 			checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
.................... 			aciona_alimentador_solda(200,1); 
.................... 			go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,5000,5000,2000,2000,200,200,true,true,false,false);	 
....................  			delay_ms(500);  
....................             go_x_y(coordenada_x_armazenado + 30,coordenada_y_armazenado,5000,5000,2000,2000,200,200,true,true,false,false); 
.................... 			go_z(z_soldar_home,velocity_z); 
.................... 			break; 
....................  
....................     case 2:  
....................            	checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
.................... 			go_x_y(coordenada_x_armazenado - 30,coordenada_y_armazenado,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false);	  
.................... 			go_z(coordenada_z_armazenado,velocity_z); 
.................... 		    aciona_alimentador_solda(300,1); 
....................             go_x(coordenada_x_armazenado,20);  
.................... 	        delay_ms(1000);   
.................... 	        posiciona_cursor(4,3); 
.................... 		    printf(lcd_putc,"%4LU",contador_step_z); 
.................... 			break; 
.................... 	   
.................... 	case 3: checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
.................... 			aciona_alimentador_solda(200,1); 
.................... 			go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,5000,5000,2000,2000,200,200,true,true,false,false);	 
....................  			delay_ms(1000);  
....................             go_x_y(coordenada_x_armazenado + 30,coordenada_y_armazenado,5000,5000,2000,2000,200,200,true,true,false,false); 
.................... 			go_z(z_soldar_home,velocity_z); 
.................... 			break; 
....................  
.................... 	case 4: checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
.................... 			solda_mola(1); 
....................     		break; 
....................  
.................... 	case 5: checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
.................... 		   	go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,12000,12000,2000,2000,200,200,true,true,false,false);	  
.................... 			aciona_alimentador_solda(200,1); 
.................... 			go_z(coordenada_z_armazenado,velocity_z); 
.................... 			delay_ms(1000);   
.................... 		 	go_x_y(coordenada_x_armazenado + 30,coordenada_y_armazenado,5000,5000,2000,2000,200,200,false,false,false,false); 
.................... 		 	go_z(z_soldar_home,velocity_z);	 
.................... 			go_x_y(coordenada_x_armazenado,coordenada_y_armazenado ,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
.................... 			posiciona_cursor(4,3); 
.................... 			printf(lcd_putc,"%4LU",contador_step_z); 
.................... 			break; 
....................  
.................... 	case 6: checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
.................... 			solda_mola_2(1); 
.................... 			break; 
....................  
.................... 	case 7: checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
.................... 			go_z(z_soldar_home,velocity_z); 
....................           	go_x_y(coordenada_x_armazenado - 30,coordenada_y_armazenado,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false);	  
.................... 		    go_z(coordenada_z_armazenado,velocity_z); 
....................             aciona_alimentador_solda(200,1); 
.................... 			go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,12000,12000,2000,2000,200,200,true,true,false,false); 
.................... 			delay_ms(1000);   
.................... 		 	go_x_y(coordenada_x_armazenado,coordenada_y_armazenado - 5,5000,5000,2000,2000,200,200,false,false,false,false); 
.................... 		 	go_x_y(coordenada_x_armazenado + 25,coordenada_y_armazenado,5000,5000,2000,2000,200,200,false,false,false,false); 
.................... 			go_z(200,velocity_z);	 
.................... 			posiciona_cursor(4,3); 
.................... 			printf(lcd_putc,"%4LU",contador_step_z); 
.................... 			break; 
....................  
....................          default: 
....................  
.................... 			break; 
....................  
....................     }   
....................  
....................  
.................... } 
....................  
....................  
.................... } 
....................  
....................  
.................... void  edita_ponto(int cursor_line,int indexador_ponto) 
.................... { 
.................... 	 int n_ponto; 
....................      int key_code; 
....................      int erro; 
....................     
....................      display_edita_ponto(); 
*
08100:  RCALL  7F8C
....................      n_ponto = (cursor_line + indexador_ponto); 
08102:  MOVLB  1
08104:  MOVF   x95,W
08106:  ADDWF  x94,W
08108:  MOVWF  x96
....................      passo =  n_ponto - 1; 
0810A:  MOVLW  01
0810C:  SUBWF  x96,W
0810E:  MOVWF  54
....................      posiciona_cursor(1,8); 
08110:  MOVLW  01
08112:  MOVWF  xA5
08114:  MOVLW  08
08116:  MOVWF  xA6
08118:  MOVLB  0
0811A:  CALL   1F92
.................... 	 printf(lcd_putc,"%2u",n_ponto); 
0811E:  MOVFF  196,19A
08122:  MOVLW  11
08124:  MOVLB  1
08126:  MOVWF  x9B
08128:  MOVLB  0
0812A:  CALL   2626
....................  
....................      pega_data_eeprom(passo); 
0812E:  MOVFF  54,19A
08132:  CALL   53D8
....................       
.................... 	 checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
08136:  MOVFF  2B,19B
0813A:  MOVFF  2A,19A
0813E:  MOVFF  2D,19D
08142:  MOVFF  2C,19C
08146:  MOVFF  2F,19F
0814A:  MOVFF  2E,19E
0814E:  CALL   550A
.................... 	 go_z(50,3000);//muito importante pra nao quebrar o ferro 
08152:  MOVLB  1
08154:  CLRF   x9C
08156:  MOVLW  32
08158:  MOVWF  x9B
0815A:  MOVLW  0B
0815C:  MOVWF  x9E
0815E:  MOVLW  B8
08160:  MOVWF  x9D
08162:  MOVLB  0
08164:  CALL   55F6
....................  
....................       if(n_maquina == 1) 
08168:  DECFSZ 1D,W
0816A:  BRA    8200
....................       { 
.................... 		 
....................  	    go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false);	  
0816C:  MOVFF  2B,19D
08170:  MOVFF  2A,19C
08174:  MOVFF  2D,19F
08178:  MOVFF  2C,19E
0817C:  MOVLW  01
0817E:  MOVLB  1
08180:  MOVWF  xA1
08182:  MOVLW  2C
08184:  MOVWF  xA0
08186:  MOVLW  01
08188:  MOVWF  xA3
0818A:  MOVLW  2C
0818C:  MOVWF  xA2
0818E:  MOVLW  07
08190:  MOVWF  xA5
08192:  MOVLW  D0
08194:  MOVWF  xA4
08196:  MOVLW  07
08198:  MOVWF  xA7
0819A:  MOVLW  D0
0819C:  MOVWF  xA6
0819E:  MOVLW  C8
081A0:  MOVWF  xA8
081A2:  MOVWF  xA9
081A4:  MOVLW  01
081A6:  MOVWF  xAA
081A8:  MOVWF  xAB
081AA:  CLRF   xAC
081AC:  CLRF   xAD
081AE:  MOVLB  0
081B0:  CALL   42F6
.................... 	  //if(flag_estagio2 == true) envia_posicao_para_maquina2(POSICAO_SOLDA_ESTAGIO2); 
.................... 		if(passo <= 7) 
081B4:  MOVF   54,W
081B6:  SUBLW  07
081B8:  BNC   81E4
.................... 		{ 
....................  
.................... 		  
....................           aciona_saida(FERRO_SOLDA2); 
081BA:  MOVLB  1
081BC:  CLRF   xA1
081BE:  MOVLW  02
081C0:  MOVWF  xA0
081C2:  MOVLB  0
081C4:  CALL   2FD2
081C8:  CLRF   16
081CA:  BTFSC  FF2.7
081CC:  BSF    16.7
081CE:  BCF    FF2.7
.................... 		  desaciona_saida(FERRO_SOLDA1); 
081D0:  MOVLB  2
081D2:  CLRF   x1B
081D4:  MOVLW  03
081D6:  MOVWF  x1A
081D8:  MOVLB  0
081DA:  CALL   1B96
081DE:  BTFSC  16.7
081E0:  BSF    FF2.7
....................  
....................  
.................... 	    }else{ 
081E2:  BRA    8200
....................  
.................... 			 aciona_saida(FERRO_SOLDA1); 
081E4:  MOVLB  1
081E6:  CLRF   xA1
081E8:  MOVLW  03
081EA:  MOVWF  xA0
081EC:  MOVLB  0
081EE:  CALL   2FD2
....................              aciona_saida(FERRO_SOLDA2); 
081F2:  MOVLB  1
081F4:  CLRF   xA1
081F6:  MOVLW  02
081F8:  MOVWF  xA0
081FA:  MOVLB  0
081FC:  CALL   2FD2
.................... 	 
.................... 	         }	 
....................  
....................  
.................... 	  } 
....................  
....................       if(n_maquina == 2) 
08200:  MOVF   1D,W
08202:  SUBLW  02
08204:  BNZ   829A
.................... 	  { 
....................  
....................       go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
08206:  MOVFF  2B,19D
0820A:  MOVFF  2A,19C
0820E:  MOVFF  2D,19F
08212:  MOVFF  2C,19E
08216:  MOVLW  01
08218:  MOVLB  1
0821A:  MOVWF  xA1
0821C:  MOVLW  2C
0821E:  MOVWF  xA0
08220:  MOVLW  01
08222:  MOVWF  xA3
08224:  MOVLW  2C
08226:  MOVWF  xA2
08228:  MOVLW  07
0822A:  MOVWF  xA5
0822C:  MOVLW  D0
0822E:  MOVWF  xA4
08230:  MOVLW  07
08232:  MOVWF  xA7
08234:  MOVLW  D0
08236:  MOVWF  xA6
08238:  MOVLW  C8
0823A:  MOVWF  xA8
0823C:  MOVWF  xA9
0823E:  MOVLW  01
08240:  MOVWF  xAA
08242:  MOVWF  xAB
08244:  CLRF   xAC
08246:  CLRF   xAD
08248:  MOVLB  0
0824A:  CALL   42F6
....................       //if(flag_estagio2 == true) envia_posicao_para_maquina1(POSICAO_SOLDA_ESTAGIO2); 
....................  
.................... 		if(passo <= 7) 
0824E:  MOVF   54,W
08250:  SUBLW  07
08252:  BNC   8272
.................... 		{ 
....................  
.................... 		  aciona_saida(FERRO_SOLDA1); 
08254:  MOVLB  1
08256:  CLRF   xA1
08258:  MOVLW  03
0825A:  MOVWF  xA0
0825C:  MOVLB  0
0825E:  CALL   2FD2
....................           aciona_saida(FERRO_SOLDA2); 
08262:  MOVLB  1
08264:  CLRF   xA1
08266:  MOVLW  02
08268:  MOVWF  xA0
0826A:  MOVLB  0
0826C:  CALL   2FD2
....................           
....................  
....................  
.................... 	    }else{ 
08270:  BRA    829A
....................  
.................... 				 aciona_saida(FERRO_SOLDA2); 
08272:  MOVLB  1
08274:  CLRF   xA1
08276:  MOVLW  02
08278:  MOVWF  xA0
0827A:  MOVLB  0
0827C:  CALL   2FD2
08280:  CLRF   16
08282:  BTFSC  FF2.7
08284:  BSF    16.7
08286:  BCF    FF2.7
.................... 		         desaciona_saida(FERRO_SOLDA1); 
08288:  MOVLB  2
0828A:  CLRF   x1B
0828C:  MOVLW  03
0828E:  MOVWF  x1A
08290:  MOVLB  0
08292:  CALL   1B96
08296:  BTFSC  16.7
08298:  BSF    FF2.7
.................... 			 
.................... 	 
.................... 	         }	 
....................  
....................  
....................  
.................... 	  } 
....................  
....................  
....................  
....................  
.................... 	 
.................... 		delay_ms(500); 
0829A:  MOVLW  02
0829C:  MOVLB  1
0829E:  MOVWF  x99
082A0:  MOVLW  FA
082A2:  MOVLB  2
082A4:  MOVWF  x17
082A6:  MOVLB  0
082A8:  CALL   1D50
082AC:  MOVLB  1
082AE:  DECFSZ x99,F
082B0:  BRA    82A0
.................... 		go_z(coordenada_z_armazenado,velocity_z); 
082B2:  MOVFF  2F,19C
082B6:  MOVFF  2E,19B
082BA:  MOVLW  07
082BC:  MOVWF  x9E
082BE:  MOVLW  D0
082C0:  MOVWF  x9D
082C2:  MOVLB  0
082C4:  CALL   55F6
.................... 		 
....................  
.................... 	    posiciona_cursor(2,3); 
082C8:  MOVLW  02
082CA:  MOVLB  1
082CC:  MOVWF  xA5
082CE:  MOVLW  03
082D0:  MOVWF  xA6
082D2:  MOVLB  0
082D4:  CALL   1F92
.................... 		printf(lcd_putc,"%4Lu",contador_step_x); 
082D8:  MOVLW  01
082DA:  MOVWF  FE9
082DC:  MOVFF  179,19C
082E0:  MOVFF  178,19B
082E4:  CALL   5744
.................... 	    posiciona_cursor(3,3); 
082E8:  MOVLW  03
082EA:  MOVLB  1
082EC:  MOVWF  xA5
082EE:  MOVWF  xA6
082F0:  MOVLB  0
082F2:  CALL   1F92
.................... 		printf(lcd_putc,"%4Lu",contador_step_Y); 
082F6:  MOVLW  01
082F8:  MOVWF  FE9
082FA:  MOVFF  17B,19C
082FE:  MOVFF  17A,19B
08302:  CALL   5744
....................         posiciona_cursor(4,3); 
08306:  MOVLW  04
08308:  MOVLB  1
0830A:  MOVWF  xA5
0830C:  MOVLW  03
0830E:  MOVWF  xA6
08310:  MOVLB  0
08312:  CALL   1F92
.................... 		printf(lcd_putc,"%4LU",contador_step_z); 
08316:  MOVLW  01
08318:  MOVWF  FE9
0831A:  MOVFF  17F,19C
0831E:  MOVFF  17E,19B
08322:  CALL   5744
....................  
....................  
....................  
.................... 	while(true){	 
.................... 		key_code =  Teclado(); 
08326:  CALL   2344
0832A:  MOVFF  01,197
.................... 	 
.................... 		switch 	(key_code){ 
0832E:  MOVLB  1
08330:  MOVF   x97,W
08332:  XORLW  11
08334:  MOVLB  0
08336:  BZ    8368
08338:  XORLW  01
0833A:  BZ    83E2
0833C:  XORLW  1E
0833E:  BTFSC  FD8.2
08340:  BRA    845C
08342:  XORLW  01
08344:  BTFSC  FD8.2
08346:  BRA    84D4
08348:  XORLW  04
0834A:  BTFSC  FD8.2
0834C:  BRA    854C
0834E:  XORLW  06
08350:  BTFSC  FD8.2
08352:  BRA    85C6
08354:  XORLW  1E
08356:  BTFSC  FD8.2
08358:  BRA    8640
0835A:  XORLW  19
0835C:  BTFSC  FD8.2
0835E:  BRA    8718
08360:  XORLW  18
08362:  BTFSC  FD8.2
08364:  BRA    871A
08366:  BRA    8730
....................  
....................  
.................... 			case SETA_ESQUERDA:  
.................... 							direita(); 
08368:  CALL   32C4
.................... 							chopper_x(); 
0836C:  CALL   32BE
.................... 							delay_ms(100); 
08370:  MOVLW  64
08372:  MOVLB  2
08374:  MOVWF  x17
08376:  MOVLB  0
08378:  CALL   1D50
.................... 				 			while(Teclado() == SETA_ESQUERDA ) //S_X_DIREITA	 
0837C:  CALL   2344
08380:  MOVF   01,W
08382:  SUBLW  11
08384:  BNZ   83C8
.................... 							{ 
.................... 								if(le_Input(S_X_DIREITA) == false) 
08386:  MOVLW  05
08388:  MOVLB  1
0838A:  MOVWF  x9C
0838C:  MOVLB  0
0838E:  CALL   2C54
08392:  MOVF   01,F
08394:  BNZ   839A
.................... 								{ 
....................  
.................... 								  one_step_x(); 
08396:  CALL   32D2
....................  
.................... 								} 
.................... 								delay_us(8000); 
0839A:  MOVLW  08
0839C:  MOVLB  2
0839E:  MOVWF  x17
083A0:  MOVLB  0
083A2:  CALL   1D50
.................... 								posiciona_cursor(2,3); 
083A6:  MOVLW  02
083A8:  MOVLB  1
083AA:  MOVWF  xA5
083AC:  MOVLW  03
083AE:  MOVWF  xA6
083B0:  MOVLB  0
083B2:  CALL   1F92
.................... 							    printf(lcd_putc,"%4Lu",contador_step_x); 
083B6:  MOVLW  01
083B8:  MOVWF  FE9
083BA:  MOVFF  179,19C
083BE:  MOVFF  178,19B
083C2:  CALL   5744
083C6:  BRA    837C
.................... 	 
.................... 							}  
.................... 			 
.................... 	 						while(Teclado() != 0Xff){} 
083C8:  CALL   2344
083CC:  INCFSZ 01,W
083CE:  BRA    83D2
083D0:  BRA    83D4
083D2:  BRA    83C8
.................... 							delay_ms(50); 
083D4:  MOVLW  32
083D6:  MOVLB  2
083D8:  MOVWF  x17
083DA:  MOVLB  0
083DC:  CALL   1D50
.................... 						    break; 
083E0:  BRA    8730
....................  
.................... 	case SETA_DIREITA:      esquerda(); 
083E2:  CALL   3306
.................... 							chopper_x(); 
083E6:  CALL   32BE
.................... 							delay_ms(100); 
083EA:  MOVLW  64
083EC:  MOVLB  2
083EE:  MOVWF  x17
083F0:  MOVLB  0
083F2:  CALL   1D50
.................... 				 			while(Teclado() == SETA_DIREITA ) 
083F6:  CALL   2344
083FA:  MOVF   01,W
083FC:  SUBLW  10
083FE:  BNZ   8442
.................... 							{ 
.................... 								if(le_Input(S_X_ESQUERDA) == false) 
08400:  MOVLW  06
08402:  MOVLB  1
08404:  MOVWF  x9C
08406:  MOVLB  0
08408:  CALL   2C54
0840C:  MOVF   01,F
0840E:  BNZ   8414
.................... 								{ 
....................  
.................... 								   one_step_x(); 
08410:  CALL   32D2
....................  
.................... 								} 
.................... 						 
.................... 								delay_us(8000); 
08414:  MOVLW  08
08416:  MOVLB  2
08418:  MOVWF  x17
0841A:  MOVLB  0
0841C:  CALL   1D50
.................... 								posiciona_cursor(2,3); 
08420:  MOVLW  02
08422:  MOVLB  1
08424:  MOVWF  xA5
08426:  MOVLW  03
08428:  MOVWF  xA6
0842A:  MOVLB  0
0842C:  CALL   1F92
.................... 							    printf(lcd_putc,"%4Lu",contador_step_x); 
08430:  MOVLW  01
08432:  MOVWF  FE9
08434:  MOVFF  179,19C
08438:  MOVFF  178,19B
0843C:  CALL   5744
08440:  BRA    83F6
.................... 	 
....................  
....................  
.................... 							}  
.................... 			 
.................... 	 						while(Teclado() != 0xff){} 
08442:  CALL   2344
08446:  INCFSZ 01,W
08448:  BRA    844C
0844A:  BRA    844E
0844C:  BRA    8442
.................... 							delay_ms(50); 
0844E:  MOVLW  32
08450:  MOVLB  2
08452:  MOVWF  x17
08454:  MOVLB  0
08456:  CALL   1D50
....................  
.................... 						    break;  
0845A:  BRA    8730
....................  
....................  
.................... 	case SETA_SUPERIOR:  
.................... 							frente(); 
0845C:  CALL   3158
.................... 							chopper_y(); 
08460:  CALL   3152
.................... 							delay_ms(100); 
08464:  MOVLW  64
08466:  MOVLB  2
08468:  MOVWF  x17
0846A:  MOVLB  0
0846C:  CALL   1D50
.................... 				 			while(Teclado() == SETA_SUPERIOR) 	 
08470:  CALL   2344
08474:  MOVF   01,W
08476:  SUBLW  0E
08478:  BNZ   84BA
.................... 							{ 
.................... 								if(le_Input(S_Y_FRENTE) == false) 
0847A:  MOVLW  07
0847C:  MOVLB  1
0847E:  MOVWF  x9C
08480:  MOVLB  0
08482:  CALL   2C54
08486:  MOVF   01,F
08488:  BNZ   848E
.................... 								{ 
....................  
.................... 								  one_step_Y(); 
0848A:  CALL   3166
....................  
.................... 								} 
.................... 								delay_us(7000); 
0848E:  MOVLW  07
08490:  MOVLB  2
08492:  MOVWF  x17
08494:  MOVLB  0
08496:  CALL   1D50
.................... 								posiciona_cursor(3,3); 
0849A:  MOVLW  03
0849C:  MOVLB  1
0849E:  MOVWF  xA5
084A0:  MOVWF  xA6
084A2:  MOVLB  0
084A4:  CALL   1F92
.................... 							    printf(lcd_putc,"%4Lu",contador_step_Y); 
084A8:  MOVLW  01
084AA:  MOVWF  FE9
084AC:  MOVFF  17B,19C
084B0:  MOVFF  17A,19B
084B4:  CALL   5744
084B8:  BRA    8470
.................... 	 
.................... 							}  
.................... 			 
.................... 	 						while(Teclado() != 0Xff){} 
084BA:  CALL   2344
084BE:  INCFSZ 01,W
084C0:  BRA    84C4
084C2:  BRA    84C6
084C4:  BRA    84BA
.................... 							delay_ms(50); 
084C6:  MOVLW  32
084C8:  MOVLB  2
084CA:  MOVWF  x17
084CC:  MOVLB  0
084CE:  CALL   1D50
....................  
.................... 						break; 
084D2:  BRA    8730
....................  
.................... 	case SETA_INFERIOR:  
.................... 							atras(); 
084D4:  CALL   319A
.................... 							chopper_y(); 
084D8:  CALL   3152
.................... 							delay_ms(100); 
084DC:  MOVLW  64
084DE:  MOVLB  2
084E0:  MOVWF  x17
084E2:  MOVLB  0
084E4:  CALL   1D50
.................... 				 			while(Teclado() == SETA_INFERIOR) //S_X_DIREITA	 
084E8:  CALL   2344
084EC:  MOVF   01,W
084EE:  SUBLW  0F
084F0:  BNZ   8532
.................... 							{ 
.................... 								if(le_Input(S_Y_ATRAS) == false) 
084F2:  MOVLW  08
084F4:  MOVLB  1
084F6:  MOVWF  x9C
084F8:  MOVLB  0
084FA:  CALL   2C54
084FE:  MOVF   01,F
08500:  BNZ   8506
.................... 								{ 
....................  
.................... 								  one_step_Y(); 
08502:  CALL   3166
....................  
.................... 								} 
.................... 								delay_us(8000); 
08506:  MOVLW  08
08508:  MOVLB  2
0850A:  MOVWF  x17
0850C:  MOVLB  0
0850E:  CALL   1D50
.................... 								posiciona_cursor(3,3); 
08512:  MOVLW  03
08514:  MOVLB  1
08516:  MOVWF  xA5
08518:  MOVWF  xA6
0851A:  MOVLB  0
0851C:  CALL   1F92
.................... 							    printf(lcd_putc,"%4Lu",contador_step_Y); 
08520:  MOVLW  01
08522:  MOVWF  FE9
08524:  MOVFF  17B,19C
08528:  MOVFF  17A,19B
0852C:  CALL   5744
08530:  BRA    84E8
.................... 	 
.................... 							}  
.................... 			 
.................... 	 						while(Teclado() != 0Xff){} 
08532:  CALL   2344
08536:  INCFSZ 01,W
08538:  BRA    853C
0853A:  BRA    853E
0853C:  BRA    8532
.................... 							delay_ms(50); 
0853E:  MOVLW  32
08540:  MOVLB  2
08542:  MOVWF  x17
08544:  MOVLB  0
08546:  CALL   1D50
.................... 							break; 
0854A:  BRA    8730
....................  
....................         case    F2:         sobe(); 
0854C:  CALL   2ECC
.................... 							chopper_z(); 
08550:  CALL   2C0C
.................... 							delay_ms(100); 
08554:  MOVLW  64
08556:  MOVLB  2
08558:  MOVWF  x17
0855A:  MOVLB  0
0855C:  CALL   1D50
.................... 				 			while(Teclado() == F2) 
08560:  CALL   2344
08564:  MOVF   01,W
08566:  SUBLW  0B
08568:  BNZ   85AC
.................... 							{ 
.................... 									if(le_Input(S_Z_TOP) == false) 
0856A:  MOVLW  0D
0856C:  MOVLB  1
0856E:  MOVWF  x9C
08570:  MOVLB  0
08572:  CALL   2C54
08576:  MOVF   01,F
08578:  BNZ   857E
.................... 								{ 
....................   
....................  									one_step_z(); 
0857A:  CALL   2E98
....................  
....................  
.................... 								} 
.................... 								 
.................... 								delay_us(8000); 
0857E:  MOVLW  08
08580:  MOVLB  2
08582:  MOVWF  x17
08584:  MOVLB  0
08586:  CALL   1D50
.................... 								posiciona_cursor(4,3); 
0858A:  MOVLW  04
0858C:  MOVLB  1
0858E:  MOVWF  xA5
08590:  MOVLW  03
08592:  MOVWF  xA6
08594:  MOVLB  0
08596:  CALL   1F92
.................... 							    printf(lcd_putc,"%4LU",contador_step_z); 
0859A:  MOVLW  01
0859C:  MOVWF  FE9
0859E:  MOVFF  17F,19C
085A2:  MOVFF  17E,19B
085A6:  CALL   5744
085AA:  BRA    8560
.................... 	 
.................... 							}  
.................... 			 
.................... 	 						while(Teclado() != 0Xff){} 
085AC:  CALL   2344
085B0:  INCFSZ 01,W
085B2:  BRA    85B6
085B4:  BRA    85B8
085B6:  BRA    85AC
.................... 							delay_ms(50); 
085B8:  MOVLW  32
085BA:  MOVLB  2
085BC:  MOVWF  x17
085BE:  MOVLB  0
085C0:  CALL   1D50
.................... 						    break; 
085C4:  BRA    8730
....................  
....................  
....................         case    F4:         desce(); 
085C6:  CALL   2E8A
.................... 							chopper_z(); 
085CA:  CALL   2C0C
.................... 							delay_ms(100); 
085CE:  MOVLW  64
085D0:  MOVLB  2
085D2:  MOVWF  x17
085D4:  MOVLB  0
085D6:  CALL   1D50
.................... 				 			while(Teclado() == F4 ) 
085DA:  CALL   2344
085DE:  MOVF   01,W
085E0:  SUBLW  0D
085E2:  BNZ   8626
.................... 							{ 
....................  
.................... 									if(le_Input(S_Z_BOTTOM) == false) 
085E4:  MOVLW  0E
085E6:  MOVLB  1
085E8:  MOVWF  x9C
085EA:  MOVLB  0
085EC:  CALL   2C54
085F0:  MOVF   01,F
085F2:  BNZ   85F8
.................... 									{ 
....................   
....................  									    one_step_z(); 
085F4:  CALL   2E98
....................  
....................  
.................... 								    } 
.................... 								 
.................... 								delay_us(8000); 
085F8:  MOVLW  08
085FA:  MOVLB  2
085FC:  MOVWF  x17
085FE:  MOVLB  0
08600:  CALL   1D50
.................... 								posiciona_cursor(4,3); 
08604:  MOVLW  04
08606:  MOVLB  1
08608:  MOVWF  xA5
0860A:  MOVLW  03
0860C:  MOVWF  xA6
0860E:  MOVLB  0
08610:  CALL   1F92
.................... 							    printf(lcd_putc,"%4LU",contador_step_z); 
08614:  MOVLW  01
08616:  MOVWF  FE9
08618:  MOVFF  17F,19C
0861C:  MOVFF  17E,19B
08620:  CALL   5744
08624:  BRA    85DA
.................... 	 
.................... 							}  
.................... 			 
.................... 	 						while(Teclado() != 0Xff){} 
08626:  CALL   2344
0862A:  INCFSZ 01,W
0862C:  BRA    8630
0862E:  BRA    8632
08630:  BRA    8626
.................... 							delay_ms(50);  
08632:  MOVLW  32
08634:  MOVLB  2
08636:  MOVWF  x17
08638:  MOVLB  0
0863A:  CALL   1D50
.................... 							break; 
0863E:  BRA    8730
....................  
....................  
.................... 		case ENTER:			 
.................... 						limpa_display(); 
08640:  CALL   1F7C
....................  						posiciona_cursor(1,1); 
08644:  MOVLW  01
08646:  MOVLB  1
08648:  MOVWF  xA5
0864A:  MOVWF  xA6
0864C:  MOVLB  0
0864E:  CALL   1F92
.................... 						display("TEM CERTEZA?"); 
08652:  MOVLW  D6
08654:  MOVWF  FF6
08656:  MOVLW  0B
08658:  MOVWF  FF7
0865A:  CALL   1FF2
.................... 						posiciona_cursor(2,1); 
0865E:  MOVLW  02
08660:  MOVLB  1
08662:  MOVWF  xA5
08664:  MOVLW  01
08666:  MOVWF  xA6
08668:  MOVLB  0
0866A:  CALL   1F92
.................... 						display("F1=SIM"); 
0866E:  MOVLW  E4
08670:  MOVWF  FF6
08672:  MOVLW  0B
08674:  MOVWF  FF7
08676:  CALL   1FF2
.................... 						posiciona_cursor(3,1); 
0867A:  MOVLW  03
0867C:  MOVLB  1
0867E:  MOVWF  xA5
08680:  MOVLW  01
08682:  MOVWF  xA6
08684:  MOVLB  0
08686:  CALL   1F92
.................... 						display("F2=NAO"); 
0868A:  MOVLW  EC
0868C:  MOVWF  FF6
0868E:  MOVLW  0B
08690:  MOVWF  FF7
08692:  CALL   1FF2
.................... 						espera_desacionar_teclas(); 
08696:  RCALL  7FCA
.................... 						delay_ms(100); 
08698:  MOVLW  64
0869A:  MOVLB  2
0869C:  MOVWF  x17
0869E:  MOVLB  0
086A0:  CALL   1D50
.................... 						while(1){ 
....................  
.................... 							 if(teclado() == F1) 
086A4:  CALL   2344
086A8:  MOVF   01,W
086AA:  SUBLW  0A
086AC:  BNZ   8706
.................... 						 			{ 
.................... 						  			 
.................... 										grava_coordenada_na_eeprom(passo,contador_step_x,contador_step_y,contador_step_z);	 
086AE:  MOVFF  54,199
086B2:  MOVFF  179,19B
086B6:  MOVFF  178,19A
086BA:  MOVFF  17B,19D
086BE:  MOVFF  17A,19C
086C2:  MOVFF  17F,19F
086C6:  MOVFF  17E,19E
086CA:  BRA    7FF2
.................... 										limpa_display(); 
086CC:  CALL   1F7C
....................  										posiciona_cursor(1,1); 
086D0:  MOVLW  01
086D2:  MOVLB  1
086D4:  MOVWF  xA5
086D6:  MOVWF  xA6
086D8:  MOVLB  0
086DA:  CALL   1F92
.................... 										display("COORD. FORAM SALVAS"); 
086DE:  MOVLW  F4
086E0:  MOVWF  FF6
086E2:  MOVLW  0B
086E4:  MOVWF  FF7
086E6:  CALL   1FF2
.................... 										delay_ms(1000); 
086EA:  MOVLW  04
086EC:  MOVLB  1
086EE:  MOVWF  x99
086F0:  MOVLW  FA
086F2:  MOVLB  2
086F4:  MOVWF  x17
086F6:  MOVLB  0
086F8:  CALL   1D50
086FC:  MOVLB  1
086FE:  DECFSZ x99,F
08700:  BRA    86F0
.................... 										return; 
08702:  BRA    8752
08704:  MOVLB  0
.................... 									 
.................... 									} 
....................  
....................  
.................... 							  if(teclado() == F2) 
08706:  CALL   2344
0870A:  MOVF   01,W
0870C:  SUBLW  0B
0870E:  BNZ   8714
.................... 						 			{ 
.................... 						  				 
.................... 									    display_edita_ponto(); 
08710:  RCALL  7F8C
.................... 										break; 
08712:  BRA    8716
.................... 									 
.................... 									} 
08714:  BRA    86A4
....................  
....................  
....................  
....................  
.................... 							} 
....................  
....................  
.................... 					        break; 
08716:  BRA    8730
....................  
....................  
....................  
.................... 		case F1:    //solda_mola(1); 
....................                     break; 
08718:  BRA    8730
....................  
....................  
.................... 				 
.................... 		case ESC:    
.................... 						  
.................... 					espera_desacionar_teclas(); 
0871A:  RCALL  7FCA
.................... 					delay_ms(100); 
0871C:  MOVLW  64
0871E:  MOVLB  2
08720:  MOVWF  x17
08722:  MOVLB  0
08724:  CALL   1D50
....................                     return; 
08728:  MOVLB  1
0872A:  BRA    8752
....................  
.................... 				    break; 
0872C:  MOVLB  0
0872E:  BRA    8730
....................  
.................... 	 
....................  
.................... 		default: 
.................... 					break; 
.................... 		} 
....................  
.................... 	 if(key_code == ESC) break;		 
08730:  MOVLB  1
08732:  MOVF   x97,W
08734:  SUBLW  12
08736:  BTFSC  FD8.2
08738:  BRA    8740
0873A:  MOVLB  0
0873C:  BRA    8326
0873E:  MOVLB  1
....................  
....................  
.................... 	} 
....................  
.................... 	espera_desacionar_teclas(); 
08740:  MOVLB  0
08742:  RCALL  7FCA
.................... 	delay_ms(100); 
08744:  MOVLW  64
08746:  MOVLB  2
08748:  MOVWF  x17
0874A:  MOVLB  0
0874C:  CALL   1D50
08750:  MOVLB  1
08752:  MOVLB  0
08754:  GOTO   8A9E (RETURN)
.................... } 
....................  
....................  
.................... void menu_edita_pontos(void) 
*
08826:  MOVLB  1
08828:  CLRF   x8D
0882A:  MOVLW  01
0882C:  MOVWF  x8E
0882E:  MOVLW  04
08830:  MOVWF  x8F
08832:  CLRF   x90
08834:  CLRF   x93
08836:  CLRF   16
08838:  BTFSC  FF2.7
0883A:  BSF    16.7
0883C:  BCF    FF2.7
.................... { 
.................... 	int key_code = 0; 
....................     int cursor_line = 1;           // posicao do cursor no display pode  ser de 1 até 4 
....................     int numero_max_linhas = 4;     // numero maximo de linhas do display 
....................     int indexador_ponto = 0;  
.................... 	int i;	 
.................... 	int n_ponto; 
....................     int erro = 0; 
....................  
....................     desaciona_saida(RELE_ESTEIRA); 
0883E:  MOVLB  2
08840:  CLRF   x1B
08842:  MOVLW  0A
08844:  MOVWF  x1A
08846:  MOVLB  0
08848:  CALL   1B96
0884C:  BTFSC  16.7
0884E:  BSF    FF2.7
.................... 	if(n_maquina == 1) 
08850:  DECFSZ 1D,W
08852:  BRA    8908
.................... 	{ 
....................         
.................... 		printf(lcd_putc,"\f"); 						   //limpa display 
08854:  MOVLW  0C
08856:  MOVLB  1
08858:  MOVWF  xA4
0885A:  MOVLB  0
0885C:  CALL   2586
....................    		printf(lcd_putc,"POSICIONE A PLACA   \n\r"); 
08860:  MOVLW  08
08862:  MOVWF  FF6
08864:  MOVLW  0C
08866:  MOVWF  FF7
08868:  CALL   25DA
.................... 		printf(lcd_putc,"E PRESS ENTER       \n\r"); 
0886C:  MOVLW  20
0886E:  MOVWF  FF6
08870:  MOVLW  0C
08872:  MOVWF  FF7
08874:  CALL   25DA
.................... 		printf(lcd_putc,"PARA ALIMENTAR      \n\r"); 
08878:  MOVLW  38
0887A:  MOVWF  FF6
0887C:  MOVLW  0C
0887E:  MOVWF  FF7
08880:  CALL   25DA
.................... 		printf(lcd_putc,"                    \n\r"); 
08884:  MOVLW  50
08886:  MOVWF  FF6
08888:  MOVLW  0C
0888A:  MOVWF  FF7
0888C:  CALL   25DA
....................  
....................  
....................          
.................... 	 
.................... 		while(1) 
.................... 		{ 
.................... 			 
....................  
.................... 			key_code =  Teclado(); 
08890:  CALL   2344
08894:  MOVFF  01,18D
....................             if(key_code == ESC)  
08898:  MOVLB  1
0889A:  MOVF   x8D,W
0889C:  SUBLW  12
0889E:  BNZ   88B0
.................... 			{ 
.................... 			   delay_ms(100);	  
088A0:  MOVLW  64
088A2:  MOVLB  2
088A4:  MOVWF  x17
088A6:  MOVLB  0
088A8:  CALL   1D50
.................... 			   return; 
088AC:  BRA    8C8A
088AE:  MOVLB  1
....................  
.................... 			} 
....................  
....................  		    if(key_code == ENTER) break; 
088B0:  MOVF   x8D,W
088B2:  SUBLW  13
088B4:  BTFSC  FD8.2
088B6:  BRA    88BE
088B8:  MOVLB  0
088BA:  BRA    8890
088BC:  MOVLB  1
....................  
.................... 		} 
....................  
.................... 		if(input(in25_bit) == 1)  aciona_saida(RELE_ESTEIRA); 
088BE:  BSF    F93.1
088C0:  BTFSS  F81.1
088C2:  BRA    88D2
088C4:  CLRF   xA1
088C6:  MOVLW  0A
088C8:  MOVWF  xA0
088CA:  MOVLB  0
088CC:  CALL   2FD2
088D0:  MOVLB  1
.................... 		 
....................  
.................... 		envia_posicao_para_maquina2(STOP); 
088D2:  MOVLW  07
088D4:  MOVWF  x9A
088D6:  MOVLB  0
088D8:  CALL   39AC
....................  
....................  
.................... 	while(input(in25_bit) == 1){} 
088DC:  BSF    F93.1
088DE:  BTFSC  F81.1
088E0:  BRA    88DC
088E2:  CLRF   16
088E4:  BTFSC  FF2.7
088E6:  BSF    16.7
088E8:  BCF    FF2.7
....................  
....................      desaciona_saida(RELE_ESTEIRA); 
088EA:  MOVLB  2
088EC:  CLRF   x1B
088EE:  MOVLW  0A
088F0:  MOVWF  x1A
088F2:  MOVLB  0
088F4:  CALL   1B96
088F8:  BTFSC  16.7
088FA:  BSF    FF2.7
....................  
....................  
....................  
.................... 	maquina_estados1(MODO_EDITA_PONTOS);  
088FC:  MOVLW  01
088FE:  MOVLB  1
08900:  MOVWF  x94
08902:  MOVLB  0
08904:  CALL   7A48
....................  
....................      
....................  
....................  } 
....................  
....................  
.................... 	if(n_maquina == 2) 
08908:  MOVF   1D,W
0890A:  SUBLW  02
0890C:  BTFSS  FD8.2
0890E:  BRA    8A3C
.................... 	{ 
....................  
.................... 		envia_posicao_para_maquina1(STOP); 
08910:  MOVLW  07
08912:  MOVLB  1
08914:  MOVWF  x9A
08916:  MOVLB  0
08918:  CALL   50A4
....................  
....................    while(le_posicao_da_maquina1() != POSICAO_HOME1) 
0891C:  CALL   7C1C
08920:  MOVF   01,F
08922:  BZ    894E
.................... 	{ 
....................  
.................... 		posiciona_cursor(3,1); 
08924:  MOVLW  03
08926:  MOVLB  1
08928:  MOVWF  xA5
0892A:  MOVLW  01
0892C:  MOVWF  xA6
0892E:  MOVLB  0
08930:  CALL   1F92
....................     	printf(lcd_putc,"ESPERANDO  MAQUINA1\n\r"); 
08934:  MOVLW  68
08936:  MOVWF  FF6
08938:  MOVLW  0C
0893A:  MOVWF  FF7
0893C:  CALL   25DA
.................... 		printf(lcd_putc,"IR PARA HOME1      ");	  	 
08940:  MOVLW  7E
08942:  MOVWF  FF6
08944:  MOVLW  0C
08946:  MOVWF  FF7
08948:  CALL   25DA
0894C:  BRA    891C
....................    
....................  
....................     } 
....................  
.................... 	if(le_Input( S_Y_ESQUERDA_PROT ) != true)  erro_rot(10);// p/ protecao  
0894E:  MOVLW  0A
08950:  MOVLB  1
08952:  MOVWF  x9C
08954:  MOVLB  0
08956:  CALL   2C54
0895A:  DECFSZ 01,W
0895C:  BRA    8960
0895E:  BRA    896C
08960:  MOVLW  0A
08962:  MOVLB  1
08964:  MOVWF  xA0
08966:  MOVLB  0
08968:  CALL   3B1C
....................  
....................  
.................... 	    posicao_alimentacao_placa(MAQUINA2); 
0896C:  MOVLW  02
0896E:  MOVLB  1
08970:  MOVWF  x95
08972:  MOVLB  0
08974:  CALL   77C6
08978:  CLRF   16
0897A:  BTFSC  FF2.7
0897C:  BSF    16.7
0897E:  BCF    FF2.7
....................  
.................... 		desaciona_saida(RELE_ESTEIRA); 
08980:  MOVLB  2
08982:  CLRF   x1B
08984:  MOVLW  0A
08986:  MOVWF  x1A
08988:  MOVLB  0
0898A:  CALL   1B96
0898E:  BTFSC  16.7
08990:  BSF    FF2.7
....................         
.................... 		printf(lcd_putc,"\f"); 						   //limpa display 
08992:  MOVLW  0C
08994:  MOVLB  1
08996:  MOVWF  xA4
08998:  MOVLB  0
0899A:  CALL   2586
....................    		printf(lcd_putc,"POSICIONE A PLACA   \n\r"); 
0899E:  MOVLW  92
089A0:  MOVWF  FF6
089A2:  MOVLW  0C
089A4:  MOVWF  FF7
089A6:  CALL   25DA
.................... 		printf(lcd_putc,"E PRESS ENTER       \n\r"); 
089AA:  MOVLW  AA
089AC:  MOVWF  FF6
089AE:  MOVLW  0C
089B0:  MOVWF  FF7
089B2:  CALL   25DA
.................... 		printf(lcd_putc,"PARA ALIMENTAR      \n\r"); 
089B6:  MOVLW  C2
089B8:  MOVWF  FF6
089BA:  MOVLW  0C
089BC:  MOVWF  FF7
089BE:  CALL   25DA
.................... 		printf(lcd_putc,"                    \n\r"); 
089C2:  MOVLW  DA
089C4:  MOVWF  FF6
089C6:  MOVLW  0C
089C8:  MOVWF  FF7
089CA:  CALL   25DA
....................         
.................... 		while(1) 
.................... 		{ 
.................... 			key_code =  Teclado(); 
089CE:  CALL   2344
089D2:  MOVFF  01,18D
....................             if(key_code == ESC)  
089D6:  MOVLB  1
089D8:  MOVF   x8D,W
089DA:  SUBLW  12
089DC:  BNZ   89EE
.................... 			{ 
.................... 			   delay_ms(100);	  
089DE:  MOVLW  64
089E0:  MOVLB  2
089E2:  MOVWF  x17
089E4:  MOVLB  0
089E6:  CALL   1D50
.................... 			   return; 
089EA:  BRA    8C8A
089EC:  MOVLB  1
....................  
.................... 			} 
....................  
....................  		    if(key_code == ENTER) break; 
089EE:  MOVF   x8D,W
089F0:  SUBLW  13
089F2:  BTFSC  FD8.2
089F4:  BRA    89FC
089F6:  MOVLB  0
089F8:  BRA    89CE
089FA:  MOVLB  1
....................  
.................... 		} 
....................  
.................... 		if(input(in25_bit) == 1)  aciona_saida(RELE_ESTEIRA); 
089FC:  BSF    F93.1
089FE:  BTFSS  F81.1
08A00:  BRA    8A10
08A02:  CLRF   xA1
08A04:  MOVLW  0A
08A06:  MOVWF  xA0
08A08:  MOVLB  0
08A0A:  CALL   2FD2
08A0E:  MOVLB  1
.................... 		 
....................  
.................... 	 
.................... 	    while(input(in25_bit) == 1){} 
08A10:  BSF    F93.1
08A12:  BTFSC  F81.1
08A14:  BRA    8A10
08A16:  CLRF   16
08A18:  BTFSC  FF2.7
08A1A:  BSF    16.7
08A1C:  BCF    FF2.7
....................  
....................         desaciona_saida(RELE_ESTEIRA); 
08A1E:  MOVLB  2
08A20:  CLRF   x1B
08A22:  MOVLW  0A
08A24:  MOVWF  x1A
08A26:  MOVLB  0
08A28:  CALL   1B96
08A2C:  BTFSC  16.7
08A2E:  BSF    FF2.7
....................  
....................  
.................... 	    maquina_estados2(MODO_EDITA_PONTOS); 		 
08A30:  MOVLW  01
08A32:  MOVLB  1
08A34:  MOVWF  x94
08A36:  MOVLB  0
08A38:  CALL   7D34
....................  
.................... 	 
.................... 	} 
....................  
....................  
....................     display_menu_edita_pontos(); 
08A3C:  CALL   7EF4
....................  
.................... 	atualiza_pontos(0);	 
08A40:  MOVLB  1
08A42:  CLRF   x94
08A44:  MOVLB  0
08A46:  CALL   7F32
....................     posiciona_cursor(1,4); 
08A4A:  MOVLW  01
08A4C:  MOVLB  1
08A4E:  MOVWF  xA5
08A50:  MOVLW  04
08A52:  MOVWF  xA6
08A54:  MOVLB  0
08A56:  CALL   1F92
.................... 	printf(lcd_putc,"<--");	  
08A5A:  MOVLW  F2
08A5C:  MOVWF  FF6
08A5E:  MOVLW  0C
08A60:  MOVWF  FF7
08A62:  CALL   25DA
....................  
....................  
.................... 	while(true){	 
.................... 		key_code =  Teclado(); 
08A66:  CALL   2344
08A6A:  MOVFF  01,18D
.................... 	 
.................... 		switch 	(key_code){ 
08A6E:  MOVLB  1
08A70:  MOVF   x8D,W
08A72:  XORLW  13
08A74:  MOVLB  0
08A76:  BZ    8A92
08A78:  XORLW  19
08A7A:  BZ    8AC8
08A7C:  XORLW  01
08A7E:  BZ    8ACA
08A80:  XORLW  07
08A82:  BZ    8ACC
08A84:  XORLW  01
08A86:  BZ    8ACE
08A88:  XORLW  03
08A8A:  BZ    8AD0
08A8C:  XORLW  01
08A8E:  BZ    8B32
08A90:  BRA    8B92
....................  
.................... 		case ENTER: edita_ponto(cursor_line,indexador_ponto); 
08A92:  MOVFF  18E,194
08A96:  MOVFF  190,195
08A9A:  GOTO   8100
....................                     display_menu_edita_pontos(); 
08A9E:  CALL   7EF4
.................... 					atualiza_pontos(indexador_ponto); 
08AA2:  MOVFF  190,194
08AA6:  CALL   7F32
....................                  	posiciona_cursor(cursor_line,4);   // atualiza cursor 
08AAA:  MOVFF  18E,1A5
08AAE:  MOVLW  04
08AB0:  MOVLB  1
08AB2:  MOVWF  xA6
08AB4:  MOVLB  0
08AB6:  CALL   1F92
.................... 					printf(lcd_putc,"<--"); 
08ABA:  MOVLW  F6
08ABC:  MOVWF  FF6
08ABE:  MOVLW  0C
08AC0:  MOVWF  FF7
08AC2:  CALL   25DA
.................... 					break;	 
08AC6:  BRA    8B92
.................... 				 
.................... 	  case F1:	    /* 
.................... 					if(n_maquina == 1) aciona_saida(FERRO_SOLDA2); 
.................... 		            if(n_maquina == 2)  
.................... 					{ 
.................... 						aciona_saida(FERRO_SOLDA1); 
....................      					aciona_saida(FERRO_SOLDA2); 
....................  
.................... 					}		 
.................... 					delay_ms(500); 
.................... 					//go_z(150,velocity_z); 
.................... 					solda_placa_default(); 
.................... 					display_menu_edita_pontos(); 
.................... 					atualiza_pontos(indexador_ponto); 
....................                  	posiciona_cursor(cursor_line,4);   // atualiza cursor 
.................... 					printf(lcd_putc,"<--"); 
....................  
.................... 				    //cria_ponto(cursor_line,indexador_ponto); 
.................... 					*/ 
.................... 					break; 
08AC8:  BRA    8B92
.................... 		case F2:	 
.................... 				    //cria_ponto(cursor_line,indexador_ponto); 
.................... 					break; 
08ACA:  BRA    8B92
....................  
....................  
.................... 		case F3:	//deleta_ponto(); 
.................... 					break; 
08ACC:  BRA    8B92
....................  
....................         case F4:    /* 
.................... 					n_ponto = (cursor_line + indexador_ponto); 
....................                     passo =  n_ponto - 1; 
.................... 				    if(tipo_soldagem[passo] == 0) 
.................... 		     	    { 
.................... 						//solda_terminal();	                  
....................    					 
.................... 		            }			 
....................  
.................... 					if(tipo_soldagem[passo] == 1) 
.................... 		     	    { 
.................... 						solda_mola(1);	                  
....................    					 
.................... 		            } 
.................... 					*/ 
.................... 					break; 
08ACE:  BRA    8B92
....................  
.................... 		case SETA_SUPERIOR: 
.................... 								if(cursor_line == 1) 
08AD0:  MOVLB  1
08AD2:  DECFSZ x8E,W
08AD4:  BRA    8AF8
.................... 								{ 
.................... 									if(indexador_ponto == 0) 
08AD6:  MOVF   x90,F
08AD8:  BNZ   8AE8
.................... 									{  
.................... 										atualiza_pontos(indexador_ponto);    // se n_ponto for 1 atualiza a tela do display 
08ADA:  MOVFF  190,194
08ADE:  MOVLB  0
08AE0:  CALL   7F32
....................  
.................... 									}else{ 
08AE4:  BRA    8AF4
08AE6:  MOVLB  1
.................... 											indexador_ponto--;	            //  se nao for 1 decrementa e atualiza a tela do display 
08AE8:  DECF   x90,F
.................... 											atualiza_pontos(indexador_ponto); 
08AEA:  MOVFF  190,194
08AEE:  MOVLB  0
08AF0:  CALL   7F32
....................  
.................... 								         }	  
.................... 								 
.................... 								}else{ 
08AF4:  BRA    8B30
08AF6:  MOVLB  1
....................  
.................... 										posiciona_cursor(cursor_line,4); 
08AF8:  MOVFF  18E,1A5
08AFC:  MOVLW  04
08AFE:  MOVWF  xA6
08B00:  MOVLB  0
08B02:  CALL   1F92
.................... 										printf(lcd_putc,"   "); 			// apaga cursor da linha anterior 
08B06:  MOVLW  FA
08B08:  MOVWF  FF6
08B0A:  MOVLW  0C
08B0C:  MOVWF  FF7
08B0E:  CALL   25DA
.................... 										cursor_line--; 
08B12:  MOVLB  1
08B14:  DECF   x8E,F
.................... 										posiciona_cursor(cursor_line,4);   // atualiza cursor 
08B16:  MOVFF  18E,1A5
08B1A:  MOVLW  04
08B1C:  MOVWF  xA6
08B1E:  MOVLB  0
08B20:  CALL   1F92
.................... 										printf(lcd_putc,"<--"); 
08B24:  MOVLW  FE
08B26:  MOVWF  FF6
08B28:  MOVLW  0C
08B2A:  MOVWF  FF7
08B2C:  CALL   25DA
.................... 																		 
....................  
.................... 								    } 
.................... 								 
....................      								 			 
.................... 								break;		 
08B30:  BRA    8B92
....................  
....................  
.................... 	   case SETA_INFERIOR:    
.................... 								if(indexador_ponto >=  (numero_pontos - 4)) break; 
08B32:  MOVLW  04
08B34:  SUBWF  26,W
08B36:  MOVLB  1
08B38:  SUBWF  x90,W
08B3A:  BNC   8B42
08B3C:  MOVLB  0
08B3E:  BRA    8B92
08B40:  MOVLB  1
.................... 							  	if(cursor_line == 4) 
08B42:  MOVF   x8E,W
08B44:  SUBLW  04
08B46:  BNZ   8B58
.................... 								{ 
.................... 									 
.................... 											indexador_ponto++;	            //  se nao for 4 incrementa e atualiza a tela do display 
08B48:  INCF   x90,F
.................... 											atualiza_pontos(indexador_ponto); 
08B4A:  MOVFF  190,194
08B4E:  MOVLB  0
08B50:  CALL   7F32
.................... 									  
.................... 										  
.................... 								 
.................... 								}else{ 
08B54:  BRA    8B90
08B56:  MOVLB  1
....................  
.................... 										posiciona_cursor(cursor_line,4); 
08B58:  MOVFF  18E,1A5
08B5C:  MOVLW  04
08B5E:  MOVWF  xA6
08B60:  MOVLB  0
08B62:  CALL   1F92
.................... 										printf(lcd_putc,"   "); 			// apaga cursor da linha anterior 
08B66:  MOVLW  02
08B68:  MOVWF  FF6
08B6A:  MOVLW  0D
08B6C:  MOVWF  FF7
08B6E:  CALL   25DA
.................... 										cursor_line++; 
08B72:  MOVLB  1
08B74:  INCF   x8E,F
.................... 										posiciona_cursor(cursor_line,4);   // atualiza cursor 
08B76:  MOVFF  18E,1A5
08B7A:  MOVLW  04
08B7C:  MOVWF  xA6
08B7E:  MOVLB  0
08B80:  CALL   1F92
.................... 										printf(lcd_putc,"<--"); 
08B84:  MOVLW  06
08B86:  MOVWF  FF6
08B88:  MOVLW  0D
08B8A:  MOVWF  FF7
08B8C:  CALL   25DA
.................... 																		 
....................  
.................... 								    } 
....................  
....................  
.................... 					     		break; 
08B90:  BRA    8B92
.................... 			 
....................  
....................         default: 
.................... 					break;	 
....................  
.................... 				} 
....................  
.................... 		if(key_code == ESC) break; 
08B92:  MOVLB  1
08B94:  MOVF   x8D,W
08B96:  SUBLW  12
08B98:  BTFSC  FD8.2
08B9A:  BRA    8BAC
.................... 		delay_ms(200); 
08B9C:  MOVLW  C8
08B9E:  MOVLB  2
08BA0:  MOVWF  x17
08BA2:  MOVLB  0
08BA4:  CALL   1D50
08BA8:  BRA    8A66
08BAA:  MOVLB  1
....................  
.................... 	   }	 
....................  
....................     
....................  
....................     if(n_maquina == 1) 
08BAC:  DECFSZ 1D,W
08BAE:  BRA    8C12
08BB0:  CLRF   16
08BB2:  BTFSC  FF2.7
08BB4:  BSF    16.7
08BB6:  BCF    FF2.7
.................... 	{ 
....................  
....................  		desaciona_saida(FERRO_SOLDA1); 
08BB8:  MOVLB  2
08BBA:  CLRF   x1B
08BBC:  MOVLW  03
08BBE:  MOVWF  x1A
08BC0:  MOVLB  0
08BC2:  CALL   1B96
08BC6:  BTFSC  16.7
08BC8:  BSF    FF2.7
08BCA:  CLRF   16
08BCC:  BTFSC  FF2.7
08BCE:  BSF    16.7
08BD0:  BCF    FF2.7
....................     	desaciona_saida(FERRO_SOLDA2);	 
08BD2:  MOVLB  2
08BD4:  CLRF   x1B
08BD6:  MOVLW  02
08BD8:  MOVWF  x1A
08BDA:  MOVLB  0
08BDC:  CALL   1B96
08BE0:  BTFSC  16.7
08BE2:  BSF    FF2.7
....................  
.................... 		printf(lcd_putc,"\f"); 						   //limpa display 
08BE4:  MOVLW  0C
08BE6:  MOVLB  1
08BE8:  MOVWF  xA4
08BEA:  MOVLB  0
08BEC:  CALL   2586
....................    	    printf(lcd_putc,"INDO PARA POSICAO   \n\r"); 
08BF0:  MOVLW  0A
08BF2:  MOVWF  FF6
08BF4:  MOVLW  0D
08BF6:  MOVWF  FF7
08BF8:  CALL   25DA
....................         printf(lcd_putc,"DE ALIMENTACAO      \n\r"); 
08BFC:  MOVLW  22
08BFE:  MOVWF  FF6
08C00:  MOVLW  0D
08C02:  MOVWF  FF7
08C04:  CALL   25DA
....................         desaciona_todas_saidas(); 
08C08:  CALL   1EB0
....................  
....................  
....................     	home_maquina_1(); 
08C0C:  CALL   39DC
08C10:  MOVLB  1
....................  
.................... 	} 
....................  
....................  if(n_maquina == 2) 
08C12:  MOVF   1D,W
08C14:  SUBLW  02
08C16:  BNZ   8C78
08C18:  CLRF   16
08C1A:  BTFSC  FF2.7
08C1C:  BSF    16.7
08C1E:  BCF    FF2.7
.................... 	{ 
....................  
....................  		desaciona_saida(FERRO_SOLDA1); 
08C20:  MOVLB  2
08C22:  CLRF   x1B
08C24:  MOVLW  03
08C26:  MOVWF  x1A
08C28:  MOVLB  0
08C2A:  CALL   1B96
08C2E:  BTFSC  16.7
08C30:  BSF    FF2.7
08C32:  CLRF   16
08C34:  BTFSC  FF2.7
08C36:  BSF    16.7
08C38:  BCF    FF2.7
....................     	desaciona_saida(FERRO_SOLDA2);	 
08C3A:  MOVLB  2
08C3C:  CLRF   x1B
08C3E:  MOVLW  02
08C40:  MOVWF  x1A
08C42:  MOVLB  0
08C44:  CALL   1B96
08C48:  BTFSC  16.7
08C4A:  BSF    FF2.7
....................  
.................... 		printf(lcd_putc,"\f"); 						   //limpa display 
08C4C:  MOVLW  0C
08C4E:  MOVLB  1
08C50:  MOVWF  xA4
08C52:  MOVLB  0
08C54:  CALL   2586
....................    	    printf(lcd_putc,"INDO PARA POSICAO   \n\r"); 
08C58:  MOVLW  3A
08C5A:  MOVWF  FF6
08C5C:  MOVLW  0D
08C5E:  MOVWF  FF7
08C60:  CALL   25DA
....................         printf(lcd_putc,"      HOME1         \n\r"); 
08C64:  MOVLW  52
08C66:  MOVWF  FF6
08C68:  MOVLW  0D
08C6A:  MOVWF  FF7
08C6C:  CALL   25DA
....................         desaciona_todas_saidas(); 
08C70:  CALL   1EB0
....................  
....................  
....................     	home_maquina_2(); 
08C74:  RCALL  8758
08C76:  MOVLB  1
....................  
.................... 	} 
....................  
....................  
....................     espera_desacionar_teclas(); 
08C78:  MOVLB  0
08C7A:  CALL   7FCA
.................... 	delay_ms(200); 
08C7E:  MOVLW  C8
08C80:  MOVLB  2
08C82:  MOVWF  x17
08C84:  MOVLB  0
08C86:  CALL   1D50
08C8A:  GOTO   A9D4 (RETURN)
....................  
....................  
.................... } 
....................  
....................  
.................... void	manutencao_opcoes(int dado,int cursor) 
.................... { 
.................... 	int i; 
....................  
....................  
.................... 	posiciona_cursor(1,1); 
08C8E:  MOVLW  01
08C90:  MOVLB  1
08C92:  MOVWF  xA5
08C94:  MOVWF  xA6
08C96:  MOVLB  0
08C98:  CALL   1F92
.................... 				 
.................... 	for(i = 0 ; i < 4; i++) 
08C9C:  MOVLB  1
08C9E:  CLRF   x93
08CA0:  MOVF   x93,W
08CA2:  SUBLW  03
08CA4:  BTFSS  FD8.0
08CA6:  BRA    8E02
.................... 	{ 
....................  
.................... 	switch 	(i + dado){ 
08CA8:  MOVF   x91,W
08CAA:  ADDWF  x93,W
08CAC:  XORLW  00
08CAE:  MOVLB  0
08CB0:  BZ    8D00
08CB2:  XORLW  01
08CB4:  BZ    8D0E
08CB6:  XORLW  03
08CB8:  BZ    8D1C
08CBA:  XORLW  01
08CBC:  BZ    8D2A
08CBE:  XORLW  07
08CC0:  BZ    8D38
08CC2:  XORLW  01
08CC4:  BZ    8D46
08CC6:  XORLW  03
08CC8:  BZ    8D54
08CCA:  XORLW  01
08CCC:  BZ    8D62
08CCE:  XORLW  0F
08CD0:  BZ    8D70
08CD2:  XORLW  01
08CD4:  BZ    8D7E
08CD6:  XORLW  03
08CD8:  BZ    8D8C
08CDA:  XORLW  01
08CDC:  BZ    8D9A
08CDE:  XORLW  07
08CE0:  BZ    8DA8
08CE2:  XORLW  01
08CE4:  BZ    8DB6
08CE6:  XORLW  03
08CE8:  BTFSC  FD8.2
08CEA:  BRA    8DC4
08CEC:  XORLW  01
08CEE:  BTFSC  FD8.2
08CF0:  BRA    8DD2
08CF2:  XORLW  1F
08CF4:  BTFSC  FD8.2
08CF6:  BRA    8DE0
08CF8:  XORLW  01
08CFA:  BTFSC  FD8.2
08CFC:  BRA    8DEE
08CFE:  BRA    8DFC
....................  
.................... 		case 0:  	printf(lcd_putc,"EIXO X,Y            \n\r"); 	 
08D00:  MOVLW  6A
08D02:  MOVWF  FF6
08D04:  MOVLW  0D
08D06:  MOVWF  FF7
08D08:  CALL   25DA
.................... 					break; 
08D0C:  BRA    8DFC
....................  
....................     	case 1: 	printf(lcd_putc,"EIXO  Z             \n\r");	 
08D0E:  MOVLW  82
08D10:  MOVWF  FF6
08D12:  MOVLW  0D
08D14:  MOVWF  FF7
08D16:  CALL   25DA
.................... 					break;	 
08D1A:  BRA    8DFC
.................... 	 
.................... 		case 2:		printf(lcd_putc,"EIXO ROTACIONAL     \n\r"); 
08D1C:  MOVLW  9A
08D1E:  MOVWF  FF6
08D20:  MOVLW  0D
08D22:  MOVWF  FF7
08D24:  CALL   25DA
.................... 					break; 
08D28:  BRA    8DFC
.................... 			 
....................     	case 3:     printf(lcd_putc,"EMPURRADOR ENT.     \n\r"); 
08D2A:  MOVLW  B2
08D2C:  MOVWF  FF6
08D2E:  MOVLW  0D
08D30:  MOVWF  FF7
08D32:  CALL   25DA
....................         			break;	 
08D36:  BRA    8DFC
....................  
.................... 		case 4:     printf(lcd_putc,"DEDOS ENTRADA       \n\r"); 
08D38:  MOVLW  CA
08D3A:  MOVWF  FF6
08D3C:  MOVLW  0D
08D3E:  MOVWF  FF7
08D40:  CALL   25DA
....................         			break; 
08D44:  BRA    8DFC
.................... 			 
.................... 		case 5:	    printf(lcd_putc,"PRESSOR             \n\r"); 
08D46:  MOVLW  E2
08D48:  MOVWF  FF6
08D4A:  MOVLW  0D
08D4C:  MOVWF  FF7
08D4E:  CALL   25DA
.................... 					break; 
08D52:  BRA    8DFC
.................... 			 
....................     	case 6:     printf(lcd_putc,"EMPURRADOR SAIDA    \n\r"); 
08D54:  MOVLW  FA
08D56:  MOVWF  FF6
08D58:  MOVLW  0D
08D5A:  MOVWF  FF7
08D5C:  CALL   25DA
.................... 					break; 
08D60:  BRA    8DFC
....................  
.................... 		case 7:     printf(lcd_putc,"DEDOS SAIDA         \n\r"); 
08D62:  MOVLW  12
08D64:  MOVWF  FF6
08D66:  MOVLW  0E
08D68:  MOVWF  FF7
08D6A:  CALL   25DA
.................... 					break; 
08D6E:  BRA    8DFC
....................  
....................     	case 8: 	printf(lcd_putc,"LIMPADOR            \n\r");	 
08D70:  MOVLW  2A
08D72:  MOVWF  FF6
08D74:  MOVLW  0E
08D76:  MOVWF  FF7
08D78:  CALL   25DA
.................... 					break;	 
08D7C:  BRA    8DFC
.................... 	 
.................... 		case 9:		printf(lcd_putc,"ALIMENT. SOLDA      \n\r"); 
08D7E:  MOVLW  42
08D80:  MOVWF  FF6
08D82:  MOVLW  0E
08D84:  MOVWF  FF7
08D86:  CALL   25DA
.................... 					break; 
08D8A:  BRA    8DFC
.................... 		 
.................... 		case 10:	printf(lcd_putc,"FERRO DE SOLDA 1    \n\r"); 
08D8C:  MOVLW  5A
08D8E:  MOVWF  FF6
08D90:  MOVLW  0E
08D92:  MOVWF  FF7
08D94:  CALL   25DA
.................... 					break; 
08D98:  BRA    8DFC
....................  
.................... 		case 11:	printf(lcd_putc,"FERRO DE SOLDA 2    \n\r"); 
08D9A:  MOVLW  72
08D9C:  MOVWF  FF6
08D9E:  MOVLW  0E
08DA0:  MOVWF  FF7
08DA2:  CALL   25DA
.................... 					break; 
08DA6:  BRA    8DFC
....................  
.................... 		case 12:	printf(lcd_putc,"DEBUG  SENSORES     \n\r"); 
08DA8:  MOVLW  8A
08DAA:  MOVWF  FF6
08DAC:  MOVLW  0E
08DAE:  MOVWF  FF7
08DB0:  CALL   25DA
.................... 					break; 
08DB4:  BRA    8DFC
....................  
.................... 		case 13:    printf(lcd_putc,"DEBUG  SAIDAS       \n\r"); 
08DB6:  MOVLW  A2
08DB8:  MOVWF  FF6
08DBA:  MOVLW  0E
08DBC:  MOVWF  FF7
08DBE:  CALL   25DA
.................... 					break; 
08DC2:  BRA    8DFC
....................  
....................  
.................... 		case 14:    printf(lcd_putc,"STATUS POSICOES     \n\r"); 
08DC4:  MOVLW  BA
08DC6:  MOVWF  FF6
08DC8:  MOVLW  0E
08DCA:  MOVWF  FF7
08DCC:  CALL   25DA
.................... 					break; 
08DD0:  BRA    8DFC
....................  
.................... 		case 15:    printf(lcd_putc,"ENVIA POSICOES      \n\r"); 
08DD2:  MOVLW  D2
08DD4:  MOVWF  FF6
08DD6:  MOVLW  0E
08DD8:  MOVWF  FF7
08DDA:  CALL   25DA
.................... 				    break;	 
08DDE:  BRA    8DFC
....................          
....................         case 16:    printf(lcd_putc,"DEBUG SOLDAGEM      \n\r"); 
08DE0:  MOVLW  EA
08DE2:  MOVWF  FF6
08DE4:  MOVLW  0E
08DE6:  MOVWF  FF7
08DE8:  CALL   25DA
.................... 				    break; 
08DEC:  BRA    8DFC
....................  
.................... 		case 17:    printf(lcd_putc,"DEBUG ESTEIRA       \n\r"); 
08DEE:  MOVLW  02
08DF0:  MOVWF  FF6
08DF2:  MOVLW  0F
08DF4:  MOVWF  FF7
08DF6:  CALL   25DA
.................... 				    break; 
08DFA:  BRA    8DFC
....................  
.................... 		 
....................  
....................  
.................... 		default:    break; 
....................  
....................  
....................  				} 
08DFC:  MOVLB  1
08DFE:  INCF   x93,F
08E00:  BRA    8CA0
.................... 	} 
....................  
.................... 		posiciona_cursor(cursor,17); 
08E02:  MOVFF  192,1A5
08E06:  MOVLW  11
08E08:  MOVWF  xA6
08E0A:  MOVLB  0
08E0C:  CALL   1F92
.................... 		printf(lcd_putc,"<--"); 
08E10:  MOVLW  1A
08E12:  MOVWF  FF6
08E14:  MOVLW  0F
08E16:  MOVWF  FF7
08E18:  CALL   25DA
08E1C:  RETURN 0
.................... 	 
....................  
.................... } 
....................  
.................... void  seleciona_manutencao(int index,int cursor_line) 
.................... { 
....................  
.................... 	switch(index + cursor_line ){ 
*
0A790:  MOVLB  1
0A792:  MOVF   x92,W
0A794:  ADDWF  x91,W
0A796:  XORLW  01
0A798:  MOVLB  0
0A79A:  BZ    A7E2
0A79C:  XORLW  03
0A79E:  BZ    A7E8
0A7A0:  XORLW  01
0A7A2:  BZ    A7EE
0A7A4:  XORLW  07
0A7A6:  BZ    A7F4
0A7A8:  XORLW  01
0A7AA:  BZ    A7FA
0A7AC:  XORLW  03
0A7AE:  BZ    A800
0A7B0:  XORLW  01
0A7B2:  BZ    A806
0A7B4:  XORLW  0F
0A7B6:  BZ    A80C
0A7B8:  XORLW  01
0A7BA:  BZ    A812
0A7BC:  XORLW  03
0A7BE:  BZ    A818
0A7C0:  XORLW  01
0A7C2:  BZ    A81E
0A7C4:  XORLW  07
0A7C6:  BZ    A824
0A7C8:  XORLW  01
0A7CA:  BZ    A82A
0A7CC:  XORLW  03
0A7CE:  BZ    A830
0A7D0:  XORLW  01
0A7D2:  BZ    A836
0A7D4:  XORLW  1F
0A7D6:  BZ    A83A
0A7D8:  XORLW  01
0A7DA:  BZ    A83E
0A7DC:  XORLW  03
0A7DE:  BZ    A840
0A7E0:  BRA    A844
....................  
.................... 					 
.................... 	case 1: Debug_eixo_XY(); 
0A7E2:  GOTO   8E1E
.................... 			break; 
0A7E6:  BRA    A844
....................  
.................... 	case 2: Debug_eixo_Z(); 
0A7E8:  GOTO   90C2
.................... 			break; 
0A7EC:  BRA    A844
....................  
.................... 	case 3: Debug_eixo_FLIP(); 
0A7EE:  GOTO   9266
.................... 			break; 
0A7F2:  BRA    A844
....................  
.................... 	case 4: Debug_Empurrador_Entrada(); 
0A7F4:  GOTO   93E4
.................... 			break; 
0A7F8:  BRA    A844
.................... 	             				 
.................... 	case 5: Debug_dedos_Entrada(); 
0A7FA:  GOTO   9548
.................... 			break; 
0A7FE:  BRA    A844
....................  
.................... 	case 6: Debug_pressor(); 
0A800:  GOTO   968E
.................... 			break; 
0A804:  BRA    A844
....................  
.................... 	case 7: Debug_Empurrador_Saida(); 
0A806:  GOTO   978C
.................... 			break; 
0A80A:  BRA    A844
....................  
.................... 	case 8: Debug_Dedos_Saida(); 
0A80C:  GOTO   98F8
.................... 			break; 
0A810:  BRA    A844
....................  
.................... 	case 9: Debug_Limpador();  
0A812:  GOTO   9A40
.................... 			break; 
0A816:  BRA    A844
....................  
.................... 	case 10:Debug_Alimentador_Solda();   
0A818:  GOTO   9B0C
.................... 			break; 
0A81C:  BRA    A844
....................  
.................... 	case 11:Debug_Ferro_Solda_1(); 
0A81E:  GOTO   9C6A
.................... 			break; 
0A822:  BRA    A844
....................  
.................... 	case 12:Debug_Ferro_Solda_2(); 
0A824:  GOTO   9D68
.................... 			break; 
0A828:  BRA    A844
....................  
....................     case 13:Debug_Sensores(); 
0A82A:  GOTO   9EB0
.................... 			break; 
0A82E:  BRA    A844
....................  
.................... 	case 14:Debug_saidas(); 
0A830:  GOTO   9F7A
.................... 			break; 
0A834:  BRA    A844
....................  
.................... 	case 15:Debug_posicoes_outra_maquina(); 
0A836:  BRA    A0FC
.................... 			break; 
0A838:  BRA    A844
....................  
....................     case 16:envia_posicoes(); 
0A83A:  BRA    A27A
.................... 			break; 
0A83C:  BRA    A844
....................  	case 17: 
.................... 			break; 
0A83E:  BRA    A844
....................  
....................     case 18:debug_esteira();	 
0A840:  BRA    A692
.................... 			break; 
0A842:  BRA    A844
.................... 	default: 
.................... 			break; 
.................... 	} 
0A844:  GOTO   A96C (RETURN)
....................  
.................... } 
....................  
....................  
.................... void menu_manutencao(void) 
0A848:  MOVLB  1
0A84A:  CLRF   x8D
0A84C:  CLRF   x8E
0A84E:  MOVLW  01
0A850:  MOVWF  x8F
0A852:  MOVLW  12
0A854:  MOVWF  x90
.................... { 
....................  
....................     int index = 0; 
.................... 	int key_code = 0; 
.................... 	int cursor_line = 1;  
....................     int numero_opcoes = 18; 
....................  
.................... 	printf(lcd_putc,"\f"); 
0A856:  MOVLW  0C
0A858:  MOVWF  xA4
0A85A:  MOVLB  0
0A85C:  CALL   2586
....................     
....................  
.................... 	//for(i = 0 ; i < 4; i++) 
.................... 	//	{ 
.................... 		 	 
.................... 		 	manutencao_opcoes(index,cursor_line); 
0A860:  MOVFF  18D,191
0A864:  MOVFF  18F,192
0A868:  CALL   8C8E
.................... 	  
....................  
.................... 	//	}  
....................  		posiciona_cursor(1,17); 
0A86C:  MOVLW  01
0A86E:  MOVLB  1
0A870:  MOVWF  xA5
0A872:  MOVLW  11
0A874:  MOVWF  xA6
0A876:  MOVLB  0
0A878:  CALL   1F92
.................... 		printf(lcd_putc,"<--"); 
0A87C:  MOVLW  1E
0A87E:  MOVWF  FF6
0A880:  MOVLW  0F
0A882:  MOVWF  FF7
0A884:  CALL   25DA
....................  
....................  
.................... 	while(true){ 
.................... 		key_code = Teclado(); 
0A888:  CALL   2344
0A88C:  MOVFF  01,18E
.................... 	 
.................... 		switch(key_code){ 
0A890:  MOVLB  1
0A892:  MOVF   x8E,W
0A894:  XORLW  0E
0A896:  MOVLB  0
0A898:  BZ    A8A4
0A89A:  XORLW  01
0A89C:  BZ    A902
0A89E:  XORLW  1C
0A8A0:  BZ    A962
0A8A2:  BRA    A978
....................  
.................... 			case SETA_SUPERIOR: 
.................... 			    				posiciona_cursor(cursor_line,17); 
0A8A4:  MOVFF  18F,1A5
0A8A8:  MOVLW  11
0A8AA:  MOVLB  1
0A8AC:  MOVWF  xA6
0A8AE:  MOVLB  0
0A8B0:  CALL   1F92
.................... 								printf(lcd_putc,"   "); 
0A8B4:  MOVLW  22
0A8B6:  MOVWF  FF6
0A8B8:  MOVLW  0F
0A8BA:  MOVWF  FF7
0A8BC:  CALL   25DA
.................... 								cursor_line--; 
0A8C0:  MOVLB  1
0A8C2:  DECF   x8F,F
....................  
.................... 								if(cursor_line < 1) 
0A8C4:  MOVF   x8F,F
0A8C6:  BNZ   A8E6
.................... 								{ 
.................... 									cursor_line = 1; 
0A8C8:  MOVLW  01
0A8CA:  MOVWF  x8F
.................... 									index--; 
0A8CC:  DECF   x8D,F
.................... 									if(index == 255) index = 0; 
0A8CE:  INCFSZ x8D,W
0A8D0:  BRA    A8D4
0A8D2:  CLRF   x8D
.................... 									manutencao_opcoes(index,cursor_line); 
0A8D4:  MOVFF  18D,191
0A8D8:  MOVFF  18F,192
0A8DC:  MOVLB  0
0A8DE:  CALL   8C8E
....................  
.................... 	 			    			}else{ posiciona_cursor(cursor_line,17); 
0A8E2:  BRA    A900
0A8E4:  MOVLB  1
0A8E6:  MOVFF  18F,1A5
0A8EA:  MOVLW  11
0A8EC:  MOVWF  xA6
0A8EE:  MOVLB  0
0A8F0:  CALL   1F92
.................... 									   printf(lcd_putc,"<--"); 
0A8F4:  MOVLW  26
0A8F6:  MOVWF  FF6
0A8F8:  MOVLW  0F
0A8FA:  MOVWF  FF7
0A8FC:  CALL   25DA
....................      								 } 
.................... 				 
.................... 								break;						 
0A900:  BRA    A978
.................... 			 
.................... 							 
.................... 			case SETA_INFERIOR:	posiciona_cursor(cursor_line,17); 
0A902:  MOVFF  18F,1A5
0A906:  MOVLW  11
0A908:  MOVLB  1
0A90A:  MOVWF  xA6
0A90C:  MOVLB  0
0A90E:  CALL   1F92
.................... 								printf(lcd_putc,"   "); 
0A912:  MOVLW  2A
0A914:  MOVWF  FF6
0A916:  MOVLW  0F
0A918:  MOVWF  FF7
0A91A:  CALL   25DA
.................... 								cursor_line++; 
0A91E:  MOVLB  1
0A920:  INCF   x8F,F
.................... 								if(cursor_line > 4) 
0A922:  MOVF   x8F,W
0A924:  SUBLW  04
0A926:  BC    A946
.................... 								{	  
.................... 		    						cursor_line = 4; 
0A928:  MOVLW  04
0A92A:  MOVWF  x8F
.................... 									if(index < numero_opcoes - 4) 
0A92C:  SUBWF  x90,W
0A92E:  SUBWF  x8D,W
0A930:  BC    A934
.................... 									 {index++;}	 
0A932:  INCF   x8D,F
.................... 							 		manutencao_opcoes(index,cursor_line); 
0A934:  MOVFF  18D,191
0A938:  MOVFF  18F,192
0A93C:  MOVLB  0
0A93E:  CALL   8C8E
.................... 	  
.................... 								}else{  posiciona_cursor(cursor_line,17); 
0A942:  BRA    A960
0A944:  MOVLB  1
0A946:  MOVFF  18F,1A5
0A94A:  MOVLW  11
0A94C:  MOVWF  xA6
0A94E:  MOVLB  0
0A950:  CALL   1F92
.................... 										printf(lcd_putc,"<--"); 
0A954:  MOVLW  2E
0A956:  MOVWF  FF6
0A958:  MOVLW  0F
0A95A:  MOVWF  FF7
0A95C:  CALL   25DA
.................... 				     				 }	    
....................  
.................... 					     		break; 
0A960:  BRA    A978
....................  
....................  
.................... 			case ENTER:		    seleciona_manutencao(index,cursor_line); 
0A962:  MOVFF  18D,191
0A966:  MOVFF  18F,192
0A96A:  BRA    A790
.................... 			                    manutencao_opcoes(index,cursor_line); 
0A96C:  MOVFF  18D,191
0A970:  MOVFF  18F,192
0A974:  CALL   8C8E
.................... 								break;							 
....................  
....................  
....................  
.................... 	} 
.................... 				delay_ms(200); 
0A978:  MOVLW  C8
0A97A:  MOVLB  2
0A97C:  MOVWF  x17
0A97E:  MOVLB  0
0A980:  CALL   1D50
.................... 				 
.................... 			 
.................... 		 		 
.................... 		 if(key_code == ESC) break;		 
0A984:  MOVLB  1
0A986:  MOVF   x8E,W
0A988:  SUBLW  12
0A98A:  BTFSC  FD8.2
0A98C:  BRA    A994
0A98E:  MOVLB  0
0A990:  BRA    A888
0A992:  MOVLB  1
.................... 		 
.................... 	} 
.................... 		espera_desacionar_teclas(); 
0A994:  MOVLB  0
0A996:  CALL   7FCA
.................... 		delay_ms(100); 
0A99A:  MOVLW  64
0A99C:  MOVLB  2
0A99E:  MOVWF  x17
0A9A0:  MOVLB  0
0A9A2:  CALL   1D50
0A9A6:  GOTO   A9DC (RETURN)
....................  
.................... } 
....................  
....................  
....................  
.................... void tela_menu1(void) 
.................... { 
....................  
.................... 	posiciona_cursor(1,1); 
*
046BA:  MOVLW  01
046BC:  MOVLB  1
046BE:  MOVWF  xA5
046C0:  MOVWF  xA6
046C2:  MOVLB  0
046C4:  CALL   1F92
....................    	printf(lcd_putc,"F1:EDITA PONTO      \n\r"); 
046C8:  MOVLW  32
046CA:  MOVWF  FF6
046CC:  MOVLW  0F
046CE:  MOVWF  FF7
046D0:  CALL   25DA
.................... 	printf(lcd_putc,"F2:MANUTENCAO       \n\r"); 
046D4:  MOVLW  4A
046D6:  MOVWF  FF6
046D8:  MOVLW  0F
046DA:  MOVWF  FF7
046DC:  CALL   25DA
.................... 	printf(lcd_putc,"                    \n\r"); 
046E0:  MOVLW  62
046E2:  MOVWF  FF6
046E4:  MOVLW  0F
046E6:  MOVWF  FF7
046E8:  CALL   25DA
.................... 	printf(lcd_putc,"                   "); 
046EC:  MOVLW  7A
046EE:  MOVWF  FF6
046F0:  MOVLW  0F
046F2:  MOVWF  FF7
046F4:  CALL   25DA
046F8:  RETURN 0
....................  
....................  
.................... } 
....................  
....................  
.................... void menu1(void) 
*
0A9AA:  MOVLB  1
0A9AC:  CLRF   x8C
.................... { 
....................  	int key_code = 0; 
....................  
.................... 		 
.................... 	tela_menu1(); 
0A9AE:  MOVLB  0
0A9B0:  CALL   46BA
.................... 	 
.................... 	 
.................... 	while(true){	 
.................... 	 
....................  
.................... 		key_code = Teclado(); 
0A9B4:  CALL   2344
0A9B8:  MOVFF  01,18C
.................... 	 
.................... 		switch 	(key_code){ 
0A9BC:  MOVLB  1
0A9BE:  MOVF   x8C,W
0A9C0:  XORLW  0A
0A9C2:  MOVLB  0
0A9C4:  BZ    A9D0
0A9C6:  XORLW  01
0A9C8:  BZ    A9DA
0A9CA:  XORLW  19
0A9CC:  BZ    A9E2
0A9CE:  BRA    A9E4
....................  
.................... 		case F1: 	menu_edita_pontos(); 
0A9D0:  GOTO   8826
.................... 					tela_menu1(); 
0A9D4:  CALL   46BA
.................... 					break;	 
0A9D8:  BRA    A9E4
.................... 	 
.................... 		case F2:	menu_manutencao(); 
0A9DA:  BRA    A848
.................... 					tela_menu1(); 
0A9DC:  CALL   46BA
.................... 					break;  
0A9E0:  BRA    A9E4
.................... 			 
....................     	case ESC:   
.................... 					break; 
0A9E2:  BRA    A9E4
....................  
.................... 		default:    break; 
....................  
....................   				} 
....................  
.................... 		if(key_code == ESC) break; 
0A9E4:  MOVLB  1
0A9E6:  MOVF   x8C,W
0A9E8:  SUBLW  12
0A9EA:  BTFSC  FD8.2
0A9EC:  BRA    A9F4
0A9EE:  MOVLB  0
0A9F0:  BRA    A9B4
0A9F2:  MOVLB  1
....................  
.................... 	   }	 
....................  
.................... 	espera_desacionar_teclas(); 
0A9F4:  MOVLB  0
0A9F6:  CALL   7FCA
0A9FA:  GOTO   AAF8 (RETURN)
....................  
.................... 	 
....................  
.................... } 
....................  
....................  
.................... void atualiza_modelo(void) 
.................... { 
.................... 	posiciona_cursor(3,7); 
*
0452E:  MOVLW  03
04530:  MOVLB  1
04532:  MOVWF  xA5
04534:  MOVLW  07
04536:  MOVWF  xA6
04538:  MOVLB  0
0453A:  CALL   1F92
....................  
.................... 	switch(programa){ 
0453E:  MOVF   29,W
04540:  BZ    45A0
04542:  XORLW  01
04544:  BZ    45AE
04546:  XORLW  03
04548:  BZ    45BC
0454A:  XORLW  01
0454C:  BZ    45CA
0454E:  XORLW  07
04550:  BZ    45D8
04552:  XORLW  01
04554:  BZ    45E6
04556:  XORLW  03
04558:  BZ    45F4
0455A:  XORLW  01
0455C:  BZ    4602
0455E:  XORLW  0F
04560:  BZ    4610
04562:  XORLW  01
04564:  BZ    461E
04566:  XORLW  03
04568:  BZ    462C
0456A:  XORLW  01
0456C:  BZ    463A
0456E:  XORLW  07
04570:  BTFSC  FD8.2
04572:  BRA    4648
04574:  XORLW  01
04576:  BTFSC  FD8.2
04578:  BRA    4656
0457A:  XORLW  03
0457C:  BTFSC  FD8.2
0457E:  BRA    4664
04580:  XORLW  01
04582:  BTFSC  FD8.2
04584:  BRA    4672
04586:  XORLW  1F
04588:  BTFSC  FD8.2
0458A:  BRA    4680
0458C:  XORLW  01
0458E:  BTFSC  FD8.2
04590:  BRA    468E
04592:  XORLW  03
04594:  BTFSC  FD8.2
04596:  BRA    469C
04598:  XORLW  01
0459A:  BTFSC  FD8.2
0459C:  BRA    46AA
0459E:  BRA    46B8
....................  
.................... 	case 0 :  printf(lcd_putc,"MODELO1  "); 
045A0:  MOVLW  8E
045A2:  MOVWF  FF6
045A4:  MOVLW  0F
045A6:  MOVWF  FF7
045A8:  CALL   25DA
.................... 			  break; 
045AC:  BRA    46B8
.................... 	case 1 :  printf(lcd_putc,"MODELO2  "); 
045AE:  MOVLW  98
045B0:  MOVWF  FF6
045B2:  MOVLW  0F
045B4:  MOVWF  FF7
045B6:  CALL   25DA
.................... 			  break; 
045BA:  BRA    46B8
.................... 	case 2 :  printf(lcd_putc,"MODELO3  "); 
045BC:  MOVLW  A2
045BE:  MOVWF  FF6
045C0:  MOVLW  0F
045C2:  MOVWF  FF7
045C4:  CALL   25DA
.................... 			  break; 
045C8:  BRA    46B8
.................... 	case 3 :  printf(lcd_putc,"MODELO4  "); 
045CA:  MOVLW  AC
045CC:  MOVWF  FF6
045CE:  MOVLW  0F
045D0:  MOVWF  FF7
045D2:  CALL   25DA
.................... 			  break; 
045D6:  BRA    46B8
.................... 	case 4 :  printf(lcd_putc,"MODELO5  "); 
045D8:  MOVLW  B6
045DA:  MOVWF  FF6
045DC:  MOVLW  0F
045DE:  MOVWF  FF7
045E0:  CALL   25DA
.................... 			  break; 
045E4:  BRA    46B8
.................... 	case 5 :  printf(lcd_putc,"MODELO6  "); 
045E6:  MOVLW  C0
045E8:  MOVWF  FF6
045EA:  MOVLW  0F
045EC:  MOVWF  FF7
045EE:  CALL   25DA
.................... 			  break; 
045F2:  BRA    46B8
.................... 	case 6 :  printf(lcd_putc,"MODELO7  "); 
045F4:  MOVLW  CA
045F6:  MOVWF  FF6
045F8:  MOVLW  0F
045FA:  MOVWF  FF7
045FC:  CALL   25DA
.................... 			  break; 
04600:  BRA    46B8
.................... 	case 7 :  printf(lcd_putc,"MODELO8  "); 
04602:  MOVLW  D4
04604:  MOVWF  FF6
04606:  MOVLW  0F
04608:  MOVWF  FF7
0460A:  CALL   25DA
.................... 			  break; 
0460E:  BRA    46B8
.................... 	case 8 :  printf(lcd_putc,"MODELO9  "); 
04610:  MOVLW  DE
04612:  MOVWF  FF6
04614:  MOVLW  0F
04616:  MOVWF  FF7
04618:  CALL   25DA
....................               break; 
0461C:  BRA    46B8
.................... 	case 9 :  printf(lcd_putc,"MODELO10 "); 
0461E:  MOVLW  E8
04620:  MOVWF  FF6
04622:  MOVLW  0F
04624:  MOVWF  FF7
04626:  CALL   25DA
.................... 			  break; 
0462A:  BRA    46B8
.................... 	case 10 : printf(lcd_putc,"MODELO11 "); 
0462C:  MOVLW  F2
0462E:  MOVWF  FF6
04630:  MOVLW  0F
04632:  MOVWF  FF7
04634:  CALL   25DA
....................               break; 
04638:  BRA    46B8
.................... 	case 11 : printf(lcd_putc,"MODELO12"); 
0463A:  MOVLW  FC
0463C:  MOVWF  FF6
0463E:  MOVLW  0F
04640:  MOVWF  FF7
04642:  CALL   25DA
.................... 			  break; 
04646:  BRA    46B8
.................... 	case 12 : printf(lcd_putc,"MODELO13"); 
04648:  MOVLW  06
0464A:  MOVWF  FF6
0464C:  MOVLW  10
0464E:  MOVWF  FF7
04650:  CALL   25DA
.................... 			  break; 
04654:  BRA    46B8
.................... 	case 13 : printf(lcd_putc,"MODELO14"); 
04656:  MOVLW  10
04658:  MOVWF  FF6
0465A:  MOVLW  10
0465C:  MOVWF  FF7
0465E:  CALL   25DA
....................               break; 
04662:  BRA    46B8
.................... 	case 14 : printf(lcd_putc,"MODELO15"); 
04664:  MOVLW  1A
04666:  MOVWF  FF6
04668:  MOVLW  10
0466A:  MOVWF  FF7
0466C:  CALL   25DA
.................... 			  break; 
04670:  BRA    46B8
.................... 	case 15 : printf(lcd_putc,"PLACA1 "); 
04672:  MOVLW  24
04674:  MOVWF  FF6
04676:  MOVLW  10
04678:  MOVWF  FF7
0467A:  CALL   25DA
....................               break; 
0467E:  BRA    46B8
.................... 	case 16 : printf(lcd_putc,"PLACA2 "); 
04680:  MOVLW  2C
04682:  MOVWF  FF6
04684:  MOVLW  10
04686:  MOVWF  FF7
04688:  CALL   25DA
.................... 			  break; 
0468C:  BRA    46B8
.................... 	case 17 : printf(lcd_putc,"PLACA3 "); 
0468E:  MOVLW  34
04690:  MOVWF  FF6
04692:  MOVLW  10
04694:  MOVWF  FF7
04696:  CALL   25DA
....................               break; 
0469A:  BRA    46B8
.................... 	case 18 : printf(lcd_putc,"PLACA4 "); 
0469C:  MOVLW  3C
0469E:  MOVWF  FF6
046A0:  MOVLW  10
046A2:  MOVWF  FF7
046A4:  CALL   25DA
.................... 			  break; 
046A8:  BRA    46B8
.................... 	case 19 : printf(lcd_putc,"PLACA5 "); 
046AA:  MOVLW  44
046AC:  MOVWF  FF6
046AE:  MOVLW  10
046B0:  MOVWF  FF7
046B2:  CALL   25DA
.................... 			  break;	 
046B6:  BRA    46B8
....................  
.................... 	default: 
.................... 			  break;	 
....................  
....................  
.................... 	} 
046B8:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... void	check_keyboard(void) 
*
0A9FE:  MOVLB  1
0AA00:  CLRF   x8B
.................... { 
.................... // Checa o teclado  
.................... //se nenhuma tecla acionada retorna 
.................... //caso contrário dá a tratativa para a tecla acionada 
....................  
....................     int key_code = 0; 
....................  
.................... 	atualiza_modelo();	 
0AA02:  MOVLB  0
0AA04:  CALL   452E
.................... 	key_code = Teclado(); 
0AA08:  CALL   2344
0AA0C:  MOVFF  01,18B
.................... 	if(key_code == 0xff) return; 
0AA10:  MOVLB  1
0AA12:  INCFSZ x8B,W
0AA14:  BRA    AA18
0AA16:  BRA    AB10
....................  
.................... 	 
.................... 	switch 	(key_code){ 
0AA18:  MOVF   x8B,W
0AA1A:  XORLW  0E
0AA1C:  MOVLB  0
0AA1E:  BZ    AA2A
0AA20:  XORLW  01
0AA22:  BZ    AA8E
0AA24:  XORLW  1B
0AA26:  BZ    AAF6
0AA28:  BRA    AAFE
....................  
.................... 	case SETA_SUPERIOR: 	programa++; 
0AA2A:  INCF   29,F
.................... 						 	posiciona_cursor (2,6); 
0AA2C:  MOVLW  02
0AA2E:  MOVLB  1
0AA30:  MOVWF  xA5
0AA32:  MOVLW  06
0AA34:  MOVWF  xA6
0AA36:  MOVLB  0
0AA38:  CALL   1F92
....................     						printf(lcd_putc,"%2u",programa+1); 
0AA3C:  MOVLW  01
0AA3E:  ADDWF  29,W
0AA40:  MOVLB  1
0AA42:  MOVWF  x8C
0AA44:  MOVWF  x9A
0AA46:  MOVLW  11
0AA48:  MOVWF  x9B
0AA4A:  MOVLB  0
0AA4C:  CALL   2626
.................... 							atualiza_modelo(); 
0AA50:  CALL   452E
.................... 							write_eeprom(0x02,programa); 
0AA54:  MOVF   FF2,W
0AA56:  MOVWF  00
0AA58:  BCF    FF2.7
0AA5A:  CLRF   FAA
0AA5C:  MOVLW  02
0AA5E:  MOVWF  FA9
0AA60:  MOVFF  29,FA8
0AA64:  BCF    FA6.6
0AA66:  BCF    FA6.7
0AA68:  BSF    FA6.2
0AA6A:  MOVLB  F
0AA6C:  MOVLW  55
0AA6E:  MOVWF  FA7
0AA70:  MOVLW  AA
0AA72:  MOVWF  FA7
0AA74:  BSF    FA6.1
0AA76:  BTFSC  FA6.1
0AA78:  BRA    AA76
0AA7A:  BCF    FA6.2
0AA7C:  MOVF   00,W
0AA7E:  IORWF  FF2,F
.................... 							delay_ms(5); 
0AA80:  MOVLW  05
0AA82:  MOVLB  2
0AA84:  MOVWF  x17
0AA86:  MOVLB  0
0AA88:  CALL   1D50
.................... 							break; 
0AA8C:  BRA    AAFE
....................  
.................... 	case SETA_INFERIOR:  
.................... 							if(programa != 0) 
0AA8E:  MOVF   29,F
0AA90:  BZ    AAF4
.................... 							{  
.................... 							programa--; 
0AA92:  DECF   29,F
.................... 							posiciona_cursor (2,6); 
0AA94:  MOVLW  02
0AA96:  MOVLB  1
0AA98:  MOVWF  xA5
0AA9A:  MOVLW  06
0AA9C:  MOVWF  xA6
0AA9E:  MOVLB  0
0AAA0:  CALL   1F92
....................     						printf(lcd_putc,"%2u",programa+1); 
0AAA4:  MOVLW  01
0AAA6:  ADDWF  29,W
0AAA8:  MOVLB  1
0AAAA:  MOVWF  x8C
0AAAC:  MOVWF  x9A
0AAAE:  MOVLW  11
0AAB0:  MOVWF  x9B
0AAB2:  MOVLB  0
0AAB4:  CALL   2626
.................... 							atualiza_modelo(); 
0AAB8:  CALL   452E
.................... 							write_eeprom(0x02,programa); 
0AABC:  MOVF   FF2,W
0AABE:  MOVWF  00
0AAC0:  BCF    FF2.7
0AAC2:  CLRF   FAA
0AAC4:  MOVLW  02
0AAC6:  MOVWF  FA9
0AAC8:  MOVFF  29,FA8
0AACC:  BCF    FA6.6
0AACE:  BCF    FA6.7
0AAD0:  BSF    FA6.2
0AAD2:  MOVLB  F
0AAD4:  MOVLW  55
0AAD6:  MOVWF  FA7
0AAD8:  MOVLW  AA
0AADA:  MOVWF  FA7
0AADC:  BSF    FA6.1
0AADE:  BTFSC  FA6.1
0AAE0:  BRA    AADE
0AAE2:  BCF    FA6.2
0AAE4:  MOVF   00,W
0AAE6:  IORWF  FF2,F
.................... 							delay_ms(5); 
0AAE8:  MOVLW  05
0AAEA:  MOVLB  2
0AAEC:  MOVWF  x17
0AAEE:  MOVLB  0
0AAF0:  CALL   1D50
.................... 						 
.................... 							} 
.................... 							break; 
0AAF4:  BRA    AAFE
....................  
....................  
.................... 			 
....................     case MENU:     	    	menu1(); 
0AAF6:  BRA    A9AA
.................... 							Tela_Inicial(); 
0AAF8:  CALL   26A2
.................... 							break; 
0AAFC:  BRA    AAFE
....................  
....................     default:   
.................... 							break; 
....................  
.................... 	} 
....................     delay_ms(20); 
0AAFE:  MOVLW  14
0AB00:  MOVLB  2
0AB02:  MOVWF  x17
0AB04:  MOVLB  0
0AB06:  CALL   1D50
.................... 	espera_desacionar_teclas(); 
0AB0A:  CALL   7FCA
0AB0E:  MOVLB  1
0AB10:  MOVLB  0
0AB12:  RETURN 0
....................  
....................  
.................... } 
....................  
.................... #include "maquinas.c" 
....................  
....................  
....................  
.................... int  posicao_maquina2 = 0; 
.................... int step; 
.................... int i; 
.................... int erro; 
.................... int posicao_atual = 0; 
.................... 	  
....................  
.................... short int le_bit(int n_bit) 
.................... { 
.................... 	short int retorno; 
....................  
.................... 	if  (input(n_bit)  == 1)  return retorno  = 1; 
*
035B4:  MOVFF  199,19B
035B8:  MOVLW  01
035BA:  MOVLB  1
035BC:  MOVWF  x9C
035BE:  MOVLW  0F
035C0:  MOVWF  x9E
035C2:  MOVLW  92
035C4:  MOVWF  x9D
035C6:  MOVLB  0
035C8:  RCALL  3540
035CA:  MOVFF  199,19B
035CE:  MOVLW  0F
035D0:  MOVLB  1
035D2:  MOVWF  x9D
035D4:  MOVLW  80
035D6:  MOVWF  x9C
035D8:  MOVLB  0
035DA:  RCALL  3582
035DC:  BTFSS  01.0
035DE:  BRA    35EC
035E0:  MOVLB  1
035E2:  BSF    x9A.0
035E4:  MOVLW  01
035E6:  MOVWF  01
035E8:  BRA    3636
035EA:  MOVLB  0
.................... 	delay_us(30); 
035EC:  MOVLW  31
035EE:  MOVWF  00
035F0:  DECFSZ 00,F
035F2:  BRA    35F0
035F4:  BRA    35F6
.................... 	if  (input(n_bit)  == 0)  return retorno  = 0; 
035F6:  MOVFF  199,19B
035FA:  MOVLW  01
035FC:  MOVLB  1
035FE:  MOVWF  x9C
03600:  MOVLW  0F
03602:  MOVWF  x9E
03604:  MOVLW  92
03606:  MOVWF  x9D
03608:  MOVLB  0
0360A:  RCALL  3540
0360C:  MOVFF  199,19B
03610:  MOVLW  0F
03612:  MOVLB  1
03614:  MOVWF  x9D
03616:  MOVLW  80
03618:  MOVWF  x9C
0361A:  MOVLB  0
0361C:  RCALL  3582
0361E:  BTFSC  01.0
03620:  BRA    362E
03622:  MOVLB  1
03624:  BCF    x9A.0
03626:  MOVLW  00
03628:  MOVWF  01
0362A:  BRA    3636
0362C:  MOVLB  0
.................... 	return retorno = 1; 
0362E:  MOVLB  1
03630:  BSF    x9A.0
03632:  MOVLW  01
03634:  MOVWF  01
03636:  MOVLB  0
03638:  RETURN 0
....................  
....................  
.................... } 
....................  
....................  
.................... int le_posicao_da_maquina2(void) 
0363A:  MOVLB  1
0363C:  CLRF   x98
.................... { 
.................... 	int dado = 0; 
....................  
.................... 	if(le_bit(H0) == 0) 
0363E:  MOVLW  1F
03640:  MOVWF  x99
03642:  MOVLB  0
03644:  RCALL  35B4
03646:  MOVF   01,F
03648:  BNZ   3652
.................... 	{ 
....................  
.................... 		bit_clear(dado,0); 
0364A:  MOVLB  1
0364C:  BCF    x98.0
....................  
.................... 	}else{ 
0364E:  BRA    3656
03650:  MOVLB  0
....................  
.................... 			bit_set(dado,0); 
03652:  MOVLB  1
03654:  BSF    x98.0
....................  
.................... 	     } 
....................  
.................... 	if(le_bit(H1) == 0) 
03656:  MOVLW  1E
03658:  MOVWF  x99
0365A:  MOVLB  0
0365C:  RCALL  35B4
0365E:  MOVF   01,F
03660:  BNZ   366A
.................... 	{ 
....................  
.................... 		bit_clear(dado,1); 
03662:  MOVLB  1
03664:  BCF    x98.1
....................  
.................... 	}else{ 
03666:  BRA    366E
03668:  MOVLB  0
....................  
.................... 			bit_set(dado,1); 
0366A:  MOVLB  1
0366C:  BSF    x98.1
....................  
.................... 	     } 
....................  
.................... 	if(le_bit(H2) == 0) 
0366E:  MOVLW  1D
03670:  MOVWF  x99
03672:  MOVLB  0
03674:  RCALL  35B4
03676:  MOVF   01,F
03678:  BNZ   3682
.................... 	{ 
....................  
.................... 		bit_clear(dado,2); 
0367A:  MOVLB  1
0367C:  BCF    x98.2
....................  
.................... 	}else{ 
0367E:  BRA    3686
03680:  MOVLB  0
....................  
.................... 			bit_set(dado,2); 
03682:  MOVLB  1
03684:  BSF    x98.2
....................  
.................... 	     } 
.................... 	 
....................  
.................... 	return dado; 
03686:  MOVFF  198,01
0368A:  MOVLB  0
0368C:  RETURN 0
....................  
.................... } 
....................  
.................... int le_posicao_da_maquina1(void) 
*
07C1C:  MOVLB  1
07C1E:  CLRF   x98
.................... { 
....................  
.................... 	int dado = 0; 
....................  
.................... 	if(le_bit(H3) == 0) 
07C20:  MOVLW  1C
07C22:  MOVWF  x99
07C24:  MOVLB  0
07C26:  CALL   35B4
07C2A:  MOVF   01,F
07C2C:  BNZ   7C36
.................... 	{ 
....................  
.................... 		bit_clear(dado,0); 
07C2E:  MOVLB  1
07C30:  BCF    x98.0
....................  
.................... 	}else{ 
07C32:  BRA    7C3A
07C34:  MOVLB  0
....................  
.................... 			bit_set(dado,0); 
07C36:  MOVLB  1
07C38:  BSF    x98.0
....................  
.................... 	     } 
....................  
.................... 	if(le_bit(H4) == 0) 
07C3A:  MOVLW  17
07C3C:  MOVWF  x99
07C3E:  MOVLB  0
07C40:  CALL   35B4
07C44:  MOVF   01,F
07C46:  BNZ   7C50
.................... 	{ 
....................  
.................... 		bit_clear(dado,1); 
07C48:  MOVLB  1
07C4A:  BCF    x98.1
....................  
.................... 	}else{ 
07C4C:  BRA    7C54
07C4E:  MOVLB  0
....................  
.................... 			bit_set(dado,1); 
07C50:  MOVLB  1
07C52:  BSF    x98.1
....................  
.................... 	     } 
....................  
.................... 	if(le_bit(H5) == 0) 
07C54:  MOVLW  16
07C56:  MOVWF  x99
07C58:  MOVLB  0
07C5A:  CALL   35B4
07C5E:  MOVF   01,F
07C60:  BNZ   7C6A
.................... 	{ 
....................  
.................... 		bit_clear(dado,2); 
07C62:  MOVLB  1
07C64:  BCF    x98.2
....................  
.................... 	}else{ 
07C66:  BRA    7C6E
07C68:  MOVLB  0
....................  
.................... 			bit_set(dado,2); 
07C6A:  MOVLB  1
07C6C:  BSF    x98.2
....................  
.................... 	     } 
.................... 	 
....................  
.................... 	return dado; 
07C6E:  MOVFF  198,01
07C72:  MOVLB  0
07C74:  RETURN 0
....................  
....................  
....................  
.................... } 
....................  
.................... void envia_posicao_para_maquina1(int n_posicao) 
.................... { 
....................  
....................  
.................... 		if(bit_test (n_posicao, 0) == 0) 
*
050A4:  MOVLB  1
050A6:  BTFSC  x9A.0
050A8:  BRA    50B0
.................... 	{ 
.................... 		output_low(H0); 
050AA:  BCF    F95.7
050AC:  BCF    F8C.7
....................  
.................... 	}else{ 
050AE:  BRA    50B4
....................  
.................... 			output_high(H0); 
050B0:  BCF    F95.7
050B2:  BSF    F8C.7
....................  
....................  
.................... 	     }	 	 
....................  
....................  
.................... 	if(bit_test (n_posicao, 1) == 0) 
050B4:  BTFSC  x9A.1
050B6:  BRA    50BE
.................... 	{ 
.................... 		output_low(H1); 
050B8:  BCF    F95.6
050BA:  BCF    F8C.6
....................  
.................... 	}else{ 
050BC:  BRA    50C2
....................  
.................... 			output_high(H1); 
050BE:  BCF    F95.6
050C0:  BSF    F8C.6
....................  
.................... 	     }	  
....................  
....................  
.................... 	if(bit_test (n_posicao, 2) == 0) 
050C2:  BTFSC  x9A.2
050C4:  BRA    50CC
.................... 	{ 
.................... 		output_low(H2); 
050C6:  BCF    F95.5
050C8:  BCF    F8C.5
....................  
.................... 	}else{ 
050CA:  BRA    50D0
....................  
.................... 			output_high(H2); 
050CC:  BCF    F95.5
050CE:  BSF    F8C.5
....................  
.................... 	     }	  
050D0:  MOVLB  0
050D2:  RETURN 0
....................  
....................  
....................  
....................  
.................... } 
....................  
.................... void envia_posicao_para_maquina2(int n_posicao) 
.................... { 
.................... 	 
.................... 	if(bit_test (n_posicao, 0) == 0) 
*
039AC:  MOVLB  1
039AE:  BTFSC  x9A.0
039B0:  BRA    39B8
.................... 	{ 
.................... 		output_low(H3); 
039B2:  BCF    F95.4
039B4:  BCF    F8C.4
....................  
.................... 	}else{ 
039B6:  BRA    39BC
....................  
.................... 			output_high(H3); 
039B8:  BCF    F95.4
039BA:  BSF    F8C.4
....................  
....................  
.................... 	     }	 	 
....................  
....................  
.................... 	if(bit_test (n_posicao, 1) == 0) 
039BC:  BTFSC  x9A.1
039BE:  BRA    39C6
.................... 	{ 
.................... 		output_low(H4); 
039C0:  BCF    F94.7
039C2:  BCF    F8B.7
....................  
.................... 	}else{ 
039C4:  BRA    39CA
....................  
.................... 			output_high(H4); 
039C6:  BCF    F94.7
039C8:  BSF    F8B.7
....................  
.................... 	     }	  
....................  
....................  
.................... 	if(bit_test (n_posicao, 2) == 0) 
039CA:  BTFSC  x9A.2
039CC:  BRA    39D4
.................... 	{ 
.................... 		output_low(H5); 
039CE:  BCF    F94.6
039D0:  BCF    F8B.6
....................  
.................... 	}else{ 
039D2:  BRA    39D8
....................  
.................... 			output_high(H5); 
039D4:  BCF    F94.6
039D6:  BSF    F8B.6
....................  
.................... 	     }	  
039D8:  MOVLB  0
039DA:  RETURN 0
....................  
.................... } 
....................  
.................... void posicao_alimentacao_placa_estagio1(int n_maquina) 
.................... { 
....................  
....................     posiciona_cursor(3,1); 
....................  	printf(lcd_putc,"MOVIMENTANDO POSICAO\n\r"); 
....................  	printf(lcd_putc,"ALIMENTACAO PLACA   ");   
....................  
....................     if(n_maquina == MAQUINA1) 
.................... 	{ 
....................       envia_posicao_para_maquina2(POSICAO_ALIMENTADOR); 
.................... 	  go_x_y(1500,770,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false);  
....................  
.................... 	} 	 
....................  
....................    if(n_maquina == MAQUINA2) 
.................... 	{ 
....................  
....................       envia_posicao_para_maquina1(POSICAO_ALIMENTADOR); 
.................... 	  go_x_y(2500,0,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false);  
....................  
.................... 	} 
....................  
.................... } 
....................  
.................... int posicao_alimentacao_placa(int n_maquina) 
*
077C6:  MOVLB  1
077C8:  CLRF   x96
.................... { 
....................     int erro=0; 
....................  
....................  	posiciona_cursor(3,1); 
077CA:  MOVLW  03
077CC:  MOVWF  xA5
077CE:  MOVLW  01
077D0:  MOVWF  xA6
077D2:  MOVLB  0
077D4:  CALL   1F92
....................  	printf(lcd_putc,"MOVIMENTANDO POSICAO\n\r"); 
077D8:  MOVLW  7A
077DA:  MOVWF  FF6
077DC:  MOVLW  10
077DE:  MOVWF  FF7
077E0:  CALL   25DA
....................  	printf(lcd_putc,"ALIMENTACAO PLACA   ");   
077E4:  MOVLW  92
077E6:  MOVWF  FF6
077E8:  MOVLW  10
077EA:  MOVWF  FF7
077EC:  CALL   25DA
....................  
.................... 	if(n_maquina == MAQUINA1) 
077F0:  MOVLB  1
077F2:  DECFSZ x95,W
077F4:  BRA    7916
.................... 	{ 
.................... 		envia_posicao_para_maquina2(POSICAO_ALIMENTADOR); 
077F6:  MOVLW  02
077F8:  MOVWF  x9A
077FA:  MOVLB  0
077FC:  CALL   39AC
.................... 		go_x_y(50,770,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false);  
07800:  MOVLB  1
07802:  CLRF   x9D
07804:  MOVLW  32
07806:  MOVWF  x9C
07808:  MOVLW  03
0780A:  MOVWF  x9F
0780C:  MOVLW  02
0780E:  MOVWF  x9E
07810:  MOVLW  01
07812:  MOVWF  xA1
07814:  MOVLW  2C
07816:  MOVWF  xA0
07818:  MOVLW  01
0781A:  MOVWF  xA3
0781C:  MOVLW  2C
0781E:  MOVWF  xA2
07820:  MOVLW  07
07822:  MOVWF  xA5
07824:  MOVLW  D0
07826:  MOVWF  xA4
07828:  MOVLW  07
0782A:  MOVWF  xA7
0782C:  MOVLW  D0
0782E:  MOVWF  xA6
07830:  MOVLW  C8
07832:  MOVWF  xA8
07834:  MOVWF  xA9
07836:  MOVLW  01
07838:  MOVWF  xAA
0783A:  MOVWF  xAB
0783C:  CLRF   xAC
0783E:  CLRF   xAD
07840:  MOVLB  0
07842:  CALL   42F6
.................... 	    x_home_direita(); 
07846:  CALL   368E
....................    	    if(le_Input(S_Y_FRENTE) == true)     return erro = 1;// p/ protecao  
0784A:  MOVLW  07
0784C:  MOVLB  1
0784E:  MOVWF  x9C
07850:  MOVLB  0
07852:  CALL   2C54
07856:  DECFSZ 01,W
07858:  BRA    7866
0785A:  MOVLW  01
0785C:  MOVLB  1
0785E:  MOVWF  x96
07860:  MOVWF  01
07862:  BRA    7A44
07864:  MOVLB  0
....................         go_x_y_flip(50,770,50,velocity_x,velocity_y,500,4000,4000,4000,200,200,200,true,true,true); 
07866:  MOVLB  1
07868:  CLRF   x98
0786A:  MOVLW  32
0786C:  MOVWF  x97
0786E:  MOVLW  03
07870:  MOVWF  x9A
07872:  MOVLW  02
07874:  MOVWF  x99
07876:  CLRF   x9C
07878:  MOVLW  32
0787A:  MOVWF  x9B
0787C:  MOVLW  01
0787E:  MOVWF  x9E
07880:  MOVLW  2C
07882:  MOVWF  x9D
07884:  MOVLW  01
07886:  MOVWF  xA0
07888:  MOVLW  2C
0788A:  MOVWF  x9F
0788C:  MOVLW  01
0788E:  MOVWF  xA2
07890:  MOVLW  F4
07892:  MOVWF  xA1
07894:  MOVLW  0F
07896:  MOVWF  xA4
07898:  MOVLW  A0
0789A:  MOVWF  xA3
0789C:  MOVLW  0F
0789E:  MOVWF  xA6
078A0:  MOVLW  A0
078A2:  MOVWF  xA5
078A4:  MOVLW  0F
078A6:  MOVWF  xA8
078A8:  MOVLW  A0
078AA:  MOVWF  xA7
078AC:  MOVLW  C8
078AE:  MOVWF  xA9
078B0:  MOVWF  xAA
078B2:  MOVWF  xAB
078B4:  MOVLW  01
078B6:  MOVWF  xAC
078B8:  MOVWF  xAD
078BA:  MOVWF  xAE
078BC:  MOVLB  0
078BE:  CALL   4AEE
.................... 	    if(flip_home() > 0) return erro; 
078C2:  CALL   37FC
078C6:  MOVF   01,F
078C8:  BZ    78D4
078CA:  MOVLB  1
078CC:  MOVFF  196,01
078D0:  BRA    7A44
078D2:  MOVLB  0
....................         go_x_y(50,0,1000,1000,2000,2000,200,200,false,false,false,false);  
078D4:  MOVLB  1
078D6:  CLRF   x9D
078D8:  MOVLW  32
078DA:  MOVWF  x9C
078DC:  CLRF   x9F
078DE:  CLRF   x9E
078E0:  MOVLW  03
078E2:  MOVWF  xA1
078E4:  MOVLW  E8
078E6:  MOVWF  xA0
078E8:  MOVLW  03
078EA:  MOVWF  xA3
078EC:  MOVLW  E8
078EE:  MOVWF  xA2
078F0:  MOVLW  07
078F2:  MOVWF  xA5
078F4:  MOVLW  D0
078F6:  MOVWF  xA4
078F8:  MOVLW  07
078FA:  MOVWF  xA7
078FC:  MOVLW  D0
078FE:  MOVWF  xA6
07900:  MOVLW  C8
07902:  MOVWF  xA8
07904:  MOVWF  xA9
07906:  CLRF   xAA
07908:  CLRF   xAB
0790A:  CLRF   xAC
0790C:  CLRF   xAD
0790E:  MOVLB  0
07910:  CALL   42F6
07914:  MOVLB  1
.................... 	} 
....................  
.................... 	if(n_maquina == MAQUINA2) 
07916:  MOVF   x95,W
07918:  SUBLW  02
0791A:  BTFSS  FD8.2
0791C:  BRA    7A40
.................... 	{ 
.................... 	     
....................         envia_posicao_para_maquina1(POSICAO_ALIMENTADOR); 
0791E:  MOVLW  02
07920:  MOVWF  x9A
07922:  MOVLB  0
07924:  CALL   50A4
.................... 		go_x_y(4260,0,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false);  
07928:  MOVLW  10
0792A:  MOVLB  1
0792C:  MOVWF  x9D
0792E:  MOVLW  A4
07930:  MOVWF  x9C
07932:  CLRF   x9F
07934:  CLRF   x9E
07936:  MOVLW  01
07938:  MOVWF  xA1
0793A:  MOVLW  2C
0793C:  MOVWF  xA0
0793E:  MOVLW  01
07940:  MOVWF  xA3
07942:  MOVLW  2C
07944:  MOVWF  xA2
07946:  MOVLW  07
07948:  MOVWF  xA5
0794A:  MOVLW  D0
0794C:  MOVWF  xA4
0794E:  MOVLW  07
07950:  MOVWF  xA7
07952:  MOVLW  D0
07954:  MOVWF  xA6
07956:  MOVLW  C8
07958:  MOVWF  xA8
0795A:  MOVWF  xA9
0795C:  MOVLW  01
0795E:  MOVWF  xAA
07960:  MOVWF  xAB
07962:  CLRF   xAC
07964:  CLRF   xAD
07966:  MOVLB  0
07968:  CALL   42F6
....................         if(first_time == true) 
0796C:  BTFSS  1E.3
0796E:  BRA    7986
.................... 		{ 
....................     
....................      	    if(flip_home() > 0) return erro;	 
07970:  CALL   37FC
07974:  MOVF   01,F
07976:  BZ    7982
07978:  MOVLB  1
0797A:  MOVFF  196,01
0797E:  BRA    7A44
07980:  MOVLB  0
....................             first_time = false; 
07982:  BCF    1E.3
....................  
.................... 		}else{ 
07984:  BRA    79F2
....................      
.................... 	    	//if(le_Input(S_Y_FRENTE) == true)     return erro = 1; 
....................      
....................          
....................             go_x_y_flip(4260,0,50,velocity_x,velocity_y,1000,4000,4000,4000,200,200,200,true,true,true); 
07986:  MOVLW  10
07988:  MOVLB  1
0798A:  MOVWF  x98
0798C:  MOVLW  A4
0798E:  MOVWF  x97
07990:  CLRF   x9A
07992:  CLRF   x99
07994:  CLRF   x9C
07996:  MOVLW  32
07998:  MOVWF  x9B
0799A:  MOVLW  01
0799C:  MOVWF  x9E
0799E:  MOVLW  2C
079A0:  MOVWF  x9D
079A2:  MOVLW  01
079A4:  MOVWF  xA0
079A6:  MOVLW  2C
079A8:  MOVWF  x9F
079AA:  MOVLW  03
079AC:  MOVWF  xA2
079AE:  MOVLW  E8
079B0:  MOVWF  xA1
079B2:  MOVLW  0F
079B4:  MOVWF  xA4
079B6:  MOVLW  A0
079B8:  MOVWF  xA3
079BA:  MOVLW  0F
079BC:  MOVWF  xA6
079BE:  MOVLW  A0
079C0:  MOVWF  xA5
079C2:  MOVLW  0F
079C4:  MOVWF  xA8
079C6:  MOVLW  A0
079C8:  MOVWF  xA7
079CA:  MOVLW  C8
079CC:  MOVWF  xA9
079CE:  MOVWF  xAA
079D0:  MOVWF  xAB
079D2:  MOVLW  01
079D4:  MOVWF  xAC
079D6:  MOVWF  xAD
079D8:  MOVWF  xAE
079DA:  MOVLB  0
079DC:  CALL   4AEE
....................             if(flip_home() > 0) return erro; 
079E0:  CALL   37FC
079E4:  MOVF   01,F
079E6:  BZ    79F2
079E8:  MOVLB  1
079EA:  MOVFF  196,01
079EE:  BRA    7A44
079F0:  MOVLB  0
.................... 	                    
....................   
....................         	}	 
....................             contador_step_y = 0; 
079F2:  MOVLB  1
079F4:  CLRF   x7B
079F6:  CLRF   x7A
.................... 	    	go_x_y_negativo(4260,700,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
079F8:  MOVLW  10
079FA:  MOVWF  x98
079FC:  MOVLW  A4
079FE:  MOVWF  x97
07A00:  MOVLW  02
07A02:  MOVWF  x9A
07A04:  MOVLW  BC
07A06:  MOVWF  x99
07A08:  MOVLW  01
07A0A:  MOVWF  x9C
07A0C:  MOVLW  2C
07A0E:  MOVWF  x9B
07A10:  MOVLW  01
07A12:  MOVWF  x9E
07A14:  MOVLW  2C
07A16:  MOVWF  x9D
07A18:  MOVLW  07
07A1A:  MOVWF  xA0
07A1C:  MOVLW  D0
07A1E:  MOVWF  x9F
07A20:  MOVLW  07
07A22:  MOVWF  xA2
07A24:  MOVLW  D0
07A26:  MOVWF  xA1
07A28:  MOVLW  C8
07A2A:  MOVWF  xA3
07A2C:  MOVWF  xA4
07A2E:  MOVLW  01
07A30:  MOVWF  xA5
07A32:  MOVWF  xA6
07A34:  CLRF   xA7
07A36:  CLRF   xA8
07A38:  MOVLB  0
07A3A:  CALL   4E6A
07A3E:  MOVLB  1
.................... 	 
....................      
.................... 	} 
....................       return erro; 
07A40:  MOVFF  196,01
07A44:  MOVLB  0
07A46:  RETURN 0
.................... } 
....................  
....................  
.................... int posicao_soldagem(int n_maquina) 
*
050D4:  MOVLB  1
050D6:  CLRF   x96
.................... { 
....................  
....................     int erro = 0; 
.................... 	 
.................... 	 posiciona_cursor(3,1); 
050D8:  MOVLW  03
050DA:  MOVWF  xA5
050DC:  MOVLW  01
050DE:  MOVWF  xA6
050E0:  MOVLB  0
050E2:  CALL   1F92
....................  	 printf(lcd_putc,"MOVIMENTANDO POSICAO\n\r"); 
050E6:  MOVLW  A8
050E8:  MOVWF  FF6
050EA:  MOVLW  10
050EC:  MOVWF  FF7
050EE:  CALL   25DA
....................      printf(lcd_putc,"     DE SOLDAGEM    "); 
050F2:  MOVLW  C0
050F4:  MOVWF  FF6
050F6:  MOVLW  10
050F8:  MOVWF  FF7
050FA:  CALL   25DA
....................  
.................... 	if(n_maquina == MAQUINA1) 
050FE:  MOVLB  1
05100:  DECFSZ x95,W
05102:  BRA    5216
....................  
.................... 	{    
.................... 	 	go_x_y_flip(0,900,1867,velocity_x,velocity_y,velocity_flip,4000,4000,4000,200,200,200,true,true,true);//retiradp para teste 
05104:  CLRF   x98
05106:  CLRF   x97
05108:  MOVLW  03
0510A:  MOVWF  x9A
0510C:  MOVLW  84
0510E:  MOVWF  x99
05110:  MOVLW  07
05112:  MOVWF  x9C
05114:  MOVLW  4B
05116:  MOVWF  x9B
05118:  MOVLW  01
0511A:  MOVWF  x9E
0511C:  MOVLW  2C
0511E:  MOVWF  x9D
05120:  MOVLW  01
05122:  MOVWF  xA0
05124:  MOVLW  2C
05126:  MOVWF  x9F
05128:  MOVLW  03
0512A:  MOVWF  xA2
0512C:  MOVLW  E8
0512E:  MOVWF  xA1
05130:  MOVLW  0F
05132:  MOVWF  xA4
05134:  MOVLW  A0
05136:  MOVWF  xA3
05138:  MOVLW  0F
0513A:  MOVWF  xA6
0513C:  MOVLW  A0
0513E:  MOVWF  xA5
05140:  MOVLW  0F
05142:  MOVWF  xA8
05144:  MOVLW  A0
05146:  MOVWF  xA7
05148:  MOVLW  C8
0514A:  MOVWF  xA9
0514C:  MOVWF  xAA
0514E:  MOVWF  xAB
05150:  MOVLW  01
05152:  MOVWF  xAC
05154:  MOVWF  xAD
05156:  MOVWF  xAE
05158:  MOVLB  0
0515A:  RCALL  4AEE
....................         if(le_Input(S_Y_FRENTE) == true)     return erro = 2;   
0515C:  MOVLW  07
0515E:  MOVLB  1
05160:  MOVWF  x9C
05162:  MOVLB  0
05164:  CALL   2C54
05168:  DECFSZ 01,W
0516A:  BRA    5178
0516C:  MOVLW  02
0516E:  MOVLB  1
05170:  MOVWF  x96
05172:  MOVWF  01
05174:  BRA    53D4
05176:  MOVLB  0
.................... 	    go_x_y(3700,900,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
05178:  MOVLW  0E
0517A:  MOVLB  1
0517C:  MOVWF  x9D
0517E:  MOVLW  74
05180:  MOVWF  x9C
05182:  MOVLW  03
05184:  MOVWF  x9F
05186:  MOVLW  84
05188:  MOVWF  x9E
0518A:  MOVLW  01
0518C:  MOVWF  xA1
0518E:  MOVLW  2C
05190:  MOVWF  xA0
05192:  MOVLW  01
05194:  MOVWF  xA3
05196:  MOVLW  2C
05198:  MOVWF  xA2
0519A:  MOVLW  07
0519C:  MOVWF  xA5
0519E:  MOVLW  D0
051A0:  MOVWF  xA4
051A2:  MOVLW  07
051A4:  MOVWF  xA7
051A6:  MOVLW  D0
051A8:  MOVWF  xA6
051AA:  MOVLW  C8
051AC:  MOVWF  xA8
051AE:  MOVWF  xA9
051B0:  MOVLW  01
051B2:  MOVWF  xAA
051B4:  MOVWF  xAB
051B6:  CLRF   xAC
051B8:  CLRF   xAD
051BA:  MOVLB  0
051BC:  CALL   42F6
....................         go_x_y(3849,4375,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
051C0:  MOVLW  0F
051C2:  MOVLB  1
051C4:  MOVWF  x9D
051C6:  MOVLW  09
051C8:  MOVWF  x9C
051CA:  MOVLW  11
051CC:  MOVWF  x9F
051CE:  MOVLW  17
051D0:  MOVWF  x9E
051D2:  MOVLW  01
051D4:  MOVWF  xA1
051D6:  MOVLW  2C
051D8:  MOVWF  xA0
051DA:  MOVLW  01
051DC:  MOVWF  xA3
051DE:  MOVLW  2C
051E0:  MOVWF  xA2
051E2:  MOVLW  07
051E4:  MOVWF  xA5
051E6:  MOVLW  D0
051E8:  MOVWF  xA4
051EA:  MOVLW  07
051EC:  MOVWF  xA7
051EE:  MOVLW  D0
051F0:  MOVWF  xA6
051F2:  MOVLW  C8
051F4:  MOVWF  xA8
051F6:  MOVWF  xA9
051F8:  MOVLW  01
051FA:  MOVWF  xAA
051FC:  MOVWF  xAB
051FE:  CLRF   xAC
05200:  CLRF   xAD
05202:  MOVLB  0
05204:  CALL   42F6
.................... 	 	envia_posicao_para_maquina2(POSICAO_SOLDA_ESTAGIO1); 
05208:  MOVLW  03
0520A:  MOVLB  1
0520C:  MOVWF  x9A
0520E:  MOVLB  0
05210:  CALL   39AC
05214:  MOVLB  1
.................... 	} 
....................  
.................... 	if(n_maquina == MAQUINA2) 
05216:  MOVF   x95,W
05218:  SUBLW  02
0521A:  BTFSS  FD8.2
0521C:  BRA    53D0
.................... 	{ 
....................  
.................... 	    chopper_y(); 
0521E:  MOVLB  0
05220:  CALL   3152
....................         atras(); 
05224:  CALL   319A
....................         delay_ms(50); 
05228:  MOVLW  32
0522A:  MOVLB  2
0522C:  MOVWF  x17
0522E:  MOVLB  0
05230:  CALL   1D50
....................  
....................         go_x_y_negativo(3900,0,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false);  
05234:  MOVLW  0F
05236:  MOVLB  1
05238:  MOVWF  x98
0523A:  MOVLW  3C
0523C:  MOVWF  x97
0523E:  CLRF   x9A
05240:  CLRF   x99
05242:  MOVLW  01
05244:  MOVWF  x9C
05246:  MOVLW  2C
05248:  MOVWF  x9B
0524A:  MOVLW  01
0524C:  MOVWF  x9E
0524E:  MOVLW  2C
05250:  MOVWF  x9D
05252:  MOVLW  07
05254:  MOVWF  xA0
05256:  MOVLW  D0
05258:  MOVWF  x9F
0525A:  MOVLW  07
0525C:  MOVWF  xA2
0525E:  MOVLW  D0
05260:  MOVWF  xA1
05262:  MOVLW  C8
05264:  MOVWF  xA3
05266:  MOVWF  xA4
05268:  MOVLW  01
0526A:  MOVWF  xA5
0526C:  MOVWF  xA6
0526E:  CLRF   xA7
05270:  CLRF   xA8
05272:  MOVLB  0
05274:  RCALL  4E6A
....................         go_x_y_flip(3900,0,1855,velocity_x,velocity_y,velocity_flip,4000,4000,4000,200,200,200,true,true,true);//retiradp para teste 
05276:  MOVLW  0F
05278:  MOVLB  1
0527A:  MOVWF  x98
0527C:  MOVLW  3C
0527E:  MOVWF  x97
05280:  CLRF   x9A
05282:  CLRF   x99
05284:  MOVLW  07
05286:  MOVWF  x9C
05288:  MOVLW  3F
0528A:  MOVWF  x9B
0528C:  MOVLW  01
0528E:  MOVWF  x9E
05290:  MOVLW  2C
05292:  MOVWF  x9D
05294:  MOVLW  01
05296:  MOVWF  xA0
05298:  MOVLW  2C
0529A:  MOVWF  x9F
0529C:  MOVLW  03
0529E:  MOVWF  xA2
052A0:  MOVLW  E8
052A2:  MOVWF  xA1
052A4:  MOVLW  0F
052A6:  MOVWF  xA4
052A8:  MOVLW  A0
052AA:  MOVWF  xA3
052AC:  MOVLW  0F
052AE:  MOVWF  xA6
052B0:  MOVLW  A0
052B2:  MOVWF  xA5
052B4:  MOVLW  0F
052B6:  MOVWF  xA8
052B8:  MOVLW  A0
052BA:  MOVWF  xA7
052BC:  MOVLW  C8
052BE:  MOVWF  xA9
052C0:  MOVWF  xAA
052C2:  MOVWF  xAB
052C4:  MOVLW  01
052C6:  MOVWF  xAC
052C8:  MOVWF  xAD
052CA:  MOVWF  xAE
052CC:  MOVLB  0
052CE:  RCALL  4AEE
.................... 	    go_x_y(3900,80,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false);  
052D0:  MOVLW  0F
052D2:  MOVLB  1
052D4:  MOVWF  x9D
052D6:  MOVLW  3C
052D8:  MOVWF  x9C
052DA:  CLRF   x9F
052DC:  MOVLW  50
052DE:  MOVWF  x9E
052E0:  MOVLW  01
052E2:  MOVWF  xA1
052E4:  MOVLW  2C
052E6:  MOVWF  xA0
052E8:  MOVLW  01
052EA:  MOVWF  xA3
052EC:  MOVLW  2C
052EE:  MOVWF  xA2
052F0:  MOVLW  07
052F2:  MOVWF  xA5
052F4:  MOVLW  D0
052F6:  MOVWF  xA4
052F8:  MOVLW  07
052FA:  MOVWF  xA7
052FC:  MOVLW  D0
052FE:  MOVWF  xA6
05300:  MOVLW  C8
05302:  MOVWF  xA8
05304:  MOVWF  xA9
05306:  MOVLW  01
05308:  MOVWF  xAA
0530A:  MOVWF  xAB
0530C:  CLRF   xAC
0530E:  CLRF   xAD
05310:  MOVLB  0
05312:  CALL   42F6
....................         delay_ms(100); 
05316:  MOVLW  64
05318:  MOVLB  2
0531A:  MOVWF  x17
0531C:  MOVLB  0
0531E:  CALL   1D50
....................         if(le_Input(S_Y_FRENTE) == true)     return erro = 2;    
05322:  MOVLW  07
05324:  MOVLB  1
05326:  MOVWF  x9C
05328:  MOVLB  0
0532A:  CALL   2C54
0532E:  DECFSZ 01,W
05330:  BRA    533E
05332:  MOVLW  02
05334:  MOVLB  1
05336:  MOVWF  x96
05338:  MOVWF  01
0533A:  BRA    53D4
0533C:  MOVLB  0
....................         go_x_y(0,80,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false);    
0533E:  MOVLB  1
05340:  CLRF   x9D
05342:  CLRF   x9C
05344:  CLRF   x9F
05346:  MOVLW  50
05348:  MOVWF  x9E
0534A:  MOVLW  01
0534C:  MOVWF  xA1
0534E:  MOVLW  2C
05350:  MOVWF  xA0
05352:  MOVLW  01
05354:  MOVWF  xA3
05356:  MOVLW  2C
05358:  MOVWF  xA2
0535A:  MOVLW  07
0535C:  MOVWF  xA5
0535E:  MOVLW  D0
05360:  MOVWF  xA4
05362:  MOVLW  07
05364:  MOVWF  xA7
05366:  MOVLW  D0
05368:  MOVWF  xA6
0536A:  MOVLW  C8
0536C:  MOVWF  xA8
0536E:  MOVWF  xA9
05370:  MOVLW  01
05372:  MOVWF  xAA
05374:  MOVWF  xAB
05376:  CLRF   xAC
05378:  CLRF   xAD
0537A:  MOVLB  0
0537C:  CALL   42F6
....................         go_x_y(0,3455,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false);                                                                                            
05380:  MOVLB  1
05382:  CLRF   x9D
05384:  CLRF   x9C
05386:  MOVLW  0D
05388:  MOVWF  x9F
0538A:  MOVLW  7F
0538C:  MOVWF  x9E
0538E:  MOVLW  01
05390:  MOVWF  xA1
05392:  MOVLW  2C
05394:  MOVWF  xA0
05396:  MOVLW  01
05398:  MOVWF  xA3
0539A:  MOVLW  2C
0539C:  MOVWF  xA2
0539E:  MOVLW  07
053A0:  MOVWF  xA5
053A2:  MOVLW  D0
053A4:  MOVWF  xA4
053A6:  MOVLW  07
053A8:  MOVWF  xA7
053AA:  MOVLW  D0
053AC:  MOVWF  xA6
053AE:  MOVLW  C8
053B0:  MOVWF  xA8
053B2:  MOVWF  xA9
053B4:  MOVLW  01
053B6:  MOVWF  xAA
053B8:  MOVWF  xAB
053BA:  CLRF   xAC
053BC:  CLRF   xAD
053BE:  MOVLB  0
053C0:  CALL   42F6
....................         envia_posicao_para_maquina1(POSICAO_SOLDA_ESTAGIO1); 
053C4:  MOVLW  03
053C6:  MOVLB  1
053C8:  MOVWF  x9A
053CA:  MOVLB  0
053CC:  RCALL  50A4
053CE:  MOVLB  1
....................  
.................... 	} 
....................  
....................   return erro; 
053D0:  MOVFF  196,01
053D4:  MOVLB  0
053D6:  RETURN 0
.................... 	 
.................... } 
....................  
.................... /* 
.................... int  soldar(int n_maquina) 
.................... { 
.................... 	int i; 
....................     int erro = 0; 
....................     long int posicao_limite_estagio2_solda_maquina_1 = 3200; 
....................     long int posicao_limite_estagio2_solda_maquina_2 = 500; 
.................... 	short int flag_estagio2 = false; 
....................  
.................... 	aciona_saida(FERRO_SOLDA2); 
....................     posiciona_cursor(1,1); 
....................     printf(lcd_putc,"P:                  \n\r"); 
....................     printf(lcd_putc,"                    \n\r"); 
.................... 	printf(lcd_putc,"     SOLDANDO       \n\r"); 
.................... 	printf(lcd_putc,"     ESTAGIO1       "); 
....................  
.................... 	for(i=0;i<numero_pontos;i++) 
.................... 	{ 
.................... 		posiciona_cursor(1,4); 
.................... 		printf(lcd_putc,"%2u",i); 
....................  
.................... if(n_maquina == 1) 
.................... { 
....................  
.................... 	   if(flag_estagio2 == false) 
.................... 	   { 
.................... 	 
.................... 			   if(posicao_x[i] >= posicao_limite_estagio2_solda_maquina_1)  
.................... 	   			{ 
.................... 			 
.................... 					aciona_saida(FERRO_SOLDA1); 
.................... 					flag_estagio2 = true; 
.................... 					posiciona_cursor(3,1); 
.................... 					printf(lcd_putc,"     SOLDANDO       \n\r"); 
.................... 					printf(lcd_putc,"     ESTAGIO2       "); 
.................... 				 
.................... 	   			}  
.................... 	   }else{ 
....................  
.................... 				    if(posicao_x[i] < posicao_limite_estagio2_solda_maquina_1)  
.................... 					{ 
....................  
.................... 						return erro=3; 
....................  
....................  
.................... 					} 
....................  
....................  
.................... 			} 
....................  
.................... }  
.................... 	 
....................  
.................... if(n_maquina == 2) 
.................... { 
....................  
.................... 	   if(flag_estagio2 == false) 
.................... 	   { 
.................... 	 
.................... 			   if(posicao_x_2[i] <= posicao_limite_estagio2_solda_maquina_2)  
.................... 	   			{ 
.................... 			 
.................... 					aciona_saida(FERRO_SOLDA1); 
.................... 					flag_estagio2 = true; 
.................... 					posiciona_cursor(3,1); 
.................... 					printf(lcd_putc,"     SOLDANDO       \n\r"); 
.................... 					printf(lcd_putc,"     ESTAGIO2       "); 
.................... 				 
.................... 	   			}  
.................... 	   }else{ 
....................  
.................... 				    if(posicao_x_2[i] > posicao_limite_estagio2_solda_maquina_2)  
.................... 					{ 
....................  
.................... 						return erro=3; 
....................  
....................  
.................... 					} 
....................  
....................  
.................... 			} 
....................  
.................... }  
....................  
....................   
....................      //delay_ms(500); 
.................... 	//while(le_Input(SENSOR_BOARD) == false){} //SOMENTE P TESTE 
....................  
....................       if(n_maquina == 1) 
....................       { 
....................  
.................... 	  go_x_y(posicao_x[i],posicao_y[i],velocity_x,velocity_y,2000,2000,200,200,true,true,false,false);	  
.................... 	  if(flag_estagio2 == true) envia_posicao_para_maquina2(POSICAO_SOLDA_ESTAGIO2); 
....................  
....................  
.................... 	  } 
....................  
....................       if(n_maquina == 2) 
.................... 	  { 
....................  
....................       go_x_y(posicao_x_2[i],posicao_y_2[i],velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
....................       if(flag_estagio2 == true) envia_posicao_para_maquina1(POSICAO_SOLDA_ESTAGIO2); 
....................  
.................... 	  } 
....................              
....................  
....................             //go_x_y_z(posicao_x[i],posicao_y[i],300,velocity_x,velocity_y,2000,4000,4000,3000,200,200,50,true,true,true); 
.................... 			go_z(300,velocity_z); 
.................... 	   		delay_ms(100); 
.................... 	   		aciona_saida(ALIMENTADOR1); 
....................   	   		aciona_saida(ALIMENTADOR2); 
....................        		aciona_saida(ALIMENTADOR3); 
....................  	   		delay_ms(200); 
....................  	   		desaciona_saida(ALIMENTADOR1); 
....................   	   		desaciona_saida(ALIMENTADOR2); 
....................   	   		desaciona_saida(ALIMENTADOR3); 
....................   	   		go_z(200,velocity_z); 
....................             //go_x_y_z(posicao_x[i],posicao_y[i],140,velocity_x,velocity_y,2000,4000,4000,3000,200,200,50,true,true,true); 
....................  
.................... 	} 
.................... 	       desaciona_saida(FERRO_SOLDA1); 
.................... 		   desaciona_saida(FERRO_SOLDA2); 
....................            go_z(140,2000);	 
.................... 	 
....................  
....................     return erro; 
....................  
.................... } 
....................  
.................... */ 
....................  
.................... void	solda_placa_default(void) 
.................... { 
....................   int i; 
.................... 	 
....................    for(passo = 0;passo <  numero_pontos;passo++) 
*
05B52:  CLRF   54
05B54:  MOVF   26,W
05B56:  SUBWF  54,W
05B58:  BTFSC  FD8.0
05B5A:  GOTO   6B20
....................    { 
.................... 	posiciona_cursor(1,4); 
05B5E:  MOVLW  01
05B60:  MOVLB  1
05B62:  MOVWF  xA5
05B64:  MOVLW  04
05B66:  MOVWF  xA6
05B68:  MOVLB  0
05B6A:  CALL   1F92
.................... 	printf(lcd_putc,"%2u",i); 
05B6E:  MOVFF  199,19A
05B72:  MOVLW  11
05B74:  MOVLB  1
05B76:  MOVWF  x9B
05B78:  MOVLB  0
05B7A:  CALL   2626
....................  
.................... 	pega_data_eeprom(passo); 
05B7E:  MOVFF  54,19A
05B82:  RCALL  53D8
.................... 	switch 	(passo){ 
05B84:  MOVF   54,W
05B86:  BZ    5BF4
05B88:  XORLW  01
05B8A:  BTFSC  FD8.2
05B8C:  BRA    5CD2
05B8E:  XORLW  03
05B90:  BTFSC  FD8.2
05B92:  BRA    5DC6
05B94:  XORLW  01
05B96:  BTFSC  FD8.2
05B98:  BRA    5EA8
05B9A:  XORLW  07
05B9C:  BTFSC  FD8.2
05B9E:  BRA    5FA2
05BA0:  XORLW  01
05BA2:  BTFSC  FD8.2
05BA4:  BRA    5FCC
05BA6:  XORLW  03
05BA8:  BTFSC  FD8.2
05BAA:  BRA    6144
05BAC:  XORLW  01
05BAE:  BTFSC  FD8.2
05BB0:  BRA    616E
05BB2:  XORLW  0F
05BB4:  BTFSC  FD8.2
05BB6:  BRA    6354
05BB8:  XORLW  01
05BBA:  BTFSC  FD8.2
05BBC:  GOTO   64D8
05BC0:  XORLW  03
05BC2:  BTFSC  FD8.2
05BC4:  GOTO   65D0
05BC8:  XORLW  01
05BCA:  BTFSC  FD8.2
05BCC:  GOTO   66B6
05BD0:  XORLW  07
05BD2:  BTFSC  FD8.2
05BD4:  GOTO   67AE
05BD8:  XORLW  01
05BDA:  BTFSC  FD8.2
05BDC:  GOTO   67D8
05BE0:  XORLW  03
05BE2:  BTFSC  FD8.2
05BE4:  GOTO   6906
05BE8:  XORLW  01
05BEA:  BTFSC  FD8.2
05BEC:  GOTO   6930
05BF0:  GOTO   6B1A
....................  
.................... 	case 0:  
....................  
.................... 			checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
05BF4:  MOVFF  2B,19B
05BF8:  MOVFF  2A,19A
05BFC:  MOVFF  2D,19D
05C00:  MOVFF  2C,19C
05C04:  MOVFF  2F,19F
05C08:  MOVFF  2E,19E
05C0C:  RCALL  550A
.................... 			go_x_y(coordenada_x_armazenado - 30,coordenada_y_armazenado,velocity_x,velocity_y,1000,1000,200,200,true,true,false,false);	  
05C0E:  MOVLW  1E
05C10:  SUBWF  2A,W
05C12:  MOVLB  1
05C14:  MOVWF  x9A
05C16:  MOVLW  00
05C18:  SUBWFB 2B,W
05C1A:  MOVWF  x9B
05C1C:  MOVWF  x9D
05C1E:  MOVFF  19A,19C
05C22:  MOVFF  2D,19F
05C26:  MOVFF  2C,19E
05C2A:  MOVLW  01
05C2C:  MOVWF  xA1
05C2E:  MOVLW  2C
05C30:  MOVWF  xA0
05C32:  MOVLW  01
05C34:  MOVWF  xA3
05C36:  MOVLW  2C
05C38:  MOVWF  xA2
05C3A:  MOVLW  03
05C3C:  MOVWF  xA5
05C3E:  MOVLW  E8
05C40:  MOVWF  xA4
05C42:  MOVLW  03
05C44:  MOVWF  xA7
05C46:  MOVLW  E8
05C48:  MOVWF  xA6
05C4A:  MOVLW  C8
05C4C:  MOVWF  xA8
05C4E:  MOVWF  xA9
05C50:  MOVLW  01
05C52:  MOVWF  xAA
05C54:  MOVWF  xAB
05C56:  CLRF   xAC
05C58:  CLRF   xAD
05C5A:  MOVLB  0
05C5C:  CALL   42F6
.................... 	        go_z(coordenada_z_armazenado,3000); 
05C60:  MOVFF  2F,19C
05C64:  MOVFF  2E,19B
05C68:  MOVLW  0B
05C6A:  MOVLB  1
05C6C:  MOVWF  x9E
05C6E:  MOVLW  B8
05C70:  MOVWF  x9D
05C72:  MOVLB  0
05C74:  RCALL  55F6
.................... 			aciona_alimentador_solda(300,1); 
05C76:  MOVLW  01
05C78:  MOVLB  1
05C7A:  MOVWF  x9C
05C7C:  MOVLW  2C
05C7E:  MOVWF  x9B
05C80:  MOVLW  01
05C82:  MOVWF  x9D
05C84:  MOVLB  0
05C86:  RCALL  5680
.................... 		    go_x(coordenada_x_armazenado,5);  
05C88:  MOVFF  2B,19E
05C8C:  MOVFF  2A,19D
05C90:  MOVLW  05
05C92:  MOVLB  1
05C94:  MOVWF  x9F
05C96:  MOVLB  0
05C98:  RCALL  56FC
.................... 	       	delay_ms(1000);  
05C9A:  MOVLW  04
05C9C:  MOVLB  1
05C9E:  MOVWF  x9A
05CA0:  MOVLW  FA
05CA2:  MOVLB  2
05CA4:  MOVWF  x17
05CA6:  MOVLB  0
05CA8:  CALL   1D50
05CAC:  MOVLB  1
05CAE:  DECFSZ x9A,F
05CB0:  BRA    5CA0
.................... 	        posiciona_cursor(4,3); 
05CB2:  MOVLW  04
05CB4:  MOVWF  xA5
05CB6:  MOVLW  03
05CB8:  MOVWF  xA6
05CBA:  MOVLB  0
05CBC:  CALL   1F92
.................... 		    printf(lcd_putc,"%4LU",contador_step_z); 
05CC0:  MOVLW  01
05CC2:  MOVWF  FE9
05CC4:  MOVFF  17F,19C
05CC8:  MOVFF  17E,19B
05CCC:  RCALL  5744
....................  
....................              
....................  
.................... 			break; 
05CCE:  GOTO   6B1A
....................  
.................... 	case 1:  
.................... 			checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
05CD2:  MOVFF  2B,19B
05CD6:  MOVFF  2A,19A
05CDA:  MOVFF  2D,19D
05CDE:  MOVFF  2C,19C
05CE2:  MOVFF  2F,19F
05CE6:  MOVFF  2E,19E
05CEA:  RCALL  550A
.................... 			aciona_alimentador_solda(200,1); 
05CEC:  MOVLB  1
05CEE:  CLRF   x9C
05CF0:  MOVLW  C8
05CF2:  MOVWF  x9B
05CF4:  MOVLW  01
05CF6:  MOVWF  x9D
05CF8:  MOVLB  0
05CFA:  RCALL  5680
.................... 			go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,2000,2000,2000,2000,200,200,true,true,false,false);	 
05CFC:  MOVFF  2B,19D
05D00:  MOVFF  2A,19C
05D04:  MOVFF  2D,19F
05D08:  MOVFF  2C,19E
05D0C:  MOVLW  07
05D0E:  MOVLB  1
05D10:  MOVWF  xA1
05D12:  MOVLW  D0
05D14:  MOVWF  xA0
05D16:  MOVLW  07
05D18:  MOVWF  xA3
05D1A:  MOVLW  D0
05D1C:  MOVWF  xA2
05D1E:  MOVLW  07
05D20:  MOVWF  xA5
05D22:  MOVLW  D0
05D24:  MOVWF  xA4
05D26:  MOVLW  07
05D28:  MOVWF  xA7
05D2A:  MOVLW  D0
05D2C:  MOVWF  xA6
05D2E:  MOVLW  C8
05D30:  MOVWF  xA8
05D32:  MOVWF  xA9
05D34:  MOVLW  01
05D36:  MOVWF  xAA
05D38:  MOVWF  xAB
05D3A:  CLRF   xAC
05D3C:  CLRF   xAD
05D3E:  MOVLB  0
05D40:  CALL   42F6
....................  			delay_ms(1000);  
05D44:  MOVLW  04
05D46:  MOVLB  1
05D48:  MOVWF  x9A
05D4A:  MOVLW  FA
05D4C:  MOVLB  2
05D4E:  MOVWF  x17
05D50:  MOVLB  0
05D52:  CALL   1D50
05D56:  MOVLB  1
05D58:  DECFSZ x9A,F
05D5A:  BRA    5D4A
....................             go_x_y(coordenada_x_armazenado + 30,coordenada_y_armazenado,5000,5000,2000,2000,200,200,true,true,false,false); 
05D5C:  MOVLW  1E
05D5E:  ADDWF  2A,W
05D60:  MOVWF  x9A
05D62:  MOVLW  00
05D64:  ADDWFC 2B,W
05D66:  MOVWF  x9B
05D68:  MOVWF  x9D
05D6A:  MOVFF  19A,19C
05D6E:  MOVFF  2D,19F
05D72:  MOVFF  2C,19E
05D76:  MOVLW  13
05D78:  MOVWF  xA1
05D7A:  MOVLW  88
05D7C:  MOVWF  xA0
05D7E:  MOVLW  13
05D80:  MOVWF  xA3
05D82:  MOVLW  88
05D84:  MOVWF  xA2
05D86:  MOVLW  07
05D88:  MOVWF  xA5
05D8A:  MOVLW  D0
05D8C:  MOVWF  xA4
05D8E:  MOVLW  07
05D90:  MOVWF  xA7
05D92:  MOVLW  D0
05D94:  MOVWF  xA6
05D96:  MOVLW  C8
05D98:  MOVWF  xA8
05D9A:  MOVWF  xA9
05D9C:  MOVLW  01
05D9E:  MOVWF  xAA
05DA0:  MOVWF  xAB
05DA2:  CLRF   xAC
05DA4:  CLRF   xAD
05DA6:  MOVLB  0
05DA8:  CALL   42F6
.................... 			go_z(z_soldar_home,3000); 
05DAC:  MOVFF  149,19C
05DB0:  MOVFF  148,19B
05DB4:  MOVLW  0B
05DB6:  MOVLB  1
05DB8:  MOVWF  x9E
05DBA:  MOVLW  B8
05DBC:  MOVWF  x9D
05DBE:  MOVLB  0
05DC0:  RCALL  55F6
....................  
.................... 			break; 
05DC2:  GOTO   6B1A
....................  
....................     case 2:  
....................              
.................... 			checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
05DC6:  MOVFF  2B,19B
05DCA:  MOVFF  2A,19A
05DCE:  MOVFF  2D,19D
05DD2:  MOVFF  2C,19C
05DD6:  MOVFF  2F,19F
05DDA:  MOVFF  2E,19E
05DDE:  CALL   550A
.................... 			go_x_y(coordenada_x_armazenado - 30,coordenada_y_armazenado,velocity_x,velocity_y,1000,1000,200,200,true,true,false,false);	  
05DE2:  MOVLW  1E
05DE4:  SUBWF  2A,W
05DE6:  MOVLB  1
05DE8:  MOVWF  x9A
05DEA:  MOVLW  00
05DEC:  SUBWFB 2B,W
05DEE:  MOVWF  x9B
05DF0:  MOVWF  x9D
05DF2:  MOVFF  19A,19C
05DF6:  MOVFF  2D,19F
05DFA:  MOVFF  2C,19E
05DFE:  MOVLW  01
05E00:  MOVWF  xA1
05E02:  MOVLW  2C
05E04:  MOVWF  xA0
05E06:  MOVLW  01
05E08:  MOVWF  xA3
05E0A:  MOVLW  2C
05E0C:  MOVWF  xA2
05E0E:  MOVLW  03
05E10:  MOVWF  xA5
05E12:  MOVLW  E8
05E14:  MOVWF  xA4
05E16:  MOVLW  03
05E18:  MOVWF  xA7
05E1A:  MOVLW  E8
05E1C:  MOVWF  xA6
05E1E:  MOVLW  C8
05E20:  MOVWF  xA8
05E22:  MOVWF  xA9
05E24:  MOVLW  01
05E26:  MOVWF  xAA
05E28:  MOVWF  xAB
05E2A:  CLRF   xAC
05E2C:  CLRF   xAD
05E2E:  MOVLB  0
05E30:  CALL   42F6
.................... 			go_z(coordenada_z_armazenado,velocity_z); 
05E34:  MOVFF  2F,19C
05E38:  MOVFF  2E,19B
05E3C:  MOVLW  07
05E3E:  MOVLB  1
05E40:  MOVWF  x9E
05E42:  MOVLW  D0
05E44:  MOVWF  x9D
05E46:  MOVLB  0
05E48:  CALL   55F6
.................... 		    aciona_alimentador_solda(300,1); 
05E4C:  MOVLW  01
05E4E:  MOVLB  1
05E50:  MOVWF  x9C
05E52:  MOVLW  2C
05E54:  MOVWF  x9B
05E56:  MOVLW  01
05E58:  MOVWF  x9D
05E5A:  MOVLB  0
05E5C:  RCALL  5680
....................             go_x(coordenada_x_armazenado,5);  
05E5E:  MOVFF  2B,19E
05E62:  MOVFF  2A,19D
05E66:  MOVLW  05
05E68:  MOVLB  1
05E6A:  MOVWF  x9F
05E6C:  MOVLB  0
05E6E:  RCALL  56FC
.................... 	        delay_ms(1000);   
05E70:  MOVLW  04
05E72:  MOVLB  1
05E74:  MOVWF  x9A
05E76:  MOVLW  FA
05E78:  MOVLB  2
05E7A:  MOVWF  x17
05E7C:  MOVLB  0
05E7E:  CALL   1D50
05E82:  MOVLB  1
05E84:  DECFSZ x9A,F
05E86:  BRA    5E76
.................... 	        posiciona_cursor(4,3); 
05E88:  MOVLW  04
05E8A:  MOVWF  xA5
05E8C:  MOVLW  03
05E8E:  MOVWF  xA6
05E90:  MOVLB  0
05E92:  CALL   1F92
.................... 		    printf(lcd_putc,"%4LU",contador_step_z); 
05E96:  MOVLW  01
05E98:  MOVWF  FE9
05E9A:  MOVFF  17F,19C
05E9E:  MOVFF  17E,19B
05EA2:  RCALL  5744
....................  
.................... 			break; 
05EA4:  GOTO   6B1A
.................... 	   
.................... 	case 3: checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
05EA8:  MOVFF  2B,19B
05EAC:  MOVFF  2A,19A
05EB0:  MOVFF  2D,19D
05EB4:  MOVFF  2C,19C
05EB8:  MOVFF  2F,19F
05EBC:  MOVFF  2E,19E
05EC0:  CALL   550A
.................... 			aciona_alimentador_solda(200,1); 
05EC4:  MOVLB  1
05EC6:  CLRF   x9C
05EC8:  MOVLW  C8
05ECA:  MOVWF  x9B
05ECC:  MOVLW  01
05ECE:  MOVWF  x9D
05ED0:  MOVLB  0
05ED2:  CALL   5680
.................... 			go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,2000,2000,2000,2000,200,200,true,true,false,false);	 
05ED6:  MOVFF  2B,19D
05EDA:  MOVFF  2A,19C
05EDE:  MOVFF  2D,19F
05EE2:  MOVFF  2C,19E
05EE6:  MOVLW  07
05EE8:  MOVLB  1
05EEA:  MOVWF  xA1
05EEC:  MOVLW  D0
05EEE:  MOVWF  xA0
05EF0:  MOVLW  07
05EF2:  MOVWF  xA3
05EF4:  MOVLW  D0
05EF6:  MOVWF  xA2
05EF8:  MOVLW  07
05EFA:  MOVWF  xA5
05EFC:  MOVLW  D0
05EFE:  MOVWF  xA4
05F00:  MOVLW  07
05F02:  MOVWF  xA7
05F04:  MOVLW  D0
05F06:  MOVWF  xA6
05F08:  MOVLW  C8
05F0A:  MOVWF  xA8
05F0C:  MOVWF  xA9
05F0E:  MOVLW  01
05F10:  MOVWF  xAA
05F12:  MOVWF  xAB
05F14:  CLRF   xAC
05F16:  CLRF   xAD
05F18:  MOVLB  0
05F1A:  CALL   42F6
....................  			delay_ms(1000);  
05F1E:  MOVLW  04
05F20:  MOVLB  1
05F22:  MOVWF  x9A
05F24:  MOVLW  FA
05F26:  MOVLB  2
05F28:  MOVWF  x17
05F2A:  MOVLB  0
05F2C:  CALL   1D50
05F30:  MOVLB  1
05F32:  DECFSZ x9A,F
05F34:  BRA    5F24
....................             go_x_y(coordenada_x_armazenado + 30,coordenada_y_armazenado,5000,5000,2000,2000,200,200,true,true,false,false); 
05F36:  MOVLW  1E
05F38:  ADDWF  2A,W
05F3A:  MOVWF  x9A
05F3C:  MOVLW  00
05F3E:  ADDWFC 2B,W
05F40:  MOVWF  x9B
05F42:  MOVWF  x9D
05F44:  MOVFF  19A,19C
05F48:  MOVFF  2D,19F
05F4C:  MOVFF  2C,19E
05F50:  MOVLW  13
05F52:  MOVWF  xA1
05F54:  MOVLW  88
05F56:  MOVWF  xA0
05F58:  MOVLW  13
05F5A:  MOVWF  xA3
05F5C:  MOVLW  88
05F5E:  MOVWF  xA2
05F60:  MOVLW  07
05F62:  MOVWF  xA5
05F64:  MOVLW  D0
05F66:  MOVWF  xA4
05F68:  MOVLW  07
05F6A:  MOVWF  xA7
05F6C:  MOVLW  D0
05F6E:  MOVWF  xA6
05F70:  MOVLW  C8
05F72:  MOVWF  xA8
05F74:  MOVWF  xA9
05F76:  MOVLW  01
05F78:  MOVWF  xAA
05F7A:  MOVWF  xAB
05F7C:  CLRF   xAC
05F7E:  CLRF   xAD
05F80:  MOVLB  0
05F82:  CALL   42F6
.................... 			go_z(z_soldar_home,3000); 
05F86:  MOVFF  149,19C
05F8A:  MOVFF  148,19B
05F8E:  MOVLW  0B
05F90:  MOVLB  1
05F92:  MOVWF  x9E
05F94:  MOVLW  B8
05F96:  MOVWF  x9D
05F98:  MOVLB  0
05F9A:  CALL   55F6
.................... 			break; 
05F9E:  GOTO   6B1A
....................  
.................... 	case 4: checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
05FA2:  MOVFF  2B,19B
05FA6:  MOVFF  2A,19A
05FAA:  MOVFF  2D,19D
05FAE:  MOVFF  2C,19C
05FB2:  MOVFF  2F,19F
05FB6:  MOVFF  2E,19E
05FBA:  CALL   550A
.................... 			solda_mola(1); 
05FBE:  MOVLW  01
05FC0:  MOVLB  1
05FC2:  MOVWF  x9A
05FC4:  MOVLB  0
05FC6:  RCALL  580A
....................     		break; 
05FC8:  GOTO   6B1A
....................  
.................... 	case 5: checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
05FCC:  MOVFF  2B,19B
05FD0:  MOVFF  2A,19A
05FD4:  MOVFF  2D,19D
05FD8:  MOVFF  2C,19C
05FDC:  MOVFF  2F,19F
05FE0:  MOVFF  2E,19E
05FE4:  CALL   550A
.................... 		   	go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,5000,5000,2000,2000,200,200,true,true,false,false);	  
05FE8:  MOVFF  2B,19D
05FEC:  MOVFF  2A,19C
05FF0:  MOVFF  2D,19F
05FF4:  MOVFF  2C,19E
05FF8:  MOVLW  13
05FFA:  MOVLB  1
05FFC:  MOVWF  xA1
05FFE:  MOVLW  88
06000:  MOVWF  xA0
06002:  MOVLW  13
06004:  MOVWF  xA3
06006:  MOVLW  88
06008:  MOVWF  xA2
0600A:  MOVLW  07
0600C:  MOVWF  xA5
0600E:  MOVLW  D0
06010:  MOVWF  xA4
06012:  MOVLW  07
06014:  MOVWF  xA7
06016:  MOVLW  D0
06018:  MOVWF  xA6
0601A:  MOVLW  C8
0601C:  MOVWF  xA8
0601E:  MOVWF  xA9
06020:  MOVLW  01
06022:  MOVWF  xAA
06024:  MOVWF  xAB
06026:  CLRF   xAC
06028:  CLRF   xAD
0602A:  MOVLB  0
0602C:  CALL   42F6
.................... 			aciona_alimentador_solda(200,1); 
06030:  MOVLB  1
06032:  CLRF   x9C
06034:  MOVLW  C8
06036:  MOVWF  x9B
06038:  MOVLW  01
0603A:  MOVWF  x9D
0603C:  MOVLB  0
0603E:  CALL   5680
.................... 			go_z(coordenada_z_armazenado,velocity_z); 
06042:  MOVFF  2F,19C
06046:  MOVFF  2E,19B
0604A:  MOVLW  07
0604C:  MOVLB  1
0604E:  MOVWF  x9E
06050:  MOVLW  D0
06052:  MOVWF  x9D
06054:  MOVLB  0
06056:  CALL   55F6
.................... 			delay_ms(2000);   
0605A:  MOVLW  08
0605C:  MOVLB  1
0605E:  MOVWF  x9A
06060:  MOVLW  FA
06062:  MOVLB  2
06064:  MOVWF  x17
06066:  MOVLB  0
06068:  CALL   1D50
0606C:  MOVLB  1
0606E:  DECFSZ x9A,F
06070:  BRA    6060
.................... 		 	go_x_y(coordenada_x_armazenado + 30,coordenada_y_armazenado,12000,12000,2000,2000,200,200,false,false,false,false); 
06072:  MOVLW  1E
06074:  ADDWF  2A,W
06076:  MOVWF  x9A
06078:  MOVLW  00
0607A:  ADDWFC 2B,W
0607C:  MOVWF  x9B
0607E:  MOVWF  x9D
06080:  MOVFF  19A,19C
06084:  MOVFF  2D,19F
06088:  MOVFF  2C,19E
0608C:  MOVLW  2E
0608E:  MOVWF  xA1
06090:  MOVLW  E0
06092:  MOVWF  xA0
06094:  MOVLW  2E
06096:  MOVWF  xA3
06098:  MOVLW  E0
0609A:  MOVWF  xA2
0609C:  MOVLW  07
0609E:  MOVWF  xA5
060A0:  MOVLW  D0
060A2:  MOVWF  xA4
060A4:  MOVLW  07
060A6:  MOVWF  xA7
060A8:  MOVLW  D0
060AA:  MOVWF  xA6
060AC:  MOVLW  C8
060AE:  MOVWF  xA8
060B0:  MOVWF  xA9
060B2:  CLRF   xAA
060B4:  CLRF   xAB
060B6:  CLRF   xAC
060B8:  CLRF   xAD
060BA:  MOVLB  0
060BC:  CALL   42F6
.................... 		 	go_z(z_soldar_home,velocity_z);	 
060C0:  MOVFF  149,19C
060C4:  MOVFF  148,19B
060C8:  MOVLW  07
060CA:  MOVLB  1
060CC:  MOVWF  x9E
060CE:  MOVLW  D0
060D0:  MOVWF  x9D
060D2:  MOVLB  0
060D4:  CALL   55F6
.................... 			go_x_y(coordenada_x_armazenado,coordenada_y_armazenado ,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
060D8:  MOVFF  2B,19D
060DC:  MOVFF  2A,19C
060E0:  MOVFF  2D,19F
060E4:  MOVFF  2C,19E
060E8:  MOVLW  01
060EA:  MOVLB  1
060EC:  MOVWF  xA1
060EE:  MOVLW  2C
060F0:  MOVWF  xA0
060F2:  MOVLW  01
060F4:  MOVWF  xA3
060F6:  MOVLW  2C
060F8:  MOVWF  xA2
060FA:  MOVLW  07
060FC:  MOVWF  xA5
060FE:  MOVLW  D0
06100:  MOVWF  xA4
06102:  MOVLW  07
06104:  MOVWF  xA7
06106:  MOVLW  D0
06108:  MOVWF  xA6
0610A:  MOVLW  C8
0610C:  MOVWF  xA8
0610E:  MOVWF  xA9
06110:  MOVLW  01
06112:  MOVWF  xAA
06114:  MOVWF  xAB
06116:  CLRF   xAC
06118:  CLRF   xAD
0611A:  MOVLB  0
0611C:  CALL   42F6
.................... 			posiciona_cursor(4,3); 
06120:  MOVLW  04
06122:  MOVLB  1
06124:  MOVWF  xA5
06126:  MOVLW  03
06128:  MOVWF  xA6
0612A:  MOVLB  0
0612C:  CALL   1F92
.................... 			printf(lcd_putc,"%4LU",contador_step_z); 
06130:  MOVLW  01
06132:  MOVWF  FE9
06134:  MOVFF  17F,19C
06138:  MOVFF  17E,19B
0613C:  CALL   5744
.................... 			break; 
06140:  GOTO   6B1A
....................  
.................... 	case 6: checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
06144:  MOVFF  2B,19B
06148:  MOVFF  2A,19A
0614C:  MOVFF  2D,19D
06150:  MOVFF  2C,19C
06154:  MOVFF  2F,19F
06158:  MOVFF  2E,19E
0615C:  CALL   550A
.................... 			solda_mola_2(1); 
06160:  MOVLW  01
06162:  MOVLB  1
06164:  MOVWF  x9A
06166:  MOVLB  0
06168:  RCALL  59AE
....................  
.................... 			break; 
0616A:  GOTO   6B1A
....................  
.................... 	case 7: checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
0616E:  MOVFF  2B,19B
06172:  MOVFF  2A,19A
06176:  MOVFF  2D,19D
0617A:  MOVFF  2C,19C
0617E:  MOVFF  2F,19F
06182:  MOVFF  2E,19E
06186:  CALL   550A
.................... 			go_z(z_soldar_home,velocity_z); 
0618A:  MOVFF  149,19C
0618E:  MOVFF  148,19B
06192:  MOVLW  07
06194:  MOVLB  1
06196:  MOVWF  x9E
06198:  MOVLW  D0
0619A:  MOVWF  x9D
0619C:  MOVLB  0
0619E:  CALL   55F6
....................           	go_x_y(coordenada_x_armazenado - 30,coordenada_y_armazenado,velocity_x,velocity_y,1000,1000,200,200,true,true,false,false);	  
061A2:  MOVLW  1E
061A4:  SUBWF  2A,W
061A6:  MOVLB  1
061A8:  MOVWF  x9A
061AA:  MOVLW  00
061AC:  SUBWFB 2B,W
061AE:  MOVWF  x9B
061B0:  MOVWF  x9D
061B2:  MOVFF  19A,19C
061B6:  MOVFF  2D,19F
061BA:  MOVFF  2C,19E
061BE:  MOVLW  01
061C0:  MOVWF  xA1
061C2:  MOVLW  2C
061C4:  MOVWF  xA0
061C6:  MOVLW  01
061C8:  MOVWF  xA3
061CA:  MOVLW  2C
061CC:  MOVWF  xA2
061CE:  MOVLW  03
061D0:  MOVWF  xA5
061D2:  MOVLW  E8
061D4:  MOVWF  xA4
061D6:  MOVLW  03
061D8:  MOVWF  xA7
061DA:  MOVLW  E8
061DC:  MOVWF  xA6
061DE:  MOVLW  C8
061E0:  MOVWF  xA8
061E2:  MOVWF  xA9
061E4:  MOVLW  01
061E6:  MOVWF  xAA
061E8:  MOVWF  xAB
061EA:  CLRF   xAC
061EC:  CLRF   xAD
061EE:  MOVLB  0
061F0:  CALL   42F6
.................... 		    go_z(coordenada_z_armazenado,velocity_z); 
061F4:  MOVFF  2F,19C
061F8:  MOVFF  2E,19B
061FC:  MOVLW  07
061FE:  MOVLB  1
06200:  MOVWF  x9E
06202:  MOVLW  D0
06204:  MOVWF  x9D
06206:  MOVLB  0
06208:  CALL   55F6
....................             aciona_alimentador_solda(200,1); 
0620C:  MOVLB  1
0620E:  CLRF   x9C
06210:  MOVLW  C8
06212:  MOVWF  x9B
06214:  MOVLW  01
06216:  MOVWF  x9D
06218:  MOVLB  0
0621A:  CALL   5680
.................... 			go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,12000,12000,2000,2000,200,200,true,true,false,false); 
0621E:  MOVFF  2B,19D
06222:  MOVFF  2A,19C
06226:  MOVFF  2D,19F
0622A:  MOVFF  2C,19E
0622E:  MOVLW  2E
06230:  MOVLB  1
06232:  MOVWF  xA1
06234:  MOVLW  E0
06236:  MOVWF  xA0
06238:  MOVLW  2E
0623A:  MOVWF  xA3
0623C:  MOVLW  E0
0623E:  MOVWF  xA2
06240:  MOVLW  07
06242:  MOVWF  xA5
06244:  MOVLW  D0
06246:  MOVWF  xA4
06248:  MOVLW  07
0624A:  MOVWF  xA7
0624C:  MOVLW  D0
0624E:  MOVWF  xA6
06250:  MOVLW  C8
06252:  MOVWF  xA8
06254:  MOVWF  xA9
06256:  MOVLW  01
06258:  MOVWF  xAA
0625A:  MOVWF  xAB
0625C:  CLRF   xAC
0625E:  CLRF   xAD
06260:  MOVLB  0
06262:  CALL   42F6
.................... 			delay_ms(2000);   
06266:  MOVLW  08
06268:  MOVLB  1
0626A:  MOVWF  x9A
0626C:  MOVLW  FA
0626E:  MOVLB  2
06270:  MOVWF  x17
06272:  MOVLB  0
06274:  CALL   1D50
06278:  MOVLB  1
0627A:  DECFSZ x9A,F
0627C:  BRA    626C
.................... 		 	go_x_y(coordenada_x_armazenado,coordenada_y_armazenado - 5,5000,5000,2000,2000,200,200,false,false,false,false); 
0627E:  MOVLW  05
06280:  SUBWF  2C,W
06282:  MOVWF  x9A
06284:  MOVLW  00
06286:  SUBWFB 2D,W
06288:  MOVWF  x9B
0628A:  MOVFF  2B,19D
0628E:  MOVFF  2A,19C
06292:  MOVWF  x9F
06294:  MOVFF  19A,19E
06298:  MOVLW  13
0629A:  MOVWF  xA1
0629C:  MOVLW  88
0629E:  MOVWF  xA0
062A0:  MOVLW  13
062A2:  MOVWF  xA3
062A4:  MOVLW  88
062A6:  MOVWF  xA2
062A8:  MOVLW  07
062AA:  MOVWF  xA5
062AC:  MOVLW  D0
062AE:  MOVWF  xA4
062B0:  MOVLW  07
062B2:  MOVWF  xA7
062B4:  MOVLW  D0
062B6:  MOVWF  xA6
062B8:  MOVLW  C8
062BA:  MOVWF  xA8
062BC:  MOVWF  xA9
062BE:  CLRF   xAA
062C0:  CLRF   xAB
062C2:  CLRF   xAC
062C4:  CLRF   xAD
062C6:  MOVLB  0
062C8:  CALL   42F6
.................... 		 	go_x_y(coordenada_x_armazenado + 25,coordenada_y_armazenado,5000,5000,2000,2000,200,200,false,false,false,false); 
062CC:  MOVLW  19
062CE:  ADDWF  2A,W
062D0:  MOVLB  1
062D2:  MOVWF  x9A
062D4:  MOVLW  00
062D6:  ADDWFC 2B,W
062D8:  MOVWF  x9B
062DA:  MOVWF  x9D
062DC:  MOVFF  19A,19C
062E0:  MOVFF  2D,19F
062E4:  MOVFF  2C,19E
062E8:  MOVLW  13
062EA:  MOVWF  xA1
062EC:  MOVLW  88
062EE:  MOVWF  xA0
062F0:  MOVLW  13
062F2:  MOVWF  xA3
062F4:  MOVLW  88
062F6:  MOVWF  xA2
062F8:  MOVLW  07
062FA:  MOVWF  xA5
062FC:  MOVLW  D0
062FE:  MOVWF  xA4
06300:  MOVLW  07
06302:  MOVWF  xA7
06304:  MOVLW  D0
06306:  MOVWF  xA6
06308:  MOVLW  C8
0630A:  MOVWF  xA8
0630C:  MOVWF  xA9
0630E:  CLRF   xAA
06310:  CLRF   xAB
06312:  CLRF   xAC
06314:  CLRF   xAD
06316:  MOVLB  0
06318:  CALL   42F6
.................... 			go_z(100,velocity_z);	 
0631C:  MOVLB  1
0631E:  CLRF   x9C
06320:  MOVLW  64
06322:  MOVWF  x9B
06324:  MOVLW  07
06326:  MOVWF  x9E
06328:  MOVLW  D0
0632A:  MOVWF  x9D
0632C:  MOVLB  0
0632E:  CALL   55F6
.................... 			posiciona_cursor(4,3); 
06332:  MOVLW  04
06334:  MOVLB  1
06336:  MOVWF  xA5
06338:  MOVLW  03
0633A:  MOVWF  xA6
0633C:  MOVLB  0
0633E:  CALL   1F92
.................... 			printf(lcd_putc,"%4LU",contador_step_z); 
06342:  MOVLW  01
06344:  MOVWF  FE9
06346:  MOVFF  17F,19C
0634A:  MOVFF  17E,19B
0634E:  CALL   5744
....................  
.................... 			break; 
06352:  BRA    6B1A
....................  
.................... 	case 8:  
....................  
.................... 			if(n_maquina == 1)	aciona_saida(FERRO_SOLDA1); 
06354:  DECFSZ 1D,W
06356:  BRA    6366
06358:  MOVLB  1
0635A:  CLRF   xA1
0635C:  MOVLW  03
0635E:  MOVWF  xA0
06360:  MOVLB  0
06362:  CALL   2FD2
.................... 	        if(n_maquina == 2)	desaciona_saida(FERRO_SOLDA1); 
06366:  MOVF   1D,W
06368:  SUBLW  02
0636A:  BNZ   6386
0636C:  CLRF   16
0636E:  BTFSC  FF2.7
06370:  BSF    16.7
06372:  BCF    FF2.7
06374:  MOVLB  2
06376:  CLRF   x1B
06378:  MOVLW  03
0637A:  MOVWF  x1A
0637C:  MOVLB  0
0637E:  CALL   1B96
06382:  BTFSC  16.7
06384:  BSF    FF2.7
....................  
.................... 			delay_ms(200); 
06386:  MOVLW  C8
06388:  MOVLB  2
0638A:  MOVWF  x17
0638C:  MOVLB  0
0638E:  CALL   1D50
.................... 			posiciona_cursor(1,1); 
06392:  MOVLW  01
06394:  MOVLB  1
06396:  MOVWF  xA5
06398:  MOVWF  xA6
0639A:  MOVLB  0
0639C:  CALL   1F92
....................             printf(lcd_putc,"P:                  \n\r"); 
063A0:  MOVLW  D6
063A2:  MOVWF  FF6
063A4:  MOVLW  10
063A6:  MOVWF  FF7
063A8:  CALL   25DA
....................             printf(lcd_putc,"                    \n\r"); 
063AC:  MOVLW  EE
063AE:  MOVWF  FF6
063B0:  MOVLW  10
063B2:  MOVWF  FF7
063B4:  CALL   25DA
....................         	printf(lcd_putc,"     SOLDANDO       \n\r"); 
063B8:  MOVLW  06
063BA:  MOVWF  FF6
063BC:  MOVLW  11
063BE:  MOVWF  FF7
063C0:  CALL   25DA
.................... 	        printf(lcd_putc,"     ESTAGIO2       "); 
063C4:  MOVLW  1E
063C6:  MOVWF  FF6
063C8:  MOVLW  11
063CA:  MOVWF  FF7
063CC:  CALL   25DA
.................... 	 
.................... 			checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
063D0:  MOVFF  2B,19B
063D4:  MOVFF  2A,19A
063D8:  MOVFF  2D,19D
063DC:  MOVFF  2C,19C
063E0:  MOVFF  2F,19F
063E4:  MOVFF  2E,19E
063E8:  CALL   550A
.................... 			go_x_y(coordenada_x_armazenado - 30,coordenada_y_armazenado,velocity_x,velocity_y,1000,1000,200,200,true,true,false,false);	  
063EC:  MOVLW  1E
063EE:  SUBWF  2A,W
063F0:  MOVLB  1
063F2:  MOVWF  x9A
063F4:  MOVLW  00
063F6:  SUBWFB 2B,W
063F8:  MOVWF  x9B
063FA:  MOVWF  x9D
063FC:  MOVFF  19A,19C
06400:  MOVFF  2D,19F
06404:  MOVFF  2C,19E
06408:  MOVLW  01
0640A:  MOVWF  xA1
0640C:  MOVLW  2C
0640E:  MOVWF  xA0
06410:  MOVLW  01
06412:  MOVWF  xA3
06414:  MOVLW  2C
06416:  MOVWF  xA2
06418:  MOVLW  03
0641A:  MOVWF  xA5
0641C:  MOVLW  E8
0641E:  MOVWF  xA4
06420:  MOVLW  03
06422:  MOVWF  xA7
06424:  MOVLW  E8
06426:  MOVWF  xA6
06428:  MOVLW  C8
0642A:  MOVWF  xA8
0642C:  MOVWF  xA9
0642E:  MOVLW  01
06430:  MOVWF  xAA
06432:  MOVWF  xAB
06434:  CLRF   xAC
06436:  CLRF   xAD
06438:  MOVLB  0
0643A:  CALL   42F6
.................... 	        if(n_maquina == 1) envia_posicao_para_maquina2(POSICAO_SOLDA_ESTAGIO2);    
0643E:  DECFSZ 1D,W
06440:  BRA    644E
06442:  MOVLW  04
06444:  MOVLB  1
06446:  MOVWF  x9A
06448:  MOVLB  0
0644A:  CALL   39AC
....................             if(n_maquina == 2) envia_posicao_para_maquina1(POSICAO_SOLDA_ESTAGIO2); 
0644E:  MOVF   1D,W
06450:  SUBLW  02
06452:  BNZ   6460
06454:  MOVLW  04
06456:  MOVLB  1
06458:  MOVWF  x9A
0645A:  MOVLB  0
0645C:  CALL   50A4
.................... 			go_z(coordenada_z_armazenado,3000); 
06460:  MOVFF  2F,19C
06464:  MOVFF  2E,19B
06468:  MOVLW  0B
0646A:  MOVLB  1
0646C:  MOVWF  x9E
0646E:  MOVLW  B8
06470:  MOVWF  x9D
06472:  MOVLB  0
06474:  CALL   55F6
.................... 			aciona_alimentador_solda(300,2); 
06478:  MOVLW  01
0647A:  MOVLB  1
0647C:  MOVWF  x9C
0647E:  MOVLW  2C
06480:  MOVWF  x9B
06482:  MOVLW  02
06484:  MOVWF  x9D
06486:  MOVLB  0
06488:  CALL   5680
.................... 		    go_x(coordenada_x_armazenado,5);  
0648C:  MOVFF  2B,19E
06490:  MOVFF  2A,19D
06494:  MOVLW  05
06496:  MOVLB  1
06498:  MOVWF  x9F
0649A:  MOVLB  0
0649C:  CALL   56FC
.................... 	       	delay_ms(500);  
064A0:  MOVLW  02
064A2:  MOVLB  1
064A4:  MOVWF  x9A
064A6:  MOVLW  FA
064A8:  MOVLB  2
064AA:  MOVWF  x17
064AC:  MOVLB  0
064AE:  CALL   1D50
064B2:  MOVLB  1
064B4:  DECFSZ x9A,F
064B6:  BRA    64A6
.................... 	        posiciona_cursor(4,3); 
064B8:  MOVLW  04
064BA:  MOVWF  xA5
064BC:  MOVLW  03
064BE:  MOVWF  xA6
064C0:  MOVLB  0
064C2:  CALL   1F92
.................... 		    printf(lcd_putc,"%4LU",contador_step_z); 
064C6:  MOVLW  01
064C8:  MOVWF  FE9
064CA:  MOVFF  17F,19C
064CE:  MOVFF  17E,19B
064D2:  CALL   5744
....................  
....................  
....................  
.................... 			break; 
064D6:  BRA    6B1A
....................  
.................... 	case 9:  
.................... 			checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
064D8:  MOVFF  2B,19B
064DC:  MOVFF  2A,19A
064E0:  MOVFF  2D,19D
064E4:  MOVFF  2C,19C
064E8:  MOVFF  2F,19F
064EC:  MOVFF  2E,19E
064F0:  CALL   550A
.................... 			aciona_alimentador_solda(200,2); 
064F4:  MOVLB  1
064F6:  CLRF   x9C
064F8:  MOVLW  C8
064FA:  MOVWF  x9B
064FC:  MOVLW  02
064FE:  MOVWF  x9D
06500:  MOVLB  0
06502:  CALL   5680
.................... 			go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,2000,2000,2000,2000,200,200,true,true,false,false);	 
06506:  MOVFF  2B,19D
0650A:  MOVFF  2A,19C
0650E:  MOVFF  2D,19F
06512:  MOVFF  2C,19E
06516:  MOVLW  07
06518:  MOVLB  1
0651A:  MOVWF  xA1
0651C:  MOVLW  D0
0651E:  MOVWF  xA0
06520:  MOVLW  07
06522:  MOVWF  xA3
06524:  MOVLW  D0
06526:  MOVWF  xA2
06528:  MOVLW  07
0652A:  MOVWF  xA5
0652C:  MOVLW  D0
0652E:  MOVWF  xA4
06530:  MOVLW  07
06532:  MOVWF  xA7
06534:  MOVLW  D0
06536:  MOVWF  xA6
06538:  MOVLW  C8
0653A:  MOVWF  xA8
0653C:  MOVWF  xA9
0653E:  MOVLW  01
06540:  MOVWF  xAA
06542:  MOVWF  xAB
06544:  CLRF   xAC
06546:  CLRF   xAD
06548:  MOVLB  0
0654A:  CALL   42F6
....................  			delay_ms(1000);  
0654E:  MOVLW  04
06550:  MOVLB  1
06552:  MOVWF  x9A
06554:  MOVLW  FA
06556:  MOVLB  2
06558:  MOVWF  x17
0655A:  MOVLB  0
0655C:  CALL   1D50
06560:  MOVLB  1
06562:  DECFSZ x9A,F
06564:  BRA    6554
....................             go_x_y(coordenada_x_armazenado + 30,coordenada_y_armazenado,5000,5000,2000,2000,200,200,true,true,false,false); 
06566:  MOVLW  1E
06568:  ADDWF  2A,W
0656A:  MOVWF  x9A
0656C:  MOVLW  00
0656E:  ADDWFC 2B,W
06570:  MOVWF  x9B
06572:  MOVWF  x9D
06574:  MOVFF  19A,19C
06578:  MOVFF  2D,19F
0657C:  MOVFF  2C,19E
06580:  MOVLW  13
06582:  MOVWF  xA1
06584:  MOVLW  88
06586:  MOVWF  xA0
06588:  MOVLW  13
0658A:  MOVWF  xA3
0658C:  MOVLW  88
0658E:  MOVWF  xA2
06590:  MOVLW  07
06592:  MOVWF  xA5
06594:  MOVLW  D0
06596:  MOVWF  xA4
06598:  MOVLW  07
0659A:  MOVWF  xA7
0659C:  MOVLW  D0
0659E:  MOVWF  xA6
065A0:  MOVLW  C8
065A2:  MOVWF  xA8
065A4:  MOVWF  xA9
065A6:  MOVLW  01
065A8:  MOVWF  xAA
065AA:  MOVWF  xAB
065AC:  CLRF   xAC
065AE:  CLRF   xAD
065B0:  MOVLB  0
065B2:  CALL   42F6
.................... 			go_z(z_soldar_home,5000); 
065B6:  MOVFF  149,19C
065BA:  MOVFF  148,19B
065BE:  MOVLW  13
065C0:  MOVLB  1
065C2:  MOVWF  x9E
065C4:  MOVLW  88
065C6:  MOVWF  x9D
065C8:  MOVLB  0
065CA:  CALL   55F6
....................  
.................... 			break; 
065CE:  BRA    6B1A
....................  
....................     case 10:  
....................              
.................... 			checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
065D0:  MOVFF  2B,19B
065D4:  MOVFF  2A,19A
065D8:  MOVFF  2D,19D
065DC:  MOVFF  2C,19C
065E0:  MOVFF  2F,19F
065E4:  MOVFF  2E,19E
065E8:  CALL   550A
.................... 			go_x_y(coordenada_x_armazenado - 30,coordenada_y_armazenado,velocity_x,velocity_y,1000,1000,200,200,true,true,false,false);	  
065EC:  MOVLW  1E
065EE:  SUBWF  2A,W
065F0:  MOVLB  1
065F2:  MOVWF  x9A
065F4:  MOVLW  00
065F6:  SUBWFB 2B,W
065F8:  MOVWF  x9B
065FA:  MOVWF  x9D
065FC:  MOVFF  19A,19C
06600:  MOVFF  2D,19F
06604:  MOVFF  2C,19E
06608:  MOVLW  01
0660A:  MOVWF  xA1
0660C:  MOVLW  2C
0660E:  MOVWF  xA0
06610:  MOVLW  01
06612:  MOVWF  xA3
06614:  MOVLW  2C
06616:  MOVWF  xA2
06618:  MOVLW  03
0661A:  MOVWF  xA5
0661C:  MOVLW  E8
0661E:  MOVWF  xA4
06620:  MOVLW  03
06622:  MOVWF  xA7
06624:  MOVLW  E8
06626:  MOVWF  xA6
06628:  MOVLW  C8
0662A:  MOVWF  xA8
0662C:  MOVWF  xA9
0662E:  MOVLW  01
06630:  MOVWF  xAA
06632:  MOVWF  xAB
06634:  CLRF   xAC
06636:  CLRF   xAD
06638:  MOVLB  0
0663A:  CALL   42F6
.................... 			go_z(coordenada_z_armazenado,velocity_z); 
0663E:  MOVFF  2F,19C
06642:  MOVFF  2E,19B
06646:  MOVLW  07
06648:  MOVLB  1
0664A:  MOVWF  x9E
0664C:  MOVLW  D0
0664E:  MOVWF  x9D
06650:  MOVLB  0
06652:  CALL   55F6
.................... 		    aciona_alimentador_solda(300,2); 
06656:  MOVLW  01
06658:  MOVLB  1
0665A:  MOVWF  x9C
0665C:  MOVLW  2C
0665E:  MOVWF  x9B
06660:  MOVLW  02
06662:  MOVWF  x9D
06664:  MOVLB  0
06666:  CALL   5680
....................             go_x(coordenada_x_armazenado,5);  
0666A:  MOVFF  2B,19E
0666E:  MOVFF  2A,19D
06672:  MOVLW  05
06674:  MOVLB  1
06676:  MOVWF  x9F
06678:  MOVLB  0
0667A:  CALL   56FC
.................... 	        delay_ms(1000);   
0667E:  MOVLW  04
06680:  MOVLB  1
06682:  MOVWF  x9A
06684:  MOVLW  FA
06686:  MOVLB  2
06688:  MOVWF  x17
0668A:  MOVLB  0
0668C:  CALL   1D50
06690:  MOVLB  1
06692:  DECFSZ x9A,F
06694:  BRA    6684
.................... 	        posiciona_cursor(4,3); 
06696:  MOVLW  04
06698:  MOVWF  xA5
0669A:  MOVLW  03
0669C:  MOVWF  xA6
0669E:  MOVLB  0
066A0:  CALL   1F92
.................... 		    printf(lcd_putc,"%4LU",contador_step_z); 
066A4:  MOVLW  01
066A6:  MOVWF  FE9
066A8:  MOVFF  17F,19C
066AC:  MOVFF  17E,19B
066B0:  CALL   5744
....................  
....................  
....................  
.................... 			break; 
066B4:  BRA    6B1A
.................... 	   
.................... 	case 11: checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
066B6:  MOVFF  2B,19B
066BA:  MOVFF  2A,19A
066BE:  MOVFF  2D,19D
066C2:  MOVFF  2C,19C
066C6:  MOVFF  2F,19F
066CA:  MOVFF  2E,19E
066CE:  CALL   550A
.................... 			aciona_alimentador_solda(200,2); 
066D2:  MOVLB  1
066D4:  CLRF   x9C
066D6:  MOVLW  C8
066D8:  MOVWF  x9B
066DA:  MOVLW  02
066DC:  MOVWF  x9D
066DE:  MOVLB  0
066E0:  CALL   5680
.................... 			go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,2000,2000,2000,2000,200,200,true,true,false,false);	 
066E4:  MOVFF  2B,19D
066E8:  MOVFF  2A,19C
066EC:  MOVFF  2D,19F
066F0:  MOVFF  2C,19E
066F4:  MOVLW  07
066F6:  MOVLB  1
066F8:  MOVWF  xA1
066FA:  MOVLW  D0
066FC:  MOVWF  xA0
066FE:  MOVLW  07
06700:  MOVWF  xA3
06702:  MOVLW  D0
06704:  MOVWF  xA2
06706:  MOVLW  07
06708:  MOVWF  xA5
0670A:  MOVLW  D0
0670C:  MOVWF  xA4
0670E:  MOVLW  07
06710:  MOVWF  xA7
06712:  MOVLW  D0
06714:  MOVWF  xA6
06716:  MOVLW  C8
06718:  MOVWF  xA8
0671A:  MOVWF  xA9
0671C:  MOVLW  01
0671E:  MOVWF  xAA
06720:  MOVWF  xAB
06722:  CLRF   xAC
06724:  CLRF   xAD
06726:  MOVLB  0
06728:  CALL   42F6
....................  			delay_ms(1000);  
0672C:  MOVLW  04
0672E:  MOVLB  1
06730:  MOVWF  x9A
06732:  MOVLW  FA
06734:  MOVLB  2
06736:  MOVWF  x17
06738:  MOVLB  0
0673A:  CALL   1D50
0673E:  MOVLB  1
06740:  DECFSZ x9A,F
06742:  BRA    6732
....................             go_x_y(coordenada_x_armazenado + 30,coordenada_y_armazenado,5000,5000,2000,2000,200,200,true,true,false,false); 
06744:  MOVLW  1E
06746:  ADDWF  2A,W
06748:  MOVWF  x9A
0674A:  MOVLW  00
0674C:  ADDWFC 2B,W
0674E:  MOVWF  x9B
06750:  MOVWF  x9D
06752:  MOVFF  19A,19C
06756:  MOVFF  2D,19F
0675A:  MOVFF  2C,19E
0675E:  MOVLW  13
06760:  MOVWF  xA1
06762:  MOVLW  88
06764:  MOVWF  xA0
06766:  MOVLW  13
06768:  MOVWF  xA3
0676A:  MOVLW  88
0676C:  MOVWF  xA2
0676E:  MOVLW  07
06770:  MOVWF  xA5
06772:  MOVLW  D0
06774:  MOVWF  xA4
06776:  MOVLW  07
06778:  MOVWF  xA7
0677A:  MOVLW  D0
0677C:  MOVWF  xA6
0677E:  MOVLW  C8
06780:  MOVWF  xA8
06782:  MOVWF  xA9
06784:  MOVLW  01
06786:  MOVWF  xAA
06788:  MOVWF  xAB
0678A:  CLRF   xAC
0678C:  CLRF   xAD
0678E:  MOVLB  0
06790:  CALL   42F6
.................... 			go_z(z_soldar_home,5000); 
06794:  MOVFF  149,19C
06798:  MOVFF  148,19B
0679C:  MOVLW  13
0679E:  MOVLB  1
067A0:  MOVWF  x9E
067A2:  MOVLW  88
067A4:  MOVWF  x9D
067A6:  MOVLB  0
067A8:  CALL   55F6
.................... 			break; 
067AC:  BRA    6B1A
....................  
.................... 	case 12: checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
067AE:  MOVFF  2B,19B
067B2:  MOVFF  2A,19A
067B6:  MOVFF  2D,19D
067BA:  MOVFF  2C,19C
067BE:  MOVFF  2F,19F
067C2:  MOVFF  2E,19E
067C6:  CALL   550A
.................... 			solda_mola(2); 
067CA:  MOVLW  02
067CC:  MOVLB  1
067CE:  MOVWF  x9A
067D0:  MOVLB  0
067D2:  CALL   580A
....................     		break; 
067D6:  BRA    6B1A
....................  
.................... 	case 13:checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
067D8:  MOVFF  2B,19B
067DC:  MOVFF  2A,19A
067E0:  MOVFF  2D,19D
067E4:  MOVFF  2C,19C
067E8:  MOVFF  2F,19F
067EC:  MOVFF  2E,19E
067F0:  CALL   550A
.................... 		   	go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,12000,12000,2000,2000,200,200,true,true,false,false);	  
067F4:  MOVFF  2B,19D
067F8:  MOVFF  2A,19C
067FC:  MOVFF  2D,19F
06800:  MOVFF  2C,19E
06804:  MOVLW  2E
06806:  MOVLB  1
06808:  MOVWF  xA1
0680A:  MOVLW  E0
0680C:  MOVWF  xA0
0680E:  MOVLW  2E
06810:  MOVWF  xA3
06812:  MOVLW  E0
06814:  MOVWF  xA2
06816:  MOVLW  07
06818:  MOVWF  xA5
0681A:  MOVLW  D0
0681C:  MOVWF  xA4
0681E:  MOVLW  07
06820:  MOVWF  xA7
06822:  MOVLW  D0
06824:  MOVWF  xA6
06826:  MOVLW  C8
06828:  MOVWF  xA8
0682A:  MOVWF  xA9
0682C:  MOVLW  01
0682E:  MOVWF  xAA
06830:  MOVWF  xAB
06832:  CLRF   xAC
06834:  CLRF   xAD
06836:  MOVLB  0
06838:  CALL   42F6
.................... 			aciona_alimentador_solda(200,2); 
0683C:  MOVLB  1
0683E:  CLRF   x9C
06840:  MOVLW  C8
06842:  MOVWF  x9B
06844:  MOVLW  02
06846:  MOVWF  x9D
06848:  MOVLB  0
0684A:  CALL   5680
.................... 			go_z(coordenada_z_armazenado,velocity_z); 
0684E:  MOVFF  2F,19C
06852:  MOVFF  2E,19B
06856:  MOVLW  07
06858:  MOVLB  1
0685A:  MOVWF  x9E
0685C:  MOVLW  D0
0685E:  MOVWF  x9D
06860:  MOVLB  0
06862:  CALL   55F6
.................... 			delay_ms(2000);   
06866:  MOVLW  08
06868:  MOVLB  1
0686A:  MOVWF  x9A
0686C:  MOVLW  FA
0686E:  MOVLB  2
06870:  MOVWF  x17
06872:  MOVLB  0
06874:  CALL   1D50
06878:  MOVLB  1
0687A:  DECFSZ x9A,F
0687C:  BRA    686C
.................... 		 	go_x_y(coordenada_x_armazenado + 30,coordenada_y_armazenado,5000,5000,2000,2000,200,200,false,false,false,false); 
0687E:  MOVLW  1E
06880:  ADDWF  2A,W
06882:  MOVWF  x9A
06884:  MOVLW  00
06886:  ADDWFC 2B,W
06888:  MOVWF  x9B
0688A:  MOVWF  x9D
0688C:  MOVFF  19A,19C
06890:  MOVFF  2D,19F
06894:  MOVFF  2C,19E
06898:  MOVLW  13
0689A:  MOVWF  xA1
0689C:  MOVLW  88
0689E:  MOVWF  xA0
068A0:  MOVLW  13
068A2:  MOVWF  xA3
068A4:  MOVLW  88
068A6:  MOVWF  xA2
068A8:  MOVLW  07
068AA:  MOVWF  xA5
068AC:  MOVLW  D0
068AE:  MOVWF  xA4
068B0:  MOVLW  07
068B2:  MOVWF  xA7
068B4:  MOVLW  D0
068B6:  MOVWF  xA6
068B8:  MOVLW  C8
068BA:  MOVWF  xA8
068BC:  MOVWF  xA9
068BE:  CLRF   xAA
068C0:  CLRF   xAB
068C2:  CLRF   xAC
068C4:  CLRF   xAD
068C6:  MOVLB  0
068C8:  CALL   42F6
.................... 		 	go_z(z_soldar_home,velocity_z);	 
068CC:  MOVFF  149,19C
068D0:  MOVFF  148,19B
068D4:  MOVLW  07
068D6:  MOVLB  1
068D8:  MOVWF  x9E
068DA:  MOVLW  D0
068DC:  MOVWF  x9D
068DE:  MOVLB  0
068E0:  CALL   55F6
.................... 			//go_x_y(coordenada_x_armazenado,coordenada_y_armazenado ,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
.................... 			posiciona_cursor(4,3); 
068E4:  MOVLW  04
068E6:  MOVLB  1
068E8:  MOVWF  xA5
068EA:  MOVLW  03
068EC:  MOVWF  xA6
068EE:  MOVLB  0
068F0:  CALL   1F92
.................... 			printf(lcd_putc,"%4LU",contador_step_z); 
068F4:  MOVLW  01
068F6:  MOVWF  FE9
068F8:  MOVFF  17F,19C
068FC:  MOVFF  17E,19B
06900:  CALL   5744
.................... 			break; 
06904:  BRA    6B1A
....................  
.................... 	case 14: checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
06906:  MOVFF  2B,19B
0690A:  MOVFF  2A,19A
0690E:  MOVFF  2D,19D
06912:  MOVFF  2C,19C
06916:  MOVFF  2F,19F
0691A:  MOVFF  2E,19E
0691E:  CALL   550A
.................... 			 solda_mola_2(2); 
06922:  MOVLW  02
06924:  MOVLB  1
06926:  MOVWF  x9A
06928:  MOVLB  0
0692A:  CALL   59AE
....................  
.................... 			break; 
0692E:  BRA    6B1A
....................  
.................... 	case 15:checa_limites(coordenada_x_armazenado,coordenada_y_armazenado,coordenada_z_armazenado); 
06930:  MOVFF  2B,19B
06934:  MOVFF  2A,19A
06938:  MOVFF  2D,19D
0693C:  MOVFF  2C,19C
06940:  MOVFF  2F,19F
06944:  MOVFF  2E,19E
06948:  CALL   550A
.................... 			go_z(z_soldar_home,velocity_z); 
0694C:  MOVFF  149,19C
06950:  MOVFF  148,19B
06954:  MOVLW  07
06956:  MOVLB  1
06958:  MOVWF  x9E
0695A:  MOVLW  D0
0695C:  MOVWF  x9D
0695E:  MOVLB  0
06960:  CALL   55F6
....................           	go_x_y(coordenada_x_armazenado - 30,coordenada_y_armazenado,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false);	  
06964:  MOVLW  1E
06966:  SUBWF  2A,W
06968:  MOVLB  1
0696A:  MOVWF  x9A
0696C:  MOVLW  00
0696E:  SUBWFB 2B,W
06970:  MOVWF  x9B
06972:  MOVWF  x9D
06974:  MOVFF  19A,19C
06978:  MOVFF  2D,19F
0697C:  MOVFF  2C,19E
06980:  MOVLW  01
06982:  MOVWF  xA1
06984:  MOVLW  2C
06986:  MOVWF  xA0
06988:  MOVLW  01
0698A:  MOVWF  xA3
0698C:  MOVLW  2C
0698E:  MOVWF  xA2
06990:  MOVLW  07
06992:  MOVWF  xA5
06994:  MOVLW  D0
06996:  MOVWF  xA4
06998:  MOVLW  07
0699A:  MOVWF  xA7
0699C:  MOVLW  D0
0699E:  MOVWF  xA6
069A0:  MOVLW  C8
069A2:  MOVWF  xA8
069A4:  MOVWF  xA9
069A6:  MOVLW  01
069A8:  MOVWF  xAA
069AA:  MOVWF  xAB
069AC:  CLRF   xAC
069AE:  CLRF   xAD
069B0:  MOVLB  0
069B2:  CALL   42F6
.................... 		    go_z(coordenada_z_armazenado,velocity_z); 
069B6:  MOVFF  2F,19C
069BA:  MOVFF  2E,19B
069BE:  MOVLW  07
069C0:  MOVLB  1
069C2:  MOVWF  x9E
069C4:  MOVLW  D0
069C6:  MOVWF  x9D
069C8:  MOVLB  0
069CA:  CALL   55F6
....................             aciona_alimentador_solda(200,2); 
069CE:  MOVLB  1
069D0:  CLRF   x9C
069D2:  MOVLW  C8
069D4:  MOVWF  x9B
069D6:  MOVLW  02
069D8:  MOVWF  x9D
069DA:  MOVLB  0
069DC:  CALL   5680
.................... 			go_x_y(coordenada_x_armazenado,coordenada_y_armazenado,12000,12000,2000,2000,200,200,true,true,false,false); 
069E0:  MOVFF  2B,19D
069E4:  MOVFF  2A,19C
069E8:  MOVFF  2D,19F
069EC:  MOVFF  2C,19E
069F0:  MOVLW  2E
069F2:  MOVLB  1
069F4:  MOVWF  xA1
069F6:  MOVLW  E0
069F8:  MOVWF  xA0
069FA:  MOVLW  2E
069FC:  MOVWF  xA3
069FE:  MOVLW  E0
06A00:  MOVWF  xA2
06A02:  MOVLW  07
06A04:  MOVWF  xA5
06A06:  MOVLW  D0
06A08:  MOVWF  xA4
06A0A:  MOVLW  07
06A0C:  MOVWF  xA7
06A0E:  MOVLW  D0
06A10:  MOVWF  xA6
06A12:  MOVLW  C8
06A14:  MOVWF  xA8
06A16:  MOVWF  xA9
06A18:  MOVLW  01
06A1A:  MOVWF  xAA
06A1C:  MOVWF  xAB
06A1E:  CLRF   xAC
06A20:  CLRF   xAD
06A22:  MOVLB  0
06A24:  CALL   42F6
.................... 			delay_ms(2000);   
06A28:  MOVLW  08
06A2A:  MOVLB  1
06A2C:  MOVWF  x9A
06A2E:  MOVLW  FA
06A30:  MOVLB  2
06A32:  MOVWF  x17
06A34:  MOVLB  0
06A36:  CALL   1D50
06A3A:  MOVLB  1
06A3C:  DECFSZ x9A,F
06A3E:  BRA    6A2E
.................... 		 	go_x_y(coordenada_x_armazenado,coordenada_y_armazenado - 5,5000,5000,2000,2000,200,200,false,false,false,false); 
06A40:  MOVLW  05
06A42:  SUBWF  2C,W
06A44:  MOVWF  x9A
06A46:  MOVLW  00
06A48:  SUBWFB 2D,W
06A4A:  MOVWF  x9B
06A4C:  MOVFF  2B,19D
06A50:  MOVFF  2A,19C
06A54:  MOVWF  x9F
06A56:  MOVFF  19A,19E
06A5A:  MOVLW  13
06A5C:  MOVWF  xA1
06A5E:  MOVLW  88
06A60:  MOVWF  xA0
06A62:  MOVLW  13
06A64:  MOVWF  xA3
06A66:  MOVLW  88
06A68:  MOVWF  xA2
06A6A:  MOVLW  07
06A6C:  MOVWF  xA5
06A6E:  MOVLW  D0
06A70:  MOVWF  xA4
06A72:  MOVLW  07
06A74:  MOVWF  xA7
06A76:  MOVLW  D0
06A78:  MOVWF  xA6
06A7A:  MOVLW  C8
06A7C:  MOVWF  xA8
06A7E:  MOVWF  xA9
06A80:  CLRF   xAA
06A82:  CLRF   xAB
06A84:  CLRF   xAC
06A86:  CLRF   xAD
06A88:  MOVLB  0
06A8A:  CALL   42F6
.................... 		 	go_x_y(coordenada_x_armazenado + 25,coordenada_y_armazenado,5000,5000,2000,2000,200,200,false,false,false,false); 
06A8E:  MOVLW  19
06A90:  ADDWF  2A,W
06A92:  MOVLB  1
06A94:  MOVWF  x9A
06A96:  MOVLW  00
06A98:  ADDWFC 2B,W
06A9A:  MOVWF  x9B
06A9C:  MOVWF  x9D
06A9E:  MOVFF  19A,19C
06AA2:  MOVFF  2D,19F
06AA6:  MOVFF  2C,19E
06AAA:  MOVLW  13
06AAC:  MOVWF  xA1
06AAE:  MOVLW  88
06AB0:  MOVWF  xA0
06AB2:  MOVLW  13
06AB4:  MOVWF  xA3
06AB6:  MOVLW  88
06AB8:  MOVWF  xA2
06ABA:  MOVLW  07
06ABC:  MOVWF  xA5
06ABE:  MOVLW  D0
06AC0:  MOVWF  xA4
06AC2:  MOVLW  07
06AC4:  MOVWF  xA7
06AC6:  MOVLW  D0
06AC8:  MOVWF  xA6
06ACA:  MOVLW  C8
06ACC:  MOVWF  xA8
06ACE:  MOVWF  xA9
06AD0:  CLRF   xAA
06AD2:  CLRF   xAB
06AD4:  CLRF   xAC
06AD6:  CLRF   xAD
06AD8:  MOVLB  0
06ADA:  CALL   42F6
.................... 			go_z(50,velocity_z); 
06ADE:  MOVLB  1
06AE0:  CLRF   x9C
06AE2:  MOVLW  32
06AE4:  MOVWF  x9B
06AE6:  MOVLW  07
06AE8:  MOVWF  x9E
06AEA:  MOVLW  D0
06AEC:  MOVWF  x9D
06AEE:  MOVLB  0
06AF0:  CALL   55F6
....................             z_home();  
06AF4:  CALL   2EE0
.................... 			posiciona_cursor(4,3); 
06AF8:  MOVLW  04
06AFA:  MOVLB  1
06AFC:  MOVWF  xA5
06AFE:  MOVLW  03
06B00:  MOVWF  xA6
06B02:  MOVLB  0
06B04:  CALL   1F92
.................... 			printf(lcd_putc,"%4LU",contador_step_z); 
06B08:  MOVLW  01
06B0A:  MOVWF  FE9
06B0C:  MOVFF  17F,19C
06B10:  MOVFF  17E,19B
06B14:  CALL   5744
....................  
.................... 			break; 
06B18:  BRA    6B1A
....................  
....................  
....................          default: 
....................  
.................... 			break; 
....................  
....................     }   
06B1A:  INCF   54,F
06B1C:  GOTO   5B54
....................  
....................  
....................  } 
06B20:  GOTO   6B6A (RETURN)
....................  
....................  
.................... } 
....................  
....................  
.................... int  soldar(int n_maquina) 
06B24:  MOVLB  1
06B26:  CLRF   x97
06B28:  CLRF   x96
.................... { 
.................... 	long int  n_pontos = 0; 
....................     int i; 
....................  
.................... 	 
....................     posiciona_cursor(1,1); 
06B2A:  MOVLW  01
06B2C:  MOVWF  xA5
06B2E:  MOVWF  xA6
06B30:  MOVLB  0
06B32:  CALL   1F92
....................     printf(lcd_putc,"P:                  \n\r"); 
06B36:  MOVLW  34
06B38:  MOVWF  FF6
06B3A:  MOVLW  11
06B3C:  MOVWF  FF7
06B3E:  CALL   25DA
....................     printf(lcd_putc,"                    \n\r"); 
06B42:  MOVLW  4C
06B44:  MOVWF  FF6
06B46:  MOVLW  11
06B48:  MOVWF  FF7
06B4A:  CALL   25DA
.................... 	printf(lcd_putc,"     SOLDANDO       \n\r"); 
06B4E:  MOVLW  64
06B50:  MOVWF  FF6
06B52:  MOVLW  11
06B54:  MOVWF  FF7
06B56:  CALL   25DA
.................... 	printf(lcd_putc,"     ESTAGIO1       "); 
06B5A:  MOVLW  7C
06B5C:  MOVWF  FF6
06B5E:  MOVLW  11
06B60:  MOVWF  FF7
06B62:  CALL   25DA
....................  
....................     
....................  
.................... 	solda_placa_default(); 
06B66:  GOTO   5B52
06B6A:  CLRF   16
06B6C:  BTFSC  FF2.7
06B6E:  BSF    16.7
06B70:  BCF    FF2.7
....................  
....................    desaciona_saida(FERRO_SOLDA1); 
06B72:  MOVLB  2
06B74:  CLRF   x1B
06B76:  MOVLW  03
06B78:  MOVWF  x1A
06B7A:  MOVLB  0
06B7C:  CALL   1B96
06B80:  BTFSC  16.7
06B82:  BSF    FF2.7
06B84:  CLRF   16
06B86:  BTFSC  FF2.7
06B88:  BSF    16.7
06B8A:  BCF    FF2.7
....................    desaciona_saida(FERRO_SOLDA2); 
06B8C:  MOVLB  2
06B8E:  CLRF   x1B
06B90:  MOVLW  02
06B92:  MOVWF  x1A
06B94:  MOVLB  0
06B96:  CALL   1B96
06B9A:  BTFSC  16.7
06B9C:  BSF    FF2.7
06B9E:  RETURN 0
.................... } 
....................  
....................  
.................... int posicao_home_2(int n_maquina) 
06BA0:  MOVLB  1
06BA2:  CLRF   x96
.................... { 
....................     int erro = 0; 
.................... 	posiciona_cursor(1,1); 
06BA4:  MOVLW  01
06BA6:  MOVWF  xA5
06BA8:  MOVWF  xA6
06BAA:  MOVLB  0
06BAC:  CALL   1F92
.................... 	printf(lcd_putc,"                    \n\r"); 
06BB0:  MOVLW  92
06BB2:  MOVWF  FF6
06BB4:  MOVLW  11
06BB6:  MOVWF  FF7
06BB8:  CALL   25DA
....................  	printf(lcd_putc,"                    \n\r"); 
06BBC:  MOVLW  AA
06BBE:  MOVWF  FF6
06BC0:  MOVLW  11
06BC2:  MOVWF  FF7
06BC4:  CALL   25DA
....................  	printf(lcd_putc,"MOVIMENTANDO POSICAO\n\r"); 
06BC8:  MOVLW  C2
06BCA:  MOVWF  FF6
06BCC:  MOVLW  11
06BCE:  MOVWF  FF7
06BD0:  CALL   25DA
....................  	printf(lcd_putc,"       HOME2       "); 
06BD4:  MOVLW  DA
06BD6:  MOVWF  FF6
06BD8:  MOVLW  11
06BDA:  MOVWF  FF7
06BDC:  CALL   25DA
....................  
....................  	if(n_maquina == MAQUINA1) 
06BE0:  MOVLB  1
06BE2:  DECFSZ x95,W
06BE4:  BRA    6C82
....................     { 
....................  
.................... 		go_x_y(4290,5550,velocity_x,velocity_y,4000,2000,200,200,true,true,false,false); 
06BE6:  MOVLW  10
06BE8:  MOVWF  x9D
06BEA:  MOVLW  C2
06BEC:  MOVWF  x9C
06BEE:  MOVLW  15
06BF0:  MOVWF  x9F
06BF2:  MOVLW  AE
06BF4:  MOVWF  x9E
06BF6:  MOVLW  01
06BF8:  MOVWF  xA1
06BFA:  MOVLW  2C
06BFC:  MOVWF  xA0
06BFE:  MOVLW  01
06C00:  MOVWF  xA3
06C02:  MOVLW  2C
06C04:  MOVWF  xA2
06C06:  MOVLW  0F
06C08:  MOVWF  xA5
06C0A:  MOVLW  A0
06C0C:  MOVWF  xA4
06C0E:  MOVLW  07
06C10:  MOVWF  xA7
06C12:  MOVLW  D0
06C14:  MOVWF  xA6
06C16:  MOVLW  C8
06C18:  MOVWF  xA8
06C1A:  MOVWF  xA9
06C1C:  MOVLW  01
06C1E:  MOVWF  xAA
06C20:  MOVWF  xAB
06C22:  CLRF   xAC
06C24:  CLRF   xAD
06C26:  MOVLB  0
06C28:  CALL   42F6
....................         delay_ms(100); 
06C2C:  MOVLW  64
06C2E:  MOVLB  2
06C30:  MOVWF  x17
06C32:  MOVLB  0
06C34:  CALL   1D50
.................... 		if(le_Input(S_Y_ATRAS)    != true)  return erro = 4; 
06C38:  MOVLW  08
06C3A:  MOVLB  1
06C3C:  MOVWF  x9C
06C3E:  MOVLB  0
06C40:  CALL   2C54
06C44:  DECFSZ 01,W
06C46:  BRA    6C4A
06C48:  BRA    6C56
06C4A:  MOVLW  04
06C4C:  MOVLB  1
06C4E:  MOVWF  x96
06C50:  MOVWF  01
06C52:  BRA    6D24
06C54:  MOVLB  0
....................         if(le_Input(S_X_ESQUERDA) != true)  return erro = 5; 
06C56:  MOVLW  06
06C58:  MOVLB  1
06C5A:  MOVWF  x9C
06C5C:  MOVLB  0
06C5E:  CALL   2C54
06C62:  DECFSZ 01,W
06C64:  BRA    6C68
06C66:  BRA    6C74
06C68:  MOVLW  05
06C6A:  MOVLB  1
06C6C:  MOVWF  x96
06C6E:  MOVWF  01
06C70:  BRA    6D24
06C72:  MOVLB  0
....................         envia_posicao_para_maquina2(POSICAO_HOME2); 
06C74:  MOVLW  01
06C76:  MOVLB  1
06C78:  MOVWF  x9A
06C7A:  MOVLB  0
06C7C:  CALL   39AC
06C80:  MOVLB  1
.................... 	} 
....................  
.................... 	 
....................     if(n_maquina == MAQUINA2)	 
06C82:  MOVF   x95,W
06C84:  SUBLW  02
06C86:  BNZ   6D20
....................     { 
....................  
.................... 		go_x_y(0,4925,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
06C88:  CLRF   x9D
06C8A:  CLRF   x9C
06C8C:  MOVLW  13
06C8E:  MOVWF  x9F
06C90:  MOVLW  3D
06C92:  MOVWF  x9E
06C94:  MOVLW  01
06C96:  MOVWF  xA1
06C98:  MOVLW  2C
06C9A:  MOVWF  xA0
06C9C:  MOVLW  01
06C9E:  MOVWF  xA3
06CA0:  MOVLW  2C
06CA2:  MOVWF  xA2
06CA4:  MOVLW  07
06CA6:  MOVWF  xA5
06CA8:  MOVLW  D0
06CAA:  MOVWF  xA4
06CAC:  MOVLW  07
06CAE:  MOVWF  xA7
06CB0:  MOVLW  D0
06CB2:  MOVWF  xA6
06CB4:  MOVLW  C8
06CB6:  MOVWF  xA8
06CB8:  MOVWF  xA9
06CBA:  MOVLW  01
06CBC:  MOVWF  xAA
06CBE:  MOVWF  xAB
06CC0:  CLRF   xAC
06CC2:  CLRF   xAD
06CC4:  MOVLB  0
06CC6:  CALL   42F6
....................         delay_ms(150); 
06CCA:  MOVLW  96
06CCC:  MOVLB  2
06CCE:  MOVWF  x17
06CD0:  MOVLB  0
06CD2:  CALL   1D50
.................... 	    if(le_Input(S_Y_ATRAS)   != true)   return erro = 4; 
06CD6:  MOVLW  08
06CD8:  MOVLB  1
06CDA:  MOVWF  x9C
06CDC:  MOVLB  0
06CDE:  CALL   2C54
06CE2:  DECFSZ 01,W
06CE4:  BRA    6CE8
06CE6:  BRA    6CF4
06CE8:  MOVLW  04
06CEA:  MOVLB  1
06CEC:  MOVWF  x96
06CEE:  MOVWF  01
06CF0:  BRA    6D24
06CF2:  MOVLB  0
....................         if(le_Input(S_X_DIREITA) != true)   return erro = 5; 
06CF4:  MOVLW  05
06CF6:  MOVLB  1
06CF8:  MOVWF  x9C
06CFA:  MOVLB  0
06CFC:  CALL   2C54
06D00:  DECFSZ 01,W
06D02:  BRA    6D06
06D04:  BRA    6D12
06D06:  MOVLW  05
06D08:  MOVLB  1
06D0A:  MOVWF  x96
06D0C:  MOVWF  01
06D0E:  BRA    6D24
06D10:  MOVLB  0
.................... 		envia_posicao_para_maquina1(POSICAO_HOME2); 
06D12:  MOVLW  01
06D14:  MOVLB  1
06D16:  MOVWF  x9A
06D18:  MOVLB  0
06D1A:  CALL   50A4
06D1E:  MOVLB  1
....................  
.................... 	} 
....................  
....................     return erro; 
06D20:  MOVFF  196,01
06D24:  MOVLB  0
06D26:  RETURN 0
.................... } 
....................  
....................  
.................... int  posicao_dispensar_placa(int n_maquina) 
.................... { 
.................... 	 
.................... 	 posiciona_cursor(3,1); 
*
06F30:  MOVLW  03
06F32:  MOVLB  1
06F34:  MOVWF  xA5
06F36:  MOVLW  01
06F38:  MOVWF  xA6
06F3A:  MOVLB  0
06F3C:  CALL   1F92
....................  	 printf(lcd_putc,"MOVIMENTANDO POSICAO\n\r"); 
06F40:  MOVLW  EE
06F42:  MOVWF  FF6
06F44:  MOVLW  11
06F46:  MOVWF  FF7
06F48:  CALL   25DA
.................... 	 printf(lcd_putc,"DISPENSADOR PLACA   "); 
06F4C:  MOVLW  06
06F4E:  MOVWF  FF6
06F50:  MOVLW  12
06F52:  MOVWF  FF7
06F54:  CALL   25DA
....................  
.................... 	 if(n_maquina == MAQUINA1) 
06F58:  MOVLB  1
06F5A:  DECFSZ x95,W
06F5C:  BRA    704C
.................... 	 {  
.................... 	    envia_posicao_para_maquina2(POSICAO_DISPENSADOR); 
06F5E:  MOVLW  05
06F60:  MOVWF  x9A
06F62:  MOVLB  0
06F64:  CALL   39AC
....................         go_x_y(0,5530,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
06F68:  MOVLB  1
06F6A:  CLRF   x9D
06F6C:  CLRF   x9C
06F6E:  MOVLW  15
06F70:  MOVWF  x9F
06F72:  MOVLW  9A
06F74:  MOVWF  x9E
06F76:  MOVLW  01
06F78:  MOVWF  xA1
06F7A:  MOVLW  2C
06F7C:  MOVWF  xA0
06F7E:  MOVLW  01
06F80:  MOVWF  xA3
06F82:  MOVLW  2C
06F84:  MOVWF  xA2
06F86:  MOVLW  07
06F88:  MOVWF  xA5
06F8A:  MOVLW  D0
06F8C:  MOVWF  xA4
06F8E:  MOVLW  07
06F90:  MOVWF  xA7
06F92:  MOVLW  D0
06F94:  MOVWF  xA6
06F96:  MOVLW  C8
06F98:  MOVWF  xA8
06F9A:  MOVWF  xA9
06F9C:  MOVLW  01
06F9E:  MOVWF  xAA
06FA0:  MOVWF  xAB
06FA2:  CLRF   xAC
06FA4:  CLRF   xAD
06FA6:  MOVLB  0
06FA8:  CALL   42F6
....................         delay_ms(200); 
06FAC:  MOVLW  C8
06FAE:  MOVLB  2
06FB0:  MOVWF  x17
06FB2:  MOVLB  0
06FB4:  CALL   1D50
....................         if(le_Input(S_X_DIREITA) != true)  return erro = 6; 
06FB8:  MOVLW  05
06FBA:  MOVLB  1
06FBC:  MOVWF  x9C
06FBE:  MOVLB  0
06FC0:  CALL   2C54
06FC4:  DECFSZ 01,W
06FC6:  BRA    6FCA
06FC8:  BRA    6FD6
06FCA:  MOVLW  06
06FCC:  MOVLB  1
06FCE:  MOVWF  x84
06FD0:  MOVWF  01
06FD2:  BRA    7114
06FD4:  MOVLB  0
.................... 	    go_x_y(0,6176,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
06FD6:  MOVLB  1
06FD8:  CLRF   x9D
06FDA:  CLRF   x9C
06FDC:  MOVLW  18
06FDE:  MOVWF  x9F
06FE0:  MOVLW  20
06FE2:  MOVWF  x9E
06FE4:  MOVLW  01
06FE6:  MOVWF  xA1
06FE8:  MOVLW  2C
06FEA:  MOVWF  xA0
06FEC:  MOVLW  01
06FEE:  MOVWF  xA3
06FF0:  MOVLW  2C
06FF2:  MOVWF  xA2
06FF4:  MOVLW  07
06FF6:  MOVWF  xA5
06FF8:  MOVLW  D0
06FFA:  MOVWF  xA4
06FFC:  MOVLW  07
06FFE:  MOVWF  xA7
07000:  MOVLW  D0
07002:  MOVWF  xA6
07004:  MOVLW  C8
07006:  MOVWF  xA8
07008:  MOVWF  xA9
0700A:  MOVLW  01
0700C:  MOVWF  xAA
0700E:  MOVWF  xAB
07010:  CLRF   xAC
07012:  CLRF   xAD
07014:  MOVLB  0
07016:  CALL   42F6
....................  
.................... 	    direita(); 
0701A:  CALL   32C4
.................... 		delay_ms(50); 
0701E:  MOVLW  32
07020:  MOVLB  2
07022:  MOVWF  x17
07024:  MOVLB  0
07026:  CALL   1D50
....................         for(i=0;i<=20;i++) //ajuste fino da posição de dispensa da placa 
0702A:  MOVLB  1
0702C:  CLRF   x83
0702E:  MOVF   x83,W
07030:  SUBLW  14
07032:  BNC   704C
.................... 		{ 
.................... 							 
.................... 		    one_step_x(); 
07034:  MOVLB  0
07036:  CALL   32D2
.................... 		    delay_us(2000); 
0703A:  MOVLW  02
0703C:  MOVLB  2
0703E:  MOVWF  x17
07040:  MOVLB  0
07042:  CALL   1D50
07046:  MOVLB  1
07048:  INCF   x83,F
0704A:  BRA    702E
....................  
.................... 		} 
....................  
.................... 	     
....................      }    
....................  
.................... 	 if(n_maquina == MAQUINA2) 
0704C:  MOVF   x95,W
0704E:  SUBLW  02
07050:  BNZ   70FA
.................... 	 { 
.................... 		envia_posicao_para_maquina1(POSICAO_DISPENSADOR); 
07052:  MOVLW  05
07054:  MOVWF  x9A
07056:  MOVLB  0
07058:  CALL   50A4
.................... 	 	go_x_y(4177,4925,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
0705C:  MOVLW  10
0705E:  MOVLB  1
07060:  MOVWF  x9D
07062:  MOVLW  51
07064:  MOVWF  x9C
07066:  MOVLW  13
07068:  MOVWF  x9F
0706A:  MOVLW  3D
0706C:  MOVWF  x9E
0706E:  MOVLW  01
07070:  MOVWF  xA1
07072:  MOVLW  2C
07074:  MOVWF  xA0
07076:  MOVLW  01
07078:  MOVWF  xA3
0707A:  MOVLW  2C
0707C:  MOVWF  xA2
0707E:  MOVLW  07
07080:  MOVWF  xA5
07082:  MOVLW  D0
07084:  MOVWF  xA4
07086:  MOVLW  07
07088:  MOVWF  xA7
0708A:  MOVLW  D0
0708C:  MOVWF  xA6
0708E:  MOVLW  C8
07090:  MOVWF  xA8
07092:  MOVWF  xA9
07094:  MOVLW  01
07096:  MOVWF  xAA
07098:  MOVWF  xAB
0709A:  CLRF   xAC
0709C:  CLRF   xAD
0709E:  MOVLB  0
070A0:  CALL   42F6
....................         delay_ms(100); 
070A4:  MOVLW  64
070A6:  MOVLB  2
070A8:  MOVWF  x17
070AA:  MOVLB  0
070AC:  CALL   1D50
....................         //if(le_Input(S_X_ESQUERDA) != true)  return erro = 6; 
.................... 	 	go_x_y(4177,5500,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
070B0:  MOVLW  10
070B2:  MOVLB  1
070B4:  MOVWF  x9D
070B6:  MOVLW  51
070B8:  MOVWF  x9C
070BA:  MOVLW  15
070BC:  MOVWF  x9F
070BE:  MOVLW  7C
070C0:  MOVWF  x9E
070C2:  MOVLW  01
070C4:  MOVWF  xA1
070C6:  MOVLW  2C
070C8:  MOVWF  xA0
070CA:  MOVLW  01
070CC:  MOVWF  xA3
070CE:  MOVLW  2C
070D0:  MOVWF  xA2
070D2:  MOVLW  07
070D4:  MOVWF  xA5
070D6:  MOVLW  D0
070D8:  MOVWF  xA4
070DA:  MOVLW  07
070DC:  MOVWF  xA7
070DE:  MOVLW  D0
070E0:  MOVWF  xA6
070E2:  MOVLW  C8
070E4:  MOVWF  xA8
070E6:  MOVWF  xA9
070E8:  MOVLW  01
070EA:  MOVWF  xAA
070EC:  MOVWF  xAB
070EE:  CLRF   xAC
070F0:  CLRF   xAD
070F2:  MOVLB  0
070F4:  CALL   42F6
070F8:  MOVLB  1
....................  
....................  
.................... 	 } 
.................... 	delay_ms(500); 
070FA:  MOVLW  02
070FC:  MOVWF  x96
070FE:  MOVLW  FA
07100:  MOVLB  2
07102:  MOVWF  x17
07104:  MOVLB  0
07106:  CALL   1D50
0710A:  MOVLB  1
0710C:  DECFSZ x96,F
0710E:  BRA    70FE
....................    return erro; 
07110:  MOVFF  184,01
07114:  MOVLB  0
07116:  RETURN 0
....................  
.................... }     
....................  
.................... int posicao_home_3(int n_maquina) 
*
07464:  MOVLB  1
07466:  CLRF   x96
.................... { 
....................     int erro = 0; 
....................  
....................      if(n_maquina == MAQUINA1) 
07468:  DECFSZ x95,W
0746A:  BRA    7560
.................... 	 {  
....................  
....................         esquerda(); 
0746C:  MOVLB  0
0746E:  CALL   3306
.................... 		delay_ms(50); 
07472:  MOVLW  32
07474:  MOVLB  2
07476:  MOVWF  x17
07478:  MOVLB  0
0747A:  CALL   1D50
....................         for(i=0;i<=20;i++) //ajuste fino da posição de dispensa da placa 
0747E:  MOVLB  1
07480:  CLRF   x83
07482:  MOVF   x83,W
07484:  SUBLW  14
07486:  BNC   74A0
.................... 		{ 
.................... 							 
.................... 		    one_step_x(); 
07488:  MOVLB  0
0748A:  CALL   32D2
.................... 		    delay_us(2000); 
0748E:  MOVLW  02
07490:  MOVLB  2
07492:  MOVWF  x17
07494:  MOVLB  0
07496:  CALL   1D50
0749A:  MOVLB  1
0749C:  INCF   x83,F
0749E:  BRA    7482
....................  
.................... 		} 
.................... 	   go_x_y(0,5500,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
074A0:  CLRF   x9D
074A2:  CLRF   x9C
074A4:  MOVLW  15
074A6:  MOVWF  x9F
074A8:  MOVLW  7C
074AA:  MOVWF  x9E
074AC:  MOVLW  01
074AE:  MOVWF  xA1
074B0:  MOVLW  2C
074B2:  MOVWF  xA0
074B4:  MOVLW  01
074B6:  MOVWF  xA3
074B8:  MOVLW  2C
074BA:  MOVWF  xA2
074BC:  MOVLW  07
074BE:  MOVWF  xA5
074C0:  MOVLW  D0
074C2:  MOVWF  xA4
074C4:  MOVLW  07
074C6:  MOVWF  xA7
074C8:  MOVLW  D0
074CA:  MOVWF  xA6
074CC:  MOVLW  C8
074CE:  MOVWF  xA8
074D0:  MOVWF  xA9
074D2:  MOVLW  01
074D4:  MOVWF  xAA
074D6:  MOVWF  xAB
074D8:  CLRF   xAC
074DA:  CLRF   xAD
074DC:  MOVLB  0
074DE:  CALL   42F6
....................        delay_ms(100); 
074E2:  MOVLW  64
074E4:  MOVLB  2
074E6:  MOVWF  x17
074E8:  MOVLB  0
074EA:  CALL   1D50
.................... 	   if(le_Input(S_Y_ATRAS) == true)     return erro = 7 ; 
074EE:  MOVLW  08
074F0:  MOVLB  1
074F2:  MOVWF  x9C
074F4:  MOVLB  0
074F6:  CALL   2C54
074FA:  DECFSZ 01,W
074FC:  BRA    750A
074FE:  MOVLW  07
07500:  MOVLB  1
07502:  MOVWF  x96
07504:  MOVWF  01
07506:  BRA    762E
07508:  MOVLB  0
....................        go_x_y(1000,5500,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
0750A:  MOVLW  03
0750C:  MOVLB  1
0750E:  MOVWF  x9D
07510:  MOVLW  E8
07512:  MOVWF  x9C
07514:  MOVLW  15
07516:  MOVWF  x9F
07518:  MOVLW  7C
0751A:  MOVWF  x9E
0751C:  MOVLW  01
0751E:  MOVWF  xA1
07520:  MOVLW  2C
07522:  MOVWF  xA0
07524:  MOVLW  01
07526:  MOVWF  xA3
07528:  MOVLW  2C
0752A:  MOVWF  xA2
0752C:  MOVLW  07
0752E:  MOVWF  xA5
07530:  MOVLW  D0
07532:  MOVWF  xA4
07534:  MOVLW  07
07536:  MOVWF  xA7
07538:  MOVLW  D0
0753A:  MOVWF  xA6
0753C:  MOVLW  C8
0753E:  MOVWF  xA8
07540:  MOVWF  xA9
07542:  MOVLW  01
07544:  MOVWF  xAA
07546:  MOVWF  xAB
07548:  CLRF   xAC
0754A:  CLRF   xAD
0754C:  MOVLB  0
0754E:  CALL   42F6
....................        envia_posicao_para_maquina2(POSICAO_HOME3); 
07552:  MOVLW  06
07554:  MOVLB  1
07556:  MOVWF  x9A
07558:  MOVLB  0
0755A:  CALL   39AC
0755E:  MOVLB  1
....................  
.................... 	 } 
....................  
....................      if(n_maquina == MAQUINA2) 
07560:  MOVF   x95,W
07562:  SUBLW  02
07564:  BNZ   762A
.................... 	 {  
.................... 	   go_x_y(4177,4880,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
07566:  MOVLW  10
07568:  MOVWF  x9D
0756A:  MOVLW  51
0756C:  MOVWF  x9C
0756E:  MOVLW  13
07570:  MOVWF  x9F
07572:  MOVLW  10
07574:  MOVWF  x9E
07576:  MOVLW  01
07578:  MOVWF  xA1
0757A:  MOVLW  2C
0757C:  MOVWF  xA0
0757E:  MOVLW  01
07580:  MOVWF  xA3
07582:  MOVLW  2C
07584:  MOVWF  xA2
07586:  MOVLW  07
07588:  MOVWF  xA5
0758A:  MOVLW  D0
0758C:  MOVWF  xA4
0758E:  MOVLW  07
07590:  MOVWF  xA7
07592:  MOVLW  D0
07594:  MOVWF  xA6
07596:  MOVLW  C8
07598:  MOVWF  xA8
0759A:  MOVWF  xA9
0759C:  MOVLW  01
0759E:  MOVWF  xAA
075A0:  MOVWF  xAB
075A2:  CLRF   xAC
075A4:  CLRF   xAD
075A6:  MOVLB  0
075A8:  CALL   42F6
....................        delay_ms(100); 
075AC:  MOVLW  64
075AE:  MOVLB  2
075B0:  MOVWF  x17
075B2:  MOVLB  0
075B4:  CALL   1D50
.................... 	   if(le_Input(S_Y_ATRAS) == true)     return erro = 7; 
075B8:  MOVLW  08
075BA:  MOVLB  1
075BC:  MOVWF  x9C
075BE:  MOVLB  0
075C0:  CALL   2C54
075C4:  DECFSZ 01,W
075C6:  BRA    75D4
075C8:  MOVLW  07
075CA:  MOVLB  1
075CC:  MOVWF  x96
075CE:  MOVWF  01
075D0:  BRA    762E
075D2:  MOVLB  0
....................        go_x_y(2865,4880,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
075D4:  MOVLW  0B
075D6:  MOVLB  1
075D8:  MOVWF  x9D
075DA:  MOVLW  31
075DC:  MOVWF  x9C
075DE:  MOVLW  13
075E0:  MOVWF  x9F
075E2:  MOVLW  10
075E4:  MOVWF  x9E
075E6:  MOVLW  01
075E8:  MOVWF  xA1
075EA:  MOVLW  2C
075EC:  MOVWF  xA0
075EE:  MOVLW  01
075F0:  MOVWF  xA3
075F2:  MOVLW  2C
075F4:  MOVWF  xA2
075F6:  MOVLW  07
075F8:  MOVWF  xA5
075FA:  MOVLW  D0
075FC:  MOVWF  xA4
075FE:  MOVLW  07
07600:  MOVWF  xA7
07602:  MOVLW  D0
07604:  MOVWF  xA6
07606:  MOVLW  C8
07608:  MOVWF  xA8
0760A:  MOVWF  xA9
0760C:  MOVLW  01
0760E:  MOVWF  xAA
07610:  MOVWF  xAB
07612:  CLRF   xAC
07614:  CLRF   xAD
07616:  MOVLB  0
07618:  CALL   42F6
....................        envia_posicao_para_maquina1(POSICAO_HOME3); 
0761C:  MOVLW  06
0761E:  MOVLB  1
07620:  MOVWF  x9A
07622:  MOVLB  0
07624:  CALL   50A4
07628:  MOVLB  1
....................  
.................... 	 } 
....................  
.................... 	 
....................  
....................      return erro; 
0762A:  MOVFF  196,01
0762E:  MOVLB  0
07630:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... int posicao_home_1(int n_maquina) 
07632:  MOVLB  1
07634:  CLRF   x96
.................... { 
....................     int erro=0; 
.................... 	posiciona_cursor(3,1); 
07636:  MOVLW  03
07638:  MOVWF  xA5
0763A:  MOVLW  01
0763C:  MOVWF  xA6
0763E:  MOVLB  0
07640:  CALL   1F92
....................  	printf(lcd_putc,"MOVIMENTANDO POSICAO\n\r"); 
07644:  MOVLW  1C
07646:  MOVWF  FF6
07648:  MOVLW  12
0764A:  MOVWF  FF7
0764C:  CALL   25DA
....................  	printf(lcd_putc,"       HOME1       "); 
07650:  MOVLW  34
07652:  MOVWF  FF6
07654:  MOVLW  12
07656:  MOVWF  FF7
07658:  CALL   25DA
....................  
.................... 	if(n_maquina == MAQUINA1) 
0765C:  MOVLB  1
0765E:  DECFSZ x95,W
07660:  BRA    76FC
....................     { 
.................... 	    go_x_y(4290,740,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
07662:  MOVLW  10
07664:  MOVWF  x9D
07666:  MOVLW  C2
07668:  MOVWF  x9C
0766A:  MOVLW  02
0766C:  MOVWF  x9F
0766E:  MOVLW  E4
07670:  MOVWF  x9E
07672:  MOVLW  01
07674:  MOVWF  xA1
07676:  MOVLW  2C
07678:  MOVWF  xA0
0767A:  MOVLW  01
0767C:  MOVWF  xA3
0767E:  MOVLW  2C
07680:  MOVWF  xA2
07682:  MOVLW  07
07684:  MOVWF  xA5
07686:  MOVLW  D0
07688:  MOVWF  xA4
0768A:  MOVLW  07
0768C:  MOVWF  xA7
0768E:  MOVLW  D0
07690:  MOVWF  xA6
07692:  MOVLW  C8
07694:  MOVWF  xA8
07696:  MOVWF  xA9
07698:  MOVLW  01
0769A:  MOVWF  xAA
0769C:  MOVWF  xAB
0769E:  CLRF   xAC
076A0:  CLRF   xAD
076A2:  MOVLB  0
076A4:  CALL   42F6
....................         delay_ms(100); 
076A8:  MOVLW  64
076AA:  MOVLB  2
076AC:  MOVWF  x17
076AE:  MOVLB  0
076B0:  CALL   1D50
....................        	if(le_Input(S_Y_FRENTE)   != true)    return erro = 8; 
076B4:  MOVLW  07
076B6:  MOVLB  1
076B8:  MOVWF  x9C
076BA:  MOVLB  0
076BC:  CALL   2C54
076C0:  DECFSZ 01,W
076C2:  BRA    76C6
076C4:  BRA    76D2
076C6:  MOVLW  08
076C8:  MOVLB  1
076CA:  MOVWF  x96
076CC:  MOVWF  01
076CE:  BRA    779E
076D0:  MOVLB  0
....................         if(le_Input(S_X_ESQUERDA) != true)    return erro = 9; 
076D2:  MOVLW  06
076D4:  MOVLB  1
076D6:  MOVWF  x9C
076D8:  MOVLB  0
076DA:  CALL   2C54
076DE:  DECFSZ 01,W
076E0:  BRA    76E4
076E2:  BRA    76F0
076E4:  MOVLW  09
076E6:  MOVLB  1
076E8:  MOVWF  x96
076EA:  MOVWF  01
076EC:  BRA    779E
076EE:  MOVLB  0
....................      	envia_posicao_para_maquina2(POSICAO_HOME1); 
076F0:  MOVLB  1
076F2:  CLRF   x9A
076F4:  MOVLB  0
076F6:  CALL   39AC
076FA:  MOVLB  1
....................  
.................... 	} 
....................  
....................     if(n_maquina == MAQUINA2) 
076FC:  MOVF   x95,W
076FE:  SUBLW  02
07700:  BNZ   779A
....................     { 
.................... 	    go_x_y(200,200,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
07702:  CLRF   x9D
07704:  MOVLW  C8
07706:  MOVWF  x9C
07708:  CLRF   x9F
0770A:  MOVWF  x9E
0770C:  MOVLW  01
0770E:  MOVWF  xA1
07710:  MOVLW  2C
07712:  MOVWF  xA0
07714:  MOVLW  01
07716:  MOVWF  xA3
07718:  MOVLW  2C
0771A:  MOVWF  xA2
0771C:  MOVLW  07
0771E:  MOVWF  xA5
07720:  MOVLW  D0
07722:  MOVWF  xA4
07724:  MOVLW  07
07726:  MOVWF  xA7
07728:  MOVLW  D0
0772A:  MOVWF  xA6
0772C:  MOVLW  C8
0772E:  MOVWF  xA8
07730:  MOVWF  xA9
07732:  MOVLW  01
07734:  MOVWF  xAA
07736:  MOVWF  xAB
07738:  CLRF   xAC
0773A:  CLRF   xAD
0773C:  MOVLB  0
0773E:  CALL   42F6
....................         y_home_frente(); 
07742:  CALL   342A
....................         x_home_direita(); 
07746:  CALL   368E
.................... 	    contador_step_y = 0; 
0774A:  MOVLB  1
0774C:  CLRF   x7B
0774E:  CLRF   x7A
....................         contador_step_x = 0; 
07750:  CLRF   x79
07752:  CLRF   x78
.................... 	   	if(le_Input(S_Y_FRENTE)  != true)       return erro = 8; 
07754:  MOVLW  07
07756:  MOVWF  x9C
07758:  MOVLB  0
0775A:  CALL   2C54
0775E:  DECFSZ 01,W
07760:  BRA    7764
07762:  BRA    7770
07764:  MOVLW  08
07766:  MOVLB  1
07768:  MOVWF  x96
0776A:  MOVWF  01
0776C:  BRA    779E
0776E:  MOVLB  0
....................         if(le_Input(S_X_DIREITA) != true)       return erro = 9; 
07770:  MOVLW  05
07772:  MOVLB  1
07774:  MOVWF  x9C
07776:  MOVLB  0
07778:  CALL   2C54
0777C:  DECFSZ 01,W
0777E:  BRA    7782
07780:  BRA    778E
07782:  MOVLW  09
07784:  MOVLB  1
07786:  MOVWF  x96
07788:  MOVWF  01
0778A:  BRA    779E
0778C:  MOVLB  0
....................      	envia_posicao_para_maquina1(POSICAO_HOME1); 
0778E:  MOVLB  1
07790:  CLRF   x9A
07792:  MOVLB  0
07794:  CALL   50A4
07798:  MOVLB  1
....................          
....................  
.................... 	} 
....................  
....................    return erro; 
0779A:  MOVFF  196,01
0779E:  MOVLB  0
077A0:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... int aciona_dedos_entrada(void) 
*
046FA:  MOVLB  1
046FC:  CLRF   x95
046FE:  CLRF   x97
04700:  CLRF   x96
04702:  MOVLW  0B
04704:  MOVWF  x99
04706:  MOVLW  B8
04708:  MOVWF  x98
.................... { 
.................... 	int erro = 0; 
....................     long int time_out = 0; 
....................     long int time_out_max = 3000; 
....................  
....................     erro = false; 
0470A:  CLRF   x95
.................... 	posiciona_cursor(3,1); 
0470C:  MOVLW  03
0470E:  MOVWF  xA5
04710:  MOVLW  01
04712:  MOVWF  xA6
04714:  MOVLB  0
04716:  CALL   1F92
....................  	printf(lcd_putc,"ACIONANDO DEDOS     \n\r"); 
0471A:  MOVLW  48
0471C:  MOVWF  FF6
0471E:  MOVLW  12
04720:  MOVWF  FF7
04722:  CALL   25DA
.................... 	printf(lcd_putc,"  DE ENTRADA        "); 
04726:  MOVLW  60
04728:  MOVWF  FF6
0472A:  MOVLW  12
0472C:  MOVWF  FF7
0472E:  CALL   25DA
....................     aciona_saida(DEDO_ENTRADA); 
04732:  MOVLB  1
04734:  CLRF   xA1
04736:  MOVLW  07
04738:  MOVWF  xA0
0473A:  MOVLB  0
0473C:  CALL   2FD2
....................  
....................     while(le_Input(S_DEDO_IN_LS1) == false)   
04740:  MOVLB  1
04742:  CLRF   x9C
04744:  MOVLB  0
04746:  CALL   2C54
0474A:  MOVF   01,F
0474C:  BNZ   477C
.................... 	{ 
....................       
....................      delay_ms(1); 
0474E:  MOVLW  01
04750:  MOVLB  2
04752:  MOVWF  x17
04754:  MOVLB  0
04756:  CALL   1D50
....................      time_out++; 
0475A:  MOVLB  1
0475C:  INCF   x96,F
0475E:  BTFSC  FD8.2
04760:  INCF   x97,F
....................      if(time_out >= time_out_max) return erro = 12; 
04762:  MOVF   x99,W
04764:  SUBWF  x97,W
04766:  BNC   4778
04768:  BNZ   4770
0476A:  MOVF   x98,W
0476C:  SUBWF  x96,W
0476E:  BNC   4778
04770:  MOVLW  0C
04772:  MOVWF  x95
04774:  MOVWF  01
04776:  BRA    47C4
04778:  BRA    4742
0477A:  MOVLB  0
....................  
.................... 	} 
....................  
.................... 	time_out=0; 
0477C:  MOVLB  1
0477E:  CLRF   x97
04780:  CLRF   x96
....................  
....................    while(le_Input(S_DEDO_IN_LS2) == false)   
04782:  MOVLW  01
04784:  MOVWF  x9C
04786:  MOVLB  0
04788:  CALL   2C54
0478C:  MOVF   01,F
0478E:  BNZ   47BE
.................... 	{ 
....................       
....................      delay_ms(1); 
04790:  MOVLW  01
04792:  MOVLB  2
04794:  MOVWF  x17
04796:  MOVLB  0
04798:  CALL   1D50
....................      time_out++; 
0479C:  MOVLB  1
0479E:  INCF   x96,F
047A0:  BTFSC  FD8.2
047A2:  INCF   x97,F
....................      if(time_out >= time_out_max) return erro = 13; 
047A4:  MOVF   x99,W
047A6:  SUBWF  x97,W
047A8:  BNC   47BA
047AA:  BNZ   47B2
047AC:  MOVF   x98,W
047AE:  SUBWF  x96,W
047B0:  BNC   47BA
047B2:  MOVLW  0D
047B4:  MOVWF  x95
047B6:  MOVWF  01
047B8:  BRA    47C4
047BA:  BRA    4782
047BC:  MOVLB  0
....................  
.................... 	} 
....................  
....................       return erro; 
047BE:  MOVLB  1
047C0:  MOVFF  195,01
047C4:  MOVLB  0
047C6:  RETURN 0
.................... } 
....................  
.................... int acionar_alimentador_placa(void) 
047C8:  MOVLB  1
047CA:  CLRF   x95
047CC:  CLRF   x97
047CE:  CLRF   x96
047D0:  MOVLW  2E
047D2:  MOVWF  x99
047D4:  MOVLW  E0
047D6:  MOVWF  x98
.................... {    
.................... 	int erro = 0; 
....................     long int time_out = 0; 
....................     long int time_out_max = 12000; 
....................  
....................   	posiciona_cursor(3,1); 
047D8:  MOVLW  03
047DA:  MOVWF  xA5
047DC:  MOVLW  01
047DE:  MOVWF  xA6
047E0:  MOVLB  0
047E2:  CALL   1F92
.................... 	printf(lcd_putc,"    ACIONANDO       \n\r"); 
047E6:  MOVLW  76
047E8:  MOVWF  FF6
047EA:  MOVLW  12
047EC:  MOVWF  FF7
047EE:  CALL   25DA
.................... 	printf(lcd_putc,"ALIMENTADOR PLACA   "); 
047F2:  MOVLW  8E
047F4:  MOVWF  FF6
047F6:  MOVLW  12
047F8:  MOVWF  FF7
047FA:  CALL   25DA
047FE:  CLRF   16
04800:  BTFSC  FF2.7
04802:  BSF    16.7
04804:  BCF    FF2.7
.................... 	desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
04806:  MOVLB  2
04808:  CLRF   x1B
0480A:  MOVLW  05
0480C:  MOVWF  x1A
0480E:  MOVLB  0
04810:  CALL   1B96
04814:  BTFSC  16.7
04816:  BSF    FF2.7
....................     aciona_saida( EMPURRADOR_ENTRADA_SOL_EMPURRA); 
04818:  MOVLB  1
0481A:  CLRF   xA1
0481C:  MOVLW  06
0481E:  MOVWF  xA0
04820:  MOVLB  0
04822:  CALL   2FD2
....................  
.................... 	while(le_Input(S_BANDEJA) == false)   
04826:  MOVLW  15
04828:  MOVLB  1
0482A:  MOVWF  x9C
0482C:  MOVLB  0
0482E:  CALL   2C54
04832:  MOVF   01,F
04834:  BNZ   4864
....................     { 
....................  
.................... 	 delay_ms(1); 
04836:  MOVLW  01
04838:  MOVLB  2
0483A:  MOVWF  x17
0483C:  MOVLB  0
0483E:  CALL   1D50
....................      time_out++; 
04842:  MOVLB  1
04844:  INCF   x96,F
04846:  BTFSC  FD8.2
04848:  INCF   x97,F
....................      if(time_out >= time_out_max) return erro = 26;		 
0484A:  MOVF   x99,W
0484C:  SUBWF  x97,W
0484E:  BNC   4860
04850:  BNZ   4858
04852:  MOVF   x98,W
04854:  SUBWF  x96,W
04856:  BNC   4860
04858:  MOVLW  1A
0485A:  MOVWF  x95
0485C:  MOVWF  01
0485E:  BRA    48D4
04860:  MOVLB  0
04862:  BRA    4826
04864:  CLRF   16
04866:  BTFSC  FF2.7
04868:  BSF    16.7
0486A:  BCF    FF2.7
....................  
....................  
.................... 	} 
....................  
....................      
....................     desaciona_saida( EMPURRADOR_ENTRADA_SOL_EMPURRA); 
0486C:  MOVLB  2
0486E:  CLRF   x1B
04870:  MOVLW  06
04872:  MOVWF  x1A
04874:  MOVLB  0
04876:  CALL   1B96
0487A:  BTFSC  16.7
0487C:  BSF    FF2.7
....................     aciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
0487E:  MOVLB  1
04880:  CLRF   xA1
04882:  MOVLW  05
04884:  MOVWF  xA0
04886:  MOVLB  0
04888:  CALL   2FD2
....................  
....................     time_out = 0; 
0488C:  MOVLB  1
0488E:  CLRF   x97
04890:  CLRF   x96
.................... 	while(le_Input(S_EMPURRADOR_IN_LS2) == false)   
04892:  MOVLW  03
04894:  MOVWF  x9C
04896:  MOVLB  0
04898:  CALL   2C54
0489C:  MOVF   01,F
0489E:  BNZ   48CE
....................     { 
....................  
.................... 	 delay_ms(1); 
048A0:  MOVLW  01
048A2:  MOVLB  2
048A4:  MOVWF  x17
048A6:  MOVLB  0
048A8:  CALL   1D50
....................      time_out++; 
048AC:  MOVLB  1
048AE:  INCF   x96,F
048B0:  BTFSC  FD8.2
048B2:  INCF   x97,F
....................      if(time_out >= time_out_max) return erro = 27;	 
048B4:  MOVF   x99,W
048B6:  SUBWF  x97,W
048B8:  BNC   48CA
048BA:  BNZ   48C2
048BC:  MOVF   x98,W
048BE:  SUBWF  x96,W
048C0:  BNC   48CA
048C2:  MOVLW  1B
048C4:  MOVWF  x95
048C6:  MOVWF  01
048C8:  BRA    48D4
048CA:  BRA    4892
048CC:  MOVLB  0
....................     } 
....................  
....................     return erro; 
048CE:  MOVLB  1
048D0:  MOVFF  195,01
048D4:  MOVLB  0
048D6:  RETURN 0
.................... } 
....................  
.................... int desaciona_mecanismo_de_entrada(void) 
*
02708:  MOVLB  1
0270A:  CLRF   x95
0270C:  CLRF   16
0270E:  BTFSC  FF2.7
02710:  BSF    16.7
02712:  BCF    FF2.7
.................... { 
.................... 	int erro = false; 
....................  
....................     
....................     desaciona_saida(DEDO_ENTRADA); 
02714:  MOVLB  2
02716:  CLRF   x1B
02718:  MOVLW  07
0271A:  MOVWF  x1A
0271C:  MOVLB  0
0271E:  CALL   1B96
02722:  BTFSC  16.7
02724:  BSF    FF2.7
02726:  CLRF   16
02728:  BTFSC  FF2.7
0272A:  BSF    16.7
0272C:  BCF    FF2.7
.................... 	desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
0272E:  MOVLB  2
02730:  CLRF   x1B
02732:  MOVLW  05
02734:  MOVWF  x1A
02736:  MOVLB  0
02738:  CALL   1B96
0273C:  BTFSC  16.7
0273E:  BSF    FF2.7
02740:  CLRF   16
02742:  BTFSC  FF2.7
02744:  BSF    16.7
02746:  BCF    FF2.7
....................     desaciona_saida( EMPURRADOR_ENTRADA_SOL_EMPURRA); 
02748:  MOVLB  2
0274A:  CLRF   x1B
0274C:  MOVLW  06
0274E:  MOVWF  x1A
02750:  MOVLB  0
02752:  CALL   1B96
02756:  BTFSC  16.7
02758:  BSF    FF2.7
....................  
....................     return erro; 
0275A:  MOVLB  1
0275C:  MOVFF  195,01
02760:  MOVLB  0
02762:  RETURN 0
....................  
.................... } 
....................  
.................... int desaciona_mecanismo_de_saida(void) 
02764:  MOVLB  1
02766:  CLRF   x95
02768:  CLRF   16
0276A:  BTFSC  FF2.7
0276C:  BSF    16.7
0276E:  BCF    FF2.7
.................... { 
.................... 	int erro = 0; 
....................  
.................... 	desaciona_saida(DEDO_SAIDA); 
02770:  MOVLB  2
02772:  CLRF   x1B
02774:  MOVLW  01
02776:  MOVWF  x1A
02778:  MOVLB  0
0277A:  CALL   1B96
0277E:  BTFSC  16.7
02780:  BSF    FF2.7
02782:  CLRF   16
02784:  BTFSC  FF2.7
02786:  BSF    16.7
02788:  BCF    FF2.7
.................... 	desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
0278A:  MOVLB  2
0278C:  CLRF   x1B
0278E:  MOVLW  0F
02790:  MOVWF  x1A
02792:  MOVLB  0
02794:  CALL   1B96
02798:  BTFSC  16.7
0279A:  BSF    FF2.7
0279C:  CLRF   16
0279E:  BTFSC  FF2.7
027A0:  BSF    16.7
027A2:  BCF    FF2.7
.................... 	desaciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
027A4:  MOVLB  2
027A6:  CLRF   x1B
027A8:  CLRF   x1A
027AA:  MOVLB  0
027AC:  CALL   1B96
027B0:  BTFSC  16.7
027B2:  BSF    FF2.7
....................  
.................... 	return erro; 
027B4:  MOVLB  1
027B6:  MOVFF  195,01
027BA:  MOVLB  0
027BC:  RETURN 0
....................  
.................... } 
....................  
.................... int acionar_pressor(void) 
*
048D8:  MOVLB  1
048DA:  CLRF   x95
048DC:  CLRF   x97
048DE:  CLRF   x96
048E0:  MOVLW  0B
048E2:  MOVWF  x99
048E4:  MOVLW  B8
048E6:  MOVWF  x98
.................... { 
.................... 	int erro=0; 
....................     long int time_out = 0; 
....................     long int time_out_max = 3000; 
....................  
....................   	posiciona_cursor(3,1); 
048E8:  MOVLW  03
048EA:  MOVWF  xA5
048EC:  MOVLW  01
048EE:  MOVWF  xA6
048F0:  MOVLB  0
048F2:  CALL   1F92
.................... 	printf(lcd_putc,"ACIONANDO PRESSOR   \n\r"); 
048F6:  MOVLW  A4
048F8:  MOVWF  FF6
048FA:  MOVLW  12
048FC:  MOVWF  FF7
048FE:  CALL   25DA
.................... 	printf(lcd_putc,"                    "); 
04902:  MOVLW  BC
04904:  MOVWF  FF6
04906:  MOVLW  12
04908:  MOVWF  FF7
0490A:  CALL   25DA
....................  
.................... 	aciona_saida(PRESSOR);	 
0490E:  MOVLB  1
04910:  CLRF   xA1
04912:  MOVLW  04
04914:  MOVWF  xA0
04916:  MOVLB  0
04918:  CALL   2FD2
....................     while(le_Input(S_PRESSOR_LS2) == false)   
0491C:  MOVLW  04
0491E:  MOVLB  1
04920:  MOVWF  x9C
04922:  MOVLB  0
04924:  CALL   2C54
04928:  MOVF   01,F
0492A:  BNZ   495A
.................... 	{ 
....................       
....................        delay_ms(1); 
0492C:  MOVLW  01
0492E:  MOVLB  2
04930:  MOVWF  x17
04932:  MOVLB  0
04934:  CALL   1D50
....................        time_out++; 
04938:  MOVLB  1
0493A:  INCF   x96,F
0493C:  BTFSC  FD8.2
0493E:  INCF   x97,F
....................        if(time_out >= time_out_max) return erro = 17; 
04940:  MOVF   x99,W
04942:  SUBWF  x97,W
04944:  BNC   4956
04946:  BNZ   494E
04948:  MOVF   x98,W
0494A:  SUBWF  x96,W
0494C:  BNC   4956
0494E:  MOVLW  11
04950:  MOVWF  x95
04952:  MOVWF  01
04954:  BRA    4960
04956:  MOVLB  0
04958:  BRA    491C
....................  
.................... 	} 
....................     
....................     return erro; 
0495A:  MOVLB  1
0495C:  MOVFF  195,01
04960:  MOVLB  0
04962:  RETURN 0
.................... } 
....................  
....................  
.................... int desaciona_pressor(void) 
*
07118:  MOVLB  1
0711A:  CLRF   x95
0711C:  CLRF   x97
0711E:  CLRF   x96
07120:  MOVLW  0B
07122:  MOVWF  x99
07124:  MOVLW  B8
07126:  MOVWF  x98
.................... { 
.................... 	int erro=0; 
....................     long int time_out = 0; 
....................     long int time_out_max = 3000; 
....................  
....................   	posiciona_cursor(3,1); 
07128:  MOVLW  03
0712A:  MOVWF  xA5
0712C:  MOVLW  01
0712E:  MOVWF  xA6
07130:  MOVLB  0
07132:  CALL   1F92
.................... 	printf(lcd_putc,"DESACION. PRESSOR  \n\r"); 
07136:  MOVLW  D2
07138:  MOVWF  FF6
0713A:  MOVLW  12
0713C:  MOVWF  FF7
0713E:  CALL   25DA
.................... 	printf(lcd_putc,"                    "); 
07142:  MOVLW  E8
07144:  MOVWF  FF6
07146:  MOVLW  12
07148:  MOVWF  FF7
0714A:  CALL   25DA
0714E:  CLRF   16
07150:  BTFSC  FF2.7
07152:  BSF    16.7
07154:  BCF    FF2.7
....................  
.................... 	desaciona_saida(PRESSOR);	 
07156:  MOVLB  2
07158:  CLRF   x1B
0715A:  MOVLW  04
0715C:  MOVWF  x1A
0715E:  MOVLB  0
07160:  CALL   1B96
07164:  BTFSC  16.7
07166:  BSF    FF2.7
....................     while(le_Input(S_PRESSOR_LS2) == true)   
07168:  MOVLW  04
0716A:  MOVLB  1
0716C:  MOVWF  x9C
0716E:  MOVLB  0
07170:  CALL   2C54
07174:  DECFSZ 01,W
07176:  BRA    71A6
.................... 	{ 
....................       
....................      delay_ms(1); 
07178:  MOVLW  01
0717A:  MOVLB  2
0717C:  MOVWF  x17
0717E:  MOVLB  0
07180:  CALL   1D50
....................      time_out++; 
07184:  MOVLB  1
07186:  INCF   x96,F
07188:  BTFSC  FD8.2
0718A:  INCF   x97,F
....................      if(time_out >= time_out_max) return erro = 17; 
0718C:  MOVF   x99,W
0718E:  SUBWF  x97,W
07190:  BNC   71A2
07192:  BNZ   719A
07194:  MOVF   x98,W
07196:  SUBWF  x96,W
07198:  BNC   71A2
0719A:  MOVLW  11
0719C:  MOVWF  x95
0719E:  MOVWF  01
071A0:  BRA    71AC
071A2:  MOVLB  0
071A4:  BRA    7168
....................  
.................... 	} 
....................     
....................     return erro; 
071A6:  MOVLB  1
071A8:  MOVFF  195,01
071AC:  MOVLB  0
071AE:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... int aciona_dedos_saida(void) 
071B0:  MOVLB  1
071B2:  CLRF   x95
071B4:  CLRF   x97
071B6:  CLRF   x96
071B8:  MOVLW  0B
071BA:  MOVWF  x99
071BC:  MOVLW  B8
071BE:  MOVWF  x98
.................... { 
....................     int erro = 0; 
....................     long int time_out = 0; 
....................     long int time_out_max = 3000; 
....................  
.................... 	posiciona_cursor(3,1); 
071C0:  MOVLW  03
071C2:  MOVWF  xA5
071C4:  MOVLW  01
071C6:  MOVWF  xA6
071C8:  MOVLB  0
071CA:  CALL   1F92
.................... 	printf(lcd_putc,"ACIONANDO DEDOS     \n\r"); 
071CE:  MOVLW  FE
071D0:  MOVWF  FF6
071D2:  MOVLW  12
071D4:  MOVWF  FF7
071D6:  CALL   25DA
.................... 	printf(lcd_putc,"     SAIDA          "); 
071DA:  MOVLW  16
071DC:  MOVWF  FF6
071DE:  MOVLW  13
071E0:  MOVWF  FF7
071E2:  CALL   25DA
....................  
.................... 	aciona_saida(DEDO_SAIDA); 
071E6:  MOVLB  1
071E8:  CLRF   xA1
071EA:  MOVLW  01
071EC:  MOVWF  xA0
071EE:  MOVLB  0
071F0:  CALL   2FD2
....................  
....................     while(le_Input(S_DEDO_OUT_LS1) == false)   
071F4:  MOVLW  10
071F6:  MOVLB  1
071F8:  MOVWF  x9C
071FA:  MOVLB  0
071FC:  CALL   2C54
07200:  MOVF   01,F
07202:  BNZ   7232
.................... 	{ 
....................       
....................      delay_ms(1); 
07204:  MOVLW  01
07206:  MOVLB  2
07208:  MOVWF  x17
0720A:  MOVLB  0
0720C:  CALL   1D50
....................      time_out++; 
07210:  MOVLB  1
07212:  INCF   x96,F
07214:  BTFSC  FD8.2
07216:  INCF   x97,F
....................      if(time_out >= time_out_max) return erro = 15; 
07218:  MOVF   x99,W
0721A:  SUBWF  x97,W
0721C:  BNC   722E
0721E:  BNZ   7226
07220:  MOVF   x98,W
07222:  SUBWF  x96,W
07224:  BNC   722E
07226:  MOVLW  0F
07228:  MOVWF  x95
0722A:  MOVWF  01
0722C:  BRA    727A
0722E:  MOVLB  0
07230:  BRA    71F4
....................  
.................... 	} 
....................  
.................... 	time_out=0; 
07232:  MOVLB  1
07234:  CLRF   x97
07236:  CLRF   x96
....................  
....................     while(le_Input(S_DEDO_OUT_LS2) == false)   
07238:  MOVLW  11
0723A:  MOVWF  x9C
0723C:  MOVLB  0
0723E:  CALL   2C54
07242:  MOVF   01,F
07244:  BNZ   7274
.................... 	{ 
....................       
....................      delay_ms(1); 
07246:  MOVLW  01
07248:  MOVLB  2
0724A:  MOVWF  x17
0724C:  MOVLB  0
0724E:  CALL   1D50
....................      time_out++; 
07252:  MOVLB  1
07254:  INCF   x96,F
07256:  BTFSC  FD8.2
07258:  INCF   x97,F
....................      if(time_out >= time_out_max) return erro = 16; 
0725A:  MOVF   x99,W
0725C:  SUBWF  x97,W
0725E:  BNC   7270
07260:  BNZ   7268
07262:  MOVF   x98,W
07264:  SUBWF  x96,W
07266:  BNC   7270
07268:  MOVLW  10
0726A:  MOVWF  x95
0726C:  MOVWF  01
0726E:  BRA    727A
07270:  BRA    7238
07272:  MOVLB  0
....................  
.................... 	} 
....................  
....................  
....................  
....................  
....................    return erro; 
07274:  MOVLB  1
07276:  MOVFF  195,01
0727A:  MOVLB  0
0727C:  RETURN 0
....................  
.................... } 
....................  
.................... int desaciona_dedos_saida(void) 
*
0738A:  MOVLB  1
0738C:  CLRF   x95
0738E:  CLRF   x97
07390:  CLRF   x96
07392:  MOVLW  0B
07394:  MOVWF  x99
07396:  MOVLW  B8
07398:  MOVWF  x98
.................... { 
....................     int erro = 0; 
....................     long int time_out = 0; 
....................     long int time_out_max = 3000; 
....................  
.................... 	posiciona_cursor(3,1); 
0739A:  MOVLW  03
0739C:  MOVWF  xA5
0739E:  MOVLW  01
073A0:  MOVWF  xA6
073A2:  MOVLB  0
073A4:  CALL   1F92
.................... 	printf(lcd_putc,"DESACIONANDO DEDOS \n\r"); 
073A8:  MOVLW  2C
073AA:  MOVWF  FF6
073AC:  MOVLW  13
073AE:  MOVWF  FF7
073B0:  CALL   25DA
.................... 	printf(lcd_putc,"     SAIDA         "); 
073B4:  MOVLW  42
073B6:  MOVWF  FF6
073B8:  MOVLW  13
073BA:  MOVWF  FF7
073BC:  CALL   25DA
073C0:  CLRF   16
073C2:  BTFSC  FF2.7
073C4:  BSF    16.7
073C6:  BCF    FF2.7
....................  
.................... 	desaciona_saida(DEDO_SAIDA); 
073C8:  MOVLB  2
073CA:  CLRF   x1B
073CC:  MOVLW  01
073CE:  MOVWF  x1A
073D0:  MOVLB  0
073D2:  CALL   1B96
073D6:  BTFSC  16.7
073D8:  BSF    FF2.7
....................  
....................     while(le_Input(S_DEDO_OUT_LS1) == true)   
073DA:  MOVLW  10
073DC:  MOVLB  1
073DE:  MOVWF  x9C
073E0:  MOVLB  0
073E2:  CALL   2C54
073E6:  DECFSZ 01,W
073E8:  BRA    7418
.................... 	{ 
....................       
....................      delay_ms(1); 
073EA:  MOVLW  01
073EC:  MOVLB  2
073EE:  MOVWF  x17
073F0:  MOVLB  0
073F2:  CALL   1D50
....................      time_out++; 
073F6:  MOVLB  1
073F8:  INCF   x96,F
073FA:  BTFSC  FD8.2
073FC:  INCF   x97,F
....................      if(time_out >= time_out_max) return erro = 15; 
073FE:  MOVF   x99,W
07400:  SUBWF  x97,W
07402:  BNC   7414
07404:  BNZ   740C
07406:  MOVF   x98,W
07408:  SUBWF  x96,W
0740A:  BNC   7414
0740C:  MOVLW  0F
0740E:  MOVWF  x95
07410:  MOVWF  01
07412:  BRA    7460
07414:  MOVLB  0
07416:  BRA    73DA
....................  
.................... 	} 
....................  
.................... 	time_out=0; 
07418:  MOVLB  1
0741A:  CLRF   x97
0741C:  CLRF   x96
....................  
....................     while(le_Input(S_DEDO_OUT_LS2) == true)   
0741E:  MOVLW  11
07420:  MOVWF  x9C
07422:  MOVLB  0
07424:  CALL   2C54
07428:  DECFSZ 01,W
0742A:  BRA    745A
.................... 	{ 
....................       
....................      delay_ms(1); 
0742C:  MOVLW  01
0742E:  MOVLB  2
07430:  MOVWF  x17
07432:  MOVLB  0
07434:  CALL   1D50
....................      time_out++; 
07438:  MOVLB  1
0743A:  INCF   x96,F
0743C:  BTFSC  FD8.2
0743E:  INCF   x97,F
....................      if(time_out >= time_out_max) return erro = 16; 
07440:  MOVF   x99,W
07442:  SUBWF  x97,W
07444:  BNC   7456
07446:  BNZ   744E
07448:  MOVF   x98,W
0744A:  SUBWF  x96,W
0744C:  BNC   7456
0744E:  MOVLW  10
07450:  MOVWF  x95
07452:  MOVWF  01
07454:  BRA    7460
07456:  BRA    741E
07458:  MOVLB  0
....................  
.................... 	} 
....................  
....................  
....................  
....................  
....................    return erro; 
0745A:  MOVLB  1
0745C:  MOVFF  195,01
07460:  MOVLB  0
07462:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... int aciona_dispensador_placa(void) 
*
0727E:  MOVLB  1
07280:  CLRF   x95
07282:  CLRF   x97
07284:  CLRF   x96
07286:  MOVLW  0F
07288:  MOVWF  x99
0728A:  MOVLW  A0
0728C:  MOVWF  x98
.................... { 
.................... 	int erro = 0; 
....................     long int time_out = 0; 
....................     long int time_out_max = 4000; 
....................  
.................... 	posiciona_cursor(3,1); 
0728E:  MOVLW  03
07290:  MOVWF  xA5
07292:  MOVLW  01
07294:  MOVWF  xA6
07296:  MOVLB  0
07298:  CALL   1F92
.................... 	printf(lcd_putc,"   ACIONANDO        \n\r"); 
0729C:  MOVLW  56
0729E:  MOVWF  FF6
072A0:  MOVLW  13
072A2:  MOVWF  FF7
072A4:  CALL   25DA
.................... 	printf(lcd_putc," DISPENSADOR PLACA  "); 
072A8:  MOVLW  6E
072AA:  MOVWF  FF6
072AC:  MOVLW  13
072AE:  MOVWF  FF7
072B0:  CALL   25DA
072B4:  CLRF   16
072B6:  BTFSC  FF2.7
072B8:  BSF    16.7
072BA:  BCF    FF2.7
....................  
.................... 	desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
072BC:  MOVLB  2
072BE:  CLRF   x1B
072C0:  MOVLW  0F
072C2:  MOVWF  x1A
072C4:  MOVLB  0
072C6:  CALL   1B96
072CA:  BTFSC  16.7
072CC:  BSF    FF2.7
.................... 	aciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
072CE:  MOVLB  1
072D0:  CLRF   xA1
072D2:  CLRF   xA0
072D4:  MOVLB  0
072D6:  CALL   2FD2
....................  
.................... 	while(le_Input(S_EMPURRADOR_OUT_LS1) == false)   
072DA:  MOVLW  12
072DC:  MOVLB  1
072DE:  MOVWF  x9C
072E0:  MOVLB  0
072E2:  CALL   2C54
072E6:  MOVF   01,F
072E8:  BNZ   7318
....................     { 
....................  
.................... 	 delay_ms(1); 
072EA:  MOVLW  01
072EC:  MOVLB  2
072EE:  MOVWF  x17
072F0:  MOVLB  0
072F2:  CALL   1D50
....................      time_out++; 
072F6:  MOVLB  1
072F8:  INCF   x96,F
072FA:  BTFSC  FD8.2
072FC:  INCF   x97,F
....................      if(time_out >= time_out_max) return erro = 18;		 
072FE:  MOVF   x99,W
07300:  SUBWF  x97,W
07302:  BNC   7314
07304:  BNZ   730C
07306:  MOVF   x98,W
07308:  SUBWF  x96,W
0730A:  BNC   7314
0730C:  MOVLW  12
0730E:  MOVWF  x95
07310:  MOVWF  01
07312:  BRA    7386
07314:  MOVLB  0
07316:  BRA    72DA
07318:  CLRF   16
0731A:  BTFSC  FF2.7
0731C:  BSF    16.7
0731E:  BCF    FF2.7
....................  
....................  
.................... 	} 
....................  
....................     desaciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
07320:  MOVLB  2
07322:  CLRF   x1B
07324:  CLRF   x1A
07326:  MOVLB  0
07328:  CALL   1B96
0732C:  BTFSC  16.7
0732E:  BSF    FF2.7
....................     aciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
07330:  MOVLB  1
07332:  CLRF   xA1
07334:  MOVLW  0F
07336:  MOVWF  xA0
07338:  MOVLB  0
0733A:  CALL   2FD2
....................  
....................     time_out = 0; 
0733E:  MOVLB  1
07340:  CLRF   x97
07342:  CLRF   x96
.................... 	while(le_Input(S_EMPURRADOR_OUT_LS2) == false)   
07344:  MOVLW  13
07346:  MOVWF  x9C
07348:  MOVLB  0
0734A:  CALL   2C54
0734E:  MOVF   01,F
07350:  BNZ   7380
....................     { 
....................  
.................... 	 delay_ms(1); 
07352:  MOVLW  01
07354:  MOVLB  2
07356:  MOVWF  x17
07358:  MOVLB  0
0735A:  CALL   1D50
....................      time_out++; 
0735E:  MOVLB  1
07360:  INCF   x96,F
07362:  BTFSC  FD8.2
07364:  INCF   x97,F
....................      if(time_out >= time_out_max) return erro = 19;		 
07366:  MOVF   x99,W
07368:  SUBWF  x97,W
0736A:  BNC   737C
0736C:  BNZ   7374
0736E:  MOVF   x98,W
07370:  SUBWF  x96,W
07372:  BNC   737C
07374:  MOVLW  13
07376:  MOVWF  x95
07378:  MOVWF  01
0737A:  BRA    7386
0737C:  BRA    7344
0737E:  MOVLB  0
....................  
....................  
.................... 	} 
....................  
....................  
.................... 	return erro; 
07380:  MOVLB  1
07382:  MOVFF  195,01
07386:  MOVLB  0
07388:  RETURN 0
....................  
.................... } 
....................  
.................... int checa_farol_1(int n_step) 
*
06D28:  MOVLB  1
06D2A:  CLRF   x96
06D2C:  CLRF   x97
.................... { 
.................... 	int farol = FAROL_VERMELHO;  
....................     int erro = 0;  
....................  
....................   if(enable_checa_farol == false) return; 
06D2E:  MOVF   27,F
06D30:  BTFSC  FD8.2
06D32:  BRA    6F2C
....................  
....................  
.................... while( farol == FAROL_VERMELHO) 
06D34:  MOVF   x96,F
06D36:  BTFSS  FD8.2
06D38:  BRA    6F26
.................... {	 
....................  
....................   switch(n_step){ 
06D3A:  MOVF   x95,W
06D3C:  XORLW  01
06D3E:  MOVLB  0
06D40:  BZ    6D58
06D42:  XORLW  03
06D44:  BZ    6D9C
06D46:  XORLW  01
06D48:  BZ    6DE0
06D4A:  XORLW  07
06D4C:  BTFSC  FD8.2
06D4E:  BRA    6E5E
06D50:  XORLW  01
06D52:  BTFSC  FD8.2
06D54:  BRA    6EA2
06D56:  BRA    6F22
....................  
.................... 	case(1):     posiciona_cursor(3,1); 
06D58:  MOVLW  03
06D5A:  MOVLB  1
06D5C:  MOVWF  xA5
06D5E:  MOVLW  01
06D60:  MOVWF  xA6
06D62:  MOVLB  0
06D64:  CALL   1F92
.................... 	             printf(lcd_putc,"ESPERANDO MAQUINA 2\n\r"); 
06D68:  MOVLW  84
06D6A:  MOVWF  FF6
06D6C:  MOVLW  13
06D6E:  MOVWF  FF7
06D70:  CALL   25DA
.................... 	             printf(lcd_putc,"SAIR ESTAGIO1      "); 
06D74:  MOVLW  9A
06D76:  MOVWF  FF6
06D78:  MOVLW  13
06D7A:  MOVWF  FF7
06D7C:  CALL   25DA
....................  
.................... 				 if(le_posicao_da_maquina2() == POSICAO_ALIMENTADOR) 
06D80:  CALL   363A
06D84:  MOVF   01,W
06D86:  SUBLW  02
06D88:  BNZ   6D92
.................... 				 { 
.................... 					 
....................  					farol = FAROL_VERMELHO;  
06D8A:  MOVLB  1
06D8C:  CLRF   x96
.................... 					 
....................  
.................... 					break; 
06D8E:  BRA    6F24
06D90:  MOVLB  0
.................... 				 } 
....................  
.................... 				 farol = FAROL_VERDE;  
06D92:  MOVLW  01
06D94:  MOVLB  1
06D96:  MOVWF  x96
....................  				 erro = 0; 
06D98:  CLRF   x97
.................... 				 break; 
06D9A:  BRA    6F24
....................  
....................  
.................... 	case(2):      
.................... 				posiciona_cursor(3,1); 
06D9C:  MOVLW  03
06D9E:  MOVLB  1
06DA0:  MOVWF  xA5
06DA2:  MOVLW  01
06DA4:  MOVWF  xA6
06DA6:  MOVLB  0
06DA8:  CALL   1F92
.................... 	            printf(lcd_putc,"ESPERANDO MAQUINA 2\n\r"); 
06DAC:  MOVLW  AE
06DAE:  MOVWF  FF6
06DB0:  MOVLW  13
06DB2:  MOVWF  FF7
06DB4:  CALL   25DA
.................... 	            printf(lcd_putc,"SAIR DISPENSADOR   "); 
06DB8:  MOVLW  C4
06DBA:  MOVWF  FF6
06DBC:  MOVLW  13
06DBE:  MOVWF  FF7
06DC0:  CALL   25DA
.................... 				if(le_posicao_da_maquina2() == POSICAO_DISPENSADOR) 
06DC4:  CALL   363A
06DC8:  MOVF   01,W
06DCA:  SUBLW  05
06DCC:  BNZ   6DD6
.................... 				 { 
.................... 					farol = FAROL_VERMELHO; 
06DCE:  MOVLB  1
06DD0:  CLRF   x96
.................... 				 
....................  
.................... 					break; 
06DD2:  BRA    6F24
06DD4:  MOVLB  0
....................  
.................... 				 } 
....................    					farol = FAROL_VERDE;  
06DD6:  MOVLW  01
06DD8:  MOVLB  1
06DDA:  MOVWF  x96
....................                     erro = 0; 
06DDC:  CLRF   x97
.................... 				    break; 
06DDE:  BRA    6F24
....................  
.................... 	case(3):     posiciona_cursor(3,1); 
06DE0:  MOVLW  03
06DE2:  MOVLB  1
06DE4:  MOVWF  xA5
06DE6:  MOVLW  01
06DE8:  MOVWF  xA6
06DEA:  MOVLB  0
06DEC:  CALL   1F92
.................... 	             printf(lcd_putc,"ESPERANDO MAQUINA 2\n\r"); 
06DF0:  MOVLW  D8
06DF2:  MOVWF  FF6
06DF4:  MOVLW  13
06DF6:  MOVWF  FF7
06DF8:  CALL   25DA
.................... 	             printf(lcd_putc,"SAIR DISPENSADOR   "); 
06DFC:  MOVLW  EE
06DFE:  MOVWF  FF6
06E00:  MOVLW  13
06E02:  MOVWF  FF7
06E04:  CALL   25DA
....................  
.................... 				 if(le_posicao_da_maquina2() == POSICAO_DISPENSADOR) 
06E08:  CALL   363A
06E0C:  MOVF   01,W
06E0E:  SUBLW  05
06E10:  BNZ   6E1A
.................... 				 { 
.................... 					farol = FAROL_VERMELHO; 
06E12:  MOVLB  1
06E14:  CLRF   x96
.................... 					 
....................  
.................... 					break; 
06E16:  BRA    6F24
06E18:  MOVLB  0
....................  
.................... 				 } 
....................  
....................    
.................... 	            posiciona_cursor(3,1); 
06E1A:  MOVLW  03
06E1C:  MOVLB  1
06E1E:  MOVWF  xA5
06E20:  MOVLW  01
06E22:  MOVWF  xA6
06E24:  MOVLB  0
06E26:  CALL   1F92
.................... 	            printf(lcd_putc,"ESPERANDO MAQUINA 2\n\r"); 
06E2A:  MOVLW  02
06E2C:  MOVWF  FF6
06E2E:  MOVLW  14
06E30:  MOVWF  FF7
06E32:  CALL   25DA
.................... 	            printf(lcd_putc,"SAIR ESTAGIO 1    "); 
06E36:  MOVLW  18
06E38:  MOVWF  FF6
06E3A:  MOVLW  14
06E3C:  MOVWF  FF7
06E3E:  CALL   25DA
....................                 if(le_posicao_da_maquina2() == POSICAO_SOLDA_ESTAGIO1) 
06E42:  CALL   363A
06E46:  MOVF   01,W
06E48:  SUBLW  03
06E4A:  BNZ   6E54
.................... 				 { 
.................... 					farol = FAROL_VERMELHO; 
06E4C:  MOVLB  1
06E4E:  CLRF   x96
.................... 				 
....................  
.................... 					break; 
06E50:  BRA    6F24
06E52:  MOVLB  0
....................  
.................... 				 } 
.................... 				 
....................  
....................  
.................... 				 //if(le_Input(S_Y_ESQUERDA_PROT) == true) return erro = 1; 
....................                  farol = FAROL_VERDE;  
06E54:  MOVLW  01
06E56:  MOVLB  1
06E58:  MOVWF  x96
....................                  erro = 0; 
06E5A:  CLRF   x97
.................... 				 break; 
06E5C:  BRA    6F24
....................  
.................... 	 
....................  
.................... 		case(4):  
.................... 				 posiciona_cursor(3,1); 
06E5E:  MOVLW  03
06E60:  MOVLB  1
06E62:  MOVWF  xA5
06E64:  MOVLW  01
06E66:  MOVWF  xA6
06E68:  MOVLB  0
06E6A:  CALL   1F92
.................... 	             printf(lcd_putc,"ESPERANDO MAQUINA 2\n\r"); 
06E6E:  MOVLW  2C
06E70:  MOVWF  FF6
06E72:  MOVLW  14
06E74:  MOVWF  FF7
06E76:  CALL   25DA
.................... 	             printf(lcd_putc,"SAIR ALIMENTADOR   "); 
06E7A:  MOVLW  42
06E7C:  MOVWF  FF6
06E7E:  MOVLW  14
06E80:  MOVWF  FF7
06E82:  CALL   25DA
.................... 				 if(le_posicao_da_maquina2() == POSICAO_ALIMENTADOR) 
06E86:  CALL   363A
06E8A:  MOVF   01,W
06E8C:  SUBLW  02
06E8E:  BNZ   6E98
.................... 				 { 
.................... 					farol = FAROL_VERMELHO; 
06E90:  MOVLB  1
06E92:  CLRF   x96
.................... 					 
....................  
.................... 					break; 
06E94:  BRA    6F24
06E96:  MOVLB  0
....................  
.................... 				 } 
....................  
....................              
.................... 				//if(le_Input(S_Y_ESQUERDA_PROT) == true) return erro = 1; 
.................... 				farol = FAROL_VERDE;  
06E98:  MOVLW  01
06E9A:  MOVLB  1
06E9C:  MOVWF  x96
....................                 erro = 0; 
06E9E:  CLRF   x97
.................... 				 break; 
06EA0:  BRA    6F24
....................  
....................  
....................     	case(5):   posiciona_cursor(3,1); 
06EA2:  MOVLW  03
06EA4:  MOVLB  1
06EA6:  MOVWF  xA5
06EA8:  MOVLW  01
06EAA:  MOVWF  xA6
06EAC:  MOVLB  0
06EAE:  CALL   1F92
.................... 	               printf(lcd_putc,"ESPERANDO MAQUINA 2\n\r"); 
06EB2:  MOVLW  56
06EB4:  MOVWF  FF6
06EB6:  MOVLW  14
06EB8:  MOVWF  FF7
06EBA:  CALL   25DA
.................... 	               printf(lcd_putc,"SAIR DISPENSADOR   "); 
06EBE:  MOVLW  6C
06EC0:  MOVWF  FF6
06EC2:  MOVLW  14
06EC4:  MOVWF  FF7
06EC6:  CALL   25DA
....................  
....................  				   if(le_posicao_da_maquina2() == POSICAO_ALIMENTADOR ) 
06ECA:  CALL   363A
06ECE:  MOVF   01,W
06ED0:  SUBLW  02
06ED2:  BNZ   6EDC
.................... 				   { 
.................... 					  farol = FAROL_VERMELHO; 
06ED4:  MOVLB  1
06ED6:  CLRF   x96
.................... 					  break; 
06ED8:  BRA    6F24
06EDA:  MOVLB  0
....................  
.................... 				   } 
....................  
.................... 				  posiciona_cursor(3,1); 
06EDC:  MOVLW  03
06EDE:  MOVLB  1
06EE0:  MOVWF  xA5
06EE2:  MOVLW  01
06EE4:  MOVWF  xA6
06EE6:  MOVLB  0
06EE8:  CALL   1F92
.................... 	              printf(lcd_putc,"ESPERANDO MAQUINA 2\n\r"); 
06EEC:  MOVLW  80
06EEE:  MOVWF  FF6
06EF0:  MOVLW  14
06EF2:  MOVWF  FF7
06EF4:  CALL   25DA
.................... 	              printf(lcd_putc,"    SAIR STOP          "); 
06EF8:  MOVLW  96
06EFA:  MOVWF  FF6
06EFC:  MOVLW  14
06EFE:  MOVWF  FF7
06F00:  CALL   25DA
....................  
....................  				  if(le_posicao_da_maquina2() == STOP) 
06F04:  CALL   363A
06F08:  MOVF   01,W
06F0A:  SUBLW  07
06F0C:  BNZ   6F16
.................... 				  { 
.................... 					farol = FAROL_VERMELHO; 
06F0E:  MOVLB  1
06F10:  CLRF   x96
.................... 				 
.................... 					break; 
06F12:  BRA    6F24
06F14:  MOVLB  0
....................  
.................... 				  } 
....................  
....................  
.................... 		         farol = FAROL_VERDE;  
06F16:  MOVLW  01
06F18:  MOVLB  1
06F1A:  MOVWF  x96
....................                  erro = 0; 
06F1C:  CLRF   x97
.................... 				  
....................  
....................  				 break; 
06F1E:  BRA    6F24
06F20:  MOVLB  0
....................  
....................     default: 
.................... 				break; 
06F22:  MOVLB  1
....................  
....................  
....................  
....................  
....................    }       
06F24:  BRA    6D34
....................  
....................  
.................... } 
....................  
.................... 		return erro = 0; 
06F26:  CLRF   x97
06F28:  MOVFF  197,01
06F2C:  MOVLB  0
06F2E:  RETURN 0
....................  
.................... }  
....................  
....................  
....................  
.................... int checa_farol_2(int n_step) 
*
07C76:  MOVLB  1
07C78:  CLRF   x96
07C7A:  CLRF   x97
.................... { 
.................... 	int farol = FAROL_VERMELHO;  
....................     int erro = 0;  
....................  
....................   if(enable_checa_farol == false) return; 
07C7C:  MOVF   27,F
07C7E:  BTFSC  FD8.2
07C80:  BRA    7D30
....................  
....................  
.................... while( farol == FAROL_VERMELHO) 
07C82:  MOVF   x96,F
07C84:  BNZ   7D2A
.................... {	 
....................  
....................   switch(n_step){ 
07C86:  MOVF   x95,W
07C88:  XORLW  01
07C8A:  MOVLB  0
07C8C:  BZ    7C9C
07C8E:  XORLW  03
07C90:  BZ    7CB6
07C92:  XORLW  01
07C94:  BZ    7CD0
07C96:  XORLW  07
07C98:  BZ    7CFA
07C9A:  BRA    7D26
....................  
.................... 	case(1):     if(le_posicao_da_maquina1() == POSICAO_SOLDA_ESTAGIO1) 
07C9C:  RCALL  7C1C
07C9E:  MOVF   01,W
07CA0:  SUBLW  03
07CA2:  BNZ   7CAC
.................... 				 { 
.................... 					farol = FAROL_VERMELHO;  
07CA4:  MOVLB  1
07CA6:  CLRF   x96
.................... 					//posiciona_cursor(3,1); 
.................... 	                //printf(lcd_putc,"ESPERANDO MAQUINA 1\n\r"); 
.................... 	                //printf(lcd_putc,"SAIR ESTAGIO1      "); 
.................... 					break; 
07CA8:  BRA    7D28
07CAA:  MOVLB  0
.................... 				 } 
....................  
.................... 				 farol = FAROL_VERDE;  
07CAC:  MOVLW  01
07CAE:  MOVLB  1
07CB0:  MOVWF  x96
....................  				 erro = 0; 
07CB2:  CLRF   x97
.................... 				 break; 
07CB4:  BRA    7D28
....................  
....................  
.................... 	case(2):     if(le_posicao_da_maquina1() == POSICAO_DISPENSADOR) 
07CB6:  RCALL  7C1C
07CB8:  MOVF   01,W
07CBA:  SUBLW  05
07CBC:  BNZ   7CC6
.................... 				 { 
.................... 					farol = FAROL_VERMELHO; 
07CBE:  MOVLB  1
07CC0:  CLRF   x96
.................... 					//posiciona_cursor(3,1); 
.................... 	                //printf(lcd_putc,"ESPERANDO MAQUINA 1\n\r"); 
.................... 	                //printf(lcd_putc,"SAIR DISPENSADOR   "); 
....................  
.................... 					break; 
07CC2:  BRA    7D28
07CC4:  MOVLB  0
....................  
.................... 				 } 
....................    					farol = FAROL_VERDE;  
07CC6:  MOVLW  01
07CC8:  MOVLB  1
07CCA:  MOVWF  x96
....................                     erro = 0; 
07CCC:  CLRF   x97
.................... 				    break; 
07CCE:  BRA    7D28
....................  
....................  
....................  
.................... 	case(3):     if(le_posicao_da_maquina1() == POSICAO_DISPENSADOR) 
07CD0:  RCALL  7C1C
07CD2:  MOVF   01,W
07CD4:  SUBLW  05
07CD6:  BNZ   7CE0
.................... 				 { 
.................... 					farol = FAROL_VERMELHO; 
07CD8:  MOVLB  1
07CDA:  CLRF   x96
.................... 					//posiciona_cursor(3,1); 
.................... 	                //printf(lcd_putc,"ESPERANDO MAQUINA 1\n\r"); 
.................... 	                //printf(lcd_putc,"SAIR DISPENSADOR   "); 
.................... 					break; 
07CDC:  BRA    7D28
07CDE:  MOVLB  0
....................  
.................... 				 } 
....................  
.................... 			 if(le_posicao_da_maquina1() == POSICAO_SOLDA_ESTAGIO1) 
07CE0:  RCALL  7C1C
07CE2:  MOVF   01,W
07CE4:  SUBLW  03
07CE6:  BNZ   7CF0
.................... 				 { 
.................... 					farol = FAROL_VERMELHO; 
07CE8:  MOVLB  1
07CEA:  CLRF   x96
.................... 					//posiciona_cursor(3,1); 
.................... 	                //printf(lcd_putc,"ESPERANDO MAQUINA 1\n\r"); 
.................... 	                //printf(lcd_putc,"SAIR ESTAGIO 1    "); 
....................  
.................... 					break; 
07CEC:  BRA    7D28
07CEE:  MOVLB  0
....................  
.................... 				 }	 
....................  
.................... 				 //if(le_Input(S_Y_ESQUERDA_PROT) == true) return erro = 1; 
....................                  farol = FAROL_VERDE;  
07CF0:  MOVLW  01
07CF2:  MOVLB  1
07CF4:  MOVWF  x96
....................                  erro = 0; 
07CF6:  CLRF   x97
.................... 				 break; 
07CF8:  BRA    7D28
....................  
.................... 	 
....................  
.................... 		case(4): if(le_posicao_da_maquina1() == POSICAO_ALIMENTADOR) 
07CFA:  RCALL  7C1C
07CFC:  MOVF   01,W
07CFE:  SUBLW  02
07D00:  BNZ   7D0A
.................... 				 { 
.................... 					farol = FAROL_VERMELHO; 
07D02:  MOVLB  1
07D04:  CLRF   x96
.................... 					//posiciona_cursor(3,1); 
.................... 	                //printf(lcd_putc,"ESPERANDO MAQUINA 1\n\r"); 
.................... 	                //printf(lcd_putc,"SAIR ALIMENTADOR   "); 
....................  
.................... 					break; 
07D06:  BRA    7D28
07D08:  MOVLB  0
....................  
.................... 				 } 
....................  
....................  
....................                  if(le_posicao_da_maquina1() == POSICAO_SOLDA_ESTAGIO1) 
07D0A:  RCALL  7C1C
07D0C:  MOVF   01,W
07D0E:  SUBLW  03
07D10:  BNZ   7D1A
.................... 				 { 
.................... 					farol = FAROL_VERMELHO; 
07D12:  MOVLB  1
07D14:  CLRF   x96
.................... 					//posiciona_cursor(3,1); 
.................... 	                //printf(lcd_putc,"ESPERANDO MAQUINA 1\n\r"); 
.................... 	                //printf(lcd_putc,"SAIR ESTAGIO 1    "); 
....................  
.................... 					break; 
07D16:  BRA    7D28
07D18:  MOVLB  0
....................  
.................... 				 } 
....................  
....................  
....................  
....................  
....................  
.................... 				//if(le_Input(S_Y_ESQUERDA_PROT) == true) return erro = 1; 
.................... 				farol = FAROL_VERDE;  
07D1A:  MOVLW  01
07D1C:  MOVLB  1
07D1E:  MOVWF  x96
....................                 erro = 0; 
07D20:  CLRF   x97
.................... 				 break; 
07D22:  BRA    7D28
07D24:  MOVLB  0
....................  
....................  
....................  
....................  
....................     default: 
.................... 				break; 
07D26:  MOVLB  1
....................  
....................  
....................  
....................  
....................    }       
07D28:  BRA    7C82
....................  
....................  
.................... } 
....................  
.................... 		return erro = 0; 
07D2A:  CLRF   x97
07D2C:  MOVFF  197,01
07D30:  MOVLB  0
07D32:  RETURN 0
....................  
.................... }  
....................  
....................  
.................... int dispensador_home(void) 
*
03028:  MOVLB  1
0302A:  CLRF   x97
0302C:  CLRF   x99
0302E:  CLRF   x98
03030:  MOVLW  0F
03032:  MOVWF  x9B
03034:  MOVLW  A0
03036:  MOVWF  x9A
03038:  CLRF   16
0303A:  BTFSC  FF2.7
0303C:  BSF    16.7
0303E:  BCF    FF2.7
.................... { 
....................     int erro = 0; 
....................     long int time_out = 0; 
....................     long int time_out_max = 4000; 
....................  
.................... 	desaciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
03040:  MOVLB  2
03042:  CLRF   x1B
03044:  CLRF   x1A
03046:  MOVLB  0
03048:  CALL   1B96
0304C:  BTFSC  16.7
0304E:  BSF    FF2.7
.................... 	aciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
03050:  MOVLB  1
03052:  CLRF   xA1
03054:  MOVLW  0F
03056:  MOVWF  xA0
03058:  MOVLB  0
0305A:  RCALL  2FD2
....................          
....................  	  
.................... 	while(le_Input(S_EMPURRADOR_OUT_LS2) == false) 
0305C:  MOVLW  13
0305E:  MOVLB  1
03060:  MOVWF  x9C
03062:  MOVLB  0
03064:  RCALL  2C54
03066:  MOVF   01,F
03068:  BNZ   3098
.................... 	{  
.................... 		 
.................... 	 delay_ms(1); 
0306A:  MOVLW  01
0306C:  MOVLB  2
0306E:  MOVWF  x17
03070:  MOVLB  0
03072:  CALL   1D50
....................      time_out++; 
03076:  MOVLB  1
03078:  INCF   x98,F
0307A:  BTFSC  FD8.2
0307C:  INCF   x99,F
....................      if(time_out >= time_out_max) return erro = 14; 
0307E:  MOVF   x9B,W
03080:  SUBWF  x99,W
03082:  BNC   3094
03084:  BNZ   308C
03086:  MOVF   x9A,W
03088:  SUBWF  x98,W
0308A:  BNC   3094
0308C:  MOVLW  0E
0308E:  MOVWF  x97
03090:  MOVWF  01
03092:  BRA    30B4
03094:  MOVLB  0
03096:  BRA    305C
03098:  CLRF   16
0309A:  BTFSC  FF2.7
0309C:  BSF    16.7
0309E:  BCF    FF2.7
....................  
....................  
.................... 	} 
....................  
.................... desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
030A0:  MOVLB  2
030A2:  CLRF   x1B
030A4:  MOVLW  0F
030A6:  MOVWF  x1A
030A8:  MOVLB  0
030AA:  CALL   1B96
030AE:  BTFSC  16.7
030B0:  BSF    FF2.7
030B2:  MOVLB  1
030B4:  MOVLB  0
030B6:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... int alimentador_home(void) 
030B8:  MOVLB  1
030BA:  CLRF   x97
030BC:  CLRF   x99
030BE:  CLRF   x98
030C0:  MOVLW  27
030C2:  MOVWF  x9B
030C4:  MOVLW  10
030C6:  MOVWF  x9A
030C8:  CLRF   16
030CA:  BTFSC  FF2.7
030CC:  BSF    16.7
030CE:  BCF    FF2.7
.................... { 
....................  	int erro = 0; 
....................     long int time_out = 0; 
....................     long int time_out_max = 10000; 
....................  
....................     desaciona_saida( EMPURRADOR_ENTRADA_SOL_EMPURRA); 
030D0:  MOVLB  2
030D2:  CLRF   x1B
030D4:  MOVLW  06
030D6:  MOVWF  x1A
030D8:  MOVLB  0
030DA:  CALL   1B96
030DE:  BTFSC  16.7
030E0:  BSF    FF2.7
....................     aciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
030E2:  MOVLB  1
030E4:  CLRF   xA1
030E6:  MOVLW  05
030E8:  MOVWF  xA0
030EA:  MOVLB  0
030EC:  RCALL  2FD2
....................  
....................     time_out = 0; 
030EE:  MOVLB  1
030F0:  CLRF   x99
030F2:  CLRF   x98
.................... 	while(le_Input(S_EMPURRADOR_IN_LS2) == false)   
030F4:  MOVLW  03
030F6:  MOVWF  x9C
030F8:  MOVLB  0
030FA:  RCALL  2C54
030FC:  MOVF   01,F
030FE:  BNZ   312E
....................     { 
....................  
.................... 	 delay_ms(1); 
03100:  MOVLW  01
03102:  MOVLB  2
03104:  MOVWF  x17
03106:  MOVLB  0
03108:  CALL   1D50
....................      time_out++; 
0310C:  MOVLB  1
0310E:  INCF   x98,F
03110:  BTFSC  FD8.2
03112:  INCF   x99,F
....................      if(time_out >= time_out_max) return erro = 27;	 
03114:  MOVF   x9B,W
03116:  SUBWF  x99,W
03118:  BNC   312A
0311A:  BNZ   3122
0311C:  MOVF   x9A,W
0311E:  SUBWF  x98,W
03120:  BNC   312A
03122:  MOVLW  1B
03124:  MOVWF  x97
03126:  MOVWF  01
03128:  BRA    314E
0312A:  BRA    30F4
0312C:  MOVLB  0
0312E:  CLRF   16
03130:  BTFSC  FF2.7
03132:  BSF    16.7
03134:  BCF    FF2.7
....................     } 
....................  
.................... 	desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
03136:  MOVLB  2
03138:  CLRF   x1B
0313A:  MOVLW  05
0313C:  MOVWF  x1A
0313E:  MOVLB  0
03140:  CALL   1B96
03144:  BTFSC  16.7
03146:  BSF    FF2.7
....................  
....................  
....................     return erro; 
03148:  MOVLB  1
0314A:  MOVFF  197,01
0314E:  MOVLB  0
03150:  RETURN 0
....................  
....................  
.................... } 
....................  
....................  
.................... int home_maquina_1(void) 
*
039DC:  MOVLB  1
039DE:  CLRF   x94
039E0:  CLRF   x96
039E2:  CLRF   x95
.................... { 
....................   int erro=0; 
....................   long int i = 0; 
....................  
....................    z_home();  
039E4:  MOVLB  0
039E6:  CALL   2EE0
....................    erro=dispensador_home();  //retirado somente p/ teste 
039EA:  CALL   3028
039EE:  MOVFF  01,194
....................    if(erro > 0) return erro; 
039F2:  MOVLB  1
039F4:  MOVF   x94,F
039F6:  BZ    39FE
039F8:  MOVFF  194,01
039FC:  BRA    3B18
....................    erro=alimentador_home(); 
039FE:  MOVLB  0
03A00:  CALL   30B8
03A04:  MOVFF  01,194
....................    if(erro > 0) return erro; 
03A08:  MOVLB  1
03A0A:  MOVF   x94,F
03A0C:  BZ    3A14
03A0E:  MOVFF  194,01
03A12:  BRA    3B18
....................  
....................    chopper_y(); 
03A14:  MOVLB  0
03A16:  CALL   3152
....................    frente(); 
03A1A:  CALL   3158
....................    delay_ms(50); 
03A1E:  MOVLW  32
03A20:  MOVLB  2
03A22:  MOVWF  x17
03A24:  MOVLB  0
03A26:  CALL   1D50
....................  
.................... 	    if(le_Input(S_Y_ATRAS) == true) 
03A2A:  MOVLW  08
03A2C:  MOVLB  1
03A2E:  MOVWF  x9C
03A30:  MOVLB  0
03A32:  CALL   2C54
03A36:  DECFSZ 01,W
03A38:  BRA    3A44
.................... 			{ 
.................... 				 
.................... 			   	y_home_atras(); 
03A3A:  CALL   31AE
.................... 				x_home_esquerda(); 
03A3E:  RCALL  331A
.................... 	            y_home_frente(); 
03A40:  RCALL  342A
.................... 	             
....................  
.................... 			}else{ 
03A42:  BRA    3A5E
....................  
.................... 					if(le_Input(S_Y_FRENTE) == true) 
03A44:  MOVLW  07
03A46:  MOVLB  1
03A48:  MOVWF  x9C
03A4A:  MOVLB  0
03A4C:  CALL   2C54
03A50:  DECFSZ 01,W
03A52:  BRA    3A5A
.................... 					{ 
....................  
.................... 						y_home_frente(); 
03A54:  RCALL  342A
.................... 						x_home_esquerda(); 
03A56:  RCALL  331A
....................  
.................... 					}else{ 
03A58:  BRA    3A5E
.................... 							x_home_esquerda(); 
03A5A:  RCALL  331A
.................... 							y_home_frente();  
03A5C:  RCALL  342A
.................... 							 
....................  
....................  
.................... 					     }	 	 
....................  
.................... 			    }	 
....................  
.................... 	while(le_posicao_da_maquina2() != POSICAO_HOME1) 
03A5E:  RCALL  363A
03A60:  MOVF   01,F
03A62:  BZ    3A8E
.................... 	{ 
....................  
.................... 			posiciona_cursor(3,1); 
03A64:  MOVLW  03
03A66:  MOVLB  1
03A68:  MOVWF  xA5
03A6A:  MOVLW  01
03A6C:  MOVWF  xA6
03A6E:  MOVLB  0
03A70:  CALL   1F92
....................     	    printf(lcd_putc,"ESPERANDO  MAQUINA2\n\r");// SOMENTE PARA TESTE 
03A74:  MOVLW  AE
03A76:  MOVWF  FF6
03A78:  MOVLW  14
03A7A:  MOVWF  FF7
03A7C:  CALL   25DA
.................... 			printf(lcd_putc,"IR PARA HOME1      ");	  	 
03A80:  MOVLW  C4
03A82:  MOVWF  FF6
03A84:  MOVLW  14
03A86:  MOVWF  FF7
03A88:  CALL   25DA
03A8C:  BRA    3A5E
....................   
....................     } 
....................  
.................... 	if(le_Input(S_Y_DIREITA_PROT) == false) return erro = 1; 
03A8E:  MOVLW  09
03A90:  MOVLB  1
03A92:  MOVWF  x9C
03A94:  MOVLB  0
03A96:  CALL   2C54
03A9A:  MOVF   01,F
03A9C:  BNZ   3AAA
03A9E:  MOVLW  01
03AA0:  MOVLB  1
03AA2:  MOVWF  x94
03AA4:  MOVWF  01
03AA6:  BRA    3B18
03AA8:  MOVLB  0
....................  
....................  
....................     //envia_posicao_para_maquina2(POSICAO_ALIMENTADOR); 
....................  
.................... 	x_home_direita(); 
03AAA:  RCALL  368E
.................... 	fliP_home();  
03AAC:  RCALL  37FC
....................      
....................     envia_posicao_para_maquina2(POSICAO_ALIMENTADOR); 
03AAE:  MOVLW  02
03AB0:  MOVLB  1
03AB2:  MOVWF  x9A
03AB4:  MOVLB  0
03AB6:  RCALL  39AC
....................  
....................  
....................     chopper_y(); 
03AB8:  CALL   3152
....................     frente(); 
03ABC:  CALL   3158
....................     delay_ms(50); 
03AC0:  MOVLW  32
03AC2:  MOVLB  2
03AC4:  MOVWF  x17
03AC6:  MOVLB  0
03AC8:  CALL   1D50
....................  
....................     
....................  
....................  
....................     for(i=0;i < 700;i++) 
03ACC:  MOVLB  1
03ACE:  CLRF   x96
03AD0:  CLRF   x95
03AD2:  MOVF   x96,W
03AD4:  SUBLW  02
03AD6:  BNC   3AFC
03AD8:  BNZ   3AE0
03ADA:  MOVF   x95,W
03ADC:  SUBLW  BB
03ADE:  BNC   3AFC
....................     { 
....................  		one_step_y(); 
03AE0:  MOVLB  0
03AE2:  CALL   3166
.................... 		delay_us(2000); 
03AE6:  MOVLW  02
03AE8:  MOVLB  2
03AEA:  MOVWF  x17
03AEC:  MOVLB  0
03AEE:  CALL   1D50
03AF2:  MOVLB  1
03AF4:  INCF   x95,F
03AF6:  BTFSC  FD8.2
03AF8:  INCF   x96,F
03AFA:  BRA    3AD2
.................... 	 
.................... 	} 
....................  
.................... 	chopper_x(); 
03AFC:  MOVLB  0
03AFE:  CALL   32BE
....................     esquerda(); 
03B02:  RCALL  3306
.................... 	delay_ms(50); 
03B04:  MOVLW  32
03B06:  MOVLB  2
03B08:  MOVWF  x17
03B0A:  MOVLB  0
03B0C:  CALL   1D50
....................  
....................  
....................  
....................  
....................  		return erro = 0; 
03B10:  MOVLB  1
03B12:  CLRF   x94
03B14:  MOVFF  194,01
03B18:  MOVLB  0
03B1A:  RETURN 0
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... int home_maquina_2(void) 
.................... { 
....................  
....................    z_home();  
*
08758:  CALL   2EE0
....................    erro=dispensador_home();  //retirado somente p/ teste 
0875C:  CALL   3028
08760:  MOVFF  01,184
....................    if(erro > 0) return erro; 
08764:  MOVLB  1
08766:  MOVF   x84,F
08768:  BZ    8770
0876A:  MOVFF  184,01
0876E:  BRA    8822
....................    erro=alimentador_home(); 
08770:  MOVLB  0
08772:  CALL   30B8
08776:  MOVFF  01,184
....................    if(erro > 0) return erro; 
0877A:  MOVLB  1
0877C:  MOVF   x84,F
0877E:  BZ    8786
08780:  MOVFF  184,01
08784:  BRA    8822
....................  
....................    chopper_y(); 
08786:  MOVLB  0
08788:  CALL   3152
....................    frente(); 
0878C:  CALL   3158
....................    delay_ms(50); 
08790:  MOVLW  32
08792:  MOVLB  2
08794:  MOVWF  x17
08796:  MOVLB  0
08798:  CALL   1D50
....................  
.................... 	    if(le_Input(S_Y_ATRAS) == true) 
0879C:  MOVLW  08
0879E:  MOVLB  1
087A0:  MOVWF  x9C
087A2:  MOVLB  0
087A4:  CALL   2C54
087A8:  DECFSZ 01,W
087AA:  BRA    87BA
.................... 			{ 
.................... 				 
.................... 			   	y_home_atras(); 
087AC:  CALL   31AE
.................... 				x_home_direita(); 
087B0:  CALL   368E
.................... 	            y_home_frente(); 
087B4:  CALL   342A
....................  
.................... 			}else{ 
087B8:  BRA    87DC
....................  
.................... 					if(le_Input(S_Y_FRENTE) == true) 
087BA:  MOVLW  07
087BC:  MOVLB  1
087BE:  MOVWF  x9C
087C0:  MOVLB  0
087C2:  CALL   2C54
087C6:  DECFSZ 01,W
087C8:  BRA    87D4
.................... 					{ 
....................  
.................... 						y_home_frente(); 
087CA:  CALL   342A
.................... 						x_home_direita(); 
087CE:  CALL   368E
....................  
.................... 					}else{ 
087D2:  BRA    87DC
.................... 							x_home_direita(); 
087D4:  CALL   368E
.................... 							y_home_frente(); 
087D8:  CALL   342A
....................  
.................... 					     }	 	 
....................  
.................... 			    }	 
....................  
.................... 		 
....................  
.................... 	    envia_posicao_para_maquina1(POSICAO_HOME1); 
087DC:  MOVLB  1
087DE:  CLRF   x9A
087E0:  MOVLB  0
087E2:  CALL   50A4
....................  
.................... 	while(le_posicao_da_maquina1() != POSICAO_ALIMENTADOR) 
087E6:  CALL   7C1C
087EA:  MOVF   01,W
087EC:  SUBLW  02
087EE:  BZ    881A
.................... 	{ 
....................  
.................... 			posiciona_cursor(3,1); 
087F0:  MOVLW  03
087F2:  MOVLB  1
087F4:  MOVWF  xA5
087F6:  MOVLW  01
087F8:  MOVWF  xA6
087FA:  MOVLB  0
087FC:  CALL   1F92
....................     	    printf(lcd_putc,"ESPERANDO  MAQUINA1\n\r");// SOMENTE PARA TESTE 
08800:  MOVLW  D8
08802:  MOVWF  FF6
08804:  MOVLW  14
08806:  MOVWF  FF7
08808:  CALL   25DA
.................... 			printf(lcd_putc,"IR PARA ALIMENTACAO");	  	 
0880C:  MOVLW  EE
0880E:  MOVWF  FF6
08810:  MOVLW  14
08812:  MOVWF  FF7
08814:  CALL   25DA
08818:  BRA    87E6
....................    
....................  
....................     } 
....................  
....................  		return erro = 0; 
0881A:  MOVLB  1
0881C:  CLRF   x84
0881E:  MOVFF  184,01
08822:  MOVLB  0
08824:  RETURN 0
....................  
.................... } 
....................  
.................... void erro_rot(int n_erro) 
.................... { 
.................... 	posiciona_cursor(1,1); 
*
03B1C:  MOVLW  01
03B1E:  MOVLB  1
03B20:  MOVWF  xA5
03B22:  MOVWF  xA6
03B24:  MOVLB  0
03B26:  CALL   1F92
.................... 	printf(lcd_putc,"\f"); 
03B2A:  MOVLW  0C
03B2C:  MOVLB  1
03B2E:  MOVWF  xA4
03B30:  MOVLB  0
03B32:  CALL   2586
....................     printf(lcd_putc,"       ERRO        \n\r"); 
03B36:  MOVLW  02
03B38:  MOVWF  FF6
03B3A:  MOVLW  15
03B3C:  MOVWF  FF7
03B3E:  CALL   25DA
....................  
....................   switch(n_erro){ 
03B42:  MOVLB  1
03B44:  MOVF   xA0,W
03B46:  XORLW  01
03B48:  MOVLB  0
03B4A:  BZ    3BE8
03B4C:  XORLW  03
03B4E:  BZ    3C0E
03B50:  XORLW  01
03B52:  BTFSC  FD8.2
03B54:  BRA    3C34
03B56:  XORLW  07
03B58:  BTFSC  FD8.2
03B5A:  BRA    3C5A
03B5C:  XORLW  01
03B5E:  BTFSC  FD8.2
03B60:  BRA    3C80
03B62:  XORLW  03
03B64:  BTFSC  FD8.2
03B66:  BRA    3CBC
03B68:  XORLW  01
03B6A:  BTFSC  FD8.2
03B6C:  BRA    3CF8
03B6E:  XORLW  0F
03B70:  BTFSC  FD8.2
03B72:  BRA    3D1E
03B74:  XORLW  01
03B76:  BTFSC  FD8.2
03B78:  BRA    3D44
03B7A:  XORLW  03
03B7C:  BTFSC  FD8.2
03B7E:  BRA    3D80
03B80:  XORLW  01
03B82:  BTFSC  FD8.2
03B84:  BRA    3D9A
03B86:  XORLW  07
03B88:  BTFSC  FD8.2
03B8A:  BRA    3DB4
03B8C:  XORLW  01
03B8E:  BTFSC  FD8.2
03B90:  BRA    3DCE
03B92:  XORLW  03
03B94:  BTFSC  FD8.2
03B96:  BRA    3DE8
03B98:  XORLW  01
03B9A:  BTFSC  FD8.2
03B9C:  BRA    3E02
03B9E:  XORLW  1F
03BA0:  BTFSC  FD8.2
03BA2:  BRA    3E1C
03BA4:  XORLW  01
03BA6:  BTFSC  FD8.2
03BA8:  BRA    3E36
03BAA:  XORLW  03
03BAC:  BTFSC  FD8.2
03BAE:  BRA    3E50
03BB0:  XORLW  01
03BB2:  BTFSC  FD8.2
03BB4:  BRA    3E6A
03BB6:  XORLW  07
03BB8:  BTFSC  FD8.2
03BBA:  BRA    3E84
03BBC:  XORLW  01
03BBE:  BTFSC  FD8.2
03BC0:  BRA    3E9E
03BC2:  XORLW  03
03BC4:  BTFSC  FD8.2
03BC6:  BRA    3EB8
03BC8:  XORLW  01
03BCA:  BTFSC  FD8.2
03BCC:  BRA    3ED2
03BCE:  XORLW  0F
03BD0:  BTFSC  FD8.2
03BD2:  BRA    3EEC
03BD4:  XORLW  01
03BD6:  BTFSC  FD8.2
03BD8:  BRA    3F06
03BDA:  XORLW  03
03BDC:  BTFSC  FD8.2
03BDE:  BRA    3F20
03BE0:  XORLW  01
03BE2:  BTFSC  FD8.2
03BE4:  BRA    3F3A
03BE6:  BRA    3F54
.................... 	 
.................... 	case 1:  
.................... 			 
.................... 	            printf(lcd_putc,"POSICAO ALIMENTACAO\n\r");   
03BE8:  MOVLW  18
03BEA:  MOVWF  FF6
03BEC:  MOVLW  15
03BEE:  MOVWF  FF7
03BF0:  CALL   25DA
....................                 printf(lcd_putc,"DIVERGENCIA POSICAO\n\r");    
03BF4:  MOVLW  2E
03BF6:  MOVWF  FF6
03BF8:  MOVLW  15
03BFA:  MOVWF  FF7
03BFC:  CALL   25DA
....................  				printf(lcd_putc,"  S_Y_DIREITA PROT \n\r"); 
03C00:  MOVLW  44
03C02:  MOVWF  FF6
03C04:  MOVLW  15
03C06:  MOVWF  FF7
03C08:  CALL   25DA
.................... 			    break; 
03C0C:  BRA    3F54
....................     
.................... 	case 2:     
.................... 				 
.................... 	            printf(lcd_putc,"MOV. POSICAO SOLDAR\n\r");   
03C0E:  MOVLW  5A
03C10:  MOVWF  FF6
03C12:  MOVLW  15
03C14:  MOVWF  FF7
03C16:  CALL   25DA
....................                 printf(lcd_putc,"DIVERGENCIA POSICAO\n\r");    
03C1A:  MOVLW  70
03C1C:  MOVWF  FF6
03C1E:  MOVLW  15
03C20:  MOVWF  FF7
03C22:  CALL   25DA
....................  				printf(lcd_putc,"    S_Y_FRENTE     \n\r"); 
03C26:  MOVLW  86
03C28:  MOVWF  FF6
03C2A:  MOVLW  15
03C2C:  MOVWF  FF7
03C2E:  CALL   25DA
....................     			break; 
03C32:  BRA    3F54
....................  
.................... 	case 3:     
.................... 				 
.................... 	            printf(lcd_putc,"POSICAO SOLDAR     \n\r");   
03C34:  MOVLW  9C
03C36:  MOVWF  FF6
03C38:  MOVLW  15
03C3A:  MOVWF  FF7
03C3C:  CALL   25DA
....................                 printf(lcd_putc,"COORDENADA FORA DA \n\r");    
03C40:  MOVLW  B2
03C42:  MOVWF  FF6
03C44:  MOVLW  15
03C46:  MOVWF  FF7
03C48:  CALL   25DA
....................  				printf(lcd_putc,"POSICAO ESTAGIO 2  \n\r"); 
03C4C:  MOVLW  C8
03C4E:  MOVWF  FF6
03C50:  MOVLW  15
03C52:  MOVWF  FF7
03C54:  CALL   25DA
....................     			break; 
03C58:  BRA    3F54
....................  
....................  
....................     case 4:      
.................... 	            printf(lcd_putc,"POSICAO HOME2      \n\r");   
03C5A:  MOVLW  DE
03C5C:  MOVWF  FF6
03C5E:  MOVLW  15
03C60:  MOVWF  FF7
03C62:  CALL   25DA
....................                 printf(lcd_putc,"DIVERGENCIA POSICAO\n\r");    
03C66:  MOVLW  F4
03C68:  MOVWF  FF6
03C6A:  MOVLW  15
03C6C:  MOVWF  FF7
03C6E:  CALL   25DA
....................  				printf(lcd_putc,"    S_Y_ATRAS      \n\r"); 
03C72:  MOVLW  0A
03C74:  MOVWF  FF6
03C76:  MOVLW  16
03C78:  MOVWF  FF7
03C7A:  CALL   25DA
....................     			break; 
03C7E:  BRA    3F54
....................  
.................... 		 
....................  
....................     case 5:      
.................... 	            printf(lcd_putc,"POSICAO HOME2      \n\r");   
03C80:  MOVLW  20
03C82:  MOVWF  FF6
03C84:  MOVLW  16
03C86:  MOVWF  FF7
03C88:  CALL   25DA
....................                 printf(lcd_putc,"DIVERGENCIA POSICAO\n\r");    
03C8C:  MOVLW  36
03C8E:  MOVWF  FF6
03C90:  MOVLW  16
03C92:  MOVWF  FF7
03C94:  CALL   25DA
.................... 				if(n_maquina == 1) 
03C98:  DECFSZ 1D,W
03C9A:  BRA    3CA8
....................                 {	 
....................  
....................  				printf(lcd_putc,"   S_X_ESQUERDA     \n\r"); 
03C9C:  MOVLW  4C
03C9E:  MOVWF  FF6
03CA0:  MOVLW  16
03CA2:  MOVWF  FF7
03CA4:  CALL   25DA
....................  
.................... 				} 
....................  
.................... 				if(n_maquina == 2) 
03CA8:  MOVF   1D,W
03CAA:  SUBLW  02
03CAC:  BNZ   3CBA
....................                 {	 
....................  
....................  				printf(lcd_putc,"   S_X_DIREITA     \n\r"); 
03CAE:  MOVLW  64
03CB0:  MOVWF  FF6
03CB2:  MOVLW  16
03CB4:  MOVWF  FF7
03CB6:  CALL   25DA
....................  
.................... 				} 
....................  
....................  
.................... 			    break; 
03CBA:  BRA    3F54
....................  
....................   	case 6:     printf(lcd_putc,"POSICAO DISPENSADOR\n\r");   
03CBC:  MOVLW  7A
03CBE:  MOVWF  FF6
03CC0:  MOVLW  16
03CC2:  MOVWF  FF7
03CC4:  CALL   25DA
....................                 printf(lcd_putc,"DIVERGENCIA POSICAO\n\r"); 
03CC8:  MOVLW  90
03CCA:  MOVWF  FF6
03CCC:  MOVLW  16
03CCE:  MOVWF  FF7
03CD0:  CALL   25DA
....................                 if(n_maquina == 1) 
03CD4:  DECFSZ 1D,W
03CD6:  BRA    3CE4
....................                 { 
....................     
....................      				printf(lcd_putc,"   S_X_DIREITA     \n\r"); 
03CD8:  MOVLW  A6
03CDA:  MOVWF  FF6
03CDC:  MOVLW  16
03CDE:  MOVWF  FF7
03CE0:  CALL   25DA
....................  
.................... 				} 
.................... 				if(n_maquina == 2) 
03CE4:  MOVF   1D,W
03CE6:  SUBLW  02
03CE8:  BNZ   3CF6
.................... 				{ 
....................  
....................  
.................... 					printf(lcd_putc,"   S_X_ESQUERDA    \n\r"); 
03CEA:  MOVLW  BC
03CEC:  MOVWF  FF6
03CEE:  MOVLW  16
03CF0:  MOVWF  FF7
03CF2:  CALL   25DA
....................  
.................... 				} 
.................... 				 
....................  
....................      			break; 
03CF6:  BRA    3F54
....................  
....................     case 7:     printf(lcd_putc,"POSICAO HOME 3     \n\r");   
03CF8:  MOVLW  D2
03CFA:  MOVWF  FF6
03CFC:  MOVLW  16
03CFE:  MOVWF  FF7
03D00:  CALL   25DA
....................                 printf(lcd_putc,"DIVERGENCIA POSICAO\n\r"); 
03D04:  MOVLW  E8
03D06:  MOVWF  FF6
03D08:  MOVLW  16
03D0A:  MOVWF  FF7
03D0C:  CALL   25DA
....................                 printf(lcd_putc,"  S_Y_ATRAS        \n\r"); 
03D10:  MOVLW  FE
03D12:  MOVWF  FF6
03D14:  MOVLW  16
03D16:  MOVWF  FF7
03D18:  CALL   25DA
....................     		    break; 
03D1C:  BRA    3F54
....................  
....................  
....................     case 8:     printf(lcd_putc,"POSICAO HOME 1     \n\r");   
03D1E:  MOVLW  14
03D20:  MOVWF  FF6
03D22:  MOVLW  17
03D24:  MOVWF  FF7
03D26:  CALL   25DA
....................                 printf(lcd_putc,"DIVERGENCIA POSICAO\n\r"); 
03D2A:  MOVLW  2A
03D2C:  MOVWF  FF6
03D2E:  MOVLW  17
03D30:  MOVWF  FF7
03D32:  CALL   25DA
....................                 printf(lcd_putc,"  S_Y_FRENTE       \n\r"); 
03D36:  MOVLW  40
03D38:  MOVWF  FF6
03D3A:  MOVLW  17
03D3C:  MOVWF  FF7
03D3E:  CALL   25DA
....................     		    break; 
03D42:  BRA    3F54
....................  
....................     case 9:     printf(lcd_putc,"POSICAO HOME 1     \n\r");   
03D44:  MOVLW  56
03D46:  MOVWF  FF6
03D48:  MOVLW  17
03D4A:  MOVWF  FF7
03D4C:  CALL   25DA
....................                 printf(lcd_putc,"DIVERGENCIA POSICAO\n\r"); 
03D50:  MOVLW  6C
03D52:  MOVWF  FF6
03D54:  MOVLW  17
03D56:  MOVWF  FF7
03D58:  CALL   25DA
....................  
.................... 				if(n_maquina == 1) 
03D5C:  DECFSZ 1D,W
03D5E:  BRA    3D6C
.................... 				{ 
....................  
....................                   printf(lcd_putc,"  S_X_ESQUERDA     \n\r"); 
03D60:  MOVLW  82
03D62:  MOVWF  FF6
03D64:  MOVLW  17
03D66:  MOVWF  FF7
03D68:  CALL   25DA
....................  
.................... 				} 
....................  
.................... 				if(n_maquina == 2) 
03D6C:  MOVF   1D,W
03D6E:  SUBLW  02
03D70:  BNZ   3D7E
.................... 				{ 
....................  
....................                   printf(lcd_putc,"  S_X_DIREITA      \n\r"); 
03D72:  MOVLW  98
03D74:  MOVWF  FF6
03D76:  MOVLW  17
03D78:  MOVWF  FF7
03D7A:  CALL   25DA
....................  
.................... 				} 
....................  
....................     		    break; 
03D7E:  BRA    3F54
....................  
....................  
....................     case 10:    printf(lcd_putc,"LEITURA DE POSICAO \n\r");   
03D80:  MOVLW  AE
03D82:  MOVWF  FF6
03D84:  MOVLW  17
03D86:  MOVWF  FF7
03D88:  CALL   25DA
....................                 printf(lcd_putc,"INCOERENTE         \n\r"); 
03D8C:  MOVLW  C4
03D8E:  MOVWF  FF6
03D90:  MOVLW  17
03D92:  MOVWF  FF7
03D94:  CALL   25DA
....................  
.................... 			    break; 
03D98:  BRA    3F54
....................  
....................     case 11:    printf(lcd_putc,"POSICAO PROIBIDA   \n\r");   
03D9A:  MOVLW  DA
03D9C:  MOVWF  FF6
03D9E:  MOVLW  17
03DA0:  MOVWF  FF7
03DA2:  CALL   25DA
....................                 printf(lcd_putc,"PARA GIRAR BANDEJA \n\r"); 
03DA6:  MOVLW  F0
03DA8:  MOVWF  FF6
03DAA:  MOVLW  17
03DAC:  MOVWF  FF7
03DAE:  CALL   25DA
....................  
.................... 			    break; 
03DB2:  BRA    3F54
....................  
....................     case 12:    printf(lcd_putc,"   TIME OUT        \n\r");   
03DB4:  MOVLW  06
03DB6:  MOVWF  FF6
03DB8:  MOVLW  18
03DBA:  MOVWF  FF7
03DBC:  CALL   25DA
....................                 printf(lcd_putc," S_DEDO_IN_LS1     \n\r"); 
03DC0:  MOVLW  1C
03DC2:  MOVWF  FF6
03DC4:  MOVLW  18
03DC6:  MOVWF  FF7
03DC8:  CALL   25DA
....................  
.................... 			    break; 
03DCC:  BRA    3F54
....................  
....................  
....................     case 13:    printf(lcd_putc,"   TIME OUT        \n\r");   
03DCE:  MOVLW  32
03DD0:  MOVWF  FF6
03DD2:  MOVLW  18
03DD4:  MOVWF  FF7
03DD6:  CALL   25DA
....................                 printf(lcd_putc," S_DEDO_IN_LS2     \n\r"); 
03DDA:  MOVLW  48
03DDC:  MOVWF  FF6
03DDE:  MOVLW  18
03DE0:  MOVWF  FF7
03DE2:  CALL   25DA
....................  
.................... 			    break; 
03DE6:  BRA    3F54
....................  
.................... 	case 14:    printf(lcd_putc,"   TIME OUT        \n\r");   
03DE8:  MOVLW  5E
03DEA:  MOVWF  FF6
03DEC:  MOVLW  18
03DEE:  MOVWF  FF7
03DF0:  CALL   25DA
....................                 printf(lcd_putc,"S_EMPURRADOR_IN_LS2\n\r");; 
03DF4:  MOVLW  74
03DF6:  MOVWF  FF6
03DF8:  MOVLW  18
03DFA:  MOVWF  FF7
03DFC:  CALL   25DA
....................  
.................... 			    break; 
03E00:  BRA    3F54
....................  
....................     case 15:    printf(lcd_putc,"   TIME OUT        \n\r");   
03E02:  MOVLW  8A
03E04:  MOVWF  FF6
03E06:  MOVLW  18
03E08:  MOVWF  FF7
03E0A:  CALL   25DA
....................                 printf(lcd_putc," S_DEDO_OUT_LS1    \n\r"); 
03E0E:  MOVLW  A0
03E10:  MOVWF  FF6
03E12:  MOVLW  18
03E14:  MOVWF  FF7
03E16:  CALL   25DA
....................  
.................... 			    break; 
03E1A:  BRA    3F54
....................  
.................... 	case 16:    printf(lcd_putc,"   TIME OUT        \n\r");   
03E1C:  MOVLW  B6
03E1E:  MOVWF  FF6
03E20:  MOVLW  18
03E22:  MOVWF  FF7
03E24:  CALL   25DA
....................                 printf(lcd_putc,"S_DEDO_OUT_LS2     \n\r");; 
03E28:  MOVLW  CC
03E2A:  MOVWF  FF6
03E2C:  MOVLW  18
03E2E:  MOVWF  FF7
03E30:  CALL   25DA
....................  
.................... 			    break; 
03E34:  BRA    3F54
....................  
....................  
.................... 	case 17:    printf(lcd_putc,"   TIME OUT        \n\r");   
03E36:  MOVLW  E2
03E38:  MOVWF  FF6
03E3A:  MOVLW  18
03E3C:  MOVWF  FF7
03E3E:  CALL   25DA
....................                 printf(lcd_putc,"S_PRESSOR_LS2      \n\r");; 
03E42:  MOVLW  F8
03E44:  MOVWF  FF6
03E46:  MOVLW  18
03E48:  MOVWF  FF7
03E4A:  CALL   25DA
....................  
.................... 			    break; 
03E4E:  BRA    3F54
....................  
....................  
.................... 	case 18:    printf(lcd_putc,"   TIME OUT        \n\r");   
03E50:  MOVLW  0E
03E52:  MOVWF  FF6
03E54:  MOVLW  19
03E56:  MOVWF  FF7
03E58:  CALL   25DA
....................                 printf(lcd_putc,"S_EMPURRADOR_IN_LS1\n\r");; 
03E5C:  MOVLW  24
03E5E:  MOVWF  FF6
03E60:  MOVLW  19
03E62:  MOVWF  FF7
03E64:  CALL   25DA
....................  
.................... 			    break; 
03E68:  BRA    3F54
....................  
....................  
.................... 	case 19:    printf(lcd_putc,"   TIME OUT        \n\r");   
03E6A:  MOVLW  3A
03E6C:  MOVWF  FF6
03E6E:  MOVLW  19
03E70:  MOVWF  FF7
03E72:  CALL   25DA
....................                 printf(lcd_putc,"S_EMPURRADOR_IN_LS2\n\r");; 
03E76:  MOVLW  50
03E78:  MOVWF  FF6
03E7A:  MOVLW  19
03E7C:  MOVWF  FF7
03E7E:  CALL   25DA
....................  
.................... 			    break; 
03E82:  BRA    3F54
....................  
.................... 	case 20:    printf(lcd_putc,"   OUT OF RANGE X   \n\r");   
03E84:  MOVLW  66
03E86:  MOVWF  FF6
03E88:  MOVLW  19
03E8A:  MOVWF  FF7
03E8C:  CALL   25DA
....................                 printf(lcd_putc,"        MAX         \n\r");; 
03E90:  MOVLW  7E
03E92:  MOVWF  FF6
03E94:  MOVLW  19
03E96:  MOVWF  FF7
03E98:  CALL   25DA
....................  
.................... 			    break; 
03E9C:  BRA    3F54
....................  
.................... 	case 21:    printf(lcd_putc,"   OUT OF RANGE Y   \n\r");   
03E9E:  MOVLW  96
03EA0:  MOVWF  FF6
03EA2:  MOVLW  19
03EA4:  MOVWF  FF7
03EA6:  CALL   25DA
....................                 printf(lcd_putc,"        MAX         \n\r");; 
03EAA:  MOVLW  AE
03EAC:  MOVWF  FF6
03EAE:  MOVLW  19
03EB0:  MOVWF  FF7
03EB2:  CALL   25DA
....................  
.................... 			    break; 
03EB6:  BRA    3F54
....................  
.................... 	case 22:    printf(lcd_putc,"   OUT OF RANGE Z   \n\r");   
03EB8:  MOVLW  C6
03EBA:  MOVWF  FF6
03EBC:  MOVLW  19
03EBE:  MOVWF  FF7
03EC0:  CALL   25DA
....................                 printf(lcd_putc,"        MAX         \n\r");; 
03EC4:  MOVLW  DE
03EC6:  MOVWF  FF6
03EC8:  MOVLW  19
03ECA:  MOVWF  FF7
03ECC:  CALL   25DA
....................  
.................... 			    break; 
03ED0:  BRA    3F54
....................  
.................... 	case 23:    printf(lcd_putc,"   OUT OF RANGE X   \n\r");   
03ED2:  MOVLW  F6
03ED4:  MOVWF  FF6
03ED6:  MOVLW  19
03ED8:  MOVWF  FF7
03EDA:  CALL   25DA
....................                 printf(lcd_putc,"        MIN         \n\r");; 
03EDE:  MOVLW  0E
03EE0:  MOVWF  FF6
03EE2:  MOVLW  1A
03EE4:  MOVWF  FF7
03EE6:  CALL   25DA
....................  
.................... 			    break; 
03EEA:  BRA    3F54
....................  
.................... 	case 24:    printf(lcd_putc,"   OUT OF RANGE Y   \n\r");   
03EEC:  MOVLW  26
03EEE:  MOVWF  FF6
03EF0:  MOVLW  1A
03EF2:  MOVWF  FF7
03EF4:  CALL   25DA
....................                 printf(lcd_putc,"        MIN         \n\r");; 
03EF8:  MOVLW  3E
03EFA:  MOVWF  FF6
03EFC:  MOVLW  1A
03EFE:  MOVWF  FF7
03F00:  CALL   25DA
....................  
.................... 			    break; 
03F04:  BRA    3F54
....................  
.................... 	case 25:    printf(lcd_putc,"   OUT OF RANGE Z   \n\r");   
03F06:  MOVLW  56
03F08:  MOVWF  FF6
03F0A:  MOVLW  1A
03F0C:  MOVWF  FF7
03F0E:  CALL   25DA
....................                 printf(lcd_putc,"        MIN         \n\r");; 
03F12:  MOVLW  6E
03F14:  MOVWF  FF6
03F16:  MOVLW  1A
03F18:  MOVWF  FF7
03F1A:  CALL   25DA
....................  
.................... 			    break; 
03F1E:  BRA    3F54
....................  
.................... 	case 26:    printf(lcd_putc,"   TIME_OUT        \n\r");   
03F20:  MOVLW  86
03F22:  MOVWF  FF6
03F24:  MOVLW  1A
03F26:  MOVWF  FF7
03F28:  CALL   25DA
....................                 printf(lcd_putc,"   S. BANDEJA      \n\r");; 
03F2C:  MOVLW  9C
03F2E:  MOVWF  FF6
03F30:  MOVLW  1A
03F32:  MOVWF  FF7
03F34:  CALL   25DA
....................  
.................... 			    break; 
03F38:  BRA    3F54
....................  
....................  	case 27:    printf(lcd_putc,"   TIME_OUT        \n\r");   
03F3A:  MOVLW  B2
03F3C:  MOVWF  FF6
03F3E:  MOVLW  1A
03F40:  MOVWF  FF7
03F42:  CALL   25DA
....................                 printf(lcd_putc," S_EMPURRADOR_RECUO \n\r");; 
03F46:  MOVLW  C8
03F48:  MOVWF  FF6
03F4A:  MOVLW  1A
03F4C:  MOVWF  FF7
03F4E:  CALL   25DA
....................  
.................... 			    break; 
03F52:  BRA    3F54
....................  
....................  
....................  
....................     default:    
.................... 				 
.................... 				break; 
....................  
.................... 	} 
....................  
.................... 	while(1){} 
03F54:  BRA    3F54
03F56:  RETURN 0
....................  
.................... } 
....................  
.................... void coloca_maquina_em_home_1(int n_maquina) 
.................... { 
....................  
.................... 	if(n_maquina == MAQUINA1) 
*
0AB14:  MOVLB  1
0AB16:  DECFSZ x8B,W
0AB18:  BRA    AC6E
0AB1A:  CLRF   16
0AB1C:  BTFSC  FF2.7
0AB1E:  BSF    16.7
0AB20:  BCF    FF2.7
....................  
.................... 	{   desaciona_saida(RELE_ESTEIRA); 
0AB22:  MOVLB  2
0AB24:  CLRF   x1B
0AB26:  MOVLW  0A
0AB28:  MOVWF  x1A
0AB2A:  MOVLB  0
0AB2C:  CALL   1B96
0AB30:  BTFSC  16.7
0AB32:  BSF    FF2.7
.................... 	 	go_x_y_flip(0,900,1867,velocity_x,velocity_y,velocity_flip,4000,4000,4000,200,200,200,true,true,true);//retiradp para teste 
0AB34:  MOVLB  1
0AB36:  CLRF   x98
0AB38:  CLRF   x97
0AB3A:  MOVLW  03
0AB3C:  MOVWF  x9A
0AB3E:  MOVLW  84
0AB40:  MOVWF  x99
0AB42:  MOVLW  07
0AB44:  MOVWF  x9C
0AB46:  MOVLW  4B
0AB48:  MOVWF  x9B
0AB4A:  MOVLW  01
0AB4C:  MOVWF  x9E
0AB4E:  MOVLW  2C
0AB50:  MOVWF  x9D
0AB52:  MOVLW  01
0AB54:  MOVWF  xA0
0AB56:  MOVLW  2C
0AB58:  MOVWF  x9F
0AB5A:  MOVLW  03
0AB5C:  MOVWF  xA2
0AB5E:  MOVLW  E8
0AB60:  MOVWF  xA1
0AB62:  MOVLW  0F
0AB64:  MOVWF  xA4
0AB66:  MOVLW  A0
0AB68:  MOVWF  xA3
0AB6A:  MOVLW  0F
0AB6C:  MOVWF  xA6
0AB6E:  MOVLW  A0
0AB70:  MOVWF  xA5
0AB72:  MOVLW  0F
0AB74:  MOVWF  xA8
0AB76:  MOVLW  A0
0AB78:  MOVWF  xA7
0AB7A:  MOVLW  C8
0AB7C:  MOVWF  xA9
0AB7E:  MOVWF  xAA
0AB80:  MOVWF  xAB
0AB82:  MOVLW  01
0AB84:  MOVWF  xAC
0AB86:  MOVWF  xAD
0AB88:  MOVWF  xAE
0AB8A:  MOVLB  0
0AB8C:  CALL   4AEE
....................         if(le_Input(S_Y_FRENTE) == true)     erro_rot(2);   
0AB90:  MOVLW  07
0AB92:  MOVLB  1
0AB94:  MOVWF  x9C
0AB96:  MOVLB  0
0AB98:  CALL   2C54
0AB9C:  DECFSZ 01,W
0AB9E:  BRA    ABAC
0ABA0:  MOVLW  02
0ABA2:  MOVLB  1
0ABA4:  MOVWF  xA0
0ABA6:  MOVLB  0
0ABA8:  CALL   3B1C
.................... 	    go_x_y(4290,740,velocity_x,velocity_y,2000,2000,200,200,true,true,false,false); 
0ABAC:  MOVLW  10
0ABAE:  MOVLB  1
0ABB0:  MOVWF  x9D
0ABB2:  MOVLW  C2
0ABB4:  MOVWF  x9C
0ABB6:  MOVLW  02
0ABB8:  MOVWF  x9F
0ABBA:  MOVLW  E4
0ABBC:  MOVWF  x9E
0ABBE:  MOVLW  01
0ABC0:  MOVWF  xA1
0ABC2:  MOVLW  2C
0ABC4:  MOVWF  xA0
0ABC6:  MOVLW  01
0ABC8:  MOVWF  xA3
0ABCA:  MOVLW  2C
0ABCC:  MOVWF  xA2
0ABCE:  MOVLW  07
0ABD0:  MOVWF  xA5
0ABD2:  MOVLW  D0
0ABD4:  MOVWF  xA4
0ABD6:  MOVLW  07
0ABD8:  MOVWF  xA7
0ABDA:  MOVLW  D0
0ABDC:  MOVWF  xA6
0ABDE:  MOVLW  C8
0ABE0:  MOVWF  xA8
0ABE2:  MOVWF  xA9
0ABE4:  MOVLW  01
0ABE6:  MOVWF  xAA
0ABE8:  MOVWF  xAB
0ABEA:  CLRF   xAC
0ABEC:  CLRF   xAD
0ABEE:  MOVLB  0
0ABF0:  CALL   42F6
....................         delay_ms(100); 
0ABF4:  MOVLW  64
0ABF6:  MOVLB  2
0ABF8:  MOVWF  x17
0ABFA:  MOVLB  0
0ABFC:  CALL   1D50
....................        	if(le_Input(S_Y_FRENTE)   != true)    erro_rot(8); 
0AC00:  MOVLW  07
0AC02:  MOVLB  1
0AC04:  MOVWF  x9C
0AC06:  MOVLB  0
0AC08:  CALL   2C54
0AC0C:  DECFSZ 01,W
0AC0E:  BRA    AC12
0AC10:  BRA    AC1E
0AC12:  MOVLW  08
0AC14:  MOVLB  1
0AC16:  MOVWF  xA0
0AC18:  MOVLB  0
0AC1A:  CALL   3B1C
....................         if(le_Input(S_X_ESQUERDA) != true)    erro_rot(9); 
0AC1E:  MOVLW  06
0AC20:  MOVLB  1
0AC22:  MOVWF  x9C
0AC24:  MOVLB  0
0AC26:  CALL   2C54
0AC2A:  DECFSZ 01,W
0AC2C:  BRA    AC30
0AC2E:  BRA    AC3C
0AC30:  MOVLW  09
0AC32:  MOVLB  1
0AC34:  MOVWF  xA0
0AC36:  MOVLB  0
0AC38:  CALL   3B1C
....................      	envia_posicao_para_maquina2(POSICAO_HOME1); 
0AC3C:  MOVLB  1
0AC3E:  CLRF   x9A
0AC40:  MOVLB  0
0AC42:  CALL   39AC
....................         delay_ms(500); 
0AC46:  MOVLW  02
0AC48:  MOVLB  1
0AC4A:  MOVWF  x8C
0AC4C:  MOVLW  FA
0AC4E:  MOVLB  2
0AC50:  MOVWF  x17
0AC52:  MOVLB  0
0AC54:  CALL   1D50
0AC58:  MOVLB  1
0AC5A:  DECFSZ x8C,F
0AC5C:  BRA    AC4C
.................... 	    while(le_posicao_da_maquina2() != POSICAO_HOME1){} 
0AC5E:  MOVLB  0
0AC60:  CALL   363A
0AC64:  MOVF   01,F
0AC66:  BTFSS  FD8.2
0AC68:  BRA    AC60
....................         reset_cpu(); 
0AC6A:  RESET
0AC6C:  MOVLB  1
.................... 	} 
....................  
.................... 	if(n_maquina == MAQUINA2) 
0AC6E:  MOVF   x8B,W
0AC70:  SUBLW  02
0AC72:  BNZ   AC9E
0AC74:  CLRF   16
0AC76:  BTFSC  FF2.7
0AC78:  BSF    16.7
0AC7A:  BCF    FF2.7
....................     { 
.................... 		desaciona_saida(RELE_ESTEIRA); 
0AC7C:  MOVLB  2
0AC7E:  CLRF   x1B
0AC80:  MOVLW  0A
0AC82:  MOVWF  x1A
0AC84:  MOVLB  0
0AC86:  CALL   1B96
0AC8A:  BTFSC  16.7
0AC8C:  BSF    FF2.7
.................... 		home_maquina_2(); 
0AC8E:  CALL   8758
.................... 	    envia_posicao_para_maquina1(POSICAO_HOME1); 
0AC92:  MOVLB  1
0AC94:  CLRF   x9A
0AC96:  MOVLB  0
0AC98:  CALL   50A4
0AC9C:  MOVLB  1
.................... 	     
....................  
.................... 	} 
0AC9E:  MOVLB  0
0ACA0:  RETURN 0
....................  
.................... 	 
....................  
.................... 		 
.................... } 
....................  
....................  
.................... void LIGA_ESTEIRA(void) 
.................... { 
....................   if(input(in25_bit) == 0)  
*
077A2:  BSF    F93.1
077A4:  BTFSC  F81.1
077A6:  BRA    77AC
....................   {     
.................... 		TEM_PLACA = TRUE; 
077A8:  BSF    1E.1
.................... 		return; 
077AA:  BRA    77C4
.................... 		 
....................   } 
....................   TEM_PLACA = FALSE; 
077AC:  BCF    1E.1
....................   ext_int_edge(1,H_TO_L); 
077AE:  BCF    FF1.5
....................   enable_interrupts(INT_EXT1);  
077B0:  BSF    FF0.3
....................   enable_interrupts(GLOBAL); 
077B2:  MOVLW  C0
077B4:  IORWF  FF2,F
....................   aciona_saida(RELE_ESTEIRA); 
077B6:  MOVLB  1
077B8:  CLRF   xA1
077BA:  MOVLW  0A
077BC:  MOVWF  xA0
077BE:  MOVLB  0
077C0:  CALL   2FD2
077C4:  RETURN 0
....................  
.................... } 
....................  
.................... void maquina_estados1(int modo)  
.................... { 
....................  
....................  erro = 0; 
*
07A48:  MOVLB  1
07A4A:  CLRF   x84
....................  
.................... 	for(step = 0;step <= 20;step++) 
07A4C:  CLRF   x82
07A4E:  MOVF   x82,W
07A50:  SUBLW  14
07A52:  BTFSS  FD8.0
07A54:  BRA    7C18
.................... 	{ 
.................... 		if(erro > 0) erro_rot(erro); 
07A56:  MOVF   x84,F
07A58:  BZ    7A66
07A5A:  MOVFF  184,1A0
07A5E:  MOVLB  0
07A60:  CALL   3B1C
07A64:  MOVLB  1
....................         if(modo ==  MODO_EDITA_PONTOS)  
07A66:  DECFSZ x94,W
07A68:  BRA    7A72
....................         { 
.................... 			if(step == 5) return; 
07A6A:  MOVF   x82,W
07A6C:  SUBLW  05
07A6E:  BTFSC  FD8.2
07A70:  BRA    7C18
....................  
....................  
.................... 		} 
....................  
.................... 		switch(step){ 
07A72:  MOVF   x82,W
07A74:  XORLW  00
07A76:  MOVLB  0
07A78:  BZ    7AE4
07A7A:  XORLW  01
07A7C:  BZ    7AEE
07A7E:  XORLW  03
07A80:  BZ    7AF8
07A82:  XORLW  01
07A84:  BZ    7B20
07A86:  XORLW  07
07A88:  BZ    7B22
07A8A:  XORLW  01
07A8C:  BZ    7B42
07A8E:  XORLW  03
07A90:  BZ    7B44
07A92:  XORLW  01
07A94:  BZ    7B56
07A96:  XORLW  0F
07A98:  BZ    7B68
07A9A:  XORLW  01
07A9C:  BTFSC  FD8.2
07A9E:  BRA    7B7A
07AA0:  XORLW  03
07AA2:  BTFSC  FD8.2
07AA4:  BRA    7B8C
07AA6:  XORLW  01
07AA8:  BTFSC  FD8.2
07AAA:  BRA    7B96
07AAC:  XORLW  07
07AAE:  BTFSC  FD8.2
07AB0:  BRA    7BA0
07AB2:  XORLW  01
07AB4:  BTFSC  FD8.2
07AB6:  BRA    7BAA
07AB8:  XORLW  03
07ABA:  BTFSC  FD8.2
07ABC:  BRA    7BB4
07ABE:  XORLW  01
07AC0:  BTFSC  FD8.2
07AC2:  BRA    7BC8
07AC4:  XORLW  1F
07AC6:  BTFSC  FD8.2
07AC8:  BRA    7BDA
07ACA:  XORLW  01
07ACC:  BTFSC  FD8.2
07ACE:  BRA    7BEA
07AD0:  XORLW  03
07AD2:  BTFSC  FD8.2
07AD4:  BRA    7BEE
07AD6:  XORLW  01
07AD8:  BTFSC  FD8.2
07ADA:  BRA    7BF0
07ADC:  XORLW  07
07ADE:  BTFSC  FD8.2
07AE0:  BRA    7C02
07AE2:  BRA    7C12
....................   
.................... 		case(0):    erro=aciona_dedos_entrada(); 
07AE4:  CALL   46FA
07AE8:  MOVFF  01,184
.................... 					//delay_ms(200);	 
.................... 				    break; 
07AEC:  BRA    7C12
....................  
.................... 		case(1):    erro=acionar_alimentador_placa(); 
07AEE:  CALL   47C8
07AF2:  MOVFF  01,184
.................... 					 
.................... 				    break;	 
07AF6:  BRA    7C12
....................  
.................... 		case(2):    erro=acionar_pressor(); 
07AF8:  CALL   48D8
07AFC:  MOVFF  01,184
.................... 					desaciona_mecanismo_de_entrada();//libera p/ outra maquina 
07B00:  CALL   2708
....................                     delay_ms(300); 
07B04:  MOVLW  02
07B06:  MOVLB  1
07B08:  MOVWF  x95
07B0A:  MOVLW  96
07B0C:  MOVLB  2
07B0E:  MOVWF  x17
07B10:  MOVLB  0
07B12:  CALL   1D50
07B16:  MOVLB  1
07B18:  DECFSZ x95,F
07B1A:  BRA    7B0A
....................                     break;	 
07B1C:  MOVLB  0
07B1E:  BRA    7C12
....................  
.................... 		case(3):	//erro=checa_farol_1(FAROL_POSICAO_SOLDAGEM); 
.................... 					break; 
07B20:  BRA    7C12
....................  
....................  
.................... 		case(4):    aciona_saida(FERRO_SOLDA2); 
07B22:  MOVLB  1
07B24:  CLRF   xA1
07B26:  MOVLW  02
07B28:  MOVWF  xA0
07B2A:  MOVLB  0
07B2C:  CALL   2FD2
.................... 					erro=posicao_soldagem(MAQUINA1); 
07B30:  MOVLW  01
07B32:  MOVLB  1
07B34:  MOVWF  x95
07B36:  MOVLB  0
07B38:  CALL   50D4
07B3C:  MOVFF  01,184
.................... 					break; 
07B40:  BRA    7C12
....................    
.................... 		case(5): 	//erro=checa_farol_1(FAROL_SOLDAR); 
.................... 					break; 
07B42:  BRA    7C12
....................  
....................  
.................... 		case(6):  	 
.................... 					erro=soldar(MAQUINA1); 
07B44:  MOVLW  01
07B46:  MOVLB  1
07B48:  MOVWF  x95
07B4A:  MOVLB  0
07B4C:  CALL   6B24
07B50:  MOVFF  01,184
.................... 				    break; 
07B54:  BRA    7C12
....................  
.................... 		case(7):	erro=posicao_home_2(MAQUINA1); 
07B56:  MOVLW  01
07B58:  MOVLB  1
07B5A:  MOVWF  x95
07B5C:  MOVLB  0
07B5E:  CALL   6BA0
07B62:  MOVFF  01,184
.................... 					//delay_ms(500); 
....................                    	break; 
07B66:  BRA    7C12
....................  
.................... 		case(8):    erro=checa_farol_1(FAROL_DISPENSAR_PLACA);  
07B68:  MOVLW  03
07B6A:  MOVLB  1
07B6C:  MOVWF  x95
07B6E:  MOVLB  0
07B70:  CALL   6D28
07B74:  MOVFF  01,184
....................                     break; 
07B78:  BRA    7C12
....................  
.................... 	  
.................... 		case(9):     
.................... 					erro=posicao_dispensar_placa(MAQUINA1);    
07B7A:  MOVLW  01
07B7C:  MOVLB  1
07B7E:  MOVWF  x95
07B80:  MOVLB  0
07B82:  CALL   6F30
07B86:  MOVFF  01,184
.................... 					break; 
07B8A:  BRA    7C12
....................  
.................... 		case(10):   erro= desaciona_pressor(); 
07B8C:  CALL   7118
07B90:  MOVFF  01,184
.................... 					break; 
07B94:  BRA    7C12
....................  
....................  
....................         case(11):   erro= aciona_dedos_saida(); 
07B96:  CALL   71B0
07B9A:  MOVFF  01,184
.................... 					break; 
07B9E:  BRA    7C12
....................  
....................  
.................... 		case(12):   erro= aciona_dispensador_placa(); 
07BA0:  CALL   727E
07BA4:  MOVFF  01,184
.................... 					break; 
07BA8:  BRA    7C12
....................  
....................  
.................... 		case(13):   erro= desaciona_dedos_saida();// importante p/ evitar colisao 
07BAA:  CALL   738A
07BAE:  MOVFF  01,184
.................... 					break; 
07BB2:  BRA    7C12
....................  
....................  
....................         case(14):	erro=posicao_home_3(MAQUINA1); 
07BB4:  MOVLW  01
07BB6:  MOVLB  1
07BB8:  MOVWF  x95
07BBA:  MOVLB  0
07BBC:  RCALL  7464
07BBE:  MOVFF  01,184
.................... 					//delay_ms(500); 
.................... 	                desaciona_mecanismo_de_saida();//libera p/ outra maquina assumir o controle 
07BC2:  CALL   2764
.................... 					break; 
07BC6:  BRA    7C12
....................  
.................... 	    case(15):	erro=posicao_home_2(MAQUINA1); 
07BC8:  MOVLW  01
07BCA:  MOVLB  1
07BCC:  MOVWF  x95
07BCE:  MOVLB  0
07BD0:  CALL   6BA0
07BD4:  MOVFF  01,184
.................... 					//delay_ms(500); 
.................... 					break; 
07BD8:  BRA    7C12
....................  
....................  
.................... 		case(16):   erro=posicao_home_1(MAQUINA1); 
07BDA:  MOVLW  01
07BDC:  MOVLB  1
07BDE:  MOVWF  x95
07BE0:  MOVLB  0
07BE2:  RCALL  7632
07BE4:  MOVFF  01,184
.................... 					//delay_ms(500); 
....................                    	break; 
07BE8:  BRA    7C12
....................  
....................  
.................... 		case(17):  	LIGA_ESTEIRA(); 
07BEA:  RCALL  77A2
.................... 					//erro=checa_farol_1(FAROL_ALIMENTACAO_PLACA_ESTAGIO1);  
.................... 					break; 
07BEC:  BRA    7C12
....................  
....................  
.................... 	case(18):   
.................... 					//posicao_alimentacao_placa_estagio1(MAQUINA1); 
....................   					break; 
07BEE:  BRA    7C12
....................  
....................  
.................... 		case(19):   erro=checa_farol_1(FAROL_POSICAO_ALIMENTACAO_PLACA);  
07BF0:  MOVLW  05
07BF2:  MOVLB  1
07BF4:  MOVWF  x95
07BF6:  MOVLB  0
07BF8:  CALL   6D28
07BFC:  MOVFF  01,184
.................... 				    break;	 
07C00:  BRA    7C12
....................  
....................  
.................... 	    case(20):   erro=posicao_alimentacao_placa(MAQUINA1); 
07C02:  MOVLW  01
07C04:  MOVLB  1
07C06:  MOVWF  x95
07C08:  MOVLB  0
07C0A:  RCALL  77C6
07C0C:  MOVFF  01,184
.................... 				    break;	 
07C10:  BRA    7C12
....................  
....................  
....................      	default: 
.................... 				    break; 
....................      
.................... 		} 
07C12:  MOVLB  1
07C14:  INCF   x82,F
07C16:  BRA    7A4E
....................  
....................  
....................  }   
07C18:  MOVLB  0
07C1A:  RETURN 0
....................  
....................  
....................  
.................... } 
....................  
....................  
.................... void maquina_estados2(int modo)  
.................... { 
....................  
....................  erro = 0; 
*
07D34:  MOVLB  1
07D36:  CLRF   x84
....................  
....................  
.................... 	for(step = 0;step <= 16;step++) 
07D38:  CLRF   x82
07D3A:  MOVF   x82,W
07D3C:  SUBLW  10
07D3E:  BTFSS  FD8.0
07D40:  BRA    7EF0
.................... 	{ 
.................... 		if(erro > 0) erro_rot(erro); 
07D42:  MOVF   x84,F
07D44:  BZ    7D52
07D46:  MOVFF  184,1A0
07D4A:  MOVLB  0
07D4C:  CALL   3B1C
07D50:  MOVLB  1
....................  	    if(modo ==  MODO_EDITA_PONTOS)  
07D52:  DECFSZ x94,W
07D54:  BRA    7D5E
....................         { 
.................... 			if(step == 5) return; 
07D56:  MOVF   x82,W
07D58:  SUBLW  05
07D5A:  BTFSC  FD8.2
07D5C:  BRA    7EF0
....................  
....................  
.................... 		} 
....................   
.................... 		switch(step){ 
07D5E:  MOVF   x82,W
07D60:  XORLW  00
07D62:  MOVLB  0
07D64:  BZ    7DBA
07D66:  XORLW  01
07D68:  BZ    7DD0
07D6A:  XORLW  03
07D6C:  BZ    7DDE
07D6E:  XORLW  01
07D70:  BZ    7E02
07D72:  XORLW  07
07D74:  BZ    7E04
07D76:  XORLW  01
07D78:  BZ    7E32
07D7A:  XORLW  03
07D7C:  BZ    7E42
07D7E:  XORLW  01
07D80:  BZ    7E54
07D82:  XORLW  0F
07D84:  BTFSC  FD8.2
07D86:  BRA    7E66
07D88:  XORLW  01
07D8A:  BTFSC  FD8.2
07D8C:  BRA    7E76
07D8E:  XORLW  03
07D90:  BTFSC  FD8.2
07D92:  BRA    7E88
07D94:  XORLW  01
07D96:  BTFSC  FD8.2
07D98:  BRA    7E92
07D9A:  XORLW  07
07D9C:  BTFSC  FD8.2
07D9E:  BRA    7E9C
07DA0:  XORLW  01
07DA2:  BTFSC  FD8.2
07DA4:  BRA    7EA6
07DA6:  XORLW  03
07DA8:  BTFSC  FD8.2
07DAA:  BRA    7EB0
07DAC:  XORLW  01
07DAE:  BTFSC  FD8.2
07DB0:  BRA    7EC6
07DB2:  XORLW  1F
07DB4:  BTFSC  FD8.2
07DB6:  BRA    7ED8
07DB8:  BRA    7EEA
....................   
.................... 		case(0):    erro=aciona_dedos_entrada(); 
07DBA:  CALL   46FA
07DBE:  MOVFF  01,184
.................... 					delay_ms(200);	 
07DC2:  MOVLW  C8
07DC4:  MOVLB  2
07DC6:  MOVWF  x17
07DC8:  MOVLB  0
07DCA:  CALL   1D50
.................... 				    break; 
07DCE:  BRA    7EEA
....................  
.................... 		case(1):    erro=acionar_alimentador_placa(); 
07DD0:  CALL   47C8
07DD4:  MOVFF  01,184
.................... 					//delay_ms(500); 
....................                     desaciona_mecanismo_de_entrada(); 
07DD8:  CALL   2708
.................... 				    break;	 
07DDC:  BRA    7EEA
....................  
.................... 		case(2):    erro=acionar_pressor(); 
07DDE:  CALL   48D8
07DE2:  MOVFF  01,184
.................... 					delay_ms(300);	 
07DE6:  MOVLW  02
07DE8:  MOVLB  1
07DEA:  MOVWF  x95
07DEC:  MOVLW  96
07DEE:  MOVLB  2
07DF0:  MOVWF  x17
07DF2:  MOVLB  0
07DF4:  CALL   1D50
07DF8:  MOVLB  1
07DFA:  DECFSZ x95,F
07DFC:  BRA    7DEC
....................  				    break;	 
07DFE:  MOVLB  0
07E00:  BRA    7EEA
....................  
.................... 		case(3):    //erro=checa_farol_2(FAROL_POSICAO_SOLDAGEM); 
.................... 					break; 
07E02:  BRA    7EEA
....................  
.................... 		case(4):    aciona_saida(FERRO_SOLDA1);  
07E04:  MOVLB  1
07E06:  CLRF   xA1
07E08:  MOVLW  03
07E0A:  MOVWF  xA0
07E0C:  MOVLB  0
07E0E:  CALL   2FD2
.................... 					aciona_saida(FERRO_SOLDA2); 
07E12:  MOVLB  1
07E14:  CLRF   xA1
07E16:  MOVLW  02
07E18:  MOVWF  xA0
07E1A:  MOVLB  0
07E1C:  CALL   2FD2
.................... 					erro=posicao_soldagem(MAQUINA2); 
07E20:  MOVLW  02
07E22:  MOVLB  1
07E24:  MOVWF  x95
07E26:  MOVLB  0
07E28:  CALL   50D4
07E2C:  MOVFF  01,184
.................... 				    break; 
07E30:  BRA    7EEA
....................    
.................... 		case(5): 	erro=checa_farol_2(FAROL_SOLDAR); 
07E32:  MOVLW  02
07E34:  MOVLB  1
07E36:  MOVWF  x95
07E38:  MOVLB  0
07E3A:  RCALL  7C76
07E3C:  MOVFF  01,184
.................... 					break; 
07E40:  BRA    7EEA
....................  
.................... 		case(6):   	 
.................... 					erro=soldar(MAQUINA2); 
07E42:  MOVLW  02
07E44:  MOVLB  1
07E46:  MOVWF  x95
07E48:  MOVLB  0
07E4A:  CALL   6B24
07E4E:  MOVFF  01,184
....................  					break; 
07E52:  BRA    7EEA
....................  
.................... 		case(7):	erro=posicao_home_2(MAQUINA2); 
07E54:  MOVLW  02
07E56:  MOVLB  1
07E58:  MOVWF  x95
07E5A:  MOVLB  0
07E5C:  CALL   6BA0
07E60:  MOVFF  01,184
.................... 					//delay_ms(500); 
....................                    	break; 
07E64:  BRA    7EEA
....................  
.................... 	 	 
.................... 	    case(8):    erro=checa_farol_2(FAROL_DISPENSAR_PLACA); 
07E66:  MOVLW  03
07E68:  MOVLB  1
07E6A:  MOVWF  x95
07E6C:  MOVLB  0
07E6E:  RCALL  7C76
07E70:  MOVFF  01,184
.................... 					break; 
07E74:  BRA    7EEA
....................  
.................... 		case(9):     
.................... 					erro = posicao_dispensar_placa(MAQUINA2);    
07E76:  MOVLW  02
07E78:  MOVLB  1
07E7A:  MOVWF  x95
07E7C:  MOVLB  0
07E7E:  CALL   6F30
07E82:  MOVFF  01,184
....................  			     	//delay_ms(500);   
....................          			break; 
07E86:  BRA    7EEA
....................  
.................... 		case(10):  	erro= desaciona_pressor(); 
07E88:  CALL   7118
07E8C:  MOVFF  01,184
.................... 					break; 
07E90:  BRA    7EEA
....................  
.................... 		case(11):  	erro= aciona_dedos_saida(); 
07E92:  CALL   71B0
07E96:  MOVFF  01,184
.................... 					break; 
07E9A:  BRA    7EEA
....................  
....................         case(12):   erro= aciona_dispensador_placa(); 
07E9C:  CALL   727E
07EA0:  MOVFF  01,184
.................... 					break; 
07EA4:  BRA    7EEA
....................          
.................... 		case(13):   erro= desaciona_dedos_saida();// importante p/ evitar colisao 
07EA6:  CALL   738A
07EAA:  MOVFF  01,184
.................... 				    break; 
07EAE:  BRA    7EEA
....................  
....................         case(14):	erro = posicao_home_3(MAQUINA2); 
07EB0:  MOVLW  02
07EB2:  MOVLB  1
07EB4:  MOVWF  x95
07EB6:  MOVLB  0
07EB8:  CALL   7464
07EBC:  MOVFF  01,184
.................... 					//delay_ms(500); 
.................... 					desaciona_mecanismo_de_saida();//libera p/ outra maquina assumir o controle 
07EC0:  CALL   2764
.................... 					break; 
07EC4:  BRA    7EEA
....................  
.................... 	    case(15):	erro=posicao_home_2(MAQUINA2); 
07EC6:  MOVLW  02
07EC8:  MOVLB  1
07ECA:  MOVWF  x95
07ECC:  MOVLB  0
07ECE:  CALL   6BA0
07ED2:  MOVFF  01,184
.................... 					//delay_ms(500); 
.................... 					break; 
07ED6:  BRA    7EEA
....................  
....................  
.................... 		case(16):   erro = posicao_home_1(MAQUINA2); 
07ED8:  MOVLW  02
07EDA:  MOVLB  1
07EDC:  MOVWF  x95
07EDE:  MOVLB  0
07EE0:  CALL   7632
07EE4:  MOVFF  01,184
.................... 					//delay_ms(500); 
....................                     //erro=checa_farol_2(9);  
.................... 					break; 
07EE8:  BRA    7EEA
....................  
....................  
....................      	default: 
.................... 				    break; 
....................      
.................... 		} 
07EEA:  MOVLB  1
07EEC:  INCF   x82,F
07EEE:  BRA    7D3A
....................  
....................  
.................... 	} 
07EF0:  MOVLB  0
07EF2:  RETURN 0
....................  
....................  
.................... } 
....................  
.................... void maquina_1(void) 
.................... { 
....................   
....................   delay_ms(1000);	 
*
0ACA2:  MOVLW  04
0ACA4:  MOVLB  1
0ACA6:  MOVWF  x8B
0ACA8:  MOVLW  FA
0ACAA:  MOVLB  2
0ACAC:  MOVWF  x17
0ACAE:  MOVLB  0
0ACB0:  CALL   1D50
0ACB4:  MOVLB  1
0ACB6:  DECFSZ x8B,F
0ACB8:  BRA    ACA8
....................   erro=home_maquina_1();  
0ACBA:  MOVLB  0
0ACBC:  CALL   39DC
0ACC0:  MOVFF  01,184
....................   if(erro > 0) 
0ACC4:  MOVLB  1
0ACC6:  MOVF   x84,F
0ACC8:  BZ    ACD6
....................   { 
....................      erro_rot(erro); 
0ACCA:  MOVFF  184,1A0
0ACCE:  MOVLB  0
0ACD0:  CALL   3B1C
0ACD4:  MOVLB  1
....................    
....................   }		 
.................... 	 
....................  
.................... 	//go_z(140,2000);		         
.................... 	contador_step_x    = 0x0000; 
0ACD6:  CLRF   x79
0ACD8:  CLRF   x78
....................  	contador_step_y    = 0x0000; 
0ACDA:  CLRF   x7B
0ACDC:  CLRF   x7A
....................  	contador_step_flip = 0x0000; 
0ACDE:  CLRF   x7D
0ACE0:  CLRF   x7C
....................     contador_step_z    = 0x0000; 
0ACE2:  CLRF   x7F
0ACE4:  CLRF   x7E
.................... 	go_x_y(50,0,2000,2000,2000,2000,200,200,false,false,false,false); // ajuste alinhamento bandeja 
0ACE6:  CLRF   x9D
0ACE8:  MOVLW  32
0ACEA:  MOVWF  x9C
0ACEC:  CLRF   x9F
0ACEE:  CLRF   x9E
0ACF0:  MOVLW  07
0ACF2:  MOVWF  xA1
0ACF4:  MOVLW  D0
0ACF6:  MOVWF  xA0
0ACF8:  MOVLW  07
0ACFA:  MOVWF  xA3
0ACFC:  MOVLW  D0
0ACFE:  MOVWF  xA2
0AD00:  MOVLW  07
0AD02:  MOVWF  xA5
0AD04:  MOVLW  D0
0AD06:  MOVWF  xA4
0AD08:  MOVLW  07
0AD0A:  MOVWF  xA7
0AD0C:  MOVLW  D0
0AD0E:  MOVWF  xA6
0AD10:  MOVLW  C8
0AD12:  MOVWF  xA8
0AD14:  MOVWF  xA9
0AD16:  CLRF   xAA
0AD18:  CLRF   xAB
0AD1A:  CLRF   xAC
0AD1C:  CLRF   xAD
0AD1E:  MOVLB  0
0AD20:  CALL   42F6
....................  
....................     if(input(in25_bit) == 1)  aciona_saida(RELE_ESTEIRA); 
0AD24:  BSF    F93.1
0AD26:  BTFSS  F81.1
0AD28:  BRA    AD38
0AD2A:  MOVLB  1
0AD2C:  CLRF   xA1
0AD2E:  MOVLW  0A
0AD30:  MOVWF  xA0
0AD32:  MOVLB  0
0AD34:  CALL   2FD2
.................... 	while(1){ 
....................  
....................     disable_interrupts(INT_EXT1);  
0AD38:  BCF    FF0.3
....................     disable_interrupts(GLOBAL); 
0AD3A:  BCF    FF2.6
0AD3C:  BCF    FF2.7
0AD3E:  BTFSC  FF2.7
0AD40:  BRA    AD3C
....................  
.................... 	posiciona_cursor(4,1); 
0AD42:  MOVLW  04
0AD44:  MOVLB  1
0AD46:  MOVWF  xA5
0AD48:  MOVLW  01
0AD4A:  MOVWF  xA6
0AD4C:  MOVLB  0
0AD4E:  CALL   1F92
....................  	printf(lcd_putc,"AGUARDANDO PLACA    \n\r"); 
0AD52:  MOVLW  E0
0AD54:  MOVWF  FF6
0AD56:  MOVLW  1A
0AD58:  MOVWF  FF7
0AD5A:  CALL   25DA
....................     if(input(in25_bit) == 1)  aciona_saida(RELE_ESTEIRA); 
0AD5E:  BSF    F93.1
0AD60:  BTFSS  F81.1
0AD62:  BRA    AD72
0AD64:  MOVLB  1
0AD66:  CLRF   xA1
0AD68:  MOVLW  0A
0AD6A:  MOVWF  xA0
0AD6C:  MOVLB  0
0AD6E:  CALL   2FD2
....................  
.................... 	while(input(in25_bit) == 1) 
0AD72:  BSF    F93.1
0AD74:  BTFSS  F81.1
0AD76:  BRA    ADAE
.................... 	{ 
....................          
.................... 		check_keyboard();   
0AD78:  RCALL  A9FE
....................  
....................      if(n_maquina == MAQUINA1) 
0AD7A:  DECFSZ 1D,W
0AD7C:  BRA    AD92
....................      {		 
....................  
.................... 	 
.................... 		if(le_posicao_da_maquina2() == STOP) 
0AD7E:  CALL   363A
0AD82:  MOVF   01,W
0AD84:  SUBLW  07
0AD86:  BNZ   AD92
.................... 		{ 
....................  
.................... 			coloca_maquina_em_home_1(MAQUINA1);	 
0AD88:  MOVLW  01
0AD8A:  MOVLB  1
0AD8C:  MOVWF  x8B
0AD8E:  MOVLB  0
0AD90:  RCALL  AB14
....................  
.................... 		}		 
....................  
....................     } 
....................  
....................     if(n_maquina == MAQUINA2) 
0AD92:  MOVF   1D,W
0AD94:  SUBLW  02
0AD96:  BNZ   ADAC
....................     {		 
....................  
.................... 	 
.................... 		if(le_posicao_da_maquina1() == STOP) 
0AD98:  CALL   7C1C
0AD9C:  MOVF   01,W
0AD9E:  SUBLW  07
0ADA0:  BNZ   ADAC
.................... 		{ 
....................  
.................... 			coloca_maquina_em_home_1(MAQUINA2);	 
0ADA2:  MOVLW  02
0ADA4:  MOVLB  1
0ADA6:  MOVWF  x8B
0ADA8:  MOVLB  0
0ADAA:  RCALL  AB14
....................  
.................... 		}		 
....................  
....................     } 
0ADAC:  BRA    AD72
0ADAE:  CLRF   16
0ADB0:  BTFSC  FF2.7
0ADB2:  BSF    16.7
0ADB4:  BCF    FF2.7
....................  
....................  
.................... 	} 
....................  
....................      desaciona_saida(RELE_ESTEIRA); 
0ADB6:  MOVLB  2
0ADB8:  CLRF   x1B
0ADBA:  MOVLW  0A
0ADBC:  MOVWF  x1A
0ADBE:  MOVLB  0
0ADC0:  CALL   1B96
0ADC4:  BTFSC  16.7
0ADC6:  BSF    FF2.7
....................  
....................      maquina_estados1(MODO_SOLDAR);  
0ADC8:  MOVLB  1
0ADCA:  CLRF   x94
0ADCC:  MOVLB  0
0ADCE:  CALL   7A48
0ADD2:  BRA    AD38
....................     
....................  
....................  
.................... 				//while(le_Input(SENSOR_BOARD) == false){} 
....................  
.................... 	} 
0ADD4:  GOTO   B680 (RETURN)
....................  
....................  }  
....................  
....................  
....................  
....................  
....................  
....................  
.................... void maquina_2(void) 
.................... { 
....................     first_time = true;   
0ADD8:  BSF    1E.3
....................  
....................   erro=home_maquina_2();  
0ADDA:  CALL   8758
0ADDE:  MOVFF  01,184
....................   if(erro > 0) 
0ADE2:  MOVLB  1
0ADE4:  MOVF   x84,F
0ADE6:  BZ    ADF4
....................   { 
....................  
....................      erro_rot(erro); 
0ADE8:  MOVFF  184,1A0
0ADEC:  MOVLB  0
0ADEE:  CALL   3B1C
0ADF2:  MOVLB  1
....................    
....................   }		 
.................... 	 
....................  
.................... 	//go_z(140,2000);		        //y=14000; 
.................... 	contador_step_x    = 0x0000; 
0ADF4:  CLRF   x79
0ADF6:  CLRF   x78
....................  	contador_step_y    = 0x0000; 
0ADF8:  CLRF   x7B
0ADFA:  CLRF   x7A
....................  	contador_step_flip = 0x0000; 
0ADFC:  CLRF   x7D
0ADFE:  CLRF   x7C
....................     contador_step_z    = 0x0000; 
0AE00:  CLRF   x7F
0AE02:  CLRF   x7E
....................  
.................... 	//if(input(in25_bit) == 1)  aciona_saida(RELE_ESTEIRA); 
....................  
.................... 	while(1){ 
....................  
....................     
.................... /* 
....................  	if(input(in25_bit) == 0) // rele  placa 
....................     { 
.................... 	    TEM_PLACA == TRUE; 
....................         ext_int_edge(1,L_TO_H); 
....................     }else{ 
.................... 		   TEM_PLACA == FALSE;	 
.................... 		   //aciona_saida(RELE_ESTEIRA); 
.................... 		   ext_int_edge(1,H_TO_L); 
....................  
.................... 	    }   
....................   
....................    
.................... 	enable_interrupts(INT_EXT1);  
....................     enable_interrupts(GLOBAL); 
....................  
.................... */ 
....................  
....................     Tela_Inicial(); 
0AE04:  MOVLB  0
0AE06:  CALL   26A2
.................... 	posiciona_cursor(4,1); 
0AE0A:  MOVLW  04
0AE0C:  MOVLB  1
0AE0E:  MOVWF  xA5
0AE10:  MOVLW  01
0AE12:  MOVWF  xA6
0AE14:  MOVLB  0
0AE16:  CALL   1F92
....................  	printf(lcd_putc,"AGUARDANDO PLACA    \n\r"); 
0AE1A:  MOVLW  F8
0AE1C:  MOVWF  FF6
0AE1E:  MOVLW  1A
0AE20:  MOVWF  FF7
0AE22:  CALL   25DA
....................  
.................... //	if(input(in25_bit) == 1)  aciona_saida(RELE_ESTEIRA); 
....................  
....................     posicao_atual = le_posicao_da_maquina1(); 
0AE26:  CALL   7C1C
0AE2A:  MOVFF  01,185
....................  
....................     switch(posicao_atual){ 
0AE2E:  MOVLB  1
0AE30:  MOVF   x85,W
0AE32:  XORLW  00
0AE34:  MOVLB  0
0AE36:  BZ    AE56
0AE38:  XORLW  01
0AE3A:  BZ    AE74
0AE3C:  XORLW  03
0AE3E:  BZ    AE86
0AE40:  XORLW  01
0AE42:  BZ    AEA6
0AE44:  XORLW  07
0AE46:  BZ    AEB8
0AE48:  XORLW  01
0AE4A:  BZ    AECA
0AE4C:  XORLW  03
0AE4E:  BZ    AEDC
0AE50:  XORLW  01
0AE52:  BZ    AEEE
0AE54:  BRA    AEF0
....................  
....................     case(POSICAO_HOME1):      
.................... 							 while(le_posicao_da_maquina1() != POSICAO_SOLDA_ESTAGIO1) 
0AE56:  CALL   7C1C
0AE5A:  MOVF   01,W
0AE5C:  SUBLW  03
0AE5E:  BZ    AE62
....................     						 { 
0AE60:  BRA    AE56
....................  
....................          					   //check_keyboard(); 
....................  
.................... 							 } 
....................  
.................... 						    LIGA_ESTEIRA(); 
0AE62:  CALL   77A2
.................... 							//posicao_alimentacao_placa_estagio1(MAQUINA2); 
....................  
.................... 							//while(le_posicao_da_maquina1() != POSICAO_SOLDA_ESTAGIO2) 
....................     						//{ 
....................  
....................          						//check_keyboard(); 
....................  
....................  
.................... 							//} 
....................  
....................  
....................                             posicao_alimentacao_placa(MAQUINA2);//coloca na posicao de alimentacao de placa 
0AE66:  MOVLW  02
0AE68:  MOVLB  1
0AE6A:  MOVWF  x95
0AE6C:  MOVLB  0
0AE6E:  CALL   77C6
....................  
.................... 							break;  
0AE72:  BRA    AEFC
....................  
....................     case(POSICAO_HOME2):    LIGA_ESTEIRA(); 
0AE74:  CALL   77A2
.................... 							posicao_alimentacao_placa(MAQUINA2);//coloca na posicao de alimentacao de placa 
0AE78:  MOVLW  02
0AE7A:  MOVLB  1
0AE7C:  MOVWF  x95
0AE7E:  MOVLB  0
0AE80:  CALL   77C6
....................  
.................... 							break;  
0AE84:  BRA    AEFC
....................  
....................     case(POSICAO_ALIMENTADOR):  
.................... 								while(le_posicao_da_maquina1() != POSICAO_SOLDA_ESTAGIO1) 
0AE86:  CALL   7C1C
0AE8A:  MOVF   01,W
0AE8C:  SUBLW  03
0AE8E:  BZ    AE94
....................     						   { 
....................  
....................          							check_keyboard(); 
0AE90:  RCALL  A9FE
0AE92:  BRA    AE86
....................  
.................... 						       } 
.................... 							    //LIGA_ESTEIRA(); 
.................... 								//posicao_alimentacao_placa_estagio1(MAQUINA2); 
....................  
.................... 							   //while(le_posicao_da_maquina1() != POSICAO_SOLDA_ESTAGIO2) 
....................     						   //{ 
....................  
....................          						   // check_keyboard(); 
....................  
....................  
.................... 							   //} 
....................  
.................... 							   LIGA_ESTEIRA(); 
0AE94:  CALL   77A2
....................                                posicao_alimentacao_placa(MAQUINA2);//coloca na posicao de alimentacao de placa 
0AE98:  MOVLW  02
0AE9A:  MOVLB  1
0AE9C:  MOVWF  x95
0AE9E:  MOVLB  0
0AEA0:  CALL   77C6
....................  
.................... 							break;  
0AEA4:  BRA    AEFC
....................  
....................     case(POSICAO_SOLDA_ESTAGIO1):  
.................... 								  LIGA_ESTEIRA(); 
0AEA6:  CALL   77A2
.................... 								  //posicao_alimentacao_placa_estagio1(MAQUINA2); 
.................... 								  //while(le_posicao_da_maquina1() != POSICAO_SOLDA_ESTAGIO2) 
....................     						   		//{ 
....................  
....................          						    	//check_keyboard(); 
....................  
....................  
.................... 							   		//} 
.................... 									 
.................... 								    posicao_alimentacao_placa(MAQUINA2);//coloca na posicao de alimentacao de placa 
0AEAA:  MOVLW  02
0AEAC:  MOVLB  1
0AEAE:  MOVWF  x95
0AEB0:  MOVLB  0
0AEB2:  CALL   77C6
....................  
....................  
.................... 									break;  
0AEB6:  BRA    AEFC
....................  
....................     case(POSICAO_SOLDA_ESTAGIO2):   LIGA_ESTEIRA(); 
0AEB8:  CALL   77A2
.................... 									posicao_alimentacao_placa(MAQUINA2);//coloca na posicao de alimentacao de placa 
0AEBC:  MOVLW  02
0AEBE:  MOVLB  1
0AEC0:  MOVWF  x95
0AEC2:  MOVLB  0
0AEC4:  CALL   77C6
.................... 									break;  
0AEC8:  BRA    AEFC
....................  
....................     case(POSICAO_DISPENSADOR):      LIGA_ESTEIRA(); 
0AECA:  CALL   77A2
.................... 									posicao_alimentacao_placa(MAQUINA2);//coloca na posicao de alimentacao de placa 
0AECE:  MOVLW  02
0AED0:  MOVLB  1
0AED2:  MOVWF  x95
0AED4:  MOVLB  0
0AED6:  CALL   77C6
.................... 									break; 
0AEDA:  BRA    AEFC
....................  
....................     case(POSICAO_HOME3):            LIGA_ESTEIRA(); 
0AEDC:  CALL   77A2
.................... 									posicao_alimentacao_placa(MAQUINA2);//coloca na posicao de alimentacao de placa 
0AEE0:  MOVLW  02
0AEE2:  MOVLB  1
0AEE4:  MOVWF  x95
0AEE6:  MOVLB  0
0AEE8:  CALL   77C6
.................... 								    break;  
0AEEC:  BRA    AEFC
....................  
....................     case(STOP):  
....................  
.................... 									break;  
0AEEE:  BRA    AEFC
....................  
.................... 	default:                        erro_rot(10); 
0AEF0:  MOVLW  0A
0AEF2:  MOVLB  1
0AEF4:  MOVWF  xA0
0AEF6:  MOVLB  0
0AEF8:  CALL   3B1C
.................... 									break; 
....................  
.................... 	} 
....................  
....................     disable_interrupts(INT_EXT1);  
0AEFC:  BCF    FF0.3
....................     //disable_interrupts(GLOBAL); 
....................  
....................  
....................     //LIGA_ESTEIRA(); 
....................     Tela_Inicial(); 
0AEFE:  CALL   26A2
.................... 	posiciona_cursor(4,1); 
0AF02:  MOVLW  04
0AF04:  MOVLB  1
0AF06:  MOVWF  xA5
0AF08:  MOVLW  01
0AF0A:  MOVWF  xA6
0AF0C:  MOVLB  0
0AF0E:  CALL   1F92
....................  	printf(lcd_putc,"AGUARDANDO PLACA    \n\r"); 
0AF12:  MOVLW  10
0AF14:  MOVWF  FF6
0AF16:  MOVLW  1B
0AF18:  MOVWF  FF7
0AF1A:  CALL   25DA
....................  
....................     if(input(in25_bit) == 1)  aciona_saida(RELE_ESTEIRA); 
0AF1E:  BSF    F93.1
0AF20:  BTFSS  F81.1
0AF22:  BRA    AF32
0AF24:  MOVLB  1
0AF26:  CLRF   xA1
0AF28:  MOVLW  0A
0AF2A:  MOVWF  xA0
0AF2C:  MOVLB  0
0AF2E:  CALL   2FD2
....................  
....................  
.................... 	while(input(in25_bit) == 1) 
0AF32:  BSF    F93.1
0AF34:  BTFSS  F81.1
0AF36:  BRA    AF3C
.................... 	{ 
....................  
.................... 		check_keyboard();   
0AF38:  RCALL  A9FE
0AF3A:  BRA    AF32
0AF3C:  CLRF   16
0AF3E:  BTFSC  FF2.7
0AF40:  BSF    16.7
0AF42:  BCF    FF2.7
....................  
....................  
.................... 	} 
....................  
....................      
....................     desaciona_saida(RELE_ESTEIRA); 
0AF44:  MOVLB  2
0AF46:  CLRF   x1B
0AF48:  MOVLW  0A
0AF4A:  MOVWF  x1A
0AF4C:  MOVLB  0
0AF4E:  CALL   1B96
0AF52:  BTFSC  16.7
0AF54:  BSF    FF2.7
....................  
....................     erro = 0; 
0AF56:  MOVLB  1
0AF58:  CLRF   x84
....................  
.................... 	maquina_estados2(MODO_SOLDAR);  
0AF5A:  CLRF   x94
0AF5C:  MOVLB  0
0AF5E:  CALL   7D34
0AF62:  BRA    AE06
....................  
....................  }  
0AF64:  GOTO   B686 (RETURN)
....................  
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... 	#int_timer0 
.................... 	void trata_timer0(void) 
.................... 	{  
....................  
.................... 		estouro_timer0 = true;  
*
01BD8:  BSF    1E.6
....................  
.................... 	if(trata_timer_zero_modo == 1) 
01BDA:  BTFSS  1E.2
01BDC:  BRA    1C24
....................     { 
.................... 	 
.................... 		contador_tempo++; 
01BDE:  INCF   1F,F
01BE0:  BTFSC  FD8.2
01BE2:  INCF   20,F
....................         
.................... 		if(contador_tempo < tempo_aplicacao) 
01BE4:  MOVF   20,W
01BE6:  SUBWF  24,W
01BE8:  BNC   1BFC
01BEA:  BNZ   1BF2
01BEC:  MOVF   23,W
01BEE:  SUBWF  1F,W
01BF0:  BC    1BFC
.................... 		{ 
....................  
.................... 	 	  SET_TIMER0(tempo);	 
01BF2:  MOVFF  22,FD7
01BF6:  MOVFF  21,FD6
.................... 	   	  
.................... 	  	  
....................  
....................  
.................... 	    }else{ 
01BFA:  BRA    1C24
....................  
.................... 				desaciona_saida(ALIMENTADOR1); 
01BFC:  MOVLB  2
01BFE:  CLRF   x1B
01C00:  MOVLW  0E
01C02:  MOVWF  x1A
01C04:  MOVLB  0
01C06:  RCALL  1B96
.................... 	     		desaciona_saida(ALIMENTADOR2); 
01C08:  MOVLB  2
01C0A:  CLRF   x1B
01C0C:  MOVLW  0D
01C0E:  MOVWF  x1A
01C10:  MOVLB  0
01C12:  RCALL  1B96
.................... 	     		desaciona_saida(ALIMENTADOR3); 
01C14:  MOVLB  2
01C16:  CLRF   x1B
01C18:  MOVLW  0C
01C1A:  MOVWF  x1A
01C1C:  MOVLB  0
01C1E:  RCALL  1B96
.................... 			    disable_interrupts(INT_TIMER0); 
01C20:  BCF    FF2.5
.................... 				setup_timer_0	(T0_OFF);	 
01C22:  CLRF   FD5
.................... 								 
....................  
.................... 			 } 
....................     }  
.................... 	 
.................... 	} 
....................  
01C24:  BCF    FF2.2
01C26:  GOTO   0078
....................    	#int_timer1 
.................... 	void trata_timer1(void) 
.................... 	{ 
.................... 	    estouro_timer1=true; 
01C2A:  BSF    1E.4
....................  
.................... 	} 
....................  
....................  
01C2C:  BCF    F9E.0
01C2E:  GOTO   0078
.................... 	#int_timer3 
.................... 	void trata_timer3(void) 
.................... 	{ 
....................  
.................... 	    estouro_timer3=true; 
01C32:  BSF    1E.5
....................  
....................  
.................... 	} 
....................     
01C34:  BCF    FA1.1
01C36:  GOTO   0078
.................... 	#INT_EXT1 
.................... 	void ext_int1() 
.................... 	{ 
.................... 	   	while(I2C_OCUPADA == TRUE){} 
*
01C5A:  BTFSC  1E.0
01C5C:  BRA    1C5A
.................... 		 
....................  
.................... 		delay_us(500); 
01C5E:  MOVLW  02
01C60:  MOVLB  2
01C62:  MOVWF  x1A
01C64:  MOVLW  F9
01C66:  MOVWF  x1B
01C68:  MOVLB  0
01C6A:  RCALL  1C3A
01C6C:  MOVLB  2
01C6E:  DECFSZ x1A,F
01C70:  BRA    1C64
....................  
....................        // if(TEM_PLACA == FALSE) 
.................... 		//{ 
.................... 			if(input(in25_bit) == 1) 
01C72:  BSF    F93.1
01C74:  BTFSS  F81.1
01C76:  BRA    1C7C
.................... 			{ 
.................... 								 
.................... 				return; 
01C78:  BRA    1C8A
....................  
.................... 			}else{ 
01C7A:  BRA    1C8A
....................  
.................... 	 				//ext_int_edge(1,L_TO_H); 
.................... 				    desaciona_saida(RELE_ESTEIRA); 
01C7C:  CLRF   x1B
01C7E:  MOVLW  0A
01C80:  MOVWF  x1A
01C82:  MOVLB  0
01C84:  RCALL  1B96
.................... 				    TEM_PLACA = TRUE; 
01C86:  BSF    1E.1
01C88:  MOVLB  2
.................... 				 
....................  
.................... 			     } 
.................... //			return;	  
....................  
.................... //		} 
.................... /* 
....................  
....................  		if(TEM_PLACA == TRUE) 
.................... 		{ 
.................... 			if(input(in25_bit) == 0) 
.................... 			{ 
.................... 								 
.................... 				return; 
....................  
.................... 			}else{ 
....................  
.................... 	 				ext_int_edge(1,H_TO_L); 
.................... 				    //aciona_saida(RELE_ESTEIRA); 
.................... 				    TEM_PLACA = FALSE; 
.................... 					 
.................... 			     } 
.................... 			return;	  
....................  
.................... 		} 
.................... */ 
....................  
.................... /* 
.................... 	      
.................... 	     if(input(in25_bit) == 1) 
.................... 	     { 
.................... 			ext_int_edge(1,H_TO_L); 
.................... 			aciona_saida(RELE_ESTEIRA); 
.................... 	        TEM_PLACA == FALSE; 
.................... 		    
....................  
.................... 	     }else{ 
.................... 			    ext_int_edge(1,L_TO_H); 
.................... 			    desaciona_saida(RELE_ESTEIRA); 
.................... 			    TEM_PLACA == TRUE; 
....................  
.................... 			   }  
....................  
....................    */   
.................... 	   
01C8A:  BCF    FF0.0
01C8C:  MOVLB  0
01C8E:  GOTO   0078
.................... 	} 
....................  
....................  
.................... void delay_preciso(long int xxx) 
.................... { 
.................... 	estouro_timer1 = false; 
.................... 	setup_timer_1(T1_INTERNAL | T1_DIV_BY_1); 
.................... 	enable_interrupts(INT_TIMER1); 
.................... 	set_timer1(xxx); 
.................... 	enable_interrupts(GLOBAL); 
....................  
.................... 	while(estouro_timer1  == false){}; 
.................... 	disable_interrupts(INT_TIMER1); 
.................... 	disable_interrupts(GLOBAL); 
.................... 	setup_timer_1	(t1_disabled); 
.................... } 
....................  
....................  
....................  
.................... void	pega_label_eeprom(void) 
.................... { 
.................... 	disable_interrupts(GLOBAL); 
*
02B9C:  BCF    FF2.6
02B9E:  BCF    FF2.7
02BA0:  BTFSC  FF2.7
02BA2:  BRA    2B9E
....................     addr=(long)programa*200; 
02BA4:  MOVLB  1
02BA6:  CLRF   x8C
02BA8:  MOVFF  29,18B
02BAC:  MOVFF  18C,215
02BB0:  MOVFF  29,214
02BB4:  MOVLB  2
02BB6:  CLRF   x17
02BB8:  MOVLW  C8
02BBA:  MOVWF  x16
02BBC:  MOVLB  0
02BBE:  RCALL  27BE
02BC0:  MOVFF  02,56
02BC4:  MOVFF  01,55
.................... 	tem_programa=read_ext_eeprom(addr);      //le tem programa 
02BC8:  MOVFF  56,18D
02BCC:  MOVFF  55,18C
02BD0:  CALL   202E
02BD4:  MOVFF  01,31
.................... 	addr++; 
02BD8:  INCF   55,F
02BDA:  BTFSC  FD8.2
02BDC:  INCF   56,F
.................... 	numero_de_passos=read_ext_eeprom(addr);  //le numero de passos contido no programa 
02BDE:  MOVFF  56,18D
02BE2:  MOVFF  55,18C
02BE6:  CALL   202E
02BEA:  MOVFF  01,57
.................... 	addr++;				  
02BEE:  INCF   55,F
02BF0:  BTFSC  FD8.2
02BF2:  INCF   56,F
.................... 	n_placas=read_ext_eeprom(addr);          //numero de placas contidas  na bolacha 
02BF4:  MOVFF  56,18D
02BF8:  MOVFF  55,18C
02BFC:  CALL   202E
02C00:  MOVFF  01,28
.................... 	enable_interrupts(GLOBAL); 
02C04:  MOVLW  C0
02C06:  IORWF  FF2,F
02C08:  GOTO   B678 (RETURN)
....................  
.................... } 
....................  
....................  
....................  
.................... void  pega_data_eeprom(int passo) 
.................... { 
....................  	int coordenada_x_msb; 
....................  	int coordenada_x_lsb; 
....................  	int coordenada_y_msb; 
....................  	int coordenada_y_lsb; 
....................  	int coordenada_z_msb; 
....................  	int coordenada_z_lsb; 
....................  
....................  	disable_interrupts(GLOBAL); 
*
053D8:  BCF    FF2.6
053DA:  BCF    FF2.7
053DC:  BTFSC  FF2.7
053DE:  BRA    53DA
....................  
.................... 	addr=((long)programa * 200) + 3; 
053E0:  MOVLB  1
053E2:  CLRF   xA2
053E4:  MOVFF  29,1A1
053E8:  MOVFF  1A2,215
053EC:  MOVFF  29,214
053F0:  MOVLB  2
053F2:  CLRF   x17
053F4:  MOVLW  C8
053F6:  MOVWF  x16
053F8:  MOVLB  0
053FA:  CALL   27BE
053FE:  MOVLW  03
05400:  MOVLB  1
05402:  ADDWF  01,W
05404:  MOVWF  55
05406:  MOVLW  00
05408:  ADDWFC 02,W
0540A:  MOVWF  56
.................... 	addr=addr + ((long)passo * 12); 
0540C:  CLRF   xA2
0540E:  MOVFF  19A,1A1
05412:  MOVFF  1A2,215
05416:  MOVFF  19A,214
0541A:  MOVLB  2
0541C:  CLRF   x17
0541E:  MOVLW  0C
05420:  MOVWF  x16
05422:  MOVLB  0
05424:  CALL   27BE
05428:  MOVF   01,W
0542A:  ADDWF  55,F
0542C:  MOVF   02,W
0542E:  ADDWFC 56,F
.................... 	 
....................  
....................     i2c_start(); 
05430:  BSF    FC5.0
05432:  BTFSC  FC5.0
05434:  BRA    5432
05436:  CLRF   16
05438:  BTFSC  FF2.7
0543A:  BSF    16.7
0543C:  BCF    FF2.7
....................     i2c_write(0xa0);  
0543E:  MOVLW  A0
05440:  MOVLB  2
05442:  MOVWF  x23
05444:  MOVLB  0
05446:  CALL   1B28
0544A:  BTFSC  16.7
0544C:  BSF    FF2.7
....................     i2c_write(addr >> 8); 
0544E:  MOVFF  56,1A1
05452:  MOVLB  1
05454:  CLRF   xA2
05456:  CLRF   16
05458:  BTFSC  FF2.7
0545A:  BSF    16.7
0545C:  BCF    FF2.7
0545E:  MOVFF  56,223
05462:  MOVLB  0
05464:  CALL   1B28
05468:  BTFSC  16.7
0546A:  BSF    FF2.7
0546C:  CLRF   16
0546E:  BTFSC  FF2.7
05470:  BSF    16.7
05472:  BCF    FF2.7
....................     i2c_write(addr); 
05474:  MOVFF  55,223
05478:  CALL   1B28
0547C:  BTFSC  16.7
0547E:  BSF    FF2.7
....................     i2c_start(); 
05480:  BSF    FC5.1
05482:  BTFSC  FC5.1
05484:  BRA    5482
05486:  CLRF   16
05488:  BTFSC  FF2.7
0548A:  BSF    16.7
0548C:  BCF    FF2.7
....................     i2c_write (0xa1);  
0548E:  MOVLW  A1
05490:  MOVLB  2
05492:  MOVWF  x23
05494:  MOVLB  0
05496:  CALL   1B28
0549A:  BTFSC  16.7
0549C:  BSF    FF2.7
....................  
....................    	coordenada_x_msb=i2c_read(1); 
0549E:  MOVLW  01
054A0:  MOVWF  00
054A2:  CALL   2012
054A6:  MOVFF  01,19B
....................    	coordenada_x_lsb=i2c_read(1); 
054AA:  MOVLW  01
054AC:  MOVWF  00
054AE:  CALL   2012
054B2:  MOVFF  01,19C
....................    	coordenada_y_msb=i2c_read(1); 
054B6:  MOVLW  01
054B8:  MOVWF  00
054BA:  CALL   2012
054BE:  MOVFF  01,19D
....................    	coordenada_y_lsb=i2c_read(1); 
054C2:  MOVLW  01
054C4:  MOVWF  00
054C6:  CALL   2012
054CA:  MOVFF  01,19E
....................    	coordenada_z_msb=i2c_read(1); 
054CE:  MOVLW  01
054D0:  MOVWF  00
054D2:  CALL   2012
054D6:  MOVFF  01,19F
....................    	coordenada_z_lsb=i2c_read(0); 
054DA:  CLRF   00
054DC:  CALL   2012
054E0:  MOVFF  01,1A0
....................    	i2c_stop(); 
054E4:  BSF    FC5.2
054E6:  BTFSC  FC5.2
054E8:  BRA    54E6
....................    	ack=!ack; 
054EA:  BTG    1E.7
....................  
....................  
.................... 	coordenada_x_armazenado=make16(coordenada_x_msb,coordenada_x_lsb); 
054EC:  MOVFF  19B,2B
054F0:  MOVFF  19C,2A
.................... 	coordenada_y_armazenado=make16(coordenada_y_msb,coordenada_y_lsb); 
054F4:  MOVFF  19D,2D
054F8:  MOVFF  19E,2C
.................... 	coordenada_z_armazenado=make16(coordenada_z_msb,coordenada_z_lsb); 
054FC:  MOVFF  19F,2F
05500:  MOVFF  1A0,2E
....................  
.................... 	enable_interrupts(GLOBAL); 
05504:  MOVLW  C0
05506:  IORWF  FF2,F
05508:  RETURN 0
.................... 	 
.................... } 
....................  
....................  
.................... void grava_coordenada_na_eeprom(int passo,long int coordenada_x,long int coordenada_y,long int coordenada_z) 
.................... { 
.................... 	int y; 
....................  
.................... 	disable_interrupts(GLOBAL); 
*
07FF2:  BCF    FF2.6
07FF4:  BCF    FF2.7
07FF6:  BTFSC  FF2.7
07FF8:  BRA    7FF4
.................... 	//programa=0; 
.................... 	addr=((long)programa * 200) + 3; 
07FFA:  MOVLB  1
07FFC:  CLRF   xA2
07FFE:  MOVFF  29,1A1
08002:  MOVFF  1A2,215
08006:  MOVFF  29,214
0800A:  MOVLB  2
0800C:  CLRF   x17
0800E:  MOVLW  C8
08010:  MOVWF  x16
08012:  MOVLB  0
08014:  CALL   27BE
08018:  MOVLW  03
0801A:  MOVLB  1
0801C:  ADDWF  01,W
0801E:  MOVWF  55
08020:  MOVLW  00
08022:  ADDWFC 02,W
08024:  MOVWF  56
.................... 	addr=addr + ((long)passo * 12); 
08026:  CLRF   xA2
08028:  MOVFF  199,1A1
0802C:  MOVFF  1A2,215
08030:  MOVFF  199,214
08034:  MOVLB  2
08036:  CLRF   x17
08038:  MOVLW  0C
0803A:  MOVWF  x16
0803C:  MOVLB  0
0803E:  CALL   27BE
08042:  MOVF   01,W
08044:  ADDWF  55,F
08046:  MOVF   02,W
08048:  ADDWFC 56,F
....................  
.................... 	y = make8(coordenada_x,1);   
0804A:  MOVLB  1
0804C:  MOVFF  19B,1A0
.................... 	write_ext_eeprom(addr,y); 
08050:  MOVFF  56,215
08054:  MOVFF  55,214
08058:  MOVFF  1A0,216
0805C:  MOVLB  0
0805E:  CALL   1EE0
.................... 	addr++; 
08062:  INCF   55,F
08064:  BTFSC  FD8.2
08066:  INCF   56,F
....................  
.................... 	y = make8(coordenada_x,0);   
08068:  MOVLB  1
0806A:  MOVFF  19A,1A0
.................... 	write_ext_eeprom(addr,y); 
0806E:  MOVFF  56,215
08072:  MOVFF  55,214
08076:  MOVFF  1A0,216
0807A:  MOVLB  0
0807C:  CALL   1EE0
.................... 	addr++; 
08080:  INCF   55,F
08082:  BTFSC  FD8.2
08084:  INCF   56,F
....................  
.................... 	y = make8(coordenada_y,1);   
08086:  MOVLB  1
08088:  MOVFF  19D,1A0
.................... 	write_ext_eeprom(addr,y); 
0808C:  MOVFF  56,215
08090:  MOVFF  55,214
08094:  MOVFF  1A0,216
08098:  MOVLB  0
0809A:  CALL   1EE0
.................... 	addr++; 
0809E:  INCF   55,F
080A0:  BTFSC  FD8.2
080A2:  INCF   56,F
....................  
.................... 	y = make8(coordenada_y,0);   
080A4:  MOVLB  1
080A6:  MOVFF  19C,1A0
.................... 	write_ext_eeprom(addr,y); 
080AA:  MOVFF  56,215
080AE:  MOVFF  55,214
080B2:  MOVFF  1A0,216
080B6:  MOVLB  0
080B8:  CALL   1EE0
.................... 	addr++; 
080BC:  INCF   55,F
080BE:  BTFSC  FD8.2
080C0:  INCF   56,F
....................  
.................... 	y = make8(coordenada_z,1);   
080C2:  MOVLB  1
080C4:  MOVFF  19F,1A0
.................... 	write_ext_eeprom(addr,y); 
080C8:  MOVFF  56,215
080CC:  MOVFF  55,214
080D0:  MOVFF  1A0,216
080D4:  MOVLB  0
080D6:  CALL   1EE0
.................... 	addr++; 
080DA:  INCF   55,F
080DC:  BTFSC  FD8.2
080DE:  INCF   56,F
....................  
.................... 	y = make8(coordenada_z,0);   
080E0:  MOVLB  1
080E2:  MOVFF  19E,1A0
.................... 	write_ext_eeprom(addr,y); 
080E6:  MOVFF  56,215
080EA:  MOVFF  55,214
080EE:  MOVFF  1A0,216
080F2:  MOVLB  0
080F4:  CALL   1EE0
....................     enable_interrupts(GLOBAL); 
080F8:  MOVLW  C0
080FA:  IORWF  FF2,F
080FC:  GOTO   86CC (RETURN)
.................... } 
....................  
....................  
....................  
.................... void inicializa_interna_eeprom(void) 
.................... { 
....................  
.................... 	if(read_eeprom(0x00) == 0xaa) 
*
02168:  MOVFF  FF2,18B
0216C:  BCF    FF2.7
0216E:  CLRF   FAA
02170:  CLRF   FA9
02172:  BCF    FA6.6
02174:  BCF    FA6.7
02176:  BSF    FA6.0
02178:  MOVF   FA8,W
0217A:  MOVLB  1
0217C:  BTFSC  x8B.7
0217E:  BSF    FF2.7
02180:  SUBLW  AA
02182:  BNZ   21A0
.................... 	{ 
....................  
.................... 		programa = read_eeprom(0x02); 
02184:  MOVFF  FF2,18B
02188:  BCF    FF2.7
0218A:  CLRF   FAA
0218C:  MOVLW  02
0218E:  MOVWF  FA9
02190:  BCF    FA6.6
02192:  BCF    FA6.7
02194:  BSF    FA6.0
02196:  MOVF   FA8,W
02198:  BTFSC  x8B.7
0219A:  BSF    FF2.7
0219C:  MOVWF  29
....................  
....................  
.................... 	} 
0219E:  BRA    21F8
.................... 		else 
....................      		{  
.................... 			  	 programa = 0;	 
021A0:  CLRF   29
.................... 			 	 write_eeprom(0x02,programa);			 
021A2:  MOVF   FF2,W
021A4:  MOVWF  00
021A6:  BCF    FF2.7
021A8:  CLRF   FAA
021AA:  MOVLW  02
021AC:  MOVWF  FA9
021AE:  MOVFF  29,FA8
021B2:  BCF    FA6.6
021B4:  BCF    FA6.7
021B6:  BSF    FA6.2
021B8:  MOVLB  F
021BA:  MOVLW  55
021BC:  MOVWF  FA7
021BE:  MOVLW  AA
021C0:  MOVWF  FA7
021C2:  BSF    FA6.1
021C4:  BTFSC  FA6.1
021C6:  BRA    21C4
021C8:  BCF    FA6.2
021CA:  MOVF   00,W
021CC:  IORWF  FF2,F
.................... 			     write_eeprom(0x00,0xaa);	 
021CE:  MOVFF  FF2,00
021D2:  BCF    FF2.7
021D4:  CLRF   FAA
021D6:  CLRF   FA9
021D8:  MOVLW  AA
021DA:  MOVWF  FA8
021DC:  BCF    FA6.6
021DE:  BCF    FA6.7
021E0:  BSF    FA6.2
021E2:  MOVLW  55
021E4:  MOVWF  FA7
021E6:  MOVLW  AA
021E8:  MOVWF  FA7
021EA:  BSF    FA6.1
021EC:  BTFSC  FA6.1
021EE:  BRA    21EC
021F0:  BCF    FA6.2
021F2:  MOVF   00,W
021F4:  IORWF  FF2,F
021F6:  MOVLB  1
....................  
.................... 			} 
021F8:  MOVLB  0
021FA:  GOTO   B172 (RETURN)
....................  
.................... } 
....................  
....................  
.................... void salva_valores_debug_solda(void) 
*
027E0:  MOVLB  1
027E2:  CLRF   x8C
027E4:  CLRF   x8B
027E6:  CLRF   x8E
027E8:  CLRF   x8D
027EA:  CLRF   x90
027EC:  CLRF   x8F
*
02940:  CLRF   x0A
02942:  CLRF   x09
02944:  MOVWF  x0C
02946:  MOVLW  E3
02948:  MOVWF  x0B
0294A:  MOVLW  04
0294C:  MOVWF  x0E
0294E:  MOVLW  27
02950:  MOVWF  x0D
02952:  MOVLW  06
02954:  MOVWF  x10
02956:  MOVLW  0A
02958:  MOVWF  x0F
0295A:  MOVLW  07
0295C:  MOVWF  x12
0295E:  MOVLW  F7
02960:  MOVWF  x11
.................... { 
.................... 	long int contador_programa = 0; 
....................    	long int contador_passo    = 0; 
....................     long int  coordenada_x_debug = 0x0000; 
....................     long int  posicao_x_debug[20]={3572,3605,3740,3781,3706,3791,3423,3372}; 
*
027EE:  MOVLW  F4
027F0:  MOVWF  x91
027F2:  MOVLW  0D
027F4:  MOVWF  x92
027F6:  MOVLW  15
027F8:  MOVWF  x93
027FA:  MOVLW  0E
027FC:  MOVWF  x94
027FE:  MOVLW  9C
02800:  MOVWF  x95
02802:  MOVLW  0E
02804:  MOVWF  x96
02806:  MOVLW  C5
02808:  MOVWF  x97
0280A:  MOVLW  0E
0280C:  MOVWF  x98
0280E:  MOVLW  7A
02810:  MOVWF  x99
02812:  MOVLW  0E
02814:  MOVWF  x9A
02816:  MOVLW  CF
02818:  MOVWF  x9B
0281A:  MOVLW  0E
0281C:  MOVWF  x9C
0281E:  MOVLW  5F
02820:  MOVWF  x9D
02822:  MOVLW  0D
02824:  MOVWF  x9E
02826:  MOVLW  2C
02828:  MOVWF  x9F
0282A:  MOVLW  0D
0282C:  MOVWF  xA0
0282E:  CLRF   xA1
02830:  CLRF   xA2
02832:  CLRF   xA3
02834:  CLRF   xA4
02836:  CLRF   xA5
02838:  CLRF   xA6
0283A:  CLRF   xA7
0283C:  CLRF   xA8
0283E:  CLRF   xA9
02840:  CLRF   xAA
02842:  CLRF   xAB
02844:  CLRF   xAC
02846:  CLRF   xAD
02848:  CLRF   xAE
0284A:  CLRF   xAF
0284C:  CLRF   xB0
0284E:  CLRF   xB1
02850:  CLRF   xB2
02852:  CLRF   xB3
02854:  CLRF   xB4
02856:  CLRF   xB5
02858:  CLRF   xB6
0285A:  CLRF   xB7
0285C:  CLRF   xB8
....................     long int  posicao_y_debug[20]={4406,4406,2553,2553,2499,2499,2499,2499}; 
0285E:  MOVLW  36
02860:  MOVWF  xB9
02862:  MOVLW  11
02864:  MOVWF  xBA
02866:  MOVLW  36
02868:  MOVWF  xBB
0286A:  MOVLW  11
0286C:  MOVWF  xBC
0286E:  MOVLW  F9
02870:  MOVWF  xBD
02872:  MOVLW  09
02874:  MOVWF  xBE
02876:  MOVLW  F9
02878:  MOVWF  xBF
0287A:  MOVLW  09
0287C:  MOVWF  xC0
0287E:  MOVLW  C3
02880:  MOVWF  xC1
02882:  MOVLW  09
02884:  MOVWF  xC2
02886:  MOVLW  C3
02888:  MOVWF  xC3
0288A:  MOVLW  09
0288C:  MOVWF  xC4
0288E:  MOVLW  C3
02890:  MOVWF  xC5
02892:  MOVLW  09
02894:  MOVWF  xC6
02896:  MOVLW  C3
02898:  MOVWF  xC7
0289A:  MOVLW  09
0289C:  MOVWF  xC8
0289E:  CLRF   xC9
028A0:  CLRF   xCA
028A2:  CLRF   xCB
028A4:  CLRF   xCC
028A6:  CLRF   xCD
028A8:  CLRF   xCE
028AA:  CLRF   xCF
028AC:  CLRF   xD0
028AE:  CLRF   xD1
028B0:  CLRF   xD2
028B2:  CLRF   xD3
028B4:  CLRF   xD4
028B6:  CLRF   xD5
028B8:  CLRF   xD6
028BA:  CLRF   xD7
028BC:  CLRF   xD8
028BE:  CLRF   xD9
028C0:  CLRF   xDA
028C2:  CLRF   xDB
028C4:  CLRF   xDC
028C6:  CLRF   xDD
028C8:  CLRF   xDE
028CA:  CLRF   xDF
028CC:  CLRF   xE0
.................... 	long int  posicao_z_debug[20]={330,330,330,330,336,330,336,330}; 
028CE:  MOVLW  4A
028D0:  MOVWF  xE1
028D2:  MOVLW  01
028D4:  MOVWF  xE2
028D6:  MOVLW  4A
028D8:  MOVWF  xE3
028DA:  MOVLW  01
028DC:  MOVWF  xE4
028DE:  MOVLW  4A
028E0:  MOVWF  xE5
028E2:  MOVLW  01
028E4:  MOVWF  xE6
028E6:  MOVLW  4A
028E8:  MOVWF  xE7
028EA:  MOVLW  01
028EC:  MOVWF  xE8
028EE:  MOVLW  50
028F0:  MOVWF  xE9
028F2:  MOVLW  01
028F4:  MOVWF  xEA
028F6:  MOVLW  4A
028F8:  MOVWF  xEB
028FA:  MOVLW  01
028FC:  MOVWF  xEC
028FE:  MOVLW  50
02900:  MOVWF  xED
02902:  MOVLW  01
02904:  MOVWF  xEE
02906:  MOVLW  4A
02908:  MOVWF  xEF
0290A:  MOVLW  01
0290C:  MOVWF  xF0
0290E:  CLRF   xF1
02910:  CLRF   xF2
02912:  CLRF   xF3
02914:  CLRF   xF4
02916:  CLRF   xF5
02918:  CLRF   xF6
0291A:  CLRF   xF7
0291C:  CLRF   xF8
0291E:  CLRF   xF9
02920:  CLRF   xFA
02922:  CLRF   xFB
02924:  CLRF   xFC
02926:  CLRF   xFD
02928:  CLRF   xFE
0292A:  CLRF   xFF
0292C:  MOVLB  2
0292E:  CLRF   x00
02930:  CLRF   x01
02932:  CLRF   x02
02934:  CLRF   x03
02936:  CLRF   x04
02938:  CLRF   x05
0293A:  CLRF   x06
0293C:  CLRF   x07
0293E:  CLRF   x08
....................  
....................     //3089,3122,3257,3298,3223,3308,2940,2889 
....................  
....................  
....................     long int  placa1_deslocamento = 0; 
....................     long int  placa2_deslocamento = 483; 
....................     long int  placa3_deslocamento = 1063; 
....................     long int  placa4_deslocamento = 1546; 
....................     long int  placa5_deslocamento = 2039; 
....................     int y; 
....................  
.................... // placa1 = x:3603,3571,3782,3747,3722,3797,3446,3373 (0) 
.................... //			y:4400,4400,2538,2538,2487,2487,2487,2487 
.................... // placa2 = x:3120,3088,3291,3264,3239,3314,3963,2890 (483) 
.................... //          y:4400,4400,2538,2538,2487,2487,2487,2487 
.................... // placa3 = x:2540,2508,							  (1063)	 
.................... //          y:4400,4400,2538,2538,2487,2487,2487,2487 
.................... // placa4 = x:2057,2022								  (1546) 	 
.................... //          y:4400,4400,2538,2538,2487,2487,2487,2487 
.................... // placa5 = x:1564,1530                               (2039) 
.................... //          y:4400,4400,2538,2538,2487,2487,2487,2487 
....................  
....................  
....................  
....................  
....................  
.................... 	for (contador_programa = 15;contador_programa  < 20;contador_programa++) 
*
02962:  MOVLB  1
02964:  CLRF   x8C
02966:  MOVLW  0F
02968:  MOVWF  x8B
0296A:  MOVF   x8C,F
0296C:  BTFSS  FD8.2
0296E:  BRA    2B96
02970:  MOVF   x8B,W
02972:  SUBLW  13
02974:  BTFSS  FD8.0
02976:  BRA    2B96
.................... 	{ 
.................... 			//addr=((long)contador_programa  * 200) + 3; 
....................  
.................... 		for (contador_passo =0;contador_passo  < 8;contador_passo++) 
02978:  CLRF   x8E
0297A:  CLRF   x8D
0297C:  MOVF   x8E,F
0297E:  BTFSS  FD8.2
02980:  BRA    2B8E
02982:  MOVF   x8D,W
02984:  SUBLW  07
02986:  BTFSS  FD8.0
02988:  BRA    2B8E
.................... 			{ 
....................  
.................... 				coordenada_x_debug = posicao_x_debug[contador_passo]; 
0298A:  BCF    FD8.0
0298C:  RLCF   x8D,W
0298E:  MOVWF  02
02990:  RLCF   x8E,W
02992:  MOVWF  03
02994:  MOVF   02,W
02996:  ADDLW  91
02998:  MOVWF  FE9
0299A:  MOVLW  01
0299C:  ADDWFC 03,W
0299E:  MOVWF  FEA
029A0:  MOVFF  FEC,190
029A4:  MOVF   FED,F
029A6:  MOVFF  FEF,18F
.................... 				 
.................... 				//if(contador_programa == 15)coordenada_x_debug += placa1_deslocamento; 
.................... 				if(contador_programa == 16)coordenada_x_debug -= placa2_deslocamento; 
029AA:  MOVF   x8B,W
029AC:  SUBLW  10
029AE:  BNZ   29C4
029B0:  MOVF   x8C,F
029B2:  BNZ   29C4
029B4:  MOVLB  2
029B6:  MOVF   x0B,W
029B8:  MOVLB  1
029BA:  SUBWF  x8F,F
029BC:  MOVLB  2
029BE:  MOVF   x0C,W
029C0:  MOVLB  1
029C2:  SUBWFB x90,F
.................... 				if(contador_programa == 17)coordenada_x_debug -= placa3_deslocamento; 
029C4:  MOVF   x8B,W
029C6:  SUBLW  11
029C8:  BNZ   29DE
029CA:  MOVF   x8C,F
029CC:  BNZ   29DE
029CE:  MOVLB  2
029D0:  MOVF   x0D,W
029D2:  MOVLB  1
029D4:  SUBWF  x8F,F
029D6:  MOVLB  2
029D8:  MOVF   x0E,W
029DA:  MOVLB  1
029DC:  SUBWFB x90,F
.................... 				if(contador_programa == 18)coordenada_x_debug -= placa4_deslocamento; 
029DE:  MOVF   x8B,W
029E0:  SUBLW  12
029E2:  BNZ   29F8
029E4:  MOVF   x8C,F
029E6:  BNZ   29F8
029E8:  MOVLB  2
029EA:  MOVF   x0F,W
029EC:  MOVLB  1
029EE:  SUBWF  x8F,F
029F0:  MOVLB  2
029F2:  MOVF   x10,W
029F4:  MOVLB  1
029F6:  SUBWFB x90,F
.................... 				if(contador_programa == 19)coordenada_x_debug -= placa5_deslocamento; 
029F8:  MOVF   x8B,W
029FA:  SUBLW  13
029FC:  BNZ   2A12
029FE:  MOVF   x8C,F
02A00:  BNZ   2A12
02A02:  MOVLB  2
02A04:  MOVF   x11,W
02A06:  MOVLB  1
02A08:  SUBWF  x8F,F
02A0A:  MOVLB  2
02A0C:  MOVF   x12,W
02A0E:  MOVLB  1
02A10:  SUBWFB x90,F
....................  
....................  
.................... 				addr=((long)contador_programa  * 200) + 3; 
02A12:  MOVFF  18C,215
02A16:  MOVFF  18B,214
02A1A:  MOVLB  2
02A1C:  CLRF   x17
02A1E:  MOVLW  C8
02A20:  MOVWF  x16
02A22:  MOVLB  0
02A24:  RCALL  27BE
02A26:  MOVLW  03
02A28:  MOVLB  2
02A2A:  ADDWF  01,W
02A2C:  MOVWF  55
02A2E:  MOVLW  00
02A30:  ADDWFC 02,W
02A32:  MOVWF  56
.................... 		    	addr=addr + ((long)contador_passo  * 12); 
02A34:  MOVFF  18E,215
02A38:  MOVFF  18D,214
02A3C:  CLRF   x17
02A3E:  MOVLW  0C
02A40:  MOVWF  x16
02A42:  MOVLB  0
02A44:  RCALL  27BE
02A46:  MOVF   01,W
02A48:  ADDWF  55,F
02A4A:  MOVF   02,W
02A4C:  ADDWFC 56,F
....................  
.................... 				y = make8(coordenada_x_debug,1);   
02A4E:  MOVFF  190,213
02A52:  MOVLB  2
.................... 				write_ext_eeprom(addr,y); 
02A54:  MOVFF  56,215
02A58:  MOVFF  55,214
02A5C:  MOVFF  213,216
02A60:  MOVLB  0
02A62:  CALL   1EE0
.................... 				addr++; 
02A66:  INCF   55,F
02A68:  BTFSC  FD8.2
02A6A:  INCF   56,F
....................  
.................... 				y = make8(coordenada_x_debug,0);   
02A6C:  MOVFF  18F,213
02A70:  MOVLB  2
.................... 				write_ext_eeprom(addr,y); 
02A72:  MOVFF  56,215
02A76:  MOVFF  55,214
02A7A:  MOVFF  213,216
02A7E:  MOVLB  0
02A80:  CALL   1EE0
.................... 				addr++; 
02A84:  INCF   55,F
02A86:  BTFSC  FD8.2
02A88:  INCF   56,F
....................  
.................... 				y = make8(posicao_y_debug[contador_passo],1);   
02A8A:  BCF    FD8.0
02A8C:  MOVLB  1
02A8E:  RLCF   x8D,W
02A90:  MOVWF  02
02A92:  RLCF   x8E,W
02A94:  MOVWF  03
02A96:  MOVF   02,W
02A98:  ADDLW  B9
02A9A:  MOVWF  FE9
02A9C:  MOVLW  01
02A9E:  ADDWFC 03,W
02AA0:  MOVWF  FEA
02AA2:  MOVFF  FEC,215
02AA6:  MOVF   FED,F
02AA8:  MOVFF  FEF,214
02AAC:  MOVLB  2
02AAE:  MOVFF  215,213
.................... 				write_ext_eeprom(addr,y); 
02AB2:  MOVFF  56,215
02AB6:  MOVFF  55,214
02ABA:  MOVFF  213,216
02ABE:  MOVLB  0
02AC0:  CALL   1EE0
.................... 				addr++; 
02AC4:  INCF   55,F
02AC6:  BTFSC  FD8.2
02AC8:  INCF   56,F
....................  
.................... 				y = make8(posicao_y_debug[contador_passo],0);   
02ACA:  BCF    FD8.0
02ACC:  MOVLB  1
02ACE:  RLCF   x8D,W
02AD0:  MOVWF  02
02AD2:  RLCF   x8E,W
02AD4:  MOVWF  03
02AD6:  MOVF   02,W
02AD8:  ADDLW  B9
02ADA:  MOVWF  FE9
02ADC:  MOVLW  01
02ADE:  ADDWFC 03,W
02AE0:  MOVWF  FEA
02AE2:  MOVFF  FEC,215
02AE6:  MOVF   FED,F
02AE8:  MOVFF  FEF,214
02AEC:  MOVLB  2
02AEE:  MOVFF  214,213
.................... 				write_ext_eeprom(addr,y); 
02AF2:  MOVFF  56,215
02AF6:  MOVFF  55,214
02AFA:  MOVFF  213,216
02AFE:  MOVLB  0
02B00:  CALL   1EE0
.................... 				addr++; 
02B04:  INCF   55,F
02B06:  BTFSC  FD8.2
02B08:  INCF   56,F
....................  
.................... 				y = make8(posicao_z_debug[contador_passo],1);   
02B0A:  BCF    FD8.0
02B0C:  MOVLB  1
02B0E:  RLCF   x8D,W
02B10:  MOVWF  02
02B12:  RLCF   x8E,W
02B14:  MOVWF  03
02B16:  MOVF   02,W
02B18:  ADDLW  E1
02B1A:  MOVWF  FE9
02B1C:  MOVLW  01
02B1E:  ADDWFC 03,W
02B20:  MOVWF  FEA
02B22:  MOVFF  FEC,215
02B26:  MOVF   FED,F
02B28:  MOVFF  FEF,214
02B2C:  MOVLB  2
02B2E:  MOVFF  215,213
.................... 				write_ext_eeprom(addr,y); 
02B32:  MOVFF  56,215
02B36:  MOVFF  55,214
02B3A:  MOVFF  213,216
02B3E:  MOVLB  0
02B40:  CALL   1EE0
.................... 				addr++; 
02B44:  INCF   55,F
02B46:  BTFSC  FD8.2
02B48:  INCF   56,F
....................  
.................... 				y = make8(posicao_z_debug[contador_passo],0);   
02B4A:  BCF    FD8.0
02B4C:  MOVLB  1
02B4E:  RLCF   x8D,W
02B50:  MOVWF  02
02B52:  RLCF   x8E,W
02B54:  MOVWF  03
02B56:  MOVF   02,W
02B58:  ADDLW  E1
02B5A:  MOVWF  FE9
02B5C:  MOVLW  01
02B5E:  ADDWFC 03,W
02B60:  MOVWF  FEA
02B62:  MOVFF  FEC,215
02B66:  MOVF   FED,F
02B68:  MOVFF  FEF,214
02B6C:  MOVLB  2
02B6E:  MOVFF  214,213
.................... 				write_ext_eeprom(addr,y);	 
02B72:  MOVFF  56,215
02B76:  MOVFF  55,214
02B7A:  MOVFF  213,216
02B7E:  MOVLB  0
02B80:  CALL   1EE0
02B84:  MOVLB  1
02B86:  INCF   x8D,F
02B88:  BTFSC  FD8.2
02B8A:  INCF   x8E,F
02B8C:  BRA    297C
.................... 	 
.................... 			} 
02B8E:  INCF   x8B,F
02B90:  BTFSC  FD8.2
02B92:  INCF   x8C,F
02B94:  BRA    296A
....................  
.................... } 
02B96:  MOVLB  0
02B98:  GOTO   B674 (RETURN)
....................  
....................  
.................... } 
....................  
....................  
....................  
.................... void main() 
*
0AF68:  CLRF   FF8
0AF6A:  BCF    FD0.7
0AF6C:  BSF    07.7
0AF6E:  BSF    F94.3
0AF70:  BSF    F94.4
0AF72:  MOVLW  31
0AF74:  MOVWF  FC8
0AF76:  MOVLW  28
0AF78:  MOVWF  FC6
0AF7A:  BSF    FC7.7
0AF7C:  BCF    FC7.6
0AF7E:  MOVLW  01
0AF80:  MOVWF  1D
0AF82:  BCF    1E.0
0AF84:  BCF    1E.1
0AF86:  BCF    1E.2
0AF88:  CLRF   20
0AF8A:  CLRF   1F
0AF8C:  CLRF   22
0AF8E:  CLRF   21
0AF90:  MOVLW  14
0AF92:  MOVWF  25
0AF94:  MOVLW  10
0AF96:  MOVWF  26
0AF98:  MOVLW  01
0AF9A:  MOVWF  27
0AF9C:  CLRF   54
0AF9E:  MOVLB  1
0AFA0:  CLRF   x49
0AFA2:  MOVLW  FA
0AFA4:  MOVWF  x48
0AFA6:  CLRF   x4B
0AFA8:  MOVLW  96
0AFAA:  MOVWF  x4A
0AFAC:  MOVLW  01
0AFAE:  MOVWF  x74
0AFB0:  MOVWF  x75
0AFB2:  CLRF   x81
0AFB4:  CLRF   x85
0AFB6:  MOVF   FC1,W
0AFB8:  ANDLW  C0
0AFBA:  IORLW  0F
0AFBC:  MOVWF  FC1
0AFBE:  MOVLW  07
0AFC0:  MOVWF  FB4
0AFC2:  BRA    B0D4
0AFC4:  DATA 02,00
0AFC6:  DATA 17,00
0AFC8:  DATA 00,F0
0AFCA:  DATA 00,58
0AFCC:  DATA BF,0D
0AFCE:  DATA DE,0D
0AFD0:  DATA 6C,0E
0AFD2:  DATA 90,0E
0AFD4:  DATA 4F,0E
0AFD6:  DATA A0,0E
0AFD8:  DATA 37,0D
0AFDA:  DATA FD,0C
0AFDC:  DATA A3,0F
0AFDE:  DATA C9,0F
0AFE0:  DATA 57,10
0AFE2:  DATA 76,10
0AFE4:  DATA 36,10
0AFE6:  DATA 87,10
0AFE8:  DATA 24,0F
0AFEA:  DATA E3,0E
0AFEC:  DATA 20,10
0AFEE:  DATA 13,0E
0AFF0:  DATA 13,0E
0AFF2:  DATA 13,0E
0AFF4:  DATA 32,11
0AFF6:  DATA 32,11
0AFF8:  DATA F5,09
0AFFA:  DATA F5,09
0AFFC:  DATA BD,09
0AFFE:  DATA BD,09
0B000:  DATA BD,09
0B002:  DATA BD,09
0B004:  DATA 32,11
0B006:  DATA 32,11
0B008:  DATA F5,09
0B00A:  DATA F5,09
0B00C:  DATA BD,09
0B00E:  DATA BD,09
0B010:  DATA BD,09
0B012:  DATA BD,09
0B014:  DATA 8D,11
0B016:  DATA 8D,11
0B018:  DATA 8D,11
0B01A:  DATA A5,0D
0B01C:  DATA 2C,01
0B01E:  DATA 2C,01
0B020:  DATA 2C,01
0B022:  DATA 2C,01
0B024:  DATA 2C,01
0B026:  DATA 2C,01
0B028:  DATA 2C,01
0B02A:  DATA 2C,01
0B02C:  DATA 2C,01
0B02E:  DATA 2C,01
0B030:  DATA 2C,01
0B032:  DATA 2C,01
0B034:  DATA 2C,01
0B036:  DATA 2C,01
0B038:  DATA 2C,01
0B03A:  DATA 2C,01
0B03C:  DATA 2C,01
0B03E:  DATA 2C,01
0B040:  DATA 2C,01
0B042:  DATA 2C,01
0B044:  DATA FE,02
0B046:  DATA 20,03
0B048:  DATA A7,03
0B04A:  DATA CE,03
0B04C:  DATA 82,03
0B04E:  DATA D3,03
0B050:  DATA 7B,02
0B052:  DATA 28,02
0B054:  DATA 12,01
0B056:  DATA 2E,01
0B058:  DATA BB,01
0B05A:  DATA DE,01
0B05C:  DATA 9A,01
0B05E:  DATA E0,01
0B060:  DATA 85,00
0B062:  DATA 4C,00
0B064:  DATA 80,02
0B066:  DATA 69,00
0B068:  DATA 32,00
0B06A:  DATA 32,00
0B06C:  DATA 87,0E
0B06E:  DATA 87,0E
0B070:  DATA 46,07
0B072:  DATA 46,07
0B074:  DATA 12,07
0B076:  DATA 12,07
0B078:  DATA 12,07
0B07A:  DATA 12,07
0B07C:  DATA 87,0E
0B07E:  DATA 87,0E
0B080:  DATA 4B,07
0B082:  DATA 4B,07
0B084:  DATA 12,07
0B086:  DATA 12,07
0B088:  DATA 12,07
0B08A:  DATA 12,07
0B08C:  DATA 28,0E
0B08E:  DATA 28,0E
0B090:  DATA 28,0E
0B092:  DATA 54,0B
0B094:  DATA 24,01
0B096:  DATA 24,01
0B098:  DATA 24,01
0B09A:  DATA 24,01
0B09C:  DATA 24,01
0B09E:  DATA 24,01
0B0A0:  DATA 24,01
0B0A2:  DATA 24,01
0B0A4:  DATA 24,01
0B0A6:  DATA 24,01
0B0A8:  DATA 24,01
0B0AA:  DATA 24,01
0B0AC:  DATA 24,01
0B0AE:  DATA 24,01
0B0B0:  DATA 24,01
0B0B2:  DATA 24,01
0B0B4:  DATA 24,01
0B0B6:  DATA 24,01
0B0B8:  DATA 24,01
0B0BA:  DATA 24,01
0B0BC:  DATA 04,41
0B0BE:  DATA 4C,00
0B0C0:  DATA 04,80
0B0C2:  DATA 01,02
0B0C4:  DATA 01,02
0B0C6:  DATA 10,C0
0B0C8:  DATA 00,04
0B0CA:  DATA 80,01
0B0CC:  DATA 02,01
0B0CE:  DATA 02,0C
0B0D0:  DATA C0,00
0B0D2:  DATA 00,00
0B0D4:  MOVLW  00
0B0D6:  MOVWF  FF8
0B0D8:  MOVLW  AF
0B0DA:  MOVWF  FF7
0B0DC:  MOVLW  C4
0B0DE:  MOVWF  FF6
0B0E0:  TBLRD*+
0B0E2:  MOVF   FF5,W
0B0E4:  MOVWF  00
0B0E6:  XORLW  00
0B0E8:  BZ    B110
0B0EA:  TBLRD*+
0B0EC:  MOVF   FF5,W
0B0EE:  MOVWF  01
0B0F0:  BTFSC  FE8.7
0B0F2:  BRA    B0FE
0B0F4:  ANDLW  0F
0B0F6:  MOVWF  FEA
0B0F8:  TBLRD*+
0B0FA:  MOVFF  FF5,FE9
0B0FE:  BTFSC  01.6
0B100:  TBLRD*+
0B102:  BTFSS  01.6
0B104:  TBLRD*+
0B106:  MOVFF  FF5,FEE
0B10A:  DCFSNZ 00,F
0B10C:  BRA    B0E0
0B10E:  BRA    B102
0B110:  CLRF   FF8
.................... { 
....................  	setup_adc		(ADC_OFF); 
0B112:  BCF    FC2.0
.................... 	setup_ccp1		(CCP_OFF); 
0B114:  MOVLW  F0
0B116:  ANDWF  FBD,F
.................... 	setup_ccp2		(CCP_OFF); 
0B118:  ANDWF  FBA,F
.................... 	disable_interrupts(GLOBAL); 
0B11A:  BCF    FF2.6
0B11C:  BCF    FF2.7
0B11E:  BTFSC  FF2.7
0B120:  BRA    B11C
.................... 	setup_psp		(PSP_DISABLED); 
0B122:  BCF    F96.4
.................... 	output_low(step_y);	 
0B124:  BCF    F94.2
0B126:  BCF    F8B.2
.................... 	output_low(dir_y); 
0B128:  BCF    F94.1
0B12A:  BCF    F8B.1
.................... 	output_high(enable_y);	 
0B12C:  BCF    F94.0
0B12E:  BSF    F8B.0
.................... 	output_low(step_x); 
0B130:  BCF    F95.2
0B132:  BCF    F8C.2
.................... 	output_low(dir_x);	 
0B134:  BCF    F95.1
0B136:  BCF    F8C.1
.................... 	output_high(enable_x); 
0B138:  BCF    F95.0
0B13A:  BSF    F8C.0
.................... 	output_low(step_z);	 
0B13C:  BCF    F92.5
0B13E:  BCF    F89.5
.................... 	output_low(dir_z); 
0B140:  BCF    F92.4
0B142:  BCF    F89.4
.................... 	output_high(enable_z);	 
0B144:  BCF    F92.3
0B146:  BSF    F89.3
.................... 	output_low(step_flip); 
0B148:  BCF    F96.2
0B14A:  BCF    F8D.2
.................... 	output_low(dir_flip);	 
0B14C:  BCF    F96.1
0B14E:  BCF    F8D.1
.................... 	output_high(enable_flip); 
0B150:  BCF    F96.0
0B152:  BSF    F8D.0
....................   	inicializa_display(); 
0B154:  MOVLB  0
0B156:  GOTO   1DC2
.................... 	Init_Keyboard(); 
0B15A:  GOTO   1E28
.................... 	Init_Sensores_porta1(); 
0B15E:  GOTO   1E6C
....................     Init_saidas(); 
0B162:  GOTO   1E8E
.................... 	desaciona_todas_saidas(); 
0B166:  CALL   1EB0
....................     init_ext_eeprom();  
0B16A:  GOTO   20C4
....................     inicializa_interna_eeprom(); 
0B16E:  GOTO   2168
....................  
.................... 	if(Teclado() == F1) 
0B172:  CALL   2344
0B176:  MOVF   01,W
0B178:  SUBLW  0A
0B17A:  BNZ   B1D4
....................   	{ 
....................  
.................... 	     write_ext_eeprom(0x0000,0x00); 
0B17C:  MOVLB  2
0B17E:  CLRF   x15
0B180:  CLRF   x14
0B182:  CLRF   x16
0B184:  MOVLB  0
0B186:  CALL   1EE0
....................     	 delay_ms(10); 
0B18A:  MOVLW  0A
0B18C:  MOVLB  2
0B18E:  MOVWF  x17
0B190:  MOVLB  0
0B192:  CALL   1D50
....................      	 printf(lcd_putc,"\f"); //limpa display 
0B196:  MOVLW  0C
0B198:  MOVLB  1
0B19A:  MOVWF  xA4
0B19C:  MOVLB  0
0B19E:  CALL   2586
....................    		 printf(lcd_putc," VALORES DEFAULT   \n\r"); 
0B1A2:  MOVLW  92
0B1A4:  MOVWF  FF6
0B1A6:  MOVLW  1C
0B1A8:  MOVWF  FF7
0B1AA:  CALL   25DA
.................... 	 	 printf(lcd_putc,"   RESTAURADOS     \n\r"); 
0B1AE:  MOVLW  A8
0B1B0:  MOVWF  FF6
0B1B2:  MOVLW  1C
0B1B4:  MOVWF  FF7
0B1B6:  CALL   25DA
.................... 	 	 delay_ms(500); 
0B1BA:  MOVLW  02
0B1BC:  MOVLB  1
0B1BE:  MOVWF  x8B
0B1C0:  MOVLW  FA
0B1C2:  MOVLB  2
0B1C4:  MOVWF  x17
0B1C6:  MOVLB  0
0B1C8:  CALL   1D50
0B1CC:  MOVLB  1
0B1CE:  DECFSZ x8B,F
0B1D0:  BRA    B1C0
0B1D2:  MOVLB  0
....................   
....................   	} 
....................  
....................  
....................    	printf(lcd_putc,"\f"); //limpa display 
0B1D4:  MOVLW  0C
0B1D6:  MOVLB  1
0B1D8:  MOVWF  xA4
0B1DA:  MOVLB  0
0B1DC:  CALL   2586
....................    	printf(lcd_putc,"INSTITUTO  ICTS   \n\r"); 
0B1E0:  MOVLW  BE
0B1E2:  MOVWF  FF6
0B1E4:  MOVLW  1C
0B1E6:  MOVWF  FF7
0B1E8:  CALL   25DA
.................... 	printf(lcd_putc,"TECNOLOGIA   EM   \n\r"); 
0B1EC:  MOVLW  D4
0B1EE:  MOVWF  FF6
0B1F0:  MOVLW  1C
0B1F2:  MOVWF  FF7
0B1F4:  CALL   25DA
.................... 	printf(lcd_putc,"    SOFTWARE      \n\r"); 
0B1F8:  MOVLW  EA
0B1FA:  MOVWF  FF6
0B1FC:  MOVLW  1C
0B1FE:  MOVWF  FF7
0B200:  CALL   25DA
.................... 	delay_ms(1000); 
0B204:  MOVLW  04
0B206:  MOVLB  1
0B208:  MOVWF  x8B
0B20A:  MOVLW  FA
0B20C:  MOVLB  2
0B20E:  MOVWF  x17
0B210:  MOVLB  0
0B212:  CALL   1D50
0B216:  MOVLB  1
0B218:  DECFSZ x8B,F
0B21A:  BRA    B20A
....................     Tela_Inicial(); 
0B21C:  MOVLB  0
0B21E:  CALL   26A2
....................   	contador_step_x =    0x0000; 
0B222:  MOVLB  1
0B224:  CLRF   x79
0B226:  CLRF   x78
....................  	contador_step_y =    0x0000; 
0B228:  CLRF   x7B
0B22A:  CLRF   x7A
....................  	contador_step_flip = 0x0000; 
0B22C:  CLRF   x7D
0B22E:  CLRF   x7C
....................     contador_step_z =    0x0000; 
0B230:  CLRF   x7F
0B232:  CLRF   x7E
.................... 	desaciona_mecanismo_de_entrada(); 
0B234:  MOVLB  0
0B236:  CALL   2708
.................... 	desaciona_mecanismo_de_saida(); 
0B23A:  CALL   2764
....................   
....................  
....................     if(read_ext_eeprom(0x0000) != 0xAA) 
0B23E:  MOVLB  1
0B240:  CLRF   x8D
0B242:  CLRF   x8C
0B244:  MOVLB  0
0B246:  CALL   202E
0B24A:  MOVF   01,W
0B24C:  SUBLW  AA
0B24E:  BTFSC  FD8.2
0B250:  BRA    B670
.................... 	 { 
.................... 		long int contador_programa = 0; 
....................     	long int contador_passo    = 0; 
....................     	int y; 
0B252:  MOVLB  1
0B254:  CLRF   x87
0B256:  CLRF   x86
0B258:  CLRF   x89
0B25A:  CLRF   x88
....................  
.................... 		tem_programa	  = 0xAA; 
0B25C:  MOVLW  AA
0B25E:  MOVWF  31
.................... 		steps_armazenados =   20; 
0B260:  MOVLW  14
0B262:  MOVWF  30
.................... 	    n_placas          =    5; 
0B264:  MOVLW  05
0B266:  MOVWF  28
.................... 		 
.................... 		for (contador_programa =0;contador_programa  < n_programas;contador_programa++) 
0B268:  CLRF   x87
0B26A:  CLRF   x86
0B26C:  MOVF   x87,F
0B26E:  BTFSS  FD8.2
0B270:  BRA    B66E
0B272:  MOVF   25,W
0B274:  SUBWF  x86,W
0B276:  BTFSC  FD8.0
0B278:  BRA    B66E
.................... 		{ 
.................... 			addr=(long)contador_programa*200; 
0B27A:  MOVFF  187,215
0B27E:  MOVFF  186,214
0B282:  MOVLB  2
0B284:  CLRF   x17
0B286:  MOVLW  C8
0B288:  MOVWF  x16
0B28A:  MOVLB  0
0B28C:  CALL   27BE
0B290:  MOVFF  02,56
0B294:  MOVFF  01,55
....................   			write_ext_eeprom(addr,tem_programa);	   //grava tem programa 
0B298:  MOVFF  56,215
0B29C:  MOVFF  55,214
0B2A0:  MOVFF  31,216
0B2A4:  CALL   1EE0
....................   			addr++; 
0B2A8:  INCF   55,F
0B2AA:  BTFSC  FD8.2
0B2AC:  INCF   56,F
....................   			write_ext_eeprom(addr,steps_armazenados);  //grava numero de passos contido no programa 
0B2AE:  MOVFF  56,215
0B2B2:  MOVFF  55,214
0B2B6:  MOVFF  30,216
0B2BA:  CALL   1EE0
....................   			addr++;				  
0B2BE:  INCF   55,F
0B2C0:  BTFSC  FD8.2
0B2C2:  INCF   56,F
....................   			write_ext_eeprom(addr,n_placas);		   //grava n_placas 
0B2C4:  MOVFF  56,215
0B2C8:  MOVFF  55,214
0B2CC:  MOVFF  28,216
0B2D0:  CALL   1EE0
....................   			addr++;  
0B2D4:  INCF   55,F
0B2D6:  BTFSC  FD8.2
0B2D8:  INCF   56,F
....................  
.................... 			for (contador_passo =0;contador_passo  < steps_armazenados;contador_passo++) 
0B2DA:  MOVLB  1
0B2DC:  CLRF   x89
0B2DE:  CLRF   x88
0B2E0:  MOVF   x89,F
0B2E2:  BTFSS  FD8.2
0B2E4:  BRA    B666
0B2E6:  MOVF   30,W
0B2E8:  SUBWF  x88,W
0B2EA:  BTFSC  FD8.0
0B2EC:  BRA    B666
.................... 			{ 
.................... 				if(n_maquina == 1) 
0B2EE:  DECFSZ 1D,W
0B2F0:  BRA    B4A4
.................... 				{ 
.................... 					addr=((long)contador_programa * 200) + 3; 
0B2F2:  MOVFF  187,215
0B2F6:  MOVFF  186,214
0B2FA:  MOVLB  2
0B2FC:  CLRF   x17
0B2FE:  MOVLW  C8
0B300:  MOVWF  x16
0B302:  MOVLB  0
0B304:  CALL   27BE
0B308:  MOVLW  03
0B30A:  MOVLB  1
0B30C:  ADDWF  01,W
0B30E:  MOVWF  55
0B310:  MOVLW  00
0B312:  ADDWFC 02,W
0B314:  MOVWF  56
.................... 		    		addr=addr + ((long)contador_passo  * 12); 
0B316:  MOVFF  189,215
0B31A:  MOVFF  188,214
0B31E:  MOVLB  2
0B320:  CLRF   x17
0B322:  MOVLW  0C
0B324:  MOVWF  x16
0B326:  MOVLB  0
0B328:  CALL   27BE
0B32C:  MOVF   01,W
0B32E:  ADDWF  55,F
0B330:  MOVF   02,W
0B332:  ADDWFC 56,F
....................  
.................... 					y = make8(posicao_x[contador_passo],1);   
0B334:  BCF    FD8.0
0B336:  MOVLB  1
0B338:  RLCF   x88,W
0B33A:  MOVWF  02
0B33C:  RLCF   x89,W
0B33E:  MOVWF  03
0B340:  MOVF   02,W
0B342:  ADDLW  58
0B344:  MOVWF  FE9
0B346:  MOVLW  00
0B348:  ADDWFC 03,W
0B34A:  MOVWF  FEA
0B34C:  MOVFF  FEC,18C
0B350:  MOVF   FED,F
0B352:  MOVFF  FEF,18B
0B356:  MOVFF  18C,18A
.................... 					write_ext_eeprom(addr,y); 
0B35A:  MOVFF  56,215
0B35E:  MOVFF  55,214
0B362:  MOVFF  18A,216
0B366:  MOVLB  0
0B368:  CALL   1EE0
.................... 					addr++;	 
0B36C:  INCF   55,F
0B36E:  BTFSC  FD8.2
0B370:  INCF   56,F
....................  
.................... 					y = make8(posicao_x[contador_passo],0);   
0B372:  BCF    FD8.0
0B374:  MOVLB  1
0B376:  RLCF   x88,W
0B378:  MOVWF  02
0B37A:  RLCF   x89,W
0B37C:  MOVWF  03
0B37E:  MOVF   02,W
0B380:  ADDLW  58
0B382:  MOVWF  FE9
0B384:  MOVLW  00
0B386:  ADDWFC 03,W
0B388:  MOVWF  FEA
0B38A:  MOVFF  FEC,18C
0B38E:  MOVF   FED,F
0B390:  MOVFF  FEF,18B
0B394:  MOVFF  18B,18A
.................... 					write_ext_eeprom(addr,y); 
0B398:  MOVFF  56,215
0B39C:  MOVFF  55,214
0B3A0:  MOVFF  18A,216
0B3A4:  MOVLB  0
0B3A6:  CALL   1EE0
.................... 					addr++;	 
0B3AA:  INCF   55,F
0B3AC:  BTFSC  FD8.2
0B3AE:  INCF   56,F
....................  
.................... 					y = make8(posicao_y[contador_passo],1);   
0B3B0:  BCF    FD8.0
0B3B2:  MOVLB  1
0B3B4:  RLCF   x88,W
0B3B6:  MOVWF  02
0B3B8:  RLCF   x89,W
0B3BA:  MOVWF  03
0B3BC:  MOVF   02,W
0B3BE:  ADDLW  80
0B3C0:  MOVWF  FE9
0B3C2:  MOVLW  00
0B3C4:  ADDWFC 03,W
0B3C6:  MOVWF  FEA
0B3C8:  MOVFF  FEC,18C
0B3CC:  MOVF   FED,F
0B3CE:  MOVFF  FEF,18B
0B3D2:  MOVFF  18C,18A
.................... 					write_ext_eeprom(addr,y); 
0B3D6:  MOVFF  56,215
0B3DA:  MOVFF  55,214
0B3DE:  MOVFF  18A,216
0B3E2:  MOVLB  0
0B3E4:  CALL   1EE0
.................... 					addr++; 
0B3E8:  INCF   55,F
0B3EA:  BTFSC  FD8.2
0B3EC:  INCF   56,F
....................  
.................... 					y = make8(posicao_y[contador_passo],0);   
0B3EE:  BCF    FD8.0
0B3F0:  MOVLB  1
0B3F2:  RLCF   x88,W
0B3F4:  MOVWF  02
0B3F6:  RLCF   x89,W
0B3F8:  MOVWF  03
0B3FA:  MOVF   02,W
0B3FC:  ADDLW  80
0B3FE:  MOVWF  FE9
0B400:  MOVLW  00
0B402:  ADDWFC 03,W
0B404:  MOVWF  FEA
0B406:  MOVFF  FEC,18C
0B40A:  MOVF   FED,F
0B40C:  MOVFF  FEF,18B
0B410:  MOVFF  18B,18A
.................... 					write_ext_eeprom(addr,y); 
0B414:  MOVFF  56,215
0B418:  MOVFF  55,214
0B41C:  MOVFF  18A,216
0B420:  MOVLB  0
0B422:  CALL   1EE0
.................... 					addr++; 
0B426:  INCF   55,F
0B428:  BTFSC  FD8.2
0B42A:  INCF   56,F
....................  
.................... 					y = make8(posicao_z[contador_passo],1);   
0B42C:  BCF    FD8.0
0B42E:  MOVLB  1
0B430:  RLCF   x88,W
0B432:  MOVWF  02
0B434:  RLCF   x89,W
0B436:  MOVWF  03
0B438:  MOVF   02,W
0B43A:  ADDLW  A8
0B43C:  MOVWF  FE9
0B43E:  MOVLW  00
0B440:  ADDWFC 03,W
0B442:  MOVWF  FEA
0B444:  MOVFF  FEC,18C
0B448:  MOVF   FED,F
0B44A:  MOVFF  FEF,18B
0B44E:  MOVFF  18C,18A
.................... 					write_ext_eeprom(addr,y); 
0B452:  MOVFF  56,215
0B456:  MOVFF  55,214
0B45A:  MOVFF  18A,216
0B45E:  MOVLB  0
0B460:  CALL   1EE0
.................... 					addr++;	 
0B464:  INCF   55,F
0B466:  BTFSC  FD8.2
0B468:  INCF   56,F
....................  
.................... 					y = make8(posicao_z[contador_passo],0);   
0B46A:  BCF    FD8.0
0B46C:  MOVLB  1
0B46E:  RLCF   x88,W
0B470:  MOVWF  02
0B472:  RLCF   x89,W
0B474:  MOVWF  03
0B476:  MOVF   02,W
0B478:  ADDLW  A8
0B47A:  MOVWF  FE9
0B47C:  MOVLW  00
0B47E:  ADDWFC 03,W
0B480:  MOVWF  FEA
0B482:  MOVFF  FEC,18C
0B486:  MOVF   FED,F
0B488:  MOVFF  FEF,18B
0B48C:  MOVFF  18B,18A
.................... 					write_ext_eeprom(addr,y);	 
0B490:  MOVFF  56,215
0B494:  MOVFF  55,214
0B498:  MOVFF  18A,216
0B49C:  MOVLB  0
0B49E:  CALL   1EE0
0B4A2:  MOVLB  1
.................... 				} 
.................... 		 
.................... 				if(n_maquina == 2) 
0B4A4:  MOVF   1D,W
0B4A6:  SUBLW  02
0B4A8:  BTFSS  FD8.2
0B4AA:  BRA    B65E
.................... 				{ 
.................... 					addr=((long)contador_programa * 200) + 3; 
0B4AC:  MOVFF  187,215
0B4B0:  MOVFF  186,214
0B4B4:  MOVLB  2
0B4B6:  CLRF   x17
0B4B8:  MOVLW  C8
0B4BA:  MOVWF  x16
0B4BC:  MOVLB  0
0B4BE:  CALL   27BE
0B4C2:  MOVLW  03
0B4C4:  MOVLB  1
0B4C6:  ADDWF  01,W
0B4C8:  MOVWF  55
0B4CA:  MOVLW  00
0B4CC:  ADDWFC 02,W
0B4CE:  MOVWF  56
.................... 		    		addr=addr + ((long)contador_passo  * 12); 
0B4D0:  MOVFF  189,215
0B4D4:  MOVFF  188,214
0B4D8:  MOVLB  2
0B4DA:  CLRF   x17
0B4DC:  MOVLW  0C
0B4DE:  MOVWF  x16
0B4E0:  MOVLB  0
0B4E2:  CALL   27BE
0B4E6:  MOVF   01,W
0B4E8:  ADDWF  55,F
0B4EA:  MOVF   02,W
0B4EC:  ADDWFC 56,F
....................  
.................... 					y = make8(posicao_x_2[contador_passo],1);   
0B4EE:  BCF    FD8.0
0B4F0:  MOVLB  1
0B4F2:  RLCF   x88,W
0B4F4:  MOVWF  02
0B4F6:  RLCF   x89,W
0B4F8:  MOVWF  03
0B4FA:  MOVF   02,W
0B4FC:  ADDLW  D0
0B4FE:  MOVWF  FE9
0B500:  MOVLW  00
0B502:  ADDWFC 03,W
0B504:  MOVWF  FEA
0B506:  MOVFF  FEC,18C
0B50A:  MOVF   FED,F
0B50C:  MOVFF  FEF,18B
0B510:  MOVFF  18C,18A
.................... 					write_ext_eeprom(addr,y); 
0B514:  MOVFF  56,215
0B518:  MOVFF  55,214
0B51C:  MOVFF  18A,216
0B520:  MOVLB  0
0B522:  CALL   1EE0
.................... 					addr++;	 
0B526:  INCF   55,F
0B528:  BTFSC  FD8.2
0B52A:  INCF   56,F
....................  
.................... 					y = make8(posicao_x_2[contador_passo],0);   
0B52C:  BCF    FD8.0
0B52E:  MOVLB  1
0B530:  RLCF   x88,W
0B532:  MOVWF  02
0B534:  RLCF   x89,W
0B536:  MOVWF  03
0B538:  MOVF   02,W
0B53A:  ADDLW  D0
0B53C:  MOVWF  FE9
0B53E:  MOVLW  00
0B540:  ADDWFC 03,W
0B542:  MOVWF  FEA
0B544:  MOVFF  FEC,18C
0B548:  MOVF   FED,F
0B54A:  MOVFF  FEF,18B
0B54E:  MOVFF  18B,18A
.................... 					write_ext_eeprom(addr,y); 
0B552:  MOVFF  56,215
0B556:  MOVFF  55,214
0B55A:  MOVFF  18A,216
0B55E:  MOVLB  0
0B560:  CALL   1EE0
.................... 					addr++;	 
0B564:  INCF   55,F
0B566:  BTFSC  FD8.2
0B568:  INCF   56,F
....................  
.................... 					y = make8(posicao_y_2[contador_passo],1);   
0B56A:  BCF    FD8.0
0B56C:  MOVLB  1
0B56E:  RLCF   x88,W
0B570:  MOVWF  02
0B572:  RLCF   x89,W
0B574:  MOVWF  03
0B576:  MOVF   02,W
0B578:  ADDLW  F8
0B57A:  MOVWF  FE9
0B57C:  MOVLW  00
0B57E:  ADDWFC 03,W
0B580:  MOVWF  FEA
0B582:  MOVFF  FEC,18C
0B586:  MOVF   FED,F
0B588:  MOVFF  FEF,18B
0B58C:  MOVFF  18C,18A
.................... 					write_ext_eeprom(addr,y); 
0B590:  MOVFF  56,215
0B594:  MOVFF  55,214
0B598:  MOVFF  18A,216
0B59C:  MOVLB  0
0B59E:  CALL   1EE0
.................... 					addr++; 
0B5A2:  INCF   55,F
0B5A4:  BTFSC  FD8.2
0B5A6:  INCF   56,F
....................  
.................... 					y = make8(posicao_y_2[contador_passo],0);   
0B5A8:  BCF    FD8.0
0B5AA:  MOVLB  1
0B5AC:  RLCF   x88,W
0B5AE:  MOVWF  02
0B5B0:  RLCF   x89,W
0B5B2:  MOVWF  03
0B5B4:  MOVF   02,W
0B5B6:  ADDLW  F8
0B5B8:  MOVWF  FE9
0B5BA:  MOVLW  00
0B5BC:  ADDWFC 03,W
0B5BE:  MOVWF  FEA
0B5C0:  MOVFF  FEC,18C
0B5C4:  MOVF   FED,F
0B5C6:  MOVFF  FEF,18B
0B5CA:  MOVFF  18B,18A
.................... 					write_ext_eeprom(addr,y); 
0B5CE:  MOVFF  56,215
0B5D2:  MOVFF  55,214
0B5D6:  MOVFF  18A,216
0B5DA:  MOVLB  0
0B5DC:  CALL   1EE0
.................... 					addr++; 
0B5E0:  INCF   55,F
0B5E2:  BTFSC  FD8.2
0B5E4:  INCF   56,F
....................  
.................... 					y = make8(posicao_z_2[contador_passo],1);   
0B5E6:  BCF    FD8.0
0B5E8:  MOVLB  1
0B5EA:  RLCF   x88,W
0B5EC:  MOVWF  02
0B5EE:  RLCF   x89,W
0B5F0:  MOVWF  03
0B5F2:  MOVF   02,W
0B5F4:  ADDLW  20
0B5F6:  MOVWF  FE9
0B5F8:  MOVLW  01
0B5FA:  ADDWFC 03,W
0B5FC:  MOVWF  FEA
0B5FE:  MOVFF  FEC,18C
0B602:  MOVF   FED,F
0B604:  MOVFF  FEF,18B
0B608:  MOVFF  18C,18A
.................... 					write_ext_eeprom(addr,y); 
0B60C:  MOVFF  56,215
0B610:  MOVFF  55,214
0B614:  MOVFF  18A,216
0B618:  MOVLB  0
0B61A:  CALL   1EE0
.................... 					addr++;	 
0B61E:  INCF   55,F
0B620:  BTFSC  FD8.2
0B622:  INCF   56,F
....................  
.................... 					y = make8(posicao_z_2[contador_passo],0);   
0B624:  BCF    FD8.0
0B626:  MOVLB  1
0B628:  RLCF   x88,W
0B62A:  MOVWF  02
0B62C:  RLCF   x89,W
0B62E:  MOVWF  03
0B630:  MOVF   02,W
0B632:  ADDLW  20
0B634:  MOVWF  FE9
0B636:  MOVLW  01
0B638:  ADDWFC 03,W
0B63A:  MOVWF  FEA
0B63C:  MOVFF  FEC,18C
0B640:  MOVF   FED,F
0B642:  MOVFF  FEF,18B
0B646:  MOVFF  18B,18A
.................... 					write_ext_eeprom(addr,y);	 
0B64A:  MOVFF  56,215
0B64E:  MOVFF  55,214
0B652:  MOVFF  18A,216
0B656:  MOVLB  0
0B658:  CALL   1EE0
0B65C:  MOVLB  1
.................... 				}	 
0B65E:  INCF   x88,F
0B660:  BTFSC  FD8.2
0B662:  INCF   x89,F
0B664:  BRA    B2E0
....................  
....................  
.................... 			} 
0B666:  INCF   x86,F
0B668:  BTFSC  FD8.2
0B66A:  INCF   x87,F
0B66C:  BRA    B26C
0B66E:  MOVLB  0
....................  
....................  
....................        }    
....................  
....................  
.................... 	 }  
....................  
.................... 	//Para debug de soldagem 
.................... 	salva_valores_debug_solda(); 
0B670:  GOTO   27E0
....................     pega_label_eeprom(); 
0B674:  GOTO   2B9C
....................  
....................  
....................    
.................... /*  
....................     while(1){ 
.................... 				aciona_saida(PRESSOR);	 
.................... 				delay_ms(400); 
.................... 				desaciona_saida(PRESSOR); 
.................... 				delay_ms(400); 
....................             } 
.................... */ 
....................  
.................... 	if(n_maquina == 1) 
0B678:  DECFSZ 1D,W
0B67A:  BRA    B682
.................... 	{ 
....................  
.................... 		maquina_1(); 
0B67C:  GOTO   ACA2
....................  
.................... 	} else maquina_2(); 
0B680:  BRA    B686
0B682:  GOTO   ADD8
....................  
....................  }  
....................  
0B686:  SLEEP 
....................  
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C000   PROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
