CCS PCH C Compiler, Version 5.007, 61971               18-mar-19 16:38

               Filename:   C:\Users\ICTS-0101\Desktop\software solda\Maquina 2\SoldaFlex_Maquina 2.X\build\default\production\_ext\1472\main.lst

               ROM used:   55634 bytes (85%)
                           Largest free fragment is 9898
               RAM used:   1405 (35%) at main() level
                           1451 (37%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   D45C
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  FF2.5
0004A:  GOTO   0054
0004E:  BTFSC  FF2.2
00050:  GOTO   180E
00054:  BTFSS  F9D.0
00056:  GOTO   0060
0005A:  BTFSC  F9E.0
0005C:  GOTO   1DBA
00060:  BTFSS  F9D.1
00062:  GOTO   006C
00066:  BTFSC  F9E.1
00068:  GOTO   1DC2
0006C:  BTFSS  FA0.1
0006E:  GOTO   0078
00072:  BTFSC  FA1.1
00074:  GOTO   28F6
00078:  MOVFF  0E,00
0007C:  MOVFF  0F,01
00080:  MOVFF  10,02
00084:  MOVFF  11,03
00088:  MOVFF  0C,FE9
0008C:  MOVFF  07,FEA
00090:  BSF    07.7
00092:  MOVFF  08,FE1
00096:  MOVFF  09,FE2
0009A:  MOVFF  0A,FD9
0009E:  MOVFF  0B,FDA
000A2:  MOVFF  12,FF3
000A6:  MOVFF  13,FF4
000AA:  MOVFF  14,FFA
000AE:  MOVF   04,W
000B0:  MOVFF  06,FE0
000B4:  MOVFF  05,FD8
000B8:  RETFIE 0
.................... #include <18F4620.h> 
.................... //////// Standard Header file for the PIC18F4620 device //////////////// 
.................... #device PIC18F4620 
000BA:  DATA 65,72
000BC:  DATA 72,6F
000BE:  DATA 20,64
000C0:  DATA 65,20
000C2:  DATA 65,73
000C4:  DATA 63,72
000C6:  DATA 69,74
000C8:  DATA 61,20
000CA:  DATA 00,00
000CC:  DATA 20,20
000CE:  DATA 20,45
000D0:  DATA 45,50
000D2:  DATA 52,4F
000D4:  DATA 4D,20
000D6:  DATA 20,20
000D8:  DATA 20,20
000DA:  DATA 20,20
000DC:  DATA 00,00
000DE:  DATA 65,72
000E0:  DATA 72,6F
000E2:  DATA 20,64
000E4:  DATA 65,20
000E6:  DATA 6C,65
000E8:  DATA 69,74
000EA:  DATA 75,72
000EC:  DATA 61,20
000EE:  DATA 20,00
000F0:  DATA 20,20
000F2:  DATA 20,20
000F4:  DATA 20,45
000F6:  DATA 45,50
000F8:  DATA 52,4F
000FA:  DATA 4D,20
000FC:  DATA 20,20
000FE:  DATA 20,20
00100:  DATA 20,00
00102:  DATA 20,20
00104:  DATA 20,20
00106:  DATA 20,20
00108:  DATA 20,20
0010A:  DATA 49,43
0010C:  DATA 54,53
0010E:  DATA 20,20
00110:  DATA 20,20
00112:  DATA 20,20
00114:  DATA 20,20
00116:  DATA 0A,0D
00118:  DATA 00,00
0011A:  DATA 20,20
0011C:  DATA 49,4E
0011E:  DATA 53,54
00120:  DATA 49,54
00122:  DATA 55,54
00124:  DATA 4F,20
00126:  DATA 43,45
00128:  DATA 4E,54
0012A:  DATA 52,4F
0012C:  DATA 20,20
0012E:  DATA 0A,0D
00130:  DATA 00,00
00132:  DATA 20,20
00134:  DATA 20,20
00136:  DATA 54,45
00138:  DATA 43,4E
0013A:  DATA 4F,4C
0013C:  DATA 4F,47
0013E:  DATA 49,41
00140:  DATA 20,45
00142:  DATA 4D,20
00144:  DATA 20,20
00146:  DATA 0A,0D
00148:  DATA 00,00
0014A:  DATA 20,20
0014C:  DATA 20,20
0014E:  DATA 20,20
00150:  DATA 53,4F
00152:  DATA 46,54
00154:  DATA 57,41
00156:  DATA 52,45
00158:  DATA 20,20
0015A:  DATA 20,20
0015C:  DATA 20,20
0015E:  DATA 0A,0D
00160:  DATA 00,00
00162:  DATA 20,20
00164:  DATA 20,20
00166:  DATA 20,49
00168:  DATA 4E,49
0016A:  DATA 43,49
0016C:  DATA 41,4E
0016E:  DATA 44,4F
00170:  DATA 20,20
00172:  DATA 20,20
00174:  DATA 20,0A
00176:  DATA 0D,00
00178:  DATA 20,20
0017A:  DATA 20,20
0017C:  DATA 20,20
0017E:  DATA 42,41
00180:  DATA 4E,44
00182:  DATA 45,4A
00184:  DATA 41,53
00186:  DATA 20,20
00188:  DATA 20,20
0018A:  DATA 20,0A
0018C:  DATA 0D,00
0018E:  DATA 4D,4F
00190:  DATA 56,49
00192:  DATA 4D,45
00194:  DATA 4E,54
00196:  DATA 41,4E
00198:  DATA 44,4F
0019A:  DATA 20,42
0019C:  DATA 41,4E
0019E:  DATA 44,45
001A0:  DATA 4A,41
001A2:  DATA 0A,0D
001A4:  DATA 00,00
001A6:  DATA 20,20
001A8:  DATA 20,20
001AA:  DATA 50,41
001AC:  DATA 52,41
001AE:  DATA 20,50
001B0:  DATA 4F,53
001B2:  DATA 49,43
001B4:  DATA 41,4F
001B6:  DATA 20,20
001B8:  DATA 20,20
001BA:  DATA 0A,0D
001BC:  DATA 00,00
001BE:  DATA 20,20
001C0:  DATA 20,20
001C2:  DATA 20,41
001C4:  DATA 4C,49
001C6:  DATA 4D,45
001C8:  DATA 4E,54
001CA:  DATA 41,44
001CC:  DATA 4F,52
001CE:  DATA 20,20
001D0:  DATA 20,20
001D2:  DATA 0A,0D
001D4:  DATA 00,00
001D6:  DATA 4D,4F
001D8:  DATA 56,49
001DA:  DATA 4D,45
001DC:  DATA 4E,54
001DE:  DATA 41,4E
001E0:  DATA 44,4F
001E2:  DATA 20,42
001E4:  DATA 41,4E
001E6:  DATA 44,45
001E8:  DATA 4A,41
001EA:  DATA 0A,0D
001EC:  DATA 00,00
001EE:  DATA 20,20
001F0:  DATA 20,20
001F2:  DATA 50,41
001F4:  DATA 52,41
001F6:  DATA 20,50
001F8:  DATA 4F,53
001FA:  DATA 49,43
001FC:  DATA 41,4F
001FE:  DATA 20,20
00200:  DATA 20,20
00202:  DATA 0A,0D
00204:  DATA 00,00
00206:  DATA 20,20
00208:  DATA 20,20
0020A:  DATA 20,20
0020C:  DATA 20,48
0020E:  DATA 4F,4D
00210:  DATA 45,20
00212:  DATA 31,20
00214:  DATA 20,20
00216:  DATA 20,20
00218:  DATA 20,20
0021A:  DATA 0A,0D
0021C:  DATA 00,00
0021E:  DATA 4D,4F
00220:  DATA 56,49
00222:  DATA 4D,45
00224:  DATA 4E,54
00226:  DATA 41,4E
00228:  DATA 44,4F
0022A:  DATA 20,42
0022C:  DATA 41,4E
0022E:  DATA 44,45
00230:  DATA 4A,41
00232:  DATA 0A,0D
00234:  DATA 00,00
00236:  DATA 20,20
00238:  DATA 20,20
0023A:  DATA 50,41
0023C:  DATA 52,41
0023E:  DATA 20,50
00240:  DATA 4F,53
00242:  DATA 49,43
00244:  DATA 41,4F
00246:  DATA 20,20
00248:  DATA 20,20
0024A:  DATA 0A,0D
0024C:  DATA 00,00
0024E:  DATA 20,20
00250:  DATA 20,20
00252:  DATA 20,20
00254:  DATA 53,4F
00256:  DATA 4C,44
00258:  DATA 41,47
0025A:  DATA 45,4D
0025C:  DATA 20,20
0025E:  DATA 20,20
00260:  DATA 20,0A
00262:  DATA 0D,00
00264:  DATA 4D,4F
00266:  DATA 56,49
00268:  DATA 4D,45
0026A:  DATA 4E,54
0026C:  DATA 41,4E
0026E:  DATA 44,4F
00270:  DATA 20,42
00272:  DATA 41,4E
00274:  DATA 44,45
00276:  DATA 4A,41
00278:  DATA 0A,0D
0027A:  DATA 00,00
0027C:  DATA 20,20
0027E:  DATA 20,20
00280:  DATA 50,41
00282:  DATA 52,41
00284:  DATA 20,50
00286:  DATA 4F,53
00288:  DATA 49,43
0028A:  DATA 41,4F
0028C:  DATA 20,20
0028E:  DATA 20,20
00290:  DATA 0A,0D
00292:  DATA 00,00
00294:  DATA 20,20
00296:  DATA 20,20
00298:  DATA 20,20
0029A:  DATA 20,48
0029C:  DATA 4F,4D
0029E:  DATA 45,20
002A0:  DATA 32,20
002A2:  DATA 20,20
002A4:  DATA 20,20
002A6:  DATA 20,20
002A8:  DATA 0A,0D
002AA:  DATA 00,00
002AC:  DATA 4D,4F
002AE:  DATA 56,49
002B0:  DATA 4D,45
002B2:  DATA 4E,54
002B4:  DATA 41,4E
002B6:  DATA 44,4F
002B8:  DATA 20,42
002BA:  DATA 41,4E
002BC:  DATA 44,45
002BE:  DATA 4A,41
002C0:  DATA 0A,0D
002C2:  DATA 00,00
002C4:  DATA 20,20
002C6:  DATA 20,20
002C8:  DATA 50,41
002CA:  DATA 52,41
002CC:  DATA 20,50
002CE:  DATA 4F,53
002D0:  DATA 49,43
002D2:  DATA 41,4F
002D4:  DATA 20,20
002D6:  DATA 20,20
002D8:  DATA 0A,0D
002DA:  DATA 00,00
002DC:  DATA 20,20
002DE:  DATA 20,20
002E0:  DATA 44,49
002E2:  DATA 53,50
002E4:  DATA 45,4E
002E6:  DATA 53,41
002E8:  DATA 44,4F
002EA:  DATA 52,20
002EC:  DATA 20,20
002EE:  DATA 20,20
002F0:  DATA 0A,0D
002F2:  DATA 00,00
002F4:  DATA 20,20
002F6:  DATA 45,53
002F8:  DATA 50,45
002FA:  DATA 52,41
002FC:  DATA 4E,44
002FE:  DATA 4F,20
00300:  DATA 42,41
00302:  DATA 4E,44
00304:  DATA 45,4A
00306:  DATA 41,20
00308:  DATA 0A,0D
0030A:  DATA 00,00
0030C:  DATA 20,20
0030E:  DATA 20,49
00310:  DATA 52,20
00312:  DATA 50,41
00314:  DATA 52,41
00316:  DATA 20,50
00318:  DATA 4F,53
0031A:  DATA 49,43
0031C:  DATA 41,4F
0031E:  DATA 20,20
00320:  DATA 0A,0D
00322:  DATA 00,00
00324:  DATA 20,20
00326:  DATA 20,20
00328:  DATA 50,52
0032A:  DATA 45,2D
0032C:  DATA 52,45
0032E:  DATA 51,55
00330:  DATA 49,53
00332:  DATA 49,54
00334:  DATA 4F,20
00336:  DATA 20,20
00338:  DATA 0A,0D
0033A:  DATA 00,00
0033C:  DATA 20,20
0033E:  DATA 20,45
00340:  DATA 53,50
00342:  DATA 45,52
00344:  DATA 41,4E
00346:  DATA 44,4F
00348:  DATA 20,4F
0034A:  DATA 55,54
0034C:  DATA 52,41
0034E:  DATA 20,20
00350:  DATA 0A,0D
00352:  DATA 00,00
00354:  DATA 20,20
00356:  DATA 20,20
00358:  DATA 20,20
0035A:  DATA 20,42
0035C:  DATA 41,4E
0035E:  DATA 44,45
00360:  DATA 4A,41
00362:  DATA 20,20
00364:  DATA 20,20
00366:  DATA 20,20
00368:  DATA 0A,0D
0036A:  DATA 00,00
0036C:  DATA 20,20
0036E:  DATA 20,49
00370:  DATA 52,20
00372:  DATA 50,41
00374:  DATA 52,41
00376:  DATA 20,50
00378:  DATA 4F,53
0037A:  DATA 49,43
0037C:  DATA 41,4F
0037E:  DATA 20,20
00380:  DATA 0A,0D
00382:  DATA 00,00
00384:  DATA 20,20
00386:  DATA 20,20
00388:  DATA 20,41
0038A:  DATA 4C,49
0038C:  DATA 4D,45
0038E:  DATA 4E,54
00390:  DATA 41,44
00392:  DATA 4F,52
00394:  DATA 20,20
00396:  DATA 20,20
00398:  DATA 0A,0D
0039A:  DATA 00,00
0039C:  DATA 20,20
0039E:  DATA 20,45
003A0:  DATA 53,50
003A2:  DATA 45,52
003A4:  DATA 41,4E
003A6:  DATA 44,4F
003A8:  DATA 20,4F
003AA:  DATA 55,54
003AC:  DATA 52,41
003AE:  DATA 20,20
003B0:  DATA 0A,0D
003B2:  DATA 00,00
003B4:  DATA 20,20
003B6:  DATA 20,20
003B8:  DATA 20,20
003BA:  DATA 20,42
003BC:  DATA 41,4E
003BE:  DATA 44,45
003C0:  DATA 4A,41
003C2:  DATA 20,20
003C4:  DATA 20,20
003C6:  DATA 20,20
003C8:  DATA 0A,0D
003CA:  DATA 00,00
003CC:  DATA 20,20
003CE:  DATA 20,49
003D0:  DATA 52,20
003D2:  DATA 50,41
003D4:  DATA 52,41
003D6:  DATA 20,50
003D8:  DATA 4F,53
003DA:  DATA 49,43
003DC:  DATA 41,4F
003DE:  DATA 20,20
003E0:  DATA 0A,0D
003E2:  DATA 00,00
003E4:  DATA 20,20
003E6:  DATA 20,20
003E8:  DATA 20,20
003EA:  DATA 20,48
003EC:  DATA 4F,4D
003EE:  DATA 45,20
003F0:  DATA 31,20
003F2:  DATA 20,20
003F4:  DATA 20,20
003F6:  DATA 20,20
003F8:  DATA 0A,0D
003FA:  DATA 00,00
003FC:  DATA 20,20
003FE:  DATA 20,45
00400:  DATA 53,50
00402:  DATA 45,52
00404:  DATA 41,4E
00406:  DATA 44,4F
00408:  DATA 20,4F
0040A:  DATA 55,54
0040C:  DATA 52,41
0040E:  DATA 20,20
00410:  DATA 0A,0D
00412:  DATA 00,00
00414:  DATA 20,20
00416:  DATA 20,20
00418:  DATA 20,20
0041A:  DATA 20,42
0041C:  DATA 41,4E
0041E:  DATA 44,45
00420:  DATA 4A,41
00422:  DATA 20,20
00424:  DATA 20,20
00426:  DATA 20,20
00428:  DATA 0A,0D
0042A:  DATA 00,00
0042C:  DATA 20,20
0042E:  DATA 20,49
00430:  DATA 52,20
00432:  DATA 50,41
00434:  DATA 52,41
00436:  DATA 20,50
00438:  DATA 4F,53
0043A:  DATA 49,43
0043C:  DATA 41,4F
0043E:  DATA 20,20
00440:  DATA 0A,0D
00442:  DATA 00,00
00444:  DATA 20,20
00446:  DATA 20,20
00448:  DATA 20,53
0044A:  DATA 4F,4C
0044C:  DATA 44,41
0044E:  DATA 47,45
00450:  DATA 4D,20
00452:  DATA 31,20
00454:  DATA 20,20
00456:  DATA 20,20
00458:  DATA 0A,0D
0045A:  DATA 00,00
0045C:  DATA 20,20
0045E:  DATA 20,45
00460:  DATA 53,50
00462:  DATA 45,52
00464:  DATA 41,4E
00466:  DATA 44,4F
00468:  DATA 20,4F
0046A:  DATA 55,54
0046C:  DATA 52,41
0046E:  DATA 20,20
00470:  DATA 0A,0D
00472:  DATA 00,00
00474:  DATA 20,20
00476:  DATA 20,20
00478:  DATA 20,20
0047A:  DATA 20,42
0047C:  DATA 41,4E
0047E:  DATA 44,45
00480:  DATA 4A,41
00482:  DATA 20,20
00484:  DATA 20,20
00486:  DATA 20,20
00488:  DATA 0A,0D
0048A:  DATA 00,00
0048C:  DATA 20,20
0048E:  DATA 20,49
00490:  DATA 52,20
00492:  DATA 50,41
00494:  DATA 52,41
00496:  DATA 20,50
00498:  DATA 4F,53
0049A:  DATA 49,43
0049C:  DATA 41,4F
0049E:  DATA 20,20
004A0:  DATA 0A,0D
004A2:  DATA 00,00
004A4:  DATA 20,20
004A6:  DATA 20,20
004A8:  DATA 20,20
004AA:  DATA 20,48
004AC:  DATA 4F,4D
004AE:  DATA 45,20
004B0:  DATA 32,20
004B2:  DATA 20,20
004B4:  DATA 20,20
004B6:  DATA 20,20
004B8:  DATA 0A,0D
004BA:  DATA 00,00
004BC:  DATA 20,20
004BE:  DATA 20,45
004C0:  DATA 53,50
004C2:  DATA 45,52
004C4:  DATA 41,4E
004C6:  DATA 44,4F
004C8:  DATA 20,4F
004CA:  DATA 55,54
004CC:  DATA 52,41
004CE:  DATA 20,20
004D0:  DATA 0A,0D
004D2:  DATA 00,00
004D4:  DATA 20,20
004D6:  DATA 20,20
004D8:  DATA 20,20
004DA:  DATA 20,42
004DC:  DATA 41,4E
004DE:  DATA 44,45
004E0:  DATA 4A,41
004E2:  DATA 20,20
004E4:  DATA 20,20
004E6:  DATA 20,20
004E8:  DATA 0A,0D
004EA:  DATA 00,00
004EC:  DATA 20,20
004EE:  DATA 20,49
004F0:  DATA 52,20
004F2:  DATA 50,41
004F4:  DATA 52,41
004F6:  DATA 20,50
004F8:  DATA 4F,53
004FA:  DATA 49,43
004FC:  DATA 41,4F
004FE:  DATA 20,20
00500:  DATA 0A,0D
00502:  DATA 00,00
00504:  DATA 20,20
00506:  DATA 20,20
00508:  DATA 20,44
0050A:  DATA 49,53
0050C:  DATA 50,45
0050E:  DATA 4E,53
00510:  DATA 41,44
00512:  DATA 4F,52
00514:  DATA 20,20
00516:  DATA 20,20
00518:  DATA 0A,0D
0051A:  DATA 00,00
0051C:  DATA 20,20
0051E:  DATA 20,45
00520:  DATA 53,50
00522:  DATA 45,52
00524:  DATA 41,4E
00526:  DATA 44,4F
00528:  DATA 20,4F
0052A:  DATA 55,54
0052C:  DATA 52,41
0052E:  DATA 20,20
00530:  DATA 0A,0D
00532:  DATA 00,00
00534:  DATA 20,20
00536:  DATA 20,20
00538:  DATA 20,20
0053A:  DATA 20,42
0053C:  DATA 41,4E
0053E:  DATA 44,45
00540:  DATA 4A,41
00542:  DATA 20,20
00544:  DATA 20,20
00546:  DATA 20,20
00548:  DATA 0A,0D
0054A:  DATA 00,00
0054C:  DATA 20,20
0054E:  DATA 20,53
00550:  DATA 41,49
00552:  DATA 52,20
00554:  DATA 44,41
00556:  DATA 20,50
00558:  DATA 4F,53
0055A:  DATA 49,43
0055C:  DATA 41,4F
0055E:  DATA 20,20
00560:  DATA 0A,0D
00562:  DATA 00,00
00564:  DATA 20,20
00566:  DATA 20,20
00568:  DATA 20,20
0056A:  DATA 20,20
0056C:  DATA 41,54
0056E:  DATA 55,41
00570:  DATA 4C,20
00572:  DATA 20,20
00574:  DATA 20,20
00576:  DATA 20,20
00578:  DATA 0A,0D
0057A:  DATA 00,00
0057C:  DATA 20,53
0057E:  DATA 4F,4C
00580:  DATA 44,41
00582:  DATA 44,4F
00584:  DATA 52,20
00586:  DATA 41,55
00588:  DATA 54,4F
0058A:  DATA 4D,41
0058C:  DATA 54,49
0058E:  DATA 43,4F
00590:  DATA 0A,0D
00592:  DATA 00,00
00594:  DATA 20,20
00596:  DATA 20,20
00598:  DATA 20,20
0059A:  DATA 4D,4F
0059C:  DATA 44,45
0059E:  DATA 4C,4F
005A0:  DATA 3A,25
005A2:  DATA 30,32
005A4:  DATA 75,20
005A6:  DATA 20,20
005A8:  DATA 0A,0D
005AA:  DATA 00,00
005AC:  DATA 20,20
005AE:  DATA 20,20
005B0:  DATA 20,4D
005B2:  DATA 45,4E
005B4:  DATA 55,3A
005B6:  DATA 45,44
005B8:  DATA 49,54
005BA:  DATA 41,52
005BC:  DATA 20,20
005BE:  DATA 20,20
005C0:  DATA 0A,0D
005C2:  DATA 00,00
005C4:  DATA 20,20
005C6:  DATA 45,4E
005C8:  DATA 54,45
005CA:  DATA 52,3A
005CC:  DATA 41,55
005CE:  DATA 54,4F
005D0:  DATA 4D,41
005D2:  DATA 54,49
005D4:  DATA 43,4F
005D6:  DATA 20,20
005D8:  DATA 0A,0D
005DA:  DATA 00,00
005DC:  DATA 20,53
005DE:  DATA 45,4C
005E0:  DATA 45,43
005E2:  DATA 49,4F
005E4:  DATA 4E,45
005E6:  DATA 20,41
005E8:  DATA 20,42
005EA:  DATA 41,4E
005EC:  DATA 44,45
005EE:  DATA 4A,41
005F0:  DATA 0A,0D
005F2:  DATA 00,00
005F4:  DATA 20,20
005F6:  DATA 20,20
005F8:  DATA 46,31
005FA:  DATA 3A,20
005FC:  DATA 42,41
005FE:  DATA 4E,44
00600:  DATA 45,4A
00602:  DATA 41,20
00604:  DATA 31,20
00606:  DATA 20,20
00608:  DATA 0A,0D
0060A:  DATA 00,00
0060C:  DATA 20,20
0060E:  DATA 20,20
00610:  DATA 46,32
00612:  DATA 3A,20
00614:  DATA 42,41
00616:  DATA 4E,44
00618:  DATA 45,4A
0061A:  DATA 41,20
0061C:  DATA 32,20
0061E:  DATA 20,20
00620:  DATA 0A,0D
00622:  DATA 00,00
00624:  DATA 20,20
00626:  DATA 20,20
00628:  DATA 45,53
0062A:  DATA 43,3A
0062C:  DATA 42,41
0062E:  DATA 43,4B
00630:  DATA 20,20
00632:  DATA 20,20
00634:  DATA 20,20
00636:  DATA 20,20
00638:  DATA 0A,0D
0063A:  DATA 00,00
0063C:  DATA 20,20
0063E:  DATA 20,20
00640:  DATA 20,4D
00642:  DATA 41,4E
00644:  DATA 55,54
00646:  DATA 45,4E
00648:  DATA 43,41
0064A:  DATA 4F,20
0064C:  DATA 20,20
0064E:  DATA 20,20
00650:  DATA 0A,0D
00652:  DATA 00,00
00654:  DATA 20,20
00656:  DATA 20,20
00658:  DATA 20,20
0065A:  DATA 42,41
0065C:  DATA 4E,44
0065E:  DATA 45,4A
00660:  DATA 41,20
00662:  DATA 32,20
00664:  DATA 20,20
00666:  DATA 20,20
00668:  DATA 0A,0D
0066A:  DATA 00,00
0066C:  DATA 20,20
0066E:  DATA 20,20
00670:  DATA 20,20
00672:  DATA 20,20
00674:  DATA 20,20
00676:  DATA 20,20
00678:  DATA 20,20
0067A:  DATA 20,20
0067C:  DATA 20,20
0067E:  DATA 20,20
00680:  DATA 0A,0D
00682:  DATA 00,00
00684:  DATA 20,20
00686:  DATA 20,20
00688:  DATA 20,20
0068A:  DATA 45,53
0068C:  DATA 43,3A
0068E:  DATA 42,41
00690:  DATA 43,4B
00692:  DATA 20,20
00694:  DATA 20,20
00696:  DATA 20,20
00698:  DATA 0A,0D
0069A:  DATA 00,00
0069C:  DATA 20,20
0069E:  DATA 20,20
006A0:  DATA 45,53
006A2:  DATA 43,4F
006A4:  DATA 4C,48
006A6:  DATA 45,52
006A8:  DATA 20,41
006AA:  DATA 43,41
006AC:  DATA 4F,20
006AE:  DATA 20,20
006B0:  DATA 0A,0D
006B2:  DATA 00,00
006B4:  DATA 46,31
006B6:  DATA 3A,45
006B8:  DATA 44,49
006BA:  DATA 54,41
006BC:  DATA 52,2F
006BE:  DATA 4D,41
006C0:  DATA 4E,55
006C2:  DATA 54,45
006C4:  DATA 4E,43
006C6:  DATA 41,4F
006C8:  DATA 0A,0D
006CA:  DATA 00,00
006CC:  DATA 46,32
006CE:  DATA 3A,45
006D0:  DATA 58,43
006D2:  DATA 4C,55
006D4:  DATA 49,20
006D6:  DATA 4D,4F
006D8:  DATA 44,45
006DA:  DATA 4C,4F
006DC:  DATA 20,20
006DE:  DATA 0A,0D
006E0:  DATA 00,00
006E2:  DATA 45,53
006E4:  DATA 43,3A
006E6:  DATA 42,41
006E8:  DATA 43,4B
006EA:  DATA 20,20
006EC:  DATA 20,20
006EE:  DATA 20,20
006F0:  DATA 20,20
006F2:  DATA 20,20
006F4:  DATA 0A,0D
006F6:  DATA 00,00
006F8:  DATA 20,20
006FA:  DATA 46,31
006FC:  DATA 3A,20
006FE:  DATA 45,44
00700:  DATA 49,54
00702:  DATA 41,52
00704:  DATA 20,50
00706:  DATA 4F,4E
00708:  DATA 54,4F
0070A:  DATA 53,20
0070C:  DATA 0A,0D
0070E:  DATA 00,00
00710:  DATA 20,20
00712:  DATA 46,32
00714:  DATA 3A,20
00716:  DATA 4D,41
00718:  DATA 4E,55
0071A:  DATA 54,45
0071C:  DATA 4E,43
0071E:  DATA 41,4F
00720:  DATA 20,20
00722:  DATA 20,20
00724:  DATA 0A,0D
00726:  DATA 00,00
00728:  DATA 20,20
0072A:  DATA 45,53
0072C:  DATA 43,3A
0072E:  DATA 42,41
00730:  DATA 43,4B
00732:  DATA 20,20
00734:  DATA 20,20
00736:  DATA 20,20
00738:  DATA 20,20
0073A:  DATA 20,20
0073C:  DATA 0A,0D
0073E:  DATA 00,00
00740:  DATA 20,20
00742:  DATA 20,46
00744:  DATA 31,3A
00746:  DATA 20,4E
00748:  DATA 20,50
0074A:  DATA 4F,4E
0074C:  DATA 54,4F
0074E:  DATA 53,20
00750:  DATA 20,20
00752:  DATA 20,20
00754:  DATA 0A,0D
00756:  DATA 00,00
00758:  DATA 20,20
0075A:  DATA 46,32
0075C:  DATA 3A,20
0075E:  DATA 45,44
00760:  DATA 49,54
00762:  DATA 41,52
00764:  DATA 20,50
00766:  DATA 4F,4E
00768:  DATA 54,4F
0076A:  DATA 53,20
0076C:  DATA 0A,0D
0076E:  DATA 00,00
00770:  DATA 20,20
00772:  DATA 45,53
00774:  DATA 43,3A
00776:  DATA 42,41
00778:  DATA 43,4B
0077A:  DATA 20,20
0077C:  DATA 20,20
0077E:  DATA 20,20
00780:  DATA 20,20
00782:  DATA 20,20
00784:  DATA 0A,0D
00786:  DATA 00,00
00788:  DATA 20,20
0078A:  DATA 4E,55
0078C:  DATA 4D,45
0078E:  DATA 52,4F
00790:  DATA 20,44
00792:  DATA 45,20
00794:  DATA 50,4F
00796:  DATA 4E,54
00798:  DATA 4F,53
0079A:  DATA 20,20
0079C:  DATA 0A,0D
0079E:  DATA 00,00
007A0:  DATA 20,20
007A2:  DATA 20,20
007A4:  DATA 20,20
007A6:  DATA 20,25
007A8:  DATA 30,34
007AA:  DATA 4C,75
007AC:  DATA 20,20
007AE:  DATA 20,20
007B0:  DATA 20,20
007B2:  DATA 20,0A
007B4:  DATA 0D,00
007B6:  DATA 20,45
007B8:  DATA 4E,54
007BA:  DATA 45,52
007BC:  DATA 3A,53
007BE:  DATA 41,56
007C0:  DATA 45,7C
007C2:  DATA 45,53
007C4:  DATA 43,3A
007C6:  DATA 42,41
007C8:  DATA 43,4B
007CA:  DATA 0A,0D
007CC:  DATA 00,00
007CE:  DATA 20,20
007D0:  DATA 20,44
007D2:  DATA 45,53
007D4:  DATA 45,4A
007D6:  DATA 41,20
007D8:  DATA 45,58
007DA:  DATA 43,4C
007DC:  DATA 55,49
007DE:  DATA 52,20
007E0:  DATA 20,20
007E2:  DATA 0A,0D
007E4:  DATA 00,00
007E6:  DATA 20,20
007E8:  DATA 20,20
007EA:  DATA 20,4F
007EC:  DATA 20,4D
007EE:  DATA 4F,44
007F0:  DATA 45,4C
007F2:  DATA 4F,20
007F4:  DATA 3F,20
007F6:  DATA 20,20
007F8:  DATA 20,20
007FA:  DATA 0A,0D
007FC:  DATA 00,00
007FE:  DATA 20,20
00800:  DATA 20,20
00802:  DATA 20,20
00804:  DATA 45,4E
00806:  DATA 54,45
00808:  DATA 52,3A
0080A:  DATA 4F,4B
0080C:  DATA 20,20
0080E:  DATA 20,20
00810:  DATA 20,20
00812:  DATA 0A,0D
00814:  DATA 00,00
00816:  DATA 20,20
00818:  DATA 20,20
0081A:  DATA 20,20
0081C:  DATA 45,53
0081E:  DATA 43,3A
00820:  DATA 42,41
00822:  DATA 43,4B
00824:  DATA 20,20
00826:  DATA 20,20
00828:  DATA 20,0A
0082A:  DATA 0D,00
0082C:  DATA 50,25
0082E:  DATA 30,32
00830:  DATA 75,20
00832:  DATA 20,20
00834:  DATA 20,20
00836:  DATA 20,20
00838:  DATA 20,20
0083A:  DATA 45,4E
0083C:  DATA 54,3A
0083E:  DATA 45,44
00840:  DATA 49,54
00842:  DATA 0A,0D
00844:  DATA 00,00
00846:  DATA 50,25
00848:  DATA 30,32
0084A:  DATA 75,20
0084C:  DATA 20,20
0084E:  DATA 20,20
00850:  DATA 20,20
00852:  DATA 20,20
00854:  DATA 45,53
00856:  DATA 43,3A
00858:  DATA 42,41
0085A:  DATA 43,4B
0085C:  DATA 0A,0D
0085E:  DATA 00,00
00860:  DATA 50,25
00862:  DATA 30,32
00864:  DATA 75,20
00866:  DATA 20,20
00868:  DATA 20,20
0086A:  DATA 20,20
0086C:  DATA 20,20
0086E:  DATA 20,20
00870:  DATA 20,20
00872:  DATA 20,20
00874:  DATA 20,20
00876:  DATA 0A,0D
00878:  DATA 00,00
0087A:  DATA 50,25
0087C:  DATA 30,32
0087E:  DATA 75,20
00880:  DATA 20,20
00882:  DATA 20,20
00884:  DATA 20,20
00886:  DATA 20,20
00888:  DATA 20,20
0088A:  DATA 20,20
0088C:  DATA 20,20
0088E:  DATA 20,20
00890:  DATA 0A,0D
00892:  DATA 00,00
00894:  DATA 58,3A
00896:  DATA 25,30
00898:  DATA 34,4C
0089A:  DATA 75,20
0089C:  DATA 54,3A
0089E:  DATA 25,30
008A0:  DATA 34,4C
008A2:  DATA 75,0A
008A4:  DATA 0D,00
008A6:  DATA 59,3A
008A8:  DATA 25,30
008AA:  DATA 34,4C
008AC:  DATA 75,20
008AE:  DATA 48,3A
008B0:  DATA 25,30
008B2:  DATA 34,4C
008B4:  DATA 75,20
008B6:  DATA 46,3A
008B8:  DATA 25,30
008BA:  DATA 34,4C
008BC:  DATA 75,0A
008BE:  DATA 0D,00
008C0:  DATA 5A,3A
008C2:  DATA 25,30
008C4:  DATA 34,4C
008C6:  DATA 75,20
008C8:  DATA 49,3A
008CA:  DATA 25,30
008CC:  DATA 32,75
008CE:  DATA 20,4C
008D0:  DATA 3A,25
008D2:  DATA 30,34
008D4:  DATA 4C,75
008D6:  DATA 0A,0D
008D8:  DATA 00,00
008DA:  DATA 46,31
008DC:  DATA 3A,47
008DE:  DATA 52,41
008E0:  DATA 56,41
008E2:  DATA 7C,46
008E4:  DATA 33,3A
008E6:  DATA 50,52
008E8:  DATA 4F,58
008EA:  DATA 0A,0D
008EC:  DATA 00,00
008EE:  DATA 53,31
008F0:  DATA 3A,25
008F2:  DATA 30,34
008F4:  DATA 4C,75
008F6:  DATA 0A,0D
008F8:  DATA 00,00
008FA:  DATA 53,32
008FC:  DATA 3A,25
008FE:  DATA 30,34
00900:  DATA 4C,75
00902:  DATA 20,45
00904:  DATA 3A,25
00906:  DATA 30,34
00908:  DATA 4C,75
0090A:  DATA 0A,0D
0090C:  DATA 00,00
0090E:  DATA 53,33
00910:  DATA 3A,25
00912:  DATA 30,34
00914:  DATA 4C,75
00916:  DATA 0A,0D
00918:  DATA 00,00
0091A:  DATA 46,31
0091C:  DATA 3A,52
0091E:  DATA 45,43
00920:  DATA 7C,46
00922:  DATA 33,3A
00924:  DATA 42,41
00926:  DATA 43,4B
00928:  DATA 0A,0D
0092A:  DATA 00,00
0092C:  DATA 53,32
0092E:  DATA 3A,25
00930:  DATA 30,34
00932:  DATA 4C,75
00934:  DATA 20,45
00936:  DATA 3A,25
00938:  DATA 30,34
0093A:  DATA 4C,75
0093C:  DATA 0A,0D
0093E:  DATA 00,00
00940:  DATA 53,33
00942:  DATA 3A,25
00944:  DATA 30,34
00946:  DATA 4C,75
00948:  DATA 0A,0D
0094A:  DATA 00,00
0094C:  DATA 46,31
0094E:  DATA 3A,52
00950:  DATA 45,43
00952:  DATA 7C,46
00954:  DATA 33,3A
00956:  DATA 42,41
00958:  DATA 43,4B
0095A:  DATA 0A,0D
0095C:  DATA 00,00
0095E:  DATA 53,31
00960:  DATA 3A,25
00962:  DATA 30,34
00964:  DATA 4C,75
00966:  DATA 0A,0D
00968:  DATA 00,00
0096A:  DATA 53,32
0096C:  DATA 3A,25
0096E:  DATA 30,34
00970:  DATA 4C,75
00972:  DATA 20,45
00974:  DATA 3A,25
00976:  DATA 30,34
00978:  DATA 4C,75
0097A:  DATA 0A,0D
0097C:  DATA 00,00
0097E:  DATA 46,31
00980:  DATA 3A,52
00982:  DATA 45,43
00984:  DATA 7C,46
00986:  DATA 33,3A
00988:  DATA 42,41
0098A:  DATA 43,4B
0098C:  DATA 0A,0D
0098E:  DATA 00,00
00990:  DATA 53,32
00992:  DATA 3A,25
00994:  DATA 30,34
00996:  DATA 4C,75
00998:  DATA 20,45
0099A:  DATA 3A,25
0099C:  DATA 30,34
0099E:  DATA 4C,75
009A0:  DATA 0A,0D
009A2:  DATA 00,00
009A4:  DATA 46,31
009A6:  DATA 3A,52
009A8:  DATA 45,43
009AA:  DATA 7C,46
009AC:  DATA 33,3A
009AE:  DATA 42,41
009B0:  DATA 43,4B
009B2:  DATA 0A,0D
009B4:  DATA 00,00
009B6:  DATA 20,20
009B8:  DATA 20,20
009BA:  DATA 20,20
009BC:  DATA 56,45
009BE:  DATA 52,49
009C0:  DATA 46,49
009C2:  DATA 51,55
009C4:  DATA 45,20
009C6:  DATA 20,20
009C8:  DATA 20,20
009CA:  DATA 0A,0D
009CC:  DATA 00,00
009CE:  DATA 20,20
009D0:  DATA 4F,53
009D2:  DATA 20,41
009D4:  DATA 4C,49
009D6:  DATA 4D,45
009D8:  DATA 4E,54
009DA:  DATA 41,44
009DC:  DATA 4F,52
009DE:  DATA 45,53
009E0:  DATA 20,20
009E2:  DATA 0A,0D
009E4:  DATA 00,00
009E6:  DATA 20,20
009E8:  DATA 20,20
009EA:  DATA 20,20
009EC:  DATA 44,45
009EE:  DATA 20,53
009F0:  DATA 4F,4C
009F2:  DATA 44,41
009F4:  DATA 20,20
009F6:  DATA 20,20
009F8:  DATA 20,20
009FA:  DATA 0A,0D
009FC:  DATA 00,00
009FE:  DATA 20,20
00A00:  DATA 20,20
00A02:  DATA 20,20
00A04:  DATA 45,4E
00A06:  DATA 54,45
00A08:  DATA 52,3A
00A0A:  DATA 4F,4B
00A0C:  DATA 20,20
00A0E:  DATA 20,20
00A10:  DATA 20,20
00A12:  DATA 0A,0D
00A14:  DATA 00,00
00A16:  DATA 4D,41
00A18:  DATA 4E,55
00A1A:  DATA 54,45
00A1C:  DATA 4E,43
00A1E:  DATA 41,4F
00A20:  DATA 20,42
00A22:  DATA 41,4E
00A24:  DATA 44,45
00A26:  DATA 4A,41
00A28:  DATA 20,31
00A2A:  DATA 0A,0D
00A2C:  DATA 00,00
00A2E:  DATA 20,20
00A30:  DATA 20,4A
00A32:  DATA 41,20
00A34:  DATA 46,49
00A36:  DATA 4E,41
00A38:  DATA 4C,49
00A3A:  DATA 5A,41
00A3C:  DATA 44,41
00A3E:  DATA 20,3F
00A40:  DATA 20,20
00A42:  DATA 0A,0D
00A44:  DATA 00,00
00A46:  DATA 20,20
00A48:  DATA 20,20
00A4A:  DATA 20,20
00A4C:  DATA 45,4E
00A4E:  DATA 54,45
00A50:  DATA 52,3A
00A52:  DATA 4F,4B
00A54:  DATA 20,20
00A56:  DATA 20,20
00A58:  DATA 20,20
00A5A:  DATA 0A,0D
00A5C:  DATA 00,00
00A5E:  DATA 20,20
00A60:  DATA 20,20
00A62:  DATA 20,20
00A64:  DATA 20,45
00A66:  DATA 53,43
00A68:  DATA 3A,4E
00A6A:  DATA 4F,20
00A6C:  DATA 20,20
00A6E:  DATA 20,20
00A70:  DATA 20,20
00A72:  DATA 0A,0D
00A74:  DATA 00,00
00A76:  DATA 20,46
00A78:  DATA 31,3A
00A7A:  DATA 20,44
00A7C:  DATA 45,42
00A7E:  DATA 55,47
00A80:  DATA 20,45
00A82:  DATA 4E,54
00A84:  DATA 52,41
00A86:  DATA 44,41
00A88:  DATA 53,20
00A8A:  DATA 0A,0D
00A8C:  DATA 00,00
00A8E:  DATA 20,46
00A90:  DATA 32,3A
00A92:  DATA 20,20
00A94:  DATA 44,45
00A96:  DATA 42,55
00A98:  DATA 47,20
00A9A:  DATA 53,41
00A9C:  DATA 49,44
00A9E:  DATA 41,53
00AA0:  DATA 20,20
00AA2:  DATA 0A,0D
00AA4:  DATA 00,00
00AA6:  DATA 20,20
00AA8:  DATA 20,20
00AAA:  DATA 20,20
00AAC:  DATA 20,20
00AAE:  DATA 20,20
00AB0:  DATA 20,20
00AB2:  DATA 20,20
00AB4:  DATA 20,20
00AB6:  DATA 20,20
00AB8:  DATA 20,20
00ABA:  DATA 0A,0D
00ABC:  DATA 00,00
00ABE:  DATA 20,20
00AC0:  DATA 20,20
00AC2:  DATA 20,20
00AC4:  DATA 45,53
00AC6:  DATA 43,3A
00AC8:  DATA 42,41
00ACA:  DATA 43,4B
00ACC:  DATA 20,20
00ACE:  DATA 20,20
00AD0:  DATA 20,20
00AD2:  DATA 0A,0D
00AD4:  DATA 00,00
00AD6:  DATA 45,30
00AD8:  DATA 30,3A
00ADA:  DATA 25,30
00ADC:  DATA 32,75
00ADE:  DATA 20,45
00AE0:  DATA 30,31
00AE2:  DATA 3A,25
00AE4:  DATA 30,32
00AE6:  DATA 75,20
00AE8:  DATA 45,30
00AEA:  DATA 32,3A
00AEC:  DATA 25,30
00AEE:  DATA 32,75
00AF0:  DATA 0A,0D
00AF2:  DATA 00,00
00AF4:  DATA 45,30
00AF6:  DATA 33,3A
00AF8:  DATA 25,30
00AFA:  DATA 32,75
00AFC:  DATA 20,45
00AFE:  DATA 30,34
00B00:  DATA 3A,25
00B02:  DATA 30,32
00B04:  DATA 75,20
00B06:  DATA 45,30
00B08:  DATA 35,3A
00B0A:  DATA 25,30
00B0C:  DATA 32,75
00B0E:  DATA 0A,0D
00B10:  DATA 00,00
00B12:  DATA 45,30
00B14:  DATA 36,3A
00B16:  DATA 25,30
00B18:  DATA 32,75
00B1A:  DATA 20,45
00B1C:  DATA 30,37
00B1E:  DATA 3A,25
00B20:  DATA 30,32
00B22:  DATA 75,20
00B24:  DATA 45,30
00B26:  DATA 38,3A
00B28:  DATA 25,30
00B2A:  DATA 32,75
00B2C:  DATA 0A,0D
00B2E:  DATA 00,00
00B30:  DATA 20,20
00B32:  DATA 20,3E
00B34:  DATA 3A,50
00B36:  DATA 52,4F
00B38:  DATA 58,7C
00B3A:  DATA 45,53
00B3C:  DATA 43,3A
00B3E:  DATA 42,41
00B40:  DATA 43,4B
00B42:  DATA 20,20
00B44:  DATA 0A,0D
00B46:  DATA 00,00
00B48:  DATA 45,30
00B4A:  DATA 39,3A
00B4C:  DATA 25,30
00B4E:  DATA 32,75
00B50:  DATA 20,45
00B52:  DATA 31,30
00B54:  DATA 3A,25
00B56:  DATA 30,32
00B58:  DATA 75,20
00B5A:  DATA 45,31
00B5C:  DATA 31,3A
00B5E:  DATA 25,30
00B60:  DATA 32,75
00B62:  DATA 0A,0D
00B64:  DATA 00,00
00B66:  DATA 45,31
00B68:  DATA 32,3A
00B6A:  DATA 25,30
00B6C:  DATA 32,75
00B6E:  DATA 20,45
00B70:  DATA 31,33
00B72:  DATA 3A,25
00B74:  DATA 30,32
00B76:  DATA 75,20
00B78:  DATA 45,31
00B7A:  DATA 34,3A
00B7C:  DATA 25,30
00B7E:  DATA 32,75
00B80:  DATA 0A,0D
00B82:  DATA 00,00
00B84:  DATA 45,31
00B86:  DATA 35,3A
00B88:  DATA 25,30
00B8A:  DATA 32,75
00B8C:  DATA 20,45
00B8E:  DATA 31,36
00B90:  DATA 3A,25
00B92:  DATA 30,32
00B94:  DATA 75,20
00B96:  DATA 45,31
00B98:  DATA 37,3A
00B9A:  DATA 25,30
00B9C:  DATA 32,75
00B9E:  DATA 0A,0D
00BA0:  DATA 00,00
00BA2:  DATA 20,20
00BA4:  DATA 3C,7C
00BA6:  DATA 3E,3A
00BA8:  DATA 50,52
00BAA:  DATA 4F,58
00BAC:  DATA 7C,45
00BAE:  DATA 53,43
00BB0:  DATA 3A,42
00BB2:  DATA 41,43
00BB4:  DATA 4B,20
00BB6:  DATA 0A,0D
00BB8:  DATA 00,00
00BBA:  DATA 45,31
00BBC:  DATA 38,3A
00BBE:  DATA 25,30
00BC0:  DATA 32,75
00BC2:  DATA 20,45
00BC4:  DATA 31,39
00BC6:  DATA 3A,25
00BC8:  DATA 30,32
00BCA:  DATA 75,20
00BCC:  DATA 45,32
00BCE:  DATA 30,3A
00BD0:  DATA 25,30
00BD2:  DATA 32,75
00BD4:  DATA 0A,0D
00BD6:  DATA 00,00
00BD8:  DATA 45,32
00BDA:  DATA 31,3A
00BDC:  DATA 25,30
00BDE:  DATA 32,75
00BE0:  DATA 20,45
00BE2:  DATA 32,32
00BE4:  DATA 3A,25
00BE6:  DATA 30,32
00BE8:  DATA 75,20
00BEA:  DATA 45,32
00BEC:  DATA 33,3A
00BEE:  DATA 25,30
00BF0:  DATA 32,75
00BF2:  DATA 0A,0D
00BF4:  DATA 00,00
00BF6:  DATA 45,32
00BF8:  DATA 34,3A
00BFA:  DATA 25,30
00BFC:  DATA 32,75
00BFE:  DATA 20,45
00C00:  DATA 32,35
00C02:  DATA 3A,25
00C04:  DATA 30,32
00C06:  DATA 75,20
00C08:  DATA 45,32
00C0A:  DATA 36,3A
00C0C:  DATA 25,30
00C0E:  DATA 32,75
00C10:  DATA 0A,0D
00C12:  DATA 00,00
00C14:  DATA 45,32
00C16:  DATA 37,3A
00C18:  DATA 25,30
00C1A:  DATA 32,75
00C1C:  DATA 20,3C
00C1E:  DATA 3A,41
00C20:  DATA 4E,54
00C22:  DATA 7C,45
00C24:  DATA 53,43
00C26:  DATA 3A,42
00C28:  DATA 41,43
00C2A:  DATA 4B,0A
00C2C:  DATA 0D,00
00C2E:  DATA 45,53
00C30:  DATA 54,45
00C32:  DATA 49,52
00C34:  DATA 41,20
00C36:  DATA 20,20
00C38:  DATA 20,20
00C3A:  DATA 20,20
00C3C:  DATA 20,20
00C3E:  DATA 20,20
00C40:  DATA 20,20
00C42:  DATA 0A,0D
00C44:  DATA 00,00
00C46:  DATA 44,45
00C48:  DATA 44,4F
00C4A:  DATA 53,20
00C4C:  DATA 45,4E
00C4E:  DATA 54,52
00C50:  DATA 41,44
00C52:  DATA 41,20
00C54:  DATA 20,20
00C56:  DATA 20,20
00C58:  DATA 20,20
00C5A:  DATA 0A,0D
00C5C:  DATA 00,00
00C5E:  DATA 41,4C
00C60:  DATA 49,4D
00C62:  DATA 45,4E
00C64:  DATA 54,41
00C66:  DATA 44,4F
00C68:  DATA 52,5F
00C6A:  DATA 50,4C
00C6C:  DATA 41,43
00C6E:  DATA 41,20
00C70:  DATA 20,20
00C72:  DATA 0A,0D
00C74:  DATA 00,00
00C76:  DATA 46,31
00C78:  DATA 3A,4F
00C7A:  DATA 4E,7C
00C7C:  DATA 46,32
00C7E:  DATA 3A,4F
00C80:  DATA 46,7C
00C82:  DATA 45,53
00C84:  DATA 43,3A
00C86:  DATA 42,41
00C88:  DATA 43,4B
00C8A:  DATA 0A,0D
00C8C:  DATA 00,00
00C8E:  DATA 50,52
00C90:  DATA 45,53
00C92:  DATA 53,4F
00C94:  DATA 52,20
00C96:  DATA 20,20
00C98:  DATA 20,20
00C9A:  DATA 20,20
00C9C:  DATA 20,20
00C9E:  DATA 20,20
00CA0:  DATA 20,20
00CA2:  DATA 0A,0D
00CA4:  DATA 00,00
00CA6:  DATA 44,45
00CA8:  DATA 44,4F
00CAA:  DATA 53,5F
00CAC:  DATA 53,41
00CAE:  DATA 49,44
00CB0:  DATA 41,20
00CB2:  DATA 20,20
00CB4:  DATA 20,20
00CB6:  DATA 20,20
00CB8:  DATA 20,20
00CBA:  DATA 0A,0D
00CBC:  DATA 00,00
00CBE:  DATA 44,49
00CC0:  DATA 53,50
00CC2:  DATA 45,4E
00CC4:  DATA 53,41
00CC6:  DATA 44,4F
00CC8:  DATA 52,5F
00CCA:  DATA 50,4C
00CCC:  DATA 41,43
00CCE:  DATA 41,20
00CD0:  DATA 20,20
00CD2:  DATA 0A,0D
00CD4:  DATA 00,00
00CD6:  DATA 46,31
00CD8:  DATA 3A,4F
00CDA:  DATA 4E,7C
00CDC:  DATA 46,32
00CDE:  DATA 3A,4F
00CE0:  DATA 46,7C
00CE2:  DATA 45,53
00CE4:  DATA 43,3A
00CE6:  DATA 42,41
00CE8:  DATA 43,4B
00CEA:  DATA 0A,0D
00CEC:  DATA 00,00
00CEE:  DATA 41,4C
00CF0:  DATA 49,4D
00CF2:  DATA 45,4E
00CF4:  DATA 54,41
00CF6:  DATA 44,4F
00CF8:  DATA 52,5F
00CFA:  DATA 53,4F
00CFC:  DATA 4C,44
00CFE:  DATA 41,20
00D00:  DATA 20,20
00D02:  DATA 0A,0D
00D04:  DATA 00,00
00D06:  DATA 4C,49
00D08:  DATA 4D,50
00D0A:  DATA 41,44
00D0C:  DATA 4F,52
00D0E:  DATA 5F,42
00D10:  DATA 49,43
00D12:  DATA 4F,20
00D14:  DATA 20,20
00D16:  DATA 20,20
00D18:  DATA 20,20
00D1A:  DATA 0A,0D
00D1C:  DATA 00,00
00D1E:  DATA 46,45
00D20:  DATA 52,52
00D22:  DATA 4F,53
00D24:  DATA 5F,44
00D26:  DATA 45,5F
00D28:  DATA 53,4F
00D2A:  DATA 4C,44
00D2C:  DATA 41,20
00D2E:  DATA 20,20
00D30:  DATA 20,20
00D32:  DATA 0A,0D
00D34:  DATA 00,00
00D36:  DATA 46,31
00D38:  DATA 3A,4F
00D3A:  DATA 4E,7C
00D3C:  DATA 46,32
00D3E:  DATA 3A,4F
00D40:  DATA 46,7C
00D42:  DATA 45,53
00D44:  DATA 43,3A
00D46:  DATA 42,41
00D48:  DATA 43,4B
00D4A:  DATA 0A,0D
00D4C:  DATA 00,00
00D4E:  DATA 20,20
00D50:  DATA 20,58
00D52:  DATA 3A,25
00D54:  DATA 30,34
00D56:  DATA 4C,75
00D58:  DATA 20,20
00D5A:  DATA 59,3A
00D5C:  DATA 25,30
00D5E:  DATA 34,4C
00D60:  DATA 75,20
00D62:  DATA 20,0A
00D64:  DATA 0D,00
00D66:  DATA 20,20
00D68:  DATA 20,5A
00D6A:  DATA 3A,25
00D6C:  DATA 30,34
00D6E:  DATA 4C,75
00D70:  DATA 20,20
00D72:  DATA 46,3A
00D74:  DATA 25,30
00D76:  DATA 34,4C
00D78:  DATA 75,20
00D7A:  DATA 20,0A
00D7C:  DATA 0D,00
00D7E:  DATA 20,20
00D80:  DATA 20,20
00D82:  DATA 20,20
00D84:  DATA 20,49
00D86:  DATA 4E,43
00D88:  DATA 3A,25
00D8A:  DATA 32,75
00D8C:  DATA 20,20
00D8E:  DATA 20,20
00D90:  DATA 20,0A
00D92:  DATA 0D,00
00D94:  DATA 20,20
00D96:  DATA 20,20
00D98:  DATA 20,20
00D9A:  DATA 20,45
00D9C:  DATA 53,43
00D9E:  DATA 3A,42
00DA0:  DATA 41,43
00DA2:  DATA 4B,20
00DA4:  DATA 20,20
00DA6:  DATA 20,20
00DA8:  DATA 20,0A
00DAA:  DATA 0D,00
00DAC:  DATA 20,45
00DAE:  DATA 58,45
00DB0:  DATA 43,55
00DB2:  DATA 54,41
00DB4:  DATA 4E,44
00DB6:  DATA 4F,20
00DB8:  DATA 50,52
00DBA:  DATA 4F,47
00DBC:  DATA 52,41
00DBE:  DATA 4D,41
00DC0:  DATA 0A,0D
00DC2:  DATA 00,00
00DC4:  DATA 20,20
00DC6:  DATA 20,20
00DC8:  DATA 20,4D
00DCA:  DATA 4F,44
00DCC:  DATA 45,4C
00DCE:  DATA 4F,3A
00DD0:  DATA 25,30
00DD2:  DATA 32,75
00DD4:  DATA 20,20
00DD6:  DATA 20,20
00DD8:  DATA 0A,0D
00DDA:  DATA 00,00
00DDC:  DATA 20,20
00DDE:  DATA 20,20
00DE0:  DATA 20,20
00DE2:  DATA 20,20
00DE4:  DATA 20,20
00DE6:  DATA 20,20
00DE8:  DATA 20,20
00DEA:  DATA 20,20
00DEC:  DATA 20,20
00DEE:  DATA 20,20
00DF0:  DATA 0A,0D
00DF2:  DATA 00,00
00DF4:  DATA 20,20
00DF6:  DATA 20,20
00DF8:  DATA 20,20
00DFA:  DATA 45,53
00DFC:  DATA 43,3A
00DFE:  DATA 53,54
00E00:  DATA 4F,50
00E02:  DATA 20,20
00E04:  DATA 20,20
00E06:  DATA 20,20
00E08:  DATA 0A,0D
00E0A:  DATA 00,00
00E0C:  DATA 20,20
00E0E:  DATA 50,4F
00E10:  DATA 53,49
00E12:  DATA 43,41
00E14:  DATA 4F,20
00E16:  DATA 49,52
00E18:  DATA 52,45
00E1A:  DATA 47,55
00E1C:  DATA 4C,41
00E1E:  DATA 52,20
00E20:  DATA 0A,0D
00E22:  DATA 00,00
00E24:  DATA 20,20
00E26:  DATA 20,58
00E28:  DATA 20,44
00E2A:  DATA 45,56
00E2C:  DATA 45,20
00E2E:  DATA 53,45
00E30:  DATA 52,20
00E32:  DATA 3E,20
00E34:  DATA 30,20
00E36:  DATA 20,20
00E38:  DATA 0A,0D
00E3A:  DATA 00,00
00E3C:  DATA 20,20
00E3E:  DATA 59,20
00E40:  DATA 44,45
00E42:  DATA 56,45
00E44:  DATA 20,53
00E46:  DATA 45,52
00E48:  DATA 20,3E
00E4A:  DATA 20,37
00E4C:  DATA 30,30
00E4E:  DATA 20,20
00E50:  DATA 0A,0D
00E52:  DATA 00,00
00E54:  DATA 20,20
00E56:  DATA 43,41
00E58:  DATA 52,52
00E5A:  DATA 45,47
00E5C:  DATA 41,4E
00E5E:  DATA 44,4F
00E60:  DATA 20,4D
00E62:  DATA 4F,44
00E64:  DATA 45,4C
00E66:  DATA 4F,20
00E68:  DATA 0A,0D
00E6A:  DATA 00,00
00E6C:  DATA 20,20
00E6E:  DATA 43,41
00E70:  DATA 52,52
00E72:  DATA 45,47
00E74:  DATA 41,4E
00E76:  DATA 44,4F
00E78:  DATA 20,4D
00E7A:  DATA 4F,44
00E7C:  DATA 45,4C
00E7E:  DATA 4F,20
00E80:  DATA 0A,0D
00E82:  DATA 00,00
00E84:  DATA 20,20
00E86:  DATA 20,45
00E88:  DATA 53,50
00E8A:  DATA 45,52
00E8C:  DATA 41,4E
00E8E:  DATA 44,4F
00E90:  DATA 20,50
00E92:  DATA 4C,41
00E94:  DATA 43,41
00E96:  DATA 20,20
00E98:  DATA 20,0A
00E9A:  DATA 0D,00
00E9C:  DATA 20,20
00E9E:  DATA 20,20
00EA0:  DATA 20,4E
00EA2:  DATA 41,20
00EA4:  DATA 45,53
00EA6:  DATA 54,45
00EA8:  DATA 49,52
00EAA:  DATA 41,20
00EAC:  DATA 20,20
00EAE:  DATA 20,20
00EB0:  DATA 0A,0D
00EB2:  DATA 00,00
00EB4:  DATA 20,56
00EB6:  DATA 45,52
00EB8:  DATA 49,46
00EBA:  DATA 49,51
00EBC:  DATA 55,45
00EBE:  DATA 20,4F
00EC0:  DATA 20,4E
00EC2:  DATA 55,4D
00EC4:  DATA 45,52
00EC6:  DATA 4F,20
00EC8:  DATA 0A,0D
00ECA:  DATA 00,00
00ECC:  DATA 20,44
00ECE:  DATA 45,20
00ED0:  DATA 50,4F
00ED2:  DATA 4E,54
00ED4:  DATA 4F,53
00ED6:  DATA 20,4E
00ED8:  DATA 4F,20
00EDA:  DATA 4D,4F
00EDC:  DATA 44,45
00EDE:  DATA 4C,4F
00EE0:  DATA 0A,0D
00EE2:  DATA 00,00
00EE4:  DATA 20,20
00EE6:  DATA 20,47
00EE8:  DATA 52,41
00EEA:  DATA 56,41
00EEC:  DATA 4E,44
00EEE:  DATA 4F,20
00EF0:  DATA 50,4F
00EF2:  DATA 4E,54
00EF4:  DATA 4F,53
00EF6:  DATA 20,20
00EF8:  DATA 0A,0D
00EFA:  DATA 00,00
00EFC:  DATA 50,4F
00EFE:  DATA 4E,54
00F00:  DATA 4F,53
00F02:  DATA 20,41
00F04:  DATA 54,55
00F06:  DATA 41,4C
00F08:  DATA 49,5A
00F0A:  DATA 41,44
00F0C:  DATA 4F,53
00F0E:  DATA 0A,0D
00F10:  DATA 00,00
00F12:  DATA 20,20
00F14:  DATA 45,58
00F16:  DATA 43,4C
00F18:  DATA 55,49
00F1A:  DATA 4E,44
00F1C:  DATA 4F,20
00F1E:  DATA 4D,4F
00F20:  DATA 44,45
00F22:  DATA 4C,4F
00F24:  DATA 20,20
00F26:  DATA 0A,0D
00F28:  DATA 00,00
00F2A:  DATA 20,20
00F2C:  DATA 20,4D
00F2E:  DATA 4F,44
00F30:  DATA 45,4C
00F32:  DATA 4F,20
00F34:  DATA 45,58
00F36:  DATA 43,55
00F38:  DATA 49,44
00F3A:  DATA 4F,20
00F3C:  DATA 20,20
00F3E:  DATA 0A,0D
00F40:  DATA 00,00
00F42:  DATA 20,20
00F44:  DATA 20,47
00F46:  DATA 52,41
00F48:  DATA 56,41
00F4A:  DATA 4E,44
00F4C:  DATA 4F,20
00F4E:  DATA 50,4F
00F50:  DATA 4E,54
00F52:  DATA 4F,20
00F54:  DATA 20,20
00F56:  DATA 0A,0D
00F58:  DATA 00,00
00F5A:  DATA 20,20
00F5C:  DATA 20,20
00F5E:  DATA 50,4F
00F60:  DATA 4E,54
00F62:  DATA 4F,20
00F64:  DATA 47,52
00F66:  DATA 41,56
00F68:  DATA 41,44
00F6A:  DATA 4F,20
00F6C:  DATA 20,20
00F6E:  DATA 0A,0D
00F70:  DATA 00,00
00F72:  DATA 20,20
00F74:  DATA 20,20
00F76:  DATA 53,45
00F78:  DATA 4D,20
00F7A:  DATA 53,4F
00F7C:  DATA 4C,44
00F7E:  DATA 41,20
00F80:  DATA 4E,4F
00F82:  DATA 53,20
00F84:  DATA 20,20
00F86:  DATA 0A,0D
00F88:  DATA 00,00
00F8A:  DATA 20,20
00F8C:  DATA 20,20
00F8E:  DATA 41,4C
00F90:  DATA 49,4D
00F92:  DATA 45,4E
00F94:  DATA 54,41
00F96:  DATA 44,4F
00F98:  DATA 52,45
00F9A:  DATA 53,20
00F9C:  DATA 20,20
00F9E:  DATA 0A,0D
00FA0:  DATA 00,00
00FA2:  DATA 20,20
00FA4:  DATA 20,47
00FA6:  DATA 52,41
00FA8:  DATA 56,41
00FAA:  DATA 4E,44
00FAC:  DATA 4F,20
00FAE:  DATA 50,4F
00FB0:  DATA 4E,54
00FB2:  DATA 4F,20
00FB4:  DATA 20,20
00FB6:  DATA 0A,0D
00FB8:  DATA 00,00
00FBA:  DATA 20,20
00FBC:  DATA 20,20
00FBE:  DATA 50,4F
00FC0:  DATA 4E,54
00FC2:  DATA 4F,20
00FC4:  DATA 47,52
00FC6:  DATA 41,56
00FC8:  DATA 41,44
00FCA:  DATA 4F,20
00FCC:  DATA 20,20
00FCE:  DATA 0A,0D
00FD0:  DATA 00,00
00FD2:  DATA 20,20
00FD4:  DATA 20,20
00FD6:  DATA 53,45
00FD8:  DATA 4D,20
00FDA:  DATA 53,4F
00FDC:  DATA 4C,44
00FDE:  DATA 41,20
00FE0:  DATA 4E,4F
00FE2:  DATA 53,20
00FE4:  DATA 20,20
00FE6:  DATA 0A,0D
00FE8:  DATA 00,00
00FEA:  DATA 20,20
00FEC:  DATA 20,20
00FEE:  DATA 41,4C
00FF0:  DATA 49,4D
00FF2:  DATA 45,4E
00FF4:  DATA 54,41
00FF6:  DATA 44,4F
00FF8:  DATA 52,45
00FFA:  DATA 53,20
00FFC:  DATA 20,20
00FFE:  DATA 0A,0D
01000:  DATA 00,00
01002:  DATA 20,20
01004:  DATA 56,45
01006:  DATA 52,49
01008:  DATA 46,49
0100A:  DATA 43,41
0100C:  DATA 4E,44
0100E:  DATA 4F,20
01010:  DATA 53,4F
01012:  DATA 4C,44
01014:  DATA 41,20
01016:  DATA 0A,0D
01018:  DATA 00,00
0101A:  DATA 20,56
0101C:  DATA 45,52
0101E:  DATA 49,46
01020:  DATA 49,51
01022:  DATA 55,45
01024:  DATA 20,4E
01026:  DATA 4F,56
01028:  DATA 41,4D
0102A:  DATA 45,4E
0102C:  DATA 54,45
0102E:  DATA 0A,0D
01030:  DATA 00,00
01032:  DATA 20,20
01034:  DATA 20,20
01036:  DATA 20,20
01038:  DATA 20,41
0103A:  DATA 20,53
0103C:  DATA 4F,4C
0103E:  DATA 44,41
01040:  DATA 20,20
01042:  DATA 20,20
01044:  DATA 20,20
01046:  DATA 0A,0D
01048:  DATA 00,00
0104A:  DATA 20,20
0104C:  DATA 20,20
0104E:  DATA 20,20
01050:  DATA 53,4F
01052:  DATA 4C,44
01054:  DATA 41,20
01056:  DATA 4F,4B
01058:  DATA 20,20
0105A:  DATA 20,20
0105C:  DATA 20,20
0105E:  DATA 0A,0D
01060:  DATA 00,00
01062:  DATA 52,45
01064:  DATA 49,4E
01066:  DATA 49,43
01068:  DATA 49,4F
0106A:  DATA 20,44
0106C:  DATA 4F,20
0106E:  DATA 50,52
01070:  DATA 4F,47
01072:  DATA 52,41
01074:  DATA 4D,41
01076:  DATA 0A,0D
01078:  DATA 00,00
0107A:  DATA 20,20
0107C:  DATA 20,41
0107E:  DATA 4F,20
01080:  DATA 46,49
01082:  DATA 4D,20
01084:  DATA 44,4F
01086:  DATA 20,43
01088:  DATA 49,43
0108A:  DATA 4C,4F
0108C:  DATA 20,20
0108E:  DATA 0A,0D
01090:  DATA 00,00
01092:  DATA 20,20
01094:  DATA 20,45
01096:  DATA 53,50
01098:  DATA 45,52
0109A:  DATA 41,4E
0109C:  DATA 44,4F
0109E:  DATA 20,50
010A0:  DATA 4C,41
010A2:  DATA 43,41
010A4:  DATA 20,20
010A6:  DATA 20,0A
010A8:  DATA 0D,00
010AA:  DATA 20,20
010AC:  DATA 20,20
010AE:  DATA 20,4E
010B0:  DATA 41,20
010B2:  DATA 45,53
010B4:  DATA 54,45
010B6:  DATA 49,52
010B8:  DATA 41,20
010BA:  DATA 20,20
010BC:  DATA 20,20
010BE:  DATA 0A,0D
010C0:  DATA 00,00
010C2:  DATA 52,45
010C4:  DATA 49,4E
010C6:  DATA 49,43
010C8:  DATA 49,4F
010CA:  DATA 20,44
010CC:  DATA 4F,20
010CE:  DATA 50,52
010D0:  DATA 4F,47
010D2:  DATA 52,41
010D4:  DATA 4D,41
010D6:  DATA 0A,0D
010D8:  DATA 00,00
010DA:  DATA 20,20
010DC:  DATA 20,41
010DE:  DATA 4F,20
010E0:  DATA 46,49
010E2:  DATA 4D,20
010E4:  DATA 44,4F
010E6:  DATA 20,43
010E8:  DATA 49,43
010EA:  DATA 4C,4F
010EC:  DATA 20,20
010EE:  DATA 0A,0D
010F0:  DATA 00,00
010F2:  DATA 20,20
010F4:  DATA 20,20
010F6:  DATA 20,20
010F8:  DATA 53,45
010FA:  DATA 4D,20
010FC:  DATA 50,4C
010FE:  DATA 41,43
01100:  DATA 41,20
01102:  DATA 20,20
01104:  DATA 20,20
01106:  DATA 0A,0D
01108:  DATA 00,00
0110A:  DATA 20,20
0110C:  DATA 20,20
0110E:  DATA 20,4E
01110:  DATA 41,20
01112:  DATA 42,41
01114:  DATA 4E,44
01116:  DATA 45,4A
01118:  DATA 41,20
0111A:  DATA 20,20
0111C:  DATA 20,20
0111E:  DATA 0A,0D
01120:  DATA 00,00
01122:  DATA 52,45
01124:  DATA 49,4E
01126:  DATA 49,43
01128:  DATA 49,4F
0112A:  DATA 20,44
0112C:  DATA 4F,20
0112E:  DATA 50,52
01130:  DATA 4F,47
01132:  DATA 52,41
01134:  DATA 4D,41
01136:  DATA 0A,0D
01138:  DATA 00,00
0113A:  DATA 20,20
0113C:  DATA 20,41
0113E:  DATA 4F,20
01140:  DATA 46,49
01142:  DATA 4D,20
01144:  DATA 44,4F
01146:  DATA 20,43
01148:  DATA 49,43
0114A:  DATA 4C,4F
0114C:  DATA 20,20
0114E:  DATA 0A,0D
01150:  DATA 00,00
01152:  DATA 52,45
01154:  DATA 49,4E
01156:  DATA 49,43
01158:  DATA 49,4F
0115A:  DATA 20,44
0115C:  DATA 4F,20
0115E:  DATA 50,52
01160:  DATA 4F,47
01162:  DATA 52,41
01164:  DATA 4D,41
01166:  DATA 0A,0D
01168:  DATA 00,00
0116A:  DATA 20,20
0116C:  DATA 20,41
0116E:  DATA 4F,20
01170:  DATA 46,49
01172:  DATA 4D,20
01174:  DATA 44,4F
01176:  DATA 20,43
01178:  DATA 49,43
0117A:  DATA 4C,4F
0117C:  DATA 20,20
0117E:  DATA 0A,0D
01180:  DATA 00,00
01182:  DATA 52,45
01184:  DATA 49,4E
01186:  DATA 49,43
01188:  DATA 49,4F
0118A:  DATA 20,44
0118C:  DATA 4F,20
0118E:  DATA 50,52
01190:  DATA 4F,47
01192:  DATA 52,41
01194:  DATA 4D,41
01196:  DATA 0A,0D
01198:  DATA 00,00
0119A:  DATA 20,20
0119C:  DATA 20,41
0119E:  DATA 4F,20
011A0:  DATA 46,49
011A2:  DATA 4D,20
011A4:  DATA 44,4F
011A6:  DATA 20,43
011A8:  DATA 49,43
011AA:  DATA 4C,4F
011AC:  DATA 20,20
011AE:  DATA 0A,0D
011B0:  DATA 00,00
011B2:  DATA 52,45
011B4:  DATA 49,4E
011B6:  DATA 49,43
011B8:  DATA 49,4F
011BA:  DATA 20,44
011BC:  DATA 4F,20
011BE:  DATA 50,52
011C0:  DATA 4F,47
011C2:  DATA 52,41
011C4:  DATA 4D,41
011C6:  DATA 0A,0D
011C8:  DATA 00,00
011CA:  DATA 20,20
011CC:  DATA 20,41
011CE:  DATA 4F,20
011D0:  DATA 46,49
011D2:  DATA 4D,20
011D4:  DATA 44,4F
011D6:  DATA 20,43
011D8:  DATA 49,43
011DA:  DATA 4C,4F
011DC:  DATA 20,20
011DE:  DATA 0A,0D
011E0:  DATA 00,00
011E2:  DATA 52,45
011E4:  DATA 49,4E
011E6:  DATA 49,43
011E8:  DATA 49,4F
011EA:  DATA 20,44
011EC:  DATA 4F,20
011EE:  DATA 50,52
011F0:  DATA 4F,47
011F2:  DATA 52,41
011F4:  DATA 4D,41
011F6:  DATA 0A,0D
011F8:  DATA 00,00
011FA:  DATA 20,20
011FC:  DATA 20,41
011FE:  DATA 4F,20
01200:  DATA 46,49
01202:  DATA 4D,20
01204:  DATA 44,4F
01206:  DATA 20,43
01208:  DATA 49,43
0120A:  DATA 4C,4F
0120C:  DATA 20,20
0120E:  DATA 0A,0D
01210:  DATA 00,00
01212:  DATA 52,45
01214:  DATA 49,4E
01216:  DATA 49,43
01218:  DATA 49,4F
0121A:  DATA 20,44
0121C:  DATA 4F,20
0121E:  DATA 50,52
01220:  DATA 4F,47
01222:  DATA 52,41
01224:  DATA 4D,41
01226:  DATA 0A,0D
01228:  DATA 00,00
0122A:  DATA 20,20
0122C:  DATA 20,41
0122E:  DATA 4F,20
01230:  DATA 46,49
01232:  DATA 4D,20
01234:  DATA 44,4F
01236:  DATA 20,43
01238:  DATA 49,43
0123A:  DATA 4C,4F
0123C:  DATA 20,20
0123E:  DATA 0A,0D
01240:  DATA 00,00
01242:  DATA 52,45
01244:  DATA 49,4E
01246:  DATA 49,43
01248:  DATA 49,4F
0124A:  DATA 20,44
0124C:  DATA 4F,20
0124E:  DATA 50,52
01250:  DATA 4F,47
01252:  DATA 52,41
01254:  DATA 4D,41
01256:  DATA 0A,0D
01258:  DATA 00,00
0125A:  DATA 20,20
0125C:  DATA 20,41
0125E:  DATA 4F,20
01260:  DATA 46,49
01262:  DATA 4D,20
01264:  DATA 44,4F
01266:  DATA 20,43
01268:  DATA 49,43
0126A:  DATA 4C,4F
0126C:  DATA 20,20
0126E:  DATA 0A,0D
01270:  DATA 00,00
*
02BE4:  TBLRD*+
02BE6:  MOVF   FF5,F
02BE8:  BZ    2C02
02BEA:  MOVFF  FF6,576
02BEE:  MOVFF  FF7,577
02BF2:  MOVFF  FF5,587
02BF6:  RCALL  2BD8
02BF8:  MOVFF  576,FF6
02BFC:  MOVFF  577,FF7
02C00:  BRA    2BE4
02C02:  RETURN 0
*
02D86:  TBLRD*+
02D88:  MOVF   FF5,F
02D8A:  BZ    2DA4
02D8C:  MOVFF  FF6,57D
02D90:  MOVFF  FF7,57E
02D94:  MOVFF  FF5,586
02D98:  RCALL  2D32
02D9A:  MOVFF  57D,FF6
02D9E:  MOVFF  57E,FF7
02DA2:  BRA    2D86
02DA4:  RETURN 0
*
02F24:  MOVLB  5
02F26:  MOVF   x90,W
02F28:  BTFSC  FD8.2
02F2A:  BRA    300E
02F2C:  MOVWF  00
02F2E:  MOVF   x94,W
02F30:  BTFSC  FD8.2
02F32:  BRA    300E
02F34:  ADDWF  00,F
02F36:  BNC   2F40
02F38:  MOVLW  81
02F3A:  ADDWF  00,F
02F3C:  BC    300E
02F3E:  BRA    2F48
02F40:  MOVLW  7F
02F42:  SUBWF  00,F
02F44:  BNC   300E
02F46:  BZ    300E
02F48:  MOVFF  591,598
02F4C:  MOVF   x95,W
02F4E:  XORWF  x98,F
02F50:  BSF    x91.7
02F52:  BSF    x95.7
02F54:  MOVF   x93,W
02F56:  MULWF  x97
02F58:  MOVFF  FF4,59A
02F5C:  MOVF   x92,W
02F5E:  MULWF  x96
02F60:  MOVFF  FF4,03
02F64:  MOVFF  FF3,599
02F68:  MULWF  x97
02F6A:  MOVF   FF3,W
02F6C:  ADDWF  x9A,F
02F6E:  MOVF   FF4,W
02F70:  ADDWFC x99,F
02F72:  MOVLW  00
02F74:  ADDWFC 03,F
02F76:  MOVF   x93,W
02F78:  MULWF  x96
02F7A:  MOVF   FF3,W
02F7C:  ADDWF  x9A,F
02F7E:  MOVF   FF4,W
02F80:  ADDWFC x99,F
02F82:  MOVLW  00
02F84:  CLRF   02
02F86:  ADDWFC 03,F
02F88:  ADDWFC 02,F
02F8A:  MOVF   x91,W
02F8C:  MULWF  x97
02F8E:  MOVF   FF3,W
02F90:  ADDWF  x99,F
02F92:  MOVF   FF4,W
02F94:  ADDWFC 03,F
02F96:  MOVLW  00
02F98:  ADDWFC 02,F
02F9A:  MOVF   x91,W
02F9C:  MULWF  x96
02F9E:  MOVF   FF3,W
02FA0:  ADDWF  03,F
02FA2:  MOVF   FF4,W
02FA4:  ADDWFC 02,F
02FA6:  MOVLW  00
02FA8:  CLRF   01
02FAA:  ADDWFC 01,F
02FAC:  MOVF   x93,W
02FAE:  MULWF  x95
02FB0:  MOVF   FF3,W
02FB2:  ADDWF  x99,F
02FB4:  MOVF   FF4,W
02FB6:  ADDWFC 03,F
02FB8:  MOVLW  00
02FBA:  ADDWFC 02,F
02FBC:  ADDWFC 01,F
02FBE:  MOVF   x92,W
02FC0:  MULWF  x95
02FC2:  MOVF   FF3,W
02FC4:  ADDWF  03,F
02FC6:  MOVF   FF4,W
02FC8:  ADDWFC 02,F
02FCA:  MOVLW  00
02FCC:  ADDWFC 01,F
02FCE:  MOVF   x91,W
02FD0:  MULWF  x95
02FD2:  MOVF   FF3,W
02FD4:  ADDWF  02,F
02FD6:  MOVF   FF4,W
02FD8:  ADDWFC 01,F
02FDA:  INCF   00,F
02FDC:  BTFSC  01.7
02FDE:  BRA    2FEA
02FE0:  RLCF   x99,F
02FE2:  RLCF   03,F
02FE4:  RLCF   02,F
02FE6:  RLCF   01,F
02FE8:  DECF   00,F
02FEA:  MOVLW  00
02FEC:  BTFSS  x99.7
02FEE:  BRA    3004
02FF0:  INCF   03,F
02FF2:  ADDWFC 02,F
02FF4:  ADDWFC 01,F
02FF6:  MOVF   01,W
02FF8:  BNZ   3004
02FFA:  MOVF   02,W
02FFC:  BNZ   3004
02FFE:  MOVF   03,W
03000:  BNZ   3004
03002:  INCF   00,F
03004:  BTFSC  x98.7
03006:  BSF    01.7
03008:  BTFSS  x98.7
0300A:  BCF    01.7
0300C:  BRA    3016
0300E:  CLRF   00
03010:  CLRF   01
03012:  CLRF   02
03014:  CLRF   03
03016:  MOVLB  0
03018:  RETURN 0
0301A:  MOVLB  5
0301C:  MOVF   x96,W
0301E:  BTFSC  FD8.2
03020:  BRA    316C
03022:  MOVWF  xA2
03024:  MOVF   x9A,W
03026:  BTFSC  FD8.2
03028:  BRA    316C
0302A:  SUBWF  xA2,F
0302C:  BNC   3038
0302E:  MOVLW  7F
03030:  ADDWF  xA2,F
03032:  BTFSC  FD8.0
03034:  BRA    316C
03036:  BRA    3044
03038:  MOVLW  81
0303A:  SUBWF  xA2,F
0303C:  BTFSS  FD8.0
0303E:  BRA    316C
03040:  BTFSC  FD8.2
03042:  BRA    316C
03044:  MOVFF  5A2,00
03048:  CLRF   01
0304A:  CLRF   02
0304C:  CLRF   03
0304E:  CLRF   xA1
03050:  MOVFF  597,5A0
03054:  BSF    xA0.7
03056:  MOVFF  598,59F
0305A:  MOVFF  599,59E
0305E:  MOVLW  19
03060:  MOVWF  xA2
03062:  MOVF   x9D,W
03064:  SUBWF  x9E,F
03066:  BC    3082
03068:  MOVLW  01
0306A:  SUBWF  x9F,F
0306C:  BC    3082
0306E:  SUBWF  xA0,F
03070:  BC    3082
03072:  SUBWF  xA1,F
03074:  BC    3082
03076:  INCF   xA1,F
03078:  INCF   xA0,F
0307A:  INCF   x9F,F
0307C:  MOVF   x9D,W
0307E:  ADDWF  x9E,F
03080:  BRA    30D2
03082:  MOVF   x9C,W
03084:  SUBWF  x9F,F
03086:  BC    30AC
03088:  MOVLW  01
0308A:  SUBWF  xA0,F
0308C:  BC    30AC
0308E:  SUBWF  xA1,F
03090:  BC    30AC
03092:  INCF   xA1,F
03094:  INCF   xA0,F
03096:  MOVF   x9C,W
03098:  ADDWF  x9F,F
0309A:  MOVF   x9D,W
0309C:  ADDWF  x9E,F
0309E:  BNC   30D2
030A0:  INCF   x9F,F
030A2:  BNZ   30D2
030A4:  INCF   xA0,F
030A6:  BNZ   30D2
030A8:  INCF   xA1,F
030AA:  BRA    30D2
030AC:  MOVF   x9B,W
030AE:  IORLW  80
030B0:  SUBWF  xA0,F
030B2:  BC    30D0
030B4:  MOVLW  01
030B6:  SUBWF  xA1,F
030B8:  BC    30D0
030BA:  INCF   xA1,F
030BC:  MOVF   x9B,W
030BE:  IORLW  80
030C0:  ADDWF  xA0,F
030C2:  MOVF   x9C,W
030C4:  ADDWF  x9F,F
030C6:  BNC   309A
030C8:  INCF   xA0,F
030CA:  BNZ   309A
030CC:  INCF   xA1,F
030CE:  BRA    309A
030D0:  BSF    03.0
030D2:  DECFSZ xA2,F
030D4:  BRA    30D8
030D6:  BRA    30EE
030D8:  BCF    FD8.0
030DA:  RLCF   x9E,F
030DC:  RLCF   x9F,F
030DE:  RLCF   xA0,F
030E0:  RLCF   xA1,F
030E2:  BCF    FD8.0
030E4:  RLCF   03,F
030E6:  RLCF   02,F
030E8:  RLCF   01,F
030EA:  RLCF   xA3,F
030EC:  BRA    3062
030EE:  BTFSS  xA3.0
030F0:  BRA    30FE
030F2:  BCF    FD8.0
030F4:  RRCF   01,F
030F6:  RRCF   02,F
030F8:  RRCF   03,F
030FA:  RRCF   xA3,F
030FC:  BRA    3102
030FE:  DECF   00,F
03100:  BZ    316C
03102:  BTFSC  xA3.7
03104:  BRA    3142
03106:  BCF    FD8.0
03108:  RLCF   x9E,F
0310A:  RLCF   x9F,F
0310C:  RLCF   xA0,F
0310E:  RLCF   xA1,F
03110:  MOVF   x9D,W
03112:  SUBWF  x9E,F
03114:  BC    3124
03116:  MOVLW  01
03118:  SUBWF  x9F,F
0311A:  BC    3124
0311C:  SUBWF  xA0,F
0311E:  BC    3124
03120:  SUBWF  xA1,F
03122:  BNC   3158
03124:  MOVF   x9C,W
03126:  SUBWF  x9F,F
03128:  BC    3134
0312A:  MOVLW  01
0312C:  SUBWF  xA0,F
0312E:  BC    3134
03130:  SUBWF  xA1,F
03132:  BNC   3158
03134:  MOVF   x9B,W
03136:  IORLW  80
03138:  SUBWF  xA0,F
0313A:  BC    3142
0313C:  MOVLW  01
0313E:  SUBWF  xA1,F
03140:  BNC   3158
03142:  INCF   03,F
03144:  BNZ   3158
03146:  INCF   02,F
03148:  BNZ   3158
0314A:  INCF   01,F
0314C:  BNZ   3158
0314E:  INCF   00,F
03150:  BZ    316C
03152:  RRCF   01,F
03154:  RRCF   02,F
03156:  RRCF   03,F
03158:  MOVFF  597,5A2
0315C:  MOVF   x9B,W
0315E:  XORWF  xA2,F
03160:  BTFSS  xA2.7
03162:  BRA    3168
03164:  BSF    01.7
03166:  BRA    3174
03168:  BCF    01.7
0316A:  BRA    3174
0316C:  CLRF   00
0316E:  CLRF   01
03170:  CLRF   02
03172:  CLRF   03
03174:  MOVLB  0
03176:  RETURN 0
03178:  MOVLW  8E
0317A:  MOVWF  00
0317C:  MOVFF  591,01
03180:  MOVFF  590,02
03184:  CLRF   03
03186:  MOVF   01,F
03188:  BNZ   319C
0318A:  MOVFF  02,01
0318E:  CLRF   02
03190:  MOVLW  08
03192:  SUBWF  00,F
03194:  MOVF   01,F
03196:  BNZ   319C
03198:  CLRF   00
0319A:  BRA    31AC
0319C:  BCF    FD8.0
0319E:  BTFSC  01.7
031A0:  BRA    31AA
031A2:  RLCF   02,F
031A4:  RLCF   01,F
031A6:  DECF   00,F
031A8:  BRA    319C
031AA:  BCF    01.7
031AC:  RETURN 0
031AE:  MOVLW  80
031B0:  BTFSS  FD8.1
031B2:  BRA    31B8
031B4:  MOVLB  5
031B6:  XORWF  x9B,F
031B8:  MOVLB  5
031BA:  CLRF   xA0
031BC:  CLRF   xA1
031BE:  MOVFF  597,59F
031C2:  MOVF   x9B,W
031C4:  XORWF  x9F,F
031C6:  MOVF   x96,W
031C8:  BTFSC  FD8.2
031CA:  BRA    338A
031CC:  MOVWF  x9E
031CE:  MOVWF  00
031D0:  MOVF   x9A,W
031D2:  BTFSC  FD8.2
031D4:  BRA    339C
031D6:  SUBWF  x9E,F
031D8:  BTFSC  FD8.2
031DA:  BRA    32E2
031DC:  BNC   325A
031DE:  MOVFF  59B,5A4
031E2:  BSF    xA4.7
031E4:  MOVFF  59C,5A3
031E8:  MOVFF  59D,5A2
031EC:  CLRF   xA1
031EE:  BCF    FD8.0
031F0:  RRCF   xA4,F
031F2:  RRCF   xA3,F
031F4:  RRCF   xA2,F
031F6:  RRCF   xA1,F
031F8:  DECFSZ x9E,F
031FA:  BRA    31EC
031FC:  BTFSS  x9F.7
031FE:  BRA    3206
03200:  BSF    xA0.0
03202:  BRA    33C4
03204:  BCF    xA0.0
03206:  BCF    x9E.0
03208:  BSF    xA0.4
0320A:  MOVLW  05
0320C:  MOVWF  FEA
0320E:  MOVLW  99
03210:  MOVWF  FE9
03212:  BRA    33EA
03214:  BCF    xA0.4
03216:  BTFSC  x9F.7
03218:  BRA    322E
0321A:  BTFSS  x9E.0
0321C:  BRA    3244
0321E:  RRCF   xA4,F
03220:  RRCF   xA3,F
03222:  RRCF   xA2,F
03224:  RRCF   xA1,F
03226:  INCF   00,F
03228:  BTFSC  FD8.2
0322A:  BRA    33BA
0322C:  BRA    3244
0322E:  BTFSC  xA4.7
03230:  BRA    324A
03232:  BCF    FD8.0
03234:  RLCF   xA1,F
03236:  RLCF   xA2,F
03238:  RLCF   xA3,F
0323A:  RLCF   xA4,F
0323C:  DECF   00,F
0323E:  BTFSC  FD8.2
03240:  BRA    33BA
03242:  BRA    322E
03244:  BSF    xA0.6
03246:  BRA    3322
03248:  BCF    xA0.6
0324A:  MOVFF  597,59F
0324E:  BTFSS  x97.7
03250:  BRA    3256
03252:  BSF    xA4.7
03254:  BRA    33AC
03256:  BCF    xA4.7
03258:  BRA    33AC
0325A:  MOVFF  59A,59E
0325E:  MOVFF  59A,00
03262:  MOVF   x96,W
03264:  SUBWF  x9E,F
03266:  MOVFF  597,5A4
0326A:  BSF    xA4.7
0326C:  MOVFF  598,5A3
03270:  MOVFF  599,5A2
03274:  CLRF   xA1
03276:  BCF    FD8.0
03278:  RRCF   xA4,F
0327A:  RRCF   xA3,F
0327C:  RRCF   xA2,F
0327E:  RRCF   xA1,F
03280:  DECFSZ x9E,F
03282:  BRA    3274
03284:  BTFSS  x9F.7
03286:  BRA    328E
03288:  BSF    xA0.1
0328A:  BRA    33C4
0328C:  BCF    xA0.1
0328E:  BCF    x9E.0
03290:  BSF    xA0.5
03292:  MOVLW  05
03294:  MOVWF  FEA
03296:  MOVLW  9D
03298:  MOVWF  FE9
0329A:  BRA    33EA
0329C:  BCF    xA0.5
0329E:  BTFSC  x9F.7
032A0:  BRA    32B6
032A2:  BTFSS  x9E.0
032A4:  BRA    32CC
032A6:  RRCF   xA4,F
032A8:  RRCF   xA3,F
032AA:  RRCF   xA2,F
032AC:  RRCF   xA1,F
032AE:  INCF   00,F
032B0:  BTFSC  FD8.2
032B2:  BRA    33BA
032B4:  BRA    32CC
032B6:  BTFSC  xA4.7
032B8:  BRA    32D2
032BA:  BCF    FD8.0
032BC:  RLCF   xA1,F
032BE:  RLCF   xA2,F
032C0:  RLCF   xA3,F
032C2:  RLCF   xA4,F
032C4:  DECF   00,F
032C6:  BTFSC  FD8.2
032C8:  BRA    33BA
032CA:  BRA    32B6
032CC:  BSF    xA0.7
032CE:  BRA    3322
032D0:  BCF    xA0.7
032D2:  MOVFF  59B,59F
032D6:  BTFSS  x9B.7
032D8:  BRA    32DE
032DA:  BSF    xA4.7
032DC:  BRA    33AC
032DE:  BCF    xA4.7
032E0:  BRA    33AC
032E2:  MOVFF  59B,5A4
032E6:  BSF    xA4.7
032E8:  MOVFF  59C,5A3
032EC:  MOVFF  59D,5A2
032F0:  BTFSS  x9F.7
032F2:  BRA    32FC
032F4:  BCF    xA4.7
032F6:  BSF    xA0.2
032F8:  BRA    33C4
032FA:  BCF    xA0.2
032FC:  CLRF   xA1
032FE:  BCF    x9E.0
03300:  MOVLW  05
03302:  MOVWF  FEA
03304:  MOVLW  99
03306:  MOVWF  FE9
03308:  BRA    33EA
0330A:  BTFSC  x9F.7
0330C:  BRA    3346
0330E:  MOVFF  597,59F
03312:  BTFSS  x9E.0
03314:  BRA    3322
03316:  RRCF   xA4,F
03318:  RRCF   xA3,F
0331A:  RRCF   xA2,F
0331C:  RRCF   xA1,F
0331E:  INCF   00,F
03320:  BZ    33BA
03322:  BTFSS  xA1.7
03324:  BRA    333C
03326:  INCF   xA2,F
03328:  BNZ   333C
0332A:  INCF   xA3,F
0332C:  BNZ   333C
0332E:  INCF   xA4,F
03330:  BNZ   333C
03332:  RRCF   xA4,F
03334:  RRCF   xA3,F
03336:  RRCF   xA2,F
03338:  INCF   00,F
0333A:  BZ    33BA
0333C:  BTFSC  xA0.6
0333E:  BRA    3248
03340:  BTFSC  xA0.7
03342:  BRA    32D0
03344:  BRA    337E
03346:  MOVLW  80
03348:  XORWF  xA4,F
0334A:  BTFSS  xA4.7
0334C:  BRA    3356
0334E:  BRA    33C4
03350:  MOVFF  59B,59F
03354:  BRA    336A
03356:  MOVFF  597,59F
0335A:  MOVF   xA4,F
0335C:  BNZ   336A
0335E:  MOVF   xA3,F
03360:  BNZ   336A
03362:  MOVF   xA2,F
03364:  BNZ   336A
03366:  CLRF   00
03368:  BRA    33AC
0336A:  BTFSC  xA4.7
0336C:  BRA    337E
0336E:  BCF    FD8.0
03370:  RLCF   xA1,F
03372:  RLCF   xA2,F
03374:  RLCF   xA3,F
03376:  RLCF   xA4,F
03378:  DECFSZ 00,F
0337A:  BRA    336A
0337C:  BRA    33BA
0337E:  BTFSS  x9F.7
03380:  BRA    3386
03382:  BSF    xA4.7
03384:  BRA    33AC
03386:  BCF    xA4.7
03388:  BRA    33AC
0338A:  MOVFF  59A,00
0338E:  MOVFF  59B,5A4
03392:  MOVFF  59C,5A3
03396:  MOVFF  59D,5A2
0339A:  BRA    33AC
0339C:  MOVFF  596,00
033A0:  MOVFF  597,5A4
033A4:  MOVFF  598,5A3
033A8:  MOVFF  599,5A2
033AC:  MOVFF  5A4,01
033B0:  MOVFF  5A3,02
033B4:  MOVFF  5A2,03
033B8:  BRA    3422
033BA:  CLRF   00
033BC:  CLRF   01
033BE:  CLRF   02
033C0:  CLRF   03
033C2:  BRA    3422
033C4:  CLRF   xA1
033C6:  COMF   xA2,F
033C8:  COMF   xA3,F
033CA:  COMF   xA4,F
033CC:  COMF   xA1,F
033CE:  INCF   xA1,F
033D0:  BNZ   33DC
033D2:  INCF   xA2,F
033D4:  BNZ   33DC
033D6:  INCF   xA3,F
033D8:  BNZ   33DC
033DA:  INCF   xA4,F
033DC:  BTFSC  xA0.0
033DE:  BRA    3204
033E0:  BTFSC  xA0.1
033E2:  BRA    328C
033E4:  BTFSC  xA0.2
033E6:  BRA    32FA
033E8:  BRA    3350
033EA:  MOVF   FEF,W
033EC:  ADDWF  xA2,F
033EE:  BNC   33FA
033F0:  INCF   xA3,F
033F2:  BNZ   33FA
033F4:  INCF   xA4,F
033F6:  BTFSC  FD8.2
033F8:  BSF    x9E.0
033FA:  MOVF   FED,F
033FC:  MOVF   FEF,W
033FE:  ADDWF  xA3,F
03400:  BNC   3408
03402:  INCF   xA4,F
03404:  BTFSC  FD8.2
03406:  BSF    x9E.0
03408:  MOVF   FED,F
0340A:  MOVF   FEF,W
0340C:  BTFSC  FEF.7
0340E:  BRA    3412
03410:  XORLW  80
03412:  ADDWF  xA4,F
03414:  BTFSC  FD8.0
03416:  BSF    x9E.0
03418:  BTFSC  xA0.4
0341A:  BRA    3214
0341C:  BTFSC  xA0.5
0341E:  BRA    329C
03420:  BRA    330A
03422:  MOVLB  0
03424:  RETURN 0
03426:  MOVLB  5
03428:  CLRF   x8E
0342A:  CLRF   x8F
0342C:  MOVLW  01
0342E:  MOVWF  x90
03430:  CLRF   FDA
03432:  CLRF   FD9
03434:  MOVLW  05
03436:  MOVWF  x93
03438:  MOVLW  86
0343A:  MOVWF  x92
0343C:  MOVLW  05
0343E:  MOVWF  FEA
03440:  MOVLW  8A
03442:  MOVWF  FE9
03444:  MOVFF  593,FE2
03448:  MOVFF  592,FE1
0344C:  MOVFF  590,591
03450:  BCF    FD8.0
03452:  MOVF   FE5,W
03454:  MULWF  FEE
03456:  MOVF   FF3,W
03458:  ADDWFC x8E,F
0345A:  MOVF   FF4,W
0345C:  ADDWFC x8F,F
0345E:  DECFSZ x91,F
03460:  BRA    3450
03462:  MOVFF  58E,FDE
03466:  MOVFF  58F,58E
0346A:  CLRF   x8F
0346C:  BTFSC  FD8.0
0346E:  INCF   x8F,F
03470:  INCF   x92,F
03472:  BTFSC  FD8.2
03474:  INCF   x93,F
03476:  INCF   x90,F
03478:  MOVF   x90,W
0347A:  SUBLW  05
0347C:  BNZ   343C
0347E:  MOVLB  0
03480:  RETURN 0
03482:  MOVLW  B6
03484:  MOVWF  00
03486:  CLRF   03
03488:  CLRF   02
0348A:  CLRF   01
0348C:  MOVLB  5
0348E:  MOVF   x96,W
03490:  IORWF  x97,W
03492:  IORWF  x98,W
03494:  IORWF  x99,W
03496:  BNZ   349C
03498:  CLRF   00
0349A:  BRA    34B6
0349C:  BCF    FD8.0
0349E:  BTFSC  01.7
034A0:  BRA    34B4
034A2:  RLCF   x96,F
034A4:  RLCF   x97,F
034A6:  RLCF   x98,F
034A8:  RLCF   x99,F
034AA:  RLCF   03,F
034AC:  RLCF   02,F
034AE:  RLCF   01,F
034B0:  DECFSZ 00,F
034B2:  BRA    349C
034B4:  BCF    01.7
034B6:  MOVLB  0
034B8:  RETURN 0
034BA:  MOVLB  5
034BC:  MOVF   x96,W
034BE:  SUBLW  B6
034C0:  MOVWF  x96
034C2:  CLRF   03
034C4:  MOVFF  597,59A
034C8:  BSF    x97.7
034CA:  BCF    FD8.0
034CC:  RRCF   x97,F
034CE:  RRCF   x98,F
034D0:  RRCF   x99,F
034D2:  RRCF   03,F
034D4:  RRCF   02,F
034D6:  RRCF   01,F
034D8:  RRCF   00,F
034DA:  DECFSZ x96,F
034DC:  BRA    34CA
034DE:  BTFSS  x9A.7
034E0:  BRA    34F8
034E2:  COMF   00,F
034E4:  COMF   01,F
034E6:  COMF   02,F
034E8:  COMF   03,F
034EA:  INCF   00,F
034EC:  BTFSC  FD8.2
034EE:  INCF   01,F
034F0:  BTFSC  FD8.2
034F2:  INCF   02,F
034F4:  BTFSC  FD8.2
034F6:  INCF   03,F
034F8:  MOVLB  0
034FA:  RETURN 0
*
047B8:  MOVFF  FF2,0D
047BC:  BCF    FF2.7
047BE:  ADDWF  FE8,W
047C0:  CLRF   FF7
047C2:  RLCF   FF7,F
047C4:  ADDLW  DD
047C6:  MOVWF  FF6
047C8:  MOVLW  47
047CA:  ADDWFC FF7,F
047CC:  TBLRD*-
047CE:  MOVF   FF5,W
047D0:  MOVWF  FFA
047D2:  TBLRD*
047D4:  MOVF   FF5,W
047D6:  BTFSC  0D.7
047D8:  BSF    FF2.7
047DA:  MOVWF  FF9
047DC:  DATA 62,47
047DE:  DATA 72,47
047E0:  DATA B2,47
047E2:  DATA 82,47
047E4:  DATA 92,47
047E6:  DATA A2,47
*
04904:  MOVFF  FF2,0D
04908:  BCF    FF2.7
0490A:  ADDWF  FE8,W
0490C:  CLRF   FF7
0490E:  RLCF   FF7,F
04910:  ADDLW  29
04912:  MOVWF  FF6
04914:  MOVLW  49
04916:  ADDWFC FF7,F
04918:  TBLRD*-
0491A:  MOVF   FF5,W
0491C:  MOVWF  FFA
0491E:  TBLRD*
04920:  MOVF   FF5,W
04922:  BTFSC  0D.7
04924:  BSF    FF2.7
04926:  MOVWF  FF9
04928:  DATA FA,47
0492A:  DATA 2E,48
0492C:  DATA FE,48
0492E:  DATA 62,48
04930:  DATA 96,48
04932:  DATA CA,48
*
04C0A:  MOVFF  FF2,0D
04C0E:  BCF    FF2.7
04C10:  ADDWF  FE8,W
04C12:  CLRF   FF7
04C14:  RLCF   FF7,F
04C16:  ADDLW  2F
04C18:  MOVWF  FF6
04C1A:  MOVLW  4C
04C1C:  ADDWFC FF7,F
04C1E:  TBLRD*-
04C20:  MOVF   FF5,W
04C22:  MOVWF  FFA
04C24:  TBLRD*
04C26:  MOVF   FF5,W
04C28:  BTFSC  0D.7
04C2A:  BSF    FF2.7
04C2C:  MOVWF  FF9
04C2E:  DATA 14,4B
04C30:  DATA 50,4B
04C32:  DATA 8C,4B
04C34:  DATA C8,4B
*
05170:  MOVLB  5
05172:  MOVF   x7E,W
05174:  ANDLW  07
05176:  MOVWF  00
05178:  RRCF   x7E,W
0517A:  MOVWF  01
0517C:  RRCF   01,F
0517E:  RRCF   01,F
05180:  MOVLW  1F
05182:  ANDWF  01,F
05184:  MOVF   01,W
05186:  ADDWF  x80,W
05188:  MOVWF  FE9
0518A:  MOVLW  00
0518C:  ADDWFC x81,W
0518E:  MOVWF  FEA
05190:  CLRF   01
05192:  INCF   01,F
05194:  INCF   00,F
05196:  BRA    519A
05198:  RLCF   01,F
0519A:  DECFSZ 00,F
0519C:  BRA    5198
0519E:  MOVF   x7F,F
051A0:  BZ    51A8
051A2:  MOVF   01,W
051A4:  IORWF  FEF,F
051A6:  BRA    51AE
051A8:  COMF   01,F
051AA:  MOVF   01,W
051AC:  ANDWF  FEF,F
051AE:  MOVLB  0
051B0:  RETURN 0
051B2:  MOVLB  5
051B4:  MOVF   x7E,W
051B6:  ANDLW  07
051B8:  MOVWF  00
051BA:  RRCF   x7E,W
051BC:  MOVWF  01
051BE:  RRCF   01,F
051C0:  RRCF   01,F
051C2:  MOVLW  1F
051C4:  ANDWF  01,F
051C6:  MOVF   01,W
051C8:  ADDWF  x7F,W
051CA:  MOVWF  FE9
051CC:  MOVLW  00
051CE:  ADDWFC x80,W
051D0:  MOVWF  FEA
051D2:  MOVFF  FEF,01
051D6:  INCF   00,F
051D8:  BRA    51DC
051DA:  RRCF   01,F
051DC:  DECFSZ 00,F
051DE:  BRA    51DA
051E0:  MOVLB  0
051E2:  RETURN 0
*
06206:  MOVFF  FF2,0D
0620A:  BCF    FF2.7
0620C:  ADDWF  FE8,W
0620E:  CLRF   FF7
06210:  RLCF   FF7,F
06212:  ADDLW  2B
06214:  MOVWF  FF6
06216:  MOVLW  62
06218:  ADDWFC FF7,F
0621A:  TBLRD*-
0621C:  MOVF   FF5,W
0621E:  MOVWF  FFA
06220:  TBLRD*
06222:  MOVF   FF5,W
06224:  BTFSC  0D.7
06226:  BSF    FF2.7
06228:  MOVWF  FF9
0622A:  DATA C8,5C
0622C:  DATA F6,5D
0622E:  DATA 00,62
06230:  DATA 4C,5F
06232:  DATA 56,60
06234:  DATA 74,61
*
062FC:  TBLRD*+
062FE:  MOVFF  FF6,57E
06302:  MOVFF  FF7,57F
06306:  MOVFF  FF5,586
0630A:  CALL   2D32
0630E:  MOVFF  57E,FF6
06312:  MOVFF  57F,FF7
06316:  MOVLB  5
06318:  DECFSZ x7D,F
0631A:  BRA    631E
0631C:  BRA    6322
0631E:  MOVLB  0
06320:  BRA    62FC
06322:  MOVLB  0
06324:  RETURN 0
06326:  MOVLB  5
06328:  MOVF   x80,W
0632A:  CLRF   01
0632C:  SUBWF  x7F,W
0632E:  BC    6336
06330:  MOVFF  57F,00
06334:  BRA    634E
06336:  CLRF   00
06338:  MOVLW  08
0633A:  MOVWF  x81
0633C:  RLCF   x7F,F
0633E:  RLCF   00,F
06340:  MOVF   x80,W
06342:  SUBWF  00,W
06344:  BTFSC  FD8.0
06346:  MOVWF  00
06348:  RLCF   01,F
0634A:  DECFSZ x81,F
0634C:  BRA    633C
0634E:  MOVLB  0
06350:  RETURN 0
06352:  MOVF   01,W
06354:  MOVFF  57D,57F
06358:  MOVLW  64
0635A:  MOVLB  5
0635C:  MOVWF  x80
0635E:  MOVLB  0
06360:  RCALL  6326
06362:  MOVFF  00,57D
06366:  MOVF   01,W
06368:  MOVLW  30
0636A:  BNZ   637C
0636C:  MOVLB  5
0636E:  BTFSS  x7E.1
06370:  BRA    6392
06372:  BTFSC  x7E.3
06374:  BRA    6392
06376:  BTFSC  x7E.4
06378:  MOVLW  20
0637A:  BRA    6384
0637C:  MOVLB  5
0637E:  BCF    x7E.3
06380:  BCF    x7E.4
06382:  BSF    x7E.0
06384:  ADDWF  01,F
06386:  MOVFF  01,586
0638A:  MOVLB  0
0638C:  CALL   2D32
06390:  MOVLB  5
06392:  MOVFF  57D,57F
06396:  MOVLW  0A
06398:  MOVWF  x80
0639A:  MOVLB  0
0639C:  RCALL  6326
0639E:  MOVFF  00,57D
063A2:  MOVF   01,W
063A4:  MOVLW  30
063A6:  BNZ   63B8
063A8:  MOVLB  5
063AA:  BTFSC  x7E.3
063AC:  BRA    63C4
063AE:  BTFSS  x7E.0
063B0:  BRA    63C4
063B2:  BTFSC  x7E.4
063B4:  MOVLW  20
063B6:  MOVLB  0
063B8:  ADDWF  01,F
063BA:  MOVFF  01,586
063BE:  CALL   2D32
063C2:  MOVLB  5
063C4:  MOVLW  30
063C6:  ADDWF  x7D,F
063C8:  MOVFF  57D,586
063CC:  MOVLB  0
063CE:  CALL   2D32
063D2:  RETURN 0
*
06438:  BTFSC  FD8.1
0643A:  BRA    6444
0643C:  MOVLW  05
0643E:  MOVWF  FEA
06440:  MOVLW  81
06442:  MOVWF  FE9
06444:  CLRF   00
06446:  CLRF   01
06448:  CLRF   02
0644A:  CLRF   03
0644C:  MOVLB  5
0644E:  CLRF   x81
06450:  CLRF   x82
06452:  CLRF   x83
06454:  CLRF   x84
06456:  MOVF   x80,W
06458:  IORWF  x7F,W
0645A:  IORWF  x7E,W
0645C:  IORWF  x7D,W
0645E:  BZ    64B8
06460:  MOVLW  20
06462:  MOVWF  x85
06464:  BCF    FD8.0
06466:  RLCF   x79,F
06468:  RLCF   x7A,F
0646A:  RLCF   x7B,F
0646C:  RLCF   x7C,F
0646E:  RLCF   x81,F
06470:  RLCF   x82,F
06472:  RLCF   x83,F
06474:  RLCF   x84,F
06476:  MOVF   x80,W
06478:  SUBWF  x84,W
0647A:  BNZ   648C
0647C:  MOVF   x7F,W
0647E:  SUBWF  x83,W
06480:  BNZ   648C
06482:  MOVF   x7E,W
06484:  SUBWF  x82,W
06486:  BNZ   648C
06488:  MOVF   x7D,W
0648A:  SUBWF  x81,W
0648C:  BNC   64AC
0648E:  MOVF   x7D,W
06490:  SUBWF  x81,F
06492:  MOVF   x7E,W
06494:  BTFSS  FD8.0
06496:  INCFSZ x7E,W
06498:  SUBWF  x82,F
0649A:  MOVF   x7F,W
0649C:  BTFSS  FD8.0
0649E:  INCFSZ x7F,W
064A0:  SUBWF  x83,F
064A2:  MOVF   x80,W
064A4:  BTFSS  FD8.0
064A6:  INCFSZ x80,W
064A8:  SUBWF  x84,F
064AA:  BSF    FD8.0
064AC:  RLCF   00,F
064AE:  RLCF   01,F
064B0:  RLCF   02,F
064B2:  RLCF   03,F
064B4:  DECFSZ x85,F
064B6:  BRA    6464
064B8:  MOVFF  581,FEF
064BC:  MOVFF  582,FEC
064C0:  MOVFF  583,FEC
064C4:  MOVFF  584,FEC
064C8:  MOVLB  0
064CA:  GOTO   D81A (RETURN)
*
067A6:  MOVLB  5
067A8:  MOVF   x81,W
067AA:  MULWF  x83
067AC:  MOVFF  FF3,01
067B0:  MOVFF  FF4,00
067B4:  MULWF  x84
067B6:  MOVF   FF3,W
067B8:  ADDWF  00,F
067BA:  MOVF   x82,W
067BC:  MULWF  x83
067BE:  MOVF   FF3,W
067C0:  ADDWFC 00,W
067C2:  MOVWF  02
067C4:  MOVLB  0
067C6:  RETURN 0
*
07028:  MOVFF  FEA,585
0702C:  MOVFF  FE9,584
07030:  MOVLB  5
07032:  SWAPF  x7E,W
07034:  IORLW  F0
07036:  MOVWF  x80
07038:  ADDWF  x80,F
0703A:  ADDLW  E2
0703C:  MOVWF  x81
0703E:  ADDLW  32
07040:  MOVWF  x83
07042:  MOVF   x7E,W
07044:  ANDLW  0F
07046:  ADDWF  x81,F
07048:  ADDWF  x81,F
0704A:  ADDWF  x83,F
0704C:  ADDLW  E9
0704E:  MOVWF  x82
07050:  ADDWF  x82,F
07052:  ADDWF  x82,F
07054:  SWAPF  x7D,W
07056:  ANDLW  0F
07058:  ADDWF  x82,F
0705A:  ADDWF  x83,F
0705C:  RLCF   x82,F
0705E:  RLCF   x83,F
07060:  COMF   x83,F
07062:  RLCF   x83,F
07064:  MOVF   x7D,W
07066:  ANDLW  0F
07068:  ADDWF  x83,F
0706A:  RLCF   x80,F
0706C:  MOVLW  07
0706E:  MOVWF  x7F
07070:  MOVLW  0A
07072:  DECF   x82,F
07074:  ADDWF  x83,F
07076:  BNC   7072
07078:  DECF   x81,F
0707A:  ADDWF  x82,F
0707C:  BNC   7078
0707E:  DECF   x80,F
07080:  ADDWF  x81,F
07082:  BNC   707E
07084:  DECF   x7F,F
07086:  ADDWF  x80,F
07088:  BNC   7084
0708A:  MOVLW  05
0708C:  MOVWF  FEA
0708E:  MOVLW  7F
07090:  MOVWF  FE9
07092:  MOVLW  07
07094:  ANDWF  x84,W
07096:  BCF    x84.6
07098:  ADDWF  FE9,F
0709A:  MOVLW  83
0709C:  SUBWF  FE9,W
0709E:  BTFSC  FD8.2
070A0:  BSF    x84.6
070A2:  MOVF   FEF,W
070A4:  MOVWF  00
070A6:  BNZ   70B8
070A8:  BTFSC  x84.6
070AA:  BRA    70B8
070AC:  BTFSC  x84.4
070AE:  BRA    70DC
070B0:  BTFSC  x84.3
070B2:  BRA    70B8
070B4:  MOVLW  20
070B6:  BRA    70BE
070B8:  BSF    x84.3
070BA:  BCF    x84.4
070BC:  MOVLW  30
070BE:  ADDWF  00,F
070C0:  MOVFF  FEA,57E
070C4:  MOVFF  FE9,57D
070C8:  MOVFF  00,586
070CC:  MOVLB  0
070CE:  CALL   2D32
070D2:  MOVFF  57E,FEA
070D6:  MOVFF  57D,FE9
070DA:  MOVLB  5
070DC:  MOVF   FEE,W
070DE:  BTFSS  x84.6
070E0:  BRA    709A
070E2:  MOVLB  0
070E4:  RETURN 0
*
0724A:  MOVFF  FF2,0D
0724E:  BCF    FF2.7
07250:  ADDWF  FE8,W
07252:  CLRF   FF7
07254:  RLCF   FF7,F
07256:  ADDLW  6F
07258:  MOVWF  FF6
0725A:  MOVLW  72
0725C:  ADDWFC FF7,F
0725E:  TBLRD*-
07260:  MOVF   FF5,W
07262:  MOVWF  FFA
07264:  TBLRD*
07266:  MOVF   FF5,W
07268:  BTFSC  0D.7
0726A:  BSF    FF2.7
0726C:  MOVWF  FF9
0726E:  DATA 98,71
07270:  DATA B6,71
07272:  DATA 46,72
07274:  DATA 46,72
07276:  DATA D2,71
07278:  DATA DA,71
*
077EC:  MOVFF  FF2,0D
077F0:  BCF    FF2.7
077F2:  ADDWF  FE8,W
077F4:  CLRF   FF7
077F6:  RLCF   FF7,F
077F8:  ADDLW  11
077FA:  MOVWF  FF6
077FC:  MOVLW  78
077FE:  ADDWFC FF7,F
07800:  TBLRD*-
07802:  MOVF   FF5,W
07804:  MOVWF  FFA
07806:  TBLRD*
07808:  MOVF   FF5,W
0780A:  BTFSC  0D.7
0780C:  BSF    FF2.7
0780E:  MOVWF  FF9
07810:  DATA D0,75
07812:  DATA 14,76
07814:  DATA E8,77
07816:  DATA E8,77
07818:  DATA A0,77
0781A:  DATA 46,76
*
08C10:  MOVFF  FF2,0D
08C14:  BCF    FF2.7
08C16:  ADDWF  FE8,W
08C18:  CLRF   FF7
08C1A:  RLCF   FF7,F
08C1C:  ADDLW  35
08C1E:  MOVWF  FF6
08C20:  MOVLW  8C
08C22:  ADDWFC FF7,F
08C24:  TBLRD*-
08C26:  MOVF   FF5,W
08C28:  MOVWF  FFA
08C2A:  TBLRD*
08C2C:  MOVF   FF5,W
08C2E:  BTFSC  0D.7
08C30:  BSF    FF2.7
08C32:  MOVWF  FF9
08C34:  DATA B6,82
08C36:  DATA FC,82
08C38:  DATA 8E,84
08C3A:  DATA 20,86
*
09E84:  MOVFF  FF2,0D
09E88:  BCF    FF2.7
09E8A:  ADDWF  FE8,W
09E8C:  CLRF   FF7
09E8E:  RLCF   FF7,F
09E90:  ADDLW  A9
09E92:  MOVWF  FF6
09E94:  MOVLW  9E
09E96:  ADDWFC FF7,F
09E98:  TBLRD*-
09E9A:  MOVF   FF5,W
09E9C:  MOVWF  FFA
09E9E:  TBLRD*
09EA0:  MOVF   FF5,W
09EA2:  BTFSC  0D.7
09EA4:  BSF    FF2.7
09EA6:  MOVWF  FF9
09EA8:  DATA 02,99
09EAA:  DATA 26,98
09EAC:  DATA 94,98
09EAE:  DATA CA,99
09EB0:  DATA 80,9A
09EB2:  DATA AE,9A
09EB4:  DATA 80,9E
09EB6:  DATA 80,9E
09EB8:  DATA F8,98
09EBA:  DATA 80,9E
09EBC:  DATA 1C,9B
09EBE:  DATA 94,96
09EC0:  DATA 72,9C
09EC2:  DATA 8C,97
09EC4:  DATA 68,93
09EC6:  DATA 62,94
09EC8:  DATA FE,94
09ECA:  DATA 9A,95
09ECC:  DATA 58,9D
09ECE:  DATA 88,9D
*
0AEC4:  MOVFF  FF2,0D
0AEC8:  BCF    FF2.7
0AECA:  ADDWF  FE8,W
0AECC:  CLRF   FF7
0AECE:  RLCF   FF7,F
0AED0:  ADDLW  E9
0AED2:  MOVWF  FF6
0AED4:  MOVLW  AE
0AED6:  ADDWFC FF7,F
0AED8:  TBLRD*-
0AEDA:  MOVF   FF5,W
0AEDC:  MOVWF  FFA
0AEDE:  TBLRD*
0AEE0:  MOVF   FF5,W
0AEE2:  BTFSC  0D.7
0AEE4:  BSF    FF2.7
0AEE6:  MOVWF  FF9
0AEE8:  DATA 46,A9
0AEEA:  DATA E4,9E
0AEEC:  DATA 3C,A1
0AEEE:  DATA D4,A5
0AEF0:  DATA F2,9F
0AEF2:  DATA 4C,A3
0AEF4:  DATA E4,A6
0AEF6:  DATA 7C,AA
0AEF8:  DATA 2E,A8
0AEFA:  DATA C0,AE
0AEFC:  DATA 94,AB
0AEFE:  DATA C0,AE
0AF00:  DATA 62,AB
0AF02:  DATA C0,AE
0AF04:  DATA C0,AE
0AF06:  DATA C0,AE
0AF08:  DATA C0,AE
0AF0A:  DATA C0,AE
0AF0C:  DATA E6,AC
0AF0E:  DATA 16,AD
*
0BD60:  MOVFF  FF2,0D
0BD64:  BCF    FF2.7
0BD66:  ADDWF  FE8,W
0BD68:  CLRF   FF7
0BD6A:  RLCF   FF7,F
0BD6C:  ADDLW  85
0BD6E:  MOVWF  FF6
0BD70:  MOVLW  BD
0BD72:  ADDWFC FF7,F
0BD74:  TBLRD*-
0BD76:  MOVF   FF5,W
0BD78:  MOVWF  FFA
0BD7A:  TBLRD*
0BD7C:  MOVF   FF5,W
0BD7E:  BTFSC  0D.7
0BD80:  BSF    FF2.7
0BD82:  MOVWF  FF9
0BD84:  DATA 42,BC
0BD86:  DATA AA,BC
0BD88:  DATA 5C,BD
0BD8A:  DATA 5C,BD
0BD8C:  DATA 1E,BD
0BD8E:  DATA 2E,BD
0BD90:  DATA 12,BD
0BD92:  DATA 5C,BD
0BD94:  DATA 40,BD
*
0BF2A:  MOVFF  FF2,0D
0BF2E:  BCF    FF2.7
0BF30:  ADDWF  FE8,W
0BF32:  CLRF   FF7
0BF34:  RLCF   FF7,F
0BF36:  ADDLW  4F
0BF38:  MOVWF  FF6
0BF3A:  MOVLW  BF
0BF3C:  ADDWFC FF7,F
0BF3E:  TBLRD*-
0BF40:  MOVF   FF5,W
0BF42:  MOVWF  FFA
0BF44:  TBLRD*
0BF46:  MOVF   FF5,W
0BF48:  BTFSC  0D.7
0BF4A:  BSF    FF2.7
0BF4C:  MOVWF  FF9
0BF4E:  DATA 04,BE
0BF50:  DATA 68,BE
0BF52:  DATA 26,BF
0BF54:  DATA 26,BF
0BF56:  DATA EA,BE
0BF58:  DATA FA,BE
0BF5A:  DATA D0,BE
0BF5C:  DATA DC,BE
0BF5E:  DATA 0A,BF
*
0C1D2:  MOVFF  FF2,0D
0C1D6:  BCF    FF2.7
0C1D8:  ADDWF  FE8,W
0C1DA:  CLRF   FF7
0C1DC:  RLCF   FF7,F
0C1DE:  ADDLW  F7
0C1E0:  MOVWF  FF6
0C1E2:  MOVLW  C1
0C1E4:  ADDWFC FF7,F
0C1E6:  TBLRD*-
0C1E8:  MOVF   FF5,W
0C1EA:  MOVWF  FFA
0C1EC:  TBLRD*
0C1EE:  MOVF   FF5,W
0C1F0:  BTFSC  0D.7
0C1F2:  BSF    FF2.7
0C1F4:  MOVWF  FF9
0C1F6:  DATA 7E,C0
0C1F8:  DATA FC,C0
0C1FA:  DATA CE,C1
0C1FC:  DATA CE,C1
0C1FE:  DATA 92,C1
0C200:  DATA A2,C1
0C202:  DATA 7A,C1
0C204:  DATA 86,C1
0C206:  DATA B2,C1
*
0C608:  MOVFF  FF2,0D
0C60C:  BCF    FF2.7
0C60E:  ADDWF  FE8,W
0C610:  CLRF   FF7
0C612:  RLCF   FF7,F
0C614:  ADDLW  2D
0C616:  MOVWF  FF6
0C618:  MOVLW  C6
0C61A:  ADDWFC FF7,F
0C61C:  TBLRD*-
0C61E:  MOVF   FF5,W
0C620:  MOVWF  FFA
0C622:  TBLRD*
0C624:  MOVF   FF5,W
0C626:  BTFSC  0D.7
0C628:  BSF    FF2.7
0C62A:  MOVWF  FF9
0C62C:  DATA 52,C5
0C62E:  DATA 04,C6
0C630:  DATA B2,C5
0C632:  DATA 04,C6
0C634:  DATA 04,C6
0C636:  DATA BC,C5
0C638:  DATA 04,C6
0C63A:  DATA 04,C6
0C63C:  DATA DE,C4
0C63E:  DATA CE,C5
0C640:  DATA 04,C6
0C642:  DATA F2,C3
0C644:  DATA 04,C6
0C646:  DATA 5E,C4
0C648:  DATA 1A,C2
0C64A:  DATA 9A,C2
0C64C:  DATA 06,C3
0C64E:  DATA 72,C3
0C650:  DATA F6,C5
*
0D41A:  MOVFF  FF2,0D
0D41E:  BCF    FF2.7
0D420:  ADDWF  FE8,W
0D422:  CLRF   FF7
0D424:  RLCF   FF7,F
0D426:  ADDLW  3F
0D428:  MOVWF  FF6
0D42A:  MOVLW  D4
0D42C:  ADDWFC FF7,F
0D42E:  TBLRD*-
0D430:  MOVF   FF5,W
0D432:  MOVWF  FFA
0D434:  TBLRD*
0D436:  MOVF   FF5,W
0D438:  BTFSC  0D.7
0D43A:  BSF    FF2.7
0D43C:  MOVWF  FF9
0D43E:  DATA E0,CE
0D440:  DATA FC,CE
0D442:  DATA 5C,CF
0D444:  DATA 8E,CF
0D446:  DATA 4E,D0
0D448:  DATA 0A,D1
0D44A:  DATA 6A,D1
0D44C:  DATA D0,D1
0D44E:  DATA 2A,D2
0D450:  DATA 86,D2
0D452:  DATA E2,D2
0D454:  DATA 38,D3
0D456:  DATA 3E,D3
0D458:  DATA 44,D3
0D45A:  DATA 4A,D3
*
0D906:  MOVFF  FF2,0D
0D90A:  BCF    FF2.7
0D90C:  ADDWF  FE8,W
0D90E:  CLRF   FF7
0D910:  RLCF   FF7,F
0D912:  ADDLW  2B
0D914:  MOVWF  FF6
0D916:  MOVLW  D9
0D918:  ADDWFC FF7,F
0D91A:  TBLRD*-
0D91C:  MOVF   FF5,W
0D91E:  MOVWF  FFA
0D920:  TBLRD*
0D922:  MOVF   FF5,W
0D924:  BTFSC  0D.7
0D926:  BSF    FF2.7
0D928:  MOVWF  FF9
0D92A:  DATA 4E,D8
0D92C:  DATA 56,D8
0D92E:  DATA 76,D8
0D930:  DATA B6,D8
0D932:  DATA BE,D8
0D934:  DATA C6,D8
0D936:  DATA CE,D8
0D938:  DATA 5E,D8
0D93A:  DATA D6,D8
0D93C:  DATA DE,D8
0D93E:  DATA E6,D8
0D940:  DATA EE,D8
0D942:  DATA F6,D8
0D944:  DATA 6E,D8
0D946:  DATA 9E,D8
0D948:  DATA 86,D8
0D94A:  DATA 8E,D8
0D94C:  DATA 7E,D8
0D94E:  DATA 96,D8
0D950:  DATA A6,D8
0D952:  DATA AE,D8
0D954:  DATA 66,D8
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "main.h" 
.................... #fuses HS,NOWDT,PROTECT,NOLVP,NODEBUG,MCLR 
.................... #use delay(clock=20000000) 
*
02958:  MOVLW  05
0295A:  MOVWF  FEA
0295C:  MOVLW  92
0295E:  MOVWF  FE9
02960:  MOVF   FEF,W
02962:  BZ    297E
02964:  MOVLW  06
02966:  MOVWF  01
02968:  CLRF   00
0296A:  DECFSZ 00,F
0296C:  BRA    296A
0296E:  DECFSZ 01,F
02970:  BRA    2968
02972:  MOVLW  7B
02974:  MOVWF  00
02976:  DECFSZ 00,F
02978:  BRA    2976
0297A:  DECFSZ FEF,F
0297C:  BRA    2964
0297E:  RETURN 0
.................... #use i2c(master,sda = pin_C4,scl = pin_C3,force_hw) 
*
02906:  BCF    FC6.7
02908:  BCF    F9E.3
0290A:  MOVFF  598,FC9
0290E:  MOVLW  02
02910:  BTFSC  FC6.7
02912:  BRA    291E
02914:  BTFSS  F9E.3
02916:  BRA    2914
02918:  MOVLW  00
0291A:  BTFSC  FC5.6
0291C:  MOVLW  01
0291E:  MOVWF  01
02920:  RETURN 0
*
02C04:  BCF    FC6.6
02C06:  BSF    FC5.3
02C08:  BTFSC  FC5.3
02C0A:  BRA    2C08
02C0C:  BTFSC  00.0
02C0E:  BCF    FC5.5
02C10:  BTFSS  00.0
02C12:  BSF    FC5.5
02C14:  BSF    FC5.4
02C16:  BTFSC  FC5.4
02C18:  BRA    2C16
02C1A:  MOVFF  FC9,01
02C1E:  RETURN 0
.................... #use 		standard_io(a) 
.................... #use 		standard_io(b) 
.................... #use 		standard_io(c) 
.................... #use 		standard_io(d) 
.................... #use 		standard_io(e) 
.................... #DEFINE   	RS    pin_B5			 
.................... #DEFINE	  	E	  pin_A0 
.................... #DEFINE		EEPROM_SCL	    	pin_C3 
.................... #DEFINE 	EEPROM_SDA		    pin_C4 
.................... #DEFINE     in24_bit			pin_B0 
.................... #DEFINE     in25_bit			pin_B1 
.................... #DEFINE     in26_bit			pin_B3 
.................... #DEFINE     in27_bit			pin_B4 
.................... #DEFINE     H0					pin_D7 
.................... #DEFINE     H1					pin_D6 
.................... #DEFINE     H2					pin_D5 
.................... #DEFINE     H3					pin_D4 
.................... #DEFINE     H4					pin_C7	 
.................... #DEFINE     H5					pin_C6 
.................... #DEFINE     ALIMENTADOR         0 // 000          
.................... #DEFINE     HOME1               1 // 001 
.................... #DEFINE     SOLDAGEM            3 // 010 
.................... #DEFINE     HOME2               4 // 011 
.................... #DEFINE     DISPENSADOR         5 // 100 
....................  
....................  
.................... #define ramp_idle 0 
.................... #define ramp_up   1 
.................... #define ramp_max  2 
.................... #define ramp_down 3 
.................... #define ramp_last 4 
....................  
.................... int menu_atual = 0; 
.................... short int entradas[27]; 
....................  
.................... int ponteiro_lcd = 1; 
.................... int inicial_lcd = 0; 
.................... int final_lcd = 3; 
.................... int contador_lcd = 0; 
.................... signed int incremento = 1; 
....................  
.................... int posicao_atual; 
.................... int posicao_futura; 
.................... int posicao_outra_maquina; 
.................... int32 ciclo; 
.................... short run_ok = 1; 
.................... short exit = TRUE; 
.................... short flgMove = TRUE; 
.................... short run_flg_flip = FALSE; 
.................... int primeiraVez = 1; 
....................  
.................... int modelo = 1; 
.................... long int x[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int y[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int z[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int t_solda[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int t_wait[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int tipo[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int pontos_no_modelo = 0; 
.................... long int habilitado[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int numeroFerros[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int t_solda2[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int t_solda3[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int limpar[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
....................  
.................... #include "pcf8574.c" 
.................... short int ack; 
.................... int	lcdcoluna = 1; 
.................... int	lcdlinha  = 1; 
....................  
.................... void escreve_pcf8574(int dispositivo,int data) { 
....................    i2c_start(); 
*
02922:  BSF    FC5.0
02924:  BTFSC  FC5.0
02926:  BRA    2924
....................    ack=i2c_write(0x40 |(dispositivo << 1)); 
02928:  BCF    FD8.0
0292A:  MOVLB  5
0292C:  RLCF   x8C,W
0292E:  IORLW  40
02930:  MOVWF  x8E
02932:  MOVWF  x98
02934:  MOVLB  0
02936:  RCALL  2906
02938:  MOVF   01,W
0293A:  BCF    2D.4
0293C:  BTFSC  01.0
0293E:  BSF    2D.4
....................    ack=i2c_write(data); 
02940:  MOVFF  58D,598
02944:  RCALL  2906
02946:  MOVF   01,W
02948:  BCF    2D.4
0294A:  BTFSC  01.0
0294C:  BSF    2D.4
....................    i2c_stop(); 
0294E:  BSF    FC5.2
02950:  BTFSC  FC5.2
02952:  BRA    2950
....................    ack=!ack; 
02954:  BTG    2D.4
02956:  RETURN 0
.................... } 
....................  
.................... int le_pcf8574(int dispositivo) { 
....................     int data; 
....................     i2c_start(); 
....................     i2c_write(0x41 |(dispositivo << 1)); 
....................     data=i2c_read(0); 
....................     i2c_stop(); 
....................     ack=!ack; 
....................     return(data); 
.................... } 
....................  
.................... int le_pcf8574A(int dispositivo) { 
....................     int data; 
....................     i2c_start(); 
*
049C4:  BSF    FC5.0
049C6:  BTFSC  FC5.0
049C8:  BRA    49C6
....................     i2c_write(0x71 |(dispositivo << 1)); 
049CA:  BCF    FD8.0
049CC:  MOVLB  5
049CE:  RLCF   x7F,W
049D0:  IORLW  71
049D2:  MOVWF  x81
049D4:  MOVWF  x98
049D6:  MOVLB  0
049D8:  CALL   2906
....................     data=i2c_read(0); 
049DC:  CLRF   00
049DE:  CALL   2C04
049E2:  MOVFF  01,580
....................     i2c_stop(); 
049E6:  BSF    FC5.2
049E8:  BTFSC  FC5.2
049EA:  BRA    49E8
....................     ack=!ack; 
049EC:  BTG    2D.4
.................... 	return(data); 
049EE:  MOVLB  5
049F0:  MOVFF  580,01
049F4:  MOVLB  0
049F6:  GOTO   4A90 (RETURN)
.................... } 
....................  
....................  
.................... #include "pca9555.c" 
.................... void escreve_PCA9555(int dispositivo,int comando,int data1,int data2) { 
....................    i2c_start(); 
*
02A30:  BSF    FC5.0
02A32:  BTFSC  FC5.0
02A34:  BRA    2A32
....................    ack=i2c_write(0x40 |(dispositivo << 1)); 
02A36:  BCF    FD8.0
02A38:  MOVLB  5
02A3A:  RLCF   x93,W
02A3C:  IORLW  40
02A3E:  MOVWF  x97
02A40:  MOVWF  x98
02A42:  MOVLB  0
02A44:  RCALL  2906
02A46:  MOVF   01,W
02A48:  BCF    2D.4
02A4A:  BTFSC  01.0
02A4C:  BSF    2D.4
....................    ack=i2c_write(comando); 
02A4E:  MOVFF  594,598
02A52:  RCALL  2906
02A54:  MOVF   01,W
02A56:  BCF    2D.4
02A58:  BTFSC  01.0
02A5A:  BSF    2D.4
....................    ack=i2c_write(data2); 
02A5C:  MOVFF  596,598
02A60:  RCALL  2906
02A62:  MOVF   01,W
02A64:  BCF    2D.4
02A66:  BTFSC  01.0
02A68:  BSF    2D.4
....................    ack=i2c_write(data1); 
02A6A:  MOVFF  595,598
02A6E:  RCALL  2906
02A70:  MOVF   01,W
02A72:  BCF    2D.4
02A74:  BTFSC  01.0
02A76:  BSF    2D.4
....................    i2c_stop(); 
02A78:  BSF    FC5.2
02A7A:  BTFSC  FC5.2
02A7C:  BRA    2A7A
....................    ack=!ack; 
02A7E:  BTG    2D.4
02A80:  RETURN 0
.................... }   
....................  
.................... unsigned long  int le_PCA9555(int dispositivo,int comando) {     
*
0493C:  MOVLB  5
0493E:  CLRF   x89
04940:  CLRF   x88
04942:  CLRF   x8A
....................    unsigned long int data1 = 0x0000;  
....................    int data2= 0x00; 
....................    i2c_start(); 	 
04944:  BSF    FC5.0
04946:  BTFSC  FC5.0
04948:  BRA    4946
....................    ack=i2c_write(0x40 |(dispositivo << 1));  
0494A:  BCF    FD8.0
0494C:  RLCF   x86,W
0494E:  IORLW  40
04950:  MOVWF  x8B
04952:  MOVWF  x98
04954:  MOVLB  0
04956:  CALL   2906
0495A:  MOVF   01,W
0495C:  BCF    2D.4
0495E:  BTFSC  01.0
04960:  BSF    2D.4
....................    ack=i2c_write(comando); 
04962:  MOVFF  587,598
04966:  CALL   2906
0496A:  MOVF   01,W
0496C:  BCF    2D.4
0496E:  BTFSC  01.0
04970:  BSF    2D.4
....................    i2c_start(); 
04972:  BSF    FC5.1
04974:  BTFSC  FC5.1
04976:  BRA    4974
....................    ack=i2c_write(0x41 |(dispositivo << 1)); 
04978:  BCF    FD8.0
0497A:  MOVLB  5
0497C:  RLCF   x86,W
0497E:  IORLW  41
04980:  MOVWF  x8B
04982:  MOVWF  x98
04984:  MOVLB  0
04986:  CALL   2906
0498A:  MOVF   01,W
0498C:  BCF    2D.4
0498E:  BTFSC  01.0
04990:  BSF    2D.4
....................    data2=i2c_read(1);            // acknoledgment 
04992:  MOVLW  01
04994:  MOVWF  00
04996:  CALL   2C04
0499A:  MOVFF  01,58A
....................    data1=i2c_read(0) << 8;      // no  acknoledgment 
0499E:  CLRF   00
049A0:  CALL   2C04
049A4:  MOVFF  01,589
049A8:  MOVLB  5
049AA:  CLRF   x88
....................    i2c_stop(); 
049AC:  BSF    FC5.2
049AE:  BTFSC  FC5.2
049B0:  BRA    49AE
....................    ack=!ack; 
049B2:  BTG    2D.4
....................    data1|=data2; 
049B4:  MOVF   x8A,W
049B6:  IORWF  x88,F
....................    return(data1); 
049B8:  MOVFF  588,01
049BC:  MOVFF  589,02
049C0:  MOVLB  0
049C2:  RETURN 0
.................... }     
....................  
.................... #include "display_maq.c"  
.................... void write (char dado){ 
.................... 	delay_us(30); 
*
02980:  MOVLW  31
02982:  MOVWF  00
02984:  DECFSZ 00,F
02986:  BRA    2984
02988:  BRA    298A
.................... 	escreve_pcf8574(0x00,dado); 
0298A:  MOVLB  5
0298C:  CLRF   x8C
0298E:  MOVFF  58B,58D
02992:  MOVLB  0
02994:  RCALL  2922
.................... 	delay_us(30); 
02996:  MOVLW  31
02998:  MOVWF  00
0299A:  DECFSZ 00,F
0299C:  BRA    299A
0299E:  BRA    29A0
.................... 	output_high (E); 
029A0:  BCF    F92.0
029A2:  BSF    F89.0
.................... 	delay_us(30); 
029A4:  MOVLW  31
029A6:  MOVWF  00
029A8:  DECFSZ 00,F
029AA:  BRA    29A8
029AC:  BRA    29AE
.................... 	output_low  (E) ; 
029AE:  BCF    F92.0
029B0:  BCF    F89.0
.................... 	delay_us(30); 
029B2:  MOVLW  31
029B4:  MOVWF  00
029B6:  DECFSZ 00,F
029B8:  BRA    29B6
029BA:  BRA    29BC
029BC:  RETURN 0
.................... } 
.................... void displayprog (int valor) { 
.................... 	output_low (RS); 
029BE:  BCF    F93.5
029C0:  BCF    F8A.5
.................... 	write (valor); 
029C2:  MOVFF  58A,58B
029C6:  RCALL  2980
029C8:  RETURN 0
.................... } 
.................... void limpa_display (void){ 
....................  	displayprog (0x1); 
*
02B6E:  MOVLW  01
02B70:  MOVLB  5
02B72:  MOVWF  x8A
02B74:  MOVLB  0
02B76:  RCALL  29BE
.................... 	delay_ms(5); 
02B78:  MOVLW  05
02B7A:  MOVLB  5
02B7C:  MOVWF  x92
02B7E:  MOVLB  0
02B80:  RCALL  2958
02B82:  RETURN 0
.................... } 
.................... void inicializa_display(void){ 
....................     escreve_pcf8574(0x00,0Xff); //;output_b(0xff);				//	porta_display (0XFF); 
*
029CA:  MOVLB  5
029CC:  CLRF   x8C
029CE:  SETF   x8D
029D0:  MOVLB  0
029D2:  RCALL  2922
.................... 	output_low(E); 
029D4:  BCF    F92.0
029D6:  BCF    F89.0
.................... 	output_high(RS); 
029D8:  BCF    F93.5
029DA:  BSF    F8A.5
.................... 	delay_ms(15); 
029DC:  MOVLW  0F
029DE:  MOVLB  5
029E0:  MOVWF  x92
029E2:  MOVLB  0
029E4:  RCALL  2958
.................... 	displayprog(0x38);      // 2 linha / 5x7 /8 bit 
029E6:  MOVLW  38
029E8:  MOVLB  5
029EA:  MOVWF  x8A
029EC:  MOVLB  0
029EE:  RCALL  29BE
.................... 	delay_ms(15); 
029F0:  MOVLW  0F
029F2:  MOVLB  5
029F4:  MOVWF  x92
029F6:  MOVLB  0
029F8:  RCALL  2958
.................... 	displayprog(0x0c);		// display aceso s/ cursor 
029FA:  MOVLW  0C
029FC:  MOVLB  5
029FE:  MOVWF  x8A
02A00:  MOVLB  0
02A02:  RCALL  29BE
.................... 	delay_ms(15); 
02A04:  MOVLW  0F
02A06:  MOVLB  5
02A08:  MOVWF  x92
02A0A:  MOVLB  0
02A0C:  RCALL  2958
.................... 	displayprog(0x06);      // escreve deslocando o cursor para direita 
02A0E:  MOVLW  06
02A10:  MOVLB  5
02A12:  MOVWF  x8A
02A14:  MOVLB  0
02A16:  RCALL  29BE
.................... 	delay_ms(15); 
02A18:  MOVLW  0F
02A1A:  MOVLB  5
02A1C:  MOVWF  x92
02A1E:  MOVLB  0
02A20:  RCALL  2958
.................... 	lcdcoluna = 1; 
02A22:  MOVLW  01
02A24:  MOVLB  2
02A26:  MOVWF  x00
.................... 	lcdlinha = 1; 
02A28:  MOVWF  x01
02A2A:  MOVLB  0
02A2C:  GOTO   D7B2 (RETURN)
.................... } 
.................... void posiciona_cursor (int linha,int coluna){ 
.................... 	lcdcoluna = coluna; 
*
02B84:  MOVFF  588,200
.................... 	lcdlinha  = linha; 
02B88:  MOVFF  587,201
.................... 	int	x; 
.................... 	if (linha == 1)	x=(0x00 + coluna) - 1; 
02B8C:  MOVLB  5
02B8E:  DECFSZ x87,W
02B90:  BRA    2B98
02B92:  MOVLW  01
02B94:  SUBWF  x88,W
02B96:  MOVWF  x89
.................... 	if (linha == 2) x=(0x40 + coluna) - 1;  
02B98:  MOVF   x87,W
02B9A:  SUBLW  02
02B9C:  BNZ   2BA6
02B9E:  MOVLW  40
02BA0:  ADDWF  x88,W
02BA2:  ADDLW  FF
02BA4:  MOVWF  x89
....................     if (linha == 3) x=(0x14 + coluna) - 1; 
02BA6:  MOVF   x87,W
02BA8:  SUBLW  03
02BAA:  BNZ   2BB4
02BAC:  MOVLW  14
02BAE:  ADDWF  x88,W
02BB0:  ADDLW  FF
02BB2:  MOVWF  x89
.................... 	if (linha == 4) x=(0x54 + coluna) - 1; 
02BB4:  MOVF   x87,W
02BB6:  SUBLW  04
02BB8:  BNZ   2BC2
02BBA:  MOVLW  54
02BBC:  ADDWF  x88,W
02BBE:  ADDLW  FF
02BC0:  MOVWF  x89
.................... 	x =x | 0x80; 
02BC2:  BSF    x89.7
.................... 	displayprog (x); 
02BC4:  MOVFF  589,58A
02BC8:  MOVLB  0
02BCA:  RCALL  29BE
.................... 	delay_us(100); 
02BCC:  MOVLW  A6
02BCE:  MOVWF  00
02BD0:  DECFSZ 00,F
02BD2:  BRA    2BD0
02BD4:  NOP   
02BD6:  RETURN 0
.................... } 
.................... void display (char c){ 
.................... 	output_high (RS); 
02BD8:  BCF    F93.5
02BDA:  BSF    F8A.5
.................... 	write (c); 
02BDC:  MOVFF  587,58B
02BE0:  RCALL  2980
02BE2:  RETURN 0
.................... } 
.................... void lcd_putc(char c) { 
.................... 	// \n nova linha muda o cursor para uma linha abaixo 
....................     // \r retorno 
....................     // \f limpa display 
....................  
....................  
....................    switch (c) { 
*
02D32:  MOVLB  5
02D34:  MOVF   x86,W
02D36:  XORLW  0C
02D38:  MOVLB  0
02D3A:  BZ    2D46
02D3C:  XORLW  06
02D3E:  BZ    2D52
02D40:  XORLW  07
02D42:  BZ    2D66
02D44:  BRA    2D7A
....................      case '\f'   : limpa_display(); 
02D46:  RCALL  2B6E
....................                    lcdlinha = 1; 
02D48:  MOVLW  01
02D4A:  MOVLB  2
02D4C:  MOVWF  x01
.................... 				   lcdcoluna= 1; 
02D4E:  MOVWF  x00
....................                    break; 
02D50:  BRA    2D82
....................  
....................      case '\n'   : posiciona_cursor(++lcdlinha,lcdcoluna);  
02D52:  MOVLB  2
02D54:  INCF   x01,F
02D56:  MOVFF  201,587
02D5A:  MOVFF  200,588
02D5E:  MOVLB  0
02D60:  RCALL  2B84
.................... 			       break; 
02D62:  MOVLB  2
02D64:  BRA    2D82
....................  
....................      case '\r'   : posiciona_cursor(lcdlinha,1);  
02D66:  MOVFF  201,587
02D6A:  MOVLW  01
02D6C:  MOVLB  5
02D6E:  MOVWF  x88
02D70:  MOVLB  0
02D72:  RCALL  2B84
....................                    break; 
02D74:  MOVLB  2
02D76:  BRA    2D82
02D78:  MOVLB  0
....................  
....................      default     : display(c);   
02D7A:  MOVFF  586,587
02D7E:  RCALL  2BD8
....................                    break; 
02D80:  MOVLB  2
....................    } 
02D82:  MOVLB  0
02D84:  RETURN 0
.................... } 
.................... void Show_String(char matriz[]) { 
.................... 	int result; 
.................... 	int	a; 
.................... 	char x1[21]; 
.................... 	strcpy (x1,matriz); 
.................... 	result = strlen(x1); 
.................... 	for (a=0;a < result;a++){ 
....................         display(x1[a]); 
....................     } 
.................... } 
....................  
.................... #include "24c64.c" 
.................... void write_ext_eeprom(long int address,long int data) { 
....................  
....................    disable_interrupts(GLOBAL); 
*
02B02:  BCF    FF2.6
02B04:  BCF    FF2.7
02B06:  BTFSC  FF2.7
02B08:  BRA    2B04
....................    i2c_start(); 
02B0A:  BSF    FC5.0
02B0C:  BTFSC  FC5.0
02B0E:  BRA    2B0C
....................    ack=i2c_write(0xa0); 
02B10:  MOVLW  A0
02B12:  MOVLB  5
02B14:  MOVWF  x98
02B16:  MOVLB  0
02B18:  RCALL  2906
02B1A:  MOVF   01,W
02B1C:  BCF    2D.4
02B1E:  BTFSC  01.0
02B20:  BSF    2D.4
....................    ack=i2c_write(address >> 8); 
02B22:  MOVFF  581,584
02B26:  MOVLB  5
02B28:  CLRF   x85
02B2A:  MOVFF  581,598
02B2E:  MOVLB  0
02B30:  RCALL  2906
02B32:  MOVF   01,W
02B34:  BCF    2D.4
02B36:  BTFSC  01.0
02B38:  BSF    2D.4
....................    ack=i2c_write(address); 
02B3A:  MOVFF  580,598
02B3E:  RCALL  2906
02B40:  MOVF   01,W
02B42:  BCF    2D.4
02B44:  BTFSC  01.0
02B46:  BSF    2D.4
....................    ack=i2c_write(data); 
02B48:  MOVFF  582,598
02B4C:  RCALL  2906
02B4E:  MOVF   01,W
02B50:  BCF    2D.4
02B52:  BTFSC  01.0
02B54:  BSF    2D.4
....................    i2c_stop(); 
02B56:  BSF    FC5.2
02B58:  BTFSC  FC5.2
02B5A:  BRA    2B58
....................    ack=!ack; 
02B5C:  BTG    2D.4
....................    delay_ms(5); 
02B5E:  MOVLW  05
02B60:  MOVLB  5
02B62:  MOVWF  x92
02B64:  MOVLB  0
02B66:  RCALL  2958
....................    enable_interrupts(GLOBAL); 
02B68:  MOVLW  C0
02B6A:  IORWF  FF2,F
02B6C:  RETURN 0
....................  
.................... } 
.................... long int read_ext_eeprom(long int address) { 
....................    long int data; 
....................  
....................    disable_interrupts(GLOBAL); 
*
02C20:  BCF    FF2.6
02C22:  BCF    FF2.7
02C24:  BTFSC  FF2.7
02C26:  BRA    2C22
....................    i2c_start(); 
02C28:  BSF    FC5.0
02C2A:  BTFSC  FC5.0
02C2C:  BRA    2C2A
....................    i2c_write(0xa0); 
02C2E:  MOVLW  A0
02C30:  MOVLB  5
02C32:  MOVWF  x98
02C34:  MOVLB  0
02C36:  RCALL  2906
....................    i2c_write(address >> 8); 
02C38:  MOVFF  586,589
02C3C:  MOVLB  5
02C3E:  CLRF   x8A
02C40:  MOVFF  586,598
02C44:  MOVLB  0
02C46:  RCALL  2906
....................    i2c_write(address); 
02C48:  MOVFF  585,598
02C4C:  RCALL  2906
....................    i2c_start(); 
02C4E:  BSF    FC5.1
02C50:  BTFSC  FC5.1
02C52:  BRA    2C50
....................    i2c_write(0xa1); 
02C54:  MOVLW  A1
02C56:  MOVLB  5
02C58:  MOVWF  x98
02C5A:  MOVLB  0
02C5C:  RCALL  2906
....................    data=i2c_read(0); 
02C5E:  CLRF   00
02C60:  RCALL  2C04
02C62:  MOVLB  5
02C64:  CLRF   x88
02C66:  MOVFF  01,587
....................    i2c_stop(); 
02C6A:  BSF    FC5.2
02C6C:  BTFSC  FC5.2
02C6E:  BRA    2C6C
....................    ack=!ack; 
02C70:  BTG    2D.4
....................    delay_ms(5); 
02C72:  MOVLW  05
02C74:  MOVWF  x92
02C76:  MOVLB  0
02C78:  RCALL  2958
....................    enable_interrupts(GLOBAL); 
02C7A:  MOVLW  C0
02C7C:  IORWF  FF2,F
....................  
....................    return(data); 
02C7E:  MOVLB  5
02C80:  MOVFF  587,01
02C84:  MOVFF  588,02
02C88:  MOVLB  0
02C8A:  RETURN 0
....................  
.................... } 
.................... void init_ext_eeprom() { 
.................... 	int a; 
....................  
....................     output_float(EEPROM_SCL); 
02C8C:  BSF    F94.3
....................     output_float(EEPROM_SDA); 
02C8E:  BSF    F94.4
....................  
.................... 	write_ext_eeprom(0x00ff,0xAA); 
02C90:  MOVLB  5
02C92:  CLRF   x81
02C94:  SETF   x80
02C96:  CLRF   x83
02C98:  MOVLW  AA
02C9A:  MOVWF  x82
02C9C:  MOVLB  0
02C9E:  RCALL  2B02
.................... 	if (ack == false) 
02CA0:  BTFSC  2D.4
02CA2:  BRA    2CD6
.................... 	{ 
.................... 	limpa_display(); 
02CA4:  RCALL  2B6E
.................... 	posiciona_cursor(1,1); 
02CA6:  MOVLW  01
02CA8:  MOVLB  5
02CAA:  MOVWF  x87
02CAC:  MOVWF  x88
02CAE:  MOVLB  0
02CB0:  RCALL  2B84
.................... 	display("erro de escrita "); 
02CB2:  MOVLW  BA
02CB4:  MOVWF  FF6
02CB6:  MOVLW  00
02CB8:  MOVWF  FF7
02CBA:  RCALL  2BE4
.................... 	posiciona_cursor(2,1); 
02CBC:  MOVLW  02
02CBE:  MOVLB  5
02CC0:  MOVWF  x87
02CC2:  MOVLW  01
02CC4:  MOVWF  x88
02CC6:  MOVLB  0
02CC8:  RCALL  2B84
.................... 	display("   EEPROM       "); 
02CCA:  MOVLW  CC
02CCC:  MOVWF  FF6
02CCE:  MOVLW  00
02CD0:  MOVWF  FF7
02CD2:  RCALL  2BE4
.................... 	while(true){} 
02CD4:  BRA    2CD4
.................... 	} 
.................... 	 
.................... 	delay_ms(5);	 
02CD6:  MOVLW  05
02CD8:  MOVLB  5
02CDA:  MOVWF  x92
02CDC:  MOVLB  0
02CDE:  RCALL  2958
....................  
.................... 	a = read_ext_eeprom(0x00ff); 
02CE0:  MOVLB  5
02CE2:  CLRF   x86
02CE4:  SETF   x85
02CE6:  MOVLB  0
02CE8:  RCALL  2C20
02CEA:  MOVFF  01,575
.................... 	if (a != 0xAA) 
02CEE:  MOVLB  5
02CF0:  MOVF   x75,W
02CF2:  SUBLW  AA
02CF4:  BZ    2D2C
.................... 	{ 
.................... 	limpa_display(); 
02CF6:  MOVLB  0
02CF8:  RCALL  2B6E
.................... 	posiciona_cursor(1,1); 
02CFA:  MOVLW  01
02CFC:  MOVLB  5
02CFE:  MOVWF  x87
02D00:  MOVWF  x88
02D02:  MOVLB  0
02D04:  RCALL  2B84
.................... 	display("erro de leitura  "); 
02D06:  MOVLW  DE
02D08:  MOVWF  FF6
02D0A:  MOVLW  00
02D0C:  MOVWF  FF7
02D0E:  RCALL  2BE4
.................... 	posiciona_cursor(2,1); 
02D10:  MOVLW  02
02D12:  MOVLB  5
02D14:  MOVWF  x87
02D16:  MOVLW  01
02D18:  MOVWF  x88
02D1A:  MOVLB  0
02D1C:  RCALL  2B84
.................... 	display("     EEPROM      "); 
02D1E:  MOVLW  F0
02D20:  MOVWF  FF6
02D22:  MOVLW  00
02D24:  MOVWF  FF7
02D26:  RCALL  2BE4
.................... 	while(true){} 
02D28:  BRA    2D28
02D2A:  MOVLB  5
.................... 	} 
02D2C:  MOVLB  0
02D2E:  GOTO   D7C6 (RETURN)
....................  
....................  
....................      
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
.................... #include "teclado_21_teclas.c" 
.................... #define		F1					10 
.................... #define		F2					11 
.................... #define     F3					12 
.................... #define		F4					13 
.................... #define     SETA_SUPERIOR   	14 
.................... #define     SETA_INFERIOR   	15  
.................... #define		SETA_DIREITA    	16  
.................... #define     SETA_ESQUERDA  	    17 
.................... #define     ESC					18 
.................... #define     ENTER				19	 
.................... #define     MENU				20 
....................  
.................... void Init_Keyboard(void){ 
.................... 	escreve_PCA9555(0X01,0X06,0Xff,0xf8);// programa bit 0,bit 1,bit 2  como saida e os demais como entrada 
*
02A82:  MOVLW  01
02A84:  MOVLB  5
02A86:  MOVWF  x93
02A88:  MOVLW  06
02A8A:  MOVWF  x94
02A8C:  SETF   x95
02A8E:  MOVLW  F8
02A90:  MOVWF  x96
02A92:  MOVLB  0
02A94:  RCALL  2A30
....................  	escreve_PCA9555(0X01,0X02,0X00,0X07);//coloca colunas em  high level 
02A96:  MOVLW  01
02A98:  MOVLB  5
02A9A:  MOVWF  x93
02A9C:  MOVLW  02
02A9E:  MOVWF  x94
02AA0:  CLRF   x95
02AA2:  MOVLW  07
02AA4:  MOVWF  x96
02AA6:  MOVLB  0
02AA8:  RCALL  2A30
02AAA:  GOTO   D7B6 (RETURN)
.................... } 
.................... unsigned long int  Get_Key(void){	 
*
064CE:  MOVLB  5
064D0:  CLRF   x81
064D2:  CLRF   x80
064D4:  MOVLW  06
064D6:  MOVWF  x82
064D8:  MOVLW  7F
064DA:  MOVWF  x83
.................... 	long int dado = 0x0000; 
.................... 	int    coluna = 0x06; 
....................     int    mascara = 0x7f; 
.................... 	long int i; 
.................... 	for (i = 0 ; i < 3 ; i++) { 
064DC:  CLRF   x85
064DE:  CLRF   x84
064E0:  MOVF   x85,F
064E2:  BNZ   6556
064E4:  MOVF   x84,W
064E6:  SUBLW  02
064E8:  BNC   6556
....................     	coluna -= i; 
064EA:  MOVF   x84,W
064EC:  SUBWF  x82,F
.................... 		escreve_PCA9555(0X01,0X02,0X00,coluna);     // coloca coluna  em  low level 
064EE:  MOVLW  01
064F0:  MOVWF  x93
064F2:  MOVLW  02
064F4:  MOVWF  x94
064F6:  CLRF   x95
064F8:  MOVFF  582,596
064FC:  MOVLB  0
064FE:  CALL   2A30
.................... 		dado =  le_PCA9555(0X01,0X00) >> 3;         // desloca bits 
06502:  MOVLW  01
06504:  MOVLB  5
06506:  MOVWF  x86
06508:  CLRF   x87
0650A:  MOVLB  0
0650C:  CALL   493C
06510:  MOVLB  5
06512:  RRCF   02,W
06514:  MOVWF  x81
06516:  RRCF   01,W
06518:  MOVWF  x80
0651A:  RRCF   x81,F
0651C:  RRCF   x80,F
0651E:  RRCF   x81,F
06520:  RRCF   x80,F
06522:  MOVLW  1F
06524:  ANDWF  x81,F
.................... 		dado &= mascara;  							// mascara bits 
06526:  MOVF   x83,W
06528:  ANDWF  x80,F
0652A:  CLRF   x81
....................         dado = 127 - dado;                            
0652C:  MOVLW  7F
0652E:  BSF    FD8.0
06530:  SUBFWB x80,F
06532:  MOVLW  00
06534:  SUBFWB x81,F
.................... 		if(dado != 0) { 
06536:  MOVF   x80,F
06538:  BNZ   653E
0653A:  MOVF   x81,F
0653C:  BZ    654E
....................             i = i << 8; 
0653E:  MOVFF  584,585
06542:  CLRF   x84
....................             dado |= i ; 
06544:  MOVF   x84,W
06546:  IORWF  x80,F
06548:  MOVF   x85,W
0654A:  IORWF  x81,F
....................             break; 
0654C:  BRA    6556
.................... 		}		 
0654E:  INCF   x84,F
06550:  BTFSC  FD8.2
06552:  INCF   x85,F
06554:  BRA    64E0
.................... 	}		 
....................     return(dado); 
06556:  MOVFF  580,01
0655A:  MOVFF  581,02
0655E:  MOVLB  0
06560:  GOTO   6570 (RETURN)
.................... } 
.................... int Teclado(void) { 
06564:  MOVLB  5
06566:  CLRF   x7E
06568:  CLRF   x7D
0656A:  CLRF   x7F
....................  // l o teclado 
....................  // se nenhuma tecla acionada retorna 0xff 
....................  // se acionada retorna o codigo da tecla 
....................    unsigned long int codigo_teclado = 0x0000; 
....................    int key_code = 0x00; 
....................    codigo_teclado = Get_Key(); 
0656C:  MOVLB  0
0656E:  BRA    64CE
06570:  MOVFF  02,57E
06574:  MOVFF  01,57D
....................    if(codigo_teclado == 0x00) return( key_code =0xff);	 
06578:  MOVLB  5
0657A:  MOVF   x7D,F
0657C:  BNZ   658A
0657E:  MOVF   x7E,F
06580:  BNZ   658A
06582:  SETF   x7F
06584:  MOVFF  57F,01
06588:  BRA    67A2
.................... 	switch(codigo_teclado){ 
0658A:  MOVF   x7D,W
0658C:  MOVWF  00
0658E:  MOVF   x7E,W
06590:  MOVWF  03
06592:  MOVLW  01
06594:  SUBWF  03,W
06596:  BNZ   65A4
06598:  MOVLW  40
0659A:  SUBWF  00,W
0659C:  MOVLB  0
0659E:  BTFSC  FD8.2
065A0:  BRA    66F8
065A2:  MOVLB  5
065A4:  MOVF   03,W
065A6:  BNZ   65B4
065A8:  MOVLW  08
065AA:  SUBWF  00,W
065AC:  MOVLB  0
065AE:  BTFSC  FD8.2
065B0:  BRA    66FE
065B2:  MOVLB  5
065B4:  MOVLW  01
065B6:  SUBWF  03,W
065B8:  BNZ   65C6
065BA:  MOVLW  08
065BC:  SUBWF  00,W
065BE:  MOVLB  0
065C0:  BTFSC  FD8.2
065C2:  BRA    6706
065C4:  MOVLB  5
065C6:  MOVLW  02
065C8:  SUBWF  03,W
065CA:  BNZ   65D8
065CC:  MOVLW  08
065CE:  SUBWF  00,W
065D0:  MOVLB  0
065D2:  BTFSC  FD8.2
065D4:  BRA    670E
065D6:  MOVLB  5
065D8:  MOVF   03,W
065DA:  BNZ   65E8
065DC:  MOVLW  10
065DE:  SUBWF  00,W
065E0:  MOVLB  0
065E2:  BTFSC  FD8.2
065E4:  BRA    6716
065E6:  MOVLB  5
065E8:  MOVLW  01
065EA:  SUBWF  03,W
065EC:  BNZ   65FA
065EE:  MOVLW  10
065F0:  SUBWF  00,W
065F2:  MOVLB  0
065F4:  BTFSC  FD8.2
065F6:  BRA    671E
065F8:  MOVLB  5
065FA:  MOVLW  02
065FC:  SUBWF  03,W
065FE:  BNZ   660C
06600:  MOVLW  10
06602:  SUBWF  00,W
06604:  MOVLB  0
06606:  BTFSC  FD8.2
06608:  BRA    6726
0660A:  MOVLB  5
0660C:  MOVF   03,W
0660E:  BNZ   661C
06610:  MOVLW  20
06612:  SUBWF  00,W
06614:  MOVLB  0
06616:  BTFSC  FD8.2
06618:  BRA    672E
0661A:  MOVLB  5
0661C:  MOVLW  01
0661E:  SUBWF  03,W
06620:  BNZ   662E
06622:  MOVLW  20
06624:  SUBWF  00,W
06626:  MOVLB  0
06628:  BTFSC  FD8.2
0662A:  BRA    6736
0662C:  MOVLB  5
0662E:  MOVLW  02
06630:  SUBWF  03,W
06632:  BNZ   6640
06634:  MOVLW  20
06636:  SUBWF  00,W
06638:  MOVLB  0
0663A:  BTFSC  FD8.2
0663C:  BRA    673E
0663E:  MOVLB  5
06640:  MOVF   03,W
06642:  BNZ   6650
06644:  MOVLW  01
06646:  SUBWF  00,W
06648:  MOVLB  0
0664A:  BTFSC  FD8.2
0664C:  BRA    6746
0664E:  MOVLB  5
06650:  MOVLW  02
06652:  SUBWF  03,W
06654:  BNZ   6662
06656:  MOVLW  01
06658:  SUBWF  00,W
0665A:  MOVLB  0
0665C:  BTFSC  FD8.2
0665E:  BRA    674E
06660:  MOVLB  5
06662:  MOVF   03,W
06664:  BNZ   6672
06666:  MOVLW  04
06668:  SUBWF  00,W
0666A:  MOVLB  0
0666C:  BTFSC  FD8.2
0666E:  BRA    6756
06670:  MOVLB  5
06672:  MOVLW  02
06674:  SUBWF  03,W
06676:  BNZ   6684
06678:  MOVLW  04
0667A:  SUBWF  00,W
0667C:  MOVLB  0
0667E:  BTFSC  FD8.2
06680:  BRA    675E
06682:  MOVLB  5
06684:  MOVF   03,W
06686:  BNZ   6694
06688:  MOVLW  40
0668A:  SUBWF  00,W
0668C:  MOVLB  0
0668E:  BTFSC  FD8.2
06690:  BRA    6766
06692:  MOVLB  5
06694:  MOVLW  02
06696:  SUBWF  03,W
06698:  BNZ   66A6
0669A:  MOVLW  40
0669C:  SUBWF  00,W
0669E:  MOVLB  0
066A0:  BTFSC  FD8.2
066A2:  BRA    676E
066A4:  MOVLB  5
066A6:  MOVLW  01
066A8:  SUBWF  03,W
066AA:  BNZ   66B8
066AC:  MOVLW  01
066AE:  SUBWF  00,W
066B0:  MOVLB  0
066B2:  BTFSC  FD8.2
066B4:  BRA    6776
066B6:  MOVLB  5
066B8:  MOVF   03,W
066BA:  BNZ   66C6
066BC:  MOVLW  02
066BE:  SUBWF  00,W
066C0:  MOVLB  0
066C2:  BZ    677E
066C4:  MOVLB  5
066C6:  MOVLW  02
066C8:  SUBWF  03,W
066CA:  BNZ   66D6
066CC:  MOVLW  02
066CE:  SUBWF  00,W
066D0:  MOVLB  0
066D2:  BZ    6786
066D4:  MOVLB  5
066D6:  MOVLW  01
066D8:  SUBWF  03,W
066DA:  BNZ   66E6
066DC:  MOVLW  04
066DE:  SUBWF  00,W
066E0:  MOVLB  0
066E2:  BZ    678E
066E4:  MOVLB  5
066E6:  MOVLW  01
066E8:  SUBWF  03,W
066EA:  BNZ   66F6
066EC:  MOVLW  02
066EE:  SUBWF  00,W
066F0:  MOVLB  0
066F2:  BZ    6796
066F4:  MOVLB  5
066F6:  BRA    679E
.................... 		case 320:key_code=0; 
066F8:  MOVLB  5
066FA:  CLRF   x7F
.................... 				break; 
066FC:  BRA    679E
.................... 		case 8:	key_code=1; 
066FE:  MOVLW  01
06700:  MOVLB  5
06702:  MOVWF  x7F
.................... 				break; 
06704:  BRA    679E
.................... 		case 264:key_code=2; 
06706:  MOVLW  02
06708:  MOVLB  5
0670A:  MOVWF  x7F
.................... 				break; 
0670C:  BRA    679E
.................... 		case 520:key_code=3; 
0670E:  MOVLW  03
06710:  MOVLB  5
06712:  MOVWF  x7F
.................... 				break;	 
06714:  BRA    679E
.................... 		case 16: key_code=4; 
06716:  MOVLW  04
06718:  MOVLB  5
0671A:  MOVWF  x7F
.................... 				break; 
0671C:  BRA    679E
.................... 		case 272:key_code=5; 
0671E:  MOVLW  05
06720:  MOVLB  5
06722:  MOVWF  x7F
.................... 				break; 
06724:  BRA    679E
.................... 		case 528:key_code=6; 
06726:  MOVLW  06
06728:  MOVLB  5
0672A:  MOVWF  x7F
.................... 				break; 
0672C:  BRA    679E
.................... 		case 32:key_code=7; 
0672E:  MOVLW  07
06730:  MOVLB  5
06732:  MOVWF  x7F
.................... 				break; 
06734:  BRA    679E
.................... 		case 288:key_code=8; 
06736:  MOVLW  08
06738:  MOVLB  5
0673A:  MOVWF  x7F
.................... 				break; 
0673C:  BRA    679E
.................... 		case 544:key_code=9; 
0673E:  MOVLW  09
06740:  MOVLB  5
06742:  MOVWF  x7F
....................                 break; 
06744:  BRA    679E
.................... 		case 1:	key_code=F1; 
06746:  MOVLW  0A
06748:  MOVLB  5
0674A:  MOVWF  x7F
....................                 break; 
0674C:  BRA    679E
.................... 		case 513:key_code=F2; 
0674E:  MOVLW  0B
06750:  MOVLB  5
06752:  MOVWF  x7F
....................                 break; 
06754:  BRA    679E
.................... 		case 4:	key_code=F3; 
06756:  MOVLW  0C
06758:  MOVLB  5
0675A:  MOVWF  x7F
....................                 break; 
0675C:  BRA    679E
.................... 		case 516:key_code=F4; 
0675E:  MOVLW  0D
06760:  MOVLB  5
06762:  MOVWF  x7F
....................                 break; 
06764:  BRA    679E
.................... 		case 64:key_code=ESC; 
06766:  MOVLW  12
06768:  MOVLB  5
0676A:  MOVWF  x7F
....................                 break; 
0676C:  BRA    679E
.................... 		case 576:key_code=ENTER; 
0676E:  MOVLW  13
06770:  MOVLB  5
06772:  MOVWF  x7F
....................                 break; 
06774:  BRA    679E
.................... 		case 257:key_code=SETA_SUPERIOR ; 
06776:  MOVLW  0E
06778:  MOVLB  5
0677A:  MOVWF  x7F
....................                 break; 
0677C:  BRA    679E
.................... 		case 2:	key_code=SETA_ESQUERDA ; 
0677E:  MOVLW  11
06780:  MOVLB  5
06782:  MOVWF  x7F
....................                 break; 
06784:  BRA    679E
.................... 		case 514:key_code=SETA_DIREITA ; 
06786:  MOVLW  10
06788:  MOVLB  5
0678A:  MOVWF  x7F
....................                 break; 
0678C:  BRA    679E
.................... 		case 260:key_code=SETA_INFERIOR; 
0678E:  MOVLW  0F
06790:  MOVLB  5
06792:  MOVWF  x7F
....................                 break; 
06794:  BRA    679E
.................... 		case 258:key_code=MENU; 
06796:  MOVLW  14
06798:  MOVLB  5
0679A:  MOVWF  x7F
....................                 break; 
0679C:  BRA    679E
.................... 	    default: 
.................... 				break; 
.................... 	} 
.................... 	return( key_code ); 
0679E:  MOVFF  57F,01
067A2:  MOVLB  0
067A4:  RETURN 0
.................... } 
.................... void espera_desacionar_teclas(void) { 
....................   int key_code = 0x00; 
....................   key_code = Teclado(); 
....................   while(key_code != 0xff){ 
....................     key_code = Teclado(); 
....................   } 
.................... } 
....................  
.................... #include "stepper_motor.c" 
.................... #DEFINE     step_y			    pin_C2 
.................... #DEFINE     dir_y				pin_C1 
.................... #DEFINE     enable_y			pin_C0 
.................... #DEFINE     step_x 		        pin_D2 
.................... #DEFINE     dir_x				pin_D1 
.................... #DEFINE     enable_x			pin_D0 
.................... #DEFINE     step_z              pin_A5              
.................... #DEFINE     dir_z               pin_A4 
.................... #DEFINE     enable_z            pin_A3 
.................... #DEFINE     step_flip           pin_E2 
.................... #DEFINE     dir_flip            pin_E1  
.................... #DEFINE     enable_flip         pin_E0 
....................  
.................... long int buffer_saida; 
.................... signed int16 motor_pos_x; 
.................... signed int16 motor_pos_y; 
.................... signed int16 motor_pos_flip; 
.................... signed int16 motor_pos_z; 
.................... short int direita_flag; 
.................... short int esquerda_flag; 
.................... short int frente_flag; 
.................... short int atras_flag; 
.................... short int sobe_flag; 
.................... short int desce_flag; 
.................... short int sentido_horario_flag; 
.................... short int sentido_antihorario_flag; 
....................  
.................... void direita(void) { 
....................     direita_flag = true; 
*
04F3A:  BSF    2D.5
....................     esquerda_flag = false; 
04F3C:  BCF    2D.6
....................     output_low(dir_x); 
04F3E:  BCF    F95.1
04F40:  BCF    F8C.1
04F42:  RETURN 0
.................... } 
.................... void esquerda(void) { 
....................     direita_flag = false; 
*
04EF8:  BCF    2D.5
....................     esquerda_flag = true; 
04EFA:  BSF    2D.6
....................     output_high(dir_x); 
04EFC:  BCF    F95.1
04EFE:  BSF    F8C.1
04F00:  RETURN 0
.................... } 
.................... void frente(void) { 
....................     frente_flag = true; 
*
04D82:  BSF    2D.7
....................     atras_flag = false; 
04D84:  MOVLB  2
04D86:  BCF    x0C.0
....................     output_low(dir_y); 
04D88:  BCF    F94.1
04D8A:  BCF    F8B.1
04D8C:  MOVLB  0
04D8E:  RETURN 0
.................... } 
.................... void atras(void) { 
....................     frente_flag = false; 
*
04DCA:  BCF    2D.7
....................     atras_flag = true; 
04DCC:  MOVLB  2
04DCE:  BSF    x0C.0
....................     output_high(dir_y); 
04DD0:  BCF    F94.1
04DD2:  BSF    F8B.1
04DD4:  MOVLB  0
04DD6:  RETURN 0
.................... } 
.................... void sentido_antihorario(void) { 
....................     sentido_horario_flag = true; 
*
05B9E:  MOVLB  2
05BA0:  BSF    x0C.3
....................     sentido_antihorario_flag = false; 
05BA2:  BCF    x0C.4
....................     output_high(dir_flip); 
05BA4:  BCF    F96.1
05BA6:  BSF    F8D.1
05BA8:  MOVLB  0
05BAA:  RETURN 0
.................... } 
.................... void sentido_horario(void) { 
....................     sentido_horario_flag = false; 
*
05B56:  MOVLB  2
05B58:  BCF    x0C.3
....................     sentido_antihorario_flag = true; 
05B5A:  BSF    x0C.4
....................     output_low(dir_flip); 
05B5C:  BCF    F96.1
05B5E:  BCF    F8D.1
05B60:  MOVLB  0
05B62:  RETURN 0
.................... } 
.................... void sobe(void) { 
....................     sobe_flag = true; 
*
04C78:  MOVLB  2
04C7A:  BSF    x0C.1
....................     desce_flag = false; 
04C7C:  BCF    x0C.2
....................     output_low(dir_z); 
04C7E:  BCF    F92.4
04C80:  BCF    F89.4
04C82:  MOVLB  0
04C84:  RETURN 0
.................... } 
.................... void desce(void) { 
....................     sobe_flag = false; 
*
04C36:  MOVLB  2
04C38:  BCF    x0C.1
....................     desce_flag = true; 
04C3A:  BSF    x0C.2
....................     output_high(dir_z); 
04C3C:  BCF    F92.4
04C3E:  BSF    F89.4
04C40:  MOVLB  0
04C42:  RETURN 0
.................... } 
....................  
.................... void one_step_x(void) { 
....................     output_high(step_x); 
*
04F02:  BCF    F95.2
04F04:  BSF    F8C.2
....................     delay_us(10); 
04F06:  MOVLW  10
04F08:  MOVWF  00
04F0A:  DECFSZ 00,F
04F0C:  BRA    4F0A
04F0E:  NOP   
....................     output_low(step_x); 
04F10:  BCF    F95.2
04F12:  BCF    F8C.2
....................     if (esquerda_flag == true) { 
04F14:  BTFSS  2D.6
04F16:  BRA    4F24
....................         motor_pos_x++; 
04F18:  MOVLB  2
04F1A:  INCF   x04,F
04F1C:  BTFSC  FD8.2
04F1E:  INCF   x05,F
....................     } else { 
04F20:  BRA    4F36
04F22:  MOVLB  0
....................         if (motor_pos_x != 0000){ 
04F24:  MOVLB  2
04F26:  MOVF   x04,F
04F28:  BNZ   4F2E
04F2A:  MOVF   x05,F
04F2C:  BZ    4F36
....................             motor_pos_x--; 
04F2E:  MOVF   x04,W
04F30:  BTFSC  FD8.2
04F32:  DECF   x05,F
04F34:  DECF   x04,F
....................         } 
....................     } 
04F36:  MOVLB  0
04F38:  RETURN 0
.................... } 
.................... void one_step_y(void) { 
....................     output_high(step_y); 
*
04D96:  BCF    F94.2
04D98:  BSF    F8B.2
....................     delay_us(10); 
04D9A:  MOVLW  10
04D9C:  MOVWF  00
04D9E:  DECFSZ 00,F
04DA0:  BRA    4D9E
04DA2:  NOP   
....................     output_low(step_y); 
04DA4:  BCF    F94.2
04DA6:  BCF    F8B.2
....................     if (atras_flag == true) { 
04DA8:  MOVLB  2
04DAA:  BTFSS  x0C.0
04DAC:  BRA    4DB6
....................         motor_pos_y++; 
04DAE:  INCF   x06,F
04DB0:  BTFSC  FD8.2
04DB2:  INCF   x07,F
....................     } else { 
04DB4:  BRA    4DC6
....................         if (motor_pos_y != 0000){ 
04DB6:  MOVF   x06,F
04DB8:  BNZ   4DBE
04DBA:  MOVF   x07,F
04DBC:  BZ    4DC6
....................             motor_pos_y--; 
04DBE:  MOVF   x06,W
04DC0:  BTFSC  FD8.2
04DC2:  DECF   x07,F
04DC4:  DECF   x06,F
....................         } 
....................     } 
04DC6:  MOVLB  0
04DC8:  RETURN 0
.................... } 
.................... void one_step_flip(void) { 
....................     output_high(step_flip); 
*
05B64:  BCF    F96.2
05B66:  BSF    F8D.2
....................     delay_us(10); 
05B68:  MOVLW  10
05B6A:  MOVWF  00
05B6C:  DECFSZ 00,F
05B6E:  BRA    5B6C
05B70:  NOP   
....................     output_low(step_flip); 
05B72:  BCF    F96.2
05B74:  BCF    F8D.2
....................     if (sentido_antihorario_flag == true){ 
05B76:  MOVLB  2
05B78:  BTFSS  x0C.4
05B7A:  BRA    5B84
....................         motor_pos_flip++; 
05B7C:  INCF   x08,F
05B7E:  BTFSC  FD8.2
05B80:  INCF   x09,F
....................     } else { 
05B82:  BRA    5B9A
....................         if (motor_pos_flip > 0){ 
05B84:  BTFSC  x09.7
05B86:  BRA    5B9A
05B88:  MOVF   x09,F
05B8A:  BNZ   5B92
05B8C:  MOVF   x08,W
05B8E:  SUBLW  00
05B90:  BC    5B9A
....................         motor_pos_flip--; 
05B92:  MOVF   x08,W
05B94:  BTFSC  FD8.2
05B96:  DECF   x09,F
05B98:  DECF   x08,F
....................         } 
....................     } 
05B9A:  MOVLB  0
05B9C:  RETURN 0
.................... } 
.................... void one_step_z(void) { 
....................     output_high(step_z); 
*
04C44:  BCF    F92.5
04C46:  BSF    F89.5
....................     delay_us(10); 
04C48:  MOVLW  10
04C4A:  MOVWF  00
04C4C:  DECFSZ 00,F
04C4E:  BRA    4C4C
04C50:  NOP   
....................     output_low(step_z); 
04C52:  BCF    F92.5
04C54:  BCF    F89.5
....................     if (desce_flag == true) { 
04C56:  MOVLB  2
04C58:  BTFSS  x0C.2
04C5A:  BRA    4C64
....................         motor_pos_z++; 
04C5C:  INCF   x0A,F
04C5E:  BTFSC  FD8.2
04C60:  INCF   x0B,F
....................     } else { 
04C62:  BRA    4C74
....................         if (motor_pos_z != 0000){ 
04C64:  MOVF   x0A,F
04C66:  BNZ   4C6C
04C68:  MOVF   x0B,F
04C6A:  BZ    4C74
....................             motor_pos_z--; 
04C6C:  MOVF   x0A,W
04C6E:  BTFSC  FD8.2
04C70:  DECF   x0B,F
04C72:  DECF   x0A,F
....................         } 
....................     } 
04C74:  MOVLB  0
04C76:  RETURN 0
.................... } 
....................  
.................... void chopper_x(void) { 
....................     output_low(enable_x); 
*
04EF0:  BCF    F95.0
04EF2:  BCF    F8C.0
04EF4:  GOTO   4F4E (RETURN)
.................... } 
.................... void chopper_y(void) { 
....................     output_low(enable_y); 
*
04D90:  BCF    F94.0
04D92:  BCF    F8B.0
04D94:  RETURN 0
.................... } 
.................... void chopper_flip(void) { 
....................     output_low(enable_flip); 
*
05B4E:  BCF    F96.0
05B50:  BCF    F8D.0
05B52:  GOTO   5BAE (RETURN)
.................... } 
.................... void chopper_z(void) { 
....................     output_low(enable_z); 
*
04934:  BCF    F92.3
04936:  BCF    F89.3
04938:  GOTO   4C90 (RETURN)
.................... } 
.................... void stop_x(void) { 
....................     output_low(enable_x); 
*
04F44:  BCF    F95.0
04F46:  BCF    F8C.0
04F48:  GOTO   505C (RETURN)
.................... } 
.................... void stop_y(void) { 
....................     output_low(enable_y); 
*
04DD8:  BCF    F94.0
04DDA:  BCF    F8B.0
04DDC:  RETURN 0
.................... } 
.................... void stop_flip(void) { 
....................     output_low(enable_flip); 
.................... } 
.................... void stop_z(void) { 
....................     output_low(enable_z); 
*
04C86:  BCF    F92.3
04C88:  BCF    F89.3
04C8A:  GOTO   4D80 (RETURN)
.................... } 
....................  
.................... #include "I_O.c" 
.................... #define     IN0				0 
.................... #define     IN1				1 
.................... #define     IN2				2 
.................... #define     IN3				3 
.................... #define     IN4				4 
.................... #define     IN5				5 
.................... #define     IN6				6 
.................... #define     IN7				7 
.................... #define     IN8				8 
.................... #define     IN9				9 
.................... #define     IN10			10 
.................... #define     IN11			11 
.................... #define     IN12			12 
.................... #define     IN13			13 
.................... #define     IN14			14 
.................... #define     IN15			15 
.................... #define     IN16			16 
.................... #define     IN17			17 
.................... #define     IN18			18 
.................... #define     IN19			19 
.................... #define     IN20			20 
.................... #define     IN21			21	 
.................... #define     IN22			22 
.................... #define     IN23			23 
.................... #define     IN24			24 
.................... #define     IN25			25 
.................... #define     IN26    		26 
.................... #define     IN27	    	27 
.................... 	 
.................... #define     S_DEDO_IN_LS1      	    IN0  	//SENSOR AVANO CILINRO  1		 
.................... #define     S_DEDO_IN_LS2      	    IN1	 	//SENSOR AVANO CILINDRO 2			 
.................... #define     S_EMPURRADOR_IN_LS1	    IN2	 	//NT 
.................... #define     S_EMPURRADOR_IN_LS2     IN3	 	//SENSOR RECUO  CLP1			 
.................... #define     S_PRESSOR_LS2           IN4	 	//SENSOR AVANCO 
.................... #define     S_X_DIREITA			    IN5	 	//LIMITE DIREITA			 
.................... #define     S_X_ESQUERDA		    IN6	 	//LIMITE ESQUERDA			 
.................... #define     S_Y_FRENTE   		    IN7  	//LIMITE FRENTE			 
.................... #define     S_Y_ATRAS               IN8  	//LIMITE ATRAS	 
.................... #define     S_Y_DIREITA_PROT  	    IN9  	//LIMITE DIREITA DA OUTRA PLACA			 
.................... #define     S_Y_ESQUERDA_PROT       IN10 	//LIMITE ESQUERDA DA OUTRA PLACA	 
.................... #define     S_ROTACAO_LS1           IN11 	//SENSOR LIMITE GIRO HORARIO			 
.................... #define     S_FERRO_SOLDA1          IN12 	//SENSOR FERRO DE SOLDA 1 			 
.................... #define     S_Z_TOP	    		    IN13 	//SENSOR LIMITE  SUPEIOR			 
.................... #define     S_Z_BOTTOM			    IN14 	//SENSOR LIMITE  INFERIOR			 
.................... #define     S_FERRO_SOLDA2          IN15 	//SENSOR FERRO DE SOLDA 2			 
.................... #define     S_DEDO_OUT_LS1		    IN16 	//SENSOR AVANO 
.................... #define     S_DEDO_OUT_LS2	        IN17 	//SENSOR AVANO 
.................... #define     S_EMPURRADOR_OUT_LS1    IN18 	//SENSOR AVANO 			 
.................... #define     S_EMPURRADOR_OUT_LS2    IN19 	//SENSOR recuo	 
.................... #define     SENSOR_BOARD   			IN20 	 
.................... #define     S_BANDEJA               IN21 	//SENSOR BANDEJA CLP1 & CLP2 
.................... #define     S_FIO_SOLDA1	        IN22 	//SENSOR FIO DE SOLDA 1 
.................... #define     S_FIO_SOLDA2	        IN23 	//SENSOR FIO DE SOLDA 2 
.................... #define     S_FIO_SOLDA3	        IN24 	//SENSOR FIO DE SOLDA 3 
.................... #define     S_ESTEIRA               IN25 	//SENSOR DESLIGA ESTEIRA 
.................... #define     RESERVADO2 				IN26 	 
.................... #define     RESERVADO3              IN27    //RESET 
....................    	  
.................... // definio das saidas de comandos 
.................... #define     DEDO_ENTRADA				     7  //OUT 0 
.................... #define     EMPURRADOR_ENTRADA_SOL_EMPURRA   6  //OUT 1 
.................... #define     EMPURRADOR_ENTRADA_SOL_RETORNA 	 5  //OUT 2 
.................... #define     PRESSOR						     4  //OUT 3 
.................... #define     FERRO_SOLDA1				     3  //OUT 4 
.................... #define     FERRO_SOLDA2				     2  //OUT 5 
.................... #define     DEDO_SAIDA					     1  //OUT 6 
.................... #define     EMPURRADOR_SAIDA_SOL_EMPURRA     0  //OUT 7 
.................... #define     EMPURRADOR_SAIDA_SOL_RETORNA     15 //OUT 8 
.................... #define     ALIMENTADOR1					 14 //OUT 9  RL2 
.................... #define     ALIMENTADOR2					 13 //OUT 10 RL3 
.................... #define     ALIMENTADOR3					 12	//OUT 11 RL4  
.................... #define     LIMPADOR					     11	//OUT 12 RL5 
.................... #define     RELE_ESTEIRA                     10 //OUT 13  
.................... #define     LIMPA_BICO1                       8 //OUT 15    
.................... #define     LIMPA_BICO2                       9 //OUT 14  
....................  
.................... short int le_Input(int input_number){ 
*
049FA:  MOVLB  5
049FC:  CLRF   x7D
049FE:  CLRF   x7C
04A00:  CLRF   x7E
.................... 	short int retorno; 
....................     long int  data_sensores  = 0x0000; 
.................... 	int		  data_sensores2 = 0x00;	 
.................... 	if(input_number < 16) { 
04A02:  MOVF   x7A,W
04A04:  SUBLW  0F
04A06:  BNC   4A7C
.................... 	 	data_sensores = le_PCA9555(0X03,0X00); 
04A08:  MOVLW  03
04A0A:  MOVWF  x86
04A0C:  CLRF   x87
04A0E:  MOVLB  0
04A10:  RCALL  493C
04A12:  MOVFF  02,57D
04A16:  MOVFF  01,57C
.................... 		if(bit_test (data_sensores,input_number) == 0){ 
04A1A:  MOVFF  57D,03
04A1E:  MOVLB  5
04A20:  MOVFF  57C,02
04A24:  MOVF   x7A,W
04A26:  MOVWF  00
04A28:  BZ    4A34
04A2A:  BCF    FD8.0
04A2C:  RRCF   03,F
04A2E:  RRCF   02,F
04A30:  DECFSZ 00,F
04A32:  BRA    4A2A
04A34:  MOVF   02,W
04A36:  BTFSC  02.0
04A38:  BRA    4A74
.................... 			delay_us(30); 
04A3A:  MOVLW  31
04A3C:  MOVWF  00
04A3E:  DECFSZ 00,F
04A40:  BRA    4A3E
04A42:  BRA    4A44
.................... 			if(bit_test (data_sensores,input_number) == 0) return retorno = true; 
04A44:  MOVFF  57D,03
04A48:  MOVFF  57C,02
04A4C:  MOVF   x7A,W
04A4E:  MOVWF  00
04A50:  BZ    4A5C
04A52:  BCF    FD8.0
04A54:  RRCF   03,F
04A56:  RRCF   02,F
04A58:  DECFSZ 00,F
04A5A:  BRA    4A52
04A5C:  MOVF   02,W
04A5E:  BTFSC  02.0
04A60:  BRA    4A6A
04A62:  BSF    x7B.0
04A64:  MOVLW  01
04A66:  MOVWF  01
04A68:  BRA    4C06
.................... 			return  retorno = false; 
04A6A:  BCF    x7B.0
04A6C:  MOVLW  00
04A6E:  MOVWF  01
04A70:  BRA    4C06
.................... 		} 
04A72:  BRA    4A7C
....................         else  
....................             return  retorno = false; 
04A74:  BCF    x7B.0
04A76:  MOVLW  00
04A78:  MOVWF  01
04A7A:  BRA    4C06
.................... 	}		 
.................... 	if((input_number >= 16) && (input_number < 24)){ 
04A7C:  MOVF   x7A,W
04A7E:  SUBLW  0F
04A80:  BC    4AF2
04A82:  MOVF   x7A,W
04A84:  SUBLW  17
04A86:  BNC   4AF2
.................... 		data_sensores2 = le_pcf8574A(0x04); 
04A88:  MOVLW  04
04A8A:  MOVWF  x7F
04A8C:  MOVLB  0
04A8E:  BRA    49C4
04A90:  MOVFF  01,57E
.................... 		if(bit_test (data_sensores2,input_number - 16) == 0) { 
04A94:  MOVLW  10
04A96:  MOVLB  5
04A98:  SUBWF  x7A,W
04A9A:  MOVWF  x7F
04A9C:  MOVFF  57E,00
04AA0:  MOVF   x7F,W
04AA2:  MOVWF  01
04AA4:  BZ    4AAE
04AA6:  BCF    FD8.0
04AA8:  RRCF   00,F
04AAA:  DECFSZ 01,F
04AAC:  BRA    4AA6
04AAE:  BTFSC  00.0
04AB0:  BRA    4AEA
.................... 			delay_us(30); 
04AB2:  MOVLW  31
04AB4:  MOVWF  00
04AB6:  DECFSZ 00,F
04AB8:  BRA    4AB6
04ABA:  BRA    4ABC
.................... 			if(bit_test (data_sensores2,input_number - 16) == 0) return retorno = true; 
04ABC:  MOVLW  10
04ABE:  SUBWF  x7A,W
04AC0:  MOVWF  x7F
04AC2:  MOVFF  57E,00
04AC6:  MOVF   x7F,W
04AC8:  MOVWF  01
04ACA:  BZ    4AD4
04ACC:  BCF    FD8.0
04ACE:  RRCF   00,F
04AD0:  DECFSZ 01,F
04AD2:  BRA    4ACC
04AD4:  BTFSC  00.0
04AD6:  BRA    4AE0
04AD8:  BSF    x7B.0
04ADA:  MOVLW  01
04ADC:  MOVWF  01
04ADE:  BRA    4C06
.................... 			return    retorno = false; 
04AE0:  BCF    x7B.0
04AE2:  MOVLW  00
04AE4:  MOVWF  01
04AE6:  BRA    4C06
.................... 		} 
04AE8:  BRA    4AF2
....................         else { 
....................             return  retorno = false; 
04AEA:  BCF    x7B.0
04AEC:  MOVLW  00
04AEE:  MOVWF  01
04AF0:  BRA    4C06
....................         } 
.................... 	} 
.................... 	if((input_number >= 24) && (input_number <= 27)) {	 
04AF2:  MOVF   x7A,W
04AF4:  SUBLW  17
04AF6:  BTFSC  FD8.0
04AF8:  BRA    4C06
04AFA:  MOVF   x7A,W
04AFC:  SUBLW  1B
04AFE:  BTFSS  FD8.0
04B00:  BRA    4C06
.................... 		switch(input_number) { 
04B02:  MOVLW  18
04B04:  SUBWF  x7A,W
04B06:  ADDLW  FC
04B08:  BTFSC  FD8.0
04B0A:  BRA    4C06
04B0C:  ADDLW  04
04B0E:  MOVLB  0
04B10:  GOTO   4C0A
.................... 			case 24: 
....................                 if(input(in24_bit) == 0) { 
04B14:  BSF    F93.0
04B16:  BTFSC  F81.0
04B18:  BRA    4B40
....................                     delay_us(30); 
04B1A:  MOVLW  31
04B1C:  MOVWF  00
04B1E:  DECFSZ 00,F
04B20:  BRA    4B1E
04B22:  BRA    4B24
....................                     if(input(in24_bit) == 0) { 
04B24:  BSF    F93.0
04B26:  BTFSC  F81.0
04B28:  BRA    4B3E
....................                         return retorno	= true;		 
04B2A:  MOVLB  5
04B2C:  BSF    x7B.0
04B2E:  MOVLW  01
04B30:  MOVWF  01
04B32:  BRA    4C06
....................                         return retorno	= false;	 
04B34:  BCF    x7B.0
04B36:  MOVLW  00
04B38:  MOVWF  01
04B3A:  BRA    4C06
04B3C:  MOVLB  0
....................                     } 
....................                 } 
04B3E:  BRA    4B4C
....................                 else {	 
....................                     return retorno	= false; 
04B40:  MOVLB  5
04B42:  BCF    x7B.0
04B44:  MOVLW  00
04B46:  MOVWF  01
04B48:  BRA    4C06
04B4A:  MOVLB  0
....................                 } 
....................             break; 
04B4C:  MOVLB  5
04B4E:  BRA    4C06
.................... 			case 25: 
....................                 if(input(in25_bit) == 0){ 
04B50:  BSF    F93.1
04B52:  BTFSC  F81.1
04B54:  BRA    4B7C
....................                     delay_us(30); 
04B56:  MOVLW  31
04B58:  MOVWF  00
04B5A:  DECFSZ 00,F
04B5C:  BRA    4B5A
04B5E:  BRA    4B60
....................                     if(input(in25_bit) == 0) { 
04B60:  BSF    F93.1
04B62:  BTFSC  F81.1
04B64:  BRA    4B7A
....................                         return retorno	= true;		 
04B66:  MOVLB  5
04B68:  BSF    x7B.0
04B6A:  MOVLW  01
04B6C:  MOVWF  01
04B6E:  BRA    4C06
....................                         return retorno	= false;	 
04B70:  BCF    x7B.0
04B72:  MOVLW  00
04B74:  MOVWF  01
04B76:  BRA    4C06
04B78:  MOVLB  0
....................                     } 
....................                 }else {	 
04B7A:  BRA    4B88
....................                     return retorno	= false; 
04B7C:  MOVLB  5
04B7E:  BCF    x7B.0
04B80:  MOVLW  00
04B82:  MOVWF  01
04B84:  BRA    4C06
04B86:  MOVLB  0
....................                 } 
....................             break; 
04B88:  MOVLB  5
04B8A:  BRA    4C06
.................... 			case 26: 
....................                 if(input(in26_bit) == 0){ 
04B8C:  BSF    F93.3
04B8E:  BTFSC  F81.3
04B90:  BRA    4BB8
....................                     delay_us(30); 
04B92:  MOVLW  31
04B94:  MOVWF  00
04B96:  DECFSZ 00,F
04B98:  BRA    4B96
04B9A:  BRA    4B9C
....................                     if(input(in26_bit) == 0) { 
04B9C:  BSF    F93.3
04B9E:  BTFSC  F81.3
04BA0:  BRA    4BB6
....................                         return retorno	= true;		 
04BA2:  MOVLB  5
04BA4:  BSF    x7B.0
04BA6:  MOVLW  01
04BA8:  MOVWF  01
04BAA:  BRA    4C06
....................                         return retorno	= false;	 
04BAC:  BCF    x7B.0
04BAE:  MOVLW  00
04BB0:  MOVWF  01
04BB2:  BRA    4C06
04BB4:  MOVLB  0
....................                     } 
....................                 }else{ 	 
04BB6:  BRA    4BC4
....................                     return retorno	= false; 
04BB8:  MOVLB  5
04BBA:  BCF    x7B.0
04BBC:  MOVLW  00
04BBE:  MOVWF  01
04BC0:  BRA    4C06
04BC2:  MOVLB  0
....................                 } 
....................             break; 
04BC4:  MOVLB  5
04BC6:  BRA    4C06
.................... 			case 27: 
....................                 if(input(in27_bit) == 0) { 
04BC8:  BSF    F93.4
04BCA:  BTFSC  F81.4
04BCC:  BRA    4BF4
....................                     delay_us(30); 
04BCE:  MOVLW  31
04BD0:  MOVWF  00
04BD2:  DECFSZ 00,F
04BD4:  BRA    4BD2
04BD6:  BRA    4BD8
....................                     if(input(in27_bit) == 0) { 
04BD8:  BSF    F93.4
04BDA:  BTFSC  F81.4
04BDC:  BRA    4BF2
....................                         return retorno	= true;		 
04BDE:  MOVLB  5
04BE0:  BSF    x7B.0
04BE2:  MOVLW  01
04BE4:  MOVWF  01
04BE6:  BRA    4C06
....................                         return retorno	= false;	 
04BE8:  BCF    x7B.0
04BEA:  MOVLW  00
04BEC:  MOVWF  01
04BEE:  BRA    4C06
04BF0:  MOVLB  0
....................                     } 
....................                 }else{ 	 
04BF2:  BRA    4C00
....................                     return retorno	= false; 
04BF4:  MOVLB  5
04BF6:  BCF    x7B.0
04BF8:  MOVLW  00
04BFA:  MOVWF  01
04BFC:  BRA    4C06
04BFE:  MOVLB  0
....................                 } 
....................             break; 
04C00:  MOVLB  5
04C02:  BRA    4C06
04C04:  MOVLB  5
.................... 	 	} 
.................... 	} 
04C06:  MOVLB  0
04C08:  RETURN 0
.................... } 
.................... void aciona_saida(long int output_word){ 
.................... 	int valor_lsb; 
.................... 	int valor_msb; 
.................... 	bit_clear(buffer_saida,output_word); 
*
02E1E:  CLRF   03
02E20:  MOVLW  01
02E22:  MOVWF  02
02E24:  MOVLB  5
02E26:  MOVF   x8F,W
02E28:  MOVWF  00
02E2A:  BZ    2E36
02E2C:  BCF    FD8.0
02E2E:  RLCF   02,F
02E30:  RLCF   03,F
02E32:  DECFSZ 00,F
02E34:  BRA    2E2C
02E36:  MOVF   02,W
02E38:  XORLW  FF
02E3A:  MOVWF  00
02E3C:  MOVLW  FF
02E3E:  XORWF  03,F
02E40:  MOVF   00,W
02E42:  MOVLB  2
02E44:  ANDWF  x02,F
02E46:  MOVF   03,W
02E48:  ANDWF  x03,F
.................... 	valor_lsb = make8(buffer_saida,0);   
02E4A:  MOVFF  202,591
02E4E:  MOVLB  5
.................... 	valor_msb = make8(buffer_saida,1); 
02E50:  MOVFF  203,592
02E54:  MOVLB  5
.................... 	escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
02E56:  MOVLW  02
02E58:  MOVWF  x93
02E5A:  MOVWF  x94
02E5C:  MOVFF  592,595
02E60:  MOVFF  591,596
02E64:  MOVLB  0
02E66:  RCALL  2A30
02E68:  RETURN 0
.................... } 
.................... void desaciona_saida(long int output_word){ 
.................... 	int valor_lsb; 
.................... 	int valor_msb; 
.................... 	bit_set(buffer_saida,output_word); 
*
02DDC:  CLRF   03
02DDE:  MOVLW  01
02DE0:  MOVWF  02
02DE2:  MOVLB  5
02DE4:  MOVF   x8F,W
02DE6:  MOVWF  00
02DE8:  BZ    2DF4
02DEA:  BCF    FD8.0
02DEC:  RLCF   02,F
02DEE:  RLCF   03,F
02DF0:  DECFSZ 00,F
02DF2:  BRA    2DEA
02DF4:  MOVF   02,W
02DF6:  MOVLB  2
02DF8:  IORWF  x02,F
02DFA:  MOVF   03,W
02DFC:  IORWF  x03,F
.................... 	valor_lsb = make8(buffer_saida,0);   
02DFE:  MOVFF  202,591
02E02:  MOVLB  5
.................... 	valor_msb = make8(buffer_saida,1); 
02E04:  MOVFF  203,592
02E08:  MOVLB  5
.................... 	escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
02E0A:  MOVLW  02
02E0C:  MOVWF  x93
02E0E:  MOVWF  x94
02E10:  MOVFF  592,595
02E14:  MOVFF  591,596
02E18:  MOVLB  0
02E1A:  RCALL  2A30
02E1C:  RETURN 0
.................... } 
.................... void desaciona_todas_saidas(void){ 
.................... 	int valor_lsb; 
.................... 	int valor_msb; 
.................... 	buffer_saida = 0x0ffff; 
*
02ADA:  MOVLB  2
02ADC:  SETF   x03
02ADE:  SETF   x02
.................... 	valor_lsb = make8(buffer_saida,0);   
02AE0:  MOVFF  202,575
02AE4:  MOVLB  5
.................... 	valor_msb = make8(buffer_saida,1); 
02AE6:  MOVFF  203,576
02AEA:  MOVLB  5
.................... 	escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
02AEC:  MOVLW  02
02AEE:  MOVWF  x93
02AF0:  MOVWF  x94
02AF2:  MOVFF  576,595
02AF6:  MOVFF  575,596
02AFA:  MOVLB  0
02AFC:  RCALL  2A30
02AFE:  GOTO   D7C2 (RETURN)
.................... } 
.................... void Init_Sensores_porta1(void){ 
.................... 	escreve_PCA9555(0X03,0X06,0Xff,0xff);	// programa bits entradas  
*
02AAE:  MOVLW  03
02AB0:  MOVLB  5
02AB2:  MOVWF  x93
02AB4:  MOVLW  06
02AB6:  MOVWF  x94
02AB8:  SETF   x95
02ABA:  SETF   x96
02ABC:  MOVLB  0
02ABE:  RCALL  2A30
02AC0:  GOTO   D7BA (RETURN)
.................... } 
.................... void Init_saidas(void){ 
.................... 	escreve_PCA9555(0X02,0X06,0X00,0x00);	// programa bits saidas //como saida e os demais como entrada     
02AC4:  MOVLW  02
02AC6:  MOVLB  5
02AC8:  MOVWF  x93
02ACA:  MOVLW  06
02ACC:  MOVWF  x94
02ACE:  CLRF   x95
02AD0:  CLRF   x96
02AD2:  MOVLB  0
02AD4:  RCALL  2A30
02AD6:  GOTO   D7BE (RETURN)
.................... } 
....................  
.................... #include "comunicacao_entre_maquinas.c" 
.................... #include "comunicacao_entre_maquinas.h" 
.................... /*  
....................  * File:   comunicacao_entre_maquinas.h 
....................  * Author: ictsam0100 
....................  * 
....................  * Created on 6 de Dezembro de 2018, 11:13 
....................  */ 
....................  
.................... int posicao_maq; 
.................... int n_posicao; 
.................... int n_bit; 
....................  
.................... short int le_bit(int n_bit); //l bit especifico e verifica o valor "0 ou 1" 
.................... int ler_posicao_maquina_1 (void); //le os bits H3, H4 e H5 para verificar a posicao da maquina 1 
.................... void enviar_posicao_para_maquina_1 (int n_posicao); //aciona os outputs H0, H1 e H2 para enviar posicao para maquina 1    
....................  
....................  
.................... short int le_bit(int n_bit) { 
....................     short int retorno; 
....................  
....................     if (input(n_bit) == 1) { 
*
051E4:  MOVFF  57C,57E
051E8:  MOVLW  01
051EA:  MOVLB  5
051EC:  MOVWF  x7F
051EE:  MOVLW  0F
051F0:  MOVWF  x81
051F2:  MOVLW  92
051F4:  MOVWF  x80
051F6:  MOVLB  0
051F8:  RCALL  5170
051FA:  MOVFF  57C,57E
051FE:  MOVLW  0F
05200:  MOVLB  5
05202:  MOVWF  x80
05204:  MOVLW  80
05206:  MOVWF  x7F
05208:  MOVLB  0
0520A:  RCALL  51B2
0520C:  BTFSS  01.0
0520E:  BRA    5226
....................         return retorno = 1; 
05210:  MOVLB  5
05212:  BSF    x7D.0
05214:  MOVLW  01
05216:  MOVWF  01
05218:  BRA    5266
....................         delay_us(30); 
0521A:  MOVLW  31
0521C:  MOVWF  00
0521E:  DECFSZ 00,F
05220:  BRA    521E
05222:  BRA    5224
05224:  MOVLB  0
....................     } 
....................     if (input(n_bit) == 0) { 
05226:  MOVFF  57C,57E
0522A:  MOVLW  01
0522C:  MOVLB  5
0522E:  MOVWF  x7F
05230:  MOVLW  0F
05232:  MOVWF  x81
05234:  MOVLW  92
05236:  MOVWF  x80
05238:  MOVLB  0
0523A:  RCALL  5170
0523C:  MOVFF  57C,57E
05240:  MOVLW  0F
05242:  MOVLB  5
05244:  MOVWF  x80
05246:  MOVLW  80
05248:  MOVWF  x7F
0524A:  MOVLB  0
0524C:  RCALL  51B2
0524E:  BTFSC  01.0
05250:  BRA    5268
....................         return retorno = 0; 
05252:  MOVLB  5
05254:  BCF    x7D.0
05256:  MOVLW  00
05258:  MOVWF  01
0525A:  BRA    5266
....................         delay_us(30); 
0525C:  MOVLW  31
0525E:  MOVWF  00
05260:  DECFSZ 00,F
05262:  BRA    5260
05264:  BRA    5266
05266:  MOVLB  0
....................     } 
05268:  RETURN 0
.................... } 
.................... int le_posicao_outra_maquina (void){ 
0526A:  MOVLW  1C
0526C:  MOVLB  5
0526E:  MOVWF  x7C
05270:  MOVLB  0
05272:  RCALL  51E4
05274:  MOVFF  01,579
05278:  MOVLW  17
0527A:  MOVLB  5
0527C:  MOVWF  x7C
0527E:  MOVLB  0
05280:  RCALL  51E4
05282:  MOVFF  01,57A
05286:  MOVLW  16
05288:  MOVLB  5
0528A:  MOVWF  x7C
0528C:  MOVLB  0
0528E:  RCALL  51E4
05290:  MOVFF  01,57B
....................     int x = le_bit(H3); 
....................     int y = le_bit(H4); 
....................     int z = le_bit(H5); 
....................      
....................     switch (z) { 
05294:  MOVLB  5
05296:  MOVF   x7B,W
05298:  XORLW  00
0529A:  MOVLB  0
0529C:  BZ    52A4
0529E:  XORLW  01
052A0:  BZ    52FC
052A2:  BRA    533C
....................         case 0: 
....................             switch (y) { 
052A4:  MOVLB  5
052A6:  MOVF   x7A,W
052A8:  XORLW  00
052AA:  MOVLB  0
052AC:  BZ    52B4
052AE:  XORLW  01
052B0:  BZ    52D6
052B2:  BRA    52FA
....................                 case 0: 
....................                     switch (x) { 
052B4:  MOVLB  5
052B6:  MOVF   x79,W
052B8:  XORLW  00
052BA:  MOVLB  0
052BC:  BZ    52C4
052BE:  XORLW  01
052C0:  BZ    52CC
052C2:  BRA    52D4
....................                         case 0: 
....................                             posicao_maq = ALIMENTADOR; 
052C4:  MOVLB  2
052C6:  CLRF   x0D
....................                         break; 
052C8:  MOVLB  0
052CA:  BRA    52D4
....................                         case 1: 
....................                             posicao_maq = HOME1; 
052CC:  MOVLW  01
052CE:  MOVLB  2
052D0:  MOVWF  x0D
....................                         break; 
052D2:  MOVLB  0
....................                     } 
....................                 break; 
052D4:  BRA    52FA
....................                 case 1: 
....................                     switch (x) { 
052D6:  MOVLB  5
052D8:  MOVF   x79,W
052DA:  XORLW  00
052DC:  MOVLB  0
052DE:  BZ    52E6
052E0:  XORLW  01
052E2:  BZ    52F0
052E4:  BRA    52F8
....................                         case 0: 
....................                             posicao_maq = SOLDAGEM; 
052E6:  MOVLW  03
052E8:  MOVLB  2
052EA:  MOVWF  x0D
....................                         break; 
052EC:  MOVLB  0
052EE:  BRA    52F8
....................                         case 1: 
....................                             posicao_maq = HOME2; 
052F0:  MOVLW  04
052F2:  MOVLB  2
052F4:  MOVWF  x0D
....................                         break; 
052F6:  MOVLB  0
....................                     } 
....................                 break;                     
052F8:  BRA    52FA
....................             } 
....................         break; 
052FA:  BRA    533C
....................         case 1: 
....................             switch (y) { 
052FC:  MOVLB  5
052FE:  MOVF   x7A,W
05300:  XORLW  00
05302:  MOVLB  0
05304:  BZ    530C
05306:  XORLW  01
05308:  BZ    5328
0530A:  BRA    533C
....................                 case 0: 
....................                     switch (x) { 
0530C:  MOVLB  5
0530E:  MOVF   x79,W
05310:  XORLW  00
05312:  MOVLB  0
05314:  BZ    531C
05316:  XORLW  01
05318:  BZ    5326
0531A:  BRA    5326
....................                         case 0: 
....................                             posicao_maq = DISPENSADOR; 
0531C:  MOVLW  05
0531E:  MOVLB  2
05320:  MOVWF  x0D
....................                         break; 
05322:  MOVLB  0
05324:  BRA    5326
....................                         case 1: 
....................                              
....................                         break; 
....................                     } 
....................                 break; 
05326:  BRA    533C
....................                 case 1: 
....................                     switch (x) { 
05328:  MOVLB  5
0532A:  MOVF   x79,W
0532C:  XORLW  00
0532E:  MOVLB  0
05330:  BZ    5338
05332:  XORLW  01
05334:  BZ    533A
05336:  BRA    533A
....................                         case 0: 
....................                              
....................                         break; 
05338:  BRA    533A
....................                         case 1: 
....................                              
....................                         break; 
....................                     } 
....................                 break;  
0533A:  BRA    533C
....................             }                 
....................         break; 
....................     } 
....................     return posicao_maq; 
0533C:  MOVLB  2
0533E:  MOVFF  20D,01
05342:  MOVLB  0
05344:  RETURN 0
.................... } 
.................... void envia_posicao_para_outra_maquina (int n_posicao) { 
....................     switch (n_posicao){ 
*
04752:  MOVLB  5
04754:  MOVF   x79,W
04756:  ADDLW  FA
04758:  BC    47B4
0475A:  ADDLW  06
0475C:  MOVLB  0
0475E:  GOTO   47B8
....................         case ALIMENTADOR: 
....................             output_low(H0); 
04762:  BCF    F95.7
04764:  BCF    F8C.7
....................             output_low(H1); 
04766:  BCF    F95.6
04768:  BCF    F8C.6
....................             output_low(H2); 
0476A:  BCF    F95.5
0476C:  BCF    F8C.5
....................         break; 
0476E:  MOVLB  5
04770:  BRA    47B4
....................         case HOME1: 
....................             output_high(H0); 
04772:  BCF    F95.7
04774:  BSF    F8C.7
....................             output_low (H1); 
04776:  BCF    F95.6
04778:  BCF    F8C.6
....................             output_low (H2); 
0477A:  BCF    F95.5
0477C:  BCF    F8C.5
....................         break; 
0477E:  MOVLB  5
04780:  BRA    47B4
....................         case SOLDAGEM: 
....................             output_low (H0); 
04782:  BCF    F95.7
04784:  BCF    F8C.7
....................             output_high(H1); 
04786:  BCF    F95.6
04788:  BSF    F8C.6
....................             output_low (H2); 
0478A:  BCF    F95.5
0478C:  BCF    F8C.5
....................         break; 
0478E:  MOVLB  5
04790:  BRA    47B4
....................         case HOME2: 
....................             output_high (H0); 
04792:  BCF    F95.7
04794:  BSF    F8C.7
....................             output_high(H1); 
04796:  BCF    F95.6
04798:  BSF    F8C.6
....................             output_low(H2); 
0479A:  BCF    F95.5
0479C:  BCF    F8C.5
....................         break; 
0479E:  MOVLB  5
047A0:  BRA    47B4
....................         case DISPENSADOR: 
....................             output_low (H0); 
047A2:  BCF    F95.7
047A4:  BCF    F8C.7
....................             output_low (H1); 
047A6:  BCF    F95.6
047A8:  BCF    F8C.6
....................             output_high(H2); 
047AA:  BCF    F95.5
047AC:  BSF    F8C.5
....................         break; 
047AE:  MOVLB  5
047B0:  BRA    47B4
047B2:  MOVLB  5
....................     } 
047B4:  MOVLB  0
047B6:  RETURN 0
.................... } 
....................  
.................... #include "telas_maquina_2.c" 
.................... #include "telas_maquina_2.h" 
.................... #define menu_principal                          0 
.................... #define menu_seleciona_maquina                  1 
.................... #define menu_seleciona_debug                    2 
.................... #define menu_seleciona_manutencao               3 
.................... #define menu_debug_entrada_1                    4 
.................... #define menu_debug_entrada_2                    5 
.................... #define menu_debug_entrada_3                    6 
.................... #define menu_manutencao_outra_maquina           7 
.................... #define menu_debug_saida_1                      8 
.................... #define menu_debug_saida_2                      9 
.................... #define menu_debug_saida_3                      10 
.................... #define menu_debug_saida_4                      11 
....................  
.................... #define menu_programa_principal                 12 
....................  
.................... #define menu_edita_modelo                       13 
.................... #define menu_excluir_modelo                     14 
.................... #define menu_seleciona_pontos                   15 
.................... #define menu_dados_ponto                        16 
.................... #define menu_edita_pontos_no_modelo             17 
.................... #define menu_dados_ponto_2                      18 
.................... #define menu_faltaSolda                         19 
.................... #define menu_seleciona_debug_2                  20 
.................... #define menu_confirmaManutencao                 21 
....................  
.................... void tela_apresentacao(void); //Tela que aparece quando liga a maquina 
.................... void tela_iniciando_maquina (void); //tela que aparece quando a maquina esta iniciando 
.................... void tela_movimentando_maquina (int posicao); //tela de movimentacao que aparece na maquina 2 
.................... void tela_esperando_mov_maquina(void); //tela esperando movimentacao da maquina 
.................... void tela_esperando_mov_outra_maquina (int posicao); //tela de espera de movimentacao da maquina 1 
.................... void tela_esperando_sair_posicao_outra_maquina(void); //tela de espera a outra maquina sair da posicao atual 
....................  
.................... void tela_principal(void); //tela principal 
.................... void tela_seleciona_maquina(void); // tela de selecao maquina 1 ou maquina 2 
.................... void tela_manutencao_outra_maquina(void); //tela de manutencao na outra maquina 
.................... void tela_edita_modelo (void); //tela que escolhe entre edicao e exclusao do modelo escolhido 
.................... void tela_seleciona_debug(void); //tela de selecao de debug: manutencao ou pontos 
.................... void tela_edita_pontos_no_modelo(void); //tela de edicao dos pontos no modelo 
.................... void tela_excluir_modelo(void); //tela que pergunta se voce quer realmente exlcuir o modelo 
.................... void tela_seleciona_pontos(void); //tela de escolha do ponto a ser editado 
.................... void tela_dados_ponto (void); //tela que mostra todos os dados do respectivo ponto da placa 
.................... void tela_dados_ponto_2 (void); //tela que mostra todos os dados do respectivo ponto da placa 
....................  
.................... void tela_faltaSolda(void); //tela que mostra a necessidade de verificacao dos alimentados de solda 
....................  
.................... void tela_seleciona_manutencao (void); //tela que mostra as opcoes sensores de entrada e atuadores de saida 
.................... void tela_debug_entrada_1 (void); //tela 1 de sensores da maquina 
.................... void tela_debug_entrada_2 (void); //tela 2 de sensores da maquina 
.................... void tela_debug_entrada_3 (void); //tela 3 de sensores da maquina 
.................... void tela_debug_saida_1(void); //tela que podemos acionar a esteira, pinos de entrada, e o alimentador de placa 
.................... void tela_debug_saida_2(void); //tela que podemos acionar o pressor da placa, pinos de saida e dispensador de placa 
.................... void tela_debug_saida_3(void); //tela que podemos acionar os alimentadores de solda, limpar os bicos e acionar os ferros 
.................... void tela_debug_saida_4(void); //tela que podemos realizar a movimentacao do eixo x, y, z e o flip individualmenta 
....................  
....................  
.................... void tela_programa_principal(void);//tela que aparece quando estamos no programa principal 
....................  
....................  
.................... void tela_apresentacao(){ 
....................     printf(lcd_putc, "\f"); //limpa display 
*
02DA6:  MOVLW  0C
02DA8:  MOVLB  5
02DAA:  MOVWF  x86
02DAC:  MOVLB  0
02DAE:  RCALL  2D32
....................     printf(lcd_putc, "        ICTS        \n\r"); 
02DB0:  MOVLW  02
02DB2:  MOVWF  FF6
02DB4:  MOVLW  01
02DB6:  MOVWF  FF7
02DB8:  RCALL  2D86
....................     printf(lcd_putc, "  INSTITUTO CENTRO  \n\r"); 
02DBA:  MOVLW  1A
02DBC:  MOVWF  FF6
02DBE:  MOVLW  01
02DC0:  MOVWF  FF7
02DC2:  RCALL  2D86
....................     printf(lcd_putc, "    TECNOLOGIA EM   \n\r"); 
02DC4:  MOVLW  32
02DC6:  MOVWF  FF6
02DC8:  MOVLW  01
02DCA:  MOVWF  FF7
02DCC:  RCALL  2D86
....................     printf(lcd_putc, "      SOFTWARE      \n\r"); 
02DCE:  MOVLW  4A
02DD0:  MOVWF  FF6
02DD2:  MOVLW  01
02DD4:  MOVWF  FF7
02DD6:  RCALL  2D86
02DD8:  GOTO   D7CA (RETURN)
.................... } 
.................... void tela_iniciando_maquina(){ 
....................     printf(lcd_putc, "\f"); //limpa display 
*
02F02:  MOVLW  0C
02F04:  MOVLB  5
02F06:  MOVWF  x86
02F08:  MOVLB  0
02F0A:  RCALL  2D32
....................     printf(lcd_putc, "     INICIANDO     \n\r"); 
02F0C:  MOVLW  62
02F0E:  MOVWF  FF6
02F10:  MOVLW  01
02F12:  MOVWF  FF7
02F14:  RCALL  2D86
....................     printf(lcd_putc, "      BANDEJAS     \n\r"); 
02F16:  MOVLW  78
02F18:  MOVWF  FF6
02F1A:  MOVLW  01
02F1C:  MOVWF  FF7
02F1E:  RCALL  2D86
02F20:  GOTO   D7D2 (RETURN)
.................... } 
.................... void tela_movimentando_maquina (int posicao) { 
....................     switch (posicao){ 
*
047E8:  MOVLB  5
047EA:  MOVF   x79,W
047EC:  ADDLW  FA
047EE:  BTFSC  FD8.0
047F0:  BRA    4900
047F2:  ADDLW  06
047F4:  MOVLB  0
047F6:  GOTO   4904
....................         case ALIMENTADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
047FA:  MOVLW  0C
047FC:  MOVLB  5
047FE:  MOVWF  x86
04800:  MOVLB  0
04802:  CALL   2D32
....................             printf(lcd_putc, "MOVIMENTANDO BANDEJA\n\r"); 
04806:  MOVLW  8E
04808:  MOVWF  FF6
0480A:  MOVLW  01
0480C:  MOVWF  FF7
0480E:  CALL   2D86
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
04812:  MOVLW  A6
04814:  MOVWF  FF6
04816:  MOVLW  01
04818:  MOVWF  FF7
0481A:  CALL   2D86
....................             printf(lcd_putc, "     ALIMENTADOR    \n\r"); 
0481E:  MOVLW  BE
04820:  MOVWF  FF6
04822:  MOVLW  01
04824:  MOVWF  FF7
04826:  CALL   2D86
....................         break; 
0482A:  MOVLB  5
0482C:  BRA    4900
....................         case HOME1: 
....................             printf(lcd_putc, "\f"); //limpa display 
0482E:  MOVLW  0C
04830:  MOVLB  5
04832:  MOVWF  x86
04834:  MOVLB  0
04836:  CALL   2D32
....................             printf(lcd_putc, "MOVIMENTANDO BANDEJA\n\r"); 
0483A:  MOVLW  D6
0483C:  MOVWF  FF6
0483E:  MOVLW  01
04840:  MOVWF  FF7
04842:  CALL   2D86
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
04846:  MOVLW  EE
04848:  MOVWF  FF6
0484A:  MOVLW  01
0484C:  MOVWF  FF7
0484E:  CALL   2D86
....................             printf(lcd_putc, "       HOME 1       \n\r"); 
04852:  MOVLW  06
04854:  MOVWF  FF6
04856:  MOVLW  02
04858:  MOVWF  FF7
0485A:  CALL   2D86
....................         break; 
0485E:  MOVLB  5
04860:  BRA    4900
....................         case SOLDAGEM: 
....................             printf(lcd_putc, "\f"); //limpa display 
04862:  MOVLW  0C
04864:  MOVLB  5
04866:  MOVWF  x86
04868:  MOVLB  0
0486A:  CALL   2D32
....................             printf(lcd_putc, "MOVIMENTANDO BANDEJA\n\r"); 
0486E:  MOVLW  1E
04870:  MOVWF  FF6
04872:  MOVLW  02
04874:  MOVWF  FF7
04876:  CALL   2D86
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
0487A:  MOVLW  36
0487C:  MOVWF  FF6
0487E:  MOVLW  02
04880:  MOVWF  FF7
04882:  CALL   2D86
....................             printf(lcd_putc, "      SOLDAGEM     \n\r"); 
04886:  MOVLW  4E
04888:  MOVWF  FF6
0488A:  MOVLW  02
0488C:  MOVWF  FF7
0488E:  CALL   2D86
....................         break; 
04892:  MOVLB  5
04894:  BRA    4900
....................         case HOME2: 
....................             printf(lcd_putc, "\f"); //limpa display 
04896:  MOVLW  0C
04898:  MOVLB  5
0489A:  MOVWF  x86
0489C:  MOVLB  0
0489E:  CALL   2D32
....................             printf(lcd_putc, "MOVIMENTANDO BANDEJA\n\r"); 
048A2:  MOVLW  64
048A4:  MOVWF  FF6
048A6:  MOVLW  02
048A8:  MOVWF  FF7
048AA:  CALL   2D86
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
048AE:  MOVLW  7C
048B0:  MOVWF  FF6
048B2:  MOVLW  02
048B4:  MOVWF  FF7
048B6:  CALL   2D86
....................             printf(lcd_putc, "       HOME 2       \n\r"); 
048BA:  MOVLW  94
048BC:  MOVWF  FF6
048BE:  MOVLW  02
048C0:  MOVWF  FF7
048C2:  CALL   2D86
....................         break; 
048C6:  MOVLB  5
048C8:  BRA    4900
....................         case DISPENSADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
048CA:  MOVLW  0C
048CC:  MOVLB  5
048CE:  MOVWF  x86
048D0:  MOVLB  0
048D2:  CALL   2D32
....................             printf(lcd_putc, "MOVIMENTANDO BANDEJA\n\r"); 
048D6:  MOVLW  AC
048D8:  MOVWF  FF6
048DA:  MOVLW  02
048DC:  MOVWF  FF7
048DE:  CALL   2D86
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
048E2:  MOVLW  C4
048E4:  MOVWF  FF6
048E6:  MOVLW  02
048E8:  MOVWF  FF7
048EA:  CALL   2D86
....................             printf(lcd_putc, "    DISPENSADOR     \n\r"); 
048EE:  MOVLW  DC
048F0:  MOVWF  FF6
048F2:  MOVLW  02
048F4:  MOVWF  FF7
048F6:  CALL   2D86
....................         break; 
048FA:  MOVLB  5
048FC:  BRA    4900
048FE:  MOVLB  5
....................     } 
04900:  MOVLB  0
04902:  RETURN 0
.................... } 
.................... void tela_esperando_mov_maquina(void) { 
....................     printf(lcd_putc, "\f"); //limpa display 
*
05536:  MOVLW  0C
05538:  MOVLB  5
0553A:  MOVWF  x86
0553C:  MOVLB  0
0553E:  CALL   2D32
....................     printf(lcd_putc, "  ESPERANDO BANDEJA \n\r"); 
05542:  MOVLW  F4
05544:  MOVWF  FF6
05546:  MOVLW  02
05548:  MOVWF  FF7
0554A:  CALL   2D86
....................     printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
0554E:  MOVLW  0C
05550:  MOVWF  FF6
05552:  MOVLW  03
05554:  MOVWF  FF7
05556:  CALL   2D86
....................     printf(lcd_putc, "    PRE-REQUISITO   \n\r"); 
0555A:  MOVLW  24
0555C:  MOVWF  FF6
0555E:  MOVLW  03
05560:  MOVWF  FF7
05562:  CALL   2D86
05566:  RETURN 0
.................... } 
.................... void tela_esperando_mov_outra_maquina(int posicao) { 
....................     switch (posicao){ 
....................         case ALIMENTADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
....................             printf(lcd_putc, "       BANDEJA      \n\r"); 
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
....................             printf(lcd_putc, "     ALIMENTADOR    \n\r"); 
....................         case HOME1: 
....................             printf(lcd_putc, "\f"); //limpa display 
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
....................             printf(lcd_putc, "       BANDEJA      \n\r"); 
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
....................             printf(lcd_putc, "       HOME 1       \n\r"); 
....................         break; 
....................         case SOLDAGEM: 
....................             printf(lcd_putc, "\f"); //limpa display 
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
....................             printf(lcd_putc, "       BANDEJA      \n\r"); 
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
....................             printf(lcd_putc, "     SOLDAGEM 1     \n\r"); 
....................         break; 
....................         case HOME2: 
....................             printf(lcd_putc, "\f"); //limpa display 
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
....................             printf(lcd_putc, "       BANDEJA      \n\r"); 
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
....................             printf(lcd_putc, "       HOME 2       \n\r"); 
....................         break; 
....................         case DISPENSADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
....................             printf(lcd_putc, "       BANDEJA      \n\r"); 
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
....................             printf(lcd_putc, "     DISPENSADOR    \n\r"); 
....................         break; 
....................     } 
.................... } 
.................... void tela_esperando_sair_posicao_outra_maquina(void){ 
....................     printf(lcd_putc, "\f"); //limpa display 
05568:  MOVLW  0C
0556A:  MOVLB  5
0556C:  MOVWF  x86
0556E:  MOVLB  0
05570:  CALL   2D32
....................     printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
05574:  MOVLW  1C
05576:  MOVWF  FF6
05578:  MOVLW  05
0557A:  MOVWF  FF7
0557C:  CALL   2D86
....................     printf(lcd_putc, "       BANDEJA      \n\r"); 
05580:  MOVLW  34
05582:  MOVWF  FF6
05584:  MOVLW  05
05586:  MOVWF  FF7
05588:  CALL   2D86
....................     printf(lcd_putc, "   SAIR DA POSICAO  \n\r"); 
0558C:  MOVLW  4C
0558E:  MOVWF  FF6
05590:  MOVLW  05
05592:  MOVWF  FF7
05594:  CALL   2D86
....................     printf(lcd_putc, "        ATUAL       \n\r"); 
05598:  MOVLW  64
0559A:  MOVWF  FF6
0559C:  MOVLW  05
0559E:  MOVWF  FF7
055A0:  CALL   2D86
055A4:  RETURN 0
.................... } 
....................  
.................... void tela_principal() { 
....................     printf(lcd_putc, "\f"); // limpa display 
*
063D4:  MOVLW  0C
063D6:  MOVLB  5
063D8:  MOVWF  x86
063DA:  MOVLB  0
063DC:  CALL   2D32
....................     printf(lcd_putc, " SOLDADOR AUTOMATICO\n\r"); 
063E0:  MOVLW  7C
063E2:  MOVWF  FF6
063E4:  MOVLW  05
063E6:  MOVWF  FF7
063E8:  CALL   2D86
....................     printf(lcd_putc, "      MODELO:%02u   \n\r",modelo); 
063EC:  MOVLW  94
063EE:  MOVWF  FF6
063F0:  MOVLW  05
063F2:  MOVWF  FF7
063F4:  MOVLW  0D
063F6:  MOVLB  5
063F8:  MOVWF  x7D
063FA:  MOVLB  0
063FC:  RCALL  62FC
063FE:  MOVFF  2F,57D
06402:  MOVLW  01
06404:  MOVLB  5
06406:  MOVWF  x7E
06408:  MOVLB  0
0640A:  RCALL  6352
0640C:  MOVLW  A5
0640E:  MOVWF  FF6
06410:  MOVLW  05
06412:  MOVWF  FF7
06414:  MOVLW  05
06416:  MOVLB  5
06418:  MOVWF  x7D
0641A:  MOVLB  0
0641C:  RCALL  62FC
....................     printf(lcd_putc, "     MENU:EDITAR    \n\r"); 
0641E:  MOVLW  AC
06420:  MOVWF  FF6
06422:  MOVLW  05
06424:  MOVWF  FF7
06426:  CALL   2D86
....................     printf(lcd_putc, "  ENTER:AUTOMATICO  \n\r"); 
0642A:  MOVLW  C4
0642C:  MOVWF  FF6
0642E:  MOVLW  05
06430:  MOVWF  FF7
06432:  CALL   2D86
06436:  RETURN 0
.................... } 
.................... void tela_seleciona_maquina(){ 
....................     printf(lcd_putc, "\f"); 
*
06C46:  MOVLW  0C
06C48:  MOVLB  5
06C4A:  MOVWF  x86
06C4C:  MOVLB  0
06C4E:  CALL   2D32
....................     printf(lcd_putc, " SELECIONE A BANDEJA\n\r"); 
06C52:  MOVLW  DC
06C54:  MOVWF  FF6
06C56:  MOVLW  05
06C58:  MOVWF  FF7
06C5A:  CALL   2D86
....................     printf(lcd_putc, "    F1: BANDEJA 1   \n\r"); 
06C5E:  MOVLW  F4
06C60:  MOVWF  FF6
06C62:  MOVLW  05
06C64:  MOVWF  FF7
06C66:  CALL   2D86
....................     printf(lcd_putc, "    F2: BANDEJA 2   \n\r"); 
06C6A:  MOVLW  0C
06C6C:  MOVWF  FF6
06C6E:  MOVLW  06
06C70:  MOVWF  FF7
06C72:  CALL   2D86
....................     printf(lcd_putc, "    ESC:BACK        \n\r"); 
06C76:  MOVLW  24
06C78:  MOVWF  FF6
06C7A:  MOVLW  06
06C7C:  MOVWF  FF7
06C7E:  CALL   2D86
06C82:  RETURN 0
.................... } 
.................... void tela_manutencao_outra_maquina() { 
....................     printf(lcd_putc, "\f"); // limpa display 
*
06D82:  MOVLW  0C
06D84:  MOVLB  5
06D86:  MOVWF  x86
06D88:  MOVLB  0
06D8A:  CALL   2D32
....................     printf(lcd_putc, "     MANUTENCAO     \n\r"); 
06D8E:  MOVLW  3C
06D90:  MOVWF  FF6
06D92:  MOVLW  06
06D94:  MOVWF  FF7
06D96:  CALL   2D86
....................     printf(lcd_putc, "      BANDEJA 2     \n\r"); 
06D9A:  MOVLW  54
06D9C:  MOVWF  FF6
06D9E:  MOVLW  06
06DA0:  MOVWF  FF7
06DA2:  CALL   2D86
....................     printf(lcd_putc, "                    \n\r"); 
06DA6:  MOVLW  6C
06DA8:  MOVWF  FF6
06DAA:  MOVLW  06
06DAC:  MOVWF  FF7
06DAE:  CALL   2D86
....................     printf(lcd_putc, "      ESC:BACK      \n\r"); 
06DB2:  MOVLW  84
06DB4:  MOVWF  FF6
06DB6:  MOVLW  06
06DB8:  MOVWF  FF7
06DBA:  CALL   2D86
06DBE:  RETURN 0
.................... } 
.................... void tela_edita_modelo(){ 
....................     printf(lcd_putc, "\f"); 
06DC0:  MOVLW  0C
06DC2:  MOVLB  5
06DC4:  MOVWF  x86
06DC6:  MOVLB  0
06DC8:  CALL   2D32
....................     printf(lcd_putc, "    ESCOLHER ACAO   \n\r"); 
06DCC:  MOVLW  9C
06DCE:  MOVWF  FF6
06DD0:  MOVLW  06
06DD2:  MOVWF  FF7
06DD4:  CALL   2D86
....................     printf(lcd_putc, "F1:EDITAR/MANUTENCAO\n\r"); 
06DD8:  MOVLW  B4
06DDA:  MOVWF  FF6
06DDC:  MOVLW  06
06DDE:  MOVWF  FF7
06DE0:  CALL   2D86
....................     printf(lcd_putc, "F2:EXCLUI MODELO  \n\r"); 
06DE4:  MOVLW  CC
06DE6:  MOVWF  FF6
06DE8:  MOVLW  06
06DEA:  MOVWF  FF7
06DEC:  CALL   2D86
....................     printf(lcd_putc, "ESC:BACK          \n\r"); 
06DF0:  MOVLW  E2
06DF2:  MOVWF  FF6
06DF4:  MOVLW  06
06DF6:  MOVWF  FF7
06DF8:  CALL   2D86
06DFC:  RETURN 0
.................... } 
.................... void tela_seleciona_debug(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
06EAE:  MOVLW  0C
06EB0:  MOVLB  5
06EB2:  MOVWF  x86
06EB4:  MOVLB  0
06EB6:  CALL   2D32
....................     printf(lcd_putc, "  F1: EDITAR PONTOS \n\r"); 
06EBA:  MOVLW  F8
06EBC:  MOVWF  FF6
06EBE:  MOVLW  06
06EC0:  MOVWF  FF7
06EC2:  CALL   2D86
....................     printf(lcd_putc, "  F2: MANUTENCAO    \n\r"); 
06EC6:  MOVLW  10
06EC8:  MOVWF  FF6
06ECA:  MOVLW  07
06ECC:  MOVWF  FF7
06ECE:  CALL   2D86
....................     printf(lcd_putc, "\n\r"); 
06ED2:  MOVLW  0A
06ED4:  MOVLB  5
06ED6:  MOVWF  x86
06ED8:  MOVLB  0
06EDA:  CALL   2D32
06EDE:  MOVLW  0D
06EE0:  MOVLB  5
06EE2:  MOVWF  x86
06EE4:  MOVLB  0
06EE6:  CALL   2D32
....................     printf(lcd_putc, "  ESC:BACK          \n\r"); 
06EEA:  MOVLW  28
06EEC:  MOVWF  FF6
06EEE:  MOVLW  07
06EF0:  MOVWF  FF7
06EF2:  CALL   2D86
06EF6:  RETURN 0
.................... } 
.................... void tela_seleciona_debug_2(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
06F72:  MOVLW  0C
06F74:  MOVLB  5
06F76:  MOVWF  x86
06F78:  MOVLB  0
06F7A:  CALL   2D32
....................     printf(lcd_putc, "   F1: N PONTOS     \n\r"); 
06F7E:  MOVLW  40
06F80:  MOVWF  FF6
06F82:  MOVLW  07
06F84:  MOVWF  FF7
06F86:  CALL   2D86
....................     printf(lcd_putc, "  F2: EDITAR PONTOS \n\r"); 
06F8A:  MOVLW  58
06F8C:  MOVWF  FF6
06F8E:  MOVLW  07
06F90:  MOVWF  FF7
06F92:  CALL   2D86
....................     printf(lcd_putc, "\n\r"); 
06F96:  MOVLW  0A
06F98:  MOVLB  5
06F9A:  MOVWF  x86
06F9C:  MOVLB  0
06F9E:  CALL   2D32
06FA2:  MOVLW  0D
06FA4:  MOVLB  5
06FA6:  MOVWF  x86
06FA8:  MOVLB  0
06FAA:  CALL   2D32
....................     printf(lcd_putc, "  ESC:BACK          \n\r"); 
06FAE:  MOVLW  70
06FB0:  MOVWF  FF6
06FB2:  MOVLW  07
06FB4:  MOVWF  FF7
06FB6:  CALL   2D86
06FBA:  RETURN 0
.................... } 
.................... void tela_edita_pontos_no_modelo(){ 
....................     printf(lcd_putc, "\f"); 
*
070E6:  MOVLW  0C
070E8:  MOVLB  5
070EA:  MOVWF  x86
070EC:  MOVLB  0
070EE:  CALL   2D32
....................     printf(lcd_putc, "  NUMERO DE PONTOS  \n\r"); 
070F2:  MOVLW  88
070F4:  MOVWF  FF6
070F6:  MOVLW  07
070F8:  MOVWF  FF7
070FA:  CALL   2D86
....................     printf(lcd_putc, "       %04Lu       \n\r",pontos_no_modelo); 
070FE:  MOVLW  A0
07100:  MOVWF  FF6
07102:  MOVLW  07
07104:  MOVWF  FF7
07106:  MOVLW  07
07108:  MOVLB  5
0710A:  MOVWF  x7D
0710C:  MOVLB  0
0710E:  CALL   62FC
07112:  MOVLW  09
07114:  MOVWF  FE9
07116:  MOVFF  12D,57E
0711A:  MOVFF  12C,57D
0711E:  RCALL  7028
07120:  MOVLW  AC
07122:  MOVWF  FF6
07124:  MOVLW  07
07126:  MOVWF  FF7
07128:  MOVLW  09
0712A:  MOVLB  5
0712C:  MOVWF  x7D
0712E:  MOVLB  0
07130:  CALL   62FC
....................     printf(lcd_putc, " ENTER:SAVE|ESC:BACK\n\r"); 
07134:  MOVLW  B6
07136:  MOVWF  FF6
07138:  MOVLW  07
0713A:  MOVWF  FF7
0713C:  CALL   2D86
07140:  RETURN 0
.................... } 
.................... void tela_excluir_modelo(){ 
....................     printf(lcd_putc, "\f"); 
*
06EF8:  MOVLW  0C
06EFA:  MOVLB  5
06EFC:  MOVWF  x86
06EFE:  MOVLB  0
06F00:  CALL   2D32
....................     printf(lcd_putc, "   DESEJA EXCLUIR   \n\r"); 
06F04:  MOVLW  CE
06F06:  MOVWF  FF6
06F08:  MOVLW  07
06F0A:  MOVWF  FF7
06F0C:  CALL   2D86
....................     printf(lcd_putc, "     O MODELO ?     \n\r"); 
06F10:  MOVLW  E6
06F12:  MOVWF  FF6
06F14:  MOVLW  07
06F16:  MOVWF  FF7
06F18:  CALL   2D86
....................     printf(lcd_putc, "      ENTER:OK      \n\r"); 
06F1C:  MOVLW  FE
06F1E:  MOVWF  FF6
06F20:  MOVLW  07
06F22:  MOVWF  FF7
06F24:  CALL   2D86
....................     printf(lcd_putc, "      ESC:BACK     \n\r"); 
06F28:  MOVLW  16
06F2A:  MOVWF  FF6
06F2C:  MOVLW  08
06F2E:  MOVWF  FF7
06F30:  CALL   2D86
06F34:  GOTO   6F6E (RETURN)
.................... } 
.................... void tela_seleciona_pontos(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0727A:  MOVLW  0C
0727C:  MOVLB  5
0727E:  MOVWF  x86
07280:  MOVLB  0
07282:  CALL   2D32
....................     printf(lcd_putc, "P%02u         ENT:EDIT\n\r",inicial_lcd); 
07286:  MOVLW  50
07288:  MOVLB  5
0728A:  MOVWF  x86
0728C:  MOVLB  0
0728E:  CALL   2D32
07292:  MOVFF  22,57D
07296:  MOVLW  01
07298:  MOVLB  5
0729A:  MOVWF  x7E
0729C:  MOVLB  0
0729E:  CALL   6352
072A2:  MOVLW  31
072A4:  MOVWF  FF6
072A6:  MOVLW  08
072A8:  MOVWF  FF7
072AA:  MOVLW  13
072AC:  MOVLB  5
072AE:  MOVWF  x7D
072B0:  MOVLB  0
072B2:  CALL   62FC
....................     printf(lcd_putc, "P%02u         ESC:BACK\n\r",inicial_lcd+1); 
072B6:  MOVLW  01
072B8:  ADDWF  22,W
072BA:  MOVLB  5
072BC:  MOVWF  x76
072BE:  MOVLW  50
072C0:  MOVWF  x86
072C2:  MOVLB  0
072C4:  CALL   2D32
072C8:  MOVFF  576,57D
072CC:  MOVLW  01
072CE:  MOVLB  5
072D0:  MOVWF  x7E
072D2:  MOVLB  0
072D4:  CALL   6352
072D8:  MOVLW  4B
072DA:  MOVWF  FF6
072DC:  MOVLW  08
072DE:  MOVWF  FF7
072E0:  MOVLW  13
072E2:  MOVLB  5
072E4:  MOVWF  x7D
072E6:  MOVLB  0
072E8:  CALL   62FC
....................     printf(lcd_putc, "P%02u                 \n\r",inicial_lcd+2); 
072EC:  MOVLW  02
072EE:  ADDWF  22,W
072F0:  MOVLB  5
072F2:  MOVWF  x76
072F4:  MOVLW  50
072F6:  MOVWF  x86
072F8:  MOVLB  0
072FA:  CALL   2D32
072FE:  MOVFF  576,57D
07302:  MOVLW  01
07304:  MOVLB  5
07306:  MOVWF  x7E
07308:  MOVLB  0
0730A:  CALL   6352
0730E:  MOVLW  65
07310:  MOVWF  FF6
07312:  MOVLW  08
07314:  MOVWF  FF7
07316:  MOVLW  13
07318:  MOVLB  5
0731A:  MOVWF  x7D
0731C:  MOVLB  0
0731E:  CALL   62FC
....................     printf(lcd_putc, "P%02u                 \n\r",inicial_lcd+3); 
07322:  MOVLW  03
07324:  ADDWF  22,W
07326:  MOVLB  5
07328:  MOVWF  x76
0732A:  MOVLW  50
0732C:  MOVWF  x86
0732E:  MOVLB  0
07330:  CALL   2D32
07334:  MOVFF  576,57D
07338:  MOVLW  01
0733A:  MOVLB  5
0733C:  MOVWF  x7E
0733E:  MOVLB  0
07340:  CALL   6352
07344:  MOVLW  7F
07346:  MOVWF  FF6
07348:  MOVLW  08
0734A:  MOVWF  FF7
0734C:  MOVLW  13
0734E:  MOVLB  5
07350:  MOVWF  x7D
07352:  MOVLB  0
07354:  CALL   62FC
....................     posiciona_cursor(ponteiro_lcd,5); 
07358:  MOVFF  21,587
0735C:  MOVLW  05
0735E:  MOVLB  5
07360:  MOVWF  x88
07362:  MOVLB  0
07364:  CALL   2B84
....................     printf(lcd_putc,"<"); 
07368:  MOVLW  3C
0736A:  MOVLB  5
0736C:  MOVWF  x86
0736E:  MOVLB  0
07370:  CALL   2D32
07374:  RETURN 0
.................... } 
.................... void tela_dados_ponto (contador_lcd){ 
....................     printf(lcd_putc, "\f"); // limpa display 
07376:  MOVLW  0C
07378:  MOVLB  5
0737A:  MOVWF  x86
0737C:  MOVLB  0
0737E:  CALL   2D32
....................     printf(lcd_putc, "X:%04Lu T:%04Lu\n\r",x[contador_lcd],tipo[contador_lcd]); 
07382:  BCF    FD8.0
07384:  MOVLB  5
07386:  RLCF   x76,W
07388:  CLRF   03
0738A:  ADDLW  30
0738C:  MOVWF  FE9
0738E:  MOVLW  00
07390:  ADDWFC 03,W
07392:  MOVWF  FEA
07394:  MOVFF  FEC,578
07398:  MOVF   FED,F
0739A:  MOVFF  FEF,577
0739E:  BCF    FD8.0
073A0:  RLCF   x76,W
073A2:  CLRF   03
073A4:  ADDLW  02
073A6:  MOVWF  FE9
073A8:  MOVLW  01
073AA:  ADDWFC 03,W
073AC:  MOVWF  FEA
073AE:  MOVFF  FEC,57A
073B2:  MOVF   FED,F
073B4:  MOVFF  FEF,579
073B8:  MOVLW  58
073BA:  MOVWF  x86
073BC:  MOVLB  0
073BE:  CALL   2D32
073C2:  MOVLW  3A
073C4:  MOVLB  5
073C6:  MOVWF  x86
073C8:  MOVLB  0
073CA:  CALL   2D32
073CE:  MOVLW  09
073D0:  MOVWF  FE9
073D2:  MOVFF  578,57E
073D6:  MOVFF  577,57D
073DA:  RCALL  7028
073DC:  MOVLW  9B
073DE:  MOVWF  FF6
073E0:  MOVLW  08
073E2:  MOVWF  FF7
073E4:  MOVLW  03
073E6:  MOVLB  5
073E8:  MOVWF  x7D
073EA:  MOVLB  0
073EC:  CALL   62FC
073F0:  MOVLW  09
073F2:  MOVWF  FE9
073F4:  MOVFF  57A,57E
073F8:  MOVFF  579,57D
073FC:  RCALL  7028
073FE:  MOVLW  0A
07400:  MOVLB  5
07402:  MOVWF  x86
07404:  MOVLB  0
07406:  CALL   2D32
0740A:  MOVLW  0D
0740C:  MOVLB  5
0740E:  MOVWF  x86
07410:  MOVLB  0
07412:  CALL   2D32
....................     printf(lcd_putc, "Y:%04Lu H:%04Lu F:%04Lu\n\r",y[contador_lcd],habilitado[contador_lcd],numeroFerros[contador_lcd]); 
07416:  BCF    FD8.0
07418:  MOVLB  5
0741A:  RLCF   x76,W
0741C:  CLRF   03
0741E:  ADDLW  5A
07420:  MOVWF  FE9
07422:  MOVLW  00
07424:  ADDWFC 03,W
07426:  MOVWF  FEA
07428:  MOVFF  FEC,578
0742C:  MOVF   FED,F
0742E:  MOVFF  FEF,577
07432:  BCF    FD8.0
07434:  RLCF   x76,W
07436:  CLRF   03
07438:  ADDLW  2E
0743A:  MOVWF  FE9
0743C:  MOVLW  01
0743E:  ADDWFC 03,W
07440:  MOVWF  FEA
07442:  MOVFF  FEC,57A
07446:  MOVF   FED,F
07448:  MOVFF  FEF,579
0744C:  BCF    FD8.0
0744E:  RLCF   x76,W
07450:  CLRF   03
07452:  ADDLW  58
07454:  MOVWF  FE9
07456:  MOVLW  01
07458:  ADDWFC 03,W
0745A:  MOVWF  FEA
0745C:  MOVFF  FEC,57C
07460:  MOVF   FED,F
07462:  MOVFF  FEF,57B
07466:  MOVLW  59
07468:  MOVWF  x86
0746A:  MOVLB  0
0746C:  CALL   2D32
07470:  MOVLW  3A
07472:  MOVLB  5
07474:  MOVWF  x86
07476:  MOVLB  0
07478:  CALL   2D32
0747C:  MOVLW  09
0747E:  MOVWF  FE9
07480:  MOVFF  578,57E
07484:  MOVFF  577,57D
07488:  RCALL  7028
0748A:  MOVLW  AD
0748C:  MOVWF  FF6
0748E:  MOVLW  08
07490:  MOVWF  FF7
07492:  MOVLW  03
07494:  MOVLB  5
07496:  MOVWF  x7D
07498:  MOVLB  0
0749A:  CALL   62FC
0749E:  MOVLW  09
074A0:  MOVWF  FE9
074A2:  MOVFF  57A,57E
074A6:  MOVFF  579,57D
074AA:  RCALL  7028
074AC:  MOVLW  B5
074AE:  MOVWF  FF6
074B0:  MOVLW  08
074B2:  MOVWF  FF7
074B4:  MOVLW  03
074B6:  MOVLB  5
074B8:  MOVWF  x7D
074BA:  MOVLB  0
074BC:  CALL   62FC
074C0:  MOVLW  09
074C2:  MOVWF  FE9
074C4:  MOVFF  57C,57E
074C8:  MOVFF  57B,57D
074CC:  RCALL  7028
074CE:  MOVLW  0A
074D0:  MOVLB  5
074D2:  MOVWF  x86
074D4:  MOVLB  0
074D6:  CALL   2D32
074DA:  MOVLW  0D
074DC:  MOVLB  5
074DE:  MOVWF  x86
074E0:  MOVLB  0
074E2:  CALL   2D32
....................     printf(lcd_putc, "Z:%04Lu I:%02u L:%04Lu\n\r",z[contador_lcd],incremento,limpar[contador_lcd]); 
074E6:  BCF    FD8.0
074E8:  MOVLB  5
074EA:  RLCF   x76,W
074EC:  CLRF   03
074EE:  ADDLW  84
074F0:  MOVWF  FE9
074F2:  MOVLW  00
074F4:  ADDWFC 03,W
074F6:  MOVWF  FEA
074F8:  MOVFF  FEC,578
074FC:  MOVF   FED,F
074FE:  MOVFF  FEF,577
07502:  BCF    FD8.0
07504:  RLCF   x76,W
07506:  CLRF   03
07508:  ADDLW  D6
0750A:  MOVWF  FE9
0750C:  MOVLW  01
0750E:  ADDWFC 03,W
07510:  MOVWF  FEA
07512:  MOVFF  FEC,57A
07516:  MOVF   FED,F
07518:  MOVFF  FEF,579
0751C:  MOVLW  5A
0751E:  MOVWF  x86
07520:  MOVLB  0
07522:  CALL   2D32
07526:  MOVLW  3A
07528:  MOVLB  5
0752A:  MOVWF  x86
0752C:  MOVLB  0
0752E:  CALL   2D32
07532:  MOVLW  09
07534:  MOVWF  FE9
07536:  MOVFF  578,57E
0753A:  MOVFF  577,57D
0753E:  RCALL  7028
07540:  MOVLW  C7
07542:  MOVWF  FF6
07544:  MOVLW  08
07546:  MOVWF  FF7
07548:  MOVLW  03
0754A:  MOVLB  5
0754C:  MOVWF  x7D
0754E:  MOVLB  0
07550:  CALL   62FC
07554:  MOVFF  25,57D
07558:  MOVLW  01
0755A:  MOVLB  5
0755C:  MOVWF  x7E
0755E:  MOVLB  0
07560:  CALL   6352
07564:  MOVLW  CE
07566:  MOVWF  FF6
07568:  MOVLW  08
0756A:  MOVWF  FF7
0756C:  MOVLW  03
0756E:  MOVLB  5
07570:  MOVWF  x7D
07572:  MOVLB  0
07574:  CALL   62FC
07578:  MOVLW  09
0757A:  MOVWF  FE9
0757C:  MOVFF  57A,57E
07580:  MOVFF  579,57D
07584:  RCALL  7028
07586:  MOVLW  0A
07588:  MOVLB  5
0758A:  MOVWF  x86
0758C:  MOVLB  0
0758E:  CALL   2D32
07592:  MOVLW  0D
07594:  MOVLB  5
07596:  MOVWF  x86
07598:  MOVLB  0
0759A:  CALL   2D32
....................     printf(lcd_putc, "F1:GRAVA|F3:PROX\n\r"); 
0759E:  MOVLW  DA
075A0:  MOVWF  FF6
075A2:  MOVLW  08
075A4:  MOVWF  FF7
075A6:  CALL   2D86
075AA:  RETURN 0
.................... }  
.................... void tela_dados_ponto_2 (contador_lcd){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
080F4:  MOVLW  0C
080F6:  MOVLB  5
080F8:  MOVWF  x86
080FA:  MOVLB  0
080FC:  CALL   2D32
....................     printf(lcd_putc, "S1:%04Lu\n\r",t_solda[contador_lcd]); 
08100:  BCF    FD8.0
08102:  MOVLB  5
08104:  RLCF   x76,W
08106:  CLRF   03
08108:  ADDLW  AE
0810A:  MOVWF  FE9
0810C:  MOVLW  00
0810E:  ADDWFC 03,W
08110:  MOVWF  FEA
08112:  MOVFF  FEC,578
08116:  MOVF   FED,F
08118:  MOVFF  FEF,577
0811C:  MOVLW  EE
0811E:  MOVWF  FF6
08120:  MOVLW  08
08122:  MOVWF  FF7
08124:  MOVLW  03
08126:  MOVWF  x7D
08128:  MOVLB  0
0812A:  CALL   62FC
0812E:  MOVLW  09
08130:  MOVWF  FE9
08132:  MOVFF  578,57E
08136:  MOVFF  577,57D
0813A:  CALL   7028
0813E:  MOVLW  0A
08140:  MOVLB  5
08142:  MOVWF  x86
08144:  MOVLB  0
08146:  CALL   2D32
0814A:  MOVLW  0D
0814C:  MOVLB  5
0814E:  MOVWF  x86
08150:  MOVLB  0
08152:  CALL   2D32
....................     printf(lcd_putc, "S2:%04Lu E:%04Lu\n\r",t_solda2[contador_lcd],t_wait[contador_lcd]); 
08156:  BCF    FD8.0
08158:  MOVLB  5
0815A:  RLCF   x76,W
0815C:  CLRF   03
0815E:  ADDLW  82
08160:  MOVWF  FE9
08162:  MOVLW  01
08164:  ADDWFC 03,W
08166:  MOVWF  FEA
08168:  MOVFF  FEC,578
0816C:  MOVF   FED,F
0816E:  MOVFF  FEF,577
08172:  BCF    FD8.0
08174:  RLCF   x76,W
08176:  CLRF   03
08178:  ADDLW  D8
0817A:  MOVWF  FE9
0817C:  MOVLW  00
0817E:  ADDWFC 03,W
08180:  MOVWF  FEA
08182:  MOVFF  FEC,57A
08186:  MOVF   FED,F
08188:  MOVFF  FEF,579
0818C:  MOVLW  FA
0818E:  MOVWF  FF6
08190:  MOVLW  08
08192:  MOVWF  FF7
08194:  MOVLW  03
08196:  MOVWF  x7D
08198:  MOVLB  0
0819A:  CALL   62FC
0819E:  MOVLW  09
081A0:  MOVWF  FE9
081A2:  MOVFF  578,57E
081A6:  MOVFF  577,57D
081AA:  CALL   7028
081AE:  MOVLW  02
081B0:  MOVWF  FF6
081B2:  MOVLW  09
081B4:  MOVWF  FF7
081B6:  MOVLW  03
081B8:  MOVLB  5
081BA:  MOVWF  x7D
081BC:  MOVLB  0
081BE:  CALL   62FC
081C2:  MOVLW  09
081C4:  MOVWF  FE9
081C6:  MOVFF  57A,57E
081CA:  MOVFF  579,57D
081CE:  CALL   7028
081D2:  MOVLW  0A
081D4:  MOVLB  5
081D6:  MOVWF  x86
081D8:  MOVLB  0
081DA:  CALL   2D32
081DE:  MOVLW  0D
081E0:  MOVLB  5
081E2:  MOVWF  x86
081E4:  MOVLB  0
081E6:  CALL   2D32
....................     printf(lcd_putc, "S3:%04Lu\n\r",t_solda3[contador_lcd]); 
081EA:  BCF    FD8.0
081EC:  MOVLB  5
081EE:  RLCF   x76,W
081F0:  CLRF   03
081F2:  ADDLW  AC
081F4:  MOVWF  FE9
081F6:  MOVLW  01
081F8:  ADDWFC 03,W
081FA:  MOVWF  FEA
081FC:  MOVFF  FEC,578
08200:  MOVF   FED,F
08202:  MOVFF  FEF,577
08206:  MOVLW  0E
08208:  MOVWF  FF6
0820A:  MOVLW  09
0820C:  MOVWF  FF7
0820E:  MOVLW  03
08210:  MOVWF  x7D
08212:  MOVLB  0
08214:  CALL   62FC
08218:  MOVLW  09
0821A:  MOVWF  FE9
0821C:  MOVFF  578,57E
08220:  MOVFF  577,57D
08224:  CALL   7028
08228:  MOVLW  0A
0822A:  MOVLB  5
0822C:  MOVWF  x86
0822E:  MOVLB  0
08230:  CALL   2D32
08234:  MOVLW  0D
08236:  MOVLB  5
08238:  MOVWF  x86
0823A:  MOVLB  0
0823C:  CALL   2D32
....................     printf(lcd_putc, "F1:REC|F3:BACK\n\r"); 
08240:  MOVLW  1A
08242:  MOVWF  FF6
08244:  MOVLW  09
08246:  MOVWF  FF7
08248:  CALL   2D86
0824C:  RETURN 0
.................... } 
.................... void tela_dados_ponto_3 (contador_lcd){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
07FD8:  MOVLW  0C
07FDA:  MOVLB  5
07FDC:  MOVWF  x86
07FDE:  MOVLB  0
07FE0:  CALL   2D32
....................     printf(lcd_putc, "\n\r"); 
07FE4:  MOVLW  0A
07FE6:  MOVLB  5
07FE8:  MOVWF  x86
07FEA:  MOVLB  0
07FEC:  CALL   2D32
07FF0:  MOVLW  0D
07FF2:  MOVLB  5
07FF4:  MOVWF  x86
07FF6:  MOVLB  0
07FF8:  CALL   2D32
....................     printf(lcd_putc, "S2:%04Lu E:%04Lu\n\r",t_solda2[contador_lcd],t_wait[contador_lcd]); 
07FFC:  BCF    FD8.0
07FFE:  MOVLB  5
08000:  RLCF   x76,W
08002:  CLRF   03
08004:  ADDLW  82
08006:  MOVWF  FE9
08008:  MOVLW  01
0800A:  ADDWFC 03,W
0800C:  MOVWF  FEA
0800E:  MOVFF  FEC,578
08012:  MOVF   FED,F
08014:  MOVFF  FEF,577
08018:  BCF    FD8.0
0801A:  RLCF   x76,W
0801C:  CLRF   03
0801E:  ADDLW  D8
08020:  MOVWF  FE9
08022:  MOVLW  00
08024:  ADDWFC 03,W
08026:  MOVWF  FEA
08028:  MOVFF  FEC,57A
0802C:  MOVF   FED,F
0802E:  MOVFF  FEF,579
08032:  MOVLW  2C
08034:  MOVWF  FF6
08036:  MOVLW  09
08038:  MOVWF  FF7
0803A:  MOVLW  03
0803C:  MOVWF  x7D
0803E:  MOVLB  0
08040:  CALL   62FC
08044:  MOVLW  09
08046:  MOVWF  FE9
08048:  MOVFF  578,57E
0804C:  MOVFF  577,57D
08050:  CALL   7028
08054:  MOVLW  34
08056:  MOVWF  FF6
08058:  MOVLW  09
0805A:  MOVWF  FF7
0805C:  MOVLW  03
0805E:  MOVLB  5
08060:  MOVWF  x7D
08062:  MOVLB  0
08064:  CALL   62FC
08068:  MOVLW  09
0806A:  MOVWF  FE9
0806C:  MOVFF  57A,57E
08070:  MOVFF  579,57D
08074:  CALL   7028
08078:  MOVLW  0A
0807A:  MOVLB  5
0807C:  MOVWF  x86
0807E:  MOVLB  0
08080:  CALL   2D32
08084:  MOVLW  0D
08086:  MOVLB  5
08088:  MOVWF  x86
0808A:  MOVLB  0
0808C:  CALL   2D32
....................     printf(lcd_putc, "S3:%04Lu\n\r",t_solda3[contador_lcd]); 
08090:  BCF    FD8.0
08092:  MOVLB  5
08094:  RLCF   x76,W
08096:  CLRF   03
08098:  ADDLW  AC
0809A:  MOVWF  FE9
0809C:  MOVLW  01
0809E:  ADDWFC 03,W
080A0:  MOVWF  FEA
080A2:  MOVFF  FEC,578
080A6:  MOVF   FED,F
080A8:  MOVFF  FEF,577
080AC:  MOVLW  40
080AE:  MOVWF  FF6
080B0:  MOVLW  09
080B2:  MOVWF  FF7
080B4:  MOVLW  03
080B6:  MOVWF  x7D
080B8:  MOVLB  0
080BA:  CALL   62FC
080BE:  MOVLW  09
080C0:  MOVWF  FE9
080C2:  MOVFF  578,57E
080C6:  MOVFF  577,57D
080CA:  CALL   7028
080CE:  MOVLW  0A
080D0:  MOVLB  5
080D2:  MOVWF  x86
080D4:  MOVLB  0
080D6:  CALL   2D32
080DA:  MOVLW  0D
080DC:  MOVLB  5
080DE:  MOVWF  x86
080E0:  MOVLB  0
080E2:  CALL   2D32
....................     printf(lcd_putc, "F1:REC|F3:BACK\n\r"); 
080E6:  MOVLW  4C
080E8:  MOVWF  FF6
080EA:  MOVLW  09
080EC:  MOVWF  FF7
080EE:  CALL   2D86
080F2:  RETURN 0
.................... } 
.................... void tela_dados_ponto_4 (contador_lcd){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
07EBC:  MOVLW  0C
07EBE:  MOVLB  5
07EC0:  MOVWF  x86
07EC2:  MOVLB  0
07EC4:  CALL   2D32
....................     printf(lcd_putc, "S1:%04Lu\n\r",t_solda[contador_lcd]); 
07EC8:  BCF    FD8.0
07ECA:  MOVLB  5
07ECC:  RLCF   x76,W
07ECE:  CLRF   03
07ED0:  ADDLW  AE
07ED2:  MOVWF  FE9
07ED4:  MOVLW  00
07ED6:  ADDWFC 03,W
07ED8:  MOVWF  FEA
07EDA:  MOVFF  FEC,578
07EDE:  MOVF   FED,F
07EE0:  MOVFF  FEF,577
07EE4:  MOVLW  5E
07EE6:  MOVWF  FF6
07EE8:  MOVLW  09
07EEA:  MOVWF  FF7
07EEC:  MOVLW  03
07EEE:  MOVWF  x7D
07EF0:  MOVLB  0
07EF2:  CALL   62FC
07EF6:  MOVLW  09
07EF8:  MOVWF  FE9
07EFA:  MOVFF  578,57E
07EFE:  MOVFF  577,57D
07F02:  CALL   7028
07F06:  MOVLW  0A
07F08:  MOVLB  5
07F0A:  MOVWF  x86
07F0C:  MOVLB  0
07F0E:  CALL   2D32
07F12:  MOVLW  0D
07F14:  MOVLB  5
07F16:  MOVWF  x86
07F18:  MOVLB  0
07F1A:  CALL   2D32
....................     printf(lcd_putc, "S2:%04Lu E:%04Lu\n\r",t_solda2[contador_lcd],t_wait[contador_lcd]); 
07F1E:  BCF    FD8.0
07F20:  MOVLB  5
07F22:  RLCF   x76,W
07F24:  CLRF   03
07F26:  ADDLW  82
07F28:  MOVWF  FE9
07F2A:  MOVLW  01
07F2C:  ADDWFC 03,W
07F2E:  MOVWF  FEA
07F30:  MOVFF  FEC,578
07F34:  MOVF   FED,F
07F36:  MOVFF  FEF,577
07F3A:  BCF    FD8.0
07F3C:  RLCF   x76,W
07F3E:  CLRF   03
07F40:  ADDLW  D8
07F42:  MOVWF  FE9
07F44:  MOVLW  00
07F46:  ADDWFC 03,W
07F48:  MOVWF  FEA
07F4A:  MOVFF  FEC,57A
07F4E:  MOVF   FED,F
07F50:  MOVFF  FEF,579
07F54:  MOVLW  6A
07F56:  MOVWF  FF6
07F58:  MOVLW  09
07F5A:  MOVWF  FF7
07F5C:  MOVLW  03
07F5E:  MOVWF  x7D
07F60:  MOVLB  0
07F62:  CALL   62FC
07F66:  MOVLW  09
07F68:  MOVWF  FE9
07F6A:  MOVFF  578,57E
07F6E:  MOVFF  577,57D
07F72:  CALL   7028
07F76:  MOVLW  72
07F78:  MOVWF  FF6
07F7A:  MOVLW  09
07F7C:  MOVWF  FF7
07F7E:  MOVLW  03
07F80:  MOVLB  5
07F82:  MOVWF  x7D
07F84:  MOVLB  0
07F86:  CALL   62FC
07F8A:  MOVLW  09
07F8C:  MOVWF  FE9
07F8E:  MOVFF  57A,57E
07F92:  MOVFF  579,57D
07F96:  CALL   7028
07F9A:  MOVLW  0A
07F9C:  MOVLB  5
07F9E:  MOVWF  x86
07FA0:  MOVLB  0
07FA2:  CALL   2D32
07FA6:  MOVLW  0D
07FA8:  MOVLB  5
07FAA:  MOVWF  x86
07FAC:  MOVLB  0
07FAE:  CALL   2D32
....................     printf(lcd_putc, "\n\r"); 
07FB2:  MOVLW  0A
07FB4:  MOVLB  5
07FB6:  MOVWF  x86
07FB8:  MOVLB  0
07FBA:  CALL   2D32
07FBE:  MOVLW  0D
07FC0:  MOVLB  5
07FC2:  MOVWF  x86
07FC4:  MOVLB  0
07FC6:  CALL   2D32
....................     printf(lcd_putc, "F1:REC|F3:BACK\n\r"); 
07FCA:  MOVLW  7E
07FCC:  MOVWF  FF6
07FCE:  MOVLW  09
07FD0:  MOVWF  FF7
07FD2:  CALL   2D86
07FD6:  RETURN 0
.................... } 
.................... void tela_dados_ponto_5 (contador_lcd){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
07DDE:  MOVLW  0C
07DE0:  MOVLB  5
07DE2:  MOVWF  x86
07DE4:  MOVLB  0
07DE6:  CALL   2D32
....................     printf(lcd_putc, "\n\r"); 
07DEA:  MOVLW  0A
07DEC:  MOVLB  5
07DEE:  MOVWF  x86
07DF0:  MOVLB  0
07DF2:  CALL   2D32
07DF6:  MOVLW  0D
07DF8:  MOVLB  5
07DFA:  MOVWF  x86
07DFC:  MOVLB  0
07DFE:  CALL   2D32
....................     printf(lcd_putc, "S2:%04Lu E:%04Lu\n\r",t_solda2[contador_lcd],t_wait[contador_lcd]); 
07E02:  BCF    FD8.0
07E04:  MOVLB  5
07E06:  RLCF   x76,W
07E08:  CLRF   03
07E0A:  ADDLW  82
07E0C:  MOVWF  FE9
07E0E:  MOVLW  01
07E10:  ADDWFC 03,W
07E12:  MOVWF  FEA
07E14:  MOVFF  FEC,578
07E18:  MOVF   FED,F
07E1A:  MOVFF  FEF,577
07E1E:  BCF    FD8.0
07E20:  RLCF   x76,W
07E22:  CLRF   03
07E24:  ADDLW  D8
07E26:  MOVWF  FE9
07E28:  MOVLW  00
07E2A:  ADDWFC 03,W
07E2C:  MOVWF  FEA
07E2E:  MOVFF  FEC,57A
07E32:  MOVF   FED,F
07E34:  MOVFF  FEF,579
07E38:  MOVLW  90
07E3A:  MOVWF  FF6
07E3C:  MOVLW  09
07E3E:  MOVWF  FF7
07E40:  MOVLW  03
07E42:  MOVWF  x7D
07E44:  MOVLB  0
07E46:  CALL   62FC
07E4A:  MOVLW  09
07E4C:  MOVWF  FE9
07E4E:  MOVFF  578,57E
07E52:  MOVFF  577,57D
07E56:  CALL   7028
07E5A:  MOVLW  98
07E5C:  MOVWF  FF6
07E5E:  MOVLW  09
07E60:  MOVWF  FF7
07E62:  MOVLW  03
07E64:  MOVLB  5
07E66:  MOVWF  x7D
07E68:  MOVLB  0
07E6A:  CALL   62FC
07E6E:  MOVLW  09
07E70:  MOVWF  FE9
07E72:  MOVFF  57A,57E
07E76:  MOVFF  579,57D
07E7A:  CALL   7028
07E7E:  MOVLW  0A
07E80:  MOVLB  5
07E82:  MOVWF  x86
07E84:  MOVLB  0
07E86:  CALL   2D32
07E8A:  MOVLW  0D
07E8C:  MOVLB  5
07E8E:  MOVWF  x86
07E90:  MOVLB  0
07E92:  CALL   2D32
....................     printf(lcd_putc, "\n\r"); 
07E96:  MOVLW  0A
07E98:  MOVLB  5
07E9A:  MOVWF  x86
07E9C:  MOVLB  0
07E9E:  CALL   2D32
07EA2:  MOVLW  0D
07EA4:  MOVLB  5
07EA6:  MOVWF  x86
07EA8:  MOVLB  0
07EAA:  CALL   2D32
....................     printf(lcd_putc, "F1:REC|F3:BACK\n\r"); 
07EAE:  MOVLW  A4
07EB0:  MOVWF  FF6
07EB2:  MOVLW  09
07EB4:  MOVWF  FF7
07EB6:  CALL   2D86
07EBA:  RETURN 0
.................... } 
....................  
.................... void tela_faltaSolda(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0B020:  MOVLW  0C
0B022:  MOVLB  5
0B024:  MOVWF  x86
0B026:  MOVLB  0
0B028:  CALL   2D32
....................     printf(lcd_putc, "      VERIFIQUE     \n\r"); 
0B02C:  MOVLW  B6
0B02E:  MOVWF  FF6
0B030:  MOVLW  09
0B032:  MOVWF  FF7
0B034:  CALL   2D86
....................     printf(lcd_putc, "  OS ALIMENTADORES  \n\r"); 
0B038:  MOVLW  CE
0B03A:  MOVWF  FF6
0B03C:  MOVLW  09
0B03E:  MOVWF  FF7
0B040:  CALL   2D86
....................     printf(lcd_putc, "      DE SOLDA      \n\r"); 
0B044:  MOVLW  E6
0B046:  MOVWF  FF6
0B048:  MOVLW  09
0B04A:  MOVWF  FF7
0B04C:  CALL   2D86
....................     printf(lcd_putc, "      ENTER:OK      \n\r"); 
0B050:  MOVLW  FE
0B052:  MOVWF  FF6
0B054:  MOVLW  09
0B056:  MOVWF  FF7
0B058:  CALL   2D86
0B05C:  RETURN 0
.................... } 
....................  
.................... void tela_confirmaManutencao(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
06E36:  MOVLW  0C
06E38:  MOVLB  5
06E3A:  MOVWF  x86
06E3C:  MOVLB  0
06E3E:  CALL   2D32
....................     printf(lcd_putc, "MANUTENCAO BANDEJA 1\n\r"); 
06E42:  MOVLW  16
06E44:  MOVWF  FF6
06E46:  MOVLW  0A
06E48:  MOVWF  FF7
06E4A:  CALL   2D86
....................     printf(lcd_putc, "   JA FINALIZADA ?  \n\r"); 
06E4E:  MOVLW  2E
06E50:  MOVWF  FF6
06E52:  MOVLW  0A
06E54:  MOVWF  FF7
06E56:  CALL   2D86
....................     printf(lcd_putc, "      ENTER:OK      \n\r"); 
06E5A:  MOVLW  46
06E5C:  MOVWF  FF6
06E5E:  MOVLW  0A
06E60:  MOVWF  FF7
06E62:  CALL   2D86
....................     printf(lcd_putc, "       ESC:NO       \n\r"); 
06E66:  MOVLW  5E
06E68:  MOVWF  FF6
06E6A:  MOVLW  0A
06E6C:  MOVWF  FF7
06E6E:  CALL   2D86
06E72:  GOTO   6E88 (RETURN)
.................... } 
....................  
.................... void tela_seleciona_manutencao(){ 
....................     printf(lcd_putc, "\f"); 
*
06FBC:  MOVLW  0C
06FBE:  MOVLB  5
06FC0:  MOVWF  x86
06FC2:  MOVLB  0
06FC4:  CALL   2D32
....................     printf(lcd_putc, " F1: DEBUG ENTRADAS \n\r"); 
06FC8:  MOVLW  76
06FCA:  MOVWF  FF6
06FCC:  MOVLW  0A
06FCE:  MOVWF  FF7
06FD0:  CALL   2D86
....................     printf(lcd_putc, " F2:  DEBUG SAIDAS  \n\r"); 
06FD4:  MOVLW  8E
06FD6:  MOVWF  FF6
06FD8:  MOVLW  0A
06FDA:  MOVWF  FF7
06FDC:  CALL   2D86
....................     printf(lcd_putc, "                    \n\r"); 
06FE0:  MOVLW  A6
06FE2:  MOVWF  FF6
06FE4:  MOVLW  0A
06FE6:  MOVWF  FF7
06FE8:  CALL   2D86
....................     printf(lcd_putc, "      ESC:BACK      \n\r"); 
06FEC:  MOVLW  BE
06FEE:  MOVWF  FF6
06FF0:  MOVLW  0A
06FF2:  MOVWF  FF7
06FF4:  CALL   2D86
06FF8:  RETURN 0
.................... } 
.................... void tela_debug_entrada_1 (){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0B346:  MOVLW  0C
0B348:  MOVLB  5
0B34A:  MOVWF  x86
0B34C:  MOVLB  0
0B34E:  CALL   2D32
....................     printf(lcd_putc, "E00:%02u E01:%02u E02:%02u\n\r", entradas[0], entradas[1], entradas[2]); 
0B352:  MOVLW  00
0B354:  BTFSC  1D.0
0B356:  MOVLW  01
0B358:  MOVLB  5
0B35A:  MOVWF  x76
0B35C:  MOVLW  00
0B35E:  BTFSC  1D.1
0B360:  MOVLW  01
0B362:  MOVWF  x77
0B364:  MOVLW  00
0B366:  BTFSC  1D.2
0B368:  MOVLW  01
0B36A:  MOVWF  x78
0B36C:  MOVLW  D6
0B36E:  MOVWF  FF6
0B370:  MOVLW  0A
0B372:  MOVWF  FF7
0B374:  MOVLW  04
0B376:  MOVWF  x7D
0B378:  MOVLB  0
0B37A:  CALL   62FC
0B37E:  MOVFF  576,57D
0B382:  MOVLW  01
0B384:  MOVLB  5
0B386:  MOVWF  x7E
0B388:  MOVLB  0
0B38A:  CALL   6352
0B38E:  MOVLW  DE
0B390:  MOVWF  FF6
0B392:  MOVLW  0A
0B394:  MOVWF  FF7
0B396:  MOVLW  05
0B398:  MOVLB  5
0B39A:  MOVWF  x7D
0B39C:  MOVLB  0
0B39E:  CALL   62FC
0B3A2:  MOVFF  577,57D
0B3A6:  MOVLW  01
0B3A8:  MOVLB  5
0B3AA:  MOVWF  x7E
0B3AC:  MOVLB  0
0B3AE:  CALL   6352
0B3B2:  MOVLW  E7
0B3B4:  MOVWF  FF6
0B3B6:  MOVLW  0A
0B3B8:  MOVWF  FF7
0B3BA:  MOVLW  05
0B3BC:  MOVLB  5
0B3BE:  MOVWF  x7D
0B3C0:  MOVLB  0
0B3C2:  CALL   62FC
0B3C6:  MOVFF  578,57D
0B3CA:  MOVLW  01
0B3CC:  MOVLB  5
0B3CE:  MOVWF  x7E
0B3D0:  MOVLB  0
0B3D2:  CALL   6352
0B3D6:  MOVLW  0A
0B3D8:  MOVLB  5
0B3DA:  MOVWF  x86
0B3DC:  MOVLB  0
0B3DE:  CALL   2D32
0B3E2:  MOVLW  0D
0B3E4:  MOVLB  5
0B3E6:  MOVWF  x86
0B3E8:  MOVLB  0
0B3EA:  CALL   2D32
....................     printf(lcd_putc, "E03:%02u E04:%02u E05:%02u\n\r", entradas[3], entradas[4], entradas[5]); 
0B3EE:  MOVLW  00
0B3F0:  BTFSC  1D.3
0B3F2:  MOVLW  01
0B3F4:  MOVLB  5
0B3F6:  MOVWF  x76
0B3F8:  MOVLW  00
0B3FA:  BTFSC  1D.4
0B3FC:  MOVLW  01
0B3FE:  MOVWF  x77
0B400:  MOVLW  00
0B402:  BTFSC  1D.5
0B404:  MOVLW  01
0B406:  MOVWF  x78
0B408:  MOVLW  F4
0B40A:  MOVWF  FF6
0B40C:  MOVLW  0A
0B40E:  MOVWF  FF7
0B410:  MOVLW  04
0B412:  MOVWF  x7D
0B414:  MOVLB  0
0B416:  CALL   62FC
0B41A:  MOVFF  576,57D
0B41E:  MOVLW  01
0B420:  MOVLB  5
0B422:  MOVWF  x7E
0B424:  MOVLB  0
0B426:  CALL   6352
0B42A:  MOVLW  FC
0B42C:  MOVWF  FF6
0B42E:  MOVLW  0A
0B430:  MOVWF  FF7
0B432:  MOVLW  05
0B434:  MOVLB  5
0B436:  MOVWF  x7D
0B438:  MOVLB  0
0B43A:  CALL   62FC
0B43E:  MOVFF  577,57D
0B442:  MOVLW  01
0B444:  MOVLB  5
0B446:  MOVWF  x7E
0B448:  MOVLB  0
0B44A:  CALL   6352
0B44E:  MOVLW  05
0B450:  MOVWF  FF6
0B452:  MOVLW  0B
0B454:  MOVWF  FF7
0B456:  MOVLW  05
0B458:  MOVLB  5
0B45A:  MOVWF  x7D
0B45C:  MOVLB  0
0B45E:  CALL   62FC
0B462:  MOVFF  578,57D
0B466:  MOVLW  01
0B468:  MOVLB  5
0B46A:  MOVWF  x7E
0B46C:  MOVLB  0
0B46E:  CALL   6352
0B472:  MOVLW  0A
0B474:  MOVLB  5
0B476:  MOVWF  x86
0B478:  MOVLB  0
0B47A:  CALL   2D32
0B47E:  MOVLW  0D
0B480:  MOVLB  5
0B482:  MOVWF  x86
0B484:  MOVLB  0
0B486:  CALL   2D32
....................     printf(lcd_putc, "E06:%02u E07:%02u E08:%02u\n\r", entradas[6], entradas[7], entradas[8]);     
0B48A:  MOVLW  00
0B48C:  BTFSC  1D.6
0B48E:  MOVLW  01
0B490:  MOVLB  5
0B492:  MOVWF  x76
0B494:  MOVLW  00
0B496:  BTFSC  1D.7
0B498:  MOVLW  01
0B49A:  MOVWF  x77
0B49C:  MOVLW  00
0B49E:  BTFSC  1E.0
0B4A0:  MOVLW  01
0B4A2:  MOVWF  x78
0B4A4:  MOVLW  12
0B4A6:  MOVWF  FF6
0B4A8:  MOVLW  0B
0B4AA:  MOVWF  FF7
0B4AC:  MOVLW  04
0B4AE:  MOVWF  x7D
0B4B0:  MOVLB  0
0B4B2:  CALL   62FC
0B4B6:  MOVFF  576,57D
0B4BA:  MOVLW  01
0B4BC:  MOVLB  5
0B4BE:  MOVWF  x7E
0B4C0:  MOVLB  0
0B4C2:  CALL   6352
0B4C6:  MOVLW  1A
0B4C8:  MOVWF  FF6
0B4CA:  MOVLW  0B
0B4CC:  MOVWF  FF7
0B4CE:  MOVLW  05
0B4D0:  MOVLB  5
0B4D2:  MOVWF  x7D
0B4D4:  MOVLB  0
0B4D6:  CALL   62FC
0B4DA:  MOVFF  577,57D
0B4DE:  MOVLW  01
0B4E0:  MOVLB  5
0B4E2:  MOVWF  x7E
0B4E4:  MOVLB  0
0B4E6:  CALL   6352
0B4EA:  MOVLW  23
0B4EC:  MOVWF  FF6
0B4EE:  MOVLW  0B
0B4F0:  MOVWF  FF7
0B4F2:  MOVLW  05
0B4F4:  MOVLB  5
0B4F6:  MOVWF  x7D
0B4F8:  MOVLB  0
0B4FA:  CALL   62FC
0B4FE:  MOVFF  578,57D
0B502:  MOVLW  01
0B504:  MOVLB  5
0B506:  MOVWF  x7E
0B508:  MOVLB  0
0B50A:  CALL   6352
0B50E:  MOVLW  0A
0B510:  MOVLB  5
0B512:  MOVWF  x86
0B514:  MOVLB  0
0B516:  CALL   2D32
0B51A:  MOVLW  0D
0B51C:  MOVLB  5
0B51E:  MOVWF  x86
0B520:  MOVLB  0
0B522:  CALL   2D32
....................     printf(lcd_putc, "   >:PROX|ESC:BACK  \n\r"); 
0B526:  MOVLW  30
0B528:  MOVWF  FF6
0B52A:  MOVLW  0B
0B52C:  MOVWF  FF7
0B52E:  CALL   2D86
0B532:  RETURN 0
.................... } 
.................... void tela_debug_entrada_2 (){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0B5BE:  MOVLW  0C
0B5C0:  MOVLB  5
0B5C2:  MOVWF  x86
0B5C4:  MOVLB  0
0B5C6:  CALL   2D32
....................     printf(lcd_putc, "E09:%02u E10:%02u E11:%02u\n\r", entradas[9], entradas[10], entradas[11]); 
0B5CA:  MOVLW  00
0B5CC:  BTFSC  1E.1
0B5CE:  MOVLW  01
0B5D0:  MOVLB  5
0B5D2:  MOVWF  x76
0B5D4:  MOVLW  00
0B5D6:  BTFSC  1E.2
0B5D8:  MOVLW  01
0B5DA:  MOVWF  x77
0B5DC:  MOVLW  00
0B5DE:  BTFSC  1E.3
0B5E0:  MOVLW  01
0B5E2:  MOVWF  x78
0B5E4:  MOVLW  48
0B5E6:  MOVWF  FF6
0B5E8:  MOVLW  0B
0B5EA:  MOVWF  FF7
0B5EC:  MOVLW  04
0B5EE:  MOVWF  x7D
0B5F0:  MOVLB  0
0B5F2:  CALL   62FC
0B5F6:  MOVFF  576,57D
0B5FA:  MOVLW  01
0B5FC:  MOVLB  5
0B5FE:  MOVWF  x7E
0B600:  MOVLB  0
0B602:  CALL   6352
0B606:  MOVLW  50
0B608:  MOVWF  FF6
0B60A:  MOVLW  0B
0B60C:  MOVWF  FF7
0B60E:  MOVLW  05
0B610:  MOVLB  5
0B612:  MOVWF  x7D
0B614:  MOVLB  0
0B616:  CALL   62FC
0B61A:  MOVFF  577,57D
0B61E:  MOVLW  01
0B620:  MOVLB  5
0B622:  MOVWF  x7E
0B624:  MOVLB  0
0B626:  CALL   6352
0B62A:  MOVLW  59
0B62C:  MOVWF  FF6
0B62E:  MOVLW  0B
0B630:  MOVWF  FF7
0B632:  MOVLW  05
0B634:  MOVLB  5
0B636:  MOVWF  x7D
0B638:  MOVLB  0
0B63A:  CALL   62FC
0B63E:  MOVFF  578,57D
0B642:  MOVLW  01
0B644:  MOVLB  5
0B646:  MOVWF  x7E
0B648:  MOVLB  0
0B64A:  CALL   6352
0B64E:  MOVLW  0A
0B650:  MOVLB  5
0B652:  MOVWF  x86
0B654:  MOVLB  0
0B656:  CALL   2D32
0B65A:  MOVLW  0D
0B65C:  MOVLB  5
0B65E:  MOVWF  x86
0B660:  MOVLB  0
0B662:  CALL   2D32
....................     printf(lcd_putc, "E12:%02u E13:%02u E14:%02u\n\r", entradas[12], entradas[13], entradas[14]); 
0B666:  MOVLW  00
0B668:  BTFSC  1E.4
0B66A:  MOVLW  01
0B66C:  MOVLB  5
0B66E:  MOVWF  x76
0B670:  MOVLW  00
0B672:  BTFSC  1E.5
0B674:  MOVLW  01
0B676:  MOVWF  x77
0B678:  MOVLW  00
0B67A:  BTFSC  1E.6
0B67C:  MOVLW  01
0B67E:  MOVWF  x78
0B680:  MOVLW  66
0B682:  MOVWF  FF6
0B684:  MOVLW  0B
0B686:  MOVWF  FF7
0B688:  MOVLW  04
0B68A:  MOVWF  x7D
0B68C:  MOVLB  0
0B68E:  CALL   62FC
0B692:  MOVFF  576,57D
0B696:  MOVLW  01
0B698:  MOVLB  5
0B69A:  MOVWF  x7E
0B69C:  MOVLB  0
0B69E:  CALL   6352
0B6A2:  MOVLW  6E
0B6A4:  MOVWF  FF6
0B6A6:  MOVLW  0B
0B6A8:  MOVWF  FF7
0B6AA:  MOVLW  05
0B6AC:  MOVLB  5
0B6AE:  MOVWF  x7D
0B6B0:  MOVLB  0
0B6B2:  CALL   62FC
0B6B6:  MOVFF  577,57D
0B6BA:  MOVLW  01
0B6BC:  MOVLB  5
0B6BE:  MOVWF  x7E
0B6C0:  MOVLB  0
0B6C2:  CALL   6352
0B6C6:  MOVLW  77
0B6C8:  MOVWF  FF6
0B6CA:  MOVLW  0B
0B6CC:  MOVWF  FF7
0B6CE:  MOVLW  05
0B6D0:  MOVLB  5
0B6D2:  MOVWF  x7D
0B6D4:  MOVLB  0
0B6D6:  CALL   62FC
0B6DA:  MOVFF  578,57D
0B6DE:  MOVLW  01
0B6E0:  MOVLB  5
0B6E2:  MOVWF  x7E
0B6E4:  MOVLB  0
0B6E6:  CALL   6352
0B6EA:  MOVLW  0A
0B6EC:  MOVLB  5
0B6EE:  MOVWF  x86
0B6F0:  MOVLB  0
0B6F2:  CALL   2D32
0B6F6:  MOVLW  0D
0B6F8:  MOVLB  5
0B6FA:  MOVWF  x86
0B6FC:  MOVLB  0
0B6FE:  CALL   2D32
....................     printf(lcd_putc, "E15:%02u E16:%02u E17:%02u\n\r", entradas[15], entradas[16], entradas[17]);     
0B702:  MOVLW  00
0B704:  BTFSC  1E.7
0B706:  MOVLW  01
0B708:  MOVLB  5
0B70A:  MOVWF  x76
0B70C:  MOVLW  00
0B70E:  BTFSC  1F.0
0B710:  MOVLW  01
0B712:  MOVWF  x77
0B714:  MOVLW  00
0B716:  BTFSC  1F.1
0B718:  MOVLW  01
0B71A:  MOVWF  x78
0B71C:  MOVLW  84
0B71E:  MOVWF  FF6
0B720:  MOVLW  0B
0B722:  MOVWF  FF7
0B724:  MOVLW  04
0B726:  MOVWF  x7D
0B728:  MOVLB  0
0B72A:  CALL   62FC
0B72E:  MOVFF  576,57D
0B732:  MOVLW  01
0B734:  MOVLB  5
0B736:  MOVWF  x7E
0B738:  MOVLB  0
0B73A:  CALL   6352
0B73E:  MOVLW  8C
0B740:  MOVWF  FF6
0B742:  MOVLW  0B
0B744:  MOVWF  FF7
0B746:  MOVLW  05
0B748:  MOVLB  5
0B74A:  MOVWF  x7D
0B74C:  MOVLB  0
0B74E:  CALL   62FC
0B752:  MOVFF  577,57D
0B756:  MOVLW  01
0B758:  MOVLB  5
0B75A:  MOVWF  x7E
0B75C:  MOVLB  0
0B75E:  CALL   6352
0B762:  MOVLW  95
0B764:  MOVWF  FF6
0B766:  MOVLW  0B
0B768:  MOVWF  FF7
0B76A:  MOVLW  05
0B76C:  MOVLB  5
0B76E:  MOVWF  x7D
0B770:  MOVLB  0
0B772:  CALL   62FC
0B776:  MOVFF  578,57D
0B77A:  MOVLW  01
0B77C:  MOVLB  5
0B77E:  MOVWF  x7E
0B780:  MOVLB  0
0B782:  CALL   6352
0B786:  MOVLW  0A
0B788:  MOVLB  5
0B78A:  MOVWF  x86
0B78C:  MOVLB  0
0B78E:  CALL   2D32
0B792:  MOVLW  0D
0B794:  MOVLB  5
0B796:  MOVWF  x86
0B798:  MOVLB  0
0B79A:  CALL   2D32
....................     printf(lcd_putc, "  <|>:PROX|ESC:BACK \n\r"); 
0B79E:  MOVLW  A2
0B7A0:  MOVWF  FF6
0B7A2:  MOVLW  0B
0B7A4:  MOVWF  FF7
0B7A6:  CALL   2D86
0B7AA:  RETURN 0
.................... } 
.................... void tela_debug_entrada_3 (){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0B828:  MOVLW  0C
0B82A:  MOVLB  5
0B82C:  MOVWF  x86
0B82E:  MOVLB  0
0B830:  CALL   2D32
....................     printf(lcd_putc, "E18:%02u E19:%02u E20:%02u\n\r", entradas[18], entradas[19], entradas[20]); 
0B834:  MOVLW  00
0B836:  BTFSC  1F.2
0B838:  MOVLW  01
0B83A:  MOVLB  5
0B83C:  MOVWF  x76
0B83E:  MOVLW  00
0B840:  BTFSC  1F.3
0B842:  MOVLW  01
0B844:  MOVWF  x77
0B846:  MOVLW  00
0B848:  BTFSC  1F.4
0B84A:  MOVLW  01
0B84C:  MOVWF  x78
0B84E:  MOVLW  BA
0B850:  MOVWF  FF6
0B852:  MOVLW  0B
0B854:  MOVWF  FF7
0B856:  MOVLW  04
0B858:  MOVWF  x7D
0B85A:  MOVLB  0
0B85C:  CALL   62FC
0B860:  MOVFF  576,57D
0B864:  MOVLW  01
0B866:  MOVLB  5
0B868:  MOVWF  x7E
0B86A:  MOVLB  0
0B86C:  CALL   6352
0B870:  MOVLW  C2
0B872:  MOVWF  FF6
0B874:  MOVLW  0B
0B876:  MOVWF  FF7
0B878:  MOVLW  05
0B87A:  MOVLB  5
0B87C:  MOVWF  x7D
0B87E:  MOVLB  0
0B880:  CALL   62FC
0B884:  MOVFF  577,57D
0B888:  MOVLW  01
0B88A:  MOVLB  5
0B88C:  MOVWF  x7E
0B88E:  MOVLB  0
0B890:  CALL   6352
0B894:  MOVLW  CB
0B896:  MOVWF  FF6
0B898:  MOVLW  0B
0B89A:  MOVWF  FF7
0B89C:  MOVLW  05
0B89E:  MOVLB  5
0B8A0:  MOVWF  x7D
0B8A2:  MOVLB  0
0B8A4:  CALL   62FC
0B8A8:  MOVFF  578,57D
0B8AC:  MOVLW  01
0B8AE:  MOVLB  5
0B8B0:  MOVWF  x7E
0B8B2:  MOVLB  0
0B8B4:  CALL   6352
0B8B8:  MOVLW  0A
0B8BA:  MOVLB  5
0B8BC:  MOVWF  x86
0B8BE:  MOVLB  0
0B8C0:  CALL   2D32
0B8C4:  MOVLW  0D
0B8C6:  MOVLB  5
0B8C8:  MOVWF  x86
0B8CA:  MOVLB  0
0B8CC:  CALL   2D32
....................     printf(lcd_putc, "E21:%02u E22:%02u E23:%02u\n\r", entradas[21], entradas[22], entradas[23]); 
0B8D0:  MOVLW  00
0B8D2:  BTFSC  1F.5
0B8D4:  MOVLW  01
0B8D6:  MOVLB  5
0B8D8:  MOVWF  x76
0B8DA:  MOVLW  00
0B8DC:  BTFSC  1F.6
0B8DE:  MOVLW  01
0B8E0:  MOVWF  x77
0B8E2:  MOVLW  00
0B8E4:  BTFSC  1F.7
0B8E6:  MOVLW  01
0B8E8:  MOVWF  x78
0B8EA:  MOVLW  D8
0B8EC:  MOVWF  FF6
0B8EE:  MOVLW  0B
0B8F0:  MOVWF  FF7
0B8F2:  MOVLW  04
0B8F4:  MOVWF  x7D
0B8F6:  MOVLB  0
0B8F8:  CALL   62FC
0B8FC:  MOVFF  576,57D
0B900:  MOVLW  01
0B902:  MOVLB  5
0B904:  MOVWF  x7E
0B906:  MOVLB  0
0B908:  CALL   6352
0B90C:  MOVLW  E0
0B90E:  MOVWF  FF6
0B910:  MOVLW  0B
0B912:  MOVWF  FF7
0B914:  MOVLW  05
0B916:  MOVLB  5
0B918:  MOVWF  x7D
0B91A:  MOVLB  0
0B91C:  CALL   62FC
0B920:  MOVFF  577,57D
0B924:  MOVLW  01
0B926:  MOVLB  5
0B928:  MOVWF  x7E
0B92A:  MOVLB  0
0B92C:  CALL   6352
0B930:  MOVLW  E9
0B932:  MOVWF  FF6
0B934:  MOVLW  0B
0B936:  MOVWF  FF7
0B938:  MOVLW  05
0B93A:  MOVLB  5
0B93C:  MOVWF  x7D
0B93E:  MOVLB  0
0B940:  CALL   62FC
0B944:  MOVFF  578,57D
0B948:  MOVLW  01
0B94A:  MOVLB  5
0B94C:  MOVWF  x7E
0B94E:  MOVLB  0
0B950:  CALL   6352
0B954:  MOVLW  0A
0B956:  MOVLB  5
0B958:  MOVWF  x86
0B95A:  MOVLB  0
0B95C:  CALL   2D32
0B960:  MOVLW  0D
0B962:  MOVLB  5
0B964:  MOVWF  x86
0B966:  MOVLB  0
0B968:  CALL   2D32
....................     printf(lcd_putc, "E24:%02u E25:%02u E26:%02u\n\r", entradas[24], entradas[25], entradas[26]); 
0B96C:  MOVLW  00
0B96E:  BTFSC  20.0
0B970:  MOVLW  01
0B972:  MOVLB  5
0B974:  MOVWF  x76
0B976:  MOVLW  00
0B978:  BTFSC  20.1
0B97A:  MOVLW  01
0B97C:  MOVWF  x77
0B97E:  MOVLW  00
0B980:  BTFSC  20.2
0B982:  MOVLW  01
0B984:  MOVWF  x78
0B986:  MOVLW  F6
0B988:  MOVWF  FF6
0B98A:  MOVLW  0B
0B98C:  MOVWF  FF7
0B98E:  MOVLW  04
0B990:  MOVWF  x7D
0B992:  MOVLB  0
0B994:  CALL   62FC
0B998:  MOVFF  576,57D
0B99C:  MOVLW  01
0B99E:  MOVLB  5
0B9A0:  MOVWF  x7E
0B9A2:  MOVLB  0
0B9A4:  CALL   6352
0B9A8:  MOVLW  FE
0B9AA:  MOVWF  FF6
0B9AC:  MOVLW  0B
0B9AE:  MOVWF  FF7
0B9B0:  MOVLW  05
0B9B2:  MOVLB  5
0B9B4:  MOVWF  x7D
0B9B6:  MOVLB  0
0B9B8:  CALL   62FC
0B9BC:  MOVFF  577,57D
0B9C0:  MOVLW  01
0B9C2:  MOVLB  5
0B9C4:  MOVWF  x7E
0B9C6:  MOVLB  0
0B9C8:  CALL   6352
0B9CC:  MOVLW  07
0B9CE:  MOVWF  FF6
0B9D0:  MOVLW  0C
0B9D2:  MOVWF  FF7
0B9D4:  MOVLW  05
0B9D6:  MOVLB  5
0B9D8:  MOVWF  x7D
0B9DA:  MOVLB  0
0B9DC:  CALL   62FC
0B9E0:  MOVFF  578,57D
0B9E4:  MOVLW  01
0B9E6:  MOVLB  5
0B9E8:  MOVWF  x7E
0B9EA:  MOVLB  0
0B9EC:  CALL   6352
0B9F0:  MOVLW  0A
0B9F2:  MOVLB  5
0B9F4:  MOVWF  x86
0B9F6:  MOVLB  0
0B9F8:  CALL   2D32
0B9FC:  MOVLW  0D
0B9FE:  MOVLB  5
0BA00:  MOVWF  x86
0BA02:  MOVLB  0
0BA04:  CALL   2D32
....................     printf(lcd_putc, "E27:%02u <:ANT|ESC:BACK\n\r", entradas[27]); 
0BA08:  MOVLW  00
0BA0A:  BTFSC  20.3
0BA0C:  MOVLW  01
0BA0E:  MOVLB  5
0BA10:  MOVWF  x76
0BA12:  MOVLW  14
0BA14:  MOVWF  FF6
0BA16:  MOVLW  0C
0BA18:  MOVWF  FF7
0BA1A:  MOVLW  04
0BA1C:  MOVWF  x7D
0BA1E:  MOVLB  0
0BA20:  CALL   62FC
0BA24:  MOVFF  576,57D
0BA28:  MOVLW  01
0BA2A:  MOVLB  5
0BA2C:  MOVWF  x7E
0BA2E:  MOVLB  0
0BA30:  CALL   6352
0BA34:  MOVLW  1C
0BA36:  MOVWF  FF6
0BA38:  MOVLW  0C
0BA3A:  MOVWF  FF7
0BA3C:  MOVLW  11
0BA3E:  MOVLB  5
0BA40:  MOVWF  x7D
0BA42:  MOVLB  0
0BA44:  CALL   62FC
0BA48:  RETURN 0
.................... } 
.................... void tela_debug_saida_1 (){ 
....................     printf(lcd_putc, "\f"); 
*
0B534:  MOVLW  0C
0B536:  MOVLB  5
0B538:  MOVWF  x86
0B53A:  MOVLB  0
0B53C:  CALL   2D32
....................     printf(lcd_putc, "ESTEIRA             \n\r"); 
0B540:  MOVLW  2E
0B542:  MOVWF  FF6
0B544:  MOVLW  0C
0B546:  MOVWF  FF7
0B548:  CALL   2D86
....................     printf(lcd_putc, "DEDOS ENTRADA       \n\r"); 
0B54C:  MOVLW  46
0B54E:  MOVWF  FF6
0B550:  MOVLW  0C
0B552:  MOVWF  FF7
0B554:  CALL   2D86
....................     printf(lcd_putc, "ALIMENTADOR_PLACA   \n\r"); 
0B558:  MOVLW  5E
0B55A:  MOVWF  FF6
0B55C:  MOVLW  0C
0B55E:  MOVWF  FF7
0B560:  CALL   2D86
....................     printf(lcd_putc, "F1:ON|F2:OF|ESC:BACK\n\r"); 
0B564:  MOVLW  76
0B566:  MOVWF  FF6
0B568:  MOVLW  0C
0B56A:  MOVWF  FF7
0B56C:  CALL   2D86
....................     posiciona_cursor(ponteiro_lcd,19); 
0B570:  MOVFF  21,587
0B574:  MOVLW  13
0B576:  MOVLB  5
0B578:  MOVWF  x88
0B57A:  MOVLB  0
0B57C:  CALL   2B84
....................     printf(lcd_putc,"<"); 
0B580:  MOVLW  3C
0B582:  MOVLB  5
0B584:  MOVWF  x86
0B586:  MOVLB  0
0B588:  CALL   2D32
0B58C:  RETURN 0
.................... } 
.................... void tela_debug_saida_2 (){ 
....................     printf(lcd_putc, "\f"); 
*
0BB52:  MOVLW  0C
0BB54:  MOVLB  5
0BB56:  MOVWF  x86
0BB58:  MOVLB  0
0BB5A:  CALL   2D32
....................     printf(lcd_putc, "PRESSOR             \n\r"); 
0BB5E:  MOVLW  8E
0BB60:  MOVWF  FF6
0BB62:  MOVLW  0C
0BB64:  MOVWF  FF7
0BB66:  CALL   2D86
....................     printf(lcd_putc, "DEDOS_SAIDA         \n\r"); 
0BB6A:  MOVLW  A6
0BB6C:  MOVWF  FF6
0BB6E:  MOVLW  0C
0BB70:  MOVWF  FF7
0BB72:  CALL   2D86
....................     printf(lcd_putc, "DISPENSADOR_PLACA   \n\r"); 
0BB76:  MOVLW  BE
0BB78:  MOVWF  FF6
0BB7A:  MOVLW  0C
0BB7C:  MOVWF  FF7
0BB7E:  CALL   2D86
....................     printf(lcd_putc, "F1:ON|F2:OF|ESC:BACK\n\r"); 
0BB82:  MOVLW  D6
0BB84:  MOVWF  FF6
0BB86:  MOVLW  0C
0BB88:  MOVWF  FF7
0BB8A:  CALL   2D86
....................     posiciona_cursor(ponteiro_lcd,19); 
0BB8E:  MOVFF  21,587
0BB92:  MOVLW  13
0BB94:  MOVLB  5
0BB96:  MOVWF  x88
0BB98:  MOVLB  0
0BB9A:  CALL   2B84
....................     printf(lcd_putc,"<"); 
0BB9E:  MOVLW  3C
0BBA0:  MOVLB  5
0BBA2:  MOVWF  x86
0BBA4:  MOVLB  0
0BBA6:  CALL   2D32
0BBAA:  RETURN 0
.................... } 
.................... void tela_debug_saida_3 (){ 
....................     printf(lcd_putc, "\f"); 
*
0BD96:  MOVLW  0C
0BD98:  MOVLB  5
0BD9A:  MOVWF  x86
0BD9C:  MOVLB  0
0BD9E:  CALL   2D32
....................     printf(lcd_putc, "ALIMENTADOR_SOLDA   \n\r"); 
0BDA2:  MOVLW  EE
0BDA4:  MOVWF  FF6
0BDA6:  MOVLW  0C
0BDA8:  MOVWF  FF7
0BDAA:  CALL   2D86
....................     printf(lcd_putc, "LIMPADOR_BICO       \n\r"); 
0BDAE:  MOVLW  06
0BDB0:  MOVWF  FF6
0BDB2:  MOVLW  0D
0BDB4:  MOVWF  FF7
0BDB6:  CALL   2D86
....................     printf(lcd_putc, "FERROS_DE_SOLDA     \n\r"); 
0BDBA:  MOVLW  1E
0BDBC:  MOVWF  FF6
0BDBE:  MOVLW  0D
0BDC0:  MOVWF  FF7
0BDC2:  CALL   2D86
....................     printf(lcd_putc, "F1:ON|F2:OF|ESC:BACK\n\r"); 
0BDC6:  MOVLW  36
0BDC8:  MOVWF  FF6
0BDCA:  MOVLW  0D
0BDCC:  MOVWF  FF7
0BDCE:  CALL   2D86
....................     posiciona_cursor(ponteiro_lcd,19); 
0BDD2:  MOVFF  21,587
0BDD6:  MOVLW  13
0BDD8:  MOVLB  5
0BDDA:  MOVWF  x88
0BDDC:  MOVLB  0
0BDDE:  CALL   2B84
....................     printf(lcd_putc,"<"); 
0BDE2:  MOVLW  3C
0BDE4:  MOVLB  5
0BDE6:  MOVWF  x86
0BDE8:  MOVLB  0
0BDEA:  CALL   2D32
0BDEE:  RETURN 0
.................... } 
.................... void tela_debug_saida_4(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0BF60:  MOVLW  0C
0BF62:  MOVLB  5
0BF64:  MOVWF  x86
0BF66:  MOVLB  0
0BF68:  CALL   2D32
....................     printf(lcd_putc, "   X:%04Lu  Y:%04Lu  \n\r",motor_pos_x,motor_pos_y); 
0BF6C:  MOVLW  4E
0BF6E:  MOVWF  FF6
0BF70:  MOVLW  0D
0BF72:  MOVWF  FF7
0BF74:  MOVLW  05
0BF76:  MOVLB  5
0BF78:  MOVWF  x7D
0BF7A:  MOVLB  0
0BF7C:  CALL   62FC
0BF80:  MOVLW  09
0BF82:  MOVWF  FE9
0BF84:  MOVFF  205,57E
0BF88:  MOVFF  204,57D
0BF8C:  CALL   7028
0BF90:  MOVLW  58
0BF92:  MOVWF  FF6
0BF94:  MOVLW  0D
0BF96:  MOVWF  FF7
0BF98:  MOVLW  04
0BF9A:  MOVLB  5
0BF9C:  MOVWF  x7D
0BF9E:  MOVLB  0
0BFA0:  CALL   62FC
0BFA4:  MOVLW  09
0BFA6:  MOVWF  FE9
0BFA8:  MOVFF  207,57E
0BFAC:  MOVFF  206,57D
0BFB0:  CALL   7028
0BFB4:  MOVLW  61
0BFB6:  MOVWF  FF6
0BFB8:  MOVLW  0D
0BFBA:  MOVWF  FF7
0BFBC:  MOVLW  04
0BFBE:  MOVLB  5
0BFC0:  MOVWF  x7D
0BFC2:  MOVLB  0
0BFC4:  CALL   62FC
....................     printf(lcd_putc, "   Z:%04Lu  F:%04Lu  \n\r",motor_pos_z,motor_pos_flip); 
0BFC8:  MOVLW  66
0BFCA:  MOVWF  FF6
0BFCC:  MOVLW  0D
0BFCE:  MOVWF  FF7
0BFD0:  MOVLW  05
0BFD2:  MOVLB  5
0BFD4:  MOVWF  x7D
0BFD6:  MOVLB  0
0BFD8:  CALL   62FC
0BFDC:  MOVLW  09
0BFDE:  MOVWF  FE9
0BFE0:  MOVFF  20B,57E
0BFE4:  MOVFF  20A,57D
0BFE8:  CALL   7028
0BFEC:  MOVLW  70
0BFEE:  MOVWF  FF6
0BFF0:  MOVLW  0D
0BFF2:  MOVWF  FF7
0BFF4:  MOVLW  04
0BFF6:  MOVLB  5
0BFF8:  MOVWF  x7D
0BFFA:  MOVLB  0
0BFFC:  CALL   62FC
0C000:  MOVLW  09
0C002:  MOVWF  FE9
0C004:  MOVFF  209,57E
0C008:  MOVFF  208,57D
0C00C:  CALL   7028
0C010:  MOVLW  79
0C012:  MOVWF  FF6
0C014:  MOVLW  0D
0C016:  MOVWF  FF7
0C018:  MOVLW  04
0C01A:  MOVLB  5
0C01C:  MOVWF  x7D
0C01E:  MOVLB  0
0C020:  CALL   62FC
....................     printf(lcd_putc, "       INC:%2u     \n\r",incremento); 
0C024:  MOVLW  7E
0C026:  MOVWF  FF6
0C028:  MOVLW  0D
0C02A:  MOVWF  FF7
0C02C:  MOVLW  0B
0C02E:  MOVLB  5
0C030:  MOVWF  x7D
0C032:  MOVLB  0
0C034:  CALL   62FC
0C038:  MOVFF  25,57D
0C03C:  MOVLW  11
0C03E:  MOVLB  5
0C040:  MOVWF  x7E
0C042:  MOVLB  0
0C044:  CALL   6352
0C048:  MOVLW  8C
0C04A:  MOVWF  FF6
0C04C:  MOVLW  0D
0C04E:  MOVWF  FF7
0C050:  MOVLW  07
0C052:  MOVLB  5
0C054:  MOVWF  x7D
0C056:  MOVLB  0
0C058:  CALL   62FC
....................     printf(lcd_putc, "       ESC:BACK      \n\r"); 
0C05C:  MOVLW  94
0C05E:  MOVWF  FF6
0C060:  MOVLW  0D
0C062:  MOVWF  FF7
0C064:  CALL   2D86
0C068:  RETURN 0
.................... } 
....................  
.................... void tela_programa_principal(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
06C84:  MOVLW  0C
06C86:  MOVLB  5
06C88:  MOVWF  x86
06C8A:  MOVLB  0
06C8C:  CALL   2D32
....................     printf(lcd_putc, " EXECUTANDO PROGRAMA\n\r"); 
06C90:  MOVLW  AC
06C92:  MOVWF  FF6
06C94:  MOVLW  0D
06C96:  MOVWF  FF7
06C98:  CALL   2D86
....................     printf(lcd_putc, "     MODELO:%02u    \n\r",modelo); 
06C9C:  MOVLW  C4
06C9E:  MOVWF  FF6
06CA0:  MOVLW  0D
06CA2:  MOVWF  FF7
06CA4:  MOVLW  0C
06CA6:  MOVLB  5
06CA8:  MOVWF  x7D
06CAA:  MOVLB  0
06CAC:  CALL   62FC
06CB0:  MOVFF  2F,57D
06CB4:  MOVLW  01
06CB6:  MOVLB  5
06CB8:  MOVWF  x7E
06CBA:  MOVLB  0
06CBC:  CALL   6352
06CC0:  MOVLW  D4
06CC2:  MOVWF  FF6
06CC4:  MOVLW  0D
06CC6:  MOVWF  FF7
06CC8:  MOVLW  06
06CCA:  MOVLB  5
06CCC:  MOVWF  x7D
06CCE:  MOVLB  0
06CD0:  CALL   62FC
....................     printf(lcd_putc, "                    \n\r"); 
06CD4:  MOVLW  DC
06CD6:  MOVWF  FF6
06CD8:  MOVLW  0D
06CDA:  MOVWF  FF7
06CDC:  CALL   2D86
....................     printf(lcd_putc, "      ESC:STOP      \n\r"); 
06CE0:  MOVLW  F4
06CE2:  MOVWF  FF6
06CE4:  MOVLW  0D
06CE6:  MOVWF  FF7
06CE8:  CALL   2D86
06CEC:  GOTO   6D7E (RETURN)
.................... } 
....................  
.................... #include "Axis_x.c" 
.................... // <editor-fold defaultstate="collapsed" desc="Valores que devem ser inseridos"> 
.................... float stepbyrev_x = 200; 
.................... float driver_u_step_x = 1; // caso o driver esteja em 400 
.................... float Leadscrew_x = 9; //redutor de voltas do motor 
.................... float Leadscrew_Pich_x = 150; //esse valor deve ser em mm/revoluo(max = 83mm/s) 
.................... float Vmax_x = 600;//esse valor deve ser em mm por segundo 
.................... float Vmin_x = 200; 
.................... float Amax_x = 450; //esse valor deve ser em mm por segundo 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Valores calculo rampa"> 
.................... float MMbyStep_x = 0; 
.................... int8 StepinAcc_x = 20; 
.................... float Fmax_x = 0; 
.................... float Fmin_x = 100; 
.................... int32 Ts_x[20]; 
.................... int32 StepbyF_x[20]; 
.................... int16 total_acc_step_x = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Flags e Controles de Movimento"> 
.................... signed int8 pos_inc_x = 0; 
.................... int8 ramp_sts_x = ramp_idle; 
.................... short run_flg_x = FALSE; 
.................... short rest_x = FALSE; 
.................... int16 step_no_x = 0; 
.................... int16 step_down_x = 0; 
.................... int16 move_x = 0; 
.................... int16 midpt_x = 0; 
.................... int32 step_acumulado_x = 0; 
.................... int atual_frequencia_x = 0; 
.................... int vel_x = 19; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Pinos Motor"> 
.................... #DEFINE     i_limite_x            5 
.................... #DEFINE     s_limite_x            6 
....................  
.................... // </editor-fold>    
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Inicializa Motor"> 
.................... void init_axis_x(){ 
....................     set_tris_d(0xf8); 
*
034FC:  MOVLW  F8
034FE:  MOVWF  F95
....................     output_high(step_x); 
03500:  BCF    F95.2
03502:  BSF    F8C.2
....................     output_high(enable_x); 
03504:  BCF    F95.0
03506:  BSF    F8C.0
....................     output_high(dir_x); 
03508:  BCF    F95.1
0350A:  BSF    F8C.1
....................      
....................     MMbyStep_x = Leadscrew_Pich_x/(stepbyrev_x*driver_u_step_x*Leadscrew_x); 
0350C:  MOVFF  213,593
03510:  MOVFF  212,592
03514:  MOVFF  211,591
03518:  MOVFF  210,590
0351C:  MOVFF  217,597
03520:  MOVFF  216,596
03524:  MOVFF  215,595
03528:  MOVFF  214,594
0352C:  RCALL  2F24
0352E:  MOVFF  03,585
03532:  MOVFF  02,584
03536:  MOVFF  01,583
0353A:  MOVFF  00,582
0353E:  MOVFF  03,593
03542:  MOVFF  02,592
03546:  MOVFF  01,591
0354A:  MOVFF  00,590
0354E:  MOVFF  21B,597
03552:  MOVFF  21A,596
03556:  MOVFF  219,595
0355A:  MOVFF  218,594
0355E:  RCALL  2F24
03560:  MOVFF  21F,599
03564:  MOVFF  21E,598
03568:  MOVFF  21D,597
0356C:  MOVFF  21C,596
03570:  MOVFF  03,59D
03574:  MOVFF  02,59C
03578:  MOVFF  01,59B
0357C:  MOVFF  00,59A
03580:  RCALL  301A
03582:  MOVFF  03,22F
03586:  MOVFF  02,22E
0358A:  MOVFF  01,22D
0358E:  MOVFF  00,22C
....................     Fmax_x = Vmax_x/MMbyStep_x; //Valor de ferequencia adiquirido em hz 
03592:  MOVFF  223,599
03596:  MOVFF  222,598
0359A:  MOVFF  221,597
0359E:  MOVFF  220,596
035A2:  MOVFF  22F,59D
035A6:  MOVFF  22E,59C
035AA:  MOVFF  22D,59B
035AE:  MOVFF  22C,59A
035B2:  RCALL  301A
035B4:  MOVFF  03,234
035B8:  MOVFF  02,233
035BC:  MOVFF  01,232
035C0:  MOVFF  00,231
....................     //Fmin_x = Vmin_x/MMbyStep_x; 
....................      
....................     float den = Amax_x*StepinAcc_x; 
....................     float num = (Vmax_x - Vmin_x)*1000000; 
....................     float TbyF = num/den;//tempo em us 
....................      
....................     int i = 0; 
035C4:  MOVLB  5
035C6:  CLRF   x91
035C8:  MOVFF  230,590
035CC:  MOVLB  0
035CE:  RCALL  3178
035D0:  MOVFF  22B,593
035D4:  MOVFF  22A,592
035D8:  MOVFF  229,591
035DC:  MOVFF  228,590
035E0:  MOVFF  03,597
035E4:  MOVFF  02,596
035E8:  MOVFF  01,595
035EC:  MOVFF  00,594
035F0:  RCALL  2F24
035F2:  MOVFF  03,578
035F6:  MOVFF  02,577
035FA:  MOVFF  01,576
035FE:  MOVFF  00,575
03602:  BSF    FD8.1
03604:  MOVFF  223,599
03608:  MOVFF  222,598
0360C:  MOVFF  221,597
03610:  MOVFF  220,596
03614:  MOVFF  227,59D
03618:  MOVFF  226,59C
0361C:  MOVFF  225,59B
03620:  MOVFF  224,59A
03624:  RCALL  31AE
03626:  MOVFF  03,585
0362A:  MOVFF  02,584
0362E:  MOVFF  01,583
03632:  MOVFF  00,582
03636:  MOVFF  03,593
0363A:  MOVFF  02,592
0363E:  MOVFF  01,591
03642:  MOVFF  00,590
03646:  MOVLB  5
03648:  CLRF   x97
0364A:  MOVLW  24
0364C:  MOVWF  x96
0364E:  MOVLW  74
03650:  MOVWF  x95
03652:  MOVLW  92
03654:  MOVWF  x94
03656:  MOVLB  0
03658:  RCALL  2F24
0365A:  MOVFF  03,57C
0365E:  MOVFF  02,57B
03662:  MOVFF  01,57A
03666:  MOVFF  00,579
0366A:  MOVFF  57C,599
0366E:  MOVFF  57B,598
03672:  MOVFF  57A,597
03676:  MOVFF  579,596
0367A:  MOVFF  578,59D
0367E:  MOVFF  577,59C
03682:  MOVFF  576,59B
03686:  MOVFF  575,59A
0368A:  RCALL  301A
0368C:  MOVFF  03,580
03690:  MOVFF  02,57F
03694:  MOVFF  01,57E
03698:  MOVFF  00,57D
0369C:  MOVLB  5
0369E:  CLRF   x81
....................     for(i = 1; i <=StepinAcc_x;i++) 
036A0:  MOVLW  01
036A2:  MOVWF  x81
036A4:  MOVF   x81,W
036A6:  MOVLB  2
036A8:  SUBWF  x30,W
036AA:  BTFSS  FD8.0
036AC:  BRA    39D0
....................     { 
....................         Ts_x[i-1]=(1000000*StepinAcc_x)/(i*(Fmax_x-Fmin_x)+Fmin_x); 
036AE:  MOVLW  01
036B0:  MOVLB  5
036B2:  SUBWF  x81,W
036B4:  MULLW  04
036B6:  MOVF   FF3,W
036B8:  CLRF   03
036BA:  ADDLW  39
036BC:  MOVWF  FE9
036BE:  MOVLW  02
036C0:  ADDWFC 03,W
036C2:  MOVWF  FEA
036C4:  MOVFF  FEA,585
036C8:  MOVFF  FE9,584
036CC:  CLRF   x89
036CE:  MOVLW  0F
036D0:  MOVWF  x88
036D2:  MOVLW  42
036D4:  MOVWF  x87
036D6:  MOVLW  40
036D8:  MOVWF  x86
036DA:  CLRF   x8D
036DC:  CLRF   x8C
036DE:  CLRF   x8B
036E0:  MOVFF  230,58A
036E4:  MOVLB  0
036E6:  RCALL  3426
036E8:  MOVFF  585,FEA
036EC:  MOVFF  584,FE9
036F0:  MOVFF  03,589
036F4:  MOVFF  02,588
036F8:  MOVFF  01,587
036FC:  MOVFF  00,586
03700:  MOVFF  FEA,58B
03704:  MOVFF  FE9,58A
03708:  BSF    FD8.1
0370A:  MOVFF  234,599
0370E:  MOVFF  233,598
03712:  MOVFF  232,597
03716:  MOVFF  231,596
0371A:  MOVFF  238,59D
0371E:  MOVFF  237,59C
03722:  MOVFF  236,59B
03726:  MOVFF  235,59A
0372A:  RCALL  31AE
0372C:  MOVFF  58B,FEA
03730:  MOVFF  58A,FE9
03734:  MOVFF  03,58F
03738:  MOVFF  02,58E
0373C:  MOVFF  01,58D
03740:  MOVFF  00,58C
03744:  MOVLB  5
03746:  CLRF   x91
03748:  MOVFF  581,590
0374C:  MOVLB  0
0374E:  RCALL  3178
03750:  MOVFF  03,593
03754:  MOVFF  02,592
03758:  MOVFF  01,591
0375C:  MOVFF  00,590
03760:  MOVFF  58F,597
03764:  MOVFF  58E,596
03768:  MOVFF  58D,595
0376C:  MOVFF  58C,594
03770:  CALL   2F24
03774:  MOVFF  03,593
03778:  MOVFF  02,592
0377C:  MOVFF  01,591
03780:  MOVFF  00,590
03784:  MOVFF  FEA,595
03788:  MOVFF  FE9,594
0378C:  BCF    FD8.1
0378E:  MOVFF  03,599
03792:  MOVFF  02,598
03796:  MOVFF  01,597
0379A:  MOVFF  00,596
0379E:  MOVFF  238,59D
037A2:  MOVFF  237,59C
037A6:  MOVFF  236,59B
037AA:  MOVFF  235,59A
037AE:  RCALL  31AE
037B0:  MOVFF  595,FEA
037B4:  MOVFF  594,FE9
037B8:  MOVFF  03,593
037BC:  MOVFF  02,592
037C0:  MOVFF  01,591
037C4:  MOVFF  00,590
037C8:  MOVFF  589,599
037CC:  MOVFF  588,598
037D0:  MOVFF  587,597
037D4:  MOVFF  586,596
037D8:  RCALL  3482
037DA:  MOVFF  03,599
037DE:  MOVFF  02,598
037E2:  MOVFF  01,597
037E6:  MOVFF  00,596
037EA:  MOVFF  593,59D
037EE:  MOVFF  592,59C
037F2:  MOVFF  591,59B
037F6:  MOVFF  590,59A
037FA:  RCALL  301A
037FC:  MOVFF  03,599
03800:  MOVFF  02,598
03804:  MOVFF  01,597
03808:  MOVFF  00,596
0380C:  RCALL  34BA
0380E:  MOVFF  00,FEF
03812:  MOVFF  01,FEC
03816:  MOVFF  02,FEC
0381A:  MOVFF  03,FEC
....................         StepbyF_x[i-1] = 2*TbyF/Ts_x[i-1]; 
0381E:  MOVLW  01
03820:  MOVLB  5
03822:  SUBWF  x81,W
03824:  MULLW  04
03826:  MOVF   FF3,W
03828:  CLRF   03
0382A:  ADDLW  89
0382C:  MOVWF  01
0382E:  MOVLW  02
03830:  ADDWFC 03,F
03832:  MOVFF  01,582
03836:  MOVFF  03,583
0383A:  CLRF   x93
0383C:  CLRF   x92
0383E:  CLRF   x91
03840:  MOVLW  80
03842:  MOVWF  x90
03844:  MOVFF  580,597
03848:  MOVFF  57F,596
0384C:  MOVFF  57E,595
03850:  MOVFF  57D,594
03854:  MOVLB  0
03856:  CALL   2F24
0385A:  MOVFF  03,587
0385E:  MOVFF  02,586
03862:  MOVFF  01,585
03866:  MOVFF  00,584
0386A:  MOVLW  01
0386C:  MOVLB  5
0386E:  SUBWF  x81,W
03870:  MULLW  04
03872:  MOVF   FF3,W
03874:  CLRF   03
03876:  ADDLW  39
03878:  MOVWF  FE9
0387A:  MOVLW  02
0387C:  ADDWFC 03,W
0387E:  MOVWF  FEA
03880:  MOVFF  FEF,00
03884:  MOVFF  FEC,01
03888:  MOVFF  FEC,02
0388C:  MOVFF  FEC,03
03890:  MOVFF  03,599
03894:  MOVFF  02,598
03898:  MOVFF  01,597
0389C:  MOVFF  00,596
038A0:  MOVLB  0
038A2:  RCALL  3482
038A4:  MOVFF  587,599
038A8:  MOVFF  586,598
038AC:  MOVFF  585,597
038B0:  MOVFF  584,596
038B4:  MOVFF  03,59D
038B8:  MOVFF  02,59C
038BC:  MOVFF  01,59B
038C0:  MOVFF  00,59A
038C4:  CALL   301A
038C8:  MOVFF  03,599
038CC:  MOVFF  02,598
038D0:  MOVFF  01,597
038D4:  MOVFF  00,596
038D8:  RCALL  34BA
038DA:  MOVFF  583,FEA
038DE:  MOVFF  582,FE9
038E2:  MOVFF  00,FEF
038E6:  MOVFF  01,FEC
038EA:  MOVFF  02,FEC
038EE:  MOVFF  03,FEC
....................         total_acc_step_x += StepbyF_x[i-1]; 
038F2:  MOVLW  01
038F4:  MOVLB  5
038F6:  SUBWF  x81,W
038F8:  MULLW  04
038FA:  MOVF   FF3,W
038FC:  CLRF   03
038FE:  ADDLW  89
03900:  MOVWF  FE9
03902:  MOVLW  02
03904:  ADDWFC 03,W
03906:  MOVWF  FEA
03908:  MOVFF  FEF,00
0390C:  MOVFF  FEC,01
03910:  MOVFF  FEC,02
03914:  MOVFF  FEC,03
03918:  MOVF   00,W
0391A:  MOVLB  2
0391C:  ADDWF  xD9,F
0391E:  MOVF   01,W
03920:  ADDWFC xDA,F
....................         Ts_x[i-1] = Ts_x[i-1]/(8*0.2*2);//Tempo/(prescale*ciclodemaquina*metadedociclo) 
03922:  MOVLW  01
03924:  MOVLB  5
03926:  SUBWF  x81,W
03928:  MULLW  04
0392A:  MOVF   FF3,W
0392C:  CLRF   03
0392E:  ADDLW  39
03930:  MOVWF  01
03932:  MOVLW  02
03934:  ADDWFC 03,F
03936:  MOVFF  01,582
0393A:  MOVFF  03,583
0393E:  MOVLW  01
03940:  SUBWF  x81,W
03942:  MULLW  04
03944:  MOVF   FF3,W
03946:  CLRF   03
03948:  ADDLW  39
0394A:  MOVWF  FE9
0394C:  MOVLW  02
0394E:  ADDWFC 03,W
03950:  MOVWF  FEA
03952:  MOVFF  FEF,584
03956:  MOVFF  FEC,585
0395A:  MOVFF  FEC,586
0395E:  MOVFF  FEC,587
03962:  MOVFF  587,599
03966:  MOVFF  586,598
0396A:  MOVFF  585,597
0396E:  MOVFF  584,596
03972:  MOVLB  0
03974:  RCALL  3482
03976:  MOVFF  03,599
0397A:  MOVFF  02,598
0397E:  MOVFF  01,597
03982:  MOVFF  00,596
03986:  MOVLW  CD
03988:  MOVLB  5
0398A:  MOVWF  x9D
0398C:  MOVLW  CC
0398E:  MOVWF  x9C
03990:  MOVLW  4C
03992:  MOVWF  x9B
03994:  MOVLW  80
03996:  MOVWF  x9A
03998:  MOVLB  0
0399A:  CALL   301A
0399E:  MOVFF  03,599
039A2:  MOVFF  02,598
039A6:  MOVFF  01,597
039AA:  MOVFF  00,596
039AE:  RCALL  34BA
039B0:  MOVFF  583,FEA
039B4:  MOVFF  582,FE9
039B8:  MOVFF  00,FEF
039BC:  MOVFF  01,FEC
039C0:  MOVFF  02,FEC
039C4:  MOVFF  03,FEC
039C8:  MOVLB  5
039CA:  INCF   x81,F
039CC:  BRA    36A4
039CE:  MOVLB  2
....................     } 
039D0:  MOVLB  0
039D2:  GOTO   D7D6 (RETURN)
.................... } 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Movimento Motor"> 
.................... void motor_stop_x(){ 
....................     step_no_x = step_down_x; 
....................     ramp_sts_x = ramp_down; 
.................... } 
....................  
.................... void motor_disable_x(){ 
....................     output_high(enable_x); 
....................     disable_interrupts(INT_TIMER0); 
.................... } 
....................  
.................... void motor_run_x(int32 pos_new, int velocidade) { // set up to drive motor to pos_new (absolute step#) 
....................      
....................     vel_x = velocidade; 
*
05968:  MOVFF  581,2EA
....................     total_acc_step_x = 0; 
0596C:  MOVLB  2
0596E:  CLRF   xDA
05970:  CLRF   xD9
....................      
....................     /*Obtem a Direo do motor*/ 
....................     if (pos_new < motor_pos_x)  
05972:  MOVFF  204,00
05976:  MOVFF  205,01
0597A:  CLRF   02
0597C:  CLRF   03
0597E:  BTFSS  x05.7
05980:  BRA    5986
05982:  DECF   02,F
05984:  DECF   03,F
05986:  BTFSC  03.7
05988:  BRA    59F8
0598A:  MOVLB  5
0598C:  MOVF   x80,W
0598E:  SUBWF  03,W
05990:  BTFSC  FD8.0
05992:  BRA    5998
05994:  MOVLB  2
05996:  BRA    59F8
05998:  BNZ   59C2
0599A:  MOVF   x7F,W
0599C:  SUBWF  02,W
0599E:  BTFSC  FD8.0
059A0:  BRA    59A6
059A2:  MOVLB  2
059A4:  BRA    59F8
059A6:  BNZ   59C2
059A8:  MOVF   x7E,W
059AA:  SUBWF  01,W
059AC:  BTFSC  FD8.0
059AE:  BRA    59B4
059B0:  MOVLB  2
059B2:  BRA    59F8
059B4:  BNZ   59C2
059B6:  MOVF   00,W
059B8:  SUBWF  x7D,W
059BA:  BTFSS  FD8.0
059BC:  BRA    59C2
059BE:  MOVLB  2
059C0:  BRA    59F8
....................     { 
....................         output_low(dir_x); 
059C2:  BCF    F95.1
059C4:  BCF    F8C.1
....................         move_x = motor_pos_x - pos_new; 
059C6:  MOVFF  204,00
059CA:  MOVFF  205,01
059CE:  CLRF   02
059D0:  CLRF   03
059D2:  BTFSS  01.7
059D4:  BRA    59DA
059D6:  DECF   02,F
059D8:  DECF   03,F
059DA:  MOVF   x7D,W
059DC:  SUBWF  00,F
059DE:  MOVF   x7E,W
059E0:  SUBWFB 01,F
059E2:  MOVF   x7F,W
059E4:  SUBWFB 02,F
059E6:  MOVF   x80,W
059E8:  SUBWFB 03,F
059EA:  MOVFF  01,2E2
059EE:  MOVFF  00,2E1
....................         pos_inc_x = -1; 
059F2:  MOVLB  2
059F4:  SETF   xDB
....................     } else if (pos_new != motor_pos_x) { 
059F6:  BRA    5A68
059F8:  MOVFF  204,00
059FC:  MOVFF  205,01
05A00:  CLRF   02
05A02:  CLRF   03
05A04:  BTFSS  x05.7
05A06:  BRA    5A0C
05A08:  DECF   02,F
05A0A:  DECF   03,F
05A0C:  MOVF   00,W
05A0E:  MOVLB  5
05A10:  SUBWF  x7D,W
05A12:  BNZ   5A26
05A14:  MOVF   01,W
05A16:  SUBWF  x7E,W
05A18:  BNZ   5A26
05A1A:  MOVF   02,W
05A1C:  SUBWF  x7F,W
05A1E:  BNZ   5A26
05A20:  MOVF   03,W
05A22:  SUBWF  x80,W
05A24:  BZ    5A64
....................         output_high(dir_x); 
05A26:  BCF    F95.1
05A28:  BSF    F8C.1
....................         move_x = pos_new - motor_pos_x; 
05A2A:  MOVFF  204,00
05A2E:  MOVFF  205,01
05A32:  CLRF   02
05A34:  CLRF   03
05A36:  BTFSS  01.7
05A38:  BRA    5A3E
05A3A:  DECF   02,F
05A3C:  DECF   03,F
05A3E:  MOVF   00,W
05A40:  SUBWF  x7D,W
05A42:  MOVWF  00
05A44:  MOVF   01,W
05A46:  SUBWFB x7E,W
05A48:  MOVWF  01
05A4A:  MOVF   02,W
05A4C:  SUBWFB x7F,W
05A4E:  MOVF   03,W
05A50:  SUBWFB x80,W
05A52:  MOVFF  01,2E2
05A56:  MOVFF  00,2E1
....................         pos_inc_x = 1; 
05A5A:  MOVLW  01
05A5C:  MOVLB  2
05A5E:  MOVWF  xDB
....................     } else return; 
05A60:  BRA    5A68
05A62:  MOVLB  5
05A64:  BRA    5B4A
05A66:  MOVLB  2
....................      
....................     /*Calcula a quantidade de passos para chegar na velocidade desejada*/ 
....................     for(int j = 0; j <= velocidade;j++) 
05A68:  MOVLB  5
05A6A:  CLRF   x82
05A6C:  MOVF   x82,W
05A6E:  SUBWF  x81,W
05A70:  BNC   5AA4
....................     { 
....................         total_acc_step_x += StepbyF_x[j]; 
05A72:  MOVF   x82,W
05A74:  MULLW  04
05A76:  MOVF   FF3,W
05A78:  CLRF   03
05A7A:  ADDLW  89
05A7C:  MOVWF  FE9
05A7E:  MOVLW  02
05A80:  ADDWFC 03,W
05A82:  MOVWF  FEA
05A84:  MOVFF  FEF,00
05A88:  MOVFF  FEC,01
05A8C:  MOVFF  FEC,02
05A90:  MOVFF  FEC,03
05A94:  MOVF   00,W
05A96:  MOVLB  2
05A98:  ADDWF  xD9,F
05A9A:  MOVF   01,W
05A9C:  ADDWFC xDA,F
05A9E:  MOVLB  5
05AA0:  INCF   x82,F
05AA2:  BRA    5A6C
....................     } 
....................     /*Define Formato da Rampa(Trapezio,triangulo ou constante)*/ 
....................     if (move_x > 2 * total_acc_step_x) { 
05AA4:  BCF    FD8.0
05AA6:  MOVLB  2
05AA8:  RLCF   xD9,W
05AAA:  MOVWF  02
05AAC:  RLCF   xDA,W
05AAE:  MOVWF  03
05AB0:  MOVFF  02,01
05AB4:  MOVF   03,W
05AB6:  SUBWF  xE2,W
05AB8:  BNC   5AD8
05ABA:  BNZ   5AC2
05ABC:  MOVF   xE1,W
05ABE:  SUBWF  01,W
05AC0:  BC    5AD8
....................         midpt_x = total_acc_step_x; 
05AC2:  MOVFF  2DA,2E4
05AC6:  MOVFF  2D9,2E3
....................         step_down_x = move_x - total_acc_step_x; 
05ACA:  MOVF   xD9,W
05ACC:  SUBWF  xE1,W
05ACE:  MOVWF  xDF
05AD0:  MOVF   xDA,W
05AD2:  SUBWFB xE2,W
05AD4:  MOVWF  xE0
....................     }  
05AD6:  BRA    5B02
....................     else 
....................     { 
....................         midpt_x = (move_x - 1) >> 1; 
05AD8:  MOVLW  01
05ADA:  SUBWF  xE1,W
05ADC:  MOVLB  5
05ADE:  MOVWF  x83
05AE0:  MOVLW  00
05AE2:  MOVLB  2
05AE4:  SUBWFB xE2,W
05AE6:  MOVLB  5
05AE8:  MOVWF  x84
05AEA:  BCF    FD8.0
05AEC:  RRCF   x84,W
05AEE:  MOVLB  2
05AF0:  MOVWF  xE4
05AF2:  MOVLB  5
05AF4:  RRCF   x83,W
05AF6:  MOVLB  2
05AF8:  MOVWF  xE3
....................         step_down_x = midpt_x; 
05AFA:  MOVFF  2E4,2E0
05AFE:  MOVFF  2E3,2DF
....................     } 
....................     step_no_x = 0; 
05B02:  CLRF   xDE
05B04:  CLRF   xDD
....................     step_acumulado_x = 0; 
05B06:  CLRF   xE8
05B08:  CLRF   xE7
05B0A:  CLRF   xE6
05B0C:  CLRF   xE5
....................     atual_frequencia_x = 0; 
05B0E:  CLRF   xE9
....................     ramp_sts_x = ramp_up; // start ramp state-machine 
05B10:  MOVLW  01
05B12:  MOVWF  xDC
....................     run_flg_x = TRUE; 
05B14:  BSF    x0C.5
....................     output_low(enable_x); 
05B16:  BCF    F95.0
05B18:  BCF    F8C.0
....................     setup_timer_0(T0_INTERNAL | T0_DIV_8); 
05B1A:  MOVLW  82
05B1C:  MOVWF  FD5
....................     set_timer0(65535 - Ts_x[0]); 
05B1E:  MOVLW  FF
05B20:  BSF    FD8.0
05B22:  SUBFWB x39,W
05B24:  MOVLB  5
05B26:  MOVWF  x83
05B28:  MOVLW  FF
05B2A:  MOVLB  2
05B2C:  SUBFWB x3A,W
05B2E:  MOVLB  5
05B30:  MOVWF  x84
05B32:  MOVLW  00
05B34:  MOVLB  2
05B36:  SUBFWB x3B,W
05B38:  MOVLW  00
05B3A:  MOVLB  2
05B3C:  SUBFWB x3C,W
05B3E:  MOVLB  5
05B40:  MOVFF  584,FD7
05B44:  MOVFF  583,FD6
....................     enable_interrupts(INT_TIMER0); 
05B48:  BSF    FF2.5
05B4A:  MOVLB  0
05B4C:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_subida_x() { 
....................     if (atual_frequencia_x == 0) { 
*
01272:  MOVLB  2
01274:  MOVF   xE9,F
01276:  BTFSS  FD8.2
01278:  BRA    13A8
....................         if (step_no_x == StepbyF_x[atual_frequencia_x]) { 
0127A:  MOVF   xE9,W
0127C:  MULLW  04
0127E:  MOVF   FF3,W
01280:  CLRF   03
01282:  ADDLW  89
01284:  MOVWF  FE9
01286:  MOVLW  02
01288:  ADDWFC 03,W
0128A:  MOVWF  FEA
0128C:  MOVFF  FEF,00
01290:  MOVFF  FEC,01
01294:  MOVFF  FEC,02
01298:  MOVFF  FEC,03
0129C:  MOVF   00,W
0129E:  SUBWF  xDD,W
012A0:  BNZ   1362
012A2:  MOVF   01,W
012A4:  SUBWF  xDE,W
012A6:  BNZ   1362
012A8:  MOVF   02,F
012AA:  BNZ   1362
012AC:  MOVF   03,F
012AE:  BNZ   1362
....................             step_acumulado_x += StepbyF_x[atual_frequencia_x] + StepbyF_x[atual_frequencia_x + 1]; 
012B0:  MOVF   xE9,W
012B2:  MULLW  04
012B4:  MOVF   FF3,W
012B6:  CLRF   03
012B8:  ADDLW  89
012BA:  MOVWF  FE9
012BC:  MOVLW  02
012BE:  ADDWFC 03,W
012C0:  MOVWF  FEA
012C2:  MOVFF  FEF,5A6
012C6:  MOVFF  FEC,5A7
012CA:  MOVFF  FEC,5A8
012CE:  MOVFF  FEC,5A9
012D2:  MOVLW  01
012D4:  ADDWF  xE9,W
012D6:  MULLW  04
012D8:  MOVF   FF3,W
012DA:  CLRF   03
012DC:  ADDLW  89
012DE:  MOVWF  FE9
012E0:  MOVLW  02
012E2:  ADDWFC 03,W
012E4:  MOVWF  FEA
012E6:  MOVFF  FEF,00
012EA:  MOVFF  FEC,01
012EE:  MOVFF  FEC,02
012F2:  MOVFF  FEC,03
012F6:  MOVLB  5
012F8:  MOVF   xA6,W
012FA:  ADDWF  00,F
012FC:  MOVF   xA7,W
012FE:  ADDWFC 01,F
01300:  MOVF   xA8,W
01302:  ADDWFC 02,F
01304:  MOVF   xA9,W
01306:  ADDWFC 03,F
01308:  MOVF   00,W
0130A:  MOVLB  2
0130C:  ADDWF  xE5,F
0130E:  MOVF   01,W
01310:  ADDWFC xE6,F
01312:  MOVF   02,W
01314:  ADDWFC xE7,F
01316:  MOVF   03,W
01318:  ADDWFC xE8,F
....................             atual_frequencia_x++; 
0131A:  INCF   xE9,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
0131C:  MOVF   xE9,W
0131E:  MULLW  04
01320:  MOVF   FF3,W
01322:  CLRF   03
01324:  ADDLW  39
01326:  MOVWF  FE9
01328:  MOVLW  02
0132A:  ADDWFC 03,W
0132C:  MOVWF  FEA
0132E:  MOVFF  FEF,00
01332:  MOVFF  FEC,01
01336:  MOVFF  FEC,02
0133A:  MOVFF  FEC,03
0133E:  MOVLW  FF
01340:  BSF    FD8.0
01342:  SUBFWB 00,W
01344:  MOVLB  5
01346:  MOVWF  xA6
01348:  MOVLW  FF
0134A:  SUBFWB 01,W
0134C:  MOVWF  xA7
0134E:  MOVLW  00
01350:  SUBFWB 02,W
01352:  MOVLW  00
01354:  SUBFWB 03,W
01356:  MOVFF  5A7,FD7
0135A:  MOVFF  5A6,FD6
....................         } else { 
0135E:  BRA    13A4
01360:  MOVLB  2
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
01362:  MOVF   xE9,W
01364:  MULLW  04
01366:  MOVF   FF3,W
01368:  CLRF   03
0136A:  ADDLW  39
0136C:  MOVWF  FE9
0136E:  MOVLW  02
01370:  ADDWFC 03,W
01372:  MOVWF  FEA
01374:  MOVFF  FEF,00
01378:  MOVFF  FEC,01
0137C:  MOVFF  FEC,02
01380:  MOVFF  FEC,03
01384:  MOVLW  FF
01386:  BSF    FD8.0
01388:  SUBFWB 00,W
0138A:  MOVLB  5
0138C:  MOVWF  xA6
0138E:  MOVLW  FF
01390:  SUBFWB 01,W
01392:  MOVWF  xA7
01394:  MOVLW  00
01396:  SUBFWB 02,W
01398:  MOVLW  00
0139A:  SUBFWB 03,W
0139C:  MOVFF  5A7,FD7
013A0:  MOVFF  5A6,FD6
....................         } 
....................     } else if (atual_frequencia_x == vel_x) { 
013A4:  BRA    14C4
013A6:  MOVLB  2
013A8:  MOVF   xEA,W
013AA:  SUBWF  xE9,W
013AC:  BNZ   13F4
....................         set_timer0(65535 - Ts_x[atual_frequencia_x]); 
013AE:  MOVF   xE9,W
013B0:  MULLW  04
013B2:  MOVF   FF3,W
013B4:  CLRF   03
013B6:  ADDLW  39
013B8:  MOVWF  FE9
013BA:  MOVLW  02
013BC:  ADDWFC 03,W
013BE:  MOVWF  FEA
013C0:  MOVFF  FEF,00
013C4:  MOVFF  FEC,01
013C8:  MOVFF  FEC,02
013CC:  MOVFF  FEC,03
013D0:  MOVLW  FF
013D2:  BSF    FD8.0
013D4:  SUBFWB 00,W
013D6:  MOVLB  5
013D8:  MOVWF  xA6
013DA:  MOVLW  FF
013DC:  SUBFWB 01,W
013DE:  MOVWF  xA7
013E0:  MOVLW  00
013E2:  SUBFWB 02,W
013E4:  MOVLW  00
013E6:  SUBFWB 03,W
013E8:  MOVFF  5A7,FD7
013EC:  MOVFF  5A6,FD6
....................     } else { 
013F0:  BRA    14C4
013F2:  MOVLB  2
....................         if (step_no_x == step_acumulado_x) { 
013F4:  MOVF   xE5,W
013F6:  SUBWF  xDD,W
013F8:  BNZ   1482
013FA:  MOVF   xE6,W
013FC:  SUBWF  xDE,W
013FE:  BNZ   1482
01400:  MOVF   xE7,F
01402:  BNZ   1482
01404:  MOVF   xE8,F
01406:  BNZ   1482
....................             atual_frequencia_x++; 
01408:  INCF   xE9,F
....................             step_acumulado_x += StepbyF_x[atual_frequencia_x]; 
0140A:  MOVF   xE9,W
0140C:  MULLW  04
0140E:  MOVF   FF3,W
01410:  CLRF   03
01412:  ADDLW  89
01414:  MOVWF  FE9
01416:  MOVLW  02
01418:  ADDWFC 03,W
0141A:  MOVWF  FEA
0141C:  MOVFF  FEF,00
01420:  MOVFF  FEC,01
01424:  MOVFF  FEC,02
01428:  MOVFF  FEC,03
0142C:  MOVF   00,W
0142E:  ADDWF  xE5,F
01430:  MOVF   01,W
01432:  ADDWFC xE6,F
01434:  MOVF   02,W
01436:  ADDWFC xE7,F
01438:  MOVF   03,W
0143A:  ADDWFC xE8,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
0143C:  MOVF   xE9,W
0143E:  MULLW  04
01440:  MOVF   FF3,W
01442:  CLRF   03
01444:  ADDLW  39
01446:  MOVWF  FE9
01448:  MOVLW  02
0144A:  ADDWFC 03,W
0144C:  MOVWF  FEA
0144E:  MOVFF  FEF,00
01452:  MOVFF  FEC,01
01456:  MOVFF  FEC,02
0145A:  MOVFF  FEC,03
0145E:  MOVLW  FF
01460:  BSF    FD8.0
01462:  SUBFWB 00,W
01464:  MOVLB  5
01466:  MOVWF  xA6
01468:  MOVLW  FF
0146A:  SUBFWB 01,W
0146C:  MOVWF  xA7
0146E:  MOVLW  00
01470:  SUBFWB 02,W
01472:  MOVLW  00
01474:  SUBFWB 03,W
01476:  MOVFF  5A7,FD7
0147A:  MOVFF  5A6,FD6
....................         } else { 
0147E:  BRA    14C4
01480:  MOVLB  2
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
01482:  MOVF   xE9,W
01484:  MULLW  04
01486:  MOVF   FF3,W
01488:  CLRF   03
0148A:  ADDLW  39
0148C:  MOVWF  FE9
0148E:  MOVLW  02
01490:  ADDWFC 03,W
01492:  MOVWF  FEA
01494:  MOVFF  FEF,00
01498:  MOVFF  FEC,01
0149C:  MOVFF  FEC,02
014A0:  MOVFF  FEC,03
014A4:  MOVLW  FF
014A6:  BSF    FD8.0
014A8:  SUBFWB 00,W
014AA:  MOVLB  5
014AC:  MOVWF  xA6
014AE:  MOVLW  FF
014B0:  SUBFWB 01,W
014B2:  MOVWF  xA7
014B4:  MOVLW  00
014B6:  SUBFWB 02,W
014B8:  MOVLW  00
014BA:  SUBFWB 03,W
014BC:  MOVFF  5A7,FD7
014C0:  MOVFF  5A6,FD6
....................         } 
....................         break; 
....................     } 
014C4:  MOVLB  0
014C6:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_descida_x() { 
....................     if (atual_frequencia_x == 0) { 
014C8:  MOVLB  2
014CA:  MOVF   xE9,F
014CC:  BNZ   1514
....................         set_timer0(65535 - Ts_x[atual_frequencia_x]); 
014CE:  MOVF   xE9,W
014D0:  MULLW  04
014D2:  MOVF   FF3,W
014D4:  CLRF   03
014D6:  ADDLW  39
014D8:  MOVWF  FE9
014DA:  MOVLW  02
014DC:  ADDWFC 03,W
014DE:  MOVWF  FEA
014E0:  MOVFF  FEF,00
014E4:  MOVFF  FEC,01
014E8:  MOVFF  FEC,02
014EC:  MOVFF  FEC,03
014F0:  MOVLW  FF
014F2:  BSF    FD8.0
014F4:  SUBFWB 00,W
014F6:  MOVLB  5
014F8:  MOVWF  xA6
014FA:  MOVLW  FF
014FC:  SUBFWB 01,W
014FE:  MOVWF  xA7
01500:  MOVLW  00
01502:  SUBFWB 02,W
01504:  MOVLW  00
01506:  SUBFWB 03,W
01508:  MOVFF  5A7,FD7
0150C:  MOVFF  5A6,FD6
....................     }  
01510:  BRA    174C
01512:  MOVLB  2
....................     else if (atual_frequencia_x == vel_x) { 
01514:  MOVF   xEA,W
01516:  SUBWF  xE9,W
01518:  BTFSS  FD8.2
0151A:  BRA    167C
....................         if (step_no_x == (step_down_x + StepbyF_x[atual_frequencia_x])) { 
0151C:  MOVF   xE9,W
0151E:  MULLW  04
01520:  MOVF   FF3,W
01522:  CLRF   03
01524:  ADDLW  89
01526:  MOVWF  FE9
01528:  MOVLW  02
0152A:  ADDWFC 03,W
0152C:  MOVWF  FEA
0152E:  MOVFF  FEF,00
01532:  MOVFF  FEC,01
01536:  MOVFF  FEC,02
0153A:  MOVFF  FEC,03
0153E:  MOVF   xDF,W
01540:  ADDWF  00,F
01542:  MOVF   xE0,W
01544:  ADDWFC 01,F
01546:  MOVLW  00
01548:  ADDWFC 02,F
0154A:  ADDWFC 03,F
0154C:  MOVF   00,W
0154E:  SUBWF  xDD,W
01550:  BNZ   1636
01552:  MOVF   01,W
01554:  SUBWF  xDE,W
01556:  BNZ   1636
01558:  MOVF   02,F
0155A:  BNZ   1636
0155C:  MOVF   03,F
0155E:  BNZ   1636
....................             step_acumulado_x = step_down_x + StepbyF_x[atual_frequencia_x] + StepbyF_x[atual_frequencia_x - 1]; 
01560:  MOVF   xE9,W
01562:  MULLW  04
01564:  MOVF   FF3,W
01566:  CLRF   03
01568:  ADDLW  89
0156A:  MOVWF  FE9
0156C:  MOVLW  02
0156E:  ADDWFC 03,W
01570:  MOVWF  FEA
01572:  MOVFF  FEF,00
01576:  MOVFF  FEC,01
0157A:  MOVFF  FEC,02
0157E:  MOVFF  FEC,03
01582:  MOVF   00,W
01584:  ADDWF  xDF,W
01586:  MOVLB  5
01588:  MOVWF  xA6
0158A:  MOVF   01,W
0158C:  MOVLB  2
0158E:  ADDWFC xE0,W
01590:  MOVLB  5
01592:  MOVWF  xA7
01594:  MOVLW  00
01596:  ADDWFC 02,W
01598:  MOVWF  xA8
0159A:  MOVLW  00
0159C:  ADDWFC 03,W
0159E:  MOVWF  xA9
015A0:  MOVLW  01
015A2:  MOVLB  2
015A4:  SUBWF  xE9,W
015A6:  MULLW  04
015A8:  MOVF   FF3,W
015AA:  CLRF   03
015AC:  ADDLW  89
015AE:  MOVWF  FE9
015B0:  MOVLW  02
015B2:  ADDWFC 03,W
015B4:  MOVWF  FEA
015B6:  MOVFF  FEF,00
015BA:  MOVFF  FEC,01
015BE:  MOVFF  FEC,02
015C2:  MOVFF  FEC,03
015C6:  MOVF   00,W
015C8:  MOVLB  5
015CA:  ADDWF  xA6,W
015CC:  MOVLB  2
015CE:  MOVWF  xE5
015D0:  MOVF   01,W
015D2:  MOVLB  5
015D4:  ADDWFC xA7,W
015D6:  MOVLB  2
015D8:  MOVWF  xE6
015DA:  MOVF   02,W
015DC:  MOVLB  5
015DE:  ADDWFC xA8,W
015E0:  MOVLB  2
015E2:  MOVWF  xE7
015E4:  MOVF   03,W
015E6:  MOVLB  5
015E8:  ADDWFC xA9,W
015EA:  MOVLB  2
015EC:  MOVWF  xE8
....................             atual_frequencia_x--; 
015EE:  DECF   xE9,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
015F0:  MOVF   xE9,W
015F2:  MULLW  04
015F4:  MOVF   FF3,W
015F6:  CLRF   03
015F8:  ADDLW  39
015FA:  MOVWF  FE9
015FC:  MOVLW  02
015FE:  ADDWFC 03,W
01600:  MOVWF  FEA
01602:  MOVFF  FEF,00
01606:  MOVFF  FEC,01
0160A:  MOVFF  FEC,02
0160E:  MOVFF  FEC,03
01612:  MOVLW  FF
01614:  BSF    FD8.0
01616:  SUBFWB 00,W
01618:  MOVLB  5
0161A:  MOVWF  xA6
0161C:  MOVLW  FF
0161E:  SUBFWB 01,W
01620:  MOVWF  xA7
01622:  MOVLW  00
01624:  SUBFWB 02,W
01626:  MOVLW  00
01628:  SUBFWB 03,W
0162A:  MOVFF  5A7,FD7
0162E:  MOVFF  5A6,FD6
....................         } else { 
01632:  BRA    1678
01634:  MOVLB  2
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
01636:  MOVF   xE9,W
01638:  MULLW  04
0163A:  MOVF   FF3,W
0163C:  CLRF   03
0163E:  ADDLW  39
01640:  MOVWF  FE9
01642:  MOVLW  02
01644:  ADDWFC 03,W
01646:  MOVWF  FEA
01648:  MOVFF  FEF,00
0164C:  MOVFF  FEC,01
01650:  MOVFF  FEC,02
01654:  MOVFF  FEC,03
01658:  MOVLW  FF
0165A:  BSF    FD8.0
0165C:  SUBFWB 00,W
0165E:  MOVLB  5
01660:  MOVWF  xA6
01662:  MOVLW  FF
01664:  SUBFWB 01,W
01666:  MOVWF  xA7
01668:  MOVLW  00
0166A:  SUBFWB 02,W
0166C:  MOVLW  00
0166E:  SUBFWB 03,W
01670:  MOVFF  5A7,FD7
01674:  MOVFF  5A6,FD6
....................         } 
....................     } else { 
01678:  BRA    174C
0167A:  MOVLB  2
....................         if (step_no_x == step_acumulado_x) { 
0167C:  MOVF   xE5,W
0167E:  SUBWF  xDD,W
01680:  BNZ   170A
01682:  MOVF   xE6,W
01684:  SUBWF  xDE,W
01686:  BNZ   170A
01688:  MOVF   xE7,F
0168A:  BNZ   170A
0168C:  MOVF   xE8,F
0168E:  BNZ   170A
....................             atual_frequencia_x--; 
01690:  DECF   xE9,F
....................             step_acumulado_x += StepbyF_x[atual_frequencia_x]; 
01692:  MOVF   xE9,W
01694:  MULLW  04
01696:  MOVF   FF3,W
01698:  CLRF   03
0169A:  ADDLW  89
0169C:  MOVWF  FE9
0169E:  MOVLW  02
016A0:  ADDWFC 03,W
016A2:  MOVWF  FEA
016A4:  MOVFF  FEF,00
016A8:  MOVFF  FEC,01
016AC:  MOVFF  FEC,02
016B0:  MOVFF  FEC,03
016B4:  MOVF   00,W
016B6:  ADDWF  xE5,F
016B8:  MOVF   01,W
016BA:  ADDWFC xE6,F
016BC:  MOVF   02,W
016BE:  ADDWFC xE7,F
016C0:  MOVF   03,W
016C2:  ADDWFC xE8,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
016C4:  MOVF   xE9,W
016C6:  MULLW  04
016C8:  MOVF   FF3,W
016CA:  CLRF   03
016CC:  ADDLW  39
016CE:  MOVWF  FE9
016D0:  MOVLW  02
016D2:  ADDWFC 03,W
016D4:  MOVWF  FEA
016D6:  MOVFF  FEF,00
016DA:  MOVFF  FEC,01
016DE:  MOVFF  FEC,02
016E2:  MOVFF  FEC,03
016E6:  MOVLW  FF
016E8:  BSF    FD8.0
016EA:  SUBFWB 00,W
016EC:  MOVLB  5
016EE:  MOVWF  xA6
016F0:  MOVLW  FF
016F2:  SUBFWB 01,W
016F4:  MOVWF  xA7
016F6:  MOVLW  00
016F8:  SUBFWB 02,W
016FA:  MOVLW  00
016FC:  SUBFWB 03,W
016FE:  MOVFF  5A7,FD7
01702:  MOVFF  5A6,FD6
....................         } else { 
01706:  BRA    174C
01708:  MOVLB  2
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
0170A:  MOVF   xE9,W
0170C:  MULLW  04
0170E:  MOVF   FF3,W
01710:  CLRF   03
01712:  ADDLW  39
01714:  MOVWF  FE9
01716:  MOVLW  02
01718:  ADDWFC 03,W
0171A:  MOVWF  FEA
0171C:  MOVFF  FEF,00
01720:  MOVFF  FEC,01
01724:  MOVFF  FEC,02
01728:  MOVFF  FEC,03
0172C:  MOVLW  FF
0172E:  BSF    FD8.0
01730:  SUBFWB 00,W
01732:  MOVLB  5
01734:  MOVWF  xA6
01736:  MOVLW  FF
01738:  SUBFWB 01,W
0173A:  MOVWF  xA7
0173C:  MOVLW  00
0173E:  SUBFWB 02,W
01740:  MOVLW  00
01742:  SUBFWB 03,W
01744:  MOVFF  5A7,FD7
01748:  MOVFF  5A6,FD6
....................         } 
....................     } 
0174C:  MOVLB  0
0174E:  GOTO   17A6 (RETURN)
.................... } 
....................  
.................... void movimenta_eixo_x() { 
....................   
....................     switch (ramp_sts_x) { 
01752:  MOVLB  2
01754:  MOVF   xDC,W
01756:  XORLW  01
01758:  MOVLB  0
0175A:  BZ    1766
0175C:  XORLW  02
0175E:  BZ    17A4
01760:  XORLW  01
01762:  BZ    17C0
01764:  BRA    17DE
....................         case ramp_up: // accel 
....................             proximo_valor_subida_x(); 
01766:  RCALL  1272
....................             if (step_no_x == midpt_x) { // midpoint: decel 
01768:  MOVLB  2
0176A:  MOVF   xE3,W
0176C:  SUBWF  xDD,W
0176E:  BNZ   179C
01770:  MOVF   xE4,W
01772:  SUBWF  xDE,W
01774:  BNZ   179C
....................                 if (move_x > 2 * total_acc_step_x) 
01776:  BCF    FD8.0
01778:  RLCF   xD9,W
0177A:  MOVWF  02
0177C:  RLCF   xDA,W
0177E:  MOVWF  03
01780:  MOVFF  02,01
01784:  MOVF   03,W
01786:  SUBWF  xE2,W
01788:  BNC   1798
0178A:  BNZ   1792
0178C:  MOVF   xE1,W
0178E:  SUBWF  01,W
01790:  BC    1798
....................                     ramp_sts_x = ramp_max; 
01792:  MOVLW  02
01794:  MOVWF  xDC
01796:  BRA    179C
....................                 else 
....................                     ramp_sts_x = ramp_down; 
01798:  MOVLW  03
0179A:  MOVWF  xDC
....................             } 
....................             output_toggle(step_x); 
0179C:  BCF    F95.2
0179E:  BTG    F8C.2
....................             rest_x = ~rest_x; 
017A0:  BTG    x0C.6
....................             break; 
017A2:  BRA    17E6
....................  
....................         case ramp_down: // decel 
....................             proximo_valor_descida_x(); 
017A4:  BRA    14C8
....................             if (step_no_x == move_x) 
017A6:  MOVLB  2
017A8:  MOVF   xE1,W
017AA:  SUBWF  xDD,W
017AC:  BNZ   17B8
017AE:  MOVF   xE2,W
017B0:  SUBWF  xDE,W
017B2:  BNZ   17B8
....................                 ramp_sts_x = ramp_last; 
017B4:  MOVLW  04
017B6:  MOVWF  xDC
....................             output_toggle(step_x); 
017B8:  BCF    F95.2
017BA:  BTG    F8C.2
....................             rest_x = ~rest_x; 
017BC:  BTG    x0C.6
....................             break; 
017BE:  BRA    17E6
....................  
....................         case ramp_max: // constant speed 
....................             proximo_valor_subida_x(); 
017C0:  RCALL  1272
....................             if (step_no_x == step_down_x) // start decel 
017C2:  MOVLB  2
017C4:  MOVF   xDF,W
017C6:  SUBWF  xDD,W
017C8:  BNZ   17D4
017CA:  MOVF   xE0,W
017CC:  SUBWF  xDE,W
017CE:  BNZ   17D4
....................                 ramp_sts_x = ramp_down; 
017D0:  MOVLW  03
017D2:  MOVWF  xDC
....................             output_toggle(step_x); 
017D4:  BCF    F95.2
017D6:  BTG    F8C.2
....................             rest_x = ~rest_x; 
017D8:  BTG    x0C.6
....................             break; 
017DA:  BRA    17E6
017DC:  MOVLB  0
....................  
....................         default: // last step: cleanup 
....................             ramp_sts_x = ramp_idle; 
017DE:  MOVLB  2
017E0:  CLRF   xDC
....................             disable_interrupts(INT_TIMER0); 
017E2:  BCF    FF2.5
....................             run_flg_x = FALSE; // move_x complete 
017E4:  BCF    x0C.5
....................             break; 
....................     } // switch (ramp_sts_x) 
....................     if ((ramp_sts_x != ramp_idle)&&(ramp_sts_x != ramp_last)) { 
017E6:  MOVF   xDC,F
017E8:  BZ    1808
017EA:  MOVF   xDC,W
017EC:  SUBLW  04
017EE:  BZ    1808
....................         if (rest_x) { 
017F0:  BTFSS  x0C.6
017F2:  BRA    1808
....................             motor_pos_x += pos_inc_x; 
017F4:  CLRF   03
017F6:  MOVF   xDB,W
017F8:  BTFSC  FE8.7
017FA:  DECF   03,F
017FC:  ADDWF  x04,F
017FE:  MOVF   03,W
01800:  ADDWFC x05,F
....................             ++step_no_x;    
01802:  INCF   xDD,F
01804:  BTFSC  FD8.2
01806:  INCF   xDE,F
....................         } 
....................     } 
01808:  MOVLB  0
0180A:  GOTO   1810 (RETURN)
.................... } 
....................  
.................... void umpasso_x(int16 descanco, short dir) { 
....................     output_low(enable_x); 
....................     if (dir) { 
....................         output_high(dir_x); 
....................         motor_pos_x++; 
....................     } else { 
....................         output_low(dir_x); 
....................         motor_pos_x--; 
....................     } 
....................     output_high(step_x); 
....................     delay_us(descanco); 
....................     output_low(step_x); 
....................     delay_us(descanco); 
....................      
.................... } 
....................  
.................... void zerar_x() { 
....................     while(le_Input(i_limite_x)==1){ 
....................         delay_us(200); 
....................         umpasso_x(600, TRUE); 
....................     } 
....................     while (le_Input(i_limite_x)==0){ 
....................         umpasso_x(900, FALSE); 
....................         delay_us(200); 
....................     } 
....................     while(le_Input(i_limite_x)==1){ 
....................         delay_us(200); 
....................         umpasso_x(1000, TRUE); 
....................     } 
....................     motor_pos_x = 0; 
....................     output_high(enable_x); 
.................... } 
.................... // </editor-fold> 
....................  
.................... #include "Axis_y.c" 
.................... // <editor-fold defaultstate="collapsed" desc="Valores que devem ser inseridos"> 
.................... float stepbyrev_y = 200; 
.................... float driver_u_step_y = 1; // caso o driver esteja em 400 
.................... float Leadscrew_y = 9; //redutor de voltas do motor 
.................... float Leadscrew_Pich_y = 150; //esse valor deve ser em mm/revoluo 
.................... float Vmax_y = 600; //esse valor deve ser em mm por segundo 
.................... float Vmin_y = 200; 
.................... float Amax_y = 475; //esse valor deve ser em mm por segundo 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Valores calculo rampa"> 
.................... float MMbyStep_y = 0; 
.................... int8 StepinAcc_y = 20; 
.................... float Fmax_y = 0; 
.................... float Fmin_y = 100; 
.................... int32 Ts_y[20]; 
.................... int32 StepbyF_y[20]; 
.................... int16 total_acc_step_y = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Flags e Controles de Movimento"> 
.................... signed int8 pos_inc_y = 0; 
.................... int8 ramp_sts_y = ramp_idle; 
.................... short run_flg_y = FALSE; 
.................... short rest_y = FALSE; 
.................... short stop_yf = FALSE; 
.................... int16 step_no_y = 0; 
.................... int16 step_down_y = 0; 
.................... int16 move_y = 0; 
.................... int16 midpt_y = 0; 
.................... int32 step_acumulado_y = 0; 
.................... int atual_frequencia_y = 0; 
.................... int vel_y = 19; 
.................... int16 max_posicao_y=0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Pinos Motor"> 
.................... #DEFINE     i_limite_y            7 
.................... #DEFINE     s_limite_y            8 
....................  
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Inicializa Motor"> 
.................... void init_axis_y() { 
....................     set_tris_c(0xf8); 
*
039D6:  MOVLW  F8
039D8:  MOVWF  F94
....................     output_high(step_y); 
039DA:  BCF    F94.2
039DC:  BSF    F8B.2
....................     output_high(enable_y); 
039DE:  BCF    F94.0
039E0:  BSF    F8B.0
....................     output_high(dir_y); 
039E2:  BCF    F94.1
039E4:  BSF    F8B.1
....................  
....................     MMbyStep_y = Leadscrew_Pich_y / (stepbyrev_y * driver_u_step_y * Leadscrew_y); 
039E6:  MOVFF  2EE,593
039EA:  MOVFF  2ED,592
039EE:  MOVFF  2EC,591
039F2:  MOVFF  2EB,590
039F6:  MOVFF  2F2,597
039FA:  MOVFF  2F1,596
039FE:  MOVFF  2F0,595
03A02:  MOVFF  2EF,594
03A06:  CALL   2F24
03A0A:  MOVFF  03,585
03A0E:  MOVFF  02,584
03A12:  MOVFF  01,583
03A16:  MOVFF  00,582
03A1A:  MOVFF  03,593
03A1E:  MOVFF  02,592
03A22:  MOVFF  01,591
03A26:  MOVFF  00,590
03A2A:  MOVFF  2F6,597
03A2E:  MOVFF  2F5,596
03A32:  MOVFF  2F4,595
03A36:  MOVFF  2F3,594
03A3A:  CALL   2F24
03A3E:  MOVFF  2FA,599
03A42:  MOVFF  2F9,598
03A46:  MOVFF  2F8,597
03A4A:  MOVFF  2F7,596
03A4E:  MOVFF  03,59D
03A52:  MOVFF  02,59C
03A56:  MOVFF  01,59B
03A5A:  MOVFF  00,59A
03A5E:  CALL   301A
03A62:  MOVFF  03,30A
03A66:  MOVFF  02,309
03A6A:  MOVFF  01,308
03A6E:  MOVFF  00,307
....................     Fmax_y = Vmax_y/MMbyStep_y; //Valor de ferequencia adiquirido em hz 
03A72:  MOVFF  2FE,599
03A76:  MOVFF  2FD,598
03A7A:  MOVFF  2FC,597
03A7E:  MOVFF  2FB,596
03A82:  MOVFF  30A,59D
03A86:  MOVFF  309,59C
03A8A:  MOVFF  308,59B
03A8E:  MOVFF  307,59A
03A92:  CALL   301A
03A96:  MOVFF  03,30F
03A9A:  MOVFF  02,30E
03A9E:  MOVFF  01,30D
03AA2:  MOVFF  00,30C
....................      
....................     float den = Amax_y*StepinAcc_y; 
....................     float num = (Vmax_y-Vmin_y)*1000000; 
....................     float TbyF = num/den;//tempo em us 
....................      
....................     int i = 0; 
03AA6:  MOVLB  5
03AA8:  CLRF   x91
03AAA:  MOVFF  30B,590
03AAE:  MOVLB  0
03AB0:  CALL   3178
03AB4:  MOVFF  306,593
03AB8:  MOVFF  305,592
03ABC:  MOVFF  304,591
03AC0:  MOVFF  303,590
03AC4:  MOVFF  03,597
03AC8:  MOVFF  02,596
03ACC:  MOVFF  01,595
03AD0:  MOVFF  00,594
03AD4:  CALL   2F24
03AD8:  MOVFF  03,578
03ADC:  MOVFF  02,577
03AE0:  MOVFF  01,576
03AE4:  MOVFF  00,575
03AE8:  BSF    FD8.1
03AEA:  MOVFF  2FE,599
03AEE:  MOVFF  2FD,598
03AF2:  MOVFF  2FC,597
03AF6:  MOVFF  2FB,596
03AFA:  MOVFF  302,59D
03AFE:  MOVFF  301,59C
03B02:  MOVFF  300,59B
03B06:  MOVFF  2FF,59A
03B0A:  CALL   31AE
03B0E:  MOVFF  03,585
03B12:  MOVFF  02,584
03B16:  MOVFF  01,583
03B1A:  MOVFF  00,582
03B1E:  MOVFF  03,593
03B22:  MOVFF  02,592
03B26:  MOVFF  01,591
03B2A:  MOVFF  00,590
03B2E:  MOVLB  5
03B30:  CLRF   x97
03B32:  MOVLW  24
03B34:  MOVWF  x96
03B36:  MOVLW  74
03B38:  MOVWF  x95
03B3A:  MOVLW  92
03B3C:  MOVWF  x94
03B3E:  MOVLB  0
03B40:  CALL   2F24
03B44:  MOVFF  03,57C
03B48:  MOVFF  02,57B
03B4C:  MOVFF  01,57A
03B50:  MOVFF  00,579
03B54:  MOVFF  57C,599
03B58:  MOVFF  57B,598
03B5C:  MOVFF  57A,597
03B60:  MOVFF  579,596
03B64:  MOVFF  578,59D
03B68:  MOVFF  577,59C
03B6C:  MOVFF  576,59B
03B70:  MOVFF  575,59A
03B74:  CALL   301A
03B78:  MOVFF  03,580
03B7C:  MOVFF  02,57F
03B80:  MOVFF  01,57E
03B84:  MOVFF  00,57D
03B88:  MOVLB  5
03B8A:  CLRF   x81
....................     for(i = 1; i <=StepinAcc_y;i++) 
03B8C:  MOVLW  01
03B8E:  MOVWF  x81
03B90:  MOVF   x81,W
03B92:  MOVLB  3
03B94:  SUBWF  x0B,W
03B96:  BTFSS  FD8.0
03B98:  BRA    3ED0
....................     { 
....................         Ts_y[i-1]=(1000000*StepinAcc_y)/((i*(Fmax_y-Fmin_y)+Fmin_y)); 
03B9A:  MOVLW  01
03B9C:  MOVLB  5
03B9E:  SUBWF  x81,W
03BA0:  MULLW  04
03BA2:  MOVF   FF3,W
03BA4:  CLRF   03
03BA6:  ADDLW  14
03BA8:  MOVWF  FE9
03BAA:  MOVLW  03
03BAC:  ADDWFC 03,W
03BAE:  MOVWF  FEA
03BB0:  MOVFF  FEA,585
03BB4:  MOVFF  FE9,584
03BB8:  CLRF   x89
03BBA:  MOVLW  0F
03BBC:  MOVWF  x88
03BBE:  MOVLW  42
03BC0:  MOVWF  x87
03BC2:  MOVLW  40
03BC4:  MOVWF  x86
03BC6:  CLRF   x8D
03BC8:  CLRF   x8C
03BCA:  CLRF   x8B
03BCC:  MOVFF  30B,58A
03BD0:  MOVLB  0
03BD2:  RCALL  3426
03BD4:  MOVFF  585,FEA
03BD8:  MOVFF  584,FE9
03BDC:  MOVFF  03,589
03BE0:  MOVFF  02,588
03BE4:  MOVFF  01,587
03BE8:  MOVFF  00,586
03BEC:  MOVFF  FEA,58B
03BF0:  MOVFF  FE9,58A
03BF4:  BSF    FD8.1
03BF6:  MOVFF  30F,599
03BFA:  MOVFF  30E,598
03BFE:  MOVFF  30D,597
03C02:  MOVFF  30C,596
03C06:  MOVFF  313,59D
03C0A:  MOVFF  312,59C
03C0E:  MOVFF  311,59B
03C12:  MOVFF  310,59A
03C16:  CALL   31AE
03C1A:  MOVFF  58B,FEA
03C1E:  MOVFF  58A,FE9
03C22:  MOVFF  03,58F
03C26:  MOVFF  02,58E
03C2A:  MOVFF  01,58D
03C2E:  MOVFF  00,58C
03C32:  MOVLB  5
03C34:  CLRF   x91
03C36:  MOVFF  581,590
03C3A:  MOVLB  0
03C3C:  CALL   3178
03C40:  MOVFF  03,593
03C44:  MOVFF  02,592
03C48:  MOVFF  01,591
03C4C:  MOVFF  00,590
03C50:  MOVFF  58F,597
03C54:  MOVFF  58E,596
03C58:  MOVFF  58D,595
03C5C:  MOVFF  58C,594
03C60:  CALL   2F24
03C64:  MOVFF  03,593
03C68:  MOVFF  02,592
03C6C:  MOVFF  01,591
03C70:  MOVFF  00,590
03C74:  MOVFF  FEA,595
03C78:  MOVFF  FE9,594
03C7C:  BCF    FD8.1
03C7E:  MOVFF  03,599
03C82:  MOVFF  02,598
03C86:  MOVFF  01,597
03C8A:  MOVFF  00,596
03C8E:  MOVFF  313,59D
03C92:  MOVFF  312,59C
03C96:  MOVFF  311,59B
03C9A:  MOVFF  310,59A
03C9E:  CALL   31AE
03CA2:  MOVFF  595,FEA
03CA6:  MOVFF  594,FE9
03CAA:  MOVFF  03,593
03CAE:  MOVFF  02,592
03CB2:  MOVFF  01,591
03CB6:  MOVFF  00,590
03CBA:  MOVFF  589,599
03CBE:  MOVFF  588,598
03CC2:  MOVFF  587,597
03CC6:  MOVFF  586,596
03CCA:  CALL   3482
03CCE:  MOVFF  03,599
03CD2:  MOVFF  02,598
03CD6:  MOVFF  01,597
03CDA:  MOVFF  00,596
03CDE:  MOVFF  593,59D
03CE2:  MOVFF  592,59C
03CE6:  MOVFF  591,59B
03CEA:  MOVFF  590,59A
03CEE:  CALL   301A
03CF2:  MOVFF  03,599
03CF6:  MOVFF  02,598
03CFA:  MOVFF  01,597
03CFE:  MOVFF  00,596
03D02:  CALL   34BA
03D06:  MOVFF  00,FEF
03D0A:  MOVFF  01,FEC
03D0E:  MOVFF  02,FEC
03D12:  MOVFF  03,FEC
....................         StepbyF_y[i-1] = 2*TbyF/Ts_y[i-1]; 
03D16:  MOVLW  01
03D18:  MOVLB  5
03D1A:  SUBWF  x81,W
03D1C:  MULLW  04
03D1E:  MOVF   FF3,W
03D20:  CLRF   03
03D22:  ADDLW  64
03D24:  MOVWF  01
03D26:  MOVLW  03
03D28:  ADDWFC 03,F
03D2A:  MOVFF  01,582
03D2E:  MOVFF  03,583
03D32:  CLRF   x93
03D34:  CLRF   x92
03D36:  CLRF   x91
03D38:  MOVLW  80
03D3A:  MOVWF  x90
03D3C:  MOVFF  580,597
03D40:  MOVFF  57F,596
03D44:  MOVFF  57E,595
03D48:  MOVFF  57D,594
03D4C:  MOVLB  0
03D4E:  CALL   2F24
03D52:  MOVFF  03,587
03D56:  MOVFF  02,586
03D5A:  MOVFF  01,585
03D5E:  MOVFF  00,584
03D62:  MOVLW  01
03D64:  MOVLB  5
03D66:  SUBWF  x81,W
03D68:  MULLW  04
03D6A:  MOVF   FF3,W
03D6C:  CLRF   03
03D6E:  ADDLW  14
03D70:  MOVWF  FE9
03D72:  MOVLW  03
03D74:  ADDWFC 03,W
03D76:  MOVWF  FEA
03D78:  MOVFF  FEF,00
03D7C:  MOVFF  FEC,01
03D80:  MOVFF  FEC,02
03D84:  MOVFF  FEC,03
03D88:  MOVFF  03,599
03D8C:  MOVFF  02,598
03D90:  MOVFF  01,597
03D94:  MOVFF  00,596
03D98:  MOVLB  0
03D9A:  CALL   3482
03D9E:  MOVFF  587,599
03DA2:  MOVFF  586,598
03DA6:  MOVFF  585,597
03DAA:  MOVFF  584,596
03DAE:  MOVFF  03,59D
03DB2:  MOVFF  02,59C
03DB6:  MOVFF  01,59B
03DBA:  MOVFF  00,59A
03DBE:  CALL   301A
03DC2:  MOVFF  03,599
03DC6:  MOVFF  02,598
03DCA:  MOVFF  01,597
03DCE:  MOVFF  00,596
03DD2:  CALL   34BA
03DD6:  MOVFF  583,FEA
03DDA:  MOVFF  582,FE9
03DDE:  MOVFF  00,FEF
03DE2:  MOVFF  01,FEC
03DE6:  MOVFF  02,FEC
03DEA:  MOVFF  03,FEC
....................         total_acc_step_y += StepbyF_y[i-1]; 
03DEE:  MOVLW  01
03DF0:  MOVLB  5
03DF2:  SUBWF  x81,W
03DF4:  MULLW  04
03DF6:  MOVF   FF3,W
03DF8:  CLRF   03
03DFA:  ADDLW  64
03DFC:  MOVWF  FE9
03DFE:  MOVLW  03
03E00:  ADDWFC 03,W
03E02:  MOVWF  FEA
03E04:  MOVFF  FEF,00
03E08:  MOVFF  FEC,01
03E0C:  MOVFF  FEC,02
03E10:  MOVFF  FEC,03
03E14:  MOVF   00,W
03E16:  MOVLB  3
03E18:  ADDWF  xB4,F
03E1A:  MOVF   01,W
03E1C:  ADDWFC xB5,F
....................         Ts_y[i-1] = Ts_y[i-1]/(8*0.2*2);//Tempo/(prescale*ciclodemaquina*metadedociclo) 
03E1E:  MOVLW  01
03E20:  MOVLB  5
03E22:  SUBWF  x81,W
03E24:  MULLW  04
03E26:  MOVF   FF3,W
03E28:  CLRF   03
03E2A:  ADDLW  14
03E2C:  MOVWF  01
03E2E:  MOVLW  03
03E30:  ADDWFC 03,F
03E32:  MOVFF  01,582
03E36:  MOVFF  03,583
03E3A:  MOVLW  01
03E3C:  SUBWF  x81,W
03E3E:  MULLW  04
03E40:  MOVF   FF3,W
03E42:  CLRF   03
03E44:  ADDLW  14
03E46:  MOVWF  FE9
03E48:  MOVLW  03
03E4A:  ADDWFC 03,W
03E4C:  MOVWF  FEA
03E4E:  MOVFF  FEF,584
03E52:  MOVFF  FEC,585
03E56:  MOVFF  FEC,586
03E5A:  MOVFF  FEC,587
03E5E:  MOVFF  587,599
03E62:  MOVFF  586,598
03E66:  MOVFF  585,597
03E6A:  MOVFF  584,596
03E6E:  MOVLB  0
03E70:  CALL   3482
03E74:  MOVFF  03,599
03E78:  MOVFF  02,598
03E7C:  MOVFF  01,597
03E80:  MOVFF  00,596
03E84:  MOVLW  CD
03E86:  MOVLB  5
03E88:  MOVWF  x9D
03E8A:  MOVLW  CC
03E8C:  MOVWF  x9C
03E8E:  MOVLW  4C
03E90:  MOVWF  x9B
03E92:  MOVLW  80
03E94:  MOVWF  x9A
03E96:  MOVLB  0
03E98:  CALL   301A
03E9C:  MOVFF  03,599
03EA0:  MOVFF  02,598
03EA4:  MOVFF  01,597
03EA8:  MOVFF  00,596
03EAC:  CALL   34BA
03EB0:  MOVFF  583,FEA
03EB4:  MOVFF  582,FE9
03EB8:  MOVFF  00,FEF
03EBC:  MOVFF  01,FEC
03EC0:  MOVFF  02,FEC
03EC4:  MOVFF  03,FEC
03EC8:  MOVLB  5
03ECA:  INCF   x81,F
03ECC:  BRA    3B90
03ECE:  MOVLB  3
....................     } 
03ED0:  MOVLB  0
03ED2:  GOTO   D7DA (RETURN)
.................... } 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Movimento Motor"> 
.................... void motor_stop_y(){ 
....................     step_no_y = step_down_y; 
....................     ramp_sts_y = ramp_down; 
.................... } 
....................  
.................... void motor_disable_y(){ 
....................     output_high(enable_y); 
....................     disable_interrupts(INT_TIMER1); 
.................... } 
....................  
.................... void motor_run_y(int32 pos_new, int velocidade) { // set up to drive motor to pos_new (absolute step#) 
....................     vel_y = velocidade; 
*
055A6:  MOVFF  581,3C6
....................     total_acc_step_y = 0; 
055AA:  MOVLB  3
055AC:  CLRF   xB5
055AE:  CLRF   xB4
....................      
....................     if (pos_new < motor_pos_y) // get dir_yection & #steps 
055B0:  MOVFF  206,00
055B4:  MOVFF  207,01
055B8:  CLRF   02
055BA:  CLRF   03
055BC:  BTFSS  01.7
055BE:  BRA    55C4
055C0:  DECF   02,F
055C2:  DECF   03,F
055C4:  BTFSC  03.7
055C6:  BRA    5636
055C8:  MOVLB  5
055CA:  MOVF   x80,W
055CC:  SUBWF  03,W
055CE:  BTFSC  FD8.0
055D0:  BRA    55D6
055D2:  MOVLB  3
055D4:  BRA    5636
055D6:  BNZ   5600
055D8:  MOVF   x7F,W
055DA:  SUBWF  02,W
055DC:  BTFSC  FD8.0
055DE:  BRA    55E4
055E0:  MOVLB  3
055E2:  BRA    5636
055E4:  BNZ   5600
055E6:  MOVF   x7E,W
055E8:  SUBWF  01,W
055EA:  BTFSC  FD8.0
055EC:  BRA    55F2
055EE:  MOVLB  3
055F0:  BRA    5636
055F2:  BNZ   5600
055F4:  MOVF   00,W
055F6:  SUBWF  x7D,W
055F8:  BTFSS  FD8.0
055FA:  BRA    5600
055FC:  MOVLB  3
055FE:  BRA    5636
....................     { 
....................         output_low(dir_y); 
05600:  BCF    F94.1
05602:  BCF    F8B.1
....................         move_y = motor_pos_y - pos_new; 
05604:  MOVFF  206,00
05608:  MOVFF  207,01
0560C:  CLRF   02
0560E:  CLRF   03
05610:  BTFSS  01.7
05612:  BRA    5618
05614:  DECF   02,F
05616:  DECF   03,F
05618:  MOVF   x7D,W
0561A:  SUBWF  00,F
0561C:  MOVF   x7E,W
0561E:  SUBWFB 01,F
05620:  MOVF   x7F,W
05622:  SUBWFB 02,F
05624:  MOVF   x80,W
05626:  SUBWFB 03,F
05628:  MOVFF  01,3BE
0562C:  MOVFF  00,3BD
....................         pos_inc_y = -1; 
05630:  MOVLB  3
05632:  SETF   xB6
....................     } else if (pos_new != motor_pos_y) { 
05634:  BRA    56A6
05636:  MOVFF  206,00
0563A:  MOVFF  207,01
0563E:  CLRF   02
05640:  CLRF   03
05642:  BTFSS  01.7
05644:  BRA    564A
05646:  DECF   02,F
05648:  DECF   03,F
0564A:  MOVF   00,W
0564C:  MOVLB  5
0564E:  SUBWF  x7D,W
05650:  BNZ   5664
05652:  MOVF   01,W
05654:  SUBWF  x7E,W
05656:  BNZ   5664
05658:  MOVF   02,W
0565A:  SUBWF  x7F,W
0565C:  BNZ   5664
0565E:  MOVF   03,W
05660:  SUBWF  x80,W
05662:  BZ    56A2
....................         output_high(dir_y); 
05664:  BCF    F94.1
05666:  BSF    F8B.1
....................         move_y = pos_new - motor_pos_y; 
05668:  MOVFF  206,00
0566C:  MOVFF  207,01
05670:  CLRF   02
05672:  CLRF   03
05674:  BTFSS  01.7
05676:  BRA    567C
05678:  DECF   02,F
0567A:  DECF   03,F
0567C:  MOVF   00,W
0567E:  SUBWF  x7D,W
05680:  MOVWF  00
05682:  MOVF   01,W
05684:  SUBWFB x7E,W
05686:  MOVWF  01
05688:  MOVF   02,W
0568A:  SUBWFB x7F,W
0568C:  MOVF   03,W
0568E:  SUBWFB x80,W
05690:  MOVFF  01,3BE
05694:  MOVFF  00,3BD
....................         pos_inc_y = 1; 
05698:  MOVLW  01
0569A:  MOVLB  3
0569C:  MOVWF  xB6
....................     } else return; 
0569E:  BRA    56A6
056A0:  MOVLB  5
056A2:  BRA    578C
056A4:  MOVLB  3
....................  
....................     for(int j = 0; j <= velocidade;j++) 
056A6:  MOVLB  5
056A8:  CLRF   x82
056AA:  MOVF   x82,W
056AC:  SUBWF  x81,W
056AE:  BNC   56E2
....................     { 
....................         total_acc_step_y += StepbyF_y[j]; 
056B0:  MOVF   x82,W
056B2:  MULLW  04
056B4:  MOVF   FF3,W
056B6:  CLRF   03
056B8:  ADDLW  64
056BA:  MOVWF  FE9
056BC:  MOVLW  03
056BE:  ADDWFC 03,W
056C0:  MOVWF  FEA
056C2:  MOVFF  FEF,00
056C6:  MOVFF  FEC,01
056CA:  MOVFF  FEC,02
056CE:  MOVFF  FEC,03
056D2:  MOVF   00,W
056D4:  MOVLB  3
056D6:  ADDWF  xB4,F
056D8:  MOVF   01,W
056DA:  ADDWFC xB5,F
056DC:  MOVLB  5
056DE:  INCF   x82,F
056E0:  BRA    56AA
....................     } 
....................     if (move_y > 2 * total_acc_step_y) { 
056E2:  BCF    FD8.0
056E4:  MOVLB  3
056E6:  RLCF   xB4,W
056E8:  MOVWF  02
056EA:  RLCF   xB5,W
056EC:  MOVWF  03
056EE:  MOVFF  02,01
056F2:  MOVF   03,W
056F4:  SUBWF  xBE,W
056F6:  BNC   5716
056F8:  BNZ   5700
056FA:  MOVF   xBD,W
056FC:  SUBWF  01,W
056FE:  BC    5716
....................         midpt_y = total_acc_step_y; 
05700:  MOVFF  3B5,3C0
05704:  MOVFF  3B4,3BF
....................         step_down_y = move_y - total_acc_step_y; 
05708:  MOVF   xB4,W
0570A:  SUBWF  xBD,W
0570C:  MOVWF  xBB
0570E:  MOVF   xB5,W
05710:  SUBWFB xBE,W
05712:  MOVWF  xBC
....................     }  
05714:  BRA    5740
....................     else 
....................     { 
....................         midpt_y = (move_y - 1) >> 1; 
05716:  MOVLW  01
05718:  SUBWF  xBD,W
0571A:  MOVLB  5
0571C:  MOVWF  x83
0571E:  MOVLW  00
05720:  MOVLB  3
05722:  SUBWFB xBE,W
05724:  MOVLB  5
05726:  MOVWF  x84
05728:  BCF    FD8.0
0572A:  RRCF   x84,W
0572C:  MOVLB  3
0572E:  MOVWF  xC0
05730:  MOVLB  5
05732:  RRCF   x83,W
05734:  MOVLB  3
05736:  MOVWF  xBF
....................         step_down_y = midpt_y; 
05738:  MOVFF  3C0,3BC
0573C:  MOVFF  3BF,3BB
....................     } 
....................     step_no_y = 0; 
05740:  CLRF   xBA
05742:  CLRF   xB9
....................     step_acumulado_y = 0; 
05744:  CLRF   xC4
05746:  CLRF   xC3
05748:  CLRF   xC2
0574A:  CLRF   xC1
....................     atual_frequencia_y = 0; 
0574C:  CLRF   xC5
....................     ramp_sts_y = ramp_up; // start ramp state-machine 
0574E:  MOVLW  01
05750:  MOVWF  xB7
....................     run_flg_y = TRUE; 
05752:  MOVLB  2
05754:  BSF    x0C.7
....................     output_low(enable_y); 
05756:  BCF    F94.0
05758:  BCF    F8B.0
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
0575A:  MOVLW  B5
0575C:  MOVWF  FCD
....................     set_timer1(65535 - Ts_y[0]); 
0575E:  MOVLW  FF
05760:  BSF    FD8.0
05762:  MOVLB  3
05764:  SUBFWB x14,W
05766:  MOVLB  5
05768:  MOVWF  x83
0576A:  MOVLW  FF
0576C:  MOVLB  3
0576E:  SUBFWB x15,W
05770:  MOVLB  5
05772:  MOVWF  x84
05774:  MOVLW  00
05776:  MOVLB  3
05778:  SUBFWB x16,W
0577A:  MOVLW  00
0577C:  MOVLB  3
0577E:  SUBFWB x17,W
05780:  MOVLB  5
05782:  MOVFF  584,FCF
05786:  MOVFF  583,FCE
....................     enable_interrupts(INT_TIMER1); 
0578A:  BSF    F9D.0
0578C:  MOVLB  0
0578E:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_subida_y() { 
....................     if (atual_frequencia_y == 0) { 
*
01816:  MOVLB  3
01818:  MOVF   xC5,F
0181A:  BTFSS  FD8.2
0181C:  BRA    194C
....................         if (step_no_y == StepbyF_y[atual_frequencia_y]) { 
0181E:  MOVF   xC5,W
01820:  MULLW  04
01822:  MOVF   FF3,W
01824:  CLRF   03
01826:  ADDLW  64
01828:  MOVWF  FE9
0182A:  MOVLW  03
0182C:  ADDWFC 03,W
0182E:  MOVWF  FEA
01830:  MOVFF  FEF,00
01834:  MOVFF  FEC,01
01838:  MOVFF  FEC,02
0183C:  MOVFF  FEC,03
01840:  MOVF   00,W
01842:  SUBWF  xB9,W
01844:  BNZ   1906
01846:  MOVF   01,W
01848:  SUBWF  xBA,W
0184A:  BNZ   1906
0184C:  MOVF   02,F
0184E:  BNZ   1906
01850:  MOVF   03,F
01852:  BNZ   1906
....................             step_acumulado_y += StepbyF_y[atual_frequencia_y] + StepbyF_y[atual_frequencia_y + 1]; 
01854:  MOVF   xC5,W
01856:  MULLW  04
01858:  MOVF   FF3,W
0185A:  CLRF   03
0185C:  ADDLW  64
0185E:  MOVWF  FE9
01860:  MOVLW  03
01862:  ADDWFC 03,W
01864:  MOVWF  FEA
01866:  MOVFF  FEF,5A6
0186A:  MOVFF  FEC,5A7
0186E:  MOVFF  FEC,5A8
01872:  MOVFF  FEC,5A9
01876:  MOVLW  01
01878:  ADDWF  xC5,W
0187A:  MULLW  04
0187C:  MOVF   FF3,W
0187E:  CLRF   03
01880:  ADDLW  64
01882:  MOVWF  FE9
01884:  MOVLW  03
01886:  ADDWFC 03,W
01888:  MOVWF  FEA
0188A:  MOVFF  FEF,00
0188E:  MOVFF  FEC,01
01892:  MOVFF  FEC,02
01896:  MOVFF  FEC,03
0189A:  MOVLB  5
0189C:  MOVF   xA6,W
0189E:  ADDWF  00,F
018A0:  MOVF   xA7,W
018A2:  ADDWFC 01,F
018A4:  MOVF   xA8,W
018A6:  ADDWFC 02,F
018A8:  MOVF   xA9,W
018AA:  ADDWFC 03,F
018AC:  MOVF   00,W
018AE:  MOVLB  3
018B0:  ADDWF  xC1,F
018B2:  MOVF   01,W
018B4:  ADDWFC xC2,F
018B6:  MOVF   02,W
018B8:  ADDWFC xC3,F
018BA:  MOVF   03,W
018BC:  ADDWFC xC4,F
....................             atual_frequencia_y++; 
018BE:  INCF   xC5,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
018C0:  MOVF   xC5,W
018C2:  MULLW  04
018C4:  MOVF   FF3,W
018C6:  CLRF   03
018C8:  ADDLW  14
018CA:  MOVWF  FE9
018CC:  MOVLW  03
018CE:  ADDWFC 03,W
018D0:  MOVWF  FEA
018D2:  MOVFF  FEF,00
018D6:  MOVFF  FEC,01
018DA:  MOVFF  FEC,02
018DE:  MOVFF  FEC,03
018E2:  MOVLW  FF
018E4:  BSF    FD8.0
018E6:  SUBFWB 00,W
018E8:  MOVLB  5
018EA:  MOVWF  xA6
018EC:  MOVLW  FF
018EE:  SUBFWB 01,W
018F0:  MOVWF  xA7
018F2:  MOVLW  00
018F4:  SUBFWB 02,W
018F6:  MOVLW  00
018F8:  SUBFWB 03,W
018FA:  MOVFF  5A7,FCF
018FE:  MOVFF  5A6,FCE
....................         } else { 
01902:  BRA    1948
01904:  MOVLB  3
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01906:  MOVF   xC5,W
01908:  MULLW  04
0190A:  MOVF   FF3,W
0190C:  CLRF   03
0190E:  ADDLW  14
01910:  MOVWF  FE9
01912:  MOVLW  03
01914:  ADDWFC 03,W
01916:  MOVWF  FEA
01918:  MOVFF  FEF,00
0191C:  MOVFF  FEC,01
01920:  MOVFF  FEC,02
01924:  MOVFF  FEC,03
01928:  MOVLW  FF
0192A:  BSF    FD8.0
0192C:  SUBFWB 00,W
0192E:  MOVLB  5
01930:  MOVWF  xA6
01932:  MOVLW  FF
01934:  SUBFWB 01,W
01936:  MOVWF  xA7
01938:  MOVLW  00
0193A:  SUBFWB 02,W
0193C:  MOVLW  00
0193E:  SUBFWB 03,W
01940:  MOVFF  5A7,FCF
01944:  MOVFF  5A6,FCE
....................         } 
....................     } else if (atual_frequencia_y == vel_y) { 
01948:  BRA    1A68
0194A:  MOVLB  3
0194C:  MOVF   xC6,W
0194E:  SUBWF  xC5,W
01950:  BNZ   1998
....................         set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01952:  MOVF   xC5,W
01954:  MULLW  04
01956:  MOVF   FF3,W
01958:  CLRF   03
0195A:  ADDLW  14
0195C:  MOVWF  FE9
0195E:  MOVLW  03
01960:  ADDWFC 03,W
01962:  MOVWF  FEA
01964:  MOVFF  FEF,00
01968:  MOVFF  FEC,01
0196C:  MOVFF  FEC,02
01970:  MOVFF  FEC,03
01974:  MOVLW  FF
01976:  BSF    FD8.0
01978:  SUBFWB 00,W
0197A:  MOVLB  5
0197C:  MOVWF  xA6
0197E:  MOVLW  FF
01980:  SUBFWB 01,W
01982:  MOVWF  xA7
01984:  MOVLW  00
01986:  SUBFWB 02,W
01988:  MOVLW  00
0198A:  SUBFWB 03,W
0198C:  MOVFF  5A7,FCF
01990:  MOVFF  5A6,FCE
....................     } else { 
01994:  BRA    1A68
01996:  MOVLB  3
....................         if (step_no_y == step_acumulado_y) { 
01998:  MOVF   xC1,W
0199A:  SUBWF  xB9,W
0199C:  BNZ   1A26
0199E:  MOVF   xC2,W
019A0:  SUBWF  xBA,W
019A2:  BNZ   1A26
019A4:  MOVF   xC3,F
019A6:  BNZ   1A26
019A8:  MOVF   xC4,F
019AA:  BNZ   1A26
....................             atual_frequencia_y++; 
019AC:  INCF   xC5,F
....................             step_acumulado_y += StepbyF_y[atual_frequencia_y]; 
019AE:  MOVF   xC5,W
019B0:  MULLW  04
019B2:  MOVF   FF3,W
019B4:  CLRF   03
019B6:  ADDLW  64
019B8:  MOVWF  FE9
019BA:  MOVLW  03
019BC:  ADDWFC 03,W
019BE:  MOVWF  FEA
019C0:  MOVFF  FEF,00
019C4:  MOVFF  FEC,01
019C8:  MOVFF  FEC,02
019CC:  MOVFF  FEC,03
019D0:  MOVF   00,W
019D2:  ADDWF  xC1,F
019D4:  MOVF   01,W
019D6:  ADDWFC xC2,F
019D8:  MOVF   02,W
019DA:  ADDWFC xC3,F
019DC:  MOVF   03,W
019DE:  ADDWFC xC4,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
019E0:  MOVF   xC5,W
019E2:  MULLW  04
019E4:  MOVF   FF3,W
019E6:  CLRF   03
019E8:  ADDLW  14
019EA:  MOVWF  FE9
019EC:  MOVLW  03
019EE:  ADDWFC 03,W
019F0:  MOVWF  FEA
019F2:  MOVFF  FEF,00
019F6:  MOVFF  FEC,01
019FA:  MOVFF  FEC,02
019FE:  MOVFF  FEC,03
01A02:  MOVLW  FF
01A04:  BSF    FD8.0
01A06:  SUBFWB 00,W
01A08:  MOVLB  5
01A0A:  MOVWF  xA6
01A0C:  MOVLW  FF
01A0E:  SUBFWB 01,W
01A10:  MOVWF  xA7
01A12:  MOVLW  00
01A14:  SUBFWB 02,W
01A16:  MOVLW  00
01A18:  SUBFWB 03,W
01A1A:  MOVFF  5A7,FCF
01A1E:  MOVFF  5A6,FCE
....................         } else { 
01A22:  BRA    1A68
01A24:  MOVLB  3
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01A26:  MOVF   xC5,W
01A28:  MULLW  04
01A2A:  MOVF   FF3,W
01A2C:  CLRF   03
01A2E:  ADDLW  14
01A30:  MOVWF  FE9
01A32:  MOVLW  03
01A34:  ADDWFC 03,W
01A36:  MOVWF  FEA
01A38:  MOVFF  FEF,00
01A3C:  MOVFF  FEC,01
01A40:  MOVFF  FEC,02
01A44:  MOVFF  FEC,03
01A48:  MOVLW  FF
01A4A:  BSF    FD8.0
01A4C:  SUBFWB 00,W
01A4E:  MOVLB  5
01A50:  MOVWF  xA6
01A52:  MOVLW  FF
01A54:  SUBFWB 01,W
01A56:  MOVWF  xA7
01A58:  MOVLW  00
01A5A:  SUBFWB 02,W
01A5C:  MOVLW  00
01A5E:  SUBFWB 03,W
01A60:  MOVFF  5A7,FCF
01A64:  MOVFF  5A6,FCE
....................         } 
....................         break; 
....................     } 
01A68:  MOVLB  0
01A6A:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_descida_y() { 
....................     if (atual_frequencia_y == 0) { 
01A6C:  MOVLB  3
01A6E:  MOVF   xC5,F
01A70:  BNZ   1AB8
....................         set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01A72:  MOVF   xC5,W
01A74:  MULLW  04
01A76:  MOVF   FF3,W
01A78:  CLRF   03
01A7A:  ADDLW  14
01A7C:  MOVWF  FE9
01A7E:  MOVLW  03
01A80:  ADDWFC 03,W
01A82:  MOVWF  FEA
01A84:  MOVFF  FEF,00
01A88:  MOVFF  FEC,01
01A8C:  MOVFF  FEC,02
01A90:  MOVFF  FEC,03
01A94:  MOVLW  FF
01A96:  BSF    FD8.0
01A98:  SUBFWB 00,W
01A9A:  MOVLB  5
01A9C:  MOVWF  xA6
01A9E:  MOVLW  FF
01AA0:  SUBFWB 01,W
01AA2:  MOVWF  xA7
01AA4:  MOVLW  00
01AA6:  SUBFWB 02,W
01AA8:  MOVLW  00
01AAA:  SUBFWB 03,W
01AAC:  MOVFF  5A7,FCF
01AB0:  MOVFF  5A6,FCE
....................     }  
01AB4:  BRA    1CF0
01AB6:  MOVLB  3
....................     else if (atual_frequencia_y == vel_y) { 
01AB8:  MOVF   xC6,W
01ABA:  SUBWF  xC5,W
01ABC:  BTFSS  FD8.2
01ABE:  BRA    1C20
....................         if (step_no_y == (step_down_y + StepbyF_y[atual_frequencia_y])) { 
01AC0:  MOVF   xC5,W
01AC2:  MULLW  04
01AC4:  MOVF   FF3,W
01AC6:  CLRF   03
01AC8:  ADDLW  64
01ACA:  MOVWF  FE9
01ACC:  MOVLW  03
01ACE:  ADDWFC 03,W
01AD0:  MOVWF  FEA
01AD2:  MOVFF  FEF,00
01AD6:  MOVFF  FEC,01
01ADA:  MOVFF  FEC,02
01ADE:  MOVFF  FEC,03
01AE2:  MOVF   xBB,W
01AE4:  ADDWF  00,F
01AE6:  MOVF   xBC,W
01AE8:  ADDWFC 01,F
01AEA:  MOVLW  00
01AEC:  ADDWFC 02,F
01AEE:  ADDWFC 03,F
01AF0:  MOVF   00,W
01AF2:  SUBWF  xB9,W
01AF4:  BNZ   1BDA
01AF6:  MOVF   01,W
01AF8:  SUBWF  xBA,W
01AFA:  BNZ   1BDA
01AFC:  MOVF   02,F
01AFE:  BNZ   1BDA
01B00:  MOVF   03,F
01B02:  BNZ   1BDA
....................             step_acumulado_y = step_down_y + StepbyF_y[atual_frequencia_y] + StepbyF_y[atual_frequencia_y - 1]; 
01B04:  MOVF   xC5,W
01B06:  MULLW  04
01B08:  MOVF   FF3,W
01B0A:  CLRF   03
01B0C:  ADDLW  64
01B0E:  MOVWF  FE9
01B10:  MOVLW  03
01B12:  ADDWFC 03,W
01B14:  MOVWF  FEA
01B16:  MOVFF  FEF,00
01B1A:  MOVFF  FEC,01
01B1E:  MOVFF  FEC,02
01B22:  MOVFF  FEC,03
01B26:  MOVF   00,W
01B28:  ADDWF  xBB,W
01B2A:  MOVLB  5
01B2C:  MOVWF  xA6
01B2E:  MOVF   01,W
01B30:  MOVLB  3
01B32:  ADDWFC xBC,W
01B34:  MOVLB  5
01B36:  MOVWF  xA7
01B38:  MOVLW  00
01B3A:  ADDWFC 02,W
01B3C:  MOVWF  xA8
01B3E:  MOVLW  00
01B40:  ADDWFC 03,W
01B42:  MOVWF  xA9
01B44:  MOVLW  01
01B46:  MOVLB  3
01B48:  SUBWF  xC5,W
01B4A:  MULLW  04
01B4C:  MOVF   FF3,W
01B4E:  CLRF   03
01B50:  ADDLW  64
01B52:  MOVWF  FE9
01B54:  MOVLW  03
01B56:  ADDWFC 03,W
01B58:  MOVWF  FEA
01B5A:  MOVFF  FEF,00
01B5E:  MOVFF  FEC,01
01B62:  MOVFF  FEC,02
01B66:  MOVFF  FEC,03
01B6A:  MOVF   00,W
01B6C:  MOVLB  5
01B6E:  ADDWF  xA6,W
01B70:  MOVLB  3
01B72:  MOVWF  xC1
01B74:  MOVF   01,W
01B76:  MOVLB  5
01B78:  ADDWFC xA7,W
01B7A:  MOVLB  3
01B7C:  MOVWF  xC2
01B7E:  MOVF   02,W
01B80:  MOVLB  5
01B82:  ADDWFC xA8,W
01B84:  MOVLB  3
01B86:  MOVWF  xC3
01B88:  MOVF   03,W
01B8A:  MOVLB  5
01B8C:  ADDWFC xA9,W
01B8E:  MOVLB  3
01B90:  MOVWF  xC4
....................             atual_frequencia_y--; 
01B92:  DECF   xC5,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01B94:  MOVF   xC5,W
01B96:  MULLW  04
01B98:  MOVF   FF3,W
01B9A:  CLRF   03
01B9C:  ADDLW  14
01B9E:  MOVWF  FE9
01BA0:  MOVLW  03
01BA2:  ADDWFC 03,W
01BA4:  MOVWF  FEA
01BA6:  MOVFF  FEF,00
01BAA:  MOVFF  FEC,01
01BAE:  MOVFF  FEC,02
01BB2:  MOVFF  FEC,03
01BB6:  MOVLW  FF
01BB8:  BSF    FD8.0
01BBA:  SUBFWB 00,W
01BBC:  MOVLB  5
01BBE:  MOVWF  xA6
01BC0:  MOVLW  FF
01BC2:  SUBFWB 01,W
01BC4:  MOVWF  xA7
01BC6:  MOVLW  00
01BC8:  SUBFWB 02,W
01BCA:  MOVLW  00
01BCC:  SUBFWB 03,W
01BCE:  MOVFF  5A7,FCF
01BD2:  MOVFF  5A6,FCE
....................         } else { 
01BD6:  BRA    1C1C
01BD8:  MOVLB  3
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01BDA:  MOVF   xC5,W
01BDC:  MULLW  04
01BDE:  MOVF   FF3,W
01BE0:  CLRF   03
01BE2:  ADDLW  14
01BE4:  MOVWF  FE9
01BE6:  MOVLW  03
01BE8:  ADDWFC 03,W
01BEA:  MOVWF  FEA
01BEC:  MOVFF  FEF,00
01BF0:  MOVFF  FEC,01
01BF4:  MOVFF  FEC,02
01BF8:  MOVFF  FEC,03
01BFC:  MOVLW  FF
01BFE:  BSF    FD8.0
01C00:  SUBFWB 00,W
01C02:  MOVLB  5
01C04:  MOVWF  xA6
01C06:  MOVLW  FF
01C08:  SUBFWB 01,W
01C0A:  MOVWF  xA7
01C0C:  MOVLW  00
01C0E:  SUBFWB 02,W
01C10:  MOVLW  00
01C12:  SUBFWB 03,W
01C14:  MOVFF  5A7,FCF
01C18:  MOVFF  5A6,FCE
....................         } 
....................     } else { 
01C1C:  BRA    1CF0
01C1E:  MOVLB  3
....................         if (step_no_y == step_acumulado_y) { 
01C20:  MOVF   xC1,W
01C22:  SUBWF  xB9,W
01C24:  BNZ   1CAE
01C26:  MOVF   xC2,W
01C28:  SUBWF  xBA,W
01C2A:  BNZ   1CAE
01C2C:  MOVF   xC3,F
01C2E:  BNZ   1CAE
01C30:  MOVF   xC4,F
01C32:  BNZ   1CAE
....................             atual_frequencia_y--; 
01C34:  DECF   xC5,F
....................             step_acumulado_y += StepbyF_y[atual_frequencia_y]; 
01C36:  MOVF   xC5,W
01C38:  MULLW  04
01C3A:  MOVF   FF3,W
01C3C:  CLRF   03
01C3E:  ADDLW  64
01C40:  MOVWF  FE9
01C42:  MOVLW  03
01C44:  ADDWFC 03,W
01C46:  MOVWF  FEA
01C48:  MOVFF  FEF,00
01C4C:  MOVFF  FEC,01
01C50:  MOVFF  FEC,02
01C54:  MOVFF  FEC,03
01C58:  MOVF   00,W
01C5A:  ADDWF  xC1,F
01C5C:  MOVF   01,W
01C5E:  ADDWFC xC2,F
01C60:  MOVF   02,W
01C62:  ADDWFC xC3,F
01C64:  MOVF   03,W
01C66:  ADDWFC xC4,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01C68:  MOVF   xC5,W
01C6A:  MULLW  04
01C6C:  MOVF   FF3,W
01C6E:  CLRF   03
01C70:  ADDLW  14
01C72:  MOVWF  FE9
01C74:  MOVLW  03
01C76:  ADDWFC 03,W
01C78:  MOVWF  FEA
01C7A:  MOVFF  FEF,00
01C7E:  MOVFF  FEC,01
01C82:  MOVFF  FEC,02
01C86:  MOVFF  FEC,03
01C8A:  MOVLW  FF
01C8C:  BSF    FD8.0
01C8E:  SUBFWB 00,W
01C90:  MOVLB  5
01C92:  MOVWF  xA6
01C94:  MOVLW  FF
01C96:  SUBFWB 01,W
01C98:  MOVWF  xA7
01C9A:  MOVLW  00
01C9C:  SUBFWB 02,W
01C9E:  MOVLW  00
01CA0:  SUBFWB 03,W
01CA2:  MOVFF  5A7,FCF
01CA6:  MOVFF  5A6,FCE
....................         } else { 
01CAA:  BRA    1CF0
01CAC:  MOVLB  3
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01CAE:  MOVF   xC5,W
01CB0:  MULLW  04
01CB2:  MOVF   FF3,W
01CB4:  CLRF   03
01CB6:  ADDLW  14
01CB8:  MOVWF  FE9
01CBA:  MOVLW  03
01CBC:  ADDWFC 03,W
01CBE:  MOVWF  FEA
01CC0:  MOVFF  FEF,00
01CC4:  MOVFF  FEC,01
01CC8:  MOVFF  FEC,02
01CCC:  MOVFF  FEC,03
01CD0:  MOVLW  FF
01CD2:  BSF    FD8.0
01CD4:  SUBFWB 00,W
01CD6:  MOVLB  5
01CD8:  MOVWF  xA6
01CDA:  MOVLW  FF
01CDC:  SUBFWB 01,W
01CDE:  MOVWF  xA7
01CE0:  MOVLW  00
01CE2:  SUBFWB 02,W
01CE4:  MOVLW  00
01CE6:  SUBFWB 03,W
01CE8:  MOVFF  5A7,FCF
01CEC:  MOVFF  5A6,FCE
....................         } 
....................     } 
01CF0:  MOVLB  0
01CF2:  GOTO   1D4E (RETURN)
.................... } 
....................  
.................... void movimenta_eixo_y() { 
....................      
....................     switch (ramp_sts_y) { 
01CF6:  MOVLB  3
01CF8:  MOVF   xB7,W
01CFA:  XORLW  01
01CFC:  MOVLB  0
01CFE:  BZ    1D0A
01D00:  XORLW  02
01D02:  BZ    1D4C
01D04:  XORLW  01
01D06:  BZ    1D68
01D08:  BRA    1D86
....................  
....................         case ramp_up: // accel 
....................             output_toggle(step_y); 
01D0A:  BCF    F94.2
01D0C:  BTG    F8B.2
....................             rest_y = ~rest_y; 
01D0E:  MOVLB  3
01D10:  BTG    xB8.0
....................             proximo_valor_subida_y(); 
01D12:  MOVLB  0
01D14:  RCALL  1816
....................             if (step_no_y == midpt_y) { // midpoint: decel 
01D16:  MOVLB  3
01D18:  MOVF   xBF,W
01D1A:  SUBWF  xB9,W
01D1C:  BNZ   1D4A
01D1E:  MOVF   xC0,W
01D20:  SUBWF  xBA,W
01D22:  BNZ   1D4A
....................                 if (move_y > 2 * total_acc_step_y) 
01D24:  BCF    FD8.0
01D26:  RLCF   xB4,W
01D28:  MOVWF  02
01D2A:  RLCF   xB5,W
01D2C:  MOVWF  03
01D2E:  MOVFF  02,01
01D32:  MOVF   03,W
01D34:  SUBWF  xBE,W
01D36:  BNC   1D46
01D38:  BNZ   1D40
01D3A:  MOVF   xBD,W
01D3C:  SUBWF  01,W
01D3E:  BC    1D46
....................                     ramp_sts_y = ramp_max; 
01D40:  MOVLW  02
01D42:  MOVWF  xB7
01D44:  BRA    1D4A
....................                 else 
....................                     ramp_sts_y = ramp_down; 
01D46:  MOVLW  03
01D48:  MOVWF  xB7
....................             } 
....................             break; 
01D4A:  BRA    1D94
....................  
....................         case ramp_down: // decel 
....................             proximo_valor_descida_y(); 
01D4C:  BRA    1A6C
....................             if (step_no_y == move_y) 
01D4E:  MOVLB  3
01D50:  MOVF   xBD,W
01D52:  SUBWF  xB9,W
01D54:  BNZ   1D60
01D56:  MOVF   xBE,W
01D58:  SUBWF  xBA,W
01D5A:  BNZ   1D60
....................                 ramp_sts_y = ramp_last; 
01D5C:  MOVLW  04
01D5E:  MOVWF  xB7
....................             output_toggle(step_y); 
01D60:  BCF    F94.2
01D62:  BTG    F8B.2
....................             rest_y = ~rest_y; 
01D64:  BTG    xB8.0
....................             break; 
01D66:  BRA    1D94
....................  
....................         case ramp_max: // constant speed 
....................             proximo_valor_subida_y(); 
01D68:  RCALL  1816
....................             if (step_no_y == step_down_y) // start decel 
01D6A:  MOVLB  3
01D6C:  MOVF   xBB,W
01D6E:  SUBWF  xB9,W
01D70:  BNZ   1D7C
01D72:  MOVF   xBC,W
01D74:  SUBWF  xBA,W
01D76:  BNZ   1D7C
....................                 ramp_sts_y = ramp_down; 
01D78:  MOVLW  03
01D7A:  MOVWF  xB7
....................             output_toggle(step_y); 
01D7C:  BCF    F94.2
01D7E:  BTG    F8B.2
....................             rest_y = ~rest_y; 
01D80:  BTG    xB8.0
....................             break; 
01D82:  BRA    1D94
01D84:  MOVLB  0
....................  
....................         default: // last step: cleanup 
....................             ramp_sts_y = ramp_idle; 
01D86:  MOVLB  3
01D88:  CLRF   xB7
....................             stop_yf = FALSE; 
01D8A:  BCF    xB8.1
....................             disable_interrupts(INT_TIMER1); 
01D8C:  BCF    F9D.0
....................             run_flg_y = FALSE; // move_y complete 
01D8E:  MOVLB  2
01D90:  BCF    x0C.7
....................             break; 
01D92:  MOVLB  3
....................     } // switch (ramp_sts_y) 
....................     if (ramp_sts_y != ramp_idle) { 
01D94:  MOVF   xB7,F
01D96:  BZ    1DB4
....................         if (rest_y) { 
01D98:  BTFSS  xB8.0
01D9A:  BRA    1DB4
....................             motor_pos_y += pos_inc_y; 
01D9C:  CLRF   03
01D9E:  MOVF   xB6,W
01DA0:  BTFSC  FE8.7
01DA2:  DECF   03,F
01DA4:  MOVLB  2
01DA6:  ADDWF  x06,F
01DA8:  MOVF   03,W
01DAA:  ADDWFC x07,F
....................             ++step_no_y; 
01DAC:  MOVLB  3
01DAE:  INCF   xB9,F
01DB0:  BTFSC  FD8.2
01DB2:  INCF   xBA,F
....................         } 
....................     } 
01DB4:  MOVLB  0
01DB6:  GOTO   1DBC (RETURN)
.................... } 
....................  
.................... void umpasso_y(int16 descanco, short dir) { 
....................     output_low(enable_y); 
....................     if (dir) { 
....................         output_high(dir_y); 
....................         motor_pos_y--; 
....................     } else { 
....................         output_low(dir_y); 
....................         motor_pos_y++; 
....................     } 
....................     output_high(step_y); 
....................     delay_us(descanco); 
....................     output_low(step_y); 
....................     delay_us(descanco); 
....................     //output_high(enable_y); 
.................... } 
....................  
.................... void zerar_y() { 
....................     while(le_Input(i_limite_y)==1){ 
....................         umpasso_y(600, FALSE); 
....................         delay_us(200); 
....................     } 
....................     while (le_Input(i_limite_y)==0){ 
....................         umpasso_y(900,TRUE); 
....................         delay_us(200); 
....................     } 
....................     while(le_Input(i_limite_y)==1){ 
....................         umpasso_y(1000, FALSE); 
....................         delay_us(200); 
....................     } 
....................     motor_pos_y = 0; 
....................     output_high(enable_y); 
.................... } 
.................... void medir_y(){ 
....................     while (le_Input(s_limite_y)==0){ 
....................         umpasso_y(900,FALSE); 
....................         delay_us(200); 
....................     } 
....................     while (le_Input(s_limite_y)==1){ 
....................         umpasso_y(900,TRUE); 
....................         delay_us(200); 
....................     } 
....................     max_posicao_y = motor_pos_y; 
....................     output_high(enable_y); 
.................... } 
.................... // </editor-fold> 
....................  
.................... #include "Axis_z.c" 
.................... // <editor-fold defaultstate="collapsed" desc="Valores que devem ser inseridos"> 
.................... float stepbyrev_z = 200; 
.................... float driver_u_step_z = 1; // caso o driver esteja em 400 
.................... float Leadscrew_z = 9; //redutor de voltas do motor 
.................... float Leadscrew_Pich_z = 150; //esse valor deve ser em mm/revoluo 
.................... float Vmax_z = 400; //esse valor deve ser em mm por segundo 
.................... float Amax_z = 250; //esse valor deve ser em mm por segundo 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Valores calculo rampa"> 
.................... float MMbyStep_z = 0; 
.................... int8 StepinAcc_z = 20; 
.................... float Fmax_z = 0; 
.................... int32 Ts_z[20]; 
.................... int32 StepbyF_z[20]; 
.................... int16 total_acc_step_z = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Flags e Controles de Movimento"> 
.................... signed int8 pos_inc_z = 0; 
.................... int8 ramp_sts_z = ramp_idle; 
.................... short run_flg_z = FALSE; 
.................... short rest_z = false; 
.................... int16 step_no_z = 0; 
.................... int16 step_down_z = 0; 
.................... int16 move_z = 0; 
.................... int16 midpt_z = 0; 
.................... int32 step_acumulado_z = 0; 
.................... int atual_frequencia_z = 0; 
.................... int vel_z = 19; 
.................... int16 max_posicao_z = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Pinos Motor"> 
.................... #DEFINE     i_limite_z            13 
.................... #DEFINE     s_limite_z            14 
....................  
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Inicializa Motor"> 
.................... void init_axis_z() { 
....................     set_tris_a(0x00); 
*
03ED6:  MOVLW  00
03ED8:  MOVWF  F92
....................     output_high(step_z); 
03EDA:  BCF    F92.5
03EDC:  BSF    F89.5
....................     output_high(enable_z); 
03EDE:  BCF    F92.3
03EE0:  BSF    F89.3
....................     output_high(dir_z); 
03EE2:  BCF    F92.4
03EE4:  BSF    F89.4
....................  
....................     MMbyStep_z = Leadscrew_Pich_z / (stepbyrev_z * driver_u_step_z * Leadscrew_z); 
03EE6:  MOVFF  3CC,593
03EEA:  MOVFF  3CB,592
03EEE:  MOVFF  3CA,591
03EF2:  MOVFF  3C9,590
03EF6:  MOVFF  3D0,597
03EFA:  MOVFF  3CF,596
03EFE:  MOVFF  3CE,595
03F02:  MOVFF  3CD,594
03F06:  CALL   2F24
03F0A:  MOVFF  03,585
03F0E:  MOVFF  02,584
03F12:  MOVFF  01,583
03F16:  MOVFF  00,582
03F1A:  MOVFF  03,593
03F1E:  MOVFF  02,592
03F22:  MOVFF  01,591
03F26:  MOVFF  00,590
03F2A:  MOVFF  3D4,597
03F2E:  MOVFF  3D3,596
03F32:  MOVFF  3D2,595
03F36:  MOVFF  3D1,594
03F3A:  CALL   2F24
03F3E:  MOVFF  3D8,599
03F42:  MOVFF  3D7,598
03F46:  MOVFF  3D6,597
03F4A:  MOVFF  3D5,596
03F4E:  MOVFF  03,59D
03F52:  MOVFF  02,59C
03F56:  MOVFF  01,59B
03F5A:  MOVFF  00,59A
03F5E:  CALL   301A
03F62:  MOVFF  03,3E4
03F66:  MOVFF  02,3E3
03F6A:  MOVFF  01,3E2
03F6E:  MOVFF  00,3E1
....................     Fmax_z = Vmax_z / MMbyStep_z; //Valor de ferequencia adiquirido em hz 
03F72:  MOVFF  3DC,599
03F76:  MOVFF  3DB,598
03F7A:  MOVFF  3DA,597
03F7E:  MOVFF  3D9,596
03F82:  MOVFF  3E4,59D
03F86:  MOVFF  3E3,59C
03F8A:  MOVFF  3E2,59B
03F8E:  MOVFF  3E1,59A
03F92:  CALL   301A
03F96:  MOVFF  03,3E9
03F9A:  MOVFF  02,3E8
03F9E:  MOVFF  01,3E7
03FA2:  MOVFF  00,3E6
....................  
....................     float den = Amax_z*StepinAcc_z; 
....................     float num = Vmax_z * 1000000; 
....................     float TbyF = num / den; //tempo em us 
....................  
....................     int i = 0; 
03FA6:  MOVLB  5
03FA8:  CLRF   x91
03FAA:  MOVFF  3E5,590
03FAE:  MOVLB  0
03FB0:  CALL   3178
03FB4:  MOVFF  3E0,593
03FB8:  MOVFF  3DF,592
03FBC:  MOVFF  3DE,591
03FC0:  MOVFF  3DD,590
03FC4:  MOVFF  03,597
03FC8:  MOVFF  02,596
03FCC:  MOVFF  01,595
03FD0:  MOVFF  00,594
03FD4:  CALL   2F24
03FD8:  MOVFF  03,578
03FDC:  MOVFF  02,577
03FE0:  MOVFF  01,576
03FE4:  MOVFF  00,575
03FE8:  MOVFF  3DC,593
03FEC:  MOVFF  3DB,592
03FF0:  MOVFF  3DA,591
03FF4:  MOVFF  3D9,590
03FF8:  MOVLB  5
03FFA:  CLRF   x97
03FFC:  MOVLW  24
03FFE:  MOVWF  x96
04000:  MOVLW  74
04002:  MOVWF  x95
04004:  MOVLW  92
04006:  MOVWF  x94
04008:  MOVLB  0
0400A:  CALL   2F24
0400E:  MOVFF  03,57C
04012:  MOVFF  02,57B
04016:  MOVFF  01,57A
0401A:  MOVFF  00,579
0401E:  MOVFF  57C,599
04022:  MOVFF  57B,598
04026:  MOVFF  57A,597
0402A:  MOVFF  579,596
0402E:  MOVFF  578,59D
04032:  MOVFF  577,59C
04036:  MOVFF  576,59B
0403A:  MOVFF  575,59A
0403E:  CALL   301A
04042:  MOVFF  03,580
04046:  MOVFF  02,57F
0404A:  MOVFF  01,57E
0404E:  MOVFF  00,57D
04052:  MOVLB  5
04054:  CLRF   x81
....................     for (i = 1; i <= StepinAcc_z; i++) { 
04056:  MOVLW  01
04058:  MOVWF  x81
0405A:  MOVF   x81,W
0405C:  MOVLB  3
0405E:  SUBWF  xE5,W
04060:  BTFSS  FD8.0
04062:  BRA    4310
....................         Ts_z[i - 1] = (1000000 * StepinAcc_z) / (i * Fmax_z); 
04064:  MOVLW  01
04066:  MOVLB  5
04068:  SUBWF  x81,W
0406A:  MULLW  04
0406C:  MOVF   FF3,W
0406E:  CLRF   03
04070:  ADDLW  EA
04072:  MOVWF  FE9
04074:  MOVLW  03
04076:  ADDWFC 03,W
04078:  MOVWF  FEA
0407A:  MOVFF  FEA,585
0407E:  MOVFF  FE9,584
04082:  CLRF   x89
04084:  MOVLW  0F
04086:  MOVWF  x88
04088:  MOVLW  42
0408A:  MOVWF  x87
0408C:  MOVLW  40
0408E:  MOVWF  x86
04090:  CLRF   x8D
04092:  CLRF   x8C
04094:  CLRF   x8B
04096:  MOVFF  3E5,58A
0409A:  MOVLB  0
0409C:  CALL   3426
040A0:  MOVFF  585,FEA
040A4:  MOVFF  584,FE9
040A8:  MOVFF  03,589
040AC:  MOVFF  02,588
040B0:  MOVFF  01,587
040B4:  MOVFF  00,586
040B8:  MOVLB  5
040BA:  CLRF   x91
040BC:  MOVFF  581,590
040C0:  MOVLB  0
040C2:  CALL   3178
040C6:  MOVFF  03,593
040CA:  MOVFF  02,592
040CE:  MOVFF  01,591
040D2:  MOVFF  00,590
040D6:  MOVFF  3E9,597
040DA:  MOVFF  3E8,596
040DE:  MOVFF  3E7,595
040E2:  MOVFF  3E6,594
040E6:  CALL   2F24
040EA:  MOVFF  03,58D
040EE:  MOVFF  02,58C
040F2:  MOVFF  01,58B
040F6:  MOVFF  00,58A
040FA:  MOVFF  589,599
040FE:  MOVFF  588,598
04102:  MOVFF  587,597
04106:  MOVFF  586,596
0410A:  CALL   3482
0410E:  MOVFF  03,599
04112:  MOVFF  02,598
04116:  MOVFF  01,597
0411A:  MOVFF  00,596
0411E:  MOVFF  58D,59D
04122:  MOVFF  58C,59C
04126:  MOVFF  58B,59B
0412A:  MOVFF  58A,59A
0412E:  CALL   301A
04132:  MOVFF  03,599
04136:  MOVFF  02,598
0413A:  MOVFF  01,597
0413E:  MOVFF  00,596
04142:  CALL   34BA
04146:  MOVFF  00,FEF
0414A:  MOVFF  01,FEC
0414E:  MOVFF  02,FEC
04152:  MOVFF  03,FEC
....................         StepbyF_z[i - 1] = 2 * TbyF / Ts_z[i - 1]; 
04156:  MOVLW  01
04158:  MOVLB  5
0415A:  SUBWF  x81,W
0415C:  MULLW  04
0415E:  MOVF   FF3,W
04160:  CLRF   03
04162:  ADDLW  3A
04164:  MOVWF  01
04166:  MOVLW  04
04168:  ADDWFC 03,F
0416A:  MOVFF  01,582
0416E:  MOVFF  03,583
04172:  CLRF   x93
04174:  CLRF   x92
04176:  CLRF   x91
04178:  MOVLW  80
0417A:  MOVWF  x90
0417C:  MOVFF  580,597
04180:  MOVFF  57F,596
04184:  MOVFF  57E,595
04188:  MOVFF  57D,594
0418C:  MOVLB  0
0418E:  CALL   2F24
04192:  MOVFF  03,587
04196:  MOVFF  02,586
0419A:  MOVFF  01,585
0419E:  MOVFF  00,584
041A2:  MOVLW  01
041A4:  MOVLB  5
041A6:  SUBWF  x81,W
041A8:  MULLW  04
041AA:  MOVF   FF3,W
041AC:  CLRF   03
041AE:  ADDLW  EA
041B0:  MOVWF  FE9
041B2:  MOVLW  03
041B4:  ADDWFC 03,W
041B6:  MOVWF  FEA
041B8:  MOVFF  FEF,00
041BC:  MOVFF  FEC,01
041C0:  MOVFF  FEC,02
041C4:  MOVFF  FEC,03
041C8:  MOVFF  03,599
041CC:  MOVFF  02,598
041D0:  MOVFF  01,597
041D4:  MOVFF  00,596
041D8:  MOVLB  0
041DA:  CALL   3482
041DE:  MOVFF  587,599
041E2:  MOVFF  586,598
041E6:  MOVFF  585,597
041EA:  MOVFF  584,596
041EE:  MOVFF  03,59D
041F2:  MOVFF  02,59C
041F6:  MOVFF  01,59B
041FA:  MOVFF  00,59A
041FE:  CALL   301A
04202:  MOVFF  03,599
04206:  MOVFF  02,598
0420A:  MOVFF  01,597
0420E:  MOVFF  00,596
04212:  CALL   34BA
04216:  MOVFF  583,FEA
0421A:  MOVFF  582,FE9
0421E:  MOVFF  00,FEF
04222:  MOVFF  01,FEC
04226:  MOVFF  02,FEC
0422A:  MOVFF  03,FEC
....................         total_acc_step_z += StepbyF_z[i - 1]; 
0422E:  MOVLW  01
04230:  MOVLB  5
04232:  SUBWF  x81,W
04234:  MULLW  04
04236:  MOVF   FF3,W
04238:  CLRF   03
0423A:  ADDLW  3A
0423C:  MOVWF  FE9
0423E:  MOVLW  04
04240:  ADDWFC 03,W
04242:  MOVWF  FEA
04244:  MOVFF  FEF,00
04248:  MOVFF  FEC,01
0424C:  MOVFF  FEC,02
04250:  MOVFF  FEC,03
04254:  MOVF   00,W
04256:  MOVLB  4
04258:  ADDWF  x8A,F
0425A:  MOVF   01,W
0425C:  ADDWFC x8B,F
....................         Ts_z[i - 1] = Ts_z[i - 1] / (8 * 0.2 * 2); //Tempo/(prescale*ciclodemaquina*metadedociclo) 
0425E:  MOVLW  01
04260:  MOVLB  5
04262:  SUBWF  x81,W
04264:  MULLW  04
04266:  MOVF   FF3,W
04268:  CLRF   03
0426A:  ADDLW  EA
0426C:  MOVWF  01
0426E:  MOVLW  03
04270:  ADDWFC 03,F
04272:  MOVFF  01,582
04276:  MOVFF  03,583
0427A:  MOVLW  01
0427C:  SUBWF  x81,W
0427E:  MULLW  04
04280:  MOVF   FF3,W
04282:  CLRF   03
04284:  ADDLW  EA
04286:  MOVWF  FE9
04288:  MOVLW  03
0428A:  ADDWFC 03,W
0428C:  MOVWF  FEA
0428E:  MOVFF  FEF,584
04292:  MOVFF  FEC,585
04296:  MOVFF  FEC,586
0429A:  MOVFF  FEC,587
0429E:  MOVFF  587,599
042A2:  MOVFF  586,598
042A6:  MOVFF  585,597
042AA:  MOVFF  584,596
042AE:  MOVLB  0
042B0:  CALL   3482
042B4:  MOVFF  03,599
042B8:  MOVFF  02,598
042BC:  MOVFF  01,597
042C0:  MOVFF  00,596
042C4:  MOVLW  CD
042C6:  MOVLB  5
042C8:  MOVWF  x9D
042CA:  MOVLW  CC
042CC:  MOVWF  x9C
042CE:  MOVLW  4C
042D0:  MOVWF  x9B
042D2:  MOVLW  80
042D4:  MOVWF  x9A
042D6:  MOVLB  0
042D8:  CALL   301A
042DC:  MOVFF  03,599
042E0:  MOVFF  02,598
042E4:  MOVFF  01,597
042E8:  MOVFF  00,596
042EC:  CALL   34BA
042F0:  MOVFF  583,FEA
042F4:  MOVFF  582,FE9
042F8:  MOVFF  00,FEF
042FC:  MOVFF  01,FEC
04300:  MOVFF  02,FEC
04304:  MOVFF  03,FEC
04308:  MOVLB  5
0430A:  INCF   x81,F
0430C:  BRA    405A
0430E:  MOVLB  3
....................     } 
04310:  MOVLB  0
04312:  GOTO   D7DE (RETURN)
.................... } 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Movimento Motor"> 
.................... void motor_stop_z() { 
....................     step_no_z = step_down_z; 
....................     ramp_sts_z = ramp_down; 
.................... } 
....................  
.................... void motor_disable_z() { 
....................     output_high(enable_z); 
....................     disable_interrupts(INT_TIMER3); 
.................... } 
....................  
.................... void motor_run_z(int32 pos_new, int velocidade) { // set up to drive motor to pos_new (absolute step#) 
....................     vel_z = velocidade; 
*
05346:  MOVFF  581,49B
....................     total_acc_step_z = 0; 
0534A:  MOVLB  4
0534C:  CLRF   x8B
0534E:  CLRF   x8A
....................  
....................     if (!run_flg_flip) { 
05350:  BTFSC  2D.3
05352:  BRA    5532
....................         flgMove = TRUE; 
05354:  BSF    2D.2
....................         if (pos_new < motor_pos_z) // get dir_yection & #steps 
05356:  MOVFF  20A,00
0535A:  MOVFF  20B,01
0535E:  CLRF   02
05360:  CLRF   03
05362:  BTFSS  01.7
05364:  BRA    536A
05366:  DECF   02,F
05368:  DECF   03,F
0536A:  BTFSC  03.7
0536C:  BRA    53DC
0536E:  MOVLB  5
05370:  MOVF   x80,W
05372:  SUBWF  03,W
05374:  BTFSC  FD8.0
05376:  BRA    537C
05378:  MOVLB  4
0537A:  BRA    53DC
0537C:  BNZ   53A6
0537E:  MOVF   x7F,W
05380:  SUBWF  02,W
05382:  BTFSC  FD8.0
05384:  BRA    538A
05386:  MOVLB  4
05388:  BRA    53DC
0538A:  BNZ   53A6
0538C:  MOVF   x7E,W
0538E:  SUBWF  01,W
05390:  BTFSC  FD8.0
05392:  BRA    5398
05394:  MOVLB  4
05396:  BRA    53DC
05398:  BNZ   53A6
0539A:  MOVF   00,W
0539C:  SUBWF  x7D,W
0539E:  BTFSS  FD8.0
053A0:  BRA    53A6
053A2:  MOVLB  4
053A4:  BRA    53DC
....................         { 
....................             output_low(dir_z); 
053A6:  BCF    F92.4
053A8:  BCF    F89.4
....................             move_z = motor_pos_z - pos_new; 
053AA:  MOVFF  20A,00
053AE:  MOVFF  20B,01
053B2:  CLRF   02
053B4:  CLRF   03
053B6:  BTFSS  01.7
053B8:  BRA    53BE
053BA:  DECF   02,F
053BC:  DECF   03,F
053BE:  MOVF   x7D,W
053C0:  SUBWF  00,F
053C2:  MOVF   x7E,W
053C4:  SUBWFB 01,F
053C6:  MOVF   x7F,W
053C8:  SUBWFB 02,F
053CA:  MOVF   x80,W
053CC:  SUBWFB 03,F
053CE:  MOVFF  01,493
053D2:  MOVFF  00,492
....................             pos_inc_z = -1; 
053D6:  MOVLB  4
053D8:  SETF   x8C
....................         } else if (pos_new != motor_pos_z) { 
053DA:  BRA    544C
053DC:  MOVFF  20A,00
053E0:  MOVFF  20B,01
053E4:  CLRF   02
053E6:  CLRF   03
053E8:  BTFSS  01.7
053EA:  BRA    53F0
053EC:  DECF   02,F
053EE:  DECF   03,F
053F0:  MOVF   00,W
053F2:  MOVLB  5
053F4:  SUBWF  x7D,W
053F6:  BNZ   540A
053F8:  MOVF   01,W
053FA:  SUBWF  x7E,W
053FC:  BNZ   540A
053FE:  MOVF   02,W
05400:  SUBWF  x7F,W
05402:  BNZ   540A
05404:  MOVF   03,W
05406:  SUBWF  x80,W
05408:  BZ    5448
....................             output_high(dir_z); 
0540A:  BCF    F92.4
0540C:  BSF    F89.4
....................             move_z = pos_new - motor_pos_z; 
0540E:  MOVFF  20A,00
05412:  MOVFF  20B,01
05416:  CLRF   02
05418:  CLRF   03
0541A:  BTFSS  01.7
0541C:  BRA    5422
0541E:  DECF   02,F
05420:  DECF   03,F
05422:  MOVF   00,W
05424:  SUBWF  x7D,W
05426:  MOVWF  00
05428:  MOVF   01,W
0542A:  SUBWFB x7E,W
0542C:  MOVWF  01
0542E:  MOVF   02,W
05430:  SUBWFB x7F,W
05432:  MOVF   03,W
05434:  SUBWFB x80,W
05436:  MOVFF  01,493
0543A:  MOVFF  00,492
....................             pos_inc_z = 1; 
0543E:  MOVLW  01
05440:  MOVLB  4
05442:  MOVWF  x8C
....................         } else return; 
05444:  BRA    544C
05446:  MOVLB  5
05448:  BRA    5530
0544A:  MOVLB  4
....................  
....................         for (int j = 0; j <= velocidade; j++) { 
0544C:  MOVLB  5
0544E:  CLRF   x82
05450:  MOVF   x82,W
05452:  SUBWF  x81,W
05454:  BNC   5488
....................             total_acc_step_z += StepbyF_z[j]; 
05456:  MOVF   x82,W
05458:  MULLW  04
0545A:  MOVF   FF3,W
0545C:  CLRF   03
0545E:  ADDLW  3A
05460:  MOVWF  FE9
05462:  MOVLW  04
05464:  ADDWFC 03,W
05466:  MOVWF  FEA
05468:  MOVFF  FEF,00
0546C:  MOVFF  FEC,01
05470:  MOVFF  FEC,02
05474:  MOVFF  FEC,03
05478:  MOVF   00,W
0547A:  MOVLB  4
0547C:  ADDWF  x8A,F
0547E:  MOVF   01,W
05480:  ADDWFC x8B,F
05482:  MOVLB  5
05484:  INCF   x82,F
05486:  BRA    5450
....................         } 
....................  
....................         if (move_z > 2 * total_acc_step_z) { 
05488:  BCF    FD8.0
0548A:  MOVLB  4
0548C:  RLCF   x8A,W
0548E:  MOVWF  02
05490:  RLCF   x8B,W
05492:  MOVWF  03
05494:  MOVFF  02,01
05498:  MOVF   03,W
0549A:  SUBWF  x93,W
0549C:  BNC   54BC
0549E:  BNZ   54A6
054A0:  MOVF   x92,W
054A2:  SUBWF  01,W
054A4:  BC    54BC
....................             midpt_z = total_acc_step_z; 
054A6:  MOVFF  48B,495
054AA:  MOVFF  48A,494
....................             step_down_z = move_z - total_acc_step_z; 
054AE:  MOVF   x8A,W
054B0:  SUBWF  x92,W
054B2:  MOVWF  x90
054B4:  MOVF   x8B,W
054B6:  SUBWFB x93,W
054B8:  MOVWF  x91
....................         } else { 
054BA:  BRA    54E6
....................             midpt_z = (move_z - 1) >> 1; 
054BC:  MOVLW  01
054BE:  SUBWF  x92,W
054C0:  MOVLB  5
054C2:  MOVWF  x83
054C4:  MOVLW  00
054C6:  MOVLB  4
054C8:  SUBWFB x93,W
054CA:  MOVLB  5
054CC:  MOVWF  x84
054CE:  BCF    FD8.0
054D0:  RRCF   x84,W
054D2:  MOVLB  4
054D4:  MOVWF  x95
054D6:  MOVLB  5
054D8:  RRCF   x83,W
054DA:  MOVLB  4
054DC:  MOVWF  x94
....................             step_down_z = midpt_z; 
054DE:  MOVFF  495,491
054E2:  MOVFF  494,490
....................         } 
....................         step_no_z = 0; 
054E6:  CLRF   x8F
054E8:  CLRF   x8E
....................         step_acumulado_z = 0; 
054EA:  CLRF   x99
054EC:  CLRF   x98
054EE:  CLRF   x97
054F0:  CLRF   x96
....................         atual_frequencia_z = 0; 
054F2:  CLRF   x9A
....................         ramp_sts_z = ramp_up; // start ramp state-machine 
054F4:  MOVLW  01
054F6:  MOVWF  x8D
....................         run_flg_z = TRUE; 
054F8:  MOVLB  3
054FA:  BSF    xB8.2
....................         output_low(enable_z); 
054FC:  BCF    F92.3
054FE:  BCF    F89.3
....................         setup_timer_3(T3_INTERNAL | T3_DIV_BY_8); 
05500:  MOVLW  B5
05502:  MOVWF  FB1
....................         set_timer3(65535 - Ts_z[0]); 
05504:  MOVLW  FF
05506:  BSF    FD8.0
05508:  SUBFWB xEA,W
0550A:  MOVLB  5
0550C:  MOVWF  x83
0550E:  MOVLW  FF
05510:  MOVLB  3
05512:  SUBFWB xEB,W
05514:  MOVLB  5
05516:  MOVWF  x84
05518:  MOVLW  00
0551A:  MOVLB  3
0551C:  SUBFWB xEC,W
0551E:  MOVLW  00
05520:  MOVLB  3
05522:  SUBFWB xED,W
05524:  MOVLB  5
05526:  MOVFF  584,FB3
0552A:  MOVFF  583,FB2
....................         enable_interrupts(INT_TIMER3); 
0552E:  BSF    FA0.1
05530:  MOVLB  4
....................     } 
05532:  MOVLB  0
05534:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_subida_z() { 
....................     if (atual_frequencia_z == 0) { 
*
01DDA:  MOVLB  4
01DDC:  MOVF   x9A,F
01DDE:  BTFSS  FD8.2
01DE0:  BRA    1F10
....................         if (step_no_z == StepbyF_z[atual_frequencia_z]) { 
01DE2:  MOVF   x9A,W
01DE4:  MULLW  04
01DE6:  MOVF   FF3,W
01DE8:  CLRF   03
01DEA:  ADDLW  3A
01DEC:  MOVWF  FE9
01DEE:  MOVLW  04
01DF0:  ADDWFC 03,W
01DF2:  MOVWF  FEA
01DF4:  MOVFF  FEF,00
01DF8:  MOVFF  FEC,01
01DFC:  MOVFF  FEC,02
01E00:  MOVFF  FEC,03
01E04:  MOVF   00,W
01E06:  SUBWF  x8E,W
01E08:  BNZ   1ECA
01E0A:  MOVF   01,W
01E0C:  SUBWF  x8F,W
01E0E:  BNZ   1ECA
01E10:  MOVF   02,F
01E12:  BNZ   1ECA
01E14:  MOVF   03,F
01E16:  BNZ   1ECA
....................             step_acumulado_z += StepbyF_z[atual_frequencia_z] + StepbyF_z[atual_frequencia_z + 1]; 
01E18:  MOVF   x9A,W
01E1A:  MULLW  04
01E1C:  MOVF   FF3,W
01E1E:  CLRF   03
01E20:  ADDLW  3A
01E22:  MOVWF  FE9
01E24:  MOVLW  04
01E26:  ADDWFC 03,W
01E28:  MOVWF  FEA
01E2A:  MOVFF  FEF,5A6
01E2E:  MOVFF  FEC,5A7
01E32:  MOVFF  FEC,5A8
01E36:  MOVFF  FEC,5A9
01E3A:  MOVLW  01
01E3C:  ADDWF  x9A,W
01E3E:  MULLW  04
01E40:  MOVF   FF3,W
01E42:  CLRF   03
01E44:  ADDLW  3A
01E46:  MOVWF  FE9
01E48:  MOVLW  04
01E4A:  ADDWFC 03,W
01E4C:  MOVWF  FEA
01E4E:  MOVFF  FEF,00
01E52:  MOVFF  FEC,01
01E56:  MOVFF  FEC,02
01E5A:  MOVFF  FEC,03
01E5E:  MOVLB  5
01E60:  MOVF   xA6,W
01E62:  ADDWF  00,F
01E64:  MOVF   xA7,W
01E66:  ADDWFC 01,F
01E68:  MOVF   xA8,W
01E6A:  ADDWFC 02,F
01E6C:  MOVF   xA9,W
01E6E:  ADDWFC 03,F
01E70:  MOVF   00,W
01E72:  MOVLB  4
01E74:  ADDWF  x96,F
01E76:  MOVF   01,W
01E78:  ADDWFC x97,F
01E7A:  MOVF   02,W
01E7C:  ADDWFC x98,F
01E7E:  MOVF   03,W
01E80:  ADDWFC x99,F
....................             atual_frequencia_z++; 
01E82:  INCF   x9A,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01E84:  MOVF   x9A,W
01E86:  MULLW  04
01E88:  MOVF   FF3,W
01E8A:  CLRF   03
01E8C:  ADDLW  EA
01E8E:  MOVWF  FE9
01E90:  MOVLW  03
01E92:  ADDWFC 03,W
01E94:  MOVWF  FEA
01E96:  MOVFF  FEF,00
01E9A:  MOVFF  FEC,01
01E9E:  MOVFF  FEC,02
01EA2:  MOVFF  FEC,03
01EA6:  MOVLW  FF
01EA8:  BSF    FD8.0
01EAA:  SUBFWB 00,W
01EAC:  MOVLB  5
01EAE:  MOVWF  xA6
01EB0:  MOVLW  FF
01EB2:  SUBFWB 01,W
01EB4:  MOVWF  xA7
01EB6:  MOVLW  00
01EB8:  SUBFWB 02,W
01EBA:  MOVLW  00
01EBC:  SUBFWB 03,W
01EBE:  MOVFF  5A7,FB3
01EC2:  MOVFF  5A6,FB2
....................         } else { 
01EC6:  BRA    1F0C
01EC8:  MOVLB  4
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01ECA:  MOVF   x9A,W
01ECC:  MULLW  04
01ECE:  MOVF   FF3,W
01ED0:  CLRF   03
01ED2:  ADDLW  EA
01ED4:  MOVWF  FE9
01ED6:  MOVLW  03
01ED8:  ADDWFC 03,W
01EDA:  MOVWF  FEA
01EDC:  MOVFF  FEF,00
01EE0:  MOVFF  FEC,01
01EE4:  MOVFF  FEC,02
01EE8:  MOVFF  FEC,03
01EEC:  MOVLW  FF
01EEE:  BSF    FD8.0
01EF0:  SUBFWB 00,W
01EF2:  MOVLB  5
01EF4:  MOVWF  xA6
01EF6:  MOVLW  FF
01EF8:  SUBFWB 01,W
01EFA:  MOVWF  xA7
01EFC:  MOVLW  00
01EFE:  SUBFWB 02,W
01F00:  MOVLW  00
01F02:  SUBFWB 03,W
01F04:  MOVFF  5A7,FB3
01F08:  MOVFF  5A6,FB2
....................         } 
....................     } else if (atual_frequencia_z == vel_z) { 
01F0C:  BRA    202C
01F0E:  MOVLB  4
01F10:  MOVF   x9B,W
01F12:  SUBWF  x9A,W
01F14:  BNZ   1F5C
....................         set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01F16:  MOVF   x9A,W
01F18:  MULLW  04
01F1A:  MOVF   FF3,W
01F1C:  CLRF   03
01F1E:  ADDLW  EA
01F20:  MOVWF  FE9
01F22:  MOVLW  03
01F24:  ADDWFC 03,W
01F26:  MOVWF  FEA
01F28:  MOVFF  FEF,00
01F2C:  MOVFF  FEC,01
01F30:  MOVFF  FEC,02
01F34:  MOVFF  FEC,03
01F38:  MOVLW  FF
01F3A:  BSF    FD8.0
01F3C:  SUBFWB 00,W
01F3E:  MOVLB  5
01F40:  MOVWF  xA6
01F42:  MOVLW  FF
01F44:  SUBFWB 01,W
01F46:  MOVWF  xA7
01F48:  MOVLW  00
01F4A:  SUBFWB 02,W
01F4C:  MOVLW  00
01F4E:  SUBFWB 03,W
01F50:  MOVFF  5A7,FB3
01F54:  MOVFF  5A6,FB2
....................     } else { 
01F58:  BRA    202C
01F5A:  MOVLB  4
....................         if (step_no_z == step_acumulado_z) { 
01F5C:  MOVF   x96,W
01F5E:  SUBWF  x8E,W
01F60:  BNZ   1FEA
01F62:  MOVF   x97,W
01F64:  SUBWF  x8F,W
01F66:  BNZ   1FEA
01F68:  MOVF   x98,F
01F6A:  BNZ   1FEA
01F6C:  MOVF   x99,F
01F6E:  BNZ   1FEA
....................             atual_frequencia_z++; 
01F70:  INCF   x9A,F
....................             step_acumulado_z += StepbyF_z[atual_frequencia_z]; 
01F72:  MOVF   x9A,W
01F74:  MULLW  04
01F76:  MOVF   FF3,W
01F78:  CLRF   03
01F7A:  ADDLW  3A
01F7C:  MOVWF  FE9
01F7E:  MOVLW  04
01F80:  ADDWFC 03,W
01F82:  MOVWF  FEA
01F84:  MOVFF  FEF,00
01F88:  MOVFF  FEC,01
01F8C:  MOVFF  FEC,02
01F90:  MOVFF  FEC,03
01F94:  MOVF   00,W
01F96:  ADDWF  x96,F
01F98:  MOVF   01,W
01F9A:  ADDWFC x97,F
01F9C:  MOVF   02,W
01F9E:  ADDWFC x98,F
01FA0:  MOVF   03,W
01FA2:  ADDWFC x99,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01FA4:  MOVF   x9A,W
01FA6:  MULLW  04
01FA8:  MOVF   FF3,W
01FAA:  CLRF   03
01FAC:  ADDLW  EA
01FAE:  MOVWF  FE9
01FB0:  MOVLW  03
01FB2:  ADDWFC 03,W
01FB4:  MOVWF  FEA
01FB6:  MOVFF  FEF,00
01FBA:  MOVFF  FEC,01
01FBE:  MOVFF  FEC,02
01FC2:  MOVFF  FEC,03
01FC6:  MOVLW  FF
01FC8:  BSF    FD8.0
01FCA:  SUBFWB 00,W
01FCC:  MOVLB  5
01FCE:  MOVWF  xA6
01FD0:  MOVLW  FF
01FD2:  SUBFWB 01,W
01FD4:  MOVWF  xA7
01FD6:  MOVLW  00
01FD8:  SUBFWB 02,W
01FDA:  MOVLW  00
01FDC:  SUBFWB 03,W
01FDE:  MOVFF  5A7,FB3
01FE2:  MOVFF  5A6,FB2
....................         } else { 
01FE6:  BRA    202C
01FE8:  MOVLB  4
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01FEA:  MOVF   x9A,W
01FEC:  MULLW  04
01FEE:  MOVF   FF3,W
01FF0:  CLRF   03
01FF2:  ADDLW  EA
01FF4:  MOVWF  FE9
01FF6:  MOVLW  03
01FF8:  ADDWFC 03,W
01FFA:  MOVWF  FEA
01FFC:  MOVFF  FEF,00
02000:  MOVFF  FEC,01
02004:  MOVFF  FEC,02
02008:  MOVFF  FEC,03
0200C:  MOVLW  FF
0200E:  BSF    FD8.0
02010:  SUBFWB 00,W
02012:  MOVLB  5
02014:  MOVWF  xA6
02016:  MOVLW  FF
02018:  SUBFWB 01,W
0201A:  MOVWF  xA7
0201C:  MOVLW  00
0201E:  SUBFWB 02,W
02020:  MOVLW  00
02022:  SUBFWB 03,W
02024:  MOVFF  5A7,FB3
02028:  MOVFF  5A6,FB2
....................         } 
....................         break; 
....................     } 
0202C:  MOVLB  0
0202E:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_descida_z() { 
....................     if (atual_frequencia_z == 0) { 
02030:  MOVLB  4
02032:  MOVF   x9A,F
02034:  BNZ   207C
....................         set_timer3(65535 - Ts_z[atual_frequencia_z]); 
02036:  MOVF   x9A,W
02038:  MULLW  04
0203A:  MOVF   FF3,W
0203C:  CLRF   03
0203E:  ADDLW  EA
02040:  MOVWF  FE9
02042:  MOVLW  03
02044:  ADDWFC 03,W
02046:  MOVWF  FEA
02048:  MOVFF  FEF,00
0204C:  MOVFF  FEC,01
02050:  MOVFF  FEC,02
02054:  MOVFF  FEC,03
02058:  MOVLW  FF
0205A:  BSF    FD8.0
0205C:  SUBFWB 00,W
0205E:  MOVLB  5
02060:  MOVWF  xA6
02062:  MOVLW  FF
02064:  SUBFWB 01,W
02066:  MOVWF  xA7
02068:  MOVLW  00
0206A:  SUBFWB 02,W
0206C:  MOVLW  00
0206E:  SUBFWB 03,W
02070:  MOVFF  5A7,FB3
02074:  MOVFF  5A6,FB2
....................     } 
02078:  BRA    22B4
0207A:  MOVLB  4
....................     else if (atual_frequencia_z == vel_z) { 
0207C:  MOVF   x9B,W
0207E:  SUBWF  x9A,W
02080:  BTFSS  FD8.2
02082:  BRA    21E4
....................         if (step_no_z == (step_down_z + StepbyF_z[atual_frequencia_z])) { 
02084:  MOVF   x9A,W
02086:  MULLW  04
02088:  MOVF   FF3,W
0208A:  CLRF   03
0208C:  ADDLW  3A
0208E:  MOVWF  FE9
02090:  MOVLW  04
02092:  ADDWFC 03,W
02094:  MOVWF  FEA
02096:  MOVFF  FEF,00
0209A:  MOVFF  FEC,01
0209E:  MOVFF  FEC,02
020A2:  MOVFF  FEC,03
020A6:  MOVF   x90,W
020A8:  ADDWF  00,F
020AA:  MOVF   x91,W
020AC:  ADDWFC 01,F
020AE:  MOVLW  00
020B0:  ADDWFC 02,F
020B2:  ADDWFC 03,F
020B4:  MOVF   00,W
020B6:  SUBWF  x8E,W
020B8:  BNZ   219E
020BA:  MOVF   01,W
020BC:  SUBWF  x8F,W
020BE:  BNZ   219E
020C0:  MOVF   02,F
020C2:  BNZ   219E
020C4:  MOVF   03,F
020C6:  BNZ   219E
....................             step_acumulado_z = step_down_z + StepbyF_z[atual_frequencia_z] + StepbyF_z[atual_frequencia_z - 1]; 
020C8:  MOVF   x9A,W
020CA:  MULLW  04
020CC:  MOVF   FF3,W
020CE:  CLRF   03
020D0:  ADDLW  3A
020D2:  MOVWF  FE9
020D4:  MOVLW  04
020D6:  ADDWFC 03,W
020D8:  MOVWF  FEA
020DA:  MOVFF  FEF,00
020DE:  MOVFF  FEC,01
020E2:  MOVFF  FEC,02
020E6:  MOVFF  FEC,03
020EA:  MOVF   00,W
020EC:  ADDWF  x90,W
020EE:  MOVLB  5
020F0:  MOVWF  xA6
020F2:  MOVF   01,W
020F4:  MOVLB  4
020F6:  ADDWFC x91,W
020F8:  MOVLB  5
020FA:  MOVWF  xA7
020FC:  MOVLW  00
020FE:  ADDWFC 02,W
02100:  MOVWF  xA8
02102:  MOVLW  00
02104:  ADDWFC 03,W
02106:  MOVWF  xA9
02108:  MOVLW  01
0210A:  MOVLB  4
0210C:  SUBWF  x9A,W
0210E:  MULLW  04
02110:  MOVF   FF3,W
02112:  CLRF   03
02114:  ADDLW  3A
02116:  MOVWF  FE9
02118:  MOVLW  04
0211A:  ADDWFC 03,W
0211C:  MOVWF  FEA
0211E:  MOVFF  FEF,00
02122:  MOVFF  FEC,01
02126:  MOVFF  FEC,02
0212A:  MOVFF  FEC,03
0212E:  MOVF   00,W
02130:  MOVLB  5
02132:  ADDWF  xA6,W
02134:  MOVLB  4
02136:  MOVWF  x96
02138:  MOVF   01,W
0213A:  MOVLB  5
0213C:  ADDWFC xA7,W
0213E:  MOVLB  4
02140:  MOVWF  x97
02142:  MOVF   02,W
02144:  MOVLB  5
02146:  ADDWFC xA8,W
02148:  MOVLB  4
0214A:  MOVWF  x98
0214C:  MOVF   03,W
0214E:  MOVLB  5
02150:  ADDWFC xA9,W
02152:  MOVLB  4
02154:  MOVWF  x99
....................             atual_frequencia_z--; 
02156:  DECF   x9A,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
02158:  MOVF   x9A,W
0215A:  MULLW  04
0215C:  MOVF   FF3,W
0215E:  CLRF   03
02160:  ADDLW  EA
02162:  MOVWF  FE9
02164:  MOVLW  03
02166:  ADDWFC 03,W
02168:  MOVWF  FEA
0216A:  MOVFF  FEF,00
0216E:  MOVFF  FEC,01
02172:  MOVFF  FEC,02
02176:  MOVFF  FEC,03
0217A:  MOVLW  FF
0217C:  BSF    FD8.0
0217E:  SUBFWB 00,W
02180:  MOVLB  5
02182:  MOVWF  xA6
02184:  MOVLW  FF
02186:  SUBFWB 01,W
02188:  MOVWF  xA7
0218A:  MOVLW  00
0218C:  SUBFWB 02,W
0218E:  MOVLW  00
02190:  SUBFWB 03,W
02192:  MOVFF  5A7,FB3
02196:  MOVFF  5A6,FB2
....................         } else { 
0219A:  BRA    21E0
0219C:  MOVLB  4
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
0219E:  MOVF   x9A,W
021A0:  MULLW  04
021A2:  MOVF   FF3,W
021A4:  CLRF   03
021A6:  ADDLW  EA
021A8:  MOVWF  FE9
021AA:  MOVLW  03
021AC:  ADDWFC 03,W
021AE:  MOVWF  FEA
021B0:  MOVFF  FEF,00
021B4:  MOVFF  FEC,01
021B8:  MOVFF  FEC,02
021BC:  MOVFF  FEC,03
021C0:  MOVLW  FF
021C2:  BSF    FD8.0
021C4:  SUBFWB 00,W
021C6:  MOVLB  5
021C8:  MOVWF  xA6
021CA:  MOVLW  FF
021CC:  SUBFWB 01,W
021CE:  MOVWF  xA7
021D0:  MOVLW  00
021D2:  SUBFWB 02,W
021D4:  MOVLW  00
021D6:  SUBFWB 03,W
021D8:  MOVFF  5A7,FB3
021DC:  MOVFF  5A6,FB2
....................         } 
....................     } else { 
021E0:  BRA    22B4
021E2:  MOVLB  4
....................         if (step_no_z == step_acumulado_z) { 
021E4:  MOVF   x96,W
021E6:  SUBWF  x8E,W
021E8:  BNZ   2272
021EA:  MOVF   x97,W
021EC:  SUBWF  x8F,W
021EE:  BNZ   2272
021F0:  MOVF   x98,F
021F2:  BNZ   2272
021F4:  MOVF   x99,F
021F6:  BNZ   2272
....................             atual_frequencia_z--; 
021F8:  DECF   x9A,F
....................             step_acumulado_z += StepbyF_z[atual_frequencia_z]; 
021FA:  MOVF   x9A,W
021FC:  MULLW  04
021FE:  MOVF   FF3,W
02200:  CLRF   03
02202:  ADDLW  3A
02204:  MOVWF  FE9
02206:  MOVLW  04
02208:  ADDWFC 03,W
0220A:  MOVWF  FEA
0220C:  MOVFF  FEF,00
02210:  MOVFF  FEC,01
02214:  MOVFF  FEC,02
02218:  MOVFF  FEC,03
0221C:  MOVF   00,W
0221E:  ADDWF  x96,F
02220:  MOVF   01,W
02222:  ADDWFC x97,F
02224:  MOVF   02,W
02226:  ADDWFC x98,F
02228:  MOVF   03,W
0222A:  ADDWFC x99,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
0222C:  MOVF   x9A,W
0222E:  MULLW  04
02230:  MOVF   FF3,W
02232:  CLRF   03
02234:  ADDLW  EA
02236:  MOVWF  FE9
02238:  MOVLW  03
0223A:  ADDWFC 03,W
0223C:  MOVWF  FEA
0223E:  MOVFF  FEF,00
02242:  MOVFF  FEC,01
02246:  MOVFF  FEC,02
0224A:  MOVFF  FEC,03
0224E:  MOVLW  FF
02250:  BSF    FD8.0
02252:  SUBFWB 00,W
02254:  MOVLB  5
02256:  MOVWF  xA6
02258:  MOVLW  FF
0225A:  SUBFWB 01,W
0225C:  MOVWF  xA7
0225E:  MOVLW  00
02260:  SUBFWB 02,W
02262:  MOVLW  00
02264:  SUBFWB 03,W
02266:  MOVFF  5A7,FB3
0226A:  MOVFF  5A6,FB2
....................         } else { 
0226E:  BRA    22B4
02270:  MOVLB  4
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
02272:  MOVF   x9A,W
02274:  MULLW  04
02276:  MOVF   FF3,W
02278:  CLRF   03
0227A:  ADDLW  EA
0227C:  MOVWF  FE9
0227E:  MOVLW  03
02280:  ADDWFC 03,W
02282:  MOVWF  FEA
02284:  MOVFF  FEF,00
02288:  MOVFF  FEC,01
0228C:  MOVFF  FEC,02
02290:  MOVFF  FEC,03
02294:  MOVLW  FF
02296:  BSF    FD8.0
02298:  SUBFWB 00,W
0229A:  MOVLB  5
0229C:  MOVWF  xA6
0229E:  MOVLW  FF
022A0:  SUBFWB 01,W
022A2:  MOVWF  xA7
022A4:  MOVLW  00
022A6:  SUBFWB 02,W
022A8:  MOVLW  00
022AA:  SUBFWB 03,W
022AC:  MOVFF  5A7,FB3
022B0:  MOVFF  5A6,FB2
....................         } 
....................     } 
022B4:  MOVLB  0
022B6:  GOTO   231C (RETURN)
.................... } 
....................  
.................... void movimenta_eixo_z() { 
....................  
....................     switch (ramp_sts_z) { 
022BA:  MOVLB  4
022BC:  MOVF   x8D,W
022BE:  XORLW  01
022C0:  MOVLB  0
022C2:  BZ    22CE
022C4:  XORLW  02
022C6:  BZ    2310
022C8:  XORLW  01
022CA:  BZ    2330
022CC:  BRA    2352
....................         case ramp_up: // accel 
....................             output_toggle(step_z); 
022CE:  BCF    F92.5
022D0:  BTG    F89.5
....................             rest_z = ~rest_z; 
022D2:  MOVLB  3
022D4:  BTG    xB8.3
....................             proximo_valor_subida_z(); 
022D6:  MOVLB  0
022D8:  RCALL  1DDA
....................             if (step_no_z == midpt_z) { // midpoint: decel 
022DA:  MOVLB  4
022DC:  MOVF   x94,W
022DE:  SUBWF  x8E,W
022E0:  BNZ   230E
022E2:  MOVF   x95,W
022E4:  SUBWF  x8F,W
022E6:  BNZ   230E
....................                 if (move_z > 2 * total_acc_step_z) 
022E8:  BCF    FD8.0
022EA:  RLCF   x8A,W
022EC:  MOVWF  02
022EE:  RLCF   x8B,W
022F0:  MOVWF  03
022F2:  MOVFF  02,01
022F6:  MOVF   03,W
022F8:  SUBWF  x93,W
022FA:  BNC   230A
022FC:  BNZ   2304
022FE:  MOVF   x92,W
02300:  SUBWF  01,W
02302:  BC    230A
....................                     ramp_sts_z = ramp_max; 
02304:  MOVLW  02
02306:  MOVWF  x8D
02308:  BRA    230E
....................                 else 
....................                     ramp_sts_z = ramp_down; 
0230A:  MOVLW  03
0230C:  MOVWF  x8D
....................             } 
....................             break; 
0230E:  BRA    235E
....................  
....................         case ramp_down: // decel 
....................             output_toggle(step_z); 
02310:  BCF    F92.5
02312:  BTG    F89.5
....................             rest_z = ~rest_z; 
02314:  MOVLB  3
02316:  BTG    xB8.3
....................             proximo_valor_descida_z(); 
02318:  MOVLB  0
0231A:  BRA    2030
....................             if (step_no_z == move_z) 
0231C:  MOVLB  4
0231E:  MOVF   x92,W
02320:  SUBWF  x8E,W
02322:  BNZ   232E
02324:  MOVF   x93,W
02326:  SUBWF  x8F,W
02328:  BNZ   232E
....................                 ramp_sts_z = ramp_last; 
0232A:  MOVLW  04
0232C:  MOVWF  x8D
....................             break; 
0232E:  BRA    235E
....................  
....................         case ramp_max: // constant speed 
....................             output_toggle(step_z); 
02330:  BCF    F92.5
02332:  BTG    F89.5
....................             rest_z = ~rest_z; 
02334:  MOVLB  3
02336:  BTG    xB8.3
....................             proximo_valor_subida_z(); 
02338:  MOVLB  0
0233A:  RCALL  1DDA
....................             if (step_no_z == step_down_z) // start decel 
0233C:  MOVLB  4
0233E:  MOVF   x90,W
02340:  SUBWF  x8E,W
02342:  BNZ   234E
02344:  MOVF   x91,W
02346:  SUBWF  x8F,W
02348:  BNZ   234E
....................                 ramp_sts_z = ramp_down; 
0234A:  MOVLW  03
0234C:  MOVWF  x8D
....................             break; 
0234E:  BRA    235E
02350:  MOVLB  0
....................  
....................         default: // last step: cleanup 
....................             ramp_sts_z = ramp_idle; 
02352:  MOVLB  4
02354:  CLRF   x8D
....................             disable_interrupts(INT_TIMER3); 
02356:  BCF    FA0.1
....................             run_flg_z = FALSE; // move_z complete 
02358:  MOVLB  3
0235A:  BCF    xB8.2
....................             break; 
0235C:  MOVLB  4
....................     } // switch (ramp_sts_z) 
....................     if (ramp_sts_z != ramp_idle) { 
0235E:  MOVF   x8D,F
02360:  BZ    2382
....................         if (rest_z) { 
02362:  MOVLB  3
02364:  BTFSS  xB8.3
02366:  BRA    2384
....................             motor_pos_z += pos_inc_z; 
02368:  CLRF   03
0236A:  MOVLB  4
0236C:  MOVF   x8C,W
0236E:  BTFSC  FE8.7
02370:  DECF   03,F
02372:  MOVLB  2
02374:  ADDWF  x0A,F
02376:  MOVF   03,W
02378:  ADDWFC x0B,F
....................             ++step_no_z; 
0237A:  MOVLB  4
0237C:  INCF   x8E,F
0237E:  BTFSC  FD8.2
02380:  INCF   x8F,F
02382:  MOVLB  3
....................         } 
....................     } 
02384:  MOVLB  0
02386:  GOTO   28FC (RETURN)
.................... } 
....................  
.................... void umpasso_z(int16 descanco, short dir) { 
....................     output_low(enable_z); 
....................     if (dir) { 
....................         output_high(dir_z); 
....................         motor_pos_z--; 
....................     } else { 
....................         output_low(dir_z); 
....................         motor_pos_z++; 
....................     } 
....................     output_high(step_z); 
....................     delay_us(descanco); 
....................     output_low(step_z); 
....................     delay_us(descanco); 
....................  
.................... } 
....................  
.................... void zerar_z() { 
....................  
....................     while (le_Input(s_limite_z) == 1) { 
....................         delay_us(200); 
....................         umpasso_z(600, FALSE);//600 
....................     } 
....................     while (le_Input(s_limite_z) == 0) { 
....................         delay_us(200); 
....................         umpasso_z(900, TRUE);//900 
....................     } 
....................     while (le_Input(s_limite_z) == 1) { 
....................         delay_us(200); 
....................         umpasso_z(1000, FALSE);//1000 
....................     } 
....................    // output_high(enable_z); 
....................     motor_pos_z = 0; 
.................... } 
....................  
.................... void medir_z() { 
....................     while (le_Input(i_limite_z) == 0) { 
....................         umpasso_z(900, FALSE); 
....................         delay_us(200); 
....................     } 
....................     while (le_Input(i_limite_z) == 1) { 
....................         umpasso_z(900, TRUE); 
....................         delay_us(200); 
....................     } 
....................     max_posicao_z = motor_pos_z; 
....................     output_high(enable_z); 
....................     printf(lcd_putc, "%04Lu", max_posicao_z); 
.................... } 
.................... // </editor-fold> 
....................  
.................... #include "Axis_flip.c" 
.................... // <editor-fold defaultstate="collapsed" desc="Valores que devem ser inseridos"> 
.................... float stepbyrev_flip = 200; 
.................... float driver_u_step_flip = 1; // caso o driver esteja em 400 
.................... float Leadscrew_flip = 9; //redutor de voltas do motor 
.................... float Leadscrew_Pich_flip = 150; //esse valor deve ser em mm/revoluo 
.................... float Vmax_flip = 600; //esse valor deve ser em mm por segundo 
.................... float Amax_flip = 300; //esse valor deve ser em mm por segundo 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Valores calculo rampa"> 
.................... float MMbyStep_flip = 0; 
.................... int8 StepinAcc_flip = 20; 
.................... float Fmax_flip = 0; 
.................... int32 Ts_flip[20]; 
.................... int32 StepbyF_flip[20]; 
.................... int16 total_acc_step_flip = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Flags e Controles de Movimento"> 
.................... signed int8 pos_inc_flip = 0; 
.................... int8 ramp_sts_flip = ramp_idle; 
.................... short rest_flip = false; 
.................... int16 step_no_flip = 0; 
.................... int16 step_down_flip = 0; 
.................... int16 move_flip = 0; 
.................... int16 midpt_flip = 0; 
.................... int32 step_acumulado_flip = 0; 
.................... int atual_frequencia_flip = 0; 
.................... int vel_flip = 19; 
.................... int16 max_posicao_flip = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Pinos Motor"> 
.................... #DEFINE     s_limite_flip            11 
.................... #DEFINE     i_limite_flip            11 
....................  
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Inicializa Motor"> 
.................... void init_axis_flip() { 
....................     set_tris_a(0x00); 
*
04316:  MOVLW  00
04318:  MOVWF  F92
....................     output_high(step_flip); 
0431A:  BCF    F96.2
0431C:  BSF    F8D.2
....................     output_high(enable_flip); 
0431E:  BCF    F96.0
04320:  BSF    F8D.0
....................     output_high(dir_flip); 
04322:  BCF    F96.1
04324:  BSF    F8D.1
....................  
....................     MMbyStep_flip = Leadscrew_Pich_flip / (stepbyrev_flip * driver_u_step_flip * Leadscrew_flip); 
04326:  MOVFF  4A1,593
0432A:  MOVFF  4A0,592
0432E:  MOVFF  49F,591
04332:  MOVFF  49E,590
04336:  MOVFF  4A5,597
0433A:  MOVFF  4A4,596
0433E:  MOVFF  4A3,595
04342:  MOVFF  4A2,594
04346:  CALL   2F24
0434A:  MOVFF  03,585
0434E:  MOVFF  02,584
04352:  MOVFF  01,583
04356:  MOVFF  00,582
0435A:  MOVFF  03,593
0435E:  MOVFF  02,592
04362:  MOVFF  01,591
04366:  MOVFF  00,590
0436A:  MOVFF  4A9,597
0436E:  MOVFF  4A8,596
04372:  MOVFF  4A7,595
04376:  MOVFF  4A6,594
0437A:  CALL   2F24
0437E:  MOVFF  4AD,599
04382:  MOVFF  4AC,598
04386:  MOVFF  4AB,597
0438A:  MOVFF  4AA,596
0438E:  MOVFF  03,59D
04392:  MOVFF  02,59C
04396:  MOVFF  01,59B
0439A:  MOVFF  00,59A
0439E:  CALL   301A
043A2:  MOVFF  03,4B9
043A6:  MOVFF  02,4B8
043AA:  MOVFF  01,4B7
043AE:  MOVFF  00,4B6
....................     Fmax_flip = Vmax_flip / MMbyStep_flip; //Valor de ferequencia adiquirido em hz 
043B2:  MOVFF  4B1,599
043B6:  MOVFF  4B0,598
043BA:  MOVFF  4AF,597
043BE:  MOVFF  4AE,596
043C2:  MOVFF  4B9,59D
043C6:  MOVFF  4B8,59C
043CA:  MOVFF  4B7,59B
043CE:  MOVFF  4B6,59A
043D2:  CALL   301A
043D6:  MOVFF  03,4BE
043DA:  MOVFF  02,4BD
043DE:  MOVFF  01,4BC
043E2:  MOVFF  00,4BB
....................  
....................     float den = Amax_flip*StepinAcc_flip; 
....................     float num = Vmax_flip * 1000000; 
....................     float TbyF = num / den; //tempo em us 
....................  
....................     int i = 0; 
043E6:  MOVLB  5
043E8:  CLRF   x91
043EA:  MOVFF  4BA,590
043EE:  MOVLB  0
043F0:  CALL   3178
043F4:  MOVFF  4B5,593
043F8:  MOVFF  4B4,592
043FC:  MOVFF  4B3,591
04400:  MOVFF  4B2,590
04404:  MOVFF  03,597
04408:  MOVFF  02,596
0440C:  MOVFF  01,595
04410:  MOVFF  00,594
04414:  CALL   2F24
04418:  MOVFF  03,578
0441C:  MOVFF  02,577
04420:  MOVFF  01,576
04424:  MOVFF  00,575
04428:  MOVFF  4B1,593
0442C:  MOVFF  4B0,592
04430:  MOVFF  4AF,591
04434:  MOVFF  4AE,590
04438:  MOVLB  5
0443A:  CLRF   x97
0443C:  MOVLW  24
0443E:  MOVWF  x96
04440:  MOVLW  74
04442:  MOVWF  x95
04444:  MOVLW  92
04446:  MOVWF  x94
04448:  MOVLB  0
0444A:  CALL   2F24
0444E:  MOVFF  03,57C
04452:  MOVFF  02,57B
04456:  MOVFF  01,57A
0445A:  MOVFF  00,579
0445E:  MOVFF  57C,599
04462:  MOVFF  57B,598
04466:  MOVFF  57A,597
0446A:  MOVFF  579,596
0446E:  MOVFF  578,59D
04472:  MOVFF  577,59C
04476:  MOVFF  576,59B
0447A:  MOVFF  575,59A
0447E:  CALL   301A
04482:  MOVFF  03,580
04486:  MOVFF  02,57F
0448A:  MOVFF  01,57E
0448E:  MOVFF  00,57D
04492:  MOVLB  5
04494:  CLRF   x81
....................     for (i = 1; i <= StepinAcc_flip; i++) { 
04496:  MOVLW  01
04498:  MOVWF  x81
0449A:  MOVF   x81,W
0449C:  MOVLB  4
0449E:  SUBWF  xBA,W
044A0:  BTFSS  FD8.0
044A2:  BRA    474C
....................         Ts_flip[i - 1] = (1000000 * StepinAcc_flip) / (i * Fmax_flip); 
044A4:  MOVLW  01
044A6:  MOVLB  5
044A8:  SUBWF  x81,W
044AA:  MULLW  04
044AC:  MOVF   FF3,W
044AE:  CLRF   03
044B0:  ADDLW  BF
044B2:  MOVWF  FE9
044B4:  MOVLW  04
044B6:  ADDWFC 03,W
044B8:  MOVWF  FEA
044BA:  MOVFF  FEA,585
044BE:  MOVFF  FE9,584
044C2:  CLRF   x89
044C4:  MOVLW  0F
044C6:  MOVWF  x88
044C8:  MOVLW  42
044CA:  MOVWF  x87
044CC:  MOVLW  40
044CE:  MOVWF  x86
044D0:  CLRF   x8D
044D2:  CLRF   x8C
044D4:  CLRF   x8B
044D6:  MOVFF  4BA,58A
044DA:  MOVLB  0
044DC:  CALL   3426
044E0:  MOVFF  585,FEA
044E4:  MOVFF  584,FE9
044E8:  MOVFF  03,589
044EC:  MOVFF  02,588
044F0:  MOVFF  01,587
044F4:  MOVFF  00,586
044F8:  MOVLB  5
044FA:  CLRF   x91
044FC:  MOVFF  581,590
04500:  MOVLB  0
04502:  CALL   3178
04506:  MOVFF  03,593
0450A:  MOVFF  02,592
0450E:  MOVFF  01,591
04512:  MOVFF  00,590
04516:  MOVFF  4BE,597
0451A:  MOVFF  4BD,596
0451E:  MOVFF  4BC,595
04522:  MOVFF  4BB,594
04526:  CALL   2F24
0452A:  MOVFF  03,58D
0452E:  MOVFF  02,58C
04532:  MOVFF  01,58B
04536:  MOVFF  00,58A
0453A:  MOVFF  589,599
0453E:  MOVFF  588,598
04542:  MOVFF  587,597
04546:  MOVFF  586,596
0454A:  CALL   3482
0454E:  MOVFF  03,599
04552:  MOVFF  02,598
04556:  MOVFF  01,597
0455A:  MOVFF  00,596
0455E:  MOVFF  58D,59D
04562:  MOVFF  58C,59C
04566:  MOVFF  58B,59B
0456A:  MOVFF  58A,59A
0456E:  CALL   301A
04572:  MOVFF  03,599
04576:  MOVFF  02,598
0457A:  MOVFF  01,597
0457E:  MOVFF  00,596
04582:  CALL   34BA
04586:  MOVFF  00,FEF
0458A:  MOVFF  01,FEC
0458E:  MOVFF  02,FEC
04592:  MOVFF  03,FEC
....................         StepbyF_flip[i - 1] = 2 * TbyF / Ts_flip[i - 1]; 
04596:  MOVLW  01
04598:  MOVLB  5
0459A:  SUBWF  x81,W
0459C:  MULLW  04
0459E:  MOVF   FF3,W
045A0:  CLRF   03
045A2:  ADDLW  0F
045A4:  MOVWF  01
045A6:  MOVLW  05
045A8:  ADDWFC 03,F
045AA:  MOVFF  01,582
045AE:  MOVFF  03,583
045B2:  CLRF   x93
045B4:  CLRF   x92
045B6:  CLRF   x91
045B8:  MOVLW  80
045BA:  MOVWF  x90
045BC:  MOVFF  580,597
045C0:  MOVFF  57F,596
045C4:  MOVFF  57E,595
045C8:  MOVFF  57D,594
045CC:  MOVLB  0
045CE:  CALL   2F24
045D2:  MOVFF  03,587
045D6:  MOVFF  02,586
045DA:  MOVFF  01,585
045DE:  MOVFF  00,584
045E2:  MOVLW  01
045E4:  MOVLB  5
045E6:  SUBWF  x81,W
045E8:  MULLW  04
045EA:  MOVF   FF3,W
045EC:  CLRF   03
045EE:  ADDLW  BF
045F0:  MOVWF  FE9
045F2:  MOVLW  04
045F4:  ADDWFC 03,W
045F6:  MOVWF  FEA
045F8:  MOVFF  FEF,00
045FC:  MOVFF  FEC,01
04600:  MOVFF  FEC,02
04604:  MOVFF  FEC,03
04608:  MOVFF  03,599
0460C:  MOVFF  02,598
04610:  MOVFF  01,597
04614:  MOVFF  00,596
04618:  MOVLB  0
0461A:  CALL   3482
0461E:  MOVFF  587,599
04622:  MOVFF  586,598
04626:  MOVFF  585,597
0462A:  MOVFF  584,596
0462E:  MOVFF  03,59D
04632:  MOVFF  02,59C
04636:  MOVFF  01,59B
0463A:  MOVFF  00,59A
0463E:  CALL   301A
04642:  MOVFF  03,599
04646:  MOVFF  02,598
0464A:  MOVFF  01,597
0464E:  MOVFF  00,596
04652:  CALL   34BA
04656:  MOVFF  583,FEA
0465A:  MOVFF  582,FE9
0465E:  MOVFF  00,FEF
04662:  MOVFF  01,FEC
04666:  MOVFF  02,FEC
0466A:  MOVFF  03,FEC
....................         total_acc_step_flip += StepbyF_flip[i - 1]; 
0466E:  MOVLW  01
04670:  MOVLB  5
04672:  SUBWF  x81,W
04674:  MULLW  04
04676:  MOVF   FF3,W
04678:  CLRF   03
0467A:  ADDLW  0F
0467C:  MOVWF  FE9
0467E:  MOVLW  05
04680:  ADDWFC 03,W
04682:  MOVWF  FEA
04684:  MOVFF  FEF,00
04688:  MOVFF  FEC,01
0468C:  MOVFF  FEC,02
04690:  MOVFF  FEC,03
04694:  MOVF   00,W
04696:  ADDWF  x5F,F
04698:  MOVF   01,W
0469A:  ADDWFC x60,F
....................         Ts_flip[i - 1] = Ts_flip[i - 1] / (8 * 0.2 * 2); //Tempo/(prescale*ciclodemaquina*metadedociclo) 
0469C:  MOVLW  01
0469E:  SUBWF  x81,W
046A0:  MULLW  04
046A2:  MOVF   FF3,W
046A4:  CLRF   03
046A6:  ADDLW  BF
046A8:  MOVWF  01
046AA:  MOVLW  04
046AC:  ADDWFC 03,F
046AE:  MOVFF  01,582
046B2:  MOVFF  03,583
046B6:  MOVLW  01
046B8:  SUBWF  x81,W
046BA:  MULLW  04
046BC:  MOVF   FF3,W
046BE:  CLRF   03
046C0:  ADDLW  BF
046C2:  MOVWF  FE9
046C4:  MOVLW  04
046C6:  ADDWFC 03,W
046C8:  MOVWF  FEA
046CA:  MOVFF  FEF,584
046CE:  MOVFF  FEC,585
046D2:  MOVFF  FEC,586
046D6:  MOVFF  FEC,587
046DA:  MOVFF  587,599
046DE:  MOVFF  586,598
046E2:  MOVFF  585,597
046E6:  MOVFF  584,596
046EA:  MOVLB  0
046EC:  CALL   3482
046F0:  MOVFF  03,599
046F4:  MOVFF  02,598
046F8:  MOVFF  01,597
046FC:  MOVFF  00,596
04700:  MOVLW  CD
04702:  MOVLB  5
04704:  MOVWF  x9D
04706:  MOVLW  CC
04708:  MOVWF  x9C
0470A:  MOVLW  4C
0470C:  MOVWF  x9B
0470E:  MOVLW  80
04710:  MOVWF  x9A
04712:  MOVLB  0
04714:  CALL   301A
04718:  MOVFF  03,599
0471C:  MOVFF  02,598
04720:  MOVFF  01,597
04724:  MOVFF  00,596
04728:  CALL   34BA
0472C:  MOVFF  583,FEA
04730:  MOVFF  582,FE9
04734:  MOVFF  00,FEF
04738:  MOVFF  01,FEC
0473C:  MOVFF  02,FEC
04740:  MOVFF  03,FEC
04744:  MOVLB  5
04746:  INCF   x81,F
04748:  BRA    449A
0474A:  MOVLB  4
....................     } 
0474C:  MOVLB  0
0474E:  GOTO   D7E2 (RETURN)
.................... } 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Movimento Motor"> 
.................... void motor_stop_flip() { 
....................     step_no_flip = step_down_flip; 
....................     ramp_sts_flip = ramp_down; 
.................... } 
....................  
.................... void motor_disable_flip() { 
....................     output_high(enable_flip); 
....................     disable_interrupts(INT_TIMER3); 
.................... } 
....................  
.................... void motor_run_flip(int32 pos_new, int velocidade) { // set up to drive motor to pos_new (absolute step#) 
....................     vel_flip = velocidade; 
*
05790:  MOVFF  581,570
....................     total_acc_step_flip = 0; 
05794:  MOVLB  5
05796:  CLRF   x60
05798:  CLRF   x5F
....................  
....................     if (!run_flg_z) { 
0579A:  MOVLB  3
0579C:  BTFSC  xB8.2
0579E:  BRA    5964
....................         flgMove = FALSE; 
057A0:  BCF    2D.2
....................         if (pos_new < motor_pos_flip) // get dir_yection & #steps 
057A2:  MOVFF  208,00
057A6:  MOVFF  209,01
057AA:  CLRF   02
057AC:  CLRF   03
057AE:  BTFSS  01.7
057B0:  BRA    57B6
057B2:  DECF   02,F
057B4:  DECF   03,F
057B6:  BTFSC  03.7
057B8:  BRA    5828
057BA:  MOVLB  5
057BC:  MOVF   x80,W
057BE:  SUBWF  03,W
057C0:  BTFSC  FD8.0
057C2:  BRA    57C8
057C4:  MOVLB  3
057C6:  BRA    5828
057C8:  BNZ   57F2
057CA:  MOVF   x7F,W
057CC:  SUBWF  02,W
057CE:  BTFSC  FD8.0
057D0:  BRA    57D6
057D2:  MOVLB  3
057D4:  BRA    5828
057D6:  BNZ   57F2
057D8:  MOVF   x7E,W
057DA:  SUBWF  01,W
057DC:  BTFSC  FD8.0
057DE:  BRA    57E4
057E0:  MOVLB  3
057E2:  BRA    5828
057E4:  BNZ   57F2
057E6:  MOVF   00,W
057E8:  SUBWF  x7D,W
057EA:  BTFSS  FD8.0
057EC:  BRA    57F2
057EE:  MOVLB  3
057F0:  BRA    5828
....................         { 
....................             output_high(dir_flip); 
057F2:  BCF    F96.1
057F4:  BSF    F8D.1
....................             move_flip = motor_pos_flip - pos_new; 
057F6:  MOVFF  208,00
057FA:  MOVFF  209,01
057FE:  CLRF   02
05800:  CLRF   03
05802:  BTFSS  01.7
05804:  BRA    580A
05806:  DECF   02,F
05808:  DECF   03,F
0580A:  MOVF   x7D,W
0580C:  SUBWF  00,F
0580E:  MOVF   x7E,W
05810:  SUBWFB 01,F
05812:  MOVF   x7F,W
05814:  SUBWFB 02,F
05816:  MOVF   x80,W
05818:  SUBWFB 03,F
0581A:  MOVFF  01,568
0581E:  MOVFF  00,567
....................             pos_inc_flip = -1; 
05822:  SETF   x61
....................         } else if (pos_new != motor_pos_flip) { 
05824:  BRA    5892
05826:  MOVLB  3
05828:  MOVFF  208,00
0582C:  MOVFF  209,01
05830:  CLRF   02
05832:  CLRF   03
05834:  BTFSS  01.7
05836:  BRA    583C
05838:  DECF   02,F
0583A:  DECF   03,F
0583C:  MOVF   00,W
0583E:  MOVLB  5
05840:  SUBWF  x7D,W
05842:  BNZ   5856
05844:  MOVF   01,W
05846:  SUBWF  x7E,W
05848:  BNZ   5856
0584A:  MOVF   02,W
0584C:  SUBWF  x7F,W
0584E:  BNZ   5856
05850:  MOVF   03,W
05852:  SUBWF  x80,W
05854:  BZ    5890
....................             output_low(dir_flip); 
05856:  BCF    F96.1
05858:  BCF    F8D.1
....................             move_flip = pos_new - motor_pos_flip; 
0585A:  MOVFF  208,00
0585E:  MOVFF  209,01
05862:  CLRF   02
05864:  CLRF   03
05866:  BTFSS  01.7
05868:  BRA    586E
0586A:  DECF   02,F
0586C:  DECF   03,F
0586E:  MOVF   00,W
05870:  SUBWF  x7D,W
05872:  MOVWF  00
05874:  MOVF   01,W
05876:  SUBWFB x7E,W
05878:  MOVWF  01
0587A:  MOVF   02,W
0587C:  SUBWFB x7F,W
0587E:  MOVF   03,W
05880:  SUBWFB x80,W
05882:  MOVFF  01,568
05886:  MOVFF  00,567
....................             pos_inc_flip = 1; 
0588A:  MOVLW  01
0588C:  MOVWF  x61
....................         } else return; 
0588E:  BRA    5892
05890:  BRA    5962
....................  
....................         for (int j = 0; j <= velocidade; j++) { 
05892:  CLRF   x82
05894:  MOVF   x82,W
05896:  SUBWF  x81,W
05898:  BNC   58C8
....................             total_acc_step_flip += StepbyF_flip[j]; 
0589A:  MOVF   x82,W
0589C:  MULLW  04
0589E:  MOVF   FF3,W
058A0:  CLRF   03
058A2:  ADDLW  0F
058A4:  MOVWF  FE9
058A6:  MOVLW  05
058A8:  ADDWFC 03,W
058AA:  MOVWF  FEA
058AC:  MOVFF  FEF,00
058B0:  MOVFF  FEC,01
058B4:  MOVFF  FEC,02
058B8:  MOVFF  FEC,03
058BC:  MOVF   00,W
058BE:  ADDWF  x5F,F
058C0:  MOVF   01,W
058C2:  ADDWFC x60,F
058C4:  INCF   x82,F
058C6:  BRA    5894
....................         } 
....................          
....................         if (move_flip > 2 * total_acc_step_flip) { 
058C8:  BCF    FD8.0
058CA:  RLCF   x5F,W
058CC:  MOVWF  02
058CE:  RLCF   x60,W
058D0:  MOVWF  03
058D2:  MOVFF  02,01
058D6:  MOVF   03,W
058D8:  SUBWF  x68,W
058DA:  BNC   58FA
058DC:  BNZ   58E4
058DE:  MOVF   x67,W
058E0:  SUBWF  01,W
058E2:  BC    58FA
....................             midpt_flip = total_acc_step_flip; 
058E4:  MOVFF  560,56A
058E8:  MOVFF  55F,569
....................             step_down_flip = move_flip - total_acc_step_flip; 
058EC:  MOVF   x5F,W
058EE:  SUBWF  x67,W
058F0:  MOVWF  x65
058F2:  MOVF   x60,W
058F4:  SUBWFB x68,W
058F6:  MOVWF  x66
....................         } else { 
058F8:  BRA    5918
....................             midpt_flip = (move_flip - 1) >> 1; 
058FA:  MOVLW  01
058FC:  SUBWF  x67,W
058FE:  MOVWF  x83
05900:  MOVLW  00
05902:  SUBWFB x68,W
05904:  MOVWF  x84
05906:  BCF    FD8.0
05908:  RRCF   x84,W
0590A:  MOVWF  x6A
0590C:  RRCF   x83,W
0590E:  MOVWF  x69
....................             step_down_flip = midpt_flip; 
05910:  MOVFF  56A,566
05914:  MOVFF  569,565
....................         } 
....................         step_no_flip = 0; 
05918:  CLRF   x64
0591A:  CLRF   x63
....................         step_acumulado_flip = 0; 
0591C:  CLRF   x6E
0591E:  CLRF   x6D
05920:  CLRF   x6C
05922:  CLRF   x6B
....................         atual_frequencia_flip = 0; 
05924:  CLRF   x6F
....................         ramp_sts_flip = ramp_up; // start ramp state-machine 
05926:  MOVLW  01
05928:  MOVWF  x62
....................         run_flg_flip = TRUE; 
0592A:  BSF    2D.3
....................         output_low(enable_flip); 
0592C:  BCF    F96.0
0592E:  BCF    F8D.0
....................         setup_timer_3(T3_INTERNAL | T3_DIV_BY_8); 
05930:  MOVLW  B5
05932:  MOVWF  FB1
....................         set_timer3(65535 - Ts_flip[0]); 
05934:  MOVLW  FF
05936:  BSF    FD8.0
05938:  MOVLB  4
0593A:  SUBFWB xBF,W
0593C:  MOVLB  5
0593E:  MOVWF  x83
05940:  MOVLW  FF
05942:  MOVLB  4
05944:  SUBFWB xC0,W
05946:  MOVLB  5
05948:  MOVWF  x84
0594A:  MOVLW  00
0594C:  MOVLB  4
0594E:  SUBFWB xC1,W
05950:  MOVLW  00
05952:  MOVLB  4
05954:  SUBFWB xC2,W
05956:  MOVLB  5
05958:  MOVFF  584,FB3
0595C:  MOVFF  583,FB2
....................         enable_interrupts(INT_TIMER3); 
05960:  BSF    FA0.1
05962:  MOVLB  3
....................     } 
05964:  MOVLB  0
05966:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_subida_flip() { 
....................     if (atual_frequencia_flip == 0) { 
*
0238A:  MOVLB  5
0238C:  MOVF   x6F,F
0238E:  BTFSS  FD8.2
02390:  BRA    24B4
....................         if (step_no_flip == StepbyF_flip[atual_frequencia_flip]) { 
02392:  MOVF   x6F,W
02394:  MULLW  04
02396:  MOVF   FF3,W
02398:  CLRF   03
0239A:  ADDLW  0F
0239C:  MOVWF  FE9
0239E:  MOVLW  05
023A0:  ADDWFC 03,W
023A2:  MOVWF  FEA
023A4:  MOVFF  FEF,00
023A8:  MOVFF  FEC,01
023AC:  MOVFF  FEC,02
023B0:  MOVFF  FEC,03
023B4:  MOVF   00,W
023B6:  SUBWF  x63,W
023B8:  BNZ   2472
023BA:  MOVF   01,W
023BC:  SUBWF  x64,W
023BE:  BNZ   2472
023C0:  MOVF   02,F
023C2:  BNZ   2472
023C4:  MOVF   03,F
023C6:  BNZ   2472
....................             step_acumulado_flip += StepbyF_flip[atual_frequencia_flip] + StepbyF_flip[atual_frequencia_flip + 1]; 
023C8:  MOVF   x6F,W
023CA:  MULLW  04
023CC:  MOVF   FF3,W
023CE:  CLRF   03
023D0:  ADDLW  0F
023D2:  MOVWF  FE9
023D4:  MOVLW  05
023D6:  ADDWFC 03,W
023D8:  MOVWF  FEA
023DA:  MOVFF  FEF,5A6
023DE:  MOVFF  FEC,5A7
023E2:  MOVFF  FEC,5A8
023E6:  MOVFF  FEC,5A9
023EA:  MOVLW  01
023EC:  ADDWF  x6F,W
023EE:  MULLW  04
023F0:  MOVF   FF3,W
023F2:  CLRF   03
023F4:  ADDLW  0F
023F6:  MOVWF  FE9
023F8:  MOVLW  05
023FA:  ADDWFC 03,W
023FC:  MOVWF  FEA
023FE:  MOVFF  FEF,00
02402:  MOVFF  FEC,01
02406:  MOVFF  FEC,02
0240A:  MOVFF  FEC,03
0240E:  MOVF   xA6,W
02410:  ADDWF  00,F
02412:  MOVF   xA7,W
02414:  ADDWFC 01,F
02416:  MOVF   xA8,W
02418:  ADDWFC 02,F
0241A:  MOVF   xA9,W
0241C:  ADDWFC 03,F
0241E:  MOVF   00,W
02420:  ADDWF  x6B,F
02422:  MOVF   01,W
02424:  ADDWFC x6C,F
02426:  MOVF   02,W
02428:  ADDWFC x6D,F
0242A:  MOVF   03,W
0242C:  ADDWFC x6E,F
....................             atual_frequencia_flip++; 
0242E:  INCF   x6F,F
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
02430:  MOVF   x6F,W
02432:  MULLW  04
02434:  MOVF   FF3,W
02436:  CLRF   03
02438:  ADDLW  BF
0243A:  MOVWF  FE9
0243C:  MOVLW  04
0243E:  ADDWFC 03,W
02440:  MOVWF  FEA
02442:  MOVFF  FEF,00
02446:  MOVFF  FEC,01
0244A:  MOVFF  FEC,02
0244E:  MOVFF  FEC,03
02452:  MOVLW  FF
02454:  BSF    FD8.0
02456:  SUBFWB 00,W
02458:  MOVWF  xA6
0245A:  MOVLW  FF
0245C:  SUBFWB 01,W
0245E:  MOVWF  xA7
02460:  MOVLW  00
02462:  SUBFWB 02,W
02464:  MOVLW  00
02466:  SUBFWB 03,W
02468:  MOVFF  5A7,FB3
0246C:  MOVFF  5A6,FB2
....................         } else { 
02470:  BRA    24B2
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
02472:  MOVF   x6F,W
02474:  MULLW  04
02476:  MOVF   FF3,W
02478:  CLRF   03
0247A:  ADDLW  BF
0247C:  MOVWF  FE9
0247E:  MOVLW  04
02480:  ADDWFC 03,W
02482:  MOVWF  FEA
02484:  MOVFF  FEF,00
02488:  MOVFF  FEC,01
0248C:  MOVFF  FEC,02
02490:  MOVFF  FEC,03
02494:  MOVLW  FF
02496:  BSF    FD8.0
02498:  SUBFWB 00,W
0249A:  MOVWF  xA6
0249C:  MOVLW  FF
0249E:  SUBFWB 01,W
024A0:  MOVWF  xA7
024A2:  MOVLW  00
024A4:  SUBFWB 02,W
024A6:  MOVLW  00
024A8:  SUBFWB 03,W
024AA:  MOVFF  5A7,FB3
024AE:  MOVFF  5A6,FB2
....................         } 
....................     } else if (atual_frequencia_flip == vel_flip) { 
024B2:  BRA    25C6
024B4:  MOVF   x70,W
024B6:  SUBWF  x6F,W
024B8:  BNZ   24FC
....................         set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
024BA:  MOVF   x6F,W
024BC:  MULLW  04
024BE:  MOVF   FF3,W
024C0:  CLRF   03
024C2:  ADDLW  BF
024C4:  MOVWF  FE9
024C6:  MOVLW  04
024C8:  ADDWFC 03,W
024CA:  MOVWF  FEA
024CC:  MOVFF  FEF,00
024D0:  MOVFF  FEC,01
024D4:  MOVFF  FEC,02
024D8:  MOVFF  FEC,03
024DC:  MOVLW  FF
024DE:  BSF    FD8.0
024E0:  SUBFWB 00,W
024E2:  MOVWF  xA6
024E4:  MOVLW  FF
024E6:  SUBFWB 01,W
024E8:  MOVWF  xA7
024EA:  MOVLW  00
024EC:  SUBFWB 02,W
024EE:  MOVLW  00
024F0:  SUBFWB 03,W
024F2:  MOVFF  5A7,FB3
024F6:  MOVFF  5A6,FB2
....................     } else { 
024FA:  BRA    25C6
....................         if (step_no_flip == step_acumulado_flip) { 
024FC:  MOVF   x6B,W
024FE:  SUBWF  x63,W
02500:  BNZ   2586
02502:  MOVF   x6C,W
02504:  SUBWF  x64,W
02506:  BNZ   2586
02508:  MOVF   x6D,F
0250A:  BNZ   2586
0250C:  MOVF   x6E,F
0250E:  BNZ   2586
....................             atual_frequencia_flip++; 
02510:  INCF   x6F,F
....................             step_acumulado_flip += StepbyF_flip[atual_frequencia_flip]; 
02512:  MOVF   x6F,W
02514:  MULLW  04
02516:  MOVF   FF3,W
02518:  CLRF   03
0251A:  ADDLW  0F
0251C:  MOVWF  FE9
0251E:  MOVLW  05
02520:  ADDWFC 03,W
02522:  MOVWF  FEA
02524:  MOVFF  FEF,00
02528:  MOVFF  FEC,01
0252C:  MOVFF  FEC,02
02530:  MOVFF  FEC,03
02534:  MOVF   00,W
02536:  ADDWF  x6B,F
02538:  MOVF   01,W
0253A:  ADDWFC x6C,F
0253C:  MOVF   02,W
0253E:  ADDWFC x6D,F
02540:  MOVF   03,W
02542:  ADDWFC x6E,F
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
02544:  MOVF   x6F,W
02546:  MULLW  04
02548:  MOVF   FF3,W
0254A:  CLRF   03
0254C:  ADDLW  BF
0254E:  MOVWF  FE9
02550:  MOVLW  04
02552:  ADDWFC 03,W
02554:  MOVWF  FEA
02556:  MOVFF  FEF,00
0255A:  MOVFF  FEC,01
0255E:  MOVFF  FEC,02
02562:  MOVFF  FEC,03
02566:  MOVLW  FF
02568:  BSF    FD8.0
0256A:  SUBFWB 00,W
0256C:  MOVWF  xA6
0256E:  MOVLW  FF
02570:  SUBFWB 01,W
02572:  MOVWF  xA7
02574:  MOVLW  00
02576:  SUBFWB 02,W
02578:  MOVLW  00
0257A:  SUBFWB 03,W
0257C:  MOVFF  5A7,FB3
02580:  MOVFF  5A6,FB2
....................         } else { 
02584:  BRA    25C6
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
02586:  MOVF   x6F,W
02588:  MULLW  04
0258A:  MOVF   FF3,W
0258C:  CLRF   03
0258E:  ADDLW  BF
02590:  MOVWF  FE9
02592:  MOVLW  04
02594:  ADDWFC 03,W
02596:  MOVWF  FEA
02598:  MOVFF  FEF,00
0259C:  MOVFF  FEC,01
025A0:  MOVFF  FEC,02
025A4:  MOVFF  FEC,03
025A8:  MOVLW  FF
025AA:  BSF    FD8.0
025AC:  SUBFWB 00,W
025AE:  MOVWF  xA6
025B0:  MOVLW  FF
025B2:  SUBFWB 01,W
025B4:  MOVWF  xA7
025B6:  MOVLW  00
025B8:  SUBFWB 02,W
025BA:  MOVLW  00
025BC:  SUBFWB 03,W
025BE:  MOVFF  5A7,FB3
025C2:  MOVFF  5A6,FB2
....................         } 
....................         break; 
....................     } 
025C6:  MOVLB  0
025C8:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_descida_flip() { 
....................     if (atual_frequencia_flip == 0) { 
025CA:  MOVLB  5
025CC:  MOVF   x6F,F
025CE:  BNZ   2612
....................         set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
025D0:  MOVF   x6F,W
025D2:  MULLW  04
025D4:  MOVF   FF3,W
025D6:  CLRF   03
025D8:  ADDLW  BF
025DA:  MOVWF  FE9
025DC:  MOVLW  04
025DE:  ADDWFC 03,W
025E0:  MOVWF  FEA
025E2:  MOVFF  FEF,00
025E6:  MOVFF  FEC,01
025EA:  MOVFF  FEC,02
025EE:  MOVFF  FEC,03
025F2:  MOVLW  FF
025F4:  BSF    FD8.0
025F6:  SUBFWB 00,W
025F8:  MOVWF  xA6
025FA:  MOVLW  FF
025FC:  SUBFWB 01,W
025FE:  MOVWF  xA7
02600:  MOVLW  00
02602:  SUBFWB 02,W
02604:  MOVLW  00
02606:  SUBFWB 03,W
02608:  MOVFF  5A7,FB3
0260C:  MOVFF  5A6,FB2
....................     } 
02610:  BRA    2824
....................     else if (atual_frequencia_flip == vel_flip) { 
02612:  MOVF   x70,W
02614:  SUBWF  x6F,W
02616:  BTFSS  FD8.2
02618:  BRA    275A
....................         if (step_no_flip == (step_down_flip + StepbyF_flip[atual_frequencia_flip])) { 
0261A:  MOVF   x6F,W
0261C:  MULLW  04
0261E:  MOVF   FF3,W
02620:  CLRF   03
02622:  ADDLW  0F
02624:  MOVWF  FE9
02626:  MOVLW  05
02628:  ADDWFC 03,W
0262A:  MOVWF  FEA
0262C:  MOVFF  FEF,00
02630:  MOVFF  FEC,01
02634:  MOVFF  FEC,02
02638:  MOVFF  FEC,03
0263C:  MOVF   x65,W
0263E:  ADDWF  00,F
02640:  MOVF   x66,W
02642:  ADDWFC 01,F
02644:  MOVLW  00
02646:  ADDWFC 02,F
02648:  ADDWFC 03,F
0264A:  MOVF   00,W
0264C:  SUBWF  x63,W
0264E:  BNZ   2718
02650:  MOVF   01,W
02652:  SUBWF  x64,W
02654:  BNZ   2718
02656:  MOVF   02,F
02658:  BNZ   2718
0265A:  MOVF   03,F
0265C:  BNZ   2718
....................             step_acumulado_flip = step_down_flip + StepbyF_flip[atual_frequencia_flip] + StepbyF_flip[atual_frequencia_flip - 1]; 
0265E:  MOVF   x6F,W
02660:  MULLW  04
02662:  MOVF   FF3,W
02664:  CLRF   03
02666:  ADDLW  0F
02668:  MOVWF  FE9
0266A:  MOVLW  05
0266C:  ADDWFC 03,W
0266E:  MOVWF  FEA
02670:  MOVFF  FEF,00
02674:  MOVFF  FEC,01
02678:  MOVFF  FEC,02
0267C:  MOVFF  FEC,03
02680:  MOVF   00,W
02682:  ADDWF  x65,W
02684:  MOVWF  xA6
02686:  MOVF   01,W
02688:  ADDWFC x66,W
0268A:  MOVWF  xA7
0268C:  MOVLW  00
0268E:  ADDWFC 02,W
02690:  MOVWF  xA8
02692:  MOVLW  00
02694:  ADDWFC 03,W
02696:  MOVWF  xA9
02698:  MOVLW  01
0269A:  SUBWF  x6F,W
0269C:  MULLW  04
0269E:  MOVF   FF3,W
026A0:  CLRF   03
026A2:  ADDLW  0F
026A4:  MOVWF  FE9
026A6:  MOVLW  05
026A8:  ADDWFC 03,W
026AA:  MOVWF  FEA
026AC:  MOVFF  FEF,00
026B0:  MOVFF  FEC,01
026B4:  MOVFF  FEC,02
026B8:  MOVFF  FEC,03
026BC:  MOVF   00,W
026BE:  ADDWF  xA6,W
026C0:  MOVWF  x6B
026C2:  MOVF   01,W
026C4:  ADDWFC xA7,W
026C6:  MOVWF  x6C
026C8:  MOVF   02,W
026CA:  ADDWFC xA8,W
026CC:  MOVWF  x6D
026CE:  MOVF   03,W
026D0:  ADDWFC xA9,W
026D2:  MOVWF  x6E
....................             atual_frequencia_flip--; 
026D4:  DECF   x6F,F
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
026D6:  MOVF   x6F,W
026D8:  MULLW  04
026DA:  MOVF   FF3,W
026DC:  CLRF   03
026DE:  ADDLW  BF
026E0:  MOVWF  FE9
026E2:  MOVLW  04
026E4:  ADDWFC 03,W
026E6:  MOVWF  FEA
026E8:  MOVFF  FEF,00
026EC:  MOVFF  FEC,01
026F0:  MOVFF  FEC,02
026F4:  MOVFF  FEC,03
026F8:  MOVLW  FF
026FA:  BSF    FD8.0
026FC:  SUBFWB 00,W
026FE:  MOVWF  xA6
02700:  MOVLW  FF
02702:  SUBFWB 01,W
02704:  MOVWF  xA7
02706:  MOVLW  00
02708:  SUBFWB 02,W
0270A:  MOVLW  00
0270C:  SUBFWB 03,W
0270E:  MOVFF  5A7,FB3
02712:  MOVFF  5A6,FB2
....................         } else { 
02716:  BRA    2758
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
02718:  MOVF   x6F,W
0271A:  MULLW  04
0271C:  MOVF   FF3,W
0271E:  CLRF   03
02720:  ADDLW  BF
02722:  MOVWF  FE9
02724:  MOVLW  04
02726:  ADDWFC 03,W
02728:  MOVWF  FEA
0272A:  MOVFF  FEF,00
0272E:  MOVFF  FEC,01
02732:  MOVFF  FEC,02
02736:  MOVFF  FEC,03
0273A:  MOVLW  FF
0273C:  BSF    FD8.0
0273E:  SUBFWB 00,W
02740:  MOVWF  xA6
02742:  MOVLW  FF
02744:  SUBFWB 01,W
02746:  MOVWF  xA7
02748:  MOVLW  00
0274A:  SUBFWB 02,W
0274C:  MOVLW  00
0274E:  SUBFWB 03,W
02750:  MOVFF  5A7,FB3
02754:  MOVFF  5A6,FB2
....................         } 
....................     } else { 
02758:  BRA    2824
....................         if (step_no_flip == step_acumulado_flip) { 
0275A:  MOVF   x6B,W
0275C:  SUBWF  x63,W
0275E:  BNZ   27E4
02760:  MOVF   x6C,W
02762:  SUBWF  x64,W
02764:  BNZ   27E4
02766:  MOVF   x6D,F
02768:  BNZ   27E4
0276A:  MOVF   x6E,F
0276C:  BNZ   27E4
....................             atual_frequencia_flip--; 
0276E:  DECF   x6F,F
....................             step_acumulado_flip += StepbyF_flip[atual_frequencia_flip]; 
02770:  MOVF   x6F,W
02772:  MULLW  04
02774:  MOVF   FF3,W
02776:  CLRF   03
02778:  ADDLW  0F
0277A:  MOVWF  FE9
0277C:  MOVLW  05
0277E:  ADDWFC 03,W
02780:  MOVWF  FEA
02782:  MOVFF  FEF,00
02786:  MOVFF  FEC,01
0278A:  MOVFF  FEC,02
0278E:  MOVFF  FEC,03
02792:  MOVF   00,W
02794:  ADDWF  x6B,F
02796:  MOVF   01,W
02798:  ADDWFC x6C,F
0279A:  MOVF   02,W
0279C:  ADDWFC x6D,F
0279E:  MOVF   03,W
027A0:  ADDWFC x6E,F
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
027A2:  MOVF   x6F,W
027A4:  MULLW  04
027A6:  MOVF   FF3,W
027A8:  CLRF   03
027AA:  ADDLW  BF
027AC:  MOVWF  FE9
027AE:  MOVLW  04
027B0:  ADDWFC 03,W
027B2:  MOVWF  FEA
027B4:  MOVFF  FEF,00
027B8:  MOVFF  FEC,01
027BC:  MOVFF  FEC,02
027C0:  MOVFF  FEC,03
027C4:  MOVLW  FF
027C6:  BSF    FD8.0
027C8:  SUBFWB 00,W
027CA:  MOVWF  xA6
027CC:  MOVLW  FF
027CE:  SUBFWB 01,W
027D0:  MOVWF  xA7
027D2:  MOVLW  00
027D4:  SUBFWB 02,W
027D6:  MOVLW  00
027D8:  SUBFWB 03,W
027DA:  MOVFF  5A7,FB3
027DE:  MOVFF  5A6,FB2
....................         } else { 
027E2:  BRA    2824
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
027E4:  MOVF   x6F,W
027E6:  MULLW  04
027E8:  MOVF   FF3,W
027EA:  CLRF   03
027EC:  ADDLW  BF
027EE:  MOVWF  FE9
027F0:  MOVLW  04
027F2:  ADDWFC 03,W
027F4:  MOVWF  FEA
027F6:  MOVFF  FEF,00
027FA:  MOVFF  FEC,01
027FE:  MOVFF  FEC,02
02802:  MOVFF  FEC,03
02806:  MOVLW  FF
02808:  BSF    FD8.0
0280A:  SUBFWB 00,W
0280C:  MOVWF  xA6
0280E:  MOVLW  FF
02810:  SUBFWB 01,W
02812:  MOVWF  xA7
02814:  MOVLW  00
02816:  SUBFWB 02,W
02818:  MOVLW  00
0281A:  SUBFWB 03,W
0281C:  MOVFF  5A7,FB3
02820:  MOVFF  5A6,FB2
....................         } 
....................     } 
02824:  MOVLB  0
02826:  GOTO   288C (RETURN)
.................... } 
....................  
.................... void movimenta_eixo_flip() { 
....................  
....................     switch (ramp_sts_flip) { 
0282A:  MOVLB  5
0282C:  MOVF   x62,W
0282E:  XORLW  01
02830:  MOVLB  0
02832:  BZ    283E
02834:  XORLW  02
02836:  BZ    2880
02838:  XORLW  01
0283A:  BZ    28A0
0283C:  BRA    28C2
....................         case ramp_up: // accel 
....................             output_toggle(step_flip); 
0283E:  BCF    F96.2
02840:  BTG    F8D.2
....................             rest_flip = ~rest_flip; 
02842:  MOVLB  3
02844:  BTG    xB8.4
....................             proximo_valor_subida_flip(); 
02846:  MOVLB  0
02848:  RCALL  238A
....................             if (step_no_flip == midpt_flip) { // midpoint: decel 
0284A:  MOVLB  5
0284C:  MOVF   x69,W
0284E:  SUBWF  x63,W
02850:  BNZ   287E
02852:  MOVF   x6A,W
02854:  SUBWF  x64,W
02856:  BNZ   287E
....................                 if (move_flip > 2 * total_acc_step_flip) 
02858:  BCF    FD8.0
0285A:  RLCF   x5F,W
0285C:  MOVWF  02
0285E:  RLCF   x60,W
02860:  MOVWF  03
02862:  MOVFF  02,01
02866:  MOVF   03,W
02868:  SUBWF  x68,W
0286A:  BNC   287A
0286C:  BNZ   2874
0286E:  MOVF   x67,W
02870:  SUBWF  01,W
02872:  BC    287A
....................                     ramp_sts_flip = ramp_max; 
02874:  MOVLW  02
02876:  MOVWF  x62
02878:  BRA    287E
....................                 else 
....................                     ramp_sts_flip = ramp_down; 
0287A:  MOVLW  03
0287C:  MOVWF  x62
....................             } 
....................             break; 
0287E:  BRA    28CA
....................  
....................         case ramp_down: // decel 
....................             output_toggle(step_flip); 
02880:  BCF    F96.2
02882:  BTG    F8D.2
....................             rest_flip = ~rest_flip; 
02884:  MOVLB  3
02886:  BTG    xB8.4
....................             proximo_valor_descida_flip(); 
02888:  MOVLB  0
0288A:  BRA    25CA
....................             if (step_no_flip == move_flip) 
0288C:  MOVLB  5
0288E:  MOVF   x67,W
02890:  SUBWF  x63,W
02892:  BNZ   289E
02894:  MOVF   x68,W
02896:  SUBWF  x64,W
02898:  BNZ   289E
....................                 ramp_sts_flip = ramp_last; 
0289A:  MOVLW  04
0289C:  MOVWF  x62
....................             break; 
0289E:  BRA    28CA
....................  
....................         case ramp_max: // constant speed 
....................             output_toggle(step_flip); 
028A0:  BCF    F96.2
028A2:  BTG    F8D.2
....................             rest_flip = ~rest_flip; 
028A4:  MOVLB  3
028A6:  BTG    xB8.4
....................             proximo_valor_subida_flip(); 
028A8:  MOVLB  0
028AA:  RCALL  238A
....................             if (step_no_flip == step_down_flip) // start decel 
028AC:  MOVLB  5
028AE:  MOVF   x65,W
028B0:  SUBWF  x63,W
028B2:  BNZ   28BE
028B4:  MOVF   x66,W
028B6:  SUBWF  x64,W
028B8:  BNZ   28BE
....................                 ramp_sts_flip = ramp_down; 
028BA:  MOVLW  03
028BC:  MOVWF  x62
....................             break; 
028BE:  BRA    28CA
028C0:  MOVLB  0
....................  
....................         default: // last step: cleanup 
....................             ramp_sts_flip = ramp_idle; 
028C2:  MOVLB  5
028C4:  CLRF   x62
....................             disable_interrupts(INT_TIMER3); 
028C6:  BCF    FA0.1
....................             run_flg_flip = FALSE; // move_z complete 
028C8:  BCF    2D.3
....................             break; 
....................     } // switch (ramp_sts_z) 
....................     if (ramp_sts_flip != ramp_idle) { 
028CA:  MOVF   x62,F
028CC:  BZ    28EE
....................         if (rest_flip) { 
028CE:  MOVLB  3
028D0:  BTFSS  xB8.4
028D2:  BRA    28F0
....................             motor_pos_flip += pos_inc_flip; 
028D4:  CLRF   03
028D6:  MOVLB  5
028D8:  MOVF   x61,W
028DA:  BTFSC  FE8.7
028DC:  DECF   03,F
028DE:  MOVLB  2
028E0:  ADDWF  x08,F
028E2:  MOVF   03,W
028E4:  ADDWFC x09,F
....................             ++step_no_flip; 
028E6:  MOVLB  5
028E8:  INCF   x63,F
028EA:  BTFSC  FD8.2
028EC:  INCF   x64,F
028EE:  MOVLB  3
....................         } 
....................     } 
028F0:  MOVLB  0
028F2:  GOTO   2900 (RETURN)
.................... } 
....................  
.................... void umpasso_flip(int16 descanco, short dir) { 
....................     output_low(enable_flip); 
....................     if (dir) { 
....................         output_high(dir_flip); 
....................         motor_pos_flip--; 
....................     } else { 
....................         output_low(dir_flip); 
....................         motor_pos_flip++; 
....................     } 
....................     output_high(step_flip); 
....................     delay_us(descanco); 
....................     output_low(step_flip); 
....................     delay_us(descanco); 
....................  
.................... } 
....................  
.................... void zerar_flip() { 
....................  
....................     while (le_Input(s_limite_flip) == 1) { 
....................         delay_us(200); 
....................         umpasso_flip(600, FALSE);//600 
....................     } 
....................     while (le_Input(s_limite_flip) == 0) { 
....................         delay_us(200); 
....................         umpasso_flip(900, TRUE);//900 
....................     } 
....................     while (le_Input(s_limite_flip) == 1) { 
....................         delay_us(200); 
....................         umpasso_flip(1000, FALSE);//1000 
....................     } 
....................    // output_high(enable_z); 
....................     motor_pos_flip = 0; 
.................... } 
....................  
.................... void medir_flip() { 
....................     while (le_Input(i_limite_flip) == 0) { 
....................         umpasso_flip(900, FALSE); 
....................         delay_us(200); 
....................     } 
....................     while (le_Input(i_limite_flip) == 1) { 
....................         umpasso_flip(900, TRUE); 
....................         delay_us(200); 
....................     } 
....................     max_posicao_flip = motor_pos_flip; 
....................     output_high(enable_flip); 
....................     printf(lcd_putc, "%04Lu", max_posicao_flip); 
.................... } 
.................... // </editor-fold> 
....................  
.................... #include "movimentos_maq_2.c" 
.................... void  flip_home(void) { 
.................... 	int i; 
.................... 	chopper_flip(); 
*
05BAC:  BRA    5B4E
.................... 	delay_ms(50);	 
05BAE:  MOVLW  32
05BB0:  MOVLB  5
05BB2:  MOVWF  x92
05BB4:  MOVLB  0
05BB6:  CALL   2958
.................... 	if(le_Input(S_ROTACAO_LS1) == true) { 
05BBA:  MOVLW  0B
05BBC:  MOVLB  5
05BBE:  MOVWF  x7A
05BC0:  MOVLB  0
05BC2:  CALL   49FA
05BC6:  DECFSZ 01,W
05BC8:  BRA    5C12
.................... 		sentido_horario(); 
05BCA:  RCALL  5B56
.................... 	    while(le_Input(S_ROTACAO_LS1) == true) {				 
05BCC:  MOVLW  0B
05BCE:  MOVLB  5
05BD0:  MOVWF  x7A
05BD2:  MOVLB  0
05BD4:  CALL   49FA
05BD8:  DECFSZ 01,W
05BDA:  BRA    5BEC
....................             one_step_flip(); 
05BDC:  RCALL  5B64
....................             delay_us(4000); 
05BDE:  MOVLW  04
05BE0:  MOVLB  5
05BE2:  MOVWF  x92
05BE4:  MOVLB  0
05BE6:  CALL   2958
05BEA:  BRA    5BCC
.................... 		} 
....................         sentido_antihorario(); 
05BEC:  RCALL  5B9E
....................         for(i=0;i<=47;i++) { 
05BEE:  MOVLB  5
05BF0:  CLRF   x79
05BF2:  MOVF   x79,W
05BF4:  SUBLW  2F
05BF6:  BNC   5C0E
....................             one_step_flip(); 
05BF8:  MOVLB  0
05BFA:  RCALL  5B64
....................             delay_us(4000); 
05BFC:  MOVLW  04
05BFE:  MOVLB  5
05C00:  MOVWF  x92
05C02:  MOVLB  0
05C04:  CALL   2958
05C08:  MOVLB  5
05C0A:  INCF   x79,F
05C0C:  BRA    5BF2
....................         }		 
.................... 	} 
05C0E:  BRA    5C60
05C10:  MOVLB  0
....................     else{			 
....................         sentido_antihorario(); 
05C12:  RCALL  5B9E
....................         delay_ms(50); 
05C14:  MOVLW  32
05C16:  MOVLB  5
05C18:  MOVWF  x92
05C1A:  MOVLB  0
05C1C:  CALL   2958
....................         while(le_Input(S_ROTACAO_LS1) == false){				 
05C20:  MOVLW  0B
05C22:  MOVLB  5
05C24:  MOVWF  x7A
05C26:  MOVLB  0
05C28:  CALL   49FA
05C2C:  MOVF   01,F
05C2E:  BNZ   5C40
....................             one_step_flip(); 
05C30:  RCALL  5B64
....................             delay_us(2000); 
05C32:  MOVLW  02
05C34:  MOVLB  5
05C36:  MOVWF  x92
05C38:  MOVLB  0
05C3A:  CALL   2958
05C3E:  BRA    5C20
....................         }				 
....................         for(i=0;i<=42;i++) { 
05C40:  MOVLB  5
05C42:  CLRF   x79
05C44:  MOVF   x79,W
05C46:  SUBLW  2A
05C48:  BNC   5C60
....................             one_step_flip(); 
05C4A:  MOVLB  0
05C4C:  RCALL  5B64
....................             delay_us(4000); 
05C4E:  MOVLW  04
05C50:  MOVLB  5
05C52:  MOVWF  x92
05C54:  MOVLB  0
05C56:  CALL   2958
05C5A:  MOVLB  5
05C5C:  INCF   x79,F
05C5E:  BRA    5C44
....................         } 
.................... 	}	  
....................     sentido_horario(); 
05C60:  MOVLB  0
05C62:  RCALL  5B56
....................     delay_ms(50);// 
05C64:  MOVLW  32
05C66:  MOVLB  5
05C68:  MOVWF  x92
05C6A:  MOVLB  0
05C6C:  CALL   2958
....................     for(i=0;i<=58;i++) { 
05C70:  MOVLB  5
05C72:  CLRF   x79
05C74:  MOVF   x79,W
05C76:  SUBLW  3A
05C78:  BNC   5C90
....................         one_step_flip(); 
05C7A:  MOVLB  0
05C7C:  RCALL  5B64
....................         delay_us(4000); 
05C7E:  MOVLW  04
05C80:  MOVLB  5
05C82:  MOVWF  x92
05C84:  MOVLB  0
05C86:  CALL   2958
05C8A:  MOVLB  5
05C8C:  INCF   x79,F
05C8E:  BRA    5C74
....................     } 
....................     motor_pos_flip = 0;			 
05C90:  MOVLB  2
05C92:  CLRF   x09
05C94:  CLRF   x08
05C96:  MOVLB  0
05C98:  GOTO   5DB4 (RETURN)
.................... } 
.................... void  x_home_esquerda() { 
.................... 	int i; 
.................... 	chopper_x(); 
.................... 	delay_ms(50);	 
.................... 	if(le_Input(S_X_ESQUERDA) == true) { 
.................... 		direita(); 
.................... 		delay_ms(50); 
....................         while(le_Input(S_X_ESQUERDA) == true) { 
....................             one_step_x(); 
....................             delay_us(2000); 
....................         } 
....................         for(i=0;i<=40;i++) { 
....................             one_step_x(); 
....................             delay_us(2000); 
....................         } 
.................... 		esquerda(); 
.................... 		delay_ms(50); 
....................         while(le_Input(S_X_ESQUERDA) == false) {				 
....................             one_step_x(); 
....................             delay_us(2000); 
.................... 		}			 
....................         for(i=0;i<=40;i++) { 
....................             one_step_x(); 
....................             delay_us(2000); 
....................         } 
.................... 	}else{ 
....................         esquerda(); 
....................         delay_ms(50); 
....................         while(le_Input(S_X_ESQUERDA) == false) { 
....................             one_step_x(); 
....................             delay_us(2000); 
....................         }				 
....................         for(i=0;i<=40;i++) { 
....................             one_step_x(); 
....................             delay_us(2000); 
....................         } 
.................... 	}	 
....................     motor_pos_x = 0;  
....................     stop_x();			 
.................... } 
.................... void  y_home_frente(){ 
.................... 	int i; 
.................... 	chopper_y(); 
*
0505E:  RCALL  4D90
.................... 	delay_ms(50);	 
05060:  MOVLW  32
05062:  MOVLB  5
05064:  MOVWF  x92
05066:  MOVLB  0
05068:  CALL   2958
.................... 	if(le_Input(S_Y_FRENTE) == true) { 
0506C:  MOVLW  07
0506E:  MOVLB  5
05070:  MOVWF  x7A
05072:  MOVLB  0
05074:  RCALL  49FA
05076:  DECFSZ 01,W
05078:  BRA    5118
.................... 		atras(); 
0507A:  RCALL  4DCA
.................... 		delay_ms(50); 
0507C:  MOVLW  32
0507E:  MOVLB  5
05080:  MOVWF  x92
05082:  MOVLB  0
05084:  CALL   2958
....................         while(le_Input(S_Y_FRENTE) == true) { 
05088:  MOVLW  07
0508A:  MOVLB  5
0508C:  MOVWF  x7A
0508E:  MOVLB  0
05090:  RCALL  49FA
05092:  DECFSZ 01,W
05094:  BRA    50A6
....................             one_step_y(); 
05096:  RCALL  4D96
....................             delay_us(2000); 
05098:  MOVLW  02
0509A:  MOVLB  5
0509C:  MOVWF  x92
0509E:  MOVLB  0
050A0:  CALL   2958
050A4:  BRA    5088
....................         } 
....................         for(i=0;i<=40;i++) { //para sair do histerese do sensor dando maior precisao 
050A6:  MOVLB  5
050A8:  CLRF   x75
050AA:  MOVF   x75,W
050AC:  SUBLW  28
050AE:  BNC   50C6
....................             one_step_y(); 
050B0:  MOVLB  0
050B2:  RCALL  4D96
....................             delay_us(2000); 
050B4:  MOVLW  02
050B6:  MOVLB  5
050B8:  MOVWF  x92
050BA:  MOVLB  0
050BC:  CALL   2958
050C0:  MOVLB  5
050C2:  INCF   x75,F
050C4:  BRA    50AA
....................         } 
.................... 		frente(); 
050C6:  MOVLB  0
050C8:  RCALL  4D82
.................... 		delay_ms(50); 
050CA:  MOVLW  32
050CC:  MOVLB  5
050CE:  MOVWF  x92
050D0:  MOVLB  0
050D2:  CALL   2958
....................         while(le_Input(S_Y_FRENTE) == false){				 
050D6:  MOVLW  07
050D8:  MOVLB  5
050DA:  MOVWF  x7A
050DC:  MOVLB  0
050DE:  RCALL  49FA
050E0:  MOVF   01,F
050E2:  BNZ   50F4
....................             one_step_y(); 
050E4:  RCALL  4D96
....................             delay_us(2000); 
050E6:  MOVLW  02
050E8:  MOVLB  5
050EA:  MOVWF  x92
050EC:  MOVLB  0
050EE:  CALL   2958
050F2:  BRA    50D6
....................         }				 
....................         for(i=0;i<=40;i++){ 
050F4:  MOVLB  5
050F6:  CLRF   x75
050F8:  MOVF   x75,W
050FA:  SUBLW  28
050FC:  BNC   5114
....................             one_step_y(); 
050FE:  MOVLB  0
05100:  RCALL  4D96
....................             delay_us(2000); 
05102:  MOVLW  02
05104:  MOVLB  5
05106:  MOVWF  x92
05108:  MOVLB  0
0510A:  CALL   2958
0510E:  MOVLB  5
05110:  INCF   x75,F
05112:  BRA    50F8
....................         } 
.................... 	}else{ 
05114:  BRA    5164
05116:  MOVLB  0
....................         frente(); 
05118:  RCALL  4D82
....................         delay_ms(50); 
0511A:  MOVLW  32
0511C:  MOVLB  5
0511E:  MOVWF  x92
05120:  MOVLB  0
05122:  CALL   2958
....................         while(le_Input(S_Y_FRENTE) == false) { 
05126:  MOVLW  07
05128:  MOVLB  5
0512A:  MOVWF  x7A
0512C:  MOVLB  0
0512E:  RCALL  49FA
05130:  MOVF   01,F
05132:  BNZ   5144
....................             one_step_y(); 
05134:  RCALL  4D96
....................             delay_us(2000); 
05136:  MOVLW  02
05138:  MOVLB  5
0513A:  MOVWF  x92
0513C:  MOVLB  0
0513E:  CALL   2958
05142:  BRA    5126
....................         }				 
....................         for(i=0;i<=40;i++) { 
05144:  MOVLB  5
05146:  CLRF   x75
05148:  MOVF   x75,W
0514A:  SUBLW  28
0514C:  BNC   5164
....................             one_step_y(); 
0514E:  MOVLB  0
05150:  RCALL  4D96
....................             delay_us(2000); 
05152:  MOVLW  02
05154:  MOVLB  5
05156:  MOVWF  x92
05158:  MOVLB  0
0515A:  CALL   2958
0515E:  MOVLB  5
05160:  INCF   x75,F
05162:  BRA    5148
....................         } 
.................... 	}	 
....................     motor_pos_y = 0;   
05164:  MOVLB  2
05166:  CLRF   x07
05168:  CLRF   x06
....................     stop_y();			 
0516A:  MOVLB  0
0516C:  RCALL  4DD8
0516E:  RETURN 0
.................... } 
.................... void  y_home_atras() { 
.................... 	int i; 
.................... 	chopper_y(); 
*
04DDE:  RCALL  4D90
.................... 	delay_ms(50);	 
04DE0:  MOVLW  32
04DE2:  MOVLB  5
04DE4:  MOVWF  x92
04DE6:  MOVLB  0
04DE8:  CALL   2958
.................... 	if(le_Input(S_Y_ATRAS) == true) { 
04DEC:  MOVLW  08
04DEE:  MOVLB  5
04DF0:  MOVWF  x7A
04DF2:  MOVLB  0
04DF4:  RCALL  49FA
04DF6:  DECFSZ 01,W
04DF8:  BRA    4E98
.................... 		frente(); 
04DFA:  RCALL  4D82
.................... 		delay_ms(50); 
04DFC:  MOVLW  32
04DFE:  MOVLB  5
04E00:  MOVWF  x92
04E02:  MOVLB  0
04E04:  CALL   2958
....................         while(le_Input(S_Y_ATRAS) == true){ 
04E08:  MOVLW  08
04E0A:  MOVLB  5
04E0C:  MOVWF  x7A
04E0E:  MOVLB  0
04E10:  RCALL  49FA
04E12:  DECFSZ 01,W
04E14:  BRA    4E26
....................             one_step_y(); 
04E16:  RCALL  4D96
....................             delay_us(2000); 
04E18:  MOVLW  02
04E1A:  MOVLB  5
04E1C:  MOVWF  x92
04E1E:  MOVLB  0
04E20:  CALL   2958
04E24:  BRA    4E08
....................         } 
....................         for(i=0;i<=40;i++){ //para sair do histerese do sensor dando maior precisao 
04E26:  MOVLB  5
04E28:  CLRF   x75
04E2A:  MOVF   x75,W
04E2C:  SUBLW  28
04E2E:  BNC   4E46
....................             one_step_y(); 
04E30:  MOVLB  0
04E32:  RCALL  4D96
....................             delay_us(2000); 
04E34:  MOVLW  02
04E36:  MOVLB  5
04E38:  MOVWF  x92
04E3A:  MOVLB  0
04E3C:  CALL   2958
04E40:  MOVLB  5
04E42:  INCF   x75,F
04E44:  BRA    4E2A
....................         } 
.................... 		atras(); 
04E46:  MOVLB  0
04E48:  RCALL  4DCA
.................... 		delay_ms(50); 
04E4A:  MOVLW  32
04E4C:  MOVLB  5
04E4E:  MOVWF  x92
04E50:  MOVLB  0
04E52:  CALL   2958
....................         while(le_Input(S_Y_ATRAS) == false) {				 
04E56:  MOVLW  08
04E58:  MOVLB  5
04E5A:  MOVWF  x7A
04E5C:  MOVLB  0
04E5E:  RCALL  49FA
04E60:  MOVF   01,F
04E62:  BNZ   4E74
....................             one_step_y(); 
04E64:  RCALL  4D96
....................             delay_us(2000); 
04E66:  MOVLW  02
04E68:  MOVLB  5
04E6A:  MOVWF  x92
04E6C:  MOVLB  0
04E6E:  CALL   2958
04E72:  BRA    4E56
....................         }				 
....................         for(i=0;i<=40;i++){ 
04E74:  MOVLB  5
04E76:  CLRF   x75
04E78:  MOVF   x75,W
04E7A:  SUBLW  28
04E7C:  BNC   4E94
....................             one_step_y(); 
04E7E:  MOVLB  0
04E80:  RCALL  4D96
....................             delay_us(2000); 
04E82:  MOVLW  02
04E84:  MOVLB  5
04E86:  MOVWF  x92
04E88:  MOVLB  0
04E8A:  CALL   2958
04E8E:  MOVLB  5
04E90:  INCF   x75,F
04E92:  BRA    4E78
....................         } 
.................... 	}else{ 
04E94:  BRA    4EE4
04E96:  MOVLB  0
....................         atras(); 
04E98:  RCALL  4DCA
....................         delay_ms(50); 
04E9A:  MOVLW  32
04E9C:  MOVLB  5
04E9E:  MOVWF  x92
04EA0:  MOVLB  0
04EA2:  CALL   2958
....................         while(le_Input(S_Y_ATRAS) == false) { 
04EA6:  MOVLW  08
04EA8:  MOVLB  5
04EAA:  MOVWF  x7A
04EAC:  MOVLB  0
04EAE:  RCALL  49FA
04EB0:  MOVF   01,F
04EB2:  BNZ   4EC4
....................             one_step_y(); 
04EB4:  RCALL  4D96
....................             delay_us(2000); 
04EB6:  MOVLW  02
04EB8:  MOVLB  5
04EBA:  MOVWF  x92
04EBC:  MOVLB  0
04EBE:  CALL   2958
04EC2:  BRA    4EA6
....................         } 
....................         for(i=0;i<=40;i++) { 
04EC4:  MOVLB  5
04EC6:  CLRF   x75
04EC8:  MOVF   x75,W
04ECA:  SUBLW  28
04ECC:  BNC   4EE4
....................             one_step_y(); 
04ECE:  MOVLB  0
04ED0:  RCALL  4D96
....................             delay_us(2000); 
04ED2:  MOVLW  02
04ED4:  MOVLB  5
04ED6:  MOVWF  x92
04ED8:  MOVLB  0
04EDA:  CALL   2958
04EDE:  MOVLB  5
04EE0:  INCF   x75,F
04EE2:  BRA    4EC8
....................         } 
.................... 	}	 
....................     motor_pos_y = 0; 
04EE4:  MOVLB  2
04EE6:  CLRF   x07
04EE8:  CLRF   x06
....................     stop_y();			 
04EEA:  MOVLB  0
04EEC:  RCALL  4DD8
04EEE:  RETURN 0
.................... } 
.................... void  x_home_direita() {  
.................... 	int i; 
.................... 	chopper_x(); 
*
04F4C:  BRA    4EF0
.................... 	delay_ms(50);	 
04F4E:  MOVLW  32
04F50:  MOVLB  5
04F52:  MOVWF  x92
04F54:  MOVLB  0
04F56:  CALL   2958
.................... 	if(le_Input(S_X_DIREITA) == true) { 
04F5A:  MOVLW  05
04F5C:  MOVLB  5
04F5E:  MOVWF  x7A
04F60:  MOVLB  0
04F62:  RCALL  49FA
04F64:  DECFSZ 01,W
04F66:  BRA    5006
.................... 		esquerda(); 
04F68:  RCALL  4EF8
.................... 		delay_ms(50); 
04F6A:  MOVLW  32
04F6C:  MOVLB  5
04F6E:  MOVWF  x92
04F70:  MOVLB  0
04F72:  CALL   2958
....................         while(le_Input(S_X_DIREITA) == true) { 
04F76:  MOVLW  05
04F78:  MOVLB  5
04F7A:  MOVWF  x7A
04F7C:  MOVLB  0
04F7E:  RCALL  49FA
04F80:  DECFSZ 01,W
04F82:  BRA    4F94
....................             one_step_x(); 
04F84:  RCALL  4F02
....................             delay_us(2000); 
04F86:  MOVLW  02
04F88:  MOVLB  5
04F8A:  MOVWF  x92
04F8C:  MOVLB  0
04F8E:  CALL   2958
04F92:  BRA    4F76
....................         } 
....................         for(i=0;i<=40;i++){ //para sair do histerese do sensor dando maior precisao 
04F94:  MOVLB  5
04F96:  CLRF   x75
04F98:  MOVF   x75,W
04F9A:  SUBLW  28
04F9C:  BNC   4FB4
....................             one_step_x(); 
04F9E:  MOVLB  0
04FA0:  RCALL  4F02
....................             delay_us(2000); 
04FA2:  MOVLW  02
04FA4:  MOVLB  5
04FA6:  MOVWF  x92
04FA8:  MOVLB  0
04FAA:  CALL   2958
04FAE:  MOVLB  5
04FB0:  INCF   x75,F
04FB2:  BRA    4F98
....................         } 
.................... 		direita(); 
04FB4:  MOVLB  0
04FB6:  RCALL  4F3A
.................... 		delay_ms(50); 
04FB8:  MOVLW  32
04FBA:  MOVLB  5
04FBC:  MOVWF  x92
04FBE:  MOVLB  0
04FC0:  CALL   2958
....................         while(le_Input(S_X_DIREITA) == false) {				 
04FC4:  MOVLW  05
04FC6:  MOVLB  5
04FC8:  MOVWF  x7A
04FCA:  MOVLB  0
04FCC:  RCALL  49FA
04FCE:  MOVF   01,F
04FD0:  BNZ   4FE2
....................             one_step_x(); 
04FD2:  RCALL  4F02
....................             delay_us(2000); 
04FD4:  MOVLW  02
04FD6:  MOVLB  5
04FD8:  MOVWF  x92
04FDA:  MOVLB  0
04FDC:  CALL   2958
04FE0:  BRA    4FC4
....................         }				 
....................         for(i=0;i<=40;i++) { 
04FE2:  MOVLB  5
04FE4:  CLRF   x75
04FE6:  MOVF   x75,W
04FE8:  SUBLW  28
04FEA:  BNC   5002
....................             one_step_x(); 
04FEC:  MOVLB  0
04FEE:  RCALL  4F02
....................             delay_us(2000); 
04FF0:  MOVLW  02
04FF2:  MOVLB  5
04FF4:  MOVWF  x92
04FF6:  MOVLB  0
04FF8:  CALL   2958
04FFC:  MOVLB  5
04FFE:  INCF   x75,F
05000:  BRA    4FE6
....................         } 
.................... 	}else{			 
05002:  BRA    5052
05004:  MOVLB  0
....................         direita(); 
05006:  RCALL  4F3A
....................         delay_ms(50); 
05008:  MOVLW  32
0500A:  MOVLB  5
0500C:  MOVWF  x92
0500E:  MOVLB  0
05010:  CALL   2958
....................         while(le_Input(S_X_DIREITA) == false) { 
05014:  MOVLW  05
05016:  MOVLB  5
05018:  MOVWF  x7A
0501A:  MOVLB  0
0501C:  RCALL  49FA
0501E:  MOVF   01,F
05020:  BNZ   5032
....................             one_step_x(); 
05022:  RCALL  4F02
....................             delay_us(2000); 
05024:  MOVLW  02
05026:  MOVLB  5
05028:  MOVWF  x92
0502A:  MOVLB  0
0502C:  CALL   2958
05030:  BRA    5014
....................         } 
....................         for(i=0;i<=40;i++) { 
05032:  MOVLB  5
05034:  CLRF   x75
05036:  MOVF   x75,W
05038:  SUBLW  28
0503A:  BNC   5052
....................             one_step_x(); 
0503C:  MOVLB  0
0503E:  RCALL  4F02
....................             delay_us(2000); 
05040:  MOVLW  02
05042:  MOVLB  5
05044:  MOVWF  x92
05046:  MOVLB  0
05048:  CALL   2958
0504C:  MOVLB  5
0504E:  INCF   x75,F
05050:  BRA    5036
....................         } 
.................... 	} 
....................     motor_pos_x = 0;   
05052:  MOVLB  2
05054:  CLRF   x05
05056:  CLRF   x04
....................     stop_x();			 
05058:  MOVLB  0
0505A:  BRA    4F44
0505C:  RETURN 0
.................... } 
.................... void  z_home() { 
.................... 	int i; 
.................... 	chopper_z(); 
*
04C8E:  BRA    4934
.................... 	delay_ms(50);	 
04C90:  MOVLW  32
04C92:  MOVLB  5
04C94:  MOVWF  x92
04C96:  MOVLB  0
04C98:  CALL   2958
.................... 	if(le_Input(S_Z_TOP) == true) { 
04C9C:  MOVLW  0D
04C9E:  MOVLB  5
04CA0:  MOVWF  x7A
04CA2:  MOVLB  0
04CA4:  RCALL  49FA
04CA6:  DECFSZ 01,W
04CA8:  BRA    4D2A
.................... 		desce(); 
04CAA:  RCALL  4C36
.................... 		delay_ms(50); 
04CAC:  MOVLW  32
04CAE:  MOVLB  5
04CB0:  MOVWF  x92
04CB2:  MOVLB  0
04CB4:  CALL   2958
....................         for(i=0;i<=50;i++){ 
04CB8:  MOVLB  5
04CBA:  CLRF   x75
04CBC:  MOVF   x75,W
04CBE:  SUBLW  32
04CC0:  BNC   4CD8
....................             one_step_z(); 
04CC2:  MOVLB  0
04CC4:  RCALL  4C44
....................             delay_us(2000); 
04CC6:  MOVLW  02
04CC8:  MOVLB  5
04CCA:  MOVWF  x92
04CCC:  MOVLB  0
04CCE:  CALL   2958
04CD2:  MOVLB  5
04CD4:  INCF   x75,F
04CD6:  BRA    4CBC
....................         } 
....................         sobe(); 
04CD8:  MOVLB  0
04CDA:  RCALL  4C78
....................         delay_ms(50); 
04CDC:  MOVLW  32
04CDE:  MOVLB  5
04CE0:  MOVWF  x92
04CE2:  MOVLB  0
04CE4:  CALL   2958
....................         while(le_Input(S_Z_TOP) == false) {				 
04CE8:  MOVLW  0D
04CEA:  MOVLB  5
04CEC:  MOVWF  x7A
04CEE:  MOVLB  0
04CF0:  RCALL  49FA
04CF2:  MOVF   01,F
04CF4:  BNZ   4D06
....................             one_step_z(); 
04CF6:  RCALL  4C44
....................             delay_us(2000); 
04CF8:  MOVLW  02
04CFA:  MOVLB  5
04CFC:  MOVWF  x92
04CFE:  MOVLB  0
04D00:  CALL   2958
04D04:  BRA    4CE8
....................         }				 
....................         for(i=0;i<=18;i++){ 
04D06:  MOVLB  5
04D08:  CLRF   x75
04D0A:  MOVF   x75,W
04D0C:  SUBLW  12
04D0E:  BNC   4D26
....................             one_step_z(); 
04D10:  MOVLB  0
04D12:  RCALL  4C44
....................             delay_us(2000); 
04D14:  MOVLW  02
04D16:  MOVLB  5
04D18:  MOVWF  x92
04D1A:  MOVLB  0
04D1C:  CALL   2958
04D20:  MOVLB  5
04D22:  INCF   x75,F
04D24:  BRA    4D0A
....................         } 
.................... 	}else{ 
04D26:  BRA    4D76
04D28:  MOVLB  0
....................         sobe(); 
04D2A:  RCALL  4C78
....................         delay_ms(50); 
04D2C:  MOVLW  32
04D2E:  MOVLB  5
04D30:  MOVWF  x92
04D32:  MOVLB  0
04D34:  CALL   2958
....................         while(le_Input(S_Z_TOP) == false) { 
04D38:  MOVLW  0D
04D3A:  MOVLB  5
04D3C:  MOVWF  x7A
04D3E:  MOVLB  0
04D40:  RCALL  49FA
04D42:  MOVF   01,F
04D44:  BNZ   4D56
....................             one_step_z(); 
04D46:  RCALL  4C44
....................             delay_us(2000); 
04D48:  MOVLW  02
04D4A:  MOVLB  5
04D4C:  MOVWF  x92
04D4E:  MOVLB  0
04D50:  CALL   2958
04D54:  BRA    4D38
....................         } 
....................         for(i=0;i<=18;i++) { 
04D56:  MOVLB  5
04D58:  CLRF   x75
04D5A:  MOVF   x75,W
04D5C:  SUBLW  12
04D5E:  BNC   4D76
....................             one_step_z(); 
04D60:  MOVLB  0
04D62:  RCALL  4C44
....................             delay_us(2000); 
04D64:  MOVLW  02
04D66:  MOVLB  5
04D68:  MOVWF  x92
04D6A:  MOVLB  0
04D6C:  CALL   2958
04D70:  MOVLB  5
04D72:  INCF   x75,F
04D74:  BRA    4D5A
....................         } 
.................... 	} 
....................     motor_pos_z = 0;    
04D76:  MOVLB  2
04D78:  CLRF   x0B
04D7A:  CLRF   x0A
.................... 	stop_z();			 
04D7C:  MOVLB  0
04D7E:  BRA    4C86
04D80:  RETURN 0
.................... } 
....................  
.................... void envia_maquina_para_posicao(int posicao_futura){ 
....................     motor_run_z(0, 19); 
*
05C9C:  MOVLB  5
05C9E:  CLRF   x80
05CA0:  CLRF   x7F
05CA2:  CLRF   x7E
05CA4:  CLRF   x7D
05CA6:  MOVLW  13
05CA8:  MOVWF  x81
05CAA:  MOVLB  0
05CAC:  CALL   5346
....................     while ((run_flg_z)); 
05CB0:  MOVLB  3
05CB2:  BTFSC  xB8.2
05CB4:  BRA    5CB2
....................     switch (posicao_futura){ 
05CB6:  MOVLB  5
05CB8:  MOVF   x78,W
05CBA:  ADDLW  FA
05CBC:  BTFSC  FD8.0
05CBE:  BRA    6202
05CC0:  ADDLW  06
05CC2:  MOVLB  0
05CC4:  GOTO   6206
....................         case ALIMENTADOR: 
....................             if(posicao_atual != ALIMENTADOR){             
05CC8:  MOVF   26,F
05CCA:  BTFSC  FD8.2
05CCC:  BRA    5DF2
....................                 while ((posicao_atual == SOLDAGEM)||(posicao_atual == HOME2)){ 
05CCE:  MOVF   26,W
05CD0:  SUBLW  03
05CD2:  BZ    5CDA
05CD4:  MOVF   26,W
05CD6:  SUBLW  04
05CD8:  BNZ   5CDE
....................                     tela_esperando_mov_maquina();                 
05CDA:  RCALL  5536
05CDC:  BRA    5CCE
....................                 } 
....................                 posicao_outra_maquina = le_posicao_outra_maquina(); 
05CDE:  CALL   526A
05CE2:  MOVFF  01,28
....................                 while ((posicao_outra_maquina == ALIMENTADOR)){ 
05CE6:  MOVF   28,F
05CE8:  BNZ   5CF6
....................                     tela_esperando_sair_posicao_outra_maquina(); 
05CEA:  RCALL  5568
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
05CEC:  CALL   526A
05CF0:  MOVFF  01,28
05CF4:  BRA    5CE6
....................                 } 
....................                 if (posicao_atual == DISPENSADOR){ 
05CF6:  MOVF   26,W
05CF8:  SUBLW  05
05CFA:  BNZ   5D78
....................                     tela_movimentando_maquina(ALIMENTADOR); 
05CFC:  MOVLB  5
05CFE:  CLRF   x79
05D00:  MOVLB  0
05D02:  CALL   47E8
....................                     motor_run_y(700, 19); 
05D06:  MOVLB  5
05D08:  CLRF   x80
05D0A:  CLRF   x7F
05D0C:  MOVLW  02
05D0E:  MOVWF  x7E
05D10:  MOVLW  BC
05D12:  MOVWF  x7D
05D14:  MOVLW  13
05D16:  MOVWF  x81
05D18:  MOVLB  0
05D1A:  RCALL  55A6
....................                     while ((run_flg_y)); 
05D1C:  MOVLB  2
05D1E:  BTFSC  x0C.7
05D20:  BRA    5D1E
....................                     envia_posicao_para_outra_maquina(ALIMENTADOR); 
05D22:  MOVLB  5
05D24:  CLRF   x79
05D26:  MOVLB  0
05D28:  CALL   4752
....................                     motor_run_flip(0, 19); 
05D2C:  MOVLB  5
05D2E:  CLRF   x80
05D30:  CLRF   x7F
05D32:  CLRF   x7E
05D34:  CLRF   x7D
05D36:  MOVLW  13
05D38:  MOVWF  x81
05D3A:  MOVLB  0
05D3C:  RCALL  5790
....................                     while ((run_flg_flip)); 
05D3E:  BTFSC  2D.3
05D40:  BRA    5D3E
....................                     motor_run_x(4285, 19); 
05D42:  MOVLB  5
05D44:  CLRF   x80
05D46:  CLRF   x7F
05D48:  MOVLW  10
05D4A:  MOVWF  x7E
05D4C:  MOVLW  BD
05D4E:  MOVWF  x7D
05D50:  MOVLW  13
05D52:  MOVWF  x81
05D54:  MOVLB  0
05D56:  RCALL  5968
....................                     while ((run_flg_x)); 
05D58:  MOVLB  2
05D5A:  BTFSC  x0C.5
05D5C:  BRA    5D5A
....................                     motor_run_y(0, 19); 
05D5E:  MOVLB  5
05D60:  CLRF   x80
05D62:  CLRF   x7F
05D64:  CLRF   x7E
05D66:  CLRF   x7D
05D68:  MOVLW  13
05D6A:  MOVWF  x81
05D6C:  MOVLB  0
05D6E:  RCALL  55A6
....................                     while ((run_flg_y)); 
05D70:  MOVLB  2
05D72:  BTFSC  x0C.7
05D74:  BRA    5D72
05D76:  MOVLB  0
....................                 } 
....................                 if (posicao_atual == HOME1){ 
05D78:  DECFSZ 26,W
05D7A:  BRA    5DF0
....................                     envia_posicao_para_outra_maquina(ALIMENTADOR); 
05D7C:  MOVLB  5
05D7E:  CLRF   x79
05D80:  MOVLB  0
05D82:  CALL   4752
....................                     tela_movimentando_maquina(ALIMENTADOR); 
05D86:  MOVLB  5
05D88:  CLRF   x79
05D8A:  MOVLB  0
05D8C:  CALL   47E8
....................                     motor_run_x(4285, 19); 
05D90:  MOVLB  5
05D92:  CLRF   x80
05D94:  CLRF   x7F
05D96:  MOVLW  10
05D98:  MOVWF  x7E
05D9A:  MOVLW  BD
05D9C:  MOVWF  x7D
05D9E:  MOVLW  13
05DA0:  MOVWF  x81
05DA2:  MOVLB  0
05DA4:  RCALL  5968
....................                     while ((run_flg_x)); 
05DA6:  MOVLB  2
05DA8:  BTFSC  x0C.5
05DAA:  BRA    5DA8
....................                     if (primeiraVez == 1){ 
05DAC:  DECFSZ 2E,W
05DAE:  BRA    5DB8
....................                         flip_home(); 
05DB0:  MOVLB  0
05DB2:  BRA    5BAC
....................                     } else{ 
05DB4:  BRA    5DCE
05DB6:  MOVLB  2
....................                         motor_run_flip(0, 19); 
05DB8:  MOVLB  5
05DBA:  CLRF   x80
05DBC:  CLRF   x7F
05DBE:  CLRF   x7E
05DC0:  CLRF   x7D
05DC2:  MOVLW  13
05DC4:  MOVWF  x81
05DC6:  MOVLB  0
05DC8:  RCALL  5790
....................                         while ((run_flg_flip)); 
05DCA:  BTFSC  2D.3
05DCC:  BRA    5DCA
....................                     } 
....................                     motor_run_y(0, 19); 
05DCE:  MOVLB  5
05DD0:  CLRF   x80
05DD2:  CLRF   x7F
05DD4:  CLRF   x7E
05DD6:  CLRF   x7D
05DD8:  MOVLW  13
05DDA:  MOVWF  x81
05DDC:  MOVLB  0
05DDE:  CALL   55A6
....................                     while ((run_flg_y));                 
05DE2:  MOVLB  2
05DE4:  BTFSC  x0C.7
05DE6:  BRA    5DE4
....................                     posicao_atual = ALIMENTADOR; 
05DE8:  CLRF   26
....................                     primeiraVez = 2;                    
05DEA:  MOVLW  02
05DEC:  MOVWF  2E
05DEE:  MOVLB  0
....................                 } 
....................                 posicao_atual = ALIMENTADOR; 
05DF0:  CLRF   26
....................             } 
....................         break; 
05DF2:  MOVLB  5
05DF4:  BRA    6202
....................         case HOME1: 
....................             if (posicao_atual != HOME1){             
05DF6:  DECFSZ 26,W
05DF8:  BRA    5DFC
05DFA:  BRA    5F48
....................                 while (posicao_atual == DISPENSADOR){ 
05DFC:  MOVF   26,W
05DFE:  SUBLW  05
05E00:  BNZ   5E08
....................                     tela_esperando_mov_maquina();                 
05E02:  CALL   5536
05E06:  BRA    5DFC
....................                 } 
....................                 if (posicao_atual == SOLDAGEM){                     
05E08:  MOVF   26,W
05E0A:  SUBLW  03
05E0C:  BNZ   5E60
....................                     tela_movimentando_maquina(HOME1); 
05E0E:  MOVLW  01
05E10:  MOVLB  5
05E12:  MOVWF  x79
05E14:  MOVLB  0
05E16:  CALL   47E8
....................                     motor_run_x(500, 19); 
05E1A:  MOVLB  5
05E1C:  CLRF   x80
05E1E:  CLRF   x7F
05E20:  MOVLW  01
05E22:  MOVWF  x7E
05E24:  MOVLW  F4
05E26:  MOVWF  x7D
05E28:  MOVLW  13
05E2A:  MOVWF  x81
05E2C:  MOVLB  0
05E2E:  RCALL  5968
....................                     while ((run_flg_x)); 
05E30:  MOVLB  2
05E32:  BTFSC  x0C.5
05E34:  BRA    5E32
....................                     motor_run_y(650, 19); 
05E36:  MOVLB  5
05E38:  CLRF   x80
05E3A:  CLRF   x7F
05E3C:  MOVLW  02
05E3E:  MOVWF  x7E
05E40:  MOVLW  8A
05E42:  MOVWF  x7D
05E44:  MOVLW  13
05E46:  MOVWF  x81
05E48:  MOVLB  0
05E4A:  CALL   55A6
....................                     while ((run_flg_y));                                       
05E4E:  MOVLB  2
05E50:  BTFSC  x0C.7
05E52:  BRA    5E50
....................                     envia_posicao_para_outra_maquina(HOME1);                    
05E54:  MOVLW  01
05E56:  MOVLB  5
05E58:  MOVWF  x79
05E5A:  MOVLB  0
05E5C:  CALL   4752
....................                 } 
....................                 if (posicao_atual == HOME2){ 
05E60:  MOVF   26,W
05E62:  SUBLW  04
05E64:  BNZ   5ED4
....................                     tela_movimentando_maquina(HOME1); 
05E66:  MOVLW  01
05E68:  MOVLB  5
05E6A:  MOVWF  x79
05E6C:  MOVLB  0
05E6E:  CALL   47E8
....................                     motor_run_x(500, 19); 
05E72:  MOVLB  5
05E74:  CLRF   x80
05E76:  CLRF   x7F
05E78:  MOVLW  01
05E7A:  MOVWF  x7E
05E7C:  MOVLW  F4
05E7E:  MOVWF  x7D
05E80:  MOVLW  13
05E82:  MOVWF  x81
05E84:  MOVLB  0
05E86:  RCALL  5968
....................                     while ((run_flg_x)); 
05E88:  MOVLB  2
05E8A:  BTFSC  x0C.5
05E8C:  BRA    5E8A
....................                     motor_run_y(650, 19); 
05E8E:  MOVLB  5
05E90:  CLRF   x80
05E92:  CLRF   x7F
05E94:  MOVLW  02
05E96:  MOVWF  x7E
05E98:  MOVLW  8A
05E9A:  MOVWF  x7D
05E9C:  MOVLW  13
05E9E:  MOVWF  x81
05EA0:  MOVLB  0
05EA2:  CALL   55A6
....................                     while ((run_flg_y)); 
05EA6:  MOVLB  2
05EA8:  BTFSC  x0C.7
05EAA:  BRA    5EA8
....................                     motor_run_x(500, 19); 
05EAC:  MOVLB  5
05EAE:  CLRF   x80
05EB0:  CLRF   x7F
05EB2:  MOVLW  01
05EB4:  MOVWF  x7E
05EB6:  MOVLW  F4
05EB8:  MOVWF  x7D
05EBA:  MOVLW  13
05EBC:  MOVWF  x81
05EBE:  MOVLB  0
05EC0:  RCALL  5968
....................                     while ((run_flg_x)); 
05EC2:  MOVLB  2
05EC4:  BTFSC  x0C.5
05EC6:  BRA    5EC4
....................                     envia_posicao_para_outra_maquina(HOME1);                    
05EC8:  MOVLW  01
05ECA:  MOVLB  5
05ECC:  MOVWF  x79
05ECE:  MOVLB  0
05ED0:  CALL   4752
....................                 } 
....................                 if (posicao_atual == ALIMENTADOR){ 
05ED4:  MOVF   26,F
05ED6:  BNZ   5F44
....................                     tela_movimentando_maquina(HOME1); 
05ED8:  MOVLW  01
05EDA:  MOVLB  5
05EDC:  MOVWF  x79
05EDE:  MOVLB  0
05EE0:  CALL   47E8
....................                     motor_run_y(800, 19); 
05EE4:  MOVLB  5
05EE6:  CLRF   x80
05EE8:  CLRF   x7F
05EEA:  MOVLW  03
05EEC:  MOVWF  x7E
05EEE:  MOVLW  20
05EF0:  MOVWF  x7D
05EF2:  MOVLW  13
05EF4:  MOVWF  x81
05EF6:  MOVLB  0
05EF8:  CALL   55A6
....................                     while ((run_flg_y)); 
05EFC:  MOVLB  2
05EFE:  BTFSC  x0C.7
05F00:  BRA    5EFE
....................                     motor_run_flip(1868, 19); 
05F02:  MOVLB  5
05F04:  CLRF   x80
05F06:  CLRF   x7F
05F08:  MOVLW  07
05F0A:  MOVWF  x7E
05F0C:  MOVLW  4C
05F0E:  MOVWF  x7D
05F10:  MOVLW  13
05F12:  MOVWF  x81
05F14:  MOVLB  0
05F16:  RCALL  5790
....................                     while ((run_flg_flip)); 
05F18:  BTFSC  2D.3
05F1A:  BRA    5F18
....................                     motor_run_x(500, 19); 
05F1C:  MOVLB  5
05F1E:  CLRF   x80
05F20:  CLRF   x7F
05F22:  MOVLW  01
05F24:  MOVWF  x7E
05F26:  MOVLW  F4
05F28:  MOVWF  x7D
05F2A:  MOVLW  13
05F2C:  MOVWF  x81
05F2E:  MOVLB  0
05F30:  RCALL  5968
....................                     while ((run_flg_x)); 
05F32:  MOVLB  2
05F34:  BTFSC  x0C.5
05F36:  BRA    5F34
....................                     envia_posicao_para_outra_maquina(HOME1);                    
05F38:  MOVLW  01
05F3A:  MOVLB  5
05F3C:  MOVWF  x79
05F3E:  MOVLB  0
05F40:  CALL   4752
....................                 } 
....................                 posicao_atual = HOME1; 
05F44:  MOVLW  01
05F46:  MOVWF  26
....................             } 
....................         break; 
05F48:  MOVLB  5
05F4A:  BRA    6202
....................         case SOLDAGEM: 
....................             if (posicao_atual != SOLDAGEM){ 
05F4C:  MOVF   26,W
05F4E:  SUBLW  03
05F50:  BTFSC  FD8.2
05F52:  BRA    6052
....................                 while ((posicao_atual == DISPENSADOR)||(posicao_atual == HOME2)){ 
05F54:  MOVF   26,W
05F56:  SUBLW  05
05F58:  BZ    5F60
05F5A:  MOVF   26,W
05F5C:  SUBLW  04
05F5E:  BNZ   5F66
....................                     tela_esperando_mov_maquina();                 
05F60:  CALL   5536
05F64:  BRA    5F54
....................                 } 
....................                 if (posicao_atual == HOME1){ 
05F66:  DECFSZ 26,W
05F68:  BRA    5FBC
....................                     tela_movimentando_maquina(SOLDAGEM); 
05F6A:  MOVLW  03
05F6C:  MOVLB  5
05F6E:  MOVWF  x79
05F70:  MOVLB  0
05F72:  CALL   47E8
....................                     motor_run_x(500, 19); 
05F76:  MOVLB  5
05F78:  CLRF   x80
05F7A:  CLRF   x7F
05F7C:  MOVLW  01
05F7E:  MOVWF  x7E
05F80:  MOVLW  F4
05F82:  MOVWF  x7D
05F84:  MOVLW  13
05F86:  MOVWF  x81
05F88:  MOVLB  0
05F8A:  RCALL  5968
....................                     while ((run_flg_x)); 
05F8C:  MOVLB  2
05F8E:  BTFSC  x0C.5
05F90:  BRA    5F8E
....................                     motor_run_y(2450, 19); 
05F92:  MOVLB  5
05F94:  CLRF   x80
05F96:  CLRF   x7F
05F98:  MOVLW  09
05F9A:  MOVWF  x7E
05F9C:  MOVLW  92
05F9E:  MOVWF  x7D
05FA0:  MOVLW  13
05FA2:  MOVWF  x81
05FA4:  MOVLB  0
05FA6:  CALL   55A6
....................                     while ((run_flg_y)); 
05FAA:  MOVLB  2
05FAC:  BTFSC  x0C.7
05FAE:  BRA    5FAC
....................                     envia_posicao_para_outra_maquina(SOLDAGEM);                    
05FB0:  MOVLW  03
05FB2:  MOVLB  5
05FB4:  MOVWF  x79
05FB6:  MOVLB  0
05FB8:  CALL   4752
....................                 } 
....................                 if (posicao_atual == ALIMENTADOR){ 
05FBC:  MOVF   26,F
05FBE:  BNZ   604E
....................                     tela_movimentando_maquina(SOLDAGEM); 
05FC0:  MOVLW  03
05FC2:  MOVLB  5
05FC4:  MOVWF  x79
05FC6:  MOVLB  0
05FC8:  CALL   47E8
....................                     motor_run_y(800, 19); 
05FCC:  MOVLB  5
05FCE:  CLRF   x80
05FD0:  CLRF   x7F
05FD2:  MOVLW  03
05FD4:  MOVWF  x7E
05FD6:  MOVLW  20
05FD8:  MOVWF  x7D
05FDA:  MOVLW  13
05FDC:  MOVWF  x81
05FDE:  MOVLB  0
05FE0:  CALL   55A6
....................                     while ((run_flg_y)); 
05FE4:  MOVLB  2
05FE6:  BTFSC  x0C.7
05FE8:  BRA    5FE6
....................                     motor_run_flip(1868, 19); 
05FEA:  MOVLB  5
05FEC:  CLRF   x80
05FEE:  CLRF   x7F
05FF0:  MOVLW  07
05FF2:  MOVWF  x7E
05FF4:  MOVLW  4C
05FF6:  MOVWF  x7D
05FF8:  MOVLW  13
05FFA:  MOVWF  x81
05FFC:  MOVLB  0
05FFE:  CALL   5790
....................                     while ((run_flg_flip)); 
06002:  BTFSC  2D.3
06004:  BRA    6002
....................                     motor_run_x(500, 19); 
06006:  MOVLB  5
06008:  CLRF   x80
0600A:  CLRF   x7F
0600C:  MOVLW  01
0600E:  MOVWF  x7E
06010:  MOVLW  F4
06012:  MOVWF  x7D
06014:  MOVLW  13
06016:  MOVWF  x81
06018:  MOVLB  0
0601A:  RCALL  5968
....................                     while ((run_flg_x)); 
0601C:  MOVLB  2
0601E:  BTFSC  x0C.5
06020:  BRA    601E
....................                     envia_posicao_para_outra_maquina(SOLDAGEM); 
06022:  MOVLW  03
06024:  MOVLB  5
06026:  MOVWF  x79
06028:  MOVLB  0
0602A:  CALL   4752
....................                     motor_run_y(2450, 19); 
0602E:  MOVLB  5
06030:  CLRF   x80
06032:  CLRF   x7F
06034:  MOVLW  09
06036:  MOVWF  x7E
06038:  MOVLW  92
0603A:  MOVWF  x7D
0603C:  MOVLW  13
0603E:  MOVWF  x81
06040:  MOVLB  0
06042:  CALL   55A6
....................                     while ((run_flg_y));                    
06046:  MOVLB  2
06048:  BTFSC  x0C.7
0604A:  BRA    6048
0604C:  MOVLB  0
....................                 } 
....................                 posicao_atual = SOLDAGEM; 
0604E:  MOVLW  03
06050:  MOVWF  26
....................             } 
....................         break; 
06052:  MOVLB  5
06054:  BRA    6202
....................         case HOME2: 
....................             if (posicao_atual != HOME2){ 
06056:  MOVF   26,W
06058:  SUBLW  04
0605A:  BTFSC  FD8.2
0605C:  BRA    6170
....................                 while ((posicao_atual == ALIMENTADOR)){ 
0605E:  MOVF   26,F
06060:  BNZ   6068
....................                     tela_esperando_mov_maquina();                 
06062:  CALL   5536
06066:  BRA    605E
....................                 } 
....................                 if (posicao_atual == DISPENSADOR){                   
06068:  MOVF   26,W
0606A:  SUBLW  05
0606C:  BNZ   60BE
....................                     tela_movimentando_maquina(HOME2); 
0606E:  MOVLW  04
06070:  MOVLB  5
06072:  MOVWF  x79
06074:  MOVLB  0
06076:  CALL   47E8
....................                     motor_run_y(5540, 19); 
0607A:  MOVLB  5
0607C:  CLRF   x80
0607E:  CLRF   x7F
06080:  MOVLW  15
06082:  MOVWF  x7E
06084:  MOVLW  A4
06086:  MOVWF  x7D
06088:  MOVLW  13
0608A:  MOVWF  x81
0608C:  MOVLB  0
0608E:  CALL   55A6
....................                     while ((run_flg_y)); 
06092:  MOVLB  2
06094:  BTFSC  x0C.7
06096:  BRA    6094
....................                     motor_run_x(150, 19); 
06098:  MOVLB  5
0609A:  CLRF   x80
0609C:  CLRF   x7F
0609E:  CLRF   x7E
060A0:  MOVLW  96
060A2:  MOVWF  x7D
060A4:  MOVLW  13
060A6:  MOVWF  x81
060A8:  MOVLB  0
060AA:  RCALL  5968
....................                     while ((run_flg_x)); 
060AC:  MOVLB  2
060AE:  BTFSC  x0C.5
060B0:  BRA    60AE
....................                     envia_posicao_para_outra_maquina(HOME2);                    
060B2:  MOVLW  04
060B4:  MOVLB  5
060B6:  MOVWF  x79
060B8:  MOVLB  0
060BA:  CALL   4752
....................                 } 
....................                 if (posicao_atual == SOLDAGEM){                     
060BE:  MOVF   26,W
060C0:  SUBLW  03
060C2:  BNZ   6116
....................                     tela_movimentando_maquina(HOME2); 
060C4:  MOVLW  04
060C6:  MOVLB  5
060C8:  MOVWF  x79
060CA:  MOVLB  0
060CC:  CALL   47E8
....................                     motor_run_y(5540, 19); 
060D0:  MOVLB  5
060D2:  CLRF   x80
060D4:  CLRF   x7F
060D6:  MOVLW  15
060D8:  MOVWF  x7E
060DA:  MOVLW  A4
060DC:  MOVWF  x7D
060DE:  MOVLW  13
060E0:  MOVWF  x81
060E2:  MOVLB  0
060E4:  CALL   55A6
....................                     while ((run_flg_y)); 
060E8:  MOVLB  2
060EA:  BTFSC  x0C.7
060EC:  BRA    60EA
....................                     motor_run_x(500, 19); 
060EE:  MOVLB  5
060F0:  CLRF   x80
060F2:  CLRF   x7F
060F4:  MOVLW  01
060F6:  MOVWF  x7E
060F8:  MOVLW  F4
060FA:  MOVWF  x7D
060FC:  MOVLW  13
060FE:  MOVWF  x81
06100:  MOVLB  0
06102:  RCALL  5968
....................                     while ((run_flg_x)); 
06104:  MOVLB  2
06106:  BTFSC  x0C.5
06108:  BRA    6106
....................                     envia_posicao_para_outra_maquina(HOME2);                    
0610A:  MOVLW  04
0610C:  MOVLB  5
0610E:  MOVWF  x79
06110:  MOVLB  0
06112:  CALL   4752
....................                 } 
....................                 if (posicao_atual == HOME1){ 
06116:  DECFSZ 26,W
06118:  BRA    616C
....................                     tela_movimentando_maquina(HOME2); 
0611A:  MOVLW  04
0611C:  MOVLB  5
0611E:  MOVWF  x79
06120:  MOVLB  0
06122:  CALL   47E8
....................                     motor_run_x(500, 19); 
06126:  MOVLB  5
06128:  CLRF   x80
0612A:  CLRF   x7F
0612C:  MOVLW  01
0612E:  MOVWF  x7E
06130:  MOVLW  F4
06132:  MOVWF  x7D
06134:  MOVLW  13
06136:  MOVWF  x81
06138:  MOVLB  0
0613A:  RCALL  5968
....................                     while ((run_flg_x)); 
0613C:  MOVLB  2
0613E:  BTFSC  x0C.5
06140:  BRA    613E
....................                     motor_run_y(5540, 19); 
06142:  MOVLB  5
06144:  CLRF   x80
06146:  CLRF   x7F
06148:  MOVLW  15
0614A:  MOVWF  x7E
0614C:  MOVLW  A4
0614E:  MOVWF  x7D
06150:  MOVLW  13
06152:  MOVWF  x81
06154:  MOVLB  0
06156:  CALL   55A6
....................                     while ((run_flg_y));                     
0615A:  MOVLB  2
0615C:  BTFSC  x0C.7
0615E:  BRA    615C
....................                     envia_posicao_para_outra_maquina(HOME2);                    
06160:  MOVLW  04
06162:  MOVLB  5
06164:  MOVWF  x79
06166:  MOVLB  0
06168:  CALL   4752
....................                 } 
....................                 posicao_atual = HOME2; 
0616C:  MOVLW  04
0616E:  MOVWF  26
....................             } 
....................         break; 
06170:  MOVLB  5
06172:  BRA    6202
....................         case DISPENSADOR: 
....................             if (posicao_atual != DISPENSADOR){ 
06174:  MOVF   26,W
06176:  SUBLW  05
06178:  BZ    61FC
....................                 while (posicao_atual != HOME2){ 
0617A:  MOVF   26,W
0617C:  SUBLW  04
0617E:  BZ    6186
....................                     tela_esperando_mov_maquina();                 
06180:  CALL   5536
06184:  BRA    617A
....................                 } 
....................                 if (posicao_atual == HOME2){ 
06186:  MOVF   26,W
06188:  SUBLW  04
0618A:  BNZ   61F8
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
0618C:  CALL   526A
06190:  MOVFF  01,28
....................                     while ((posicao_outra_maquina == DISPENSADOR)||(posicao_outra_maquina == HOME2)){ 
06194:  MOVF   28,W
06196:  SUBLW  05
06198:  BZ    61A0
0619A:  MOVF   28,W
0619C:  SUBLW  04
0619E:  BNZ   61AE
....................                         tela_esperando_sair_posicao_outra_maquina(); 
061A0:  CALL   5568
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
061A4:  CALL   526A
061A8:  MOVFF  01,28
061AC:  BRA    6194
....................                     } 
....................                     tela_movimentando_maquina(DISPENSADOR); 
061AE:  MOVLW  05
061B0:  MOVLB  5
061B2:  MOVWF  x79
061B4:  MOVLB  0
061B6:  CALL   47E8
....................                     motor_run_x(4270, 19); 
061BA:  MOVLB  5
061BC:  CLRF   x80
061BE:  CLRF   x7F
061C0:  MOVLW  10
061C2:  MOVWF  x7E
061C4:  MOVLW  AE
061C6:  MOVWF  x7D
061C8:  MOVLW  13
061CA:  MOVWF  x81
061CC:  MOVLB  0
061CE:  CALL   5968
....................                     while ((run_flg_x)); 
061D2:  MOVLB  2
061D4:  BTFSC  x0C.5
061D6:  BRA    61D4
....................                     motor_run_y(6340, 19); 
061D8:  MOVLB  5
061DA:  CLRF   x80
061DC:  CLRF   x7F
061DE:  MOVLW  18
061E0:  MOVWF  x7E
061E2:  MOVLW  C4
061E4:  MOVWF  x7D
061E6:  MOVLW  13
061E8:  MOVWF  x81
061EA:  MOVLB  0
061EC:  CALL   55A6
....................                     while ((run_flg_y));                                        
061F0:  MOVLB  2
061F2:  BTFSC  x0C.7
061F4:  BRA    61F2
061F6:  MOVLB  0
....................                 } 
....................                 posicao_atual = DISPENSADOR; 
061F8:  MOVLW  05
061FA:  MOVWF  26
....................             } 
....................         break;        
061FC:  MOVLB  5
061FE:  BRA    6202
06200:  MOVLB  5
....................     } 
06202:  MOVLB  0
06204:  RETURN 0
.................... } 
.................... void posicao_maquina_2_default(void) { 
....................     envia_posicao_para_outra_maquina(ALIMENTADOR); 
*
06236:  MOVLB  5
06238:  CLRF   x79
0623A:  MOVLB  0
0623C:  CALL   4752
....................     tela_movimentando_maquina(HOME1); 
06240:  MOVLW  01
06242:  MOVLB  5
06244:  MOVWF  x79
06246:  MOVLB  0
06248:  CALL   47E8
....................     z_home(); 
0624C:  CALL   4C8E
....................     frente(); 
06250:  CALL   4D82
....................     delay_ms(50); 
06254:  MOVLW  32
06256:  MOVLB  5
06258:  MOVWF  x92
0625A:  MOVLB  0
0625C:  CALL   2958
....................     if (le_Input(S_Y_ATRAS) == true) { 
06260:  MOVLW  08
06262:  MOVLB  5
06264:  MOVWF  x7A
06266:  MOVLB  0
06268:  CALL   49FA
0626C:  DECFSZ 01,W
0626E:  BRA    627E
....................         y_home_atras(); 
06270:  CALL   4DDE
....................         x_home_direita(); 
06274:  CALL   4F4C
....................         y_home_frente(); 
06278:  CALL   505E
....................     } else { 
0627C:  BRA    62A0
....................         if (le_Input(S_Y_FRENTE) == true) { 
0627E:  MOVLW  07
06280:  MOVLB  5
06282:  MOVWF  x7A
06284:  MOVLB  0
06286:  CALL   49FA
0628A:  DECFSZ 01,W
0628C:  BRA    6298
....................             y_home_frente(); 
0628E:  CALL   505E
....................             x_home_direita(); 
06292:  CALL   4F4C
....................         } else { 
06296:  BRA    62A0
....................             x_home_direita(); 
06298:  CALL   4F4C
....................             y_home_frente(); 
0629C:  CALL   505E
....................         } 
....................     } 
....................     motor_pos_x = 0; 
062A0:  MOVLB  2
062A2:  CLRF   x05
062A4:  CLRF   x04
....................     motor_pos_y = 650; 
062A6:  MOVLW  02
062A8:  MOVWF  x07
062AA:  MOVLW  8A
062AC:  MOVWF  x06
....................     motor_pos_z = 0; 
062AE:  CLRF   x0B
062B0:  CLRF   x0A
....................     posicao_atual = HOME1; 
062B2:  MOVLW  01
062B4:  MOVWF  26
....................     posicao_outra_maquina = le_posicao_outra_maquina(); 
062B6:  MOVLB  0
062B8:  CALL   526A
062BC:  MOVFF  01,28
....................     while ((posicao_outra_maquina != HOME1)){ 
062C0:  DECFSZ 28,W
062C2:  BRA    62C6
062C4:  BRA    62D0
....................         posicao_outra_maquina = le_posicao_outra_maquina(); 
062C6:  CALL   526A
062CA:  MOVFF  01,28
062CE:  BRA    62C0
....................     } 
....................     envia_maquina_para_posicao(ALIMENTADOR); 
062D0:  MOVLB  5
062D2:  CLRF   x78
062D4:  MOVLB  0
062D6:  RCALL  5C9C
....................     envia_maquina_para_posicao(HOME1); 
062D8:  MOVLW  01
062DA:  MOVLB  5
062DC:  MOVWF  x78
062DE:  MOVLB  0
062E0:  RCALL  5C9C
....................     posicao_outra_maquina = le_posicao_outra_maquina(); 
062E2:  CALL   526A
062E6:  MOVFF  01,28
....................     while ((posicao_outra_maquina != ALIMENTADOR)){ 
062EA:  MOVF   28,F
062EC:  BZ    62F8
....................         posicao_outra_maquina = le_posicao_outra_maquina(); 
062EE:  CALL   526A
062F2:  MOVFF  01,28
062F6:  BRA    62EA
....................     } 
062F8:  GOTO   D7E6 (RETURN)
.................... }  
.................... void posicao_volta_manutencao(void) { 
....................     tela_movimentando_maquina(HOME1); 
*
0BBAC:  MOVLW  01
0BBAE:  MOVLB  5
0BBB0:  MOVWF  x79
0BBB2:  MOVLB  0
0BBB4:  CALL   47E8
....................     z_home(); 
0BBB8:  CALL   4C8E
....................     frente(); 
0BBBC:  CALL   4D82
....................     delay_ms(50); 
0BBC0:  MOVLW  32
0BBC2:  MOVLB  5
0BBC4:  MOVWF  x92
0BBC6:  MOVLB  0
0BBC8:  CALL   2958
....................     if (le_Input(S_Y_ATRAS) == true) { 
0BBCC:  MOVLW  08
0BBCE:  MOVLB  5
0BBD0:  MOVWF  x7A
0BBD2:  MOVLB  0
0BBD4:  CALL   49FA
0BBD8:  DECFSZ 01,W
0BBDA:  BRA    BBEA
....................         y_home_atras(); 
0BBDC:  CALL   4DDE
....................         x_home_direita(); 
0BBE0:  CALL   4F4C
....................         y_home_frente(); 
0BBE4:  CALL   505E
....................     } else { 
0BBE8:  BRA    BC0C
....................         if (le_Input(S_Y_FRENTE) == true) { 
0BBEA:  MOVLW  07
0BBEC:  MOVLB  5
0BBEE:  MOVWF  x7A
0BBF0:  MOVLB  0
0BBF2:  CALL   49FA
0BBF6:  DECFSZ 01,W
0BBF8:  BRA    BC04
....................             y_home_frente(); 
0BBFA:  CALL   505E
....................             x_home_direita(); 
0BBFE:  CALL   4F4C
....................         } else { 
0BC02:  BRA    BC0C
....................             x_home_direita(); 
0BC04:  CALL   4F4C
....................             y_home_frente(); 
0BC08:  CALL   505E
....................         } 
....................     } 
....................     motor_pos_x = 0; 
0BC0C:  MOVLB  2
0BC0E:  CLRF   x05
0BC10:  CLRF   x04
....................     motor_pos_y = 650; 
0BC12:  MOVLW  02
0BC14:  MOVWF  x07
0BC16:  MOVLW  8A
0BC18:  MOVWF  x06
....................     motor_pos_z = 0; 
0BC1A:  CLRF   x0B
0BC1C:  CLRF   x0A
....................     posicao_atual = HOME1; 
0BC1E:  MOVLW  01
0BC20:  MOVWF  26
....................     envia_posicao_para_outra_maquina(HOME1); 
0BC22:  MOVLB  5
0BC24:  MOVWF  x79
0BC26:  MOVLB  0
0BC28:  CALL   4752
0BC2C:  RETURN 0
.................... }  
....................  
.................... #include "maquinas_maq_2.c" 
.................... void liga_pressor (void){ 
....................     aciona_saida(PRESSOR); 
*
0788C:  MOVLB  5
0788E:  CLRF   x90
07890:  MOVLW  04
07892:  MOVWF  x8F
07894:  MOVLB  0
07896:  CALL   2E1E
0789A:  RETURN 0
.................... } 
.................... void desliga_pressor (void){ 
....................     desaciona_saida(PRESSOR); 
*
075AC:  MOVLB  5
075AE:  CLRF   x90
075B0:  MOVLW  04
075B2:  MOVWF  x8F
075B4:  MOVLB  0
075B6:  CALL   2DDC
075BA:  RETURN 0
.................... } 
.................... void empurra_placa(void){ 
....................     short int b; 
....................     short int c; 
....................     b = le_Input(S_BANDEJA); 
*
0B142:  MOVLW  15
0B144:  MOVLB  5
0B146:  MOVWF  x7A
0B148:  MOVLB  0
0B14A:  CALL   49FA
0B14E:  MOVLB  5
0B150:  BCF    x78.0
0B152:  BTFSC  01.0
0B154:  BSF    x78.0
....................     while (b == 0){ 
0B156:  BTFSC  x78.0
0B158:  BRA    B18A
....................         b = le_Input(S_BANDEJA); 
0B15A:  MOVLW  15
0B15C:  MOVWF  x7A
0B15E:  MOVLB  0
0B160:  CALL   49FA
0B164:  MOVLB  5
0B166:  BCF    x78.0
0B168:  BTFSC  01.0
0B16A:  BSF    x78.0
....................         aciona_saida(DEDO_ENTRADA); 
0B16C:  CLRF   x90
0B16E:  MOVLW  07
0B170:  MOVWF  x8F
0B172:  MOVLB  0
0B174:  CALL   2E1E
....................         aciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
0B178:  MOVLB  5
0B17A:  CLRF   x90
0B17C:  MOVLW  06
0B17E:  MOVWF  x8F
0B180:  MOVLB  0
0B182:  CALL   2E1E
0B186:  MOVLB  5
0B188:  BRA    B156
....................     } 
....................     desaciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
0B18A:  CLRF   x90
0B18C:  MOVLW  06
0B18E:  MOVWF  x8F
0B190:  MOVLB  0
0B192:  CALL   2DDC
....................     c = le_Input(S_EMPURRADOR_IN_LS2); 
0B196:  MOVLW  03
0B198:  MOVLB  5
0B19A:  MOVWF  x7A
0B19C:  MOVLB  0
0B19E:  CALL   49FA
0B1A2:  MOVLB  5
0B1A4:  BCF    x78.1
0B1A6:  BTFSC  01.0
0B1A8:  BSF    x78.1
....................     while (c == 0){ 
0B1AA:  BTFSC  x78.1
0B1AC:  BRA    B1D0
....................         c = le_Input(S_EMPURRADOR_IN_LS2);        
0B1AE:  MOVLW  03
0B1B0:  MOVWF  x7A
0B1B2:  MOVLB  0
0B1B4:  CALL   49FA
0B1B8:  MOVLB  5
0B1BA:  BCF    x78.1
0B1BC:  BTFSC  01.0
0B1BE:  BSF    x78.1
....................         aciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
0B1C0:  CLRF   x90
0B1C2:  MOVLW  05
0B1C4:  MOVWF  x8F
0B1C6:  MOVLB  0
0B1C8:  CALL   2E1E
0B1CC:  MOVLB  5
0B1CE:  BRA    B1AA
....................     } 
....................     desaciona_saida(DEDO_ENTRADA); 
0B1D0:  CLRF   x90
0B1D2:  MOVLW  07
0B1D4:  MOVWF  x8F
0B1D6:  MOVLB  0
0B1D8:  CALL   2DDC
....................     desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
0B1DC:  MOVLB  5
0B1DE:  CLRF   x90
0B1E0:  MOVLW  05
0B1E2:  MOVWF  x8F
0B1E4:  MOVLB  0
0B1E6:  CALL   2DDC
0B1EA:  RETURN 0
.................... } 
.................... void dispensa_placa(void){ 
....................     short int b; 
....................     short int c; 
....................     b = le_Input(S_EMPURRADOR_OUT_LS1); 
*
0CE20:  MOVLW  12
0CE22:  MOVLB  5
0CE24:  MOVWF  x7A
0CE26:  MOVLB  0
0CE28:  CALL   49FA
0CE2C:  MOVLB  5
0CE2E:  BCF    x78.0
0CE30:  BTFSC  01.0
0CE32:  BSF    x78.0
....................     while (b == 0){         
0CE34:  BTFSC  x78.0
0CE36:  BRA    CE66
....................         aciona_saida(DEDO_SAIDA); 
0CE38:  CLRF   x90
0CE3A:  MOVLW  01
0CE3C:  MOVWF  x8F
0CE3E:  MOVLB  0
0CE40:  CALL   2E1E
....................         aciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
0CE44:  MOVLB  5
0CE46:  CLRF   x90
0CE48:  CLRF   x8F
0CE4A:  MOVLB  0
0CE4C:  CALL   2E1E
....................         b = le_Input(S_EMPURRADOR_OUT_LS1); 
0CE50:  MOVLW  12
0CE52:  MOVLB  5
0CE54:  MOVWF  x7A
0CE56:  MOVLB  0
0CE58:  CALL   49FA
0CE5C:  MOVLB  5
0CE5E:  BCF    x78.0
0CE60:  BTFSC  01.0
0CE62:  BSF    x78.0
0CE64:  BRA    CE34
....................     } 
....................     desaciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
0CE66:  CLRF   x90
0CE68:  CLRF   x8F
0CE6A:  MOVLB  0
0CE6C:  CALL   2DDC
....................     c = le_Input(S_EMPURRADOR_OUT_LS2); 
0CE70:  MOVLW  13
0CE72:  MOVLB  5
0CE74:  MOVWF  x7A
0CE76:  MOVLB  0
0CE78:  CALL   49FA
0CE7C:  MOVLB  5
0CE7E:  BCF    x78.1
0CE80:  BTFSC  01.0
0CE82:  BSF    x78.1
....................     while (c == 0){         
0CE84:  BTFSC  x78.1
0CE86:  BRA    CEAA
....................         c = le_Input(S_EMPURRADOR_OUT_LS2); 
0CE88:  MOVLW  13
0CE8A:  MOVWF  x7A
0CE8C:  MOVLB  0
0CE8E:  CALL   49FA
0CE92:  MOVLB  5
0CE94:  BCF    x78.1
0CE96:  BTFSC  01.0
0CE98:  BSF    x78.1
....................         aciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
0CE9A:  CLRF   x90
0CE9C:  MOVLW  0F
0CE9E:  MOVWF  x8F
0CEA0:  MOVLB  0
0CEA2:  CALL   2E1E
0CEA6:  MOVLB  5
0CEA8:  BRA    CE84
....................     } 
....................     desaciona_saida(DEDO_SAIDA); 
0CEAA:  CLRF   x90
0CEAC:  MOVLW  01
0CEAE:  MOVWF  x8F
0CEB0:  MOVLB  0
0CEB2:  CALL   2DDC
....................     desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
0CEB6:  MOVLB  5
0CEB8:  CLRF   x90
0CEBA:  MOVLW  0F
0CEBC:  MOVWF  x8F
0CEBE:  MOVLB  0
0CEC0:  CALL   2DDC
0CEC4:  GOTO   D2E8 (RETURN)
.................... } 
.................... void desce_ferros(int quantidade){ 
....................     if (quantidade == 0){ 
*
0783A:  MOVLB  5
0783C:  MOVF   x7D,F
0783E:  BNZ   7840
....................     } 
....................     if (quantidade == 1){ 
07840:  DECFSZ x7D,W
07842:  BRA    7852
....................         aciona_saida(FERRO_SOLDA1); 
07844:  CLRF   x90
07846:  MOVLW  03
07848:  MOVWF  x8F
0784A:  MOVLB  0
0784C:  CALL   2E1E
07850:  MOVLB  5
....................     } 
....................     if (quantidade == 2){ 
07852:  MOVF   x7D,W
07854:  SUBLW  02
07856:  BNZ   7866
....................         aciona_saida(FERRO_SOLDA2); 
07858:  CLRF   x90
0785A:  MOVLW  02
0785C:  MOVWF  x8F
0785E:  MOVLB  0
07860:  CALL   2E1E
07864:  MOVLB  5
....................     } 
....................     if (quantidade == 3){ 
07866:  MOVF   x7D,W
07868:  SUBLW  03
0786A:  BNZ   7888
....................         aciona_saida(FERRO_SOLDA1); 
0786C:  CLRF   x90
0786E:  MOVLW  03
07870:  MOVWF  x8F
07872:  MOVLB  0
07874:  CALL   2E1E
....................         aciona_saida(FERRO_SOLDA2); 
07878:  MOVLB  5
0787A:  CLRF   x90
0787C:  MOVLW  02
0787E:  MOVWF  x8F
07880:  MOVLB  0
07882:  CALL   2E1E
07886:  MOVLB  5
....................     } 
07888:  MOVLB  0
0788A:  RETURN 0
.................... } 
.................... void sobe_ferros(void){ 
....................     desaciona_saida(FERRO_SOLDA1); 
*
0781C:  MOVLB  5
0781E:  CLRF   x90
07820:  MOVLW  03
07822:  MOVWF  x8F
07824:  MOVLB  0
07826:  CALL   2DDC
....................     desaciona_saida(FERRO_SOLDA2); 
0782A:  MOVLB  5
0782C:  CLRF   x90
0782E:  MOVLW  02
07830:  MOVWF  x8F
07832:  MOVLB  0
07834:  CALL   2DDC
07838:  RETURN 0
.................... } 
.................... void liga_esteira(void){ 
....................     aciona_saida(RELE_ESTEIRA); 
*
0B122:  MOVLB  5
0B124:  CLRF   x90
0B126:  MOVLW  0A
0B128:  MOVWF  x8F
0B12A:  MOVLB  0
0B12C:  CALL   2E1E
0B130:  RETURN 0
.................... } 
.................... void desliga_esteira(void){ 
....................     desaciona_saida(RELE_ESTEIRA); 
0B132:  MOVLB  5
0B134:  CLRF   x90
0B136:  MOVLW  0A
0B138:  MOVWF  x8F
0B13A:  MOVLB  0
0B13C:  CALL   2DDC
0B140:  RETURN 0
.................... } 
.................... void limpa_bicos(long int tempo){ 
....................     aciona_saida(LIMPA_BICO1); 
....................     aciona_saida(LIMPA_BICO2); 
....................     delay_ms(tempo); 
....................     desaciona_saida(LIMPA_BICO1); 
....................     desaciona_saida(LIMPA_BICO2);     
.................... } 
.................... void home_solenoides(void){ 
....................     desaciona_saida(DEDO_ENTRADA); 
*
02E6A:  MOVLB  5
02E6C:  CLRF   x90
02E6E:  MOVLW  07
02E70:  MOVWF  x8F
02E72:  MOVLB  0
02E74:  RCALL  2DDC
....................     desaciona_saida(DEDO_SAIDA); 
02E76:  MOVLB  5
02E78:  CLRF   x90
02E7A:  MOVLW  01
02E7C:  MOVWF  x8F
02E7E:  MOVLB  0
02E80:  RCALL  2DDC
....................     desaciona_saida(FERRO_SOLDA1); 
02E82:  MOVLB  5
02E84:  CLRF   x90
02E86:  MOVLW  03
02E88:  MOVWF  x8F
02E8A:  MOVLB  0
02E8C:  RCALL  2DDC
....................     desaciona_saida(FERRO_SOLDA2); 
02E8E:  MOVLB  5
02E90:  CLRF   x90
02E92:  MOVLW  02
02E94:  MOVWF  x8F
02E96:  MOVLB  0
02E98:  RCALL  2DDC
....................     desaciona_saida(PRESSOR); 
02E9A:  MOVLB  5
02E9C:  CLRF   x90
02E9E:  MOVLW  04
02EA0:  MOVWF  x8F
02EA2:  MOVLB  0
02EA4:  RCALL  2DDC
....................     desaciona_saida(LIMPA_BICO1); 
02EA6:  MOVLB  5
02EA8:  CLRF   x90
02EAA:  MOVLW  08
02EAC:  MOVWF  x8F
02EAE:  MOVLB  0
02EB0:  RCALL  2DDC
....................     desaciona_saida(LIMPA_BICO2); 
02EB2:  MOVLB  5
02EB4:  CLRF   x90
02EB6:  MOVLW  09
02EB8:  MOVWF  x8F
02EBA:  MOVLB  0
02EBC:  RCALL  2DDC
....................      
....................     aciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
02EBE:  MOVLB  5
02EC0:  CLRF   x90
02EC2:  MOVLW  05
02EC4:  MOVWF  x8F
02EC6:  MOVLB  0
02EC8:  RCALL  2E1E
....................     aciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
02ECA:  MOVLB  5
02ECC:  CLRF   x90
02ECE:  MOVLW  0F
02ED0:  MOVWF  x8F
02ED2:  MOVLB  0
02ED4:  RCALL  2E1E
....................     delay_ms(2500); 
02ED6:  MOVLW  0A
02ED8:  MOVLB  5
02EDA:  MOVWF  x75
02EDC:  MOVLW  FA
02EDE:  MOVWF  x92
02EE0:  MOVLB  0
02EE2:  RCALL  2958
02EE4:  MOVLB  5
02EE6:  DECFSZ x75,F
02EE8:  BRA    2EDC
....................     desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
02EEA:  CLRF   x90
02EEC:  MOVLW  05
02EEE:  MOVWF  x8F
02EF0:  MOVLB  0
02EF2:  RCALL  2DDC
....................     desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
02EF4:  MOVLB  5
02EF6:  CLRF   x90
02EF8:  MOVLW  0F
02EFA:  MOVWF  x8F
02EFC:  MOVLB  0
02EFE:  RCALL  2DDC
02F00:  RETURN 0
.................... } 
.................... int statusSolda(void){ 
....................     short int x; 
....................     short int y; 
....................     short int z;     
....................     x = le_Input(S_FIO_SOLDA1); 
*
0824E:  MOVLW  16
08250:  MOVLB  5
08252:  MOVWF  x7A
08254:  MOVLB  0
08256:  CALL   49FA
0825A:  MOVLB  5
0825C:  BCF    x78.0
0825E:  BTFSC  01.0
08260:  BSF    x78.0
....................     y = le_Input(S_FIO_SOLDA2); 
08262:  MOVLW  17
08264:  MOVWF  x7A
08266:  MOVLB  0
08268:  CALL   49FA
0826C:  MOVLB  5
0826E:  BCF    x78.1
08270:  BTFSC  01.0
08272:  BSF    x78.1
....................     z = le_Input(S_FIO_SOLDA3); 
08274:  MOVLW  18
08276:  MOVWF  x7A
08278:  MOVLB  0
0827A:  CALL   49FA
0827E:  MOVLB  5
08280:  BCF    x78.2
08282:  BTFSC  01.0
08284:  BSF    x78.2
....................     if ((x==1)&&(y==1)&&(z==1)){ 
08286:  BTFSS  x78.0
08288:  BRA    829A
0828A:  BTFSS  x78.1
0828C:  BRA    829A
0828E:  BTFSS  x78.2
08290:  BRA    829A
....................         return 1; 
08292:  MOVLW  01
08294:  MOVWF  01
08296:  BRA    829E
....................     } else { 
08298:  BRA    829E
....................         return 0; 
0829A:  MOVLW  00
0829C:  MOVWF  01
....................     } 
0829E:  MOVLB  0
082A0:  RETURN 0
.................... } 
.................... void ligar_alimentador_solda(int quantidade, long int tempo1, long int tempo2, long int tempo3){ 
....................     long int maior; 
....................     long int medio; 
....................     long int menor; 
....................     switch(quantidade){ 
082A2:  MOVLB  5
082A4:  MOVF   x82,W
082A6:  ADDLW  FC
082A8:  BTFSC  FD8.0
082AA:  GOTO   8C0C
082AE:  ADDLW  04
082B0:  MOVLB  0
082B2:  GOTO   8C10
....................         case 0: 
....................             aciona_saida(ALIMENTADOR2); 
082B6:  MOVLB  5
082B8:  CLRF   x90
082BA:  MOVLW  0D
082BC:  MOVWF  x8F
082BE:  MOVLB  0
082C0:  CALL   2E1E
....................             delay_ms(tempo2); 
082C4:  MOVFF  586,58F
082C8:  MOVLB  5
082CA:  INCF   x8F,F
082CC:  DECF   x8F,F
082CE:  BTFSC  FD8.2
082D0:  BRA    82DE
082D2:  SETF   x92
082D4:  MOVLB  0
082D6:  CALL   2958
082DA:  MOVLB  5
082DC:  BRA    82CC
082DE:  MOVFF  585,592
082E2:  MOVLB  0
082E4:  CALL   2958
....................             desaciona_saida(ALIMENTADOR2); 
082E8:  MOVLB  5
082EA:  CLRF   x90
082EC:  MOVLW  0D
082EE:  MOVWF  x8F
082F0:  MOVLB  0
082F2:  CALL   2DDC
....................         break; 
082F6:  MOVLB  5
082F8:  GOTO   8C0C
....................         case 1: 
....................             if (tempo1 == tempo2){ 
082FC:  MOVLB  5
082FE:  MOVF   x85,W
08300:  SUBWF  x83,W
08302:  BNZ   8368
08304:  MOVF   x86,W
08306:  SUBWF  x84,W
08308:  BNZ   8368
....................                 aciona_saida(ALIMENTADOR1); 
0830A:  CLRF   x90
0830C:  MOVLW  0E
0830E:  MOVWF  x8F
08310:  MOVLB  0
08312:  CALL   2E1E
....................                 aciona_saida(ALIMENTADOR2); 
08316:  MOVLB  5
08318:  CLRF   x90
0831A:  MOVLW  0D
0831C:  MOVWF  x8F
0831E:  MOVLB  0
08320:  CALL   2E1E
....................                 delay_ms(tempo1); 
08324:  MOVFF  584,58F
08328:  MOVLB  5
0832A:  INCF   x8F,F
0832C:  DECF   x8F,F
0832E:  BTFSC  FD8.2
08330:  BRA    833E
08332:  SETF   x92
08334:  MOVLB  0
08336:  CALL   2958
0833A:  MOVLB  5
0833C:  BRA    832C
0833E:  MOVFF  583,592
08342:  MOVLB  0
08344:  CALL   2958
....................                 desaciona_saida(ALIMENTADOR1); 
08348:  MOVLB  5
0834A:  CLRF   x90
0834C:  MOVLW  0E
0834E:  MOVWF  x8F
08350:  MOVLB  0
08352:  CALL   2DDC
....................                 desaciona_saida(ALIMENTADOR2); 
08356:  MOVLB  5
08358:  CLRF   x90
0835A:  MOVLW  0D
0835C:  MOVWF  x8F
0835E:  MOVLB  0
08360:  CALL   2DDC
....................             } else { 
08364:  BRA    848A
08366:  MOVLB  5
....................                 if (tempo1 > tempo2){ 
08368:  MOVF   x86,W
0836A:  SUBWF  x84,W
0836C:  BNC   8402
0836E:  BNZ   8376
08370:  MOVF   x83,W
08372:  SUBWF  x85,W
08374:  BC    8402
....................                     aciona_saida(ALIMENTADOR1); 
08376:  CLRF   x90
08378:  MOVLW  0E
0837A:  MOVWF  x8F
0837C:  MOVLB  0
0837E:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR2); 
08382:  MOVLB  5
08384:  CLRF   x90
08386:  MOVLW  0D
08388:  MOVWF  x8F
0838A:  MOVLB  0
0838C:  CALL   2E1E
....................                     delay_ms(tempo2); 
08390:  MOVFF  586,58F
08394:  MOVLB  5
08396:  INCF   x8F,F
08398:  DECF   x8F,F
0839A:  BTFSC  FD8.2
0839C:  BRA    83AA
0839E:  SETF   x92
083A0:  MOVLB  0
083A2:  CALL   2958
083A6:  MOVLB  5
083A8:  BRA    8398
083AA:  MOVFF  585,592
083AE:  MOVLB  0
083B0:  CALL   2958
....................                     desaciona_saida(ALIMENTADOR2); 
083B4:  MOVLB  5
083B6:  CLRF   x90
083B8:  MOVLW  0D
083BA:  MOVWF  x8F
083BC:  MOVLB  0
083BE:  CALL   2DDC
....................                     delay_ms(tempo1 - tempo2); 
083C2:  MOVLB  5
083C4:  MOVF   x85,W
083C6:  SUBWF  x83,W
083C8:  MOVWF  x8F
083CA:  MOVF   x86,W
083CC:  SUBWFB x84,W
083CE:  MOVWF  x90
083D0:  MOVWF  x91
083D2:  INCF   x91,F
083D4:  DECF   x91,F
083D6:  BTFSC  FD8.2
083D8:  BRA    83E6
083DA:  SETF   x92
083DC:  MOVLB  0
083DE:  CALL   2958
083E2:  MOVLB  5
083E4:  BRA    83D4
083E6:  MOVFF  58F,592
083EA:  MOVLB  0
083EC:  CALL   2958
....................                     desaciona_saida(ALIMENTADOR1); 
083F0:  MOVLB  5
083F2:  CLRF   x90
083F4:  MOVLW  0E
083F6:  MOVWF  x8F
083F8:  MOVLB  0
083FA:  CALL   2DDC
....................                 } else { 
083FE:  BRA    848A
08400:  MOVLB  5
....................                     aciona_saida(ALIMENTADOR1); 
08402:  CLRF   x90
08404:  MOVLW  0E
08406:  MOVWF  x8F
08408:  MOVLB  0
0840A:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR2); 
0840E:  MOVLB  5
08410:  CLRF   x90
08412:  MOVLW  0D
08414:  MOVWF  x8F
08416:  MOVLB  0
08418:  CALL   2E1E
....................                     delay_ms(tempo1); 
0841C:  MOVFF  584,58F
08420:  MOVLB  5
08422:  INCF   x8F,F
08424:  DECF   x8F,F
08426:  BTFSC  FD8.2
08428:  BRA    8436
0842A:  SETF   x92
0842C:  MOVLB  0
0842E:  CALL   2958
08432:  MOVLB  5
08434:  BRA    8424
08436:  MOVFF  583,592
0843A:  MOVLB  0
0843C:  CALL   2958
....................                     desaciona_saida(ALIMENTADOR1); 
08440:  MOVLB  5
08442:  CLRF   x90
08444:  MOVLW  0E
08446:  MOVWF  x8F
08448:  MOVLB  0
0844A:  CALL   2DDC
....................                     delay_ms(tempo2 - tempo1); 
0844E:  MOVLB  5
08450:  MOVF   x83,W
08452:  SUBWF  x85,W
08454:  MOVWF  x8F
08456:  MOVF   x84,W
08458:  SUBWFB x86,W
0845A:  MOVWF  x90
0845C:  MOVWF  x91
0845E:  INCF   x91,F
08460:  DECF   x91,F
08462:  BTFSC  FD8.2
08464:  BRA    8472
08466:  SETF   x92
08468:  MOVLB  0
0846A:  CALL   2958
0846E:  MOVLB  5
08470:  BRA    8460
08472:  MOVFF  58F,592
08476:  MOVLB  0
08478:  CALL   2958
....................                     desaciona_saida(ALIMENTADOR2); 
0847C:  MOVLB  5
0847E:  CLRF   x90
08480:  MOVLW  0D
08482:  MOVWF  x8F
08484:  MOVLB  0
08486:  CALL   2DDC
....................                 } 
....................             } 
....................         break; 
0848A:  MOVLB  5
0848C:  BRA    8C0C
....................         case 2: 
....................             if (tempo2 == tempo3){ 
0848E:  MOVLB  5
08490:  MOVF   x87,W
08492:  SUBWF  x85,W
08494:  BNZ   84FA
08496:  MOVF   x88,W
08498:  SUBWF  x86,W
0849A:  BNZ   84FA
....................                 aciona_saida(ALIMENTADOR2); 
0849C:  CLRF   x90
0849E:  MOVLW  0D
084A0:  MOVWF  x8F
084A2:  MOVLB  0
084A4:  CALL   2E1E
....................                 aciona_saida(ALIMENTADOR3); 
084A8:  MOVLB  5
084AA:  CLRF   x90
084AC:  MOVLW  0C
084AE:  MOVWF  x8F
084B0:  MOVLB  0
084B2:  CALL   2E1E
....................                 delay_ms(tempo2); 
084B6:  MOVFF  586,58F
084BA:  MOVLB  5
084BC:  INCF   x8F,F
084BE:  DECF   x8F,F
084C0:  BTFSC  FD8.2
084C2:  BRA    84D0
084C4:  SETF   x92
084C6:  MOVLB  0
084C8:  CALL   2958
084CC:  MOVLB  5
084CE:  BRA    84BE
084D0:  MOVFF  585,592
084D4:  MOVLB  0
084D6:  CALL   2958
....................                 desaciona_saida(ALIMENTADOR2); 
084DA:  MOVLB  5
084DC:  CLRF   x90
084DE:  MOVLW  0D
084E0:  MOVWF  x8F
084E2:  MOVLB  0
084E4:  CALL   2DDC
....................                 desaciona_saida(ALIMENTADOR3); 
084E8:  MOVLB  5
084EA:  CLRF   x90
084EC:  MOVLW  0C
084EE:  MOVWF  x8F
084F0:  MOVLB  0
084F2:  CALL   2DDC
....................             } else { 
084F6:  BRA    861C
084F8:  MOVLB  5
....................                 if (tempo2 > tempo3){ 
084FA:  MOVF   x88,W
084FC:  SUBWF  x86,W
084FE:  BNC   8594
08500:  BNZ   8508
08502:  MOVF   x85,W
08504:  SUBWF  x87,W
08506:  BC    8594
....................                     aciona_saida(ALIMENTADOR2); 
08508:  CLRF   x90
0850A:  MOVLW  0D
0850C:  MOVWF  x8F
0850E:  MOVLB  0
08510:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR3); 
08514:  MOVLB  5
08516:  CLRF   x90
08518:  MOVLW  0C
0851A:  MOVWF  x8F
0851C:  MOVLB  0
0851E:  CALL   2E1E
....................                     delay_ms(tempo3); 
08522:  MOVFF  588,58F
08526:  MOVLB  5
08528:  INCF   x8F,F
0852A:  DECF   x8F,F
0852C:  BTFSC  FD8.2
0852E:  BRA    853C
08530:  SETF   x92
08532:  MOVLB  0
08534:  CALL   2958
08538:  MOVLB  5
0853A:  BRA    852A
0853C:  MOVFF  587,592
08540:  MOVLB  0
08542:  CALL   2958
....................                     desaciona_saida(ALIMENTADOR3); 
08546:  MOVLB  5
08548:  CLRF   x90
0854A:  MOVLW  0C
0854C:  MOVWF  x8F
0854E:  MOVLB  0
08550:  CALL   2DDC
....................                     delay_ms(tempo2 - tempo3); 
08554:  MOVLB  5
08556:  MOVF   x87,W
08558:  SUBWF  x85,W
0855A:  MOVWF  x8F
0855C:  MOVF   x88,W
0855E:  SUBWFB x86,W
08560:  MOVWF  x90
08562:  MOVWF  x91
08564:  INCF   x91,F
08566:  DECF   x91,F
08568:  BTFSC  FD8.2
0856A:  BRA    8578
0856C:  SETF   x92
0856E:  MOVLB  0
08570:  CALL   2958
08574:  MOVLB  5
08576:  BRA    8566
08578:  MOVFF  58F,592
0857C:  MOVLB  0
0857E:  CALL   2958
....................                     desaciona_saida(ALIMENTADOR2); 
08582:  MOVLB  5
08584:  CLRF   x90
08586:  MOVLW  0D
08588:  MOVWF  x8F
0858A:  MOVLB  0
0858C:  CALL   2DDC
....................                 } else { 
08590:  BRA    861C
08592:  MOVLB  5
....................                     aciona_saida(ALIMENTADOR2); 
08594:  CLRF   x90
08596:  MOVLW  0D
08598:  MOVWF  x8F
0859A:  MOVLB  0
0859C:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR3); 
085A0:  MOVLB  5
085A2:  CLRF   x90
085A4:  MOVLW  0C
085A6:  MOVWF  x8F
085A8:  MOVLB  0
085AA:  CALL   2E1E
....................                     delay_ms(tempo2); 
085AE:  MOVFF  586,58F
085B2:  MOVLB  5
085B4:  INCF   x8F,F
085B6:  DECF   x8F,F
085B8:  BTFSC  FD8.2
085BA:  BRA    85C8
085BC:  SETF   x92
085BE:  MOVLB  0
085C0:  CALL   2958
085C4:  MOVLB  5
085C6:  BRA    85B6
085C8:  MOVFF  585,592
085CC:  MOVLB  0
085CE:  CALL   2958
....................                     desaciona_saida(ALIMENTADOR2); 
085D2:  MOVLB  5
085D4:  CLRF   x90
085D6:  MOVLW  0D
085D8:  MOVWF  x8F
085DA:  MOVLB  0
085DC:  CALL   2DDC
....................                     delay_ms(tempo3 - tempo2); 
085E0:  MOVLB  5
085E2:  MOVF   x85,W
085E4:  SUBWF  x87,W
085E6:  MOVWF  x8F
085E8:  MOVF   x86,W
085EA:  SUBWFB x88,W
085EC:  MOVWF  x90
085EE:  MOVWF  x91
085F0:  INCF   x91,F
085F2:  DECF   x91,F
085F4:  BTFSC  FD8.2
085F6:  BRA    8604
085F8:  SETF   x92
085FA:  MOVLB  0
085FC:  CALL   2958
08600:  MOVLB  5
08602:  BRA    85F2
08604:  MOVFF  58F,592
08608:  MOVLB  0
0860A:  CALL   2958
....................                     desaciona_saida(ALIMENTADOR3); 
0860E:  MOVLB  5
08610:  CLRF   x90
08612:  MOVLW  0C
08614:  MOVWF  x8F
08616:  MOVLB  0
08618:  CALL   2DDC
....................                 } 
....................             } 
....................         break; 
0861C:  MOVLB  5
0861E:  BRA    8C0C
....................         case 3: 
....................             if (tempo1>tempo2){ 
08620:  MOVLB  5
08622:  MOVF   x86,W
08624:  SUBWF  x84,W
08626:  BTFSS  FD8.0
08628:  BRA    891E
0862A:  BNZ   8634
0862C:  MOVF   x83,W
0862E:  SUBWF  x85,W
08630:  BTFSC  FD8.0
08632:  BRA    891E
....................                 if (tempo2>tempo3){ 
08634:  MOVF   x88,W
08636:  SUBWF  x86,W
08638:  BTFSS  FD8.0
0863A:  BRA    8732
0863C:  BNZ   8644
0863E:  MOVF   x85,W
08640:  SUBWF  x87,W
08642:  BC    8732
....................                     maior = tempo1; 
08644:  MOVFF  584,58A
08648:  MOVFF  583,589
....................                     medio = tempo2; 
0864C:  MOVFF  586,58C
08650:  MOVFF  585,58B
....................                     menor = tempo3; 
08654:  MOVFF  588,58E
08658:  MOVFF  587,58D
....................                     aciona_saida(ALIMENTADOR1); 
0865C:  CLRF   x90
0865E:  MOVLW  0E
08660:  MOVWF  x8F
08662:  MOVLB  0
08664:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR2); 
08668:  MOVLB  5
0866A:  CLRF   x90
0866C:  MOVLW  0D
0866E:  MOVWF  x8F
08670:  MOVLB  0
08672:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR3); 
08676:  MOVLB  5
08678:  CLRF   x90
0867A:  MOVLW  0C
0867C:  MOVWF  x8F
0867E:  MOVLB  0
08680:  CALL   2E1E
....................                     delay_ms(menor); 
08684:  MOVFF  58E,58F
08688:  MOVLB  5
0868A:  INCF   x8F,F
0868C:  DECF   x8F,F
0868E:  BTFSC  FD8.2
08690:  BRA    869E
08692:  SETF   x92
08694:  MOVLB  0
08696:  CALL   2958
0869A:  MOVLB  5
0869C:  BRA    868C
0869E:  MOVFF  58D,592
086A2:  MOVLB  0
086A4:  CALL   2958
....................                     desaciona_saida(ALIMENTADOR3); 
086A8:  MOVLB  5
086AA:  CLRF   x90
086AC:  MOVLW  0C
086AE:  MOVWF  x8F
086B0:  MOVLB  0
086B2:  CALL   2DDC
....................                     delay_ms(medio-menor); 
086B6:  MOVLB  5
086B8:  MOVF   x8D,W
086BA:  SUBWF  x8B,W
086BC:  MOVWF  x8F
086BE:  MOVF   x8E,W
086C0:  SUBWFB x8C,W
086C2:  MOVWF  x90
086C4:  MOVWF  x91
086C6:  INCF   x91,F
086C8:  DECF   x91,F
086CA:  BTFSC  FD8.2
086CC:  BRA    86DA
086CE:  SETF   x92
086D0:  MOVLB  0
086D2:  CALL   2958
086D6:  MOVLB  5
086D8:  BRA    86C8
086DA:  MOVFF  58F,592
086DE:  MOVLB  0
086E0:  CALL   2958
....................                     desaciona_saida(ALIMENTADOR2); 
086E4:  MOVLB  5
086E6:  CLRF   x90
086E8:  MOVLW  0D
086EA:  MOVWF  x8F
086EC:  MOVLB  0
086EE:  CALL   2DDC
....................                     delay_ms(maior-medio); 
086F2:  MOVLB  5
086F4:  MOVF   x8B,W
086F6:  SUBWF  x89,W
086F8:  MOVWF  x8F
086FA:  MOVF   x8C,W
086FC:  SUBWFB x8A,W
086FE:  MOVWF  x90
08700:  MOVWF  x91
08702:  INCF   x91,F
08704:  DECF   x91,F
08706:  BTFSC  FD8.2
08708:  BRA    8716
0870A:  SETF   x92
0870C:  MOVLB  0
0870E:  CALL   2958
08712:  MOVLB  5
08714:  BRA    8704
08716:  MOVFF  58F,592
0871A:  MOVLB  0
0871C:  CALL   2958
....................                     desaciona_saida(ALIMENTADOR1); 
08720:  MOVLB  5
08722:  CLRF   x90
08724:  MOVLW  0E
08726:  MOVWF  x8F
08728:  MOVLB  0
0872A:  CALL   2DDC
....................                 } else { 
0872E:  BRA    891A
08730:  MOVLB  5
....................                     if (tempo1 > tempo3) { 
08732:  MOVF   x88,W
08734:  SUBWF  x84,W
08736:  BTFSS  FD8.0
08738:  BRA    8830
0873A:  BNZ   8742
0873C:  MOVF   x83,W
0873E:  SUBWF  x87,W
08740:  BC    8830
....................                         maior = tempo1; 
08742:  MOVFF  584,58A
08746:  MOVFF  583,589
....................                         medio = tempo3; 
0874A:  MOVFF  588,58C
0874E:  MOVFF  587,58B
....................                         menor = tempo2; 
08752:  MOVFF  586,58E
08756:  MOVFF  585,58D
....................                         aciona_saida(ALIMENTADOR1); 
0875A:  CLRF   x90
0875C:  MOVLW  0E
0875E:  MOVWF  x8F
08760:  MOVLB  0
08762:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR2); 
08766:  MOVLB  5
08768:  CLRF   x90
0876A:  MOVLW  0D
0876C:  MOVWF  x8F
0876E:  MOVLB  0
08770:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR3); 
08774:  MOVLB  5
08776:  CLRF   x90
08778:  MOVLW  0C
0877A:  MOVWF  x8F
0877C:  MOVLB  0
0877E:  CALL   2E1E
....................                         delay_ms(menor); 
08782:  MOVFF  58E,58F
08786:  MOVLB  5
08788:  INCF   x8F,F
0878A:  DECF   x8F,F
0878C:  BTFSC  FD8.2
0878E:  BRA    879C
08790:  SETF   x92
08792:  MOVLB  0
08794:  CALL   2958
08798:  MOVLB  5
0879A:  BRA    878A
0879C:  MOVFF  58D,592
087A0:  MOVLB  0
087A2:  CALL   2958
....................                         desaciona_saida(ALIMENTADOR2); 
087A6:  MOVLB  5
087A8:  CLRF   x90
087AA:  MOVLW  0D
087AC:  MOVWF  x8F
087AE:  MOVLB  0
087B0:  CALL   2DDC
....................                         delay_ms(medio-menor); 
087B4:  MOVLB  5
087B6:  MOVF   x8D,W
087B8:  SUBWF  x8B,W
087BA:  MOVWF  x8F
087BC:  MOVF   x8E,W
087BE:  SUBWFB x8C,W
087C0:  MOVWF  x90
087C2:  MOVWF  x91
087C4:  INCF   x91,F
087C6:  DECF   x91,F
087C8:  BTFSC  FD8.2
087CA:  BRA    87D8
087CC:  SETF   x92
087CE:  MOVLB  0
087D0:  CALL   2958
087D4:  MOVLB  5
087D6:  BRA    87C6
087D8:  MOVFF  58F,592
087DC:  MOVLB  0
087DE:  CALL   2958
....................                         desaciona_saida(ALIMENTADOR3); 
087E2:  MOVLB  5
087E4:  CLRF   x90
087E6:  MOVLW  0C
087E8:  MOVWF  x8F
087EA:  MOVLB  0
087EC:  CALL   2DDC
....................                         delay_ms(maior-medio); 
087F0:  MOVLB  5
087F2:  MOVF   x8B,W
087F4:  SUBWF  x89,W
087F6:  MOVWF  x8F
087F8:  MOVF   x8C,W
087FA:  SUBWFB x8A,W
087FC:  MOVWF  x90
087FE:  MOVWF  x91
08800:  INCF   x91,F
08802:  DECF   x91,F
08804:  BTFSC  FD8.2
08806:  BRA    8814
08808:  SETF   x92
0880A:  MOVLB  0
0880C:  CALL   2958
08810:  MOVLB  5
08812:  BRA    8802
08814:  MOVFF  58F,592
08818:  MOVLB  0
0881A:  CALL   2958
....................                         desaciona_saida(ALIMENTADOR1); 
0881E:  MOVLB  5
08820:  CLRF   x90
08822:  MOVLW  0E
08824:  MOVWF  x8F
08826:  MOVLB  0
08828:  CALL   2DDC
....................                     } else { 
0882C:  BRA    891A
0882E:  MOVLB  5
....................                         maior = tempo3; 
08830:  MOVFF  588,58A
08834:  MOVFF  587,589
....................                         medio = tempo1; 
08838:  MOVFF  584,58C
0883C:  MOVFF  583,58B
....................                         menor = tempo2; 
08840:  MOVFF  586,58E
08844:  MOVFF  585,58D
....................                         aciona_saida(ALIMENTADOR1); 
08848:  CLRF   x90
0884A:  MOVLW  0E
0884C:  MOVWF  x8F
0884E:  MOVLB  0
08850:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR2); 
08854:  MOVLB  5
08856:  CLRF   x90
08858:  MOVLW  0D
0885A:  MOVWF  x8F
0885C:  MOVLB  0
0885E:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR3); 
08862:  MOVLB  5
08864:  CLRF   x90
08866:  MOVLW  0C
08868:  MOVWF  x8F
0886A:  MOVLB  0
0886C:  CALL   2E1E
....................                         delay_ms(menor); 
08870:  MOVFF  58E,58F
08874:  MOVLB  5
08876:  INCF   x8F,F
08878:  DECF   x8F,F
0887A:  BTFSC  FD8.2
0887C:  BRA    888A
0887E:  SETF   x92
08880:  MOVLB  0
08882:  CALL   2958
08886:  MOVLB  5
08888:  BRA    8878
0888A:  MOVFF  58D,592
0888E:  MOVLB  0
08890:  CALL   2958
....................                         desaciona_saida(ALIMENTADOR2); 
08894:  MOVLB  5
08896:  CLRF   x90
08898:  MOVLW  0D
0889A:  MOVWF  x8F
0889C:  MOVLB  0
0889E:  CALL   2DDC
....................                         delay_ms(medio-menor); 
088A2:  MOVLB  5
088A4:  MOVF   x8D,W
088A6:  SUBWF  x8B,W
088A8:  MOVWF  x8F
088AA:  MOVF   x8E,W
088AC:  SUBWFB x8C,W
088AE:  MOVWF  x90
088B0:  MOVWF  x91
088B2:  INCF   x91,F
088B4:  DECF   x91,F
088B6:  BTFSC  FD8.2
088B8:  BRA    88C6
088BA:  SETF   x92
088BC:  MOVLB  0
088BE:  CALL   2958
088C2:  MOVLB  5
088C4:  BRA    88B4
088C6:  MOVFF  58F,592
088CA:  MOVLB  0
088CC:  CALL   2958
....................                         desaciona_saida(ALIMENTADOR1); 
088D0:  MOVLB  5
088D2:  CLRF   x90
088D4:  MOVLW  0E
088D6:  MOVWF  x8F
088D8:  MOVLB  0
088DA:  CALL   2DDC
....................                         delay_ms(maior-medio); 
088DE:  MOVLB  5
088E0:  MOVF   x8B,W
088E2:  SUBWF  x89,W
088E4:  MOVWF  x8F
088E6:  MOVF   x8C,W
088E8:  SUBWFB x8A,W
088EA:  MOVWF  x90
088EC:  MOVWF  x91
088EE:  INCF   x91,F
088F0:  DECF   x91,F
088F2:  BTFSC  FD8.2
088F4:  BRA    8902
088F6:  SETF   x92
088F8:  MOVLB  0
088FA:  CALL   2958
088FE:  MOVLB  5
08900:  BRA    88F0
08902:  MOVFF  58F,592
08906:  MOVLB  0
08908:  CALL   2958
....................                         desaciona_saida(ALIMENTADOR3); 
0890C:  MOVLB  5
0890E:  CLRF   x90
08910:  MOVLW  0C
08912:  MOVWF  x8F
08914:  MOVLB  0
08916:  CALL   2DDC
....................                     } 
....................                 } 
....................             } else { 
0891A:  BRA    8C06
0891C:  MOVLB  5
....................                 if (tempo2>tempo3){ 
0891E:  MOVF   x88,W
08920:  SUBWF  x86,W
08922:  BTFSS  FD8.0
08924:  BRA    8B1C
08926:  BNZ   8930
08928:  MOVF   x85,W
0892A:  SUBWF  x87,W
0892C:  BTFSC  FD8.0
0892E:  BRA    8B1C
....................                     if (tempo1 > tempo3){ 
08930:  MOVF   x88,W
08932:  SUBWF  x84,W
08934:  BTFSS  FD8.0
08936:  BRA    8A2E
08938:  BNZ   8940
0893A:  MOVF   x83,W
0893C:  SUBWF  x87,W
0893E:  BC    8A2E
....................                         maior = tempo2; 
08940:  MOVFF  586,58A
08944:  MOVFF  585,589
....................                         medio = tempo1; 
08948:  MOVFF  584,58C
0894C:  MOVFF  583,58B
....................                         menor = tempo3; 
08950:  MOVFF  588,58E
08954:  MOVFF  587,58D
....................                         aciona_saida(ALIMENTADOR1); 
08958:  CLRF   x90
0895A:  MOVLW  0E
0895C:  MOVWF  x8F
0895E:  MOVLB  0
08960:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR2); 
08964:  MOVLB  5
08966:  CLRF   x90
08968:  MOVLW  0D
0896A:  MOVWF  x8F
0896C:  MOVLB  0
0896E:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR3); 
08972:  MOVLB  5
08974:  CLRF   x90
08976:  MOVLW  0C
08978:  MOVWF  x8F
0897A:  MOVLB  0
0897C:  CALL   2E1E
....................                         delay_ms(menor); 
08980:  MOVFF  58E,58F
08984:  MOVLB  5
08986:  INCF   x8F,F
08988:  DECF   x8F,F
0898A:  BTFSC  FD8.2
0898C:  BRA    899A
0898E:  SETF   x92
08990:  MOVLB  0
08992:  CALL   2958
08996:  MOVLB  5
08998:  BRA    8988
0899A:  MOVFF  58D,592
0899E:  MOVLB  0
089A0:  CALL   2958
....................                         desaciona_saida(ALIMENTADOR3); 
089A4:  MOVLB  5
089A6:  CLRF   x90
089A8:  MOVLW  0C
089AA:  MOVWF  x8F
089AC:  MOVLB  0
089AE:  CALL   2DDC
....................                         delay_ms(medio-menor); 
089B2:  MOVLB  5
089B4:  MOVF   x8D,W
089B6:  SUBWF  x8B,W
089B8:  MOVWF  x8F
089BA:  MOVF   x8E,W
089BC:  SUBWFB x8C,W
089BE:  MOVWF  x90
089C0:  MOVWF  x91
089C2:  INCF   x91,F
089C4:  DECF   x91,F
089C6:  BTFSC  FD8.2
089C8:  BRA    89D6
089CA:  SETF   x92
089CC:  MOVLB  0
089CE:  CALL   2958
089D2:  MOVLB  5
089D4:  BRA    89C4
089D6:  MOVFF  58F,592
089DA:  MOVLB  0
089DC:  CALL   2958
....................                         desaciona_saida(ALIMENTADOR1); 
089E0:  MOVLB  5
089E2:  CLRF   x90
089E4:  MOVLW  0E
089E6:  MOVWF  x8F
089E8:  MOVLB  0
089EA:  CALL   2DDC
....................                         delay_ms(maior-medio); 
089EE:  MOVLB  5
089F0:  MOVF   x8B,W
089F2:  SUBWF  x89,W
089F4:  MOVWF  x8F
089F6:  MOVF   x8C,W
089F8:  SUBWFB x8A,W
089FA:  MOVWF  x90
089FC:  MOVWF  x91
089FE:  INCF   x91,F
08A00:  DECF   x91,F
08A02:  BTFSC  FD8.2
08A04:  BRA    8A12
08A06:  SETF   x92
08A08:  MOVLB  0
08A0A:  CALL   2958
08A0E:  MOVLB  5
08A10:  BRA    8A00
08A12:  MOVFF  58F,592
08A16:  MOVLB  0
08A18:  CALL   2958
....................                         desaciona_saida(ALIMENTADOR2); 
08A1C:  MOVLB  5
08A1E:  CLRF   x90
08A20:  MOVLW  0D
08A22:  MOVWF  x8F
08A24:  MOVLB  0
08A26:  CALL   2DDC
....................                     } else { 
08A2A:  BRA    8B18
08A2C:  MOVLB  5
....................                         maior = tempo2; 
08A2E:  MOVFF  586,58A
08A32:  MOVFF  585,589
....................                         medio = tempo3; 
08A36:  MOVFF  588,58C
08A3A:  MOVFF  587,58B
....................                         menor = tempo1; 
08A3E:  MOVFF  584,58E
08A42:  MOVFF  583,58D
....................                         aciona_saida(ALIMENTADOR1); 
08A46:  CLRF   x90
08A48:  MOVLW  0E
08A4A:  MOVWF  x8F
08A4C:  MOVLB  0
08A4E:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR2); 
08A52:  MOVLB  5
08A54:  CLRF   x90
08A56:  MOVLW  0D
08A58:  MOVWF  x8F
08A5A:  MOVLB  0
08A5C:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR3); 
08A60:  MOVLB  5
08A62:  CLRF   x90
08A64:  MOVLW  0C
08A66:  MOVWF  x8F
08A68:  MOVLB  0
08A6A:  CALL   2E1E
....................                         delay_ms(menor); 
08A6E:  MOVFF  58E,58F
08A72:  MOVLB  5
08A74:  INCF   x8F,F
08A76:  DECF   x8F,F
08A78:  BTFSC  FD8.2
08A7A:  BRA    8A88
08A7C:  SETF   x92
08A7E:  MOVLB  0
08A80:  CALL   2958
08A84:  MOVLB  5
08A86:  BRA    8A76
08A88:  MOVFF  58D,592
08A8C:  MOVLB  0
08A8E:  CALL   2958
....................                         desaciona_saida(ALIMENTADOR1); 
08A92:  MOVLB  5
08A94:  CLRF   x90
08A96:  MOVLW  0E
08A98:  MOVWF  x8F
08A9A:  MOVLB  0
08A9C:  CALL   2DDC
....................                         delay_ms(medio-menor); 
08AA0:  MOVLB  5
08AA2:  MOVF   x8D,W
08AA4:  SUBWF  x8B,W
08AA6:  MOVWF  x8F
08AA8:  MOVF   x8E,W
08AAA:  SUBWFB x8C,W
08AAC:  MOVWF  x90
08AAE:  MOVWF  x91
08AB0:  INCF   x91,F
08AB2:  DECF   x91,F
08AB4:  BTFSC  FD8.2
08AB6:  BRA    8AC4
08AB8:  SETF   x92
08ABA:  MOVLB  0
08ABC:  CALL   2958
08AC0:  MOVLB  5
08AC2:  BRA    8AB2
08AC4:  MOVFF  58F,592
08AC8:  MOVLB  0
08ACA:  CALL   2958
....................                         desaciona_saida(ALIMENTADOR3); 
08ACE:  MOVLB  5
08AD0:  CLRF   x90
08AD2:  MOVLW  0C
08AD4:  MOVWF  x8F
08AD6:  MOVLB  0
08AD8:  CALL   2DDC
....................                         delay_ms(maior-medio); 
08ADC:  MOVLB  5
08ADE:  MOVF   x8B,W
08AE0:  SUBWF  x89,W
08AE2:  MOVWF  x8F
08AE4:  MOVF   x8C,W
08AE6:  SUBWFB x8A,W
08AE8:  MOVWF  x90
08AEA:  MOVWF  x91
08AEC:  INCF   x91,F
08AEE:  DECF   x91,F
08AF0:  BTFSC  FD8.2
08AF2:  BRA    8B00
08AF4:  SETF   x92
08AF6:  MOVLB  0
08AF8:  CALL   2958
08AFC:  MOVLB  5
08AFE:  BRA    8AEE
08B00:  MOVFF  58F,592
08B04:  MOVLB  0
08B06:  CALL   2958
....................                         desaciona_saida(ALIMENTADOR2); 
08B0A:  MOVLB  5
08B0C:  CLRF   x90
08B0E:  MOVLW  0D
08B10:  MOVWF  x8F
08B12:  MOVLB  0
08B14:  CALL   2DDC
....................                     } 
....................                 } else { 
08B18:  BRA    8C06
08B1A:  MOVLB  5
....................                     maior = tempo3; 
08B1C:  MOVFF  588,58A
08B20:  MOVFF  587,589
....................                     medio = tempo2; 
08B24:  MOVFF  586,58C
08B28:  MOVFF  585,58B
....................                     menor = tempo1; 
08B2C:  MOVFF  584,58E
08B30:  MOVFF  583,58D
....................                     aciona_saida(ALIMENTADOR1); 
08B34:  CLRF   x90
08B36:  MOVLW  0E
08B38:  MOVWF  x8F
08B3A:  MOVLB  0
08B3C:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR2); 
08B40:  MOVLB  5
08B42:  CLRF   x90
08B44:  MOVLW  0D
08B46:  MOVWF  x8F
08B48:  MOVLB  0
08B4A:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR3); 
08B4E:  MOVLB  5
08B50:  CLRF   x90
08B52:  MOVLW  0C
08B54:  MOVWF  x8F
08B56:  MOVLB  0
08B58:  CALL   2E1E
....................                     delay_ms(menor); 
08B5C:  MOVFF  58E,58F
08B60:  MOVLB  5
08B62:  INCF   x8F,F
08B64:  DECF   x8F,F
08B66:  BTFSC  FD8.2
08B68:  BRA    8B76
08B6A:  SETF   x92
08B6C:  MOVLB  0
08B6E:  CALL   2958
08B72:  MOVLB  5
08B74:  BRA    8B64
08B76:  MOVFF  58D,592
08B7A:  MOVLB  0
08B7C:  CALL   2958
....................                     desaciona_saida(ALIMENTADOR1); 
08B80:  MOVLB  5
08B82:  CLRF   x90
08B84:  MOVLW  0E
08B86:  MOVWF  x8F
08B88:  MOVLB  0
08B8A:  CALL   2DDC
....................                     delay_ms(medio-menor); 
08B8E:  MOVLB  5
08B90:  MOVF   x8D,W
08B92:  SUBWF  x8B,W
08B94:  MOVWF  x8F
08B96:  MOVF   x8E,W
08B98:  SUBWFB x8C,W
08B9A:  MOVWF  x90
08B9C:  MOVWF  x91
08B9E:  INCF   x91,F
08BA0:  DECF   x91,F
08BA2:  BTFSC  FD8.2
08BA4:  BRA    8BB2
08BA6:  SETF   x92
08BA8:  MOVLB  0
08BAA:  CALL   2958
08BAE:  MOVLB  5
08BB0:  BRA    8BA0
08BB2:  MOVFF  58F,592
08BB6:  MOVLB  0
08BB8:  CALL   2958
....................                     desaciona_saida(ALIMENTADOR2); 
08BBC:  MOVLB  5
08BBE:  CLRF   x90
08BC0:  MOVLW  0D
08BC2:  MOVWF  x8F
08BC4:  MOVLB  0
08BC6:  CALL   2DDC
....................                     delay_ms(maior-medio); 
08BCA:  MOVLB  5
08BCC:  MOVF   x8B,W
08BCE:  SUBWF  x89,W
08BD0:  MOVWF  x8F
08BD2:  MOVF   x8C,W
08BD4:  SUBWFB x8A,W
08BD6:  MOVWF  x90
08BD8:  MOVWF  x91
08BDA:  INCF   x91,F
08BDC:  DECF   x91,F
08BDE:  BTFSC  FD8.2
08BE0:  BRA    8BEE
08BE2:  SETF   x92
08BE4:  MOVLB  0
08BE6:  CALL   2958
08BEA:  MOVLB  5
08BEC:  BRA    8BDC
08BEE:  MOVFF  58F,592
08BF2:  MOVLB  0
08BF4:  CALL   2958
....................                     desaciona_saida(ALIMENTADOR3); 
08BF8:  MOVLB  5
08BFA:  CLRF   x90
08BFC:  MOVLW  0C
08BFE:  MOVWF  x8F
08C00:  MOVLB  0
08C02:  CALL   2DDC
....................                 } 
....................             } 
....................         break; 
08C06:  MOVLB  5
08C08:  BRA    8C0C
08C0A:  MOVLB  5
....................     } 
08C0C:  MOVLB  0
08C0E:  RETURN 0
....................              
.................... } 
....................  
.................... void soldar_teste(int componente, int local){ 
....................     liga_pressor(); 
*
08C3C:  CALL   788C
....................     if ((local == 14)&&(modelo == 1)){ 
08C40:  MOVLB  5
08C42:  MOVF   x79,W
08C44:  SUBLW  0E
08C46:  BNZ   8C4E
08C48:  DECFSZ 2F,W
08C4A:  BRA    8C4E
....................         local++; 
08C4C:  INCF   x79,F
....................     } 
....................     if ((y[local] > 700)&&(x[local] > 0)){ 
08C4E:  BCF    FD8.0
08C50:  RLCF   x79,W
08C52:  CLRF   03
08C54:  ADDLW  5A
08C56:  MOVWF  FE9
08C58:  MOVLW  00
08C5A:  ADDWFC 03,W
08C5C:  MOVWF  FEA
08C5E:  MOVFF  FEC,57B
08C62:  MOVF   FED,F
08C64:  MOVFF  FEF,57A
08C68:  MOVF   x7B,W
08C6A:  SUBLW  01
08C6C:  BTFSC  FD8.0
08C6E:  BRA    9308
08C70:  XORLW  FF
08C72:  BNZ   8C7C
08C74:  MOVF   x7A,W
08C76:  SUBLW  BC
08C78:  BTFSC  FD8.0
08C7A:  BRA    9308
08C7C:  BCF    FD8.0
08C7E:  RLCF   x79,W
08C80:  CLRF   03
08C82:  ADDLW  30
08C84:  MOVWF  FE9
08C86:  MOVLW  00
08C88:  ADDWFC 03,W
08C8A:  MOVWF  FEA
08C8C:  MOVFF  FEC,57B
08C90:  MOVF   FED,F
08C92:  MOVFF  FEF,57A
08C96:  MOVF   x7A,F
08C98:  BNZ   8CA0
08C9A:  MOVF   x7B,F
08C9C:  BTFSC  FD8.2
08C9E:  BRA    9308
....................         desce_ferros(numeroFerros[local]); 
08CA0:  BCF    FD8.0
08CA2:  RLCF   x79,W
08CA4:  CLRF   03
08CA6:  ADDLW  58
08CA8:  MOVWF  FE9
08CAA:  MOVLW  01
08CAC:  ADDWFC 03,W
08CAE:  MOVWF  FEA
08CB0:  MOVFF  FEC,57B
08CB4:  MOVF   FED,F
08CB6:  MOVFF  FEF,57A
08CBA:  MOVFF  57A,57D
08CBE:  MOVLB  0
08CC0:  CALL   783A
....................         switch (componente){ 
08CC4:  MOVLB  5
08CC6:  MOVF   x78,W
08CC8:  XORLW  00
08CCA:  MOVLB  0
08CCC:  BZ    8CD6
08CCE:  XORLW  01
08CD0:  BTFSC  FD8.2
08CD2:  BRA    8EB8
08CD4:  BRA    9304
....................             case 0: 
....................                 motor_run_y(y[local], 19); 
08CD6:  BCF    FD8.0
08CD8:  MOVLB  5
08CDA:  RLCF   x79,W
08CDC:  CLRF   03
08CDE:  ADDLW  5A
08CE0:  MOVWF  FE9
08CE2:  MOVLW  00
08CE4:  ADDWFC 03,W
08CE6:  MOVWF  FEA
08CE8:  MOVFF  FEC,57B
08CEC:  MOVF   FED,F
08CEE:  MOVFF  FEF,57A
08CF2:  CLRF   x80
08CF4:  CLRF   x7F
08CF6:  MOVFF  57B,57E
08CFA:  MOVFF  57A,57D
08CFE:  MOVLW  13
08D00:  MOVWF  x81
08D02:  MOVLB  0
08D04:  CALL   55A6
....................                 while ((run_flg_y)); 
08D08:  MOVLB  2
08D0A:  BTFSC  x0C.7
08D0C:  BRA    8D0A
....................                 motor_run_x(x[local], 19); 
08D0E:  BCF    FD8.0
08D10:  MOVLB  5
08D12:  RLCF   x79,W
08D14:  CLRF   03
08D16:  ADDLW  30
08D18:  MOVWF  FE9
08D1A:  MOVLW  00
08D1C:  ADDWFC 03,W
08D1E:  MOVWF  FEA
08D20:  MOVFF  FEC,57B
08D24:  MOVF   FED,F
08D26:  MOVFF  FEF,57A
08D2A:  CLRF   x80
08D2C:  CLRF   x7F
08D2E:  MOVFF  57B,57E
08D32:  MOVFF  57A,57D
08D36:  MOVLW  13
08D38:  MOVWF  x81
08D3A:  MOVLB  0
08D3C:  CALL   5968
....................                 while ((run_flg_x)); 
08D40:  MOVLB  2
08D42:  BTFSC  x0C.5
08D44:  BRA    8D42
....................                 ligar_alimentador_solda(numeroFerros[local],t_solda[local],t_solda2[local],t_solda3[local]); 
08D46:  BCF    FD8.0
08D48:  MOVLB  5
08D4A:  RLCF   x79,W
08D4C:  CLRF   03
08D4E:  ADDLW  58
08D50:  MOVWF  FE9
08D52:  MOVLW  01
08D54:  ADDWFC 03,W
08D56:  MOVWF  FEA
08D58:  MOVFF  FEC,57B
08D5C:  MOVF   FED,F
08D5E:  MOVFF  FEF,57A
08D62:  BCF    FD8.0
08D64:  RLCF   x79,W
08D66:  CLRF   03
08D68:  ADDLW  AE
08D6A:  MOVWF  FE9
08D6C:  MOVLW  00
08D6E:  ADDWFC 03,W
08D70:  MOVWF  FEA
08D72:  MOVFF  FEC,57D
08D76:  MOVF   FED,F
08D78:  MOVFF  FEF,57C
08D7C:  BCF    FD8.0
08D7E:  RLCF   x79,W
08D80:  CLRF   03
08D82:  ADDLW  82
08D84:  MOVWF  FE9
08D86:  MOVLW  01
08D88:  ADDWFC 03,W
08D8A:  MOVWF  FEA
08D8C:  MOVFF  FEC,57F
08D90:  MOVF   FED,F
08D92:  MOVFF  FEF,57E
08D96:  BCF    FD8.0
08D98:  RLCF   x79,W
08D9A:  CLRF   03
08D9C:  ADDLW  AC
08D9E:  MOVWF  FE9
08DA0:  MOVLW  01
08DA2:  ADDWFC 03,W
08DA4:  MOVWF  FEA
08DA6:  MOVFF  FEC,581
08DAA:  MOVF   FED,F
08DAC:  MOVFF  FEF,580
08DB0:  MOVFF  57A,582
08DB4:  MOVFF  57D,584
08DB8:  MOVFF  57C,583
08DBC:  MOVFF  57F,586
08DC0:  MOVFF  57E,585
08DC4:  MOVFF  581,588
08DC8:  MOVFF  580,587
08DCC:  MOVLB  0
08DCE:  CALL   82A2
....................                 motor_run_z(z[local], 19); 
08DD2:  BCF    FD8.0
08DD4:  MOVLB  5
08DD6:  RLCF   x79,W
08DD8:  CLRF   03
08DDA:  ADDLW  84
08DDC:  MOVWF  FE9
08DDE:  MOVLW  00
08DE0:  ADDWFC 03,W
08DE2:  MOVWF  FEA
08DE4:  MOVFF  FEC,57B
08DE8:  MOVF   FED,F
08DEA:  MOVFF  FEF,57A
08DEE:  CLRF   x80
08DF0:  CLRF   x7F
08DF2:  MOVFF  57B,57E
08DF6:  MOVFF  57A,57D
08DFA:  MOVLW  13
08DFC:  MOVWF  x81
08DFE:  MOVLB  0
08E00:  CALL   5346
....................                 while ((run_flg_z)); 
08E04:  MOVLB  3
08E06:  BTFSC  xB8.2
08E08:  BRA    8E06
....................                 delay_ms(t_wait[local]);  
08E0A:  BCF    FD8.0
08E0C:  MOVLB  5
08E0E:  RLCF   x79,W
08E10:  CLRF   03
08E12:  ADDLW  D8
08E14:  MOVWF  FE9
08E16:  MOVLW  00
08E18:  ADDWFC 03,W
08E1A:  MOVWF  FEA
08E1C:  MOVFF  FEC,57B
08E20:  MOVF   FED,F
08E22:  MOVFF  FEF,57A
08E26:  MOVFF  57B,57C
08E2A:  INCF   x7C,F
08E2C:  DECF   x7C,F
08E2E:  BTFSC  FD8.2
08E30:  BRA    8E3E
08E32:  SETF   x92
08E34:  MOVLB  0
08E36:  CALL   2958
08E3A:  MOVLB  5
08E3C:  BRA    8E2C
08E3E:  MOVFF  57A,592
08E42:  MOVLB  0
08E44:  CALL   2958
....................                 motor_run_z(0, 19); 
08E48:  MOVLB  5
08E4A:  CLRF   x80
08E4C:  CLRF   x7F
08E4E:  CLRF   x7E
08E50:  CLRF   x7D
08E52:  MOVLW  13
08E54:  MOVWF  x81
08E56:  MOVLB  0
08E58:  CALL   5346
....................                 while ((run_flg_z)); 
08E5C:  MOVLB  3
08E5E:  BTFSC  xB8.2
08E60:  BRA    8E5E
....................                 desce_ferros(3); 
08E62:  MOVLW  03
08E64:  MOVLB  5
08E66:  MOVWF  x7D
08E68:  MOVLB  0
08E6A:  CALL   783A
....................                 aciona_saida(LIMPA_BICO1); 
08E6E:  MOVLB  5
08E70:  CLRF   x90
08E72:  MOVLW  08
08E74:  MOVWF  x8F
08E76:  MOVLB  0
08E78:  CALL   2E1E
....................                 aciona_saida(LIMPA_BICO2); 
08E7C:  MOVLB  5
08E7E:  CLRF   x90
08E80:  MOVLW  09
08E82:  MOVWF  x8F
08E84:  MOVLB  0
08E86:  CALL   2E1E
....................                 delay_ms(200); 
08E8A:  MOVLW  C8
08E8C:  MOVLB  5
08E8E:  MOVWF  x92
08E90:  MOVLB  0
08E92:  CALL   2958
....................                 desaciona_saida(LIMPA_BICO1); 
08E96:  MOVLB  5
08E98:  CLRF   x90
08E9A:  MOVLW  08
08E9C:  MOVWF  x8F
08E9E:  MOVLB  0
08EA0:  CALL   2DDC
....................                 desaciona_saida(LIMPA_BICO2); 
08EA4:  MOVLB  5
08EA6:  CLRF   x90
08EA8:  MOVLW  09
08EAA:  MOVWF  x8F
08EAC:  MOVLB  0
08EAE:  CALL   2DDC
....................                 sobe_ferros(); 
08EB2:  CALL   781C
....................             break; 
08EB6:  BRA    9304
....................             case 1: 
....................                 motor_run_y(y[local], 19); 
08EB8:  BCF    FD8.0
08EBA:  MOVLB  5
08EBC:  RLCF   x79,W
08EBE:  CLRF   03
08EC0:  ADDLW  5A
08EC2:  MOVWF  FE9
08EC4:  MOVLW  00
08EC6:  ADDWFC 03,W
08EC8:  MOVWF  FEA
08ECA:  MOVFF  FEC,57B
08ECE:  MOVF   FED,F
08ED0:  MOVFF  FEF,57A
08ED4:  CLRF   x80
08ED6:  CLRF   x7F
08ED8:  MOVFF  57B,57E
08EDC:  MOVFF  57A,57D
08EE0:  MOVLW  13
08EE2:  MOVWF  x81
08EE4:  MOVLB  0
08EE6:  CALL   55A6
....................                 while ((run_flg_y)); 
08EEA:  MOVLB  2
08EEC:  BTFSC  x0C.7
08EEE:  BRA    8EEC
....................                 motor_run_x(x[local], 19); 
08EF0:  BCF    FD8.0
08EF2:  MOVLB  5
08EF4:  RLCF   x79,W
08EF6:  CLRF   03
08EF8:  ADDLW  30
08EFA:  MOVWF  FE9
08EFC:  MOVLW  00
08EFE:  ADDWFC 03,W
08F00:  MOVWF  FEA
08F02:  MOVFF  FEC,57B
08F06:  MOVF   FED,F
08F08:  MOVFF  FEF,57A
08F0C:  CLRF   x80
08F0E:  CLRF   x7F
08F10:  MOVFF  57B,57E
08F14:  MOVFF  57A,57D
08F18:  MOVLW  13
08F1A:  MOVWF  x81
08F1C:  MOVLB  0
08F1E:  CALL   5968
....................                 while ((run_flg_x)); 
08F22:  MOVLB  2
08F24:  BTFSC  x0C.5
08F26:  BRA    8F24
....................                 ligar_alimentador_solda(numeroFerros[local],t_solda[local],t_solda2[local],t_solda3[local]); 
08F28:  BCF    FD8.0
08F2A:  MOVLB  5
08F2C:  RLCF   x79,W
08F2E:  CLRF   03
08F30:  ADDLW  58
08F32:  MOVWF  FE9
08F34:  MOVLW  01
08F36:  ADDWFC 03,W
08F38:  MOVWF  FEA
08F3A:  MOVFF  FEC,57B
08F3E:  MOVF   FED,F
08F40:  MOVFF  FEF,57A
08F44:  BCF    FD8.0
08F46:  RLCF   x79,W
08F48:  CLRF   03
08F4A:  ADDLW  AE
08F4C:  MOVWF  FE9
08F4E:  MOVLW  00
08F50:  ADDWFC 03,W
08F52:  MOVWF  FEA
08F54:  MOVFF  FEC,57D
08F58:  MOVF   FED,F
08F5A:  MOVFF  FEF,57C
08F5E:  BCF    FD8.0
08F60:  RLCF   x79,W
08F62:  CLRF   03
08F64:  ADDLW  82
08F66:  MOVWF  FE9
08F68:  MOVLW  01
08F6A:  ADDWFC 03,W
08F6C:  MOVWF  FEA
08F6E:  MOVFF  FEC,57F
08F72:  MOVF   FED,F
08F74:  MOVFF  FEF,57E
08F78:  BCF    FD8.0
08F7A:  RLCF   x79,W
08F7C:  CLRF   03
08F7E:  ADDLW  AC
08F80:  MOVWF  FE9
08F82:  MOVLW  01
08F84:  ADDWFC 03,W
08F86:  MOVWF  FEA
08F88:  MOVFF  FEC,581
08F8C:  MOVF   FED,F
08F8E:  MOVFF  FEF,580
08F92:  MOVFF  57A,582
08F96:  MOVFF  57D,584
08F9A:  MOVFF  57C,583
08F9E:  MOVFF  57F,586
08FA2:  MOVFF  57E,585
08FA6:  MOVFF  581,588
08FAA:  MOVFF  580,587
08FAE:  MOVLB  0
08FB0:  CALL   82A2
....................                 motor_run_z(z[local], 19); 
08FB4:  BCF    FD8.0
08FB6:  MOVLB  5
08FB8:  RLCF   x79,W
08FBA:  CLRF   03
08FBC:  ADDLW  84
08FBE:  MOVWF  FE9
08FC0:  MOVLW  00
08FC2:  ADDWFC 03,W
08FC4:  MOVWF  FEA
08FC6:  MOVFF  FEC,57B
08FCA:  MOVF   FED,F
08FCC:  MOVFF  FEF,57A
08FD0:  CLRF   x80
08FD2:  CLRF   x7F
08FD4:  MOVFF  57B,57E
08FD8:  MOVFF  57A,57D
08FDC:  MOVLW  13
08FDE:  MOVWF  x81
08FE0:  MOVLB  0
08FE2:  CALL   5346
....................                 while ((run_flg_z)); 
08FE6:  MOVLB  3
08FE8:  BTFSC  xB8.2
08FEA:  BRA    8FE8
....................                 delay_ms(t_wait[local]); 
08FEC:  BCF    FD8.0
08FEE:  MOVLB  5
08FF0:  RLCF   x79,W
08FF2:  CLRF   03
08FF4:  ADDLW  D8
08FF6:  MOVWF  FE9
08FF8:  MOVLW  00
08FFA:  ADDWFC 03,W
08FFC:  MOVWF  FEA
08FFE:  MOVFF  FEC,57B
09002:  MOVF   FED,F
09004:  MOVFF  FEF,57A
09008:  MOVFF  57B,57C
0900C:  INCF   x7C,F
0900E:  DECF   x7C,F
09010:  BTFSC  FD8.2
09012:  BRA    9020
09014:  SETF   x92
09016:  MOVLB  0
09018:  CALL   2958
0901C:  MOVLB  5
0901E:  BRA    900E
09020:  MOVFF  57A,592
09024:  MOVLB  0
09026:  CALL   2958
....................                 motor_run_z(z[local]-5, 19); 
0902A:  BCF    FD8.0
0902C:  MOVLB  5
0902E:  RLCF   x79,W
09030:  CLRF   03
09032:  ADDLW  84
09034:  MOVWF  FE9
09036:  MOVLW  00
09038:  ADDWFC 03,W
0903A:  MOVWF  FEA
0903C:  MOVFF  FEC,57B
09040:  MOVF   FED,F
09042:  MOVFF  FEF,57A
09046:  MOVLW  05
09048:  SUBWF  x7A,F
0904A:  MOVLW  00
0904C:  SUBWFB x7B,F
0904E:  CLRF   x80
09050:  CLRF   x7F
09052:  MOVFF  57B,57E
09056:  MOVFF  57A,57D
0905A:  MOVLW  13
0905C:  MOVWF  x81
0905E:  MOVLB  0
09060:  CALL   5346
....................                 while ((run_flg_z)); 
09064:  MOVLB  3
09066:  BTFSC  xB8.2
09068:  BRA    9066
....................                 motor_run_x(x[local]-21, 19); 
0906A:  BCF    FD8.0
0906C:  MOVLB  5
0906E:  RLCF   x79,W
09070:  CLRF   03
09072:  ADDLW  30
09074:  MOVWF  FE9
09076:  MOVLW  00
09078:  ADDWFC 03,W
0907A:  MOVWF  FEA
0907C:  MOVFF  FEC,57B
09080:  MOVF   FED,F
09082:  MOVFF  FEF,57A
09086:  MOVLW  15
09088:  SUBWF  x7A,F
0908A:  MOVLW  00
0908C:  SUBWFB x7B,F
0908E:  CLRF   x80
09090:  CLRF   x7F
09092:  MOVFF  57B,57E
09096:  MOVFF  57A,57D
0909A:  MOVLW  13
0909C:  MOVWF  x81
0909E:  MOVLB  0
090A0:  CALL   5968
....................                 while ((run_flg_x)); 
090A4:  MOVLB  2
090A6:  BTFSC  x0C.5
090A8:  BRA    90A6
....................                 motor_run_z(z[local], 19); 
090AA:  BCF    FD8.0
090AC:  MOVLB  5
090AE:  RLCF   x79,W
090B0:  CLRF   03
090B2:  ADDLW  84
090B4:  MOVWF  FE9
090B6:  MOVLW  00
090B8:  ADDWFC 03,W
090BA:  MOVWF  FEA
090BC:  MOVFF  FEC,57B
090C0:  MOVF   FED,F
090C2:  MOVFF  FEF,57A
090C6:  CLRF   x80
090C8:  CLRF   x7F
090CA:  MOVFF  57B,57E
090CE:  MOVFF  57A,57D
090D2:  MOVLW  13
090D4:  MOVWF  x81
090D6:  MOVLB  0
090D8:  CALL   5346
....................                 while ((run_flg_z)); 
090DC:  MOVLB  3
090DE:  BTFSC  xB8.2
090E0:  BRA    90DE
....................                 delay_ms(t_wait[local]);   
090E2:  BCF    FD8.0
090E4:  MOVLB  5
090E6:  RLCF   x79,W
090E8:  CLRF   03
090EA:  ADDLW  D8
090EC:  MOVWF  FE9
090EE:  MOVLW  00
090F0:  ADDWFC 03,W
090F2:  MOVWF  FEA
090F4:  MOVFF  FEC,57B
090F8:  MOVF   FED,F
090FA:  MOVFF  FEF,57A
090FE:  MOVFF  57B,57C
09102:  INCF   x7C,F
09104:  DECF   x7C,F
09106:  BTFSC  FD8.2
09108:  BRA    9116
0910A:  SETF   x92
0910C:  MOVLB  0
0910E:  CALL   2958
09112:  MOVLB  5
09114:  BRA    9104
09116:  MOVFF  57A,592
0911A:  MOVLB  0
0911C:  CALL   2958
....................                 motor_run_z(z[local]-5, 19); 
09120:  BCF    FD8.0
09122:  MOVLB  5
09124:  RLCF   x79,W
09126:  CLRF   03
09128:  ADDLW  84
0912A:  MOVWF  FE9
0912C:  MOVLW  00
0912E:  ADDWFC 03,W
09130:  MOVWF  FEA
09132:  MOVFF  FEC,57B
09136:  MOVF   FED,F
09138:  MOVFF  FEF,57A
0913C:  MOVLW  05
0913E:  SUBWF  x7A,F
09140:  MOVLW  00
09142:  SUBWFB x7B,F
09144:  CLRF   x80
09146:  CLRF   x7F
09148:  MOVFF  57B,57E
0914C:  MOVFF  57A,57D
09150:  MOVLW  13
09152:  MOVWF  x81
09154:  MOVLB  0
09156:  CALL   5346
....................                 while ((run_flg_z)); 
0915A:  MOVLB  3
0915C:  BTFSC  xB8.2
0915E:  BRA    915C
....................                 motor_run_x(x[local]-42, 19); 
09160:  BCF    FD8.0
09162:  MOVLB  5
09164:  RLCF   x79,W
09166:  CLRF   03
09168:  ADDLW  30
0916A:  MOVWF  FE9
0916C:  MOVLW  00
0916E:  ADDWFC 03,W
09170:  MOVWF  FEA
09172:  MOVFF  FEC,57B
09176:  MOVF   FED,F
09178:  MOVFF  FEF,57A
0917C:  MOVLW  2A
0917E:  SUBWF  x7A,F
09180:  MOVLW  00
09182:  SUBWFB x7B,F
09184:  CLRF   x80
09186:  CLRF   x7F
09188:  MOVFF  57B,57E
0918C:  MOVFF  57A,57D
09190:  MOVLW  13
09192:  MOVWF  x81
09194:  MOVLB  0
09196:  CALL   5968
....................                 while ((run_flg_x)); 
0919A:  MOVLB  2
0919C:  BTFSC  x0C.5
0919E:  BRA    919C
....................                 motor_run_z(z[local], 19); 
091A0:  BCF    FD8.0
091A2:  MOVLB  5
091A4:  RLCF   x79,W
091A6:  CLRF   03
091A8:  ADDLW  84
091AA:  MOVWF  FE9
091AC:  MOVLW  00
091AE:  ADDWFC 03,W
091B0:  MOVWF  FEA
091B2:  MOVFF  FEC,57B
091B6:  MOVF   FED,F
091B8:  MOVFF  FEF,57A
091BC:  CLRF   x80
091BE:  CLRF   x7F
091C0:  MOVFF  57B,57E
091C4:  MOVFF  57A,57D
091C8:  MOVLW  13
091CA:  MOVWF  x81
091CC:  MOVLB  0
091CE:  CALL   5346
....................                 while ((run_flg_z)); 
091D2:  MOVLB  3
091D4:  BTFSC  xB8.2
091D6:  BRA    91D4
....................                 delay_ms(t_wait[local]); 
091D8:  BCF    FD8.0
091DA:  MOVLB  5
091DC:  RLCF   x79,W
091DE:  CLRF   03
091E0:  ADDLW  D8
091E2:  MOVWF  FE9
091E4:  MOVLW  00
091E6:  ADDWFC 03,W
091E8:  MOVWF  FEA
091EA:  MOVFF  FEC,57B
091EE:  MOVF   FED,F
091F0:  MOVFF  FEF,57A
091F4:  MOVFF  57B,57C
091F8:  INCF   x7C,F
091FA:  DECF   x7C,F
091FC:  BTFSC  FD8.2
091FE:  BRA    920C
09200:  SETF   x92
09202:  MOVLB  0
09204:  CALL   2958
09208:  MOVLB  5
0920A:  BRA    91FA
0920C:  MOVFF  57A,592
09210:  MOVLB  0
09212:  CALL   2958
....................                 motor_run_z(z[local]-5, 19); 
09216:  BCF    FD8.0
09218:  MOVLB  5
0921A:  RLCF   x79,W
0921C:  CLRF   03
0921E:  ADDLW  84
09220:  MOVWF  FE9
09222:  MOVLW  00
09224:  ADDWFC 03,W
09226:  MOVWF  FEA
09228:  MOVFF  FEC,57B
0922C:  MOVF   FED,F
0922E:  MOVFF  FEF,57A
09232:  MOVLW  05
09234:  SUBWF  x7A,F
09236:  MOVLW  00
09238:  SUBWFB x7B,F
0923A:  CLRF   x80
0923C:  CLRF   x7F
0923E:  MOVFF  57B,57E
09242:  MOVFF  57A,57D
09246:  MOVLW  13
09248:  MOVWF  x81
0924A:  MOVLB  0
0924C:  CALL   5346
....................                 while ((run_flg_z)); 
09250:  MOVLB  3
09252:  BTFSC  xB8.2
09254:  BRA    9252
....................                 motor_run_x(x[local]+40, 19); 
09256:  BCF    FD8.0
09258:  MOVLB  5
0925A:  RLCF   x79,W
0925C:  CLRF   03
0925E:  ADDLW  30
09260:  MOVWF  FE9
09262:  MOVLW  00
09264:  ADDWFC 03,W
09266:  MOVWF  FEA
09268:  MOVFF  FEC,57B
0926C:  MOVF   FED,F
0926E:  MOVFF  FEF,57A
09272:  MOVLW  28
09274:  ADDWF  x7A,F
09276:  MOVLW  00
09278:  ADDWFC x7B,F
0927A:  CLRF   x80
0927C:  CLRF   x7F
0927E:  MOVFF  57B,57E
09282:  MOVFF  57A,57D
09286:  MOVLW  13
09288:  MOVWF  x81
0928A:  MOVLB  0
0928C:  CALL   5968
....................                 while ((run_flg_x)); 
09290:  MOVLB  2
09292:  BTFSC  x0C.5
09294:  BRA    9292
....................                 motor_run_z(0, 19); 
09296:  MOVLB  5
09298:  CLRF   x80
0929A:  CLRF   x7F
0929C:  CLRF   x7E
0929E:  CLRF   x7D
092A0:  MOVLW  13
092A2:  MOVWF  x81
092A4:  MOVLB  0
092A6:  CALL   5346
....................                 while ((run_flg_z)); 
092AA:  MOVLB  3
092AC:  BTFSC  xB8.2
092AE:  BRA    92AC
....................                 desce_ferros(3); 
092B0:  MOVLW  03
092B2:  MOVLB  5
092B4:  MOVWF  x7D
092B6:  MOVLB  0
092B8:  CALL   783A
....................                 aciona_saida(LIMPA_BICO1); 
092BC:  MOVLB  5
092BE:  CLRF   x90
092C0:  MOVLW  08
092C2:  MOVWF  x8F
092C4:  MOVLB  0
092C6:  CALL   2E1E
....................                 aciona_saida(LIMPA_BICO2); 
092CA:  MOVLB  5
092CC:  CLRF   x90
092CE:  MOVLW  09
092D0:  MOVWF  x8F
092D2:  MOVLB  0
092D4:  CALL   2E1E
....................                 delay_ms(200); 
092D8:  MOVLW  C8
092DA:  MOVLB  5
092DC:  MOVWF  x92
092DE:  MOVLB  0
092E0:  CALL   2958
....................                 desaciona_saida(LIMPA_BICO1); 
092E4:  MOVLB  5
092E6:  CLRF   x90
092E8:  MOVLW  08
092EA:  MOVWF  x8F
092EC:  MOVLB  0
092EE:  CALL   2DDC
....................                 desaciona_saida(LIMPA_BICO2); 
092F2:  MOVLB  5
092F4:  CLRF   x90
092F6:  MOVLW  09
092F8:  MOVWF  x8F
092FA:  MOVLB  0
092FC:  CALL   2DDC
....................                 sobe_ferros(); 
09300:  CALL   781C
....................             break; 
....................         } 
....................     } 
09304:  BRA    934E
09306:  MOVLB  5
....................     else { 
....................         printf(lcd_putc, "\f"); //limpa display 
09308:  MOVLW  0C
0930A:  MOVWF  x86
0930C:  MOVLB  0
0930E:  CALL   2D32
....................         printf(lcd_putc, "  POSICAO IRREGULAR \n\r"); 
09312:  MOVLW  0C
09314:  MOVWF  FF6
09316:  MOVLW  0E
09318:  MOVWF  FF7
0931A:  CALL   2D86
....................         printf(lcd_putc, "   X DEVE SER > 0   \n\r"); 
0931E:  MOVLW  24
09320:  MOVWF  FF6
09322:  MOVLW  0E
09324:  MOVWF  FF7
09326:  CALL   2D86
....................         printf(lcd_putc, "  Y DEVE SER > 700  \n\r"); 
0932A:  MOVLW  3C
0932C:  MOVWF  FF6
0932E:  MOVLW  0E
09330:  MOVWF  FF7
09332:  CALL   2D86
....................         delay_ms(5000); 
09336:  MOVLW  14
09338:  MOVLB  5
0933A:  MOVWF  x7A
0933C:  MOVLW  FA
0933E:  MOVWF  x92
09340:  MOVLB  0
09342:  CALL   2958
09346:  MOVLB  5
09348:  DECFSZ x7A,F
0934A:  BRA    933C
0934C:  MOVLB  0
....................     } 
....................     sobe_ferros(); 
0934E:  CALL   781C
09352:  RETURN 0
.................... } //void soldar_teste(tipo[contador_lcd], contador_lcd) 
.................... void soldar(void){ 
....................     liga_pressor(); 
*
0C652:  CALL   788C
....................     for(int i=0; i < pontos_no_modelo+1; i++){ 
0C656:  MOVLB  5
0C658:  CLRF   x78
0C65A:  MOVLW  01
0C65C:  MOVLB  1
0C65E:  ADDWF  x2C,W
0C660:  MOVWF  01
0C662:  MOVLW  00
0C664:  ADDWFC x2D,W
0C666:  MOVWF  03
0C668:  MOVF   01,W
0C66A:  MOVF   03,F
0C66C:  BNZ   C67A
0C66E:  MOVF   01,W
0C670:  MOVLB  5
0C672:  SUBWF  x78,W
0C674:  BTFSC  FD8.0
0C676:  BRA    CE1A
0C678:  MOVLB  1
....................         if ((i == 14)&&(modelo == 1)){ 
0C67A:  MOVLB  5
0C67C:  MOVF   x78,W
0C67E:  SUBLW  0E
0C680:  BNZ   C688
0C682:  DECFSZ 2F,W
0C684:  BRA    C688
....................             i++; 
0C686:  INCF   x78,F
....................         } 
....................         if (habilitado[i] == TRUE) { 
0C688:  BCF    FD8.0
0C68A:  RLCF   x78,W
0C68C:  CLRF   03
0C68E:  ADDLW  2E
0C690:  MOVWF  FE9
0C692:  MOVLW  01
0C694:  ADDWFC 03,W
0C696:  MOVWF  FEA
0C698:  MOVFF  FEC,57A
0C69C:  MOVF   FED,F
0C69E:  MOVFF  FEF,579
0C6A2:  DECFSZ x79,W
0C6A4:  BRA    CE0E
0C6A6:  MOVF   x7A,F
0C6A8:  BTFSS  FD8.2
0C6AA:  BRA    CE0E
....................             switch (tipo[i]){ 
0C6AC:  BCF    FD8.0
0C6AE:  RLCF   x78,W
0C6B0:  CLRF   03
0C6B2:  ADDLW  02
0C6B4:  MOVWF  FE9
0C6B6:  MOVLW  01
0C6B8:  ADDWFC 03,W
0C6BA:  MOVWF  FEA
0C6BC:  MOVF   FEF,W
0C6BE:  MOVWF  00
0C6C0:  INCF   FE9,F
0C6C2:  MOVF   FEF,W
0C6C4:  DECF   FE9,F
0C6C6:  MOVWF  03
0C6C8:  MOVF   03,W
0C6CA:  BNZ   C6D4
0C6CC:  MOVF   00,F
0C6CE:  MOVLB  0
0C6D0:  BZ    C6E6
0C6D2:  MOVLB  5
0C6D4:  MOVF   03,W
0C6D6:  BNZ   C6E4
0C6D8:  MOVLW  01
0C6DA:  SUBWF  00,W
0C6DC:  MOVLB  0
0C6DE:  BTFSC  FD8.2
0C6E0:  BRA    C940
0C6E2:  MOVLB  5
0C6E4:  BRA    CE0E
....................                 case 0: 
....................                     motor_run_y(y[i], 19); 
0C6E6:  BCF    FD8.0
0C6E8:  MOVLB  5
0C6EA:  RLCF   x78,W
0C6EC:  CLRF   03
0C6EE:  ADDLW  5A
0C6F0:  MOVWF  FE9
0C6F2:  MOVLW  00
0C6F4:  ADDWFC 03,W
0C6F6:  MOVWF  FEA
0C6F8:  MOVFF  FEC,57A
0C6FC:  MOVF   FED,F
0C6FE:  MOVFF  FEF,579
0C702:  CLRF   x80
0C704:  CLRF   x7F
0C706:  MOVFF  57A,57E
0C70A:  MOVFF  579,57D
0C70E:  MOVLW  13
0C710:  MOVWF  x81
0C712:  MOVLB  0
0C714:  CALL   55A6
....................                     while ((run_flg_y)); 
0C718:  MOVLB  2
0C71A:  BTFSC  x0C.7
0C71C:  BRA    C71A
....................                     motor_run_x(x[i], 19); 
0C71E:  BCF    FD8.0
0C720:  MOVLB  5
0C722:  RLCF   x78,W
0C724:  CLRF   03
0C726:  ADDLW  30
0C728:  MOVWF  FE9
0C72A:  MOVLW  00
0C72C:  ADDWFC 03,W
0C72E:  MOVWF  FEA
0C730:  MOVFF  FEC,57A
0C734:  MOVF   FED,F
0C736:  MOVFF  FEF,579
0C73A:  CLRF   x80
0C73C:  CLRF   x7F
0C73E:  MOVFF  57A,57E
0C742:  MOVFF  579,57D
0C746:  MOVLW  13
0C748:  MOVWF  x81
0C74A:  MOVLB  0
0C74C:  CALL   5968
....................                     while ((run_flg_x)); 
0C750:  MOVLB  2
0C752:  BTFSC  x0C.5
0C754:  BRA    C752
....................                     desce_ferros(numeroFerros[i]); 
0C756:  BCF    FD8.0
0C758:  MOVLB  5
0C75A:  RLCF   x78,W
0C75C:  CLRF   03
0C75E:  ADDLW  58
0C760:  MOVWF  FE9
0C762:  MOVLW  01
0C764:  ADDWFC 03,W
0C766:  MOVWF  FEA
0C768:  MOVFF  FEC,57A
0C76C:  MOVF   FED,F
0C76E:  MOVFF  FEF,579
0C772:  MOVFF  579,57D
0C776:  MOVLB  0
0C778:  CALL   783A
....................                     ligar_alimentador_solda(numeroFerros[i],t_solda[i],t_solda2[i],t_solda3[i]); 
0C77C:  BCF    FD8.0
0C77E:  MOVLB  5
0C780:  RLCF   x78,W
0C782:  CLRF   03
0C784:  ADDLW  58
0C786:  MOVWF  FE9
0C788:  MOVLW  01
0C78A:  ADDWFC 03,W
0C78C:  MOVWF  FEA
0C78E:  MOVFF  FEC,57A
0C792:  MOVF   FED,F
0C794:  MOVFF  FEF,579
0C798:  BCF    FD8.0
0C79A:  RLCF   x78,W
0C79C:  CLRF   03
0C79E:  ADDLW  AE
0C7A0:  MOVWF  FE9
0C7A2:  MOVLW  00
0C7A4:  ADDWFC 03,W
0C7A6:  MOVWF  FEA
0C7A8:  MOVFF  FEC,57C
0C7AC:  MOVF   FED,F
0C7AE:  MOVFF  FEF,57B
0C7B2:  BCF    FD8.0
0C7B4:  RLCF   x78,W
0C7B6:  CLRF   03
0C7B8:  ADDLW  82
0C7BA:  MOVWF  FE9
0C7BC:  MOVLW  01
0C7BE:  ADDWFC 03,W
0C7C0:  MOVWF  FEA
0C7C2:  MOVFF  FEC,57E
0C7C6:  MOVF   FED,F
0C7C8:  MOVFF  FEF,57D
0C7CC:  BCF    FD8.0
0C7CE:  RLCF   x78,W
0C7D0:  CLRF   03
0C7D2:  ADDLW  AC
0C7D4:  MOVWF  FE9
0C7D6:  MOVLW  01
0C7D8:  ADDWFC 03,W
0C7DA:  MOVWF  FEA
0C7DC:  MOVFF  FEC,580
0C7E0:  MOVF   FED,F
0C7E2:  MOVFF  FEF,57F
0C7E6:  MOVFF  579,582
0C7EA:  MOVFF  57C,584
0C7EE:  MOVFF  57B,583
0C7F2:  MOVFF  57E,586
0C7F6:  MOVFF  57D,585
0C7FA:  MOVFF  580,588
0C7FE:  MOVFF  57F,587
0C802:  MOVLB  0
0C804:  CALL   82A2
....................                     motor_run_z(z[i], 19); 
0C808:  BCF    FD8.0
0C80A:  MOVLB  5
0C80C:  RLCF   x78,W
0C80E:  CLRF   03
0C810:  ADDLW  84
0C812:  MOVWF  FE9
0C814:  MOVLW  00
0C816:  ADDWFC 03,W
0C818:  MOVWF  FEA
0C81A:  MOVFF  FEC,57A
0C81E:  MOVF   FED,F
0C820:  MOVFF  FEF,579
0C824:  CLRF   x80
0C826:  CLRF   x7F
0C828:  MOVFF  57A,57E
0C82C:  MOVFF  579,57D
0C830:  MOVLW  13
0C832:  MOVWF  x81
0C834:  MOVLB  0
0C836:  CALL   5346
....................                     while ((run_flg_z)); 
0C83A:  MOVLB  3
0C83C:  BTFSC  xB8.2
0C83E:  BRA    C83C
....................                     delay_ms(t_wait[i]); 
0C840:  BCF    FD8.0
0C842:  MOVLB  5
0C844:  RLCF   x78,W
0C846:  CLRF   03
0C848:  ADDLW  D8
0C84A:  MOVWF  FE9
0C84C:  MOVLW  00
0C84E:  ADDWFC 03,W
0C850:  MOVWF  FEA
0C852:  MOVFF  FEC,57A
0C856:  MOVF   FED,F
0C858:  MOVFF  FEF,579
0C85C:  MOVFF  57A,57B
0C860:  INCF   x7B,F
0C862:  DECF   x7B,F
0C864:  BTFSC  FD8.2
0C866:  BRA    C874
0C868:  SETF   x92
0C86A:  MOVLB  0
0C86C:  CALL   2958
0C870:  MOVLB  5
0C872:  BRA    C862
0C874:  MOVFF  579,592
0C878:  MOVLB  0
0C87A:  CALL   2958
....................                     if (limpar[i] == 1){ 
0C87E:  BCF    FD8.0
0C880:  MOVLB  5
0C882:  RLCF   x78,W
0C884:  CLRF   03
0C886:  ADDLW  D6
0C888:  MOVWF  FE9
0C88A:  MOVLW  01
0C88C:  ADDWFC 03,W
0C88E:  MOVWF  FEA
0C890:  MOVFF  FEC,57A
0C894:  MOVF   FED,F
0C896:  MOVFF  FEF,579
0C89A:  DECFSZ x79,W
0C89C:  BRA    C91E
0C89E:  MOVF   x7A,F
0C8A0:  BNZ   C91E
....................                         motor_run_z(0, 19); 
0C8A2:  CLRF   x80
0C8A4:  CLRF   x7F
0C8A6:  CLRF   x7E
0C8A8:  CLRF   x7D
0C8AA:  MOVLW  13
0C8AC:  MOVWF  x81
0C8AE:  MOVLB  0
0C8B0:  CALL   5346
....................                         while ((run_flg_z)); 
0C8B4:  MOVLB  3
0C8B6:  BTFSC  xB8.2
0C8B8:  BRA    C8B6
....................                         desce_ferros(3); 
0C8BA:  MOVLW  03
0C8BC:  MOVLB  5
0C8BE:  MOVWF  x7D
0C8C0:  MOVLB  0
0C8C2:  CALL   783A
....................                         delay_ms(200); 
0C8C6:  MOVLW  C8
0C8C8:  MOVLB  5
0C8CA:  MOVWF  x92
0C8CC:  MOVLB  0
0C8CE:  CALL   2958
....................                         aciona_saida(LIMPA_BICO1); 
0C8D2:  MOVLB  5
0C8D4:  CLRF   x90
0C8D6:  MOVLW  08
0C8D8:  MOVWF  x8F
0C8DA:  MOVLB  0
0C8DC:  CALL   2E1E
....................                         aciona_saida(LIMPA_BICO2); 
0C8E0:  MOVLB  5
0C8E2:  CLRF   x90
0C8E4:  MOVLW  09
0C8E6:  MOVWF  x8F
0C8E8:  MOVLB  0
0C8EA:  CALL   2E1E
....................                         delay_ms(125); 
0C8EE:  MOVLW  7D
0C8F0:  MOVLB  5
0C8F2:  MOVWF  x92
0C8F4:  MOVLB  0
0C8F6:  CALL   2958
....................                         desaciona_saida(LIMPA_BICO1); 
0C8FA:  MOVLB  5
0C8FC:  CLRF   x90
0C8FE:  MOVLW  08
0C900:  MOVWF  x8F
0C902:  MOVLB  0
0C904:  CALL   2DDC
....................                         desaciona_saida(LIMPA_BICO2); 
0C908:  MOVLB  5
0C90A:  CLRF   x90
0C90C:  MOVLW  09
0C90E:  MOVWF  x8F
0C910:  MOVLB  0
0C912:  CALL   2DDC
....................                         sobe_ferros(); 
0C916:  CALL   781C
....................                     } else { 
0C91A:  BRA    C93C
0C91C:  MOVLB  5
....................                         motor_run_z(270, 19); 
0C91E:  CLRF   x80
0C920:  CLRF   x7F
0C922:  MOVLW  01
0C924:  MOVWF  x7E
0C926:  MOVLW  0E
0C928:  MOVWF  x7D
0C92A:  MOVLW  13
0C92C:  MOVWF  x81
0C92E:  MOVLB  0
0C930:  CALL   5346
....................                         while ((run_flg_z)); 
0C934:  MOVLB  3
0C936:  BTFSC  xB8.2
0C938:  BRA    C936
0C93A:  MOVLB  0
....................                     }                   
....................                 break; 
0C93C:  MOVLB  5
0C93E:  BRA    CE0E
....................                 case 1:                     
....................                     motor_run_y(y[i], 19); 
0C940:  BCF    FD8.0
0C942:  MOVLB  5
0C944:  RLCF   x78,W
0C946:  CLRF   03
0C948:  ADDLW  5A
0C94A:  MOVWF  FE9
0C94C:  MOVLW  00
0C94E:  ADDWFC 03,W
0C950:  MOVWF  FEA
0C952:  MOVFF  FEC,57A
0C956:  MOVF   FED,F
0C958:  MOVFF  FEF,579
0C95C:  CLRF   x80
0C95E:  CLRF   x7F
0C960:  MOVFF  57A,57E
0C964:  MOVFF  579,57D
0C968:  MOVLW  13
0C96A:  MOVWF  x81
0C96C:  MOVLB  0
0C96E:  CALL   55A6
....................                     while ((run_flg_y)); 
0C972:  MOVLB  2
0C974:  BTFSC  x0C.7
0C976:  BRA    C974
....................                     motor_run_x(x[i], 19); 
0C978:  BCF    FD8.0
0C97A:  MOVLB  5
0C97C:  RLCF   x78,W
0C97E:  CLRF   03
0C980:  ADDLW  30
0C982:  MOVWF  FE9
0C984:  MOVLW  00
0C986:  ADDWFC 03,W
0C988:  MOVWF  FEA
0C98A:  MOVFF  FEC,57A
0C98E:  MOVF   FED,F
0C990:  MOVFF  FEF,579
0C994:  CLRF   x80
0C996:  CLRF   x7F
0C998:  MOVFF  57A,57E
0C99C:  MOVFF  579,57D
0C9A0:  MOVLW  13
0C9A2:  MOVWF  x81
0C9A4:  MOVLB  0
0C9A6:  CALL   5968
....................                     while ((run_flg_x)); 
0C9AA:  MOVLB  2
0C9AC:  BTFSC  x0C.5
0C9AE:  BRA    C9AC
....................                     desce_ferros(numeroFerros[i]); 
0C9B0:  BCF    FD8.0
0C9B2:  MOVLB  5
0C9B4:  RLCF   x78,W
0C9B6:  CLRF   03
0C9B8:  ADDLW  58
0C9BA:  MOVWF  FE9
0C9BC:  MOVLW  01
0C9BE:  ADDWFC 03,W
0C9C0:  MOVWF  FEA
0C9C2:  MOVFF  FEC,57A
0C9C6:  MOVF   FED,F
0C9C8:  MOVFF  FEF,579
0C9CC:  MOVFF  579,57D
0C9D0:  MOVLB  0
0C9D2:  CALL   783A
....................                     ligar_alimentador_solda(numeroFerros[i],t_solda[i],t_solda2[i],t_solda3[i]); 
0C9D6:  BCF    FD8.0
0C9D8:  MOVLB  5
0C9DA:  RLCF   x78,W
0C9DC:  CLRF   03
0C9DE:  ADDLW  58
0C9E0:  MOVWF  FE9
0C9E2:  MOVLW  01
0C9E4:  ADDWFC 03,W
0C9E6:  MOVWF  FEA
0C9E8:  MOVFF  FEC,57A
0C9EC:  MOVF   FED,F
0C9EE:  MOVFF  FEF,579
0C9F2:  BCF    FD8.0
0C9F4:  RLCF   x78,W
0C9F6:  CLRF   03
0C9F8:  ADDLW  AE
0C9FA:  MOVWF  FE9
0C9FC:  MOVLW  00
0C9FE:  ADDWFC 03,W
0CA00:  MOVWF  FEA
0CA02:  MOVFF  FEC,57C
0CA06:  MOVF   FED,F
0CA08:  MOVFF  FEF,57B
0CA0C:  BCF    FD8.0
0CA0E:  RLCF   x78,W
0CA10:  CLRF   03
0CA12:  ADDLW  82
0CA14:  MOVWF  FE9
0CA16:  MOVLW  01
0CA18:  ADDWFC 03,W
0CA1A:  MOVWF  FEA
0CA1C:  MOVFF  FEC,57E
0CA20:  MOVF   FED,F
0CA22:  MOVFF  FEF,57D
0CA26:  BCF    FD8.0
0CA28:  RLCF   x78,W
0CA2A:  CLRF   03
0CA2C:  ADDLW  AC
0CA2E:  MOVWF  FE9
0CA30:  MOVLW  01
0CA32:  ADDWFC 03,W
0CA34:  MOVWF  FEA
0CA36:  MOVFF  FEC,580
0CA3A:  MOVF   FED,F
0CA3C:  MOVFF  FEF,57F
0CA40:  MOVFF  579,582
0CA44:  MOVFF  57C,584
0CA48:  MOVFF  57B,583
0CA4C:  MOVFF  57E,586
0CA50:  MOVFF  57D,585
0CA54:  MOVFF  580,588
0CA58:  MOVFF  57F,587
0CA5C:  MOVLB  0
0CA5E:  CALL   82A2
....................                     motor_run_z(z[i], 19); 
0CA62:  BCF    FD8.0
0CA64:  MOVLB  5
0CA66:  RLCF   x78,W
0CA68:  CLRF   03
0CA6A:  ADDLW  84
0CA6C:  MOVWF  FE9
0CA6E:  MOVLW  00
0CA70:  ADDWFC 03,W
0CA72:  MOVWF  FEA
0CA74:  MOVFF  FEC,57A
0CA78:  MOVF   FED,F
0CA7A:  MOVFF  FEF,579
0CA7E:  CLRF   x80
0CA80:  CLRF   x7F
0CA82:  MOVFF  57A,57E
0CA86:  MOVFF  579,57D
0CA8A:  MOVLW  13
0CA8C:  MOVWF  x81
0CA8E:  MOVLB  0
0CA90:  CALL   5346
....................                     while ((run_flg_z)); 
0CA94:  MOVLB  3
0CA96:  BTFSC  xB8.2
0CA98:  BRA    CA96
....................                     delay_ms(t_wait[i]); 
0CA9A:  BCF    FD8.0
0CA9C:  MOVLB  5
0CA9E:  RLCF   x78,W
0CAA0:  CLRF   03
0CAA2:  ADDLW  D8
0CAA4:  MOVWF  FE9
0CAA6:  MOVLW  00
0CAA8:  ADDWFC 03,W
0CAAA:  MOVWF  FEA
0CAAC:  MOVFF  FEC,57A
0CAB0:  MOVF   FED,F
0CAB2:  MOVFF  FEF,579
0CAB6:  MOVFF  57A,57B
0CABA:  INCF   x7B,F
0CABC:  DECF   x7B,F
0CABE:  BTFSC  FD8.2
0CAC0:  BRA    CACE
0CAC2:  SETF   x92
0CAC4:  MOVLB  0
0CAC6:  CALL   2958
0CACA:  MOVLB  5
0CACC:  BRA    CABC
0CACE:  MOVFF  579,592
0CAD2:  MOVLB  0
0CAD4:  CALL   2958
....................                     motor_run_z(z[i]-8, 19); 
0CAD8:  BCF    FD8.0
0CADA:  MOVLB  5
0CADC:  RLCF   x78,W
0CADE:  CLRF   03
0CAE0:  ADDLW  84
0CAE2:  MOVWF  FE9
0CAE4:  MOVLW  00
0CAE6:  ADDWFC 03,W
0CAE8:  MOVWF  FEA
0CAEA:  MOVFF  FEC,57A
0CAEE:  MOVF   FED,F
0CAF0:  MOVFF  FEF,579
0CAF4:  MOVLW  08
0CAF6:  SUBWF  x79,F
0CAF8:  MOVLW  00
0CAFA:  SUBWFB x7A,F
0CAFC:  CLRF   x80
0CAFE:  CLRF   x7F
0CB00:  MOVFF  57A,57E
0CB04:  MOVFF  579,57D
0CB08:  MOVLW  13
0CB0A:  MOVWF  x81
0CB0C:  MOVLB  0
0CB0E:  CALL   5346
....................                     while ((run_flg_z)); 
0CB12:  MOVLB  3
0CB14:  BTFSC  xB8.2
0CB16:  BRA    CB14
....................                     motor_run_x(x[i]-21, 19); 
0CB18:  BCF    FD8.0
0CB1A:  MOVLB  5
0CB1C:  RLCF   x78,W
0CB1E:  CLRF   03
0CB20:  ADDLW  30
0CB22:  MOVWF  FE9
0CB24:  MOVLW  00
0CB26:  ADDWFC 03,W
0CB28:  MOVWF  FEA
0CB2A:  MOVFF  FEC,57A
0CB2E:  MOVF   FED,F
0CB30:  MOVFF  FEF,579
0CB34:  MOVLW  15
0CB36:  SUBWF  x79,F
0CB38:  MOVLW  00
0CB3A:  SUBWFB x7A,F
0CB3C:  CLRF   x80
0CB3E:  CLRF   x7F
0CB40:  MOVFF  57A,57E
0CB44:  MOVFF  579,57D
0CB48:  MOVLW  13
0CB4A:  MOVWF  x81
0CB4C:  MOVLB  0
0CB4E:  CALL   5968
....................                     while ((run_flg_x)); 
0CB52:  MOVLB  2
0CB54:  BTFSC  x0C.5
0CB56:  BRA    CB54
....................                     motor_run_z(z[i], 19); 
0CB58:  BCF    FD8.0
0CB5A:  MOVLB  5
0CB5C:  RLCF   x78,W
0CB5E:  CLRF   03
0CB60:  ADDLW  84
0CB62:  MOVWF  FE9
0CB64:  MOVLW  00
0CB66:  ADDWFC 03,W
0CB68:  MOVWF  FEA
0CB6A:  MOVFF  FEC,57A
0CB6E:  MOVF   FED,F
0CB70:  MOVFF  FEF,579
0CB74:  CLRF   x80
0CB76:  CLRF   x7F
0CB78:  MOVFF  57A,57E
0CB7C:  MOVFF  579,57D
0CB80:  MOVLW  13
0CB82:  MOVWF  x81
0CB84:  MOVLB  0
0CB86:  CALL   5346
....................                     while ((run_flg_z)); 
0CB8A:  MOVLB  3
0CB8C:  BTFSC  xB8.2
0CB8E:  BRA    CB8C
....................                     delay_ms(t_wait[i]);   
0CB90:  BCF    FD8.0
0CB92:  MOVLB  5
0CB94:  RLCF   x78,W
0CB96:  CLRF   03
0CB98:  ADDLW  D8
0CB9A:  MOVWF  FE9
0CB9C:  MOVLW  00
0CB9E:  ADDWFC 03,W
0CBA0:  MOVWF  FEA
0CBA2:  MOVFF  FEC,57A
0CBA6:  MOVF   FED,F
0CBA8:  MOVFF  FEF,579
0CBAC:  MOVFF  57A,57B
0CBB0:  INCF   x7B,F
0CBB2:  DECF   x7B,F
0CBB4:  BTFSC  FD8.2
0CBB6:  BRA    CBC4
0CBB8:  SETF   x92
0CBBA:  MOVLB  0
0CBBC:  CALL   2958
0CBC0:  MOVLB  5
0CBC2:  BRA    CBB2
0CBC4:  MOVFF  579,592
0CBC8:  MOVLB  0
0CBCA:  CALL   2958
....................                     motor_run_z(z[i]-8, 19); 
0CBCE:  BCF    FD8.0
0CBD0:  MOVLB  5
0CBD2:  RLCF   x78,W
0CBD4:  CLRF   03
0CBD6:  ADDLW  84
0CBD8:  MOVWF  FE9
0CBDA:  MOVLW  00
0CBDC:  ADDWFC 03,W
0CBDE:  MOVWF  FEA
0CBE0:  MOVFF  FEC,57A
0CBE4:  MOVF   FED,F
0CBE6:  MOVFF  FEF,579
0CBEA:  MOVLW  08
0CBEC:  SUBWF  x79,F
0CBEE:  MOVLW  00
0CBF0:  SUBWFB x7A,F
0CBF2:  CLRF   x80
0CBF4:  CLRF   x7F
0CBF6:  MOVFF  57A,57E
0CBFA:  MOVFF  579,57D
0CBFE:  MOVLW  13
0CC00:  MOVWF  x81
0CC02:  MOVLB  0
0CC04:  CALL   5346
....................                     while ((run_flg_z)); 
0CC08:  MOVLB  3
0CC0A:  BTFSC  xB8.2
0CC0C:  BRA    CC0A
....................                     motor_run_x(x[i]-42, 19); 
0CC0E:  BCF    FD8.0
0CC10:  MOVLB  5
0CC12:  RLCF   x78,W
0CC14:  CLRF   03
0CC16:  ADDLW  30
0CC18:  MOVWF  FE9
0CC1A:  MOVLW  00
0CC1C:  ADDWFC 03,W
0CC1E:  MOVWF  FEA
0CC20:  MOVFF  FEC,57A
0CC24:  MOVF   FED,F
0CC26:  MOVFF  FEF,579
0CC2A:  MOVLW  2A
0CC2C:  SUBWF  x79,F
0CC2E:  MOVLW  00
0CC30:  SUBWFB x7A,F
0CC32:  CLRF   x80
0CC34:  CLRF   x7F
0CC36:  MOVFF  57A,57E
0CC3A:  MOVFF  579,57D
0CC3E:  MOVLW  13
0CC40:  MOVWF  x81
0CC42:  MOVLB  0
0CC44:  CALL   5968
....................                     while ((run_flg_x)); 
0CC48:  MOVLB  2
0CC4A:  BTFSC  x0C.5
0CC4C:  BRA    CC4A
....................                     motor_run_z(z[i], 19); 
0CC4E:  BCF    FD8.0
0CC50:  MOVLB  5
0CC52:  RLCF   x78,W
0CC54:  CLRF   03
0CC56:  ADDLW  84
0CC58:  MOVWF  FE9
0CC5A:  MOVLW  00
0CC5C:  ADDWFC 03,W
0CC5E:  MOVWF  FEA
0CC60:  MOVFF  FEC,57A
0CC64:  MOVF   FED,F
0CC66:  MOVFF  FEF,579
0CC6A:  CLRF   x80
0CC6C:  CLRF   x7F
0CC6E:  MOVFF  57A,57E
0CC72:  MOVFF  579,57D
0CC76:  MOVLW  13
0CC78:  MOVWF  x81
0CC7A:  MOVLB  0
0CC7C:  CALL   5346
....................                     while ((run_flg_z)); 
0CC80:  MOVLB  3
0CC82:  BTFSC  xB8.2
0CC84:  BRA    CC82
....................                     delay_ms(t_wait[i]); 
0CC86:  BCF    FD8.0
0CC88:  MOVLB  5
0CC8A:  RLCF   x78,W
0CC8C:  CLRF   03
0CC8E:  ADDLW  D8
0CC90:  MOVWF  FE9
0CC92:  MOVLW  00
0CC94:  ADDWFC 03,W
0CC96:  MOVWF  FEA
0CC98:  MOVFF  FEC,57A
0CC9C:  MOVF   FED,F
0CC9E:  MOVFF  FEF,579
0CCA2:  MOVFF  57A,57B
0CCA6:  INCF   x7B,F
0CCA8:  DECF   x7B,F
0CCAA:  BTFSC  FD8.2
0CCAC:  BRA    CCBA
0CCAE:  SETF   x92
0CCB0:  MOVLB  0
0CCB2:  CALL   2958
0CCB6:  MOVLB  5
0CCB8:  BRA    CCA8
0CCBA:  MOVFF  579,592
0CCBE:  MOVLB  0
0CCC0:  CALL   2958
....................                     motor_run_z(z[i]-8, 19); 
0CCC4:  BCF    FD8.0
0CCC6:  MOVLB  5
0CCC8:  RLCF   x78,W
0CCCA:  CLRF   03
0CCCC:  ADDLW  84
0CCCE:  MOVWF  FE9
0CCD0:  MOVLW  00
0CCD2:  ADDWFC 03,W
0CCD4:  MOVWF  FEA
0CCD6:  MOVFF  FEC,57A
0CCDA:  MOVF   FED,F
0CCDC:  MOVFF  FEF,579
0CCE0:  MOVLW  08
0CCE2:  SUBWF  x79,F
0CCE4:  MOVLW  00
0CCE6:  SUBWFB x7A,F
0CCE8:  CLRF   x80
0CCEA:  CLRF   x7F
0CCEC:  MOVFF  57A,57E
0CCF0:  MOVFF  579,57D
0CCF4:  MOVLW  13
0CCF6:  MOVWF  x81
0CCF8:  MOVLB  0
0CCFA:  CALL   5346
....................                     while ((run_flg_y)); 
0CCFE:  MOVLB  2
0CD00:  BTFSC  x0C.7
0CD02:  BRA    CD00
....................                     motor_run_x(x[i]+55, 19); 
0CD04:  BCF    FD8.0
0CD06:  MOVLB  5
0CD08:  RLCF   x78,W
0CD0A:  CLRF   03
0CD0C:  ADDLW  30
0CD0E:  MOVWF  FE9
0CD10:  MOVLW  00
0CD12:  ADDWFC 03,W
0CD14:  MOVWF  FEA
0CD16:  MOVFF  FEC,57A
0CD1A:  MOVF   FED,F
0CD1C:  MOVFF  FEF,579
0CD20:  MOVLW  37
0CD22:  ADDWF  x79,F
0CD24:  MOVLW  00
0CD26:  ADDWFC x7A,F
0CD28:  CLRF   x80
0CD2A:  CLRF   x7F
0CD2C:  MOVFF  57A,57E
0CD30:  MOVFF  579,57D
0CD34:  MOVLW  13
0CD36:  MOVWF  x81
0CD38:  MOVLB  0
0CD3A:  CALL   5968
....................                     while ((run_flg_x || run_flg_z)); 
0CD3E:  MOVLB  2
0CD40:  BTFSC  x0C.5
0CD42:  BRA    CD40
0CD44:  MOVLB  3
0CD46:  BTFSS  xB8.2
0CD48:  BRA    CD4E
0CD4A:  MOVLB  0
0CD4C:  BRA    CD3E
....................                     if (limpar[i] == 1){ 
0CD4E:  BCF    FD8.0
0CD50:  MOVLB  5
0CD52:  RLCF   x78,W
0CD54:  CLRF   03
0CD56:  ADDLW  D6
0CD58:  MOVWF  FE9
0CD5A:  MOVLW  01
0CD5C:  ADDWFC 03,W
0CD5E:  MOVWF  FEA
0CD60:  MOVFF  FEC,57A
0CD64:  MOVF   FED,F
0CD66:  MOVFF  FEF,579
0CD6A:  DECFSZ x79,W
0CD6C:  BRA    CDEE
0CD6E:  MOVF   x7A,F
0CD70:  BNZ   CDEE
....................                         motor_run_z(0, 19); 
0CD72:  CLRF   x80
0CD74:  CLRF   x7F
0CD76:  CLRF   x7E
0CD78:  CLRF   x7D
0CD7A:  MOVLW  13
0CD7C:  MOVWF  x81
0CD7E:  MOVLB  0
0CD80:  CALL   5346
....................                         while ((run_flg_z)); 
0CD84:  MOVLB  3
0CD86:  BTFSC  xB8.2
0CD88:  BRA    CD86
....................                         desce_ferros(3); 
0CD8A:  MOVLW  03
0CD8C:  MOVLB  5
0CD8E:  MOVWF  x7D
0CD90:  MOVLB  0
0CD92:  CALL   783A
....................                         delay_ms(200); 
0CD96:  MOVLW  C8
0CD98:  MOVLB  5
0CD9A:  MOVWF  x92
0CD9C:  MOVLB  0
0CD9E:  CALL   2958
....................                         aciona_saida(LIMPA_BICO1); 
0CDA2:  MOVLB  5
0CDA4:  CLRF   x90
0CDA6:  MOVLW  08
0CDA8:  MOVWF  x8F
0CDAA:  MOVLB  0
0CDAC:  CALL   2E1E
....................                         aciona_saida(LIMPA_BICO2); 
0CDB0:  MOVLB  5
0CDB2:  CLRF   x90
0CDB4:  MOVLW  09
0CDB6:  MOVWF  x8F
0CDB8:  MOVLB  0
0CDBA:  CALL   2E1E
....................                         delay_ms(125); 
0CDBE:  MOVLW  7D
0CDC0:  MOVLB  5
0CDC2:  MOVWF  x92
0CDC4:  MOVLB  0
0CDC6:  CALL   2958
....................                         desaciona_saida(LIMPA_BICO1); 
0CDCA:  MOVLB  5
0CDCC:  CLRF   x90
0CDCE:  MOVLW  08
0CDD0:  MOVWF  x8F
0CDD2:  MOVLB  0
0CDD4:  CALL   2DDC
....................                         desaciona_saida(LIMPA_BICO2); 
0CDD8:  MOVLB  5
0CDDA:  CLRF   x90
0CDDC:  MOVLW  09
0CDDE:  MOVWF  x8F
0CDE0:  MOVLB  0
0CDE2:  CALL   2DDC
....................                         sobe_ferros(); 
0CDE6:  CALL   781C
....................                     } else { 
0CDEA:  BRA    CE0C
0CDEC:  MOVLB  5
....................                         motor_run_z(270, 19); 
0CDEE:  CLRF   x80
0CDF0:  CLRF   x7F
0CDF2:  MOVLW  01
0CDF4:  MOVWF  x7E
0CDF6:  MOVLW  0E
0CDF8:  MOVWF  x7D
0CDFA:  MOVLW  13
0CDFC:  MOVWF  x81
0CDFE:  MOVLB  0
0CE00:  CALL   5346
....................                         while ((run_flg_z)); 
0CE04:  MOVLB  3
0CE06:  BTFSC  xB8.2
0CE08:  BRA    CE06
0CE0A:  MOVLB  0
....................                     }             
....................                 break; 
0CE0C:  MOVLB  5
....................             } 
....................         } 
....................         sobe_ferros(); 
0CE0E:  MOVLB  0
0CE10:  CALL   781C
0CE14:  MOVLB  5
0CE16:  INCF   x78,F
0CE18:  BRA    C65A
....................     } 
0CE1A:  MOVLB  0
0CE1C:  GOTO   D1D4 (RETURN)
.................... } 
....................  
.................... #include "Modelos_maq_2.c" 
.................... long int tamPrograma = 358; 
....................  
.................... void ler_modelo_memoria(long int modeloSelecionado){ 
*
067C8:  MOVLB  5
067CA:  CLRF   x78
067CC:  CLRF   x77
067CE:  CLRF   x7A
067D0:  CLRF   x79
067D2:  MOVLW  01
067D4:  SUBWF  x75,W
067D6:  MOVWF  x7F
067D8:  MOVLW  00
067DA:  SUBWFB x76,W
067DC:  MOVWF  x80
067DE:  MOVWF  x82
067E0:  MOVFF  57F,581
067E4:  MOVFF  574,584
067E8:  MOVFF  573,583
067EC:  MOVLB  0
067EE:  RCALL  67A6
067F0:  MOVFF  02,57C
067F4:  MOVFF  01,57B
....................     long int i = 0; 
....................     long int j = 0; 
....................     long int endInicial = (modeloSelecionado - 1)* tamPrograma; 
....................     pontos_no_modelo = read_ext_eeprom(endInicial); 
067F8:  MOVFF  57C,586
067FC:  MOVFF  57B,585
06800:  CALL   2C20
06804:  MOVFF  02,12D
06808:  MOVFF  01,12C
....................     endInicial++; 
0680C:  MOVLB  5
0680E:  INCF   x7B,F
06810:  BTFSC  FD8.2
06812:  INCF   x7C,F
....................     for(i = endInicial; i < (endInicial + tamPrograma) -1; i = i + 17) 
06814:  MOVFF  57C,578
06818:  MOVFF  57B,577
0681C:  MOVF   x73,W
0681E:  ADDWF  x7B,W
06820:  MOVWF  x7F
06822:  MOVF   x74,W
06824:  ADDWFC x7C,W
06826:  MOVWF  x80
06828:  MOVLW  01
0682A:  SUBWF  x7F,W
0682C:  MOVWF  00
0682E:  MOVLW  00
06830:  SUBWFB x80,W
06832:  MOVWF  03
06834:  MOVFF  00,01
06838:  MOVF   x78,W
0683A:  SUBWF  03,W
0683C:  BTFSS  FD8.0
0683E:  BRA    6C42
06840:  BNZ   684A
06842:  MOVF   01,W
06844:  SUBWF  x77,W
06846:  BTFSC  FD8.0
06848:  BRA    6C42
....................     { 
....................         if (i != 248){ 
0684A:  MOVF   x77,W
0684C:  SUBLW  F8
0684E:  BNZ   6856
06850:  MOVF   x78,F
06852:  BTFSC  FD8.2
06854:  BRA    6C38
....................             x[j] = make16(read_ext_eeprom(i),read_ext_eeprom(i+1)); 
06856:  BCF    FD8.0
06858:  RLCF   x79,W
0685A:  MOVWF  02
0685C:  RLCF   x7A,W
0685E:  MOVWF  03
06860:  MOVF   02,W
06862:  ADDLW  30
06864:  MOVWF  01
06866:  MOVLW  00
06868:  ADDWFC 03,F
0686A:  MOVFF  01,57F
0686E:  MOVFF  03,580
06872:  MOVFF  578,586
06876:  MOVFF  577,585
0687A:  MOVLB  0
0687C:  CALL   2C20
06880:  MOVFF  02,582
06884:  MOVFF  01,581
06888:  MOVLW  01
0688A:  MOVLB  5
0688C:  ADDWF  x77,W
0688E:  MOVWF  x83
06890:  MOVLW  00
06892:  ADDWFC x78,W
06894:  MOVWF  x84
06896:  MOVWF  x86
06898:  MOVFF  583,585
0689C:  MOVLB  0
0689E:  CALL   2C20
068A2:  MOVFF  580,FEA
068A6:  MOVFF  57F,FE9
068AA:  MOVFF  581,FEC
068AE:  MOVF   FED,F
068B0:  MOVFF  01,FEF
....................             y[j] = make16(read_ext_eeprom(i+2),read_ext_eeprom(i+3)); 
068B4:  BCF    FD8.0
068B6:  MOVLB  5
068B8:  RLCF   x79,W
068BA:  MOVWF  02
068BC:  RLCF   x7A,W
068BE:  MOVWF  03
068C0:  MOVF   02,W
068C2:  ADDLW  5A
068C4:  MOVWF  01
068C6:  MOVLW  00
068C8:  ADDWFC 03,F
068CA:  MOVFF  01,57F
068CE:  MOVFF  03,580
068D2:  MOVLW  02
068D4:  ADDWF  x77,W
068D6:  MOVWF  x81
068D8:  MOVLW  00
068DA:  ADDWFC x78,W
068DC:  MOVWF  x82
068DE:  MOVWF  x86
068E0:  MOVFF  581,585
068E4:  MOVLB  0
068E6:  CALL   2C20
068EA:  MOVFF  02,582
068EE:  MOVFF  01,581
068F2:  MOVLW  03
068F4:  MOVLB  5
068F6:  ADDWF  x77,W
068F8:  MOVWF  x83
068FA:  MOVLW  00
068FC:  ADDWFC x78,W
068FE:  MOVWF  x84
06900:  MOVWF  x86
06902:  MOVFF  583,585
06906:  MOVLB  0
06908:  CALL   2C20
0690C:  MOVFF  580,FEA
06910:  MOVFF  57F,FE9
06914:  MOVFF  581,FEC
06918:  MOVF   FED,F
0691A:  MOVFF  01,FEF
....................             z[j] = make16(read_ext_eeprom(i+4),read_ext_eeprom(i+5)); 
0691E:  BCF    FD8.0
06920:  MOVLB  5
06922:  RLCF   x79,W
06924:  MOVWF  02
06926:  RLCF   x7A,W
06928:  MOVWF  03
0692A:  MOVF   02,W
0692C:  ADDLW  84
0692E:  MOVWF  01
06930:  MOVLW  00
06932:  ADDWFC 03,F
06934:  MOVFF  01,57F
06938:  MOVFF  03,580
0693C:  MOVLW  04
0693E:  ADDWF  x77,W
06940:  MOVWF  x81
06942:  MOVLW  00
06944:  ADDWFC x78,W
06946:  MOVWF  x82
06948:  MOVWF  x86
0694A:  MOVFF  581,585
0694E:  MOVLB  0
06950:  CALL   2C20
06954:  MOVFF  02,582
06958:  MOVFF  01,581
0695C:  MOVLW  05
0695E:  MOVLB  5
06960:  ADDWF  x77,W
06962:  MOVWF  x83
06964:  MOVLW  00
06966:  ADDWFC x78,W
06968:  MOVWF  x84
0696A:  MOVWF  x86
0696C:  MOVFF  583,585
06970:  MOVLB  0
06972:  CALL   2C20
06976:  MOVFF  580,FEA
0697A:  MOVFF  57F,FE9
0697E:  MOVFF  581,FEC
06982:  MOVF   FED,F
06984:  MOVFF  01,FEF
....................             t_solda[j] = make16(read_ext_eeprom(i+6),read_ext_eeprom(i+7)); 
06988:  BCF    FD8.0
0698A:  MOVLB  5
0698C:  RLCF   x79,W
0698E:  MOVWF  02
06990:  RLCF   x7A,W
06992:  MOVWF  03
06994:  MOVF   02,W
06996:  ADDLW  AE
06998:  MOVWF  01
0699A:  MOVLW  00
0699C:  ADDWFC 03,F
0699E:  MOVFF  01,57F
069A2:  MOVFF  03,580
069A6:  MOVLW  06
069A8:  ADDWF  x77,W
069AA:  MOVWF  x81
069AC:  MOVLW  00
069AE:  ADDWFC x78,W
069B0:  MOVWF  x82
069B2:  MOVWF  x86
069B4:  MOVFF  581,585
069B8:  MOVLB  0
069BA:  CALL   2C20
069BE:  MOVFF  02,582
069C2:  MOVFF  01,581
069C6:  MOVLW  07
069C8:  MOVLB  5
069CA:  ADDWF  x77,W
069CC:  MOVWF  x83
069CE:  MOVLW  00
069D0:  ADDWFC x78,W
069D2:  MOVWF  x84
069D4:  MOVWF  x86
069D6:  MOVFF  583,585
069DA:  MOVLB  0
069DC:  CALL   2C20
069E0:  MOVFF  580,FEA
069E4:  MOVFF  57F,FE9
069E8:  MOVFF  581,FEC
069EC:  MOVF   FED,F
069EE:  MOVFF  01,FEF
....................             t_wait[j] = make16(read_ext_eeprom(i+8),read_ext_eeprom(i+9)); 
069F2:  BCF    FD8.0
069F4:  MOVLB  5
069F6:  RLCF   x79,W
069F8:  MOVWF  02
069FA:  RLCF   x7A,W
069FC:  MOVWF  03
069FE:  MOVF   02,W
06A00:  ADDLW  D8
06A02:  MOVWF  01
06A04:  MOVLW  00
06A06:  ADDWFC 03,F
06A08:  MOVFF  01,57F
06A0C:  MOVFF  03,580
06A10:  MOVLW  08
06A12:  ADDWF  x77,W
06A14:  MOVWF  x81
06A16:  MOVLW  00
06A18:  ADDWFC x78,W
06A1A:  MOVWF  x82
06A1C:  MOVWF  x86
06A1E:  MOVFF  581,585
06A22:  MOVLB  0
06A24:  CALL   2C20
06A28:  MOVFF  02,582
06A2C:  MOVFF  01,581
06A30:  MOVLW  09
06A32:  MOVLB  5
06A34:  ADDWF  x77,W
06A36:  MOVWF  x83
06A38:  MOVLW  00
06A3A:  ADDWFC x78,W
06A3C:  MOVWF  x84
06A3E:  MOVWF  x86
06A40:  MOVFF  583,585
06A44:  MOVLB  0
06A46:  CALL   2C20
06A4A:  MOVFF  580,FEA
06A4E:  MOVFF  57F,FE9
06A52:  MOVFF  581,FEC
06A56:  MOVF   FED,F
06A58:  MOVFF  01,FEF
....................             long int tipoHabilitado = read_ext_eeprom(i+10); 
06A5C:  MOVLW  0A
06A5E:  MOVLB  5
06A60:  ADDWF  x77,W
06A62:  MOVWF  x7F
06A64:  MOVLW  00
06A66:  ADDWFC x78,W
06A68:  MOVWF  x80
06A6A:  MOVWF  x86
06A6C:  MOVFF  57F,585
06A70:  MOVLB  0
06A72:  CALL   2C20
06A76:  MOVFF  02,57E
06A7A:  MOVFF  01,57D
....................             tipo[j] = (tipoHabilitado & 0x06)>>1; 
06A7E:  BCF    FD8.0
06A80:  MOVLB  5
06A82:  RLCF   x79,W
06A84:  MOVWF  02
06A86:  RLCF   x7A,W
06A88:  MOVWF  03
06A8A:  MOVF   02,W
06A8C:  ADDLW  02
06A8E:  MOVWF  FE9
06A90:  MOVLW  01
06A92:  ADDWFC 03,W
06A94:  MOVWF  FEA
06A96:  MOVF   x7D,W
06A98:  ANDLW  06
06A9A:  MOVWF  x81
06A9C:  CLRF   x82
06A9E:  BCF    FD8.0
06AA0:  RRCF   x82,W
06AA2:  MOVWF  03
06AA4:  RRCF   x81,W
06AA6:  MOVWF  FEF
06AA8:  MOVFF  03,FEC
....................             habilitado[j] = tipoHabilitado & 0x01; 
06AAC:  BCF    FD8.0
06AAE:  RLCF   x79,W
06AB0:  MOVWF  02
06AB2:  RLCF   x7A,W
06AB4:  MOVWF  03
06AB6:  MOVF   02,W
06AB8:  ADDLW  2E
06ABA:  MOVWF  FE9
06ABC:  MOVLW  01
06ABE:  ADDWFC 03,W
06AC0:  MOVWF  FEA
06AC2:  MOVF   x7D,W
06AC4:  ANDLW  01
06AC6:  CLRF   03
06AC8:  MOVWF  FEF
06ACA:  MOVFF  03,FEC
....................             numeroFerros[j] = read_ext_eeprom(i+11); 
06ACE:  BCF    FD8.0
06AD0:  RLCF   x79,W
06AD2:  MOVWF  02
06AD4:  RLCF   x7A,W
06AD6:  MOVWF  03
06AD8:  MOVF   02,W
06ADA:  ADDLW  58
06ADC:  MOVWF  01
06ADE:  MOVLW  01
06AE0:  ADDWFC 03,F
06AE2:  MOVFF  01,57F
06AE6:  MOVFF  03,580
06AEA:  MOVLW  0B
06AEC:  ADDWF  x77,W
06AEE:  MOVWF  x81
06AF0:  MOVLW  00
06AF2:  ADDWFC x78,W
06AF4:  MOVWF  x82
06AF6:  MOVWF  x86
06AF8:  MOVFF  581,585
06AFC:  MOVLB  0
06AFE:  CALL   2C20
06B02:  MOVFF  580,FEA
06B06:  MOVFF  57F,FE9
06B0A:  MOVFF  02,FEC
06B0E:  MOVF   FED,F
06B10:  MOVFF  01,FEF
....................             t_solda2[j] = make16(read_ext_eeprom(i+12),read_ext_eeprom(i+13)); 
06B14:  BCF    FD8.0
06B16:  MOVLB  5
06B18:  RLCF   x79,W
06B1A:  MOVWF  02
06B1C:  RLCF   x7A,W
06B1E:  MOVWF  03
06B20:  MOVF   02,W
06B22:  ADDLW  82
06B24:  MOVWF  01
06B26:  MOVLW  01
06B28:  ADDWFC 03,F
06B2A:  MOVFF  01,57F
06B2E:  MOVFF  03,580
06B32:  MOVLW  0C
06B34:  ADDWF  x77,W
06B36:  MOVWF  x81
06B38:  MOVLW  00
06B3A:  ADDWFC x78,W
06B3C:  MOVWF  x82
06B3E:  MOVWF  x86
06B40:  MOVFF  581,585
06B44:  MOVLB  0
06B46:  CALL   2C20
06B4A:  MOVFF  02,582
06B4E:  MOVFF  01,581
06B52:  MOVLW  0D
06B54:  MOVLB  5
06B56:  ADDWF  x77,W
06B58:  MOVWF  x83
06B5A:  MOVLW  00
06B5C:  ADDWFC x78,W
06B5E:  MOVWF  x84
06B60:  MOVWF  x86
06B62:  MOVFF  583,585
06B66:  MOVLB  0
06B68:  CALL   2C20
06B6C:  MOVFF  580,FEA
06B70:  MOVFF  57F,FE9
06B74:  MOVFF  581,FEC
06B78:  MOVF   FED,F
06B7A:  MOVFF  01,FEF
....................             t_solda3[j] = make16(read_ext_eeprom(i+14),read_ext_eeprom(i+15)); 
06B7E:  BCF    FD8.0
06B80:  MOVLB  5
06B82:  RLCF   x79,W
06B84:  MOVWF  02
06B86:  RLCF   x7A,W
06B88:  MOVWF  03
06B8A:  MOVF   02,W
06B8C:  ADDLW  AC
06B8E:  MOVWF  01
06B90:  MOVLW  01
06B92:  ADDWFC 03,F
06B94:  MOVFF  01,57F
06B98:  MOVFF  03,580
06B9C:  MOVLW  0E
06B9E:  ADDWF  x77,W
06BA0:  MOVWF  x81
06BA2:  MOVLW  00
06BA4:  ADDWFC x78,W
06BA6:  MOVWF  x82
06BA8:  MOVWF  x86
06BAA:  MOVFF  581,585
06BAE:  MOVLB  0
06BB0:  CALL   2C20
06BB4:  MOVFF  02,582
06BB8:  MOVFF  01,581
06BBC:  MOVLW  0F
06BBE:  MOVLB  5
06BC0:  ADDWF  x77,W
06BC2:  MOVWF  x83
06BC4:  MOVLW  00
06BC6:  ADDWFC x78,W
06BC8:  MOVWF  x84
06BCA:  MOVWF  x86
06BCC:  MOVFF  583,585
06BD0:  MOVLB  0
06BD2:  CALL   2C20
06BD6:  MOVFF  580,FEA
06BDA:  MOVFF  57F,FE9
06BDE:  MOVFF  581,FEC
06BE2:  MOVF   FED,F
06BE4:  MOVFF  01,FEF
....................             limpar[j] = read_ext_eeprom(i+16); 
06BE8:  BCF    FD8.0
06BEA:  MOVLB  5
06BEC:  RLCF   x79,W
06BEE:  MOVWF  02
06BF0:  RLCF   x7A,W
06BF2:  MOVWF  03
06BF4:  MOVF   02,W
06BF6:  ADDLW  D6
06BF8:  MOVWF  01
06BFA:  MOVLW  01
06BFC:  ADDWFC 03,F
06BFE:  MOVFF  01,57F
06C02:  MOVFF  03,580
06C06:  MOVLW  10
06C08:  ADDWF  x77,W
06C0A:  MOVWF  x81
06C0C:  MOVLW  00
06C0E:  ADDWFC x78,W
06C10:  MOVWF  x82
06C12:  MOVWF  x86
06C14:  MOVFF  581,585
06C18:  MOVLB  0
06C1A:  CALL   2C20
06C1E:  MOVFF  580,FEA
06C22:  MOVFF  57F,FE9
06C26:  MOVFF  02,FEC
06C2A:  MOVF   FED,F
06C2C:  MOVFF  01,FEF
....................             j++; 
06C30:  MOVLB  5
06C32:  INCF   x79,F
06C34:  BTFSC  FD8.2
06C36:  INCF   x7A,F
....................         } 
06C38:  MOVLW  11
06C3A:  ADDWF  x77,F
06C3C:  MOVLW  00
06C3E:  ADDWFC x78,F
06C40:  BRA    681C
....................     } 
06C42:  MOVLB  0
06C44:  RETURN 0
.................... } //ler_modelo_memoria(modelo)) 
.................... void escrever_ponto_memoria(long int modeloSelecionado, long int pontoSelecionado){ 
*
0789C:  MOVLW  01
0789E:  MOVLB  5
078A0:  SUBWF  x76,W
078A2:  MOVWF  x7C
078A4:  MOVLW  00
078A6:  SUBWFB x77,W
078A8:  MOVWF  x7D
078AA:  MOVWF  x82
078AC:  MOVFF  57C,581
078B0:  MOVFF  574,584
078B4:  MOVFF  573,583
078B8:  MOVLB  0
078BA:  CALL   67A6
078BE:  MOVFF  02,57D
078C2:  MOVFF  01,57C
078C6:  MOVFF  579,582
078CA:  MOVFF  578,581
078CE:  MOVLB  5
078D0:  CLRF   x84
078D2:  MOVLW  11
078D4:  MOVWF  x83
078D6:  MOVLB  0
078D8:  CALL   67A6
078DC:  MOVF   01,W
078DE:  MOVLB  5
078E0:  ADDWF  x7C,W
078E2:  MOVWF  x7A
078E4:  MOVF   02,W
078E6:  ADDWFC x7D,W
078E8:  MOVWF  x7B
....................     long int endInicial = ((modeloSelecionado - 1)*tamPrograma) + (pontoSelecionado*17); 
....................     write_ext_eeprom(endInicial+1,((x[pontoSelecionado]&0xff00)>>8));\ 
078EA:  MOVLW  01
078EC:  ADDWF  x7A,W
078EE:  MOVWF  x7C
078F0:  MOVLW  00
078F2:  ADDWFC x7B,W
078F4:  MOVWF  x7D
078F6:  BCF    FD8.0
078F8:  RLCF   x78,W
078FA:  MOVWF  02
078FC:  RLCF   x79,W
078FE:  MOVWF  03
07900:  MOVF   02,W
07902:  ADDLW  30
07904:  MOVWF  FE9
07906:  MOVLW  00
07908:  ADDWFC 03,W
0790A:  MOVWF  FEA
0790C:  MOVFF  FEC,57F
07910:  MOVF   FED,F
07912:  MOVFF  FEF,57E
07916:  CLRF   x7E
07918:  MOVFF  57F,57E
0791C:  CLRF   x7F
0791E:  MOVFF  57D,581
07922:  MOVFF  57C,580
07926:  MOVFF  57F,583
0792A:  MOVFF  57E,582
0792E:  MOVLB  0
07930:  CALL   2B02
....................     write_ext_eeprom(endInicial+2,(x[pontoSelecionado]&0x00ff)); 
07934:  MOVLW  02
07936:  MOVLB  5
07938:  ADDWF  x7A,W
0793A:  MOVWF  x7C
0793C:  MOVLW  00
0793E:  ADDWFC x7B,W
07940:  MOVWF  x7D
07942:  BCF    FD8.0
07944:  RLCF   x78,W
07946:  MOVWF  02
07948:  RLCF   x79,W
0794A:  MOVWF  03
0794C:  MOVF   02,W
0794E:  ADDLW  30
07950:  MOVWF  FE9
07952:  MOVLW  00
07954:  ADDWFC 03,W
07956:  MOVWF  FEA
07958:  MOVFF  FEC,57F
0795C:  MOVF   FED,F
0795E:  MOVFF  FEF,57E
07962:  CLRF   x7F
07964:  MOVFF  57D,581
07968:  MOVFF  57C,580
0796C:  MOVFF  57F,583
07970:  MOVFF  57E,582
07974:  MOVLB  0
07976:  CALL   2B02
....................     write_ext_eeprom(endInicial+3,((y[pontoSelecionado]&0xff00)>>8)); 
0797A:  MOVLW  03
0797C:  MOVLB  5
0797E:  ADDWF  x7A,W
07980:  MOVWF  x7C
07982:  MOVLW  00
07984:  ADDWFC x7B,W
07986:  MOVWF  x7D
07988:  BCF    FD8.0
0798A:  RLCF   x78,W
0798C:  MOVWF  02
0798E:  RLCF   x79,W
07990:  MOVWF  03
07992:  MOVF   02,W
07994:  ADDLW  5A
07996:  MOVWF  FE9
07998:  MOVLW  00
0799A:  ADDWFC 03,W
0799C:  MOVWF  FEA
0799E:  MOVFF  FEC,57F
079A2:  MOVF   FED,F
079A4:  MOVFF  FEF,57E
079A8:  CLRF   x7E
079AA:  MOVFF  57F,57E
079AE:  CLRF   x7F
079B0:  MOVFF  57D,581
079B4:  MOVFF  57C,580
079B8:  MOVFF  57F,583
079BC:  MOVFF  57E,582
079C0:  MOVLB  0
079C2:  CALL   2B02
....................     write_ext_eeprom(endInicial+4,(y[pontoSelecionado]&0x00ff)); 
079C6:  MOVLW  04
079C8:  MOVLB  5
079CA:  ADDWF  x7A,W
079CC:  MOVWF  x7C
079CE:  MOVLW  00
079D0:  ADDWFC x7B,W
079D2:  MOVWF  x7D
079D4:  BCF    FD8.0
079D6:  RLCF   x78,W
079D8:  MOVWF  02
079DA:  RLCF   x79,W
079DC:  MOVWF  03
079DE:  MOVF   02,W
079E0:  ADDLW  5A
079E2:  MOVWF  FE9
079E4:  MOVLW  00
079E6:  ADDWFC 03,W
079E8:  MOVWF  FEA
079EA:  MOVFF  FEC,57F
079EE:  MOVF   FED,F
079F0:  MOVFF  FEF,57E
079F4:  CLRF   x7F
079F6:  MOVFF  57D,581
079FA:  MOVFF  57C,580
079FE:  MOVFF  57F,583
07A02:  MOVFF  57E,582
07A06:  MOVLB  0
07A08:  CALL   2B02
....................     write_ext_eeprom(endInicial+5,((z[pontoSelecionado]&0xff00)>>8)); 
07A0C:  MOVLW  05
07A0E:  MOVLB  5
07A10:  ADDWF  x7A,W
07A12:  MOVWF  x7C
07A14:  MOVLW  00
07A16:  ADDWFC x7B,W
07A18:  MOVWF  x7D
07A1A:  BCF    FD8.0
07A1C:  RLCF   x78,W
07A1E:  MOVWF  02
07A20:  RLCF   x79,W
07A22:  MOVWF  03
07A24:  MOVF   02,W
07A26:  ADDLW  84
07A28:  MOVWF  FE9
07A2A:  MOVLW  00
07A2C:  ADDWFC 03,W
07A2E:  MOVWF  FEA
07A30:  MOVFF  FEC,57F
07A34:  MOVF   FED,F
07A36:  MOVFF  FEF,57E
07A3A:  CLRF   x7E
07A3C:  MOVFF  57F,57E
07A40:  CLRF   x7F
07A42:  MOVFF  57D,581
07A46:  MOVFF  57C,580
07A4A:  MOVFF  57F,583
07A4E:  MOVFF  57E,582
07A52:  MOVLB  0
07A54:  CALL   2B02
....................     write_ext_eeprom(endInicial+6,(z[pontoSelecionado]&0x00ff)); 
07A58:  MOVLW  06
07A5A:  MOVLB  5
07A5C:  ADDWF  x7A,W
07A5E:  MOVWF  x7C
07A60:  MOVLW  00
07A62:  ADDWFC x7B,W
07A64:  MOVWF  x7D
07A66:  BCF    FD8.0
07A68:  RLCF   x78,W
07A6A:  MOVWF  02
07A6C:  RLCF   x79,W
07A6E:  MOVWF  03
07A70:  MOVF   02,W
07A72:  ADDLW  84
07A74:  MOVWF  FE9
07A76:  MOVLW  00
07A78:  ADDWFC 03,W
07A7A:  MOVWF  FEA
07A7C:  MOVFF  FEC,57F
07A80:  MOVF   FED,F
07A82:  MOVFF  FEF,57E
07A86:  CLRF   x7F
07A88:  MOVFF  57D,581
07A8C:  MOVFF  57C,580
07A90:  MOVFF  57F,583
07A94:  MOVFF  57E,582
07A98:  MOVLB  0
07A9A:  CALL   2B02
....................     write_ext_eeprom(endInicial+7,((t_solda[pontoSelecionado]&0xff00)>>8)); 
07A9E:  MOVLW  07
07AA0:  MOVLB  5
07AA2:  ADDWF  x7A,W
07AA4:  MOVWF  x7C
07AA6:  MOVLW  00
07AA8:  ADDWFC x7B,W
07AAA:  MOVWF  x7D
07AAC:  BCF    FD8.0
07AAE:  RLCF   x78,W
07AB0:  MOVWF  02
07AB2:  RLCF   x79,W
07AB4:  MOVWF  03
07AB6:  MOVF   02,W
07AB8:  ADDLW  AE
07ABA:  MOVWF  FE9
07ABC:  MOVLW  00
07ABE:  ADDWFC 03,W
07AC0:  MOVWF  FEA
07AC2:  MOVFF  FEC,57F
07AC6:  MOVF   FED,F
07AC8:  MOVFF  FEF,57E
07ACC:  CLRF   x7E
07ACE:  MOVFF  57F,57E
07AD2:  CLRF   x7F
07AD4:  MOVFF  57D,581
07AD8:  MOVFF  57C,580
07ADC:  MOVFF  57F,583
07AE0:  MOVFF  57E,582
07AE4:  MOVLB  0
07AE6:  CALL   2B02
....................     write_ext_eeprom(endInicial+8,(t_solda[pontoSelecionado]&0x00ff)); 
07AEA:  MOVLW  08
07AEC:  MOVLB  5
07AEE:  ADDWF  x7A,W
07AF0:  MOVWF  x7C
07AF2:  MOVLW  00
07AF4:  ADDWFC x7B,W
07AF6:  MOVWF  x7D
07AF8:  BCF    FD8.0
07AFA:  RLCF   x78,W
07AFC:  MOVWF  02
07AFE:  RLCF   x79,W
07B00:  MOVWF  03
07B02:  MOVF   02,W
07B04:  ADDLW  AE
07B06:  MOVWF  FE9
07B08:  MOVLW  00
07B0A:  ADDWFC 03,W
07B0C:  MOVWF  FEA
07B0E:  MOVFF  FEC,57F
07B12:  MOVF   FED,F
07B14:  MOVFF  FEF,57E
07B18:  CLRF   x7F
07B1A:  MOVFF  57D,581
07B1E:  MOVFF  57C,580
07B22:  MOVFF  57F,583
07B26:  MOVFF  57E,582
07B2A:  MOVLB  0
07B2C:  CALL   2B02
....................     write_ext_eeprom(endInicial+9,((t_wait[pontoSelecionado]&0xff00)>>8)); 
07B30:  MOVLW  09
07B32:  MOVLB  5
07B34:  ADDWF  x7A,W
07B36:  MOVWF  x7C
07B38:  MOVLW  00
07B3A:  ADDWFC x7B,W
07B3C:  MOVWF  x7D
07B3E:  BCF    FD8.0
07B40:  RLCF   x78,W
07B42:  MOVWF  02
07B44:  RLCF   x79,W
07B46:  MOVWF  03
07B48:  MOVF   02,W
07B4A:  ADDLW  D8
07B4C:  MOVWF  FE9
07B4E:  MOVLW  00
07B50:  ADDWFC 03,W
07B52:  MOVWF  FEA
07B54:  MOVFF  FEC,57F
07B58:  MOVF   FED,F
07B5A:  MOVFF  FEF,57E
07B5E:  CLRF   x7E
07B60:  MOVFF  57F,57E
07B64:  CLRF   x7F
07B66:  MOVFF  57D,581
07B6A:  MOVFF  57C,580
07B6E:  MOVFF  57F,583
07B72:  MOVFF  57E,582
07B76:  MOVLB  0
07B78:  CALL   2B02
....................     write_ext_eeprom(endInicial+10,(t_wait[pontoSelecionado]&0x00ff)); 
07B7C:  MOVLW  0A
07B7E:  MOVLB  5
07B80:  ADDWF  x7A,W
07B82:  MOVWF  x7C
07B84:  MOVLW  00
07B86:  ADDWFC x7B,W
07B88:  MOVWF  x7D
07B8A:  BCF    FD8.0
07B8C:  RLCF   x78,W
07B8E:  MOVWF  02
07B90:  RLCF   x79,W
07B92:  MOVWF  03
07B94:  MOVF   02,W
07B96:  ADDLW  D8
07B98:  MOVWF  FE9
07B9A:  MOVLW  00
07B9C:  ADDWFC 03,W
07B9E:  MOVWF  FEA
07BA0:  MOVFF  FEC,57F
07BA4:  MOVF   FED,F
07BA6:  MOVFF  FEF,57E
07BAA:  CLRF   x7F
07BAC:  MOVFF  57D,581
07BB0:  MOVFF  57C,580
07BB4:  MOVFF  57F,583
07BB8:  MOVFF  57E,582
07BBC:  MOVLB  0
07BBE:  CALL   2B02
....................     write_ext_eeprom(endInicial+11,(tipo[pontoSelecionado]<<1)+habilitado[pontoSelecionado]); 
07BC2:  MOVLW  0B
07BC4:  MOVLB  5
07BC6:  ADDWF  x7A,W
07BC8:  MOVWF  x7C
07BCA:  MOVLW  00
07BCC:  ADDWFC x7B,W
07BCE:  MOVWF  x7D
07BD0:  BCF    FD8.0
07BD2:  RLCF   x78,W
07BD4:  MOVWF  02
07BD6:  RLCF   x79,W
07BD8:  MOVWF  03
07BDA:  MOVF   02,W
07BDC:  ADDLW  02
07BDE:  MOVWF  FE9
07BE0:  MOVLW  01
07BE2:  ADDWFC 03,W
07BE4:  MOVWF  FEA
07BE6:  MOVFF  FEC,57F
07BEA:  MOVF   FED,F
07BEC:  MOVFF  FEF,57E
07BF0:  BCF    FD8.0
07BF2:  RLCF   x7E,F
07BF4:  RLCF   x7F,F
07BF6:  BCF    FD8.0
07BF8:  RLCF   x78,W
07BFA:  MOVWF  02
07BFC:  RLCF   x79,W
07BFE:  MOVWF  03
07C00:  MOVF   02,W
07C02:  ADDLW  2E
07C04:  MOVWF  FE9
07C06:  MOVLW  01
07C08:  ADDWFC 03,W
07C0A:  MOVWF  FEA
07C0C:  MOVFF  FEC,03
07C10:  MOVF   FED,F
07C12:  MOVF   FEF,W
07C14:  ADDWF  x7E,F
07C16:  MOVF   03,W
07C18:  ADDWFC x7F,F
07C1A:  MOVFF  57D,581
07C1E:  MOVFF  57C,580
07C22:  MOVFF  57F,583
07C26:  MOVFF  57E,582
07C2A:  MOVLB  0
07C2C:  CALL   2B02
....................     write_ext_eeprom(endInicial+12,(numeroFerros[pontoSelecionado])); 
07C30:  MOVLW  0C
07C32:  MOVLB  5
07C34:  ADDWF  x7A,W
07C36:  MOVWF  x7C
07C38:  MOVLW  00
07C3A:  ADDWFC x7B,W
07C3C:  MOVWF  x7D
07C3E:  BCF    FD8.0
07C40:  RLCF   x78,W
07C42:  MOVWF  02
07C44:  RLCF   x79,W
07C46:  MOVWF  03
07C48:  MOVF   02,W
07C4A:  ADDLW  58
07C4C:  MOVWF  FE9
07C4E:  MOVLW  01
07C50:  ADDWFC 03,W
07C52:  MOVWF  FEA
07C54:  MOVFF  FEC,57F
07C58:  MOVF   FED,F
07C5A:  MOVFF  FEF,57E
07C5E:  MOVFF  57D,581
07C62:  MOVFF  57C,580
07C66:  MOVFF  57F,583
07C6A:  MOVFF  57E,582
07C6E:  MOVLB  0
07C70:  CALL   2B02
....................     write_ext_eeprom(endInicial+13,((t_solda2[pontoSelecionado]&0xff00)>>8)); 
07C74:  MOVLW  0D
07C76:  MOVLB  5
07C78:  ADDWF  x7A,W
07C7A:  MOVWF  x7C
07C7C:  MOVLW  00
07C7E:  ADDWFC x7B,W
07C80:  MOVWF  x7D
07C82:  BCF    FD8.0
07C84:  RLCF   x78,W
07C86:  MOVWF  02
07C88:  RLCF   x79,W
07C8A:  MOVWF  03
07C8C:  MOVF   02,W
07C8E:  ADDLW  82
07C90:  MOVWF  FE9
07C92:  MOVLW  01
07C94:  ADDWFC 03,W
07C96:  MOVWF  FEA
07C98:  MOVFF  FEC,57F
07C9C:  MOVF   FED,F
07C9E:  MOVFF  FEF,57E
07CA2:  CLRF   x7E
07CA4:  MOVFF  57F,57E
07CA8:  CLRF   x7F
07CAA:  MOVFF  57D,581
07CAE:  MOVFF  57C,580
07CB2:  MOVFF  57F,583
07CB6:  MOVFF  57E,582
07CBA:  MOVLB  0
07CBC:  CALL   2B02
....................     write_ext_eeprom(endInicial+14,(t_solda2[pontoSelecionado]&0x00ff)); 
07CC0:  MOVLW  0E
07CC2:  MOVLB  5
07CC4:  ADDWF  x7A,W
07CC6:  MOVWF  x7C
07CC8:  MOVLW  00
07CCA:  ADDWFC x7B,W
07CCC:  MOVWF  x7D
07CCE:  BCF    FD8.0
07CD0:  RLCF   x78,W
07CD2:  MOVWF  02
07CD4:  RLCF   x79,W
07CD6:  MOVWF  03
07CD8:  MOVF   02,W
07CDA:  ADDLW  82
07CDC:  MOVWF  FE9
07CDE:  MOVLW  01
07CE0:  ADDWFC 03,W
07CE2:  MOVWF  FEA
07CE4:  MOVFF  FEC,57F
07CE8:  MOVF   FED,F
07CEA:  MOVFF  FEF,57E
07CEE:  CLRF   x7F
07CF0:  MOVFF  57D,581
07CF4:  MOVFF  57C,580
07CF8:  MOVFF  57F,583
07CFC:  MOVFF  57E,582
07D00:  MOVLB  0
07D02:  CALL   2B02
....................     write_ext_eeprom(endInicial+15,((t_solda3[pontoSelecionado]&0xff00)>>8)); 
07D06:  MOVLW  0F
07D08:  MOVLB  5
07D0A:  ADDWF  x7A,W
07D0C:  MOVWF  x7C
07D0E:  MOVLW  00
07D10:  ADDWFC x7B,W
07D12:  MOVWF  x7D
07D14:  BCF    FD8.0
07D16:  RLCF   x78,W
07D18:  MOVWF  02
07D1A:  RLCF   x79,W
07D1C:  MOVWF  03
07D1E:  MOVF   02,W
07D20:  ADDLW  AC
07D22:  MOVWF  FE9
07D24:  MOVLW  01
07D26:  ADDWFC 03,W
07D28:  MOVWF  FEA
07D2A:  MOVFF  FEC,57F
07D2E:  MOVF   FED,F
07D30:  MOVFF  FEF,57E
07D34:  CLRF   x7E
07D36:  MOVFF  57F,57E
07D3A:  CLRF   x7F
07D3C:  MOVFF  57D,581
07D40:  MOVFF  57C,580
07D44:  MOVFF  57F,583
07D48:  MOVFF  57E,582
07D4C:  MOVLB  0
07D4E:  CALL   2B02
....................     write_ext_eeprom(endInicial+16,(t_solda3[pontoSelecionado]&0x00ff)); 
07D52:  MOVLW  10
07D54:  MOVLB  5
07D56:  ADDWF  x7A,W
07D58:  MOVWF  x7C
07D5A:  MOVLW  00
07D5C:  ADDWFC x7B,W
07D5E:  MOVWF  x7D
07D60:  BCF    FD8.0
07D62:  RLCF   x78,W
07D64:  MOVWF  02
07D66:  RLCF   x79,W
07D68:  MOVWF  03
07D6A:  MOVF   02,W
07D6C:  ADDLW  AC
07D6E:  MOVWF  FE9
07D70:  MOVLW  01
07D72:  ADDWFC 03,W
07D74:  MOVWF  FEA
07D76:  MOVFF  FEC,57F
07D7A:  MOVF   FED,F
07D7C:  MOVFF  FEF,57E
07D80:  CLRF   x7F
07D82:  MOVFF  57D,581
07D86:  MOVFF  57C,580
07D8A:  MOVFF  57F,583
07D8E:  MOVFF  57E,582
07D92:  MOVLB  0
07D94:  CALL   2B02
....................     write_ext_eeprom(endInicial+17,(limpar[pontoSelecionado])); 
07D98:  MOVLW  11
07D9A:  MOVLB  5
07D9C:  ADDWF  x7A,W
07D9E:  MOVWF  x7C
07DA0:  MOVLW  00
07DA2:  ADDWFC x7B,W
07DA4:  MOVWF  x7D
07DA6:  BCF    FD8.0
07DA8:  RLCF   x78,W
07DAA:  MOVWF  02
07DAC:  RLCF   x79,W
07DAE:  MOVWF  03
07DB0:  MOVF   02,W
07DB2:  ADDLW  D6
07DB4:  MOVWF  FE9
07DB6:  MOVLW  01
07DB8:  ADDWFC 03,W
07DBA:  MOVWF  FEA
07DBC:  MOVFF  FEC,57F
07DC0:  MOVF   FED,F
07DC2:  MOVFF  FEF,57E
07DC6:  MOVFF  57D,581
07DCA:  MOVFF  57C,580
07DCE:  MOVFF  57F,583
07DD2:  MOVFF  57E,582
07DD6:  MOVLB  0
07DD8:  CALL   2B02
07DDC:  RETURN 0
.................... } //escrever_ponto_memoria(modelo,contador_lcd) 
.................... void excluir_modelo_memoria(long int modeloSelecionado){ 
*
0AF10:  MOVLB  5
0AF12:  CLRF   x78
0AF14:  CLRF   x77
0AF16:  MOVLW  01
0AF18:  SUBWF  x75,W
0AF1A:  MOVWF  x7B
0AF1C:  MOVLW  00
0AF1E:  SUBWFB x76,W
0AF20:  MOVWF  x7C
0AF22:  MOVWF  x82
0AF24:  MOVFF  57B,581
0AF28:  MOVFF  574,584
0AF2C:  MOVFF  573,583
0AF30:  MOVLB  0
0AF32:  CALL   67A6
0AF36:  MOVFF  02,57A
0AF3A:  MOVFF  01,579
....................     long int i = 0; 
....................     long int endInicial = ((modeloSelecionado - 1)* tamPrograma); 
....................     for (i = endInicial; i< ((endInicial)  + tamPrograma); i++){ 
0AF3E:  MOVFF  57A,578
0AF42:  MOVFF  579,577
0AF46:  MOVLB  5
0AF48:  MOVF   x73,W
0AF4A:  ADDWF  x79,W
0AF4C:  MOVWF  01
0AF4E:  MOVF   x74,W
0AF50:  ADDWFC x7A,W
0AF52:  MOVWF  03
0AF54:  MOVF   x78,W
0AF56:  SUBWF  03,W
0AF58:  BNC   AF7E
0AF5A:  BNZ   AF62
0AF5C:  MOVF   01,W
0AF5E:  SUBWF  x77,W
0AF60:  BC    AF7E
....................         write_ext_eeprom(i,0);        
0AF62:  MOVFF  578,581
0AF66:  MOVFF  577,580
0AF6A:  CLRF   x83
0AF6C:  CLRF   x82
0AF6E:  MOVLB  0
0AF70:  CALL   2B02
0AF74:  MOVLB  5
0AF76:  INCF   x77,F
0AF78:  BTFSC  FD8.2
0AF7A:  INCF   x78,F
0AF7C:  BRA    AF48
....................     } 
0AF7E:  MOVLB  0
0AF80:  GOTO   AFCC (RETURN)
.................... } //excluir_modelo_memoria(modelo) 
.................... void escrever_pontos_no_modelo(long int modeloSelecionado,int quantidade_pontos){ 
*
07142:  MOVLW  01
07144:  MOVLB  5
07146:  SUBWF  x75,W
07148:  MOVWF  x7A
0714A:  MOVLW  00
0714C:  SUBWFB x76,W
0714E:  MOVWF  x7B
07150:  MOVWF  x82
07152:  MOVFF  57A,581
07156:  MOVFF  574,584
0715A:  MOVFF  573,583
0715E:  MOVLB  0
07160:  CALL   67A6
07164:  MOVFF  02,579
07168:  MOVFF  01,578
....................     long int endInicial = ((modeloSelecionado - 1)*tamPrograma); 
....................     write_ext_eeprom(endInicial,quantidade_pontos); 
0716C:  MOVFF  579,581
07170:  MOVFF  578,580
07174:  MOVLB  5
07176:  CLRF   x83
07178:  MOVFF  577,582
0717C:  MOVLB  0
0717E:  CALL   2B02
07182:  GOTO   7202 (RETURN)
.................... } //escrever_pontos_no_modelo(modelo,pontos_no_modelo) 
....................  
.................... #include "att_telas_2.c" 
.................... #include "att_telas_2.h" 
.................... void atualiza_tela_principal(void); //atualizacao de tela principal: F1 para degub F2 para main 
....................  
.................... void atualiza_tela_seleciona_maquina(void); //atualiza tela de selecao de maquina f1 para maquina 1 e f2 para maquina 2 
.................... void atualiza_tela_manutencao_outra_maquina(void); //atualizacao de tela enquanto esta sendo feita manutencao na outra maquina 
.................... void atualiza_tela_edita_modelo(void); //atualizacao de tela para editar ou excluir modelo 
.................... void atualiza_tela_seleciona_debug(void); // atualizacao de tela que escolhe f1 para editar ponto e f2 para manutencao 
.................... void atualiza_tela_edita_pontos_no_modelo(void);// atualizacao de tela da edicao de pontos do modelo 
.................... void atualiza_tela_excluir_modelo(void); //atualizacao de tela que exclui o modelo 
.................... void atualiza_tela_seleciona_pontos(void); //atualizacao de tela da escolha de ponto a ser editado 
.................... void atualiza_tela_dados_ponto (void); //atualizacao de tela que age em cima da tela de dados ponto, alterando x, y, z, tempo de solda, tempo de espera, tipo e habilitado 
....................  
.................... void atualiza_tela_seleciona_manutencao (void); //atualizacao de tela de manutencao, escolhe entre entradas e saidas 
.................... void atualiza_tela_debug_entrada_1 (void); //atualizacao de tela que ao passar pro lado mostra a tela 2 de sensores ou sai ao dar esc 
.................... void atualiza_tela_debug_entrada_2 (void); ///atualizacao de tela que ao passar pro lado mostra a tela 1 ou 3 de sensores ou sai ao dar esc 
.................... void atualiza_tela_debug_entrada_3 (void); //atualizacao de tela que ao passar pro lado mostra a tela 2 de sensores ou sai ao dar esc 
.................... void atualiza_tela_debug_saida_1(void); //atualizacao de tela que podemos acionar a esteira, pinos de entrada, e o alimentador de placa 
.................... void atualiza_tela_debug_saida_2(void); //atualizacao de tela que podemos acionar o pressor da placa, pinos de saida e dispensador de placa 
.................... void atualiza_tela_debug_saida_3(void); //atualizacao de tela que podemos acionar os alimentadores de solda, limpar os bicos e acionar os ferros 
.................... void atualiza_tela_debug_saida_4(void); //atualizacao de tela que podemos realizar a movimentacao do eixo x, y, z e o flip individualmenta 
....................  
.................... void programa_principal(void); // atualizacao de tela programa principal 
....................  
....................  
.................... void atualiza_tela_principal(){ 
....................     switch (Teclado()){ 
*
06CF0:  RCALL  6564
06CF2:  MOVF   01,W
06CF4:  XORLW  14
06CF6:  BZ    6D06
06CF8:  XORLW  07
06CFA:  BZ    6D32
06CFC:  XORLW  1D
06CFE:  BZ    6D60
06D00:  XORLW  01
06D02:  BZ    6D70
06D04:  BRA    6D7E
....................         case MENU: 
....................             printf(lcd_putc, "\f"); // limpa display 
06D06:  MOVLW  0C
06D08:  MOVLB  5
06D0A:  MOVWF  x86
06D0C:  MOVLB  0
06D0E:  CALL   2D32
....................             printf(lcd_putc, "  CARREGANDO MODELO \n\r"); 
06D12:  MOVLW  54
06D14:  MOVWF  FF6
06D16:  MOVLW  0E
06D18:  MOVWF  FF7
06D1A:  CALL   2D86
....................             ler_modelo_memoria(modelo); 
06D1E:  MOVLB  5
06D20:  CLRF   x76
06D22:  MOVFF  2F,575
06D26:  MOVLB  0
06D28:  RCALL  67C8
....................             menu_atual = menu_seleciona_maquina; 
06D2A:  MOVLW  01
06D2C:  MOVWF  1C
....................             tela_seleciona_maquina();             
06D2E:  RCALL  6C46
....................         break; 
06D30:  BRA    6D7E
....................         case ENTER: 
....................             printf(lcd_putc, "\f"); // limpa display 
06D32:  MOVLW  0C
06D34:  MOVLB  5
06D36:  MOVWF  x86
06D38:  MOVLB  0
06D3A:  CALL   2D32
....................             printf(lcd_putc, "  CARREGANDO MODELO \n\r"); 
06D3E:  MOVLW  6C
06D40:  MOVWF  FF6
06D42:  MOVLW  0E
06D44:  MOVWF  FF7
06D46:  CALL   2D86
....................             ler_modelo_memoria(modelo); 
06D4A:  MOVLB  5
06D4C:  CLRF   x76
06D4E:  MOVFF  2F,575
06D52:  MOVLB  0
06D54:  RCALL  67C8
....................             exit = TRUE; 
06D56:  BSF    2D.1
....................             menu_atual = menu_programa_principal; 
06D58:  MOVLW  0C
06D5A:  MOVWF  1C
....................             tela_programa_principal(); 
06D5C:  BRA    6C84
....................         break; 
06D5E:  BRA    6D7E
....................         case SETA_SUPERIOR: 
....................             if (modelo < 4){ 
06D60:  MOVF   2F,W
06D62:  SUBLW  03
06D64:  BNC   6D68
....................                 modelo ++; 
06D66:  INCF   2F,F
....................             } 
....................             menu_atual = menu_principal; 
06D68:  CLRF   1C
....................             tela_principal(); 
06D6A:  CALL   63D4
....................         break; 
06D6E:  BRA    6D7E
....................         case SETA_INFERIOR: 
....................             if (modelo > 1){ 
06D70:  MOVF   2F,W
06D72:  SUBLW  01
06D74:  BC    6D78
....................                 modelo --; 
06D76:  DECF   2F,F
....................             } 
....................             menu_atual = menu_principal; 
06D78:  CLRF   1C
....................             tela_principal(); 
06D7A:  CALL   63D4
....................         break; 
....................     } 
06D7E:  GOTO   D852 (RETURN)
.................... } 
....................  
.................... void atualiza_tela_seleciona_maquina(){ 
....................     switch (Teclado()){ 
*
06DFE:  CALL   6564
06E02:  MOVF   01,W
06E04:  XORLW  0A
06E06:  BZ    6E12
06E08:  XORLW  01
06E0A:  BZ    6E1A
06E0C:  XORLW  19
06E0E:  BZ    6E2C
06E10:  BRA    6E32
....................         case F1: 
....................             menu_atual = menu_manutencao_outra_maquina; 
06E12:  MOVLW  07
06E14:  MOVWF  1C
....................             tela_manutencao_outra_maquina(); 
06E16:  RCALL  6D82
....................         break; 
06E18:  BRA    6E32
....................         case F2: 
....................             envia_maquina_para_posicao(ALIMENTADOR);          
06E1A:  MOVLB  5
06E1C:  CLRF   x78
06E1E:  MOVLB  0
06E20:  CALL   5C9C
....................             menu_atual = menu_edita_modelo; 
06E24:  MOVLW  0D
06E26:  MOVWF  1C
....................             tela_edita_modelo();             
06E28:  RCALL  6DC0
....................         break; 
06E2A:  BRA    6E32
....................         case ESC: 
....................             menu_atual = menu_principal; 
06E2C:  CLRF   1C
....................             tela_principal(); 
06E2E:  CALL   63D4
....................         break; 
....................     } 
06E32:  GOTO   D85A (RETURN)
.................... } 
.................... void atualiza_tela_manutencao_outra_maquina(){ 
....................     switch(Teclado()){ 
*
06E76:  CALL   6564
06E7A:  MOVF   01,W
06E7C:  XORLW  12
06E7E:  BZ    6E82
06E80:  BRA    6E88
....................         case ESC: 
....................             menu_atual = menu_confirmaManutencao; 
06E82:  MOVLW  15
06E84:  MOVWF  1C
....................             tela_confirmaManutencao(); 
06E86:  BRA    6E36
....................         break; 
....................     } 
06E88:  GOTO   D862 (RETURN)
.................... } 
.................... void atualiza_tela_edita_modelo(){ 
....................     switch (Teclado()){ 
*
06F38:  CALL   6564
06F3C:  MOVF   01,W
06F3E:  XORLW  0A
06F40:  BZ    6F4C
06F42:  XORLW  01
06F44:  BZ    6F54
06F46:  XORLW  19
06F48:  BZ    6F5C
06F4A:  BRA    6F6E
....................         case F1: 
....................             menu_atual = menu_seleciona_debug; 
06F4C:  MOVLW  02
06F4E:  MOVWF  1C
....................             tela_seleciona_debug(); 
06F50:  RCALL  6EAE
....................         break; 
06F52:  BRA    6F6E
....................         case F2: 
....................             menu_atual = menu_excluir_modelo; 
06F54:  MOVLW  0E
06F56:  MOVWF  1C
....................             tela_excluir_modelo(); 
06F58:  BRA    6EF8
....................         break; 
06F5A:  BRA    6F6E
....................         case ESC: 
....................             envia_maquina_para_posicao(HOME1); 
06F5C:  MOVLW  01
06F5E:  MOVLB  5
06F60:  MOVWF  x78
06F62:  MOVLB  0
06F64:  CALL   5C9C
....................             menu_atual = menu_principal; 
06F68:  CLRF   1C
....................             tela_principal(); 
06F6A:  CALL   63D4
....................         break; 
....................     } 
06F6E:  GOTO   D872 (RETURN)
.................... } 
.................... void atualiza_tela_seleciona_debug (){ 
....................     switch(Teclado()){ 
*
06FFA:  CALL   6564
06FFE:  MOVF   01,W
07000:  XORLW  0A
07002:  BZ    700E
07004:  XORLW  01
07006:  BZ    7016
07008:  XORLW  19
0700A:  BZ    701E
0700C:  BRA    7024
....................         case F1: 
....................             menu_atual = menu_seleciona_debug_2; 
0700E:  MOVLW  14
07010:  MOVWF  1C
....................             tela_seleciona_debug_2(); 
07012:  RCALL  6F72
....................         break; 
07014:  BRA    7024
....................         case F2: 
....................             menu_atual = menu_seleciona_manutencao; 
07016:  MOVLW  03
07018:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
0701A:  RCALL  6FBC
....................         break; 
0701C:  BRA    7024
....................         case ESC: 
....................             menu_atual = menu_edita_modelo; 
0701E:  MOVLW  0D
07020:  MOVWF  1C
....................             tela_edita_modelo(); 
07022:  RCALL  6DC0
....................         break; 
....................     } 
07024:  GOTO   D87A (RETURN)
.................... } 
.................... void atualiza_tela_seleciona_debug_2 (){ 
*
0B1EC:  MOVLB  5
0B1EE:  BSF    x75.1
....................     short int x; 
....................     short int k = TRUE; 
....................     short int b; 
....................     switch(Teclado()){ 
0B1F0:  MOVLB  0
0B1F2:  CALL   6564
0B1F6:  MOVF   01,W
0B1F8:  XORLW  0B
0B1FA:  BZ    B20A
0B1FC:  XORLW  01
0B1FE:  BTFSC  FD8.2
0B200:  BRA    B330
0B202:  XORLW  18
0B204:  BTFSC  FD8.2
0B206:  BRA    B33A
0B208:  BRA    B342
....................         case F2: 
....................             if (pontos_no_modelo > 0){ 
0B20A:  MOVLB  1
0B20C:  MOVF   x2C,F
0B20E:  BNZ   B214
0B210:  MOVF   x2D,F
0B212:  BZ    B2EA
....................                 b = le_Input(S_BANDEJA); 
0B214:  MOVLW  15
0B216:  MOVLB  5
0B218:  MOVWF  x7A
0B21A:  MOVLB  0
0B21C:  CALL   49FA
0B220:  MOVLB  5
0B222:  BCF    x75.2
0B224:  BTFSC  01.0
0B226:  BSF    x75.2
....................                 if (b == 0){ 
0B228:  BTFSC  x75.2
0B22A:  BRA    B2CC
....................                     liga_esteira(); 
0B22C:  MOVLB  0
0B22E:  RCALL  B122
....................                     x = le_Input(S_ESTEIRA); 
0B230:  MOVLW  19
0B232:  MOVLB  5
0B234:  MOVWF  x7A
0B236:  MOVLB  0
0B238:  CALL   49FA
0B23C:  MOVLB  5
0B23E:  BCF    x75.0
0B240:  BTFSC  01.0
0B242:  BSF    x75.0
....................                     while ((x == 0)&&(k == TRUE)){ 
0B244:  BTFSC  x75.0
0B246:  BRA    B296
0B248:  BTFSS  x75.1
0B24A:  BRA    B296
....................                         printf(lcd_putc, "\f"); //limpa display 
0B24C:  MOVLW  0C
0B24E:  MOVWF  x86
0B250:  MOVLB  0
0B252:  CALL   2D32
....................                         printf(lcd_putc, "   ESPERANDO PLACA   \n\r"); 
0B256:  MOVLW  84
0B258:  MOVWF  FF6
0B25A:  MOVLW  0E
0B25C:  MOVWF  FF7
0B25E:  CALL   2D86
....................                         printf(lcd_putc, "     NA ESTEIRA     \n\r"); 
0B262:  MOVLW  9C
0B264:  MOVWF  FF6
0B266:  MOVLW  0E
0B268:  MOVWF  FF7
0B26A:  CALL   2D86
....................                         x = le_Input(S_ESTEIRA); 
0B26E:  MOVLW  19
0B270:  MOVLB  5
0B272:  MOVWF  x7A
0B274:  MOVLB  0
0B276:  CALL   49FA
0B27A:  MOVLB  5
0B27C:  BCF    x75.0
0B27E:  BTFSC  01.0
0B280:  BSF    x75.0
....................                         if (Teclado() == ESC){ 
0B282:  MOVLB  0
0B284:  CALL   6564
0B288:  MOVF   01,W
0B28A:  SUBLW  12
0B28C:  BNZ   B292
....................                             k = FALSE; 
0B28E:  MOVLB  5
0B290:  BCF    x75.1
....................                         }                    
0B292:  MOVLB  5
0B294:  BRA    B244
....................                     } 
....................                     if (k == TRUE){ 
0B296:  BTFSS  x75.1
0B298:  BRA    B2BC
....................                         desliga_esteira(); 
0B29A:  MOVLB  0
0B29C:  RCALL  B132
....................                         empurra_placa(); 
0B29E:  RCALL  B142
....................                         liga_pressor(); 
0B2A0:  CALL   788C
....................                         envia_maquina_para_posicao(HOME1); 
0B2A4:  MOVLW  01
0B2A6:  MOVLB  5
0B2A8:  MOVWF  x78
0B2AA:  MOVLB  0
0B2AC:  CALL   5C9C
....................                         menu_atual = menu_seleciona_pontos; 
0B2B0:  MOVLW  0F
0B2B2:  MOVWF  1C
....................                         tela_seleciona_pontos(); 
0B2B4:  CALL   727A
....................                     } else { 
0B2B8:  BRA    B2C8
0B2BA:  MOVLB  5
....................                         desliga_esteira(); 
0B2BC:  MOVLB  0
0B2BE:  RCALL  B132
....................                         menu_atual = menu_seleciona_debug_2; 
0B2C0:  MOVLW  14
0B2C2:  MOVWF  1C
....................                         tela_seleciona_debug_2(); 
0B2C4:  CALL   6F72
....................                     } 
....................                 } else { 
0B2C8:  BRA    B2E6
0B2CA:  MOVLB  5
....................                     liga_pressor(); 
0B2CC:  MOVLB  0
0B2CE:  CALL   788C
....................                     envia_maquina_para_posicao(HOME1); 
0B2D2:  MOVLW  01
0B2D4:  MOVLB  5
0B2D6:  MOVWF  x78
0B2D8:  MOVLB  0
0B2DA:  CALL   5C9C
....................                     menu_atual = menu_seleciona_pontos; 
0B2DE:  MOVLW  0F
0B2E0:  MOVWF  1C
....................                     tela_seleciona_pontos(); 
0B2E2:  CALL   727A
....................                 }                               
....................             } else { 
0B2E6:  BRA    B32E
0B2E8:  MOVLB  1
....................                 printf(lcd_putc, "\f"); // limpa display 
0B2EA:  MOVLW  0C
0B2EC:  MOVLB  5
0B2EE:  MOVWF  x86
0B2F0:  MOVLB  0
0B2F2:  CALL   2D32
....................                 printf(lcd_putc, " VERIFIQUE O NUMERO \n\r"); 
0B2F6:  MOVLW  B4
0B2F8:  MOVWF  FF6
0B2FA:  MOVLW  0E
0B2FC:  MOVWF  FF7
0B2FE:  CALL   2D86
....................                 printf(lcd_putc, " DE PONTOS NO MODELO\n\r"); 
0B302:  MOVLW  CC
0B304:  MOVWF  FF6
0B306:  MOVLW  0E
0B308:  MOVWF  FF7
0B30A:  CALL   2D86
....................                 delay_ms(3000); 
0B30E:  MOVLW  0C
0B310:  MOVLB  5
0B312:  MOVWF  x76
0B314:  MOVLW  FA
0B316:  MOVWF  x92
0B318:  MOVLB  0
0B31A:  CALL   2958
0B31E:  MOVLB  5
0B320:  DECFSZ x76,F
0B322:  BRA    B314
....................                 menu_atual = menu_seleciona_debug_2; 
0B324:  MOVLW  14
0B326:  MOVWF  1C
....................                 tela_seleciona_debug_2(); 
0B328:  MOVLB  0
0B32A:  CALL   6F72
....................             } 
....................         break; 
0B32E:  BRA    B342
....................         case F1: 
....................             menu_atual = menu_edita_pontos_no_modelo; 
0B330:  MOVLW  11
0B332:  MOVWF  1C
....................             tela_edita_pontos_no_modelo(); 
0B334:  CALL   70E6
....................         break; 
0B338:  BRA    B342
....................         case ESC: 
....................             menu_atual = menu_seleciona_debug; 
0B33A:  MOVLW  02
0B33C:  MOVWF  1C
....................             tela_seleciona_debug(); 
0B33E:  CALL   6EAE
....................         break; 
....................     } 
0B342:  GOTO   D8B2 (RETURN)
.................... } 
.................... void atualiza_tela_edita_pontos_no_modelo(){ 
....................     switch(Teclado()){ 
*
07186:  CALL   6564
0718A:  MOVLW  0E
0718C:  SUBWF  01,W
0718E:  ADDLW  FA
07190:  BC    7246
07192:  ADDLW  06
07194:  GOTO   724A
....................         case SETA_SUPERIOR: 
....................             if (pontos_no_modelo < 20){ 
07198:  MOVLB  1
0719A:  MOVF   x2D,F
0719C:  BNZ   71AC
0719E:  MOVF   x2C,W
071A0:  SUBLW  13
071A2:  BNC   71AC
....................                 pontos_no_modelo = pontos_no_modelo + 1;                 
071A4:  MOVLW  01
071A6:  ADDWF  x2C,F
071A8:  MOVLW  00
071AA:  ADDWFC x2D,F
....................             } 
....................             menu_atual = menu_edita_pontos_no_modelo; 
071AC:  MOVLW  11
071AE:  MOVWF  1C
....................             tela_edita_pontos_no_modelo(); 
071B0:  MOVLB  0
071B2:  RCALL  70E6
....................         break; 
071B4:  BRA    7246
....................         case SETA_INFERIOR: 
....................             if (pontos_no_modelo > 0){ 
071B6:  MOVLB  1
071B8:  MOVF   x2C,F
071BA:  BNZ   71C0
071BC:  MOVF   x2D,F
071BE:  BZ    71C8
....................                 pontos_no_modelo = pontos_no_modelo -1; 
071C0:  MOVLW  01
071C2:  SUBWF  x2C,F
071C4:  MOVLW  00
071C6:  SUBWFB x2D,F
....................             } 
....................             menu_atual = menu_edita_pontos_no_modelo; 
071C8:  MOVLW  11
071CA:  MOVWF  1C
....................             tela_edita_pontos_no_modelo(); 
071CC:  MOVLB  0
071CE:  RCALL  70E6
....................         break; 
071D0:  BRA    7246
....................         case ESC: 
....................             menu_atual = menu_seleciona_debug_2; 
071D2:  MOVLW  14
071D4:  MOVWF  1C
....................             tela_seleciona_debug_2(); 
071D6:  RCALL  6F72
....................         break; 
071D8:  BRA    7246
....................         case ENTER: 
....................             printf(lcd_putc, "\f"); // limpa display 
071DA:  MOVLW  0C
071DC:  MOVLB  5
071DE:  MOVWF  x86
071E0:  MOVLB  0
071E2:  CALL   2D32
....................             printf(lcd_putc, "   GRAVANDO PONTOS  \n\r"); 
071E6:  MOVLW  E4
071E8:  MOVWF  FF6
071EA:  MOVLW  0E
071EC:  MOVWF  FF7
071EE:  CALL   2D86
....................             escrever_pontos_no_modelo(modelo,pontos_no_modelo); 
071F2:  MOVLB  5
071F4:  CLRF   x76
071F6:  MOVFF  2F,575
071FA:  MOVFF  12C,577
071FE:  MOVLB  0
07200:  BRA    7142
....................             ler_modelo_memoria(modelo); 
07202:  MOVLB  5
07204:  CLRF   x76
07206:  MOVFF  2F,575
0720A:  MOVLB  0
0720C:  CALL   67C8
....................             printf(lcd_putc, "\f"); // limpa display 
07210:  MOVLW  0C
07212:  MOVLB  5
07214:  MOVWF  x86
07216:  MOVLB  0
07218:  CALL   2D32
....................             printf(lcd_putc, "PONTOS ATUALIZADOS\n\r"); 
0721C:  MOVLW  FC
0721E:  MOVWF  FF6
07220:  MOVLW  0E
07222:  MOVWF  FF7
07224:  CALL   2D86
....................             delay_ms(1000); 
07228:  MOVLW  04
0722A:  MOVLB  5
0722C:  MOVWF  x75
0722E:  MOVLW  FA
07230:  MOVWF  x92
07232:  MOVLB  0
07234:  CALL   2958
07238:  MOVLB  5
0723A:  DECFSZ x75,F
0723C:  BRA    722E
....................             menu_atual = menu_seleciona_debug_2; 
0723E:  MOVLW  14
07240:  MOVWF  1C
....................             tela_seleciona_debug_2(); 
07242:  MOVLB  0
07244:  RCALL  6F72
....................         break; 
....................     } 
07246:  GOTO   D882 (RETURN)
.................... } 
.................... void atualiza_tela_excluir_modelo(){ 
....................     switch (Teclado()){ 
*
0AF84:  CALL   6564
0AF88:  MOVF   01,W
0AF8A:  XORLW  13
0AF8C:  BZ    AF94
0AF8E:  XORLW  01
0AF90:  BZ    B014
0AF92:  BRA    B01C
....................         case ENTER: 
....................             printf(lcd_putc, "\f"); // limpa display 
0AF94:  MOVLW  0C
0AF96:  MOVLB  5
0AF98:  MOVWF  x86
0AF9A:  MOVLB  0
0AF9C:  CALL   2D32
....................             printf(lcd_putc, "  EXCLUINDO MODELO  \n\r"); 
0AFA0:  MOVLW  12
0AFA2:  MOVWF  FF6
0AFA4:  MOVLW  0F
0AFA6:  MOVWF  FF7
0AFA8:  CALL   2D86
....................             delay_ms(1000); 
0AFAC:  MOVLW  04
0AFAE:  MOVLB  5
0AFB0:  MOVWF  x75
0AFB2:  MOVLW  FA
0AFB4:  MOVWF  x92
0AFB6:  MOVLB  0
0AFB8:  CALL   2958
0AFBC:  MOVLB  5
0AFBE:  DECFSZ x75,F
0AFC0:  BRA    AFB2
....................             excluir_modelo_memoria(modelo); 
0AFC2:  CLRF   x76
0AFC4:  MOVFF  2F,575
0AFC8:  MOVLB  0
0AFCA:  BRA    AF10
....................             ler_modelo_memoria(modelo); 
0AFCC:  MOVLB  5
0AFCE:  CLRF   x76
0AFD0:  MOVFF  2F,575
0AFD4:  MOVLB  0
0AFD6:  CALL   67C8
....................             printf(lcd_putc, "\f"); // limpa display 
0AFDA:  MOVLW  0C
0AFDC:  MOVLB  5
0AFDE:  MOVWF  x86
0AFE0:  MOVLB  0
0AFE2:  CALL   2D32
....................             printf(lcd_putc, "   MODELO EXCUIDO   \n\r"); 
0AFE6:  MOVLW  2A
0AFE8:  MOVWF  FF6
0AFEA:  MOVLW  0F
0AFEC:  MOVWF  FF7
0AFEE:  CALL   2D86
....................             delay_ms(1000); 
0AFF2:  MOVLW  04
0AFF4:  MOVLB  5
0AFF6:  MOVWF  x75
0AFF8:  MOVLW  FA
0AFFA:  MOVWF  x92
0AFFC:  MOVLB  0
0AFFE:  CALL   2958
0B002:  MOVLB  5
0B004:  DECFSZ x75,F
0B006:  BRA    AFF8
....................             menu_atual = menu_edita_modelo; 
0B008:  MOVLW  0D
0B00A:  MOVWF  1C
....................             tela_edita_modelo(); 
0B00C:  MOVLB  0
0B00E:  CALL   6DC0
....................         break; 
0B012:  BRA    B01C
....................         case ESC: 
....................             menu_atual = menu_edita_modelo; 
0B014:  MOVLW  0D
0B016:  MOVWF  1C
....................             tela_edita_modelo(); 
0B018:  CALL   6DC0
....................         break; 
....................     } 
0B01C:  GOTO   D8A2 (RETURN)
.................... } 
.................... void atualiza_tela_seleciona_pontos(){ 
....................     switch(Teclado()){ 
*
075BC:  CALL   6564
075C0:  MOVLW  0E
075C2:  SUBWF  01,W
075C4:  ADDLW  FA
075C6:  BTFSC  FD8.0
075C8:  BRA    77E8
075CA:  ADDLW  06
075CC:  GOTO   77EC
....................         case SETA_SUPERIOR: 
....................             contador_lcd --; 
075D0:  DECF   24,F
....................             if  ((contador_lcd > 0)&&(contador_lcd < pontos_no_modelo)){ 
075D2:  MOVF   24,F
075D4:  BZ    75FC
075D6:  MOVLB  1
075D8:  MOVF   x2D,F
075DA:  BNZ   75E8
075DC:  MOVF   x2C,W
075DE:  SUBWF  24,W
075E0:  BTFSS  FD8.0
075E2:  BRA    75E8
075E4:  MOVLB  0
075E6:  BRA    75FC
....................                 if (ponteiro_lcd == 1){ 
075E8:  DECFSZ 21,W
075EA:  BRA    75F6
....................                     inicial_lcd --; 
075EC:  DECF   22,F
....................                     final_lcd --; 
075EE:  DECF   23,F
....................                     ponteiro_lcd = 1; 
075F0:  MOVLW  01
075F2:  MOVWF  21
....................                 } else { 
075F4:  BRA    75F8
....................                     ponteiro_lcd --; 
075F6:  DECF   21,F
....................                 }                 
....................             } else { 
075F8:  BRA    760A
075FA:  MOVLB  0
....................                 contador_lcd = 0; 
075FC:  CLRF   24
....................                 inicial_lcd = 0; 
075FE:  CLRF   22
....................                 final_lcd = 3; 
07600:  MOVLW  03
07602:  MOVWF  23
....................                 ponteiro_lcd = 1; 
07604:  MOVLW  01
07606:  MOVWF  21
07608:  MOVLB  1
....................             } 
....................             menu_atual = menu_seleciona_pontos; 
0760A:  MOVLW  0F
0760C:  MOVWF  1C
....................             tela_seleciona_pontos(); 
0760E:  MOVLB  0
07610:  RCALL  727A
....................         break; 
07612:  BRA    77E8
....................         case SETA_INFERIOR: 
....................             contador_lcd ++; 
07614:  INCF   24,F
....................             if (contador_lcd < pontos_no_modelo){ 
07616:  MOVLB  1
07618:  MOVF   x2D,F
0761A:  BNZ   7622
0761C:  MOVF   x2C,W
0761E:  SUBWF  24,W
07620:  BC    7636
....................                 if (ponteiro_lcd == 4){ 
07622:  MOVF   21,W
07624:  SUBLW  04
07626:  BNZ   7632
....................                     inicial_lcd ++; 
07628:  INCF   22,F
....................                     final_lcd ++; 
0762A:  INCF   23,F
....................                     ponteiro_lcd = 4; 
0762C:  MOVLW  04
0762E:  MOVWF  21
....................                 } else { 
07630:  BRA    7634
....................                     ponteiro_lcd ++; 
07632:  INCF   21,F
....................                 } 
....................             } else { 
07634:  BRA    763C
....................                 contador_lcd = pontos_no_modelo-1; 
07636:  MOVLW  01
07638:  SUBWF  x2C,W
0763A:  MOVWF  24
....................             } 
....................             menu_atual = menu_seleciona_pontos; 
0763C:  MOVLW  0F
0763E:  MOVWF  1C
....................             tela_seleciona_pontos(); 
07640:  MOVLB  0
07642:  RCALL  727A
....................         break; 
07644:  BRA    77E8
....................         case ENTER: 
....................             ponteiro_lcd = 1; 
07646:  MOVLW  01
07648:  MOVWF  21
....................             inicial_lcd = 0; 
0764A:  CLRF   22
....................             final_lcd = 3; 
0764C:  MOVLW  03
0764E:  MOVWF  23
....................             if ((contador_lcd >= 14)&&(modelo == 1)){ 
07650:  MOVF   24,W
07652:  SUBLW  0D
07654:  BC    765C
07656:  DECFSZ 2F,W
07658:  BRA    765C
....................                 contador_lcd ++; 
0765A:  INCF   24,F
....................             } 
....................             motor_run_z(0, 19); 
0765C:  MOVLB  5
0765E:  CLRF   x80
07660:  CLRF   x7F
07662:  CLRF   x7E
07664:  CLRF   x7D
07666:  MOVLW  13
07668:  MOVWF  x81
0766A:  MOVLB  0
0766C:  CALL   5346
....................             while ((run_flg_z)); 
07670:  MOVLB  3
07672:  BTFSC  xB8.2
07674:  BRA    7672
....................             if ((y[contador_lcd] > 0) && (x[contador_lcd]> 0)){                 
07676:  BCF    FD8.0
07678:  RLCF   24,W
0767A:  CLRF   03
0767C:  ADDLW  5A
0767E:  MOVWF  FE9
07680:  MOVLW  00
07682:  ADDWFC 03,W
07684:  MOVWF  FEA
07686:  MOVFF  FEC,576
0768A:  MOVF   FED,F
0768C:  MOVFF  FEF,575
07690:  MOVLB  5
07692:  MOVF   x75,F
07694:  BNZ   769A
07696:  MOVF   x76,F
07698:  BZ    773C
0769A:  BCF    FD8.0
0769C:  RLCF   24,W
0769E:  CLRF   03
076A0:  ADDLW  30
076A2:  MOVWF  FE9
076A4:  MOVLW  00
076A6:  ADDWFC 03,W
076A8:  MOVWF  FEA
076AA:  MOVFF  FEC,576
076AE:  MOVF   FED,F
076B0:  MOVFF  FEF,575
076B4:  MOVF   x75,F
076B6:  BNZ   76BC
076B8:  MOVF   x76,F
076BA:  BZ    773C
....................                 motor_run_x(x[contador_lcd],19); 
076BC:  BCF    FD8.0
076BE:  RLCF   24,W
076C0:  CLRF   03
076C2:  ADDLW  30
076C4:  MOVWF  FE9
076C6:  MOVLW  00
076C8:  ADDWFC 03,W
076CA:  MOVWF  FEA
076CC:  MOVFF  FEC,576
076D0:  MOVF   FED,F
076D2:  MOVFF  FEF,575
076D6:  CLRF   x80
076D8:  CLRF   x7F
076DA:  MOVFF  576,57E
076DE:  MOVFF  575,57D
076E2:  MOVLW  13
076E4:  MOVWF  x81
076E6:  MOVLB  0
076E8:  CALL   5968
....................                 while ((run_flg_x)); 
076EC:  MOVLB  2
076EE:  BTFSC  x0C.5
076F0:  BRA    76EE
....................                 motor_run_y(y[contador_lcd],19); 
076F2:  BCF    FD8.0
076F4:  RLCF   24,W
076F6:  CLRF   03
076F8:  ADDLW  5A
076FA:  MOVWF  FE9
076FC:  MOVLW  00
076FE:  ADDWFC 03,W
07700:  MOVWF  FEA
07702:  MOVFF  FEC,576
07706:  MOVF   FED,F
07708:  MOVFF  FEF,575
0770C:  MOVLB  5
0770E:  CLRF   x80
07710:  CLRF   x7F
07712:  MOVFF  576,57E
07716:  MOVFF  575,57D
0771A:  MOVLW  13
0771C:  MOVWF  x81
0771E:  MOVLB  0
07720:  CALL   55A6
....................                 while ((run_flg_y)); 
07724:  MOVLB  2
07726:  BTFSC  x0C.7
07728:  BRA    7726
....................                 posicao_atual = SOLDAGEM; 
0772A:  MOVLW  03
0772C:  MOVWF  26
....................                 envia_posicao_para_outra_maquina(SOLDAGEM); 
0772E:  MOVLB  5
07730:  MOVWF  x79
07732:  MOVLB  0
07734:  CALL   4752
....................             } else { 
07738:  BRA    7794
0773A:  MOVLB  5
....................                 envia_maquina_para_posicao(SOLDAGEM); 
0773C:  MOVLW  03
0773E:  MOVWF  x78
07740:  MOVLB  0
07742:  CALL   5C9C
....................                 x[contador_lcd] = motor_pos_x; 
07746:  BCF    FD8.0
07748:  RLCF   24,W
0774A:  CLRF   03
0774C:  ADDLW  30
0774E:  MOVWF  FE9
07750:  MOVLW  00
07752:  ADDWFC 03,W
07754:  MOVWF  FEA
07756:  MOVFF  205,FEC
0775A:  MOVF   FED,F
0775C:  MOVFF  204,FEF
....................                 y[contador_lcd] = motor_pos_y; 
07760:  BCF    FD8.0
07762:  RLCF   24,W
07764:  CLRF   03
07766:  ADDLW  5A
07768:  MOVWF  FE9
0776A:  MOVLW  00
0776C:  ADDWFC 03,W
0776E:  MOVWF  FEA
07770:  MOVFF  207,FEC
07774:  MOVF   FED,F
07776:  MOVFF  206,FEF
....................                 z[contador_lcd] = motor_pos_z; 
0777A:  BCF    FD8.0
0777C:  RLCF   24,W
0777E:  CLRF   03
07780:  ADDLW  84
07782:  MOVWF  FE9
07784:  MOVLW  00
07786:  ADDWFC 03,W
07788:  MOVWF  FEA
0778A:  MOVFF  20B,FEC
0778E:  MOVF   FED,F
07790:  MOVFF  20A,FEF
....................             } 
....................             menu_atual = menu_dados_ponto; 
07794:  MOVLW  10
07796:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
07798:  MOVFF  24,576
0779C:  RCALL  7376
....................         break; 
0779E:  BRA    77E8
....................         case ESC: 
....................             envia_maquina_para_posicao(HOME1); 
077A0:  MOVLW  01
077A2:  MOVLB  5
077A4:  MOVWF  x78
077A6:  MOVLB  0
077A8:  CALL   5C9C
....................             envia_maquina_para_posicao(ALIMENTADOR); 
077AC:  MOVLB  5
077AE:  CLRF   x78
077B0:  MOVLB  0
077B2:  CALL   5C9C
....................             desliga_pressor(); 
077B6:  RCALL  75AC
....................             motor_run_z(0, 19); 
077B8:  MOVLB  5
077BA:  CLRF   x80
077BC:  CLRF   x7F
077BE:  CLRF   x7E
077C0:  CLRF   x7D
077C2:  MOVLW  13
077C4:  MOVWF  x81
077C6:  MOVLB  0
077C8:  CALL   5346
....................             while ((run_flg_z)); 
077CC:  MOVLB  3
077CE:  BTFSC  xB8.2
077D0:  BRA    77CE
....................             ponteiro_lcd = 1; 
077D2:  MOVLW  01
077D4:  MOVWF  21
....................             inicial_lcd = 0; 
077D6:  CLRF   22
....................             final_lcd = 3; 
077D8:  MOVLW  03
077DA:  MOVWF  23
....................             contador_lcd = 0; 
077DC:  CLRF   24
....................             menu_atual = menu_seleciona_debug; 
077DE:  MOVLW  02
077E0:  MOVWF  1C
....................             tela_seleciona_debug(); 
077E2:  MOVLB  0
077E4:  CALL   6EAE
....................         break; 
....................     } 
077E8:  GOTO   D88A (RETURN)
.................... } 
.................... void atualiza_tela_dados_ponto(){ 
....................     short int f; 
....................     switch (Teclado()){ 
*
09354:  CALL   6564
09358:  MOVF   01,W
0935A:  ADDLW  EC
0935C:  BTFSC  FD8.0
0935E:  GOTO   9E80
09362:  ADDLW  14
09364:  GOTO   9E84
....................         case SETA_SUPERIOR: 
....................             if (y[contador_lcd] > 0){ 
09368:  BCF    FD8.0
0936A:  RLCF   24,W
0936C:  CLRF   03
0936E:  ADDLW  5A
09370:  MOVWF  FE9
09372:  MOVLW  00
09374:  ADDWFC 03,W
09376:  MOVWF  FEA
09378:  MOVFF  FEC,577
0937C:  MOVF   FED,F
0937E:  MOVFF  FEF,576
09382:  MOVLB  5
09384:  MOVF   x76,F
09386:  BNZ   938C
09388:  MOVF   x77,F
0938A:  BZ    9450
....................                 y[contador_lcd] = y[contador_lcd] - incremento; 
0938C:  BCF    FD8.0
0938E:  RLCF   24,W
09390:  CLRF   03
09392:  ADDLW  5A
09394:  MOVWF  01
09396:  MOVLW  00
09398:  ADDWFC 03,F
0939A:  MOVFF  03,577
0939E:  BCF    FD8.0
093A0:  RLCF   24,W
093A2:  CLRF   03
093A4:  ADDLW  5A
093A6:  MOVWF  FE9
093A8:  MOVLW  00
093AA:  ADDWFC 03,W
093AC:  MOVWF  FEA
093AE:  MOVFF  FEC,579
093B2:  MOVF   FED,F
093B4:  MOVFF  FEF,578
093B8:  CLRF   03
093BA:  MOVF   25,W
093BC:  MOVWF  00
093BE:  BTFSC  FE8.7
093C0:  DECF   03,F
093C2:  SUBWF  x78,W
093C4:  MOVWF  00
093C6:  MOVF   03,W
093C8:  SUBWFB x79,W
093CA:  MOVFF  577,FEA
093CE:  MOVFF  01,FE9
093D2:  MOVWF  FEC
093D4:  MOVF   FED,F
093D6:  MOVFF  00,FEF
....................                 if (y[contador_lcd] <= 0) { 
093DA:  BCF    FD8.0
093DC:  RLCF   24,W
093DE:  CLRF   03
093E0:  ADDLW  5A
093E2:  MOVWF  FE9
093E4:  MOVLW  00
093E6:  ADDWFC 03,W
093E8:  MOVWF  FEA
093EA:  MOVFF  FEC,577
093EE:  MOVF   FED,F
093F0:  MOVFF  FEF,576
093F4:  MOVF   x76,F
093F6:  BNZ   9418
093F8:  MOVF   x77,F
093FA:  BNZ   9418
....................                     motor_run_y(0,19); 
093FC:  CLRF   x80
093FE:  CLRF   x7F
09400:  CLRF   x7E
09402:  CLRF   x7D
09404:  MOVLW  13
09406:  MOVWF  x81
09408:  MOVLB  0
0940A:  CALL   55A6
....................                     while ((run_flg_y)); 
0940E:  MOVLB  2
09410:  BTFSC  x0C.7
09412:  BRA    9410
....................                 } else { 
09414:  BRA    944E
09416:  MOVLB  5
....................                     motor_run_y(y[contador_lcd],19); 
09418:  BCF    FD8.0
0941A:  RLCF   24,W
0941C:  CLRF   03
0941E:  ADDLW  5A
09420:  MOVWF  FE9
09422:  MOVLW  00
09424:  ADDWFC 03,W
09426:  MOVWF  FEA
09428:  MOVFF  FEC,577
0942C:  MOVF   FED,F
0942E:  MOVFF  FEF,576
09432:  CLRF   x80
09434:  CLRF   x7F
09436:  MOVFF  577,57E
0943A:  MOVFF  576,57D
0943E:  MOVLW  13
09440:  MOVWF  x81
09442:  MOVLB  0
09444:  CALL   55A6
....................                     while ((run_flg_y)); 
09448:  MOVLB  2
0944A:  BTFSC  x0C.7
0944C:  BRA    944A
0944E:  MOVLB  5
....................                 }             
....................             } 
....................             menu_atual = menu_dados_ponto; 
09450:  MOVLW  10
09452:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
09454:  MOVFF  24,576
09458:  MOVLB  0
0945A:  CALL   7376
....................         break; 
0945E:  GOTO   9E80
....................         case SETA_INFERIOR: 
....................             y[contador_lcd] = y[contador_lcd] + incremento; 
09462:  BCF    FD8.0
09464:  RLCF   24,W
09466:  CLRF   03
09468:  ADDLW  5A
0946A:  MOVWF  01
0946C:  MOVLW  00
0946E:  ADDWFC 03,F
09470:  MOVFF  01,576
09474:  MOVLB  5
09476:  MOVFF  03,577
0947A:  BCF    FD8.0
0947C:  RLCF   24,W
0947E:  CLRF   03
09480:  ADDLW  5A
09482:  MOVWF  FE9
09484:  MOVLW  00
09486:  ADDWFC 03,W
09488:  MOVWF  FEA
0948A:  MOVFF  FEC,579
0948E:  MOVF   FED,F
09490:  MOVFF  FEF,578
09494:  CLRF   03
09496:  MOVF   25,W
09498:  BTFSC  FE8.7
0949A:  DECF   03,F
0949C:  ADDWF  x78,W
0949E:  MOVWF  01
094A0:  MOVF   x79,W
094A2:  ADDWFC 03,F
094A4:  MOVFF  577,FEA
094A8:  MOVFF  576,FE9
094AC:  MOVFF  03,FEC
094B0:  MOVF   FED,F
094B2:  MOVFF  01,FEF
....................             motor_run_y(y[contador_lcd],19); 
094B6:  BCF    FD8.0
094B8:  RLCF   24,W
094BA:  CLRF   03
094BC:  ADDLW  5A
094BE:  MOVWF  FE9
094C0:  MOVLW  00
094C2:  ADDWFC 03,W
094C4:  MOVWF  FEA
094C6:  MOVFF  FEC,577
094CA:  MOVF   FED,F
094CC:  MOVFF  FEF,576
094D0:  CLRF   x80
094D2:  CLRF   x7F
094D4:  MOVFF  577,57E
094D8:  MOVFF  576,57D
094DC:  MOVLW  13
094DE:  MOVWF  x81
094E0:  MOVLB  0
094E2:  CALL   55A6
....................             while ((run_flg_y)); 
094E6:  MOVLB  2
094E8:  BTFSC  x0C.7
094EA:  BRA    94E8
....................             menu_atual = menu_dados_ponto; 
094EC:  MOVLW  10
094EE:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
094F0:  MOVFF  24,576
094F4:  MOVLB  0
094F6:  CALL   7376
....................         break; 
094FA:  GOTO   9E80
....................         case SETA_DIREITA: 
....................             x[contador_lcd] = x[contador_lcd] + incremento; 
094FE:  BCF    FD8.0
09500:  RLCF   24,W
09502:  CLRF   03
09504:  ADDLW  30
09506:  MOVWF  01
09508:  MOVLW  00
0950A:  ADDWFC 03,F
0950C:  MOVFF  01,576
09510:  MOVLB  5
09512:  MOVFF  03,577
09516:  BCF    FD8.0
09518:  RLCF   24,W
0951A:  CLRF   03
0951C:  ADDLW  30
0951E:  MOVWF  FE9
09520:  MOVLW  00
09522:  ADDWFC 03,W
09524:  MOVWF  FEA
09526:  MOVFF  FEC,579
0952A:  MOVF   FED,F
0952C:  MOVFF  FEF,578
09530:  CLRF   03
09532:  MOVF   25,W
09534:  BTFSC  FE8.7
09536:  DECF   03,F
09538:  ADDWF  x78,W
0953A:  MOVWF  01
0953C:  MOVF   x79,W
0953E:  ADDWFC 03,F
09540:  MOVFF  577,FEA
09544:  MOVFF  576,FE9
09548:  MOVFF  03,FEC
0954C:  MOVF   FED,F
0954E:  MOVFF  01,FEF
....................             motor_run_x(x[contador_lcd],19); 
09552:  BCF    FD8.0
09554:  RLCF   24,W
09556:  CLRF   03
09558:  ADDLW  30
0955A:  MOVWF  FE9
0955C:  MOVLW  00
0955E:  ADDWFC 03,W
09560:  MOVWF  FEA
09562:  MOVFF  FEC,577
09566:  MOVF   FED,F
09568:  MOVFF  FEF,576
0956C:  CLRF   x80
0956E:  CLRF   x7F
09570:  MOVFF  577,57E
09574:  MOVFF  576,57D
09578:  MOVLW  13
0957A:  MOVWF  x81
0957C:  MOVLB  0
0957E:  CALL   5968
....................             while ((run_flg_x)); 
09582:  MOVLB  2
09584:  BTFSC  x0C.5
09586:  BRA    9584
....................             menu_atual = menu_dados_ponto; 
09588:  MOVLW  10
0958A:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
0958C:  MOVFF  24,576
09590:  MOVLB  0
09592:  CALL   7376
....................         break; 
09596:  GOTO   9E80
....................         case SETA_ESQUERDA: 
....................             if (x[contador_lcd] > 0){ 
0959A:  BCF    FD8.0
0959C:  RLCF   24,W
0959E:  CLRF   03
095A0:  ADDLW  30
095A2:  MOVWF  FE9
095A4:  MOVLW  00
095A6:  ADDWFC 03,W
095A8:  MOVWF  FEA
095AA:  MOVFF  FEC,577
095AE:  MOVF   FED,F
095B0:  MOVFF  FEF,576
095B4:  MOVLB  5
095B6:  MOVF   x76,F
095B8:  BNZ   95BE
095BA:  MOVF   x77,F
095BC:  BZ    9682
....................                 x[contador_lcd] = x[contador_lcd] - incremento; 
095BE:  BCF    FD8.0
095C0:  RLCF   24,W
095C2:  CLRF   03
095C4:  ADDLW  30
095C6:  MOVWF  01
095C8:  MOVLW  00
095CA:  ADDWFC 03,F
095CC:  MOVFF  03,577
095D0:  BCF    FD8.0
095D2:  RLCF   24,W
095D4:  CLRF   03
095D6:  ADDLW  30
095D8:  MOVWF  FE9
095DA:  MOVLW  00
095DC:  ADDWFC 03,W
095DE:  MOVWF  FEA
095E0:  MOVFF  FEC,579
095E4:  MOVF   FED,F
095E6:  MOVFF  FEF,578
095EA:  CLRF   03
095EC:  MOVF   25,W
095EE:  MOVWF  00
095F0:  BTFSC  FE8.7
095F2:  DECF   03,F
095F4:  SUBWF  x78,W
095F6:  MOVWF  00
095F8:  MOVF   03,W
095FA:  SUBWFB x79,W
095FC:  MOVFF  577,FEA
09600:  MOVFF  01,FE9
09604:  MOVWF  FEC
09606:  MOVF   FED,F
09608:  MOVFF  00,FEF
....................                 if (x[contador_lcd] <= 0){ 
0960C:  BCF    FD8.0
0960E:  RLCF   24,W
09610:  CLRF   03
09612:  ADDLW  30
09614:  MOVWF  FE9
09616:  MOVLW  00
09618:  ADDWFC 03,W
0961A:  MOVWF  FEA
0961C:  MOVFF  FEC,577
09620:  MOVF   FED,F
09622:  MOVFF  FEF,576
09626:  MOVF   x76,F
09628:  BNZ   964A
0962A:  MOVF   x77,F
0962C:  BNZ   964A
....................                     motor_run_x(0,19); 
0962E:  CLRF   x80
09630:  CLRF   x7F
09632:  CLRF   x7E
09634:  CLRF   x7D
09636:  MOVLW  13
09638:  MOVWF  x81
0963A:  MOVLB  0
0963C:  CALL   5968
....................                     while ((run_flg_x)); 
09640:  MOVLB  2
09642:  BTFSC  x0C.5
09644:  BRA    9642
....................                 } else{ 
09646:  BRA    9680
09648:  MOVLB  5
....................                     motor_run_x(x[contador_lcd],19); 
0964A:  BCF    FD8.0
0964C:  RLCF   24,W
0964E:  CLRF   03
09650:  ADDLW  30
09652:  MOVWF  FE9
09654:  MOVLW  00
09656:  ADDWFC 03,W
09658:  MOVWF  FEA
0965A:  MOVFF  FEC,577
0965E:  MOVF   FED,F
09660:  MOVFF  FEF,576
09664:  CLRF   x80
09666:  CLRF   x7F
09668:  MOVFF  577,57E
0966C:  MOVFF  576,57D
09670:  MOVLW  13
09672:  MOVWF  x81
09674:  MOVLB  0
09676:  CALL   5968
....................                     while ((run_flg_x)); 
0967A:  MOVLB  2
0967C:  BTFSC  x0C.5
0967E:  BRA    967C
09680:  MOVLB  5
....................                 }                 
....................             } 
....................             menu_atual = menu_dados_ponto; 
09682:  MOVLW  10
09684:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
09686:  MOVFF  24,576
0968A:  MOVLB  0
0968C:  CALL   7376
....................         break; 
09690:  GOTO   9E80
....................         case F2: 
....................             if (z[contador_lcd] > 0){ 
09694:  BCF    FD8.0
09696:  RLCF   24,W
09698:  CLRF   03
0969A:  ADDLW  84
0969C:  MOVWF  FE9
0969E:  MOVLW  00
096A0:  ADDWFC 03,W
096A2:  MOVWF  FEA
096A4:  MOVFF  FEC,577
096A8:  MOVF   FED,F
096AA:  MOVFF  FEF,576
096AE:  MOVLB  5
096B0:  MOVF   x76,F
096B2:  BNZ   96B8
096B4:  MOVF   x77,F
096B6:  BZ    977C
....................                 z[contador_lcd] = z[contador_lcd] -incremento; 
096B8:  BCF    FD8.0
096BA:  RLCF   24,W
096BC:  CLRF   03
096BE:  ADDLW  84
096C0:  MOVWF  01
096C2:  MOVLW  00
096C4:  ADDWFC 03,F
096C6:  MOVFF  03,577
096CA:  BCF    FD8.0
096CC:  RLCF   24,W
096CE:  CLRF   03
096D0:  ADDLW  84
096D2:  MOVWF  FE9
096D4:  MOVLW  00
096D6:  ADDWFC 03,W
096D8:  MOVWF  FEA
096DA:  MOVFF  FEC,579
096DE:  MOVF   FED,F
096E0:  MOVFF  FEF,578
096E4:  CLRF   03
096E6:  MOVF   25,W
096E8:  MOVWF  00
096EA:  BTFSC  FE8.7
096EC:  DECF   03,F
096EE:  SUBWF  x78,W
096F0:  MOVWF  00
096F2:  MOVF   03,W
096F4:  SUBWFB x79,W
096F6:  MOVFF  577,FEA
096FA:  MOVFF  01,FE9
096FE:  MOVWF  FEC
09700:  MOVF   FED,F
09702:  MOVFF  00,FEF
....................                 if (z[contador_lcd] <= 0){ 
09706:  BCF    FD8.0
09708:  RLCF   24,W
0970A:  CLRF   03
0970C:  ADDLW  84
0970E:  MOVWF  FE9
09710:  MOVLW  00
09712:  ADDWFC 03,W
09714:  MOVWF  FEA
09716:  MOVFF  FEC,577
0971A:  MOVF   FED,F
0971C:  MOVFF  FEF,576
09720:  MOVF   x76,F
09722:  BNZ   9744
09724:  MOVF   x77,F
09726:  BNZ   9744
....................                     motor_run_z(0,19); 
09728:  CLRF   x80
0972A:  CLRF   x7F
0972C:  CLRF   x7E
0972E:  CLRF   x7D
09730:  MOVLW  13
09732:  MOVWF  x81
09734:  MOVLB  0
09736:  CALL   5346
....................                     while ((run_flg_z)); 
0973A:  MOVLB  3
0973C:  BTFSC  xB8.2
0973E:  BRA    973C
....................                 } else { 
09740:  BRA    977A
09742:  MOVLB  5
....................                     motor_run_z(z[contador_lcd],19); 
09744:  BCF    FD8.0
09746:  RLCF   24,W
09748:  CLRF   03
0974A:  ADDLW  84
0974C:  MOVWF  FE9
0974E:  MOVLW  00
09750:  ADDWFC 03,W
09752:  MOVWF  FEA
09754:  MOVFF  FEC,577
09758:  MOVF   FED,F
0975A:  MOVFF  FEF,576
0975E:  CLRF   x80
09760:  CLRF   x7F
09762:  MOVFF  577,57E
09766:  MOVFF  576,57D
0976A:  MOVLW  13
0976C:  MOVWF  x81
0976E:  MOVLB  0
09770:  CALL   5346
....................                     while ((run_flg_z)); 
09774:  MOVLB  3
09776:  BTFSC  xB8.2
09778:  BRA    9776
0977A:  MOVLB  5
....................                 } 
....................             } 
....................             menu_atual = menu_dados_ponto; 
0977C:  MOVLW  10
0977E:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
09780:  MOVFF  24,576
09784:  MOVLB  0
09786:  CALL   7376
....................         break; 
0978A:  BRA    9E80
....................         case F4:        
....................             z[contador_lcd] = z[contador_lcd] +incremento; 
0978C:  BCF    FD8.0
0978E:  RLCF   24,W
09790:  CLRF   03
09792:  ADDLW  84
09794:  MOVWF  01
09796:  MOVLW  00
09798:  ADDWFC 03,F
0979A:  MOVFF  01,576
0979E:  MOVLB  5
097A0:  MOVFF  03,577
097A4:  BCF    FD8.0
097A6:  RLCF   24,W
097A8:  CLRF   03
097AA:  ADDLW  84
097AC:  MOVWF  FE9
097AE:  MOVLW  00
097B0:  ADDWFC 03,W
097B2:  MOVWF  FEA
097B4:  MOVFF  FEC,579
097B8:  MOVF   FED,F
097BA:  MOVFF  FEF,578
097BE:  CLRF   03
097C0:  MOVF   25,W
097C2:  BTFSC  FE8.7
097C4:  DECF   03,F
097C6:  ADDWF  x78,W
097C8:  MOVWF  01
097CA:  MOVF   x79,W
097CC:  ADDWFC 03,F
097CE:  MOVFF  577,FEA
097D2:  MOVFF  576,FE9
097D6:  MOVFF  03,FEC
097DA:  MOVF   FED,F
097DC:  MOVFF  01,FEF
....................             motor_run_z(z[contador_lcd],19); 
097E0:  BCF    FD8.0
097E2:  RLCF   24,W
097E4:  CLRF   03
097E6:  ADDLW  84
097E8:  MOVWF  FE9
097EA:  MOVLW  00
097EC:  ADDWFC 03,W
097EE:  MOVWF  FEA
097F0:  MOVFF  FEC,577
097F4:  MOVF   FED,F
097F6:  MOVFF  FEF,576
097FA:  CLRF   x80
097FC:  CLRF   x7F
097FE:  MOVFF  577,57E
09802:  MOVFF  576,57D
09806:  MOVLW  13
09808:  MOVWF  x81
0980A:  MOVLB  0
0980C:  CALL   5346
....................             while ((run_flg_z)); 
09810:  MOVLB  3
09812:  BTFSC  xB8.2
09814:  BRA    9812
....................             menu_atual = menu_dados_ponto; 
09816:  MOVLW  10
09818:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
0981A:  MOVFF  24,576
0981E:  MOVLB  0
09820:  CALL   7376
....................         break; 
09824:  BRA    9E80
....................         case 1: 
....................             switch (tipo[contador_lcd]){ 
09826:  BCF    FD8.0
09828:  RLCF   24,W
0982A:  CLRF   03
0982C:  ADDLW  02
0982E:  MOVWF  FE9
09830:  MOVLW  01
09832:  ADDWFC 03,W
09834:  MOVWF  FEA
09836:  MOVFF  FEF,00
0983A:  INCF   FE9,F
0983C:  MOVF   FEF,W
0983E:  DECF   FE9,F
09840:  MOVWF  03
09842:  MOVF   03,W
09844:  BNZ   984A
09846:  MOVF   00,F
09848:  BZ    9856
0984A:  MOVF   03,W
0984C:  BNZ   9854
0984E:  MOVLW  01
09850:  SUBWF  00,W
09852:  BZ    9870
09854:  BRA    9886
....................                 case 0: 
....................                     tipo[contador_lcd] = 1; 
09856:  BCF    FD8.0
09858:  RLCF   24,W
0985A:  CLRF   03
0985C:  ADDLW  02
0985E:  MOVWF  FE9
09860:  MOVLW  01
09862:  ADDWFC 03,W
09864:  MOVWF  FEA
09866:  CLRF   FEC
09868:  MOVF   FED,F
0986A:  MOVLW  01
0986C:  MOVWF  FEF
....................                 break; 
0986E:  BRA    9886
....................                 case 1: 
....................                     tipo[contador_lcd] = 0; 
09870:  BCF    FD8.0
09872:  RLCF   24,W
09874:  CLRF   03
09876:  ADDLW  02
09878:  MOVWF  FE9
0987A:  MOVLW  01
0987C:  ADDWFC 03,W
0987E:  MOVWF  FEA
09880:  CLRF   FEC
09882:  MOVF   FED,F
09884:  CLRF   FEF
....................                 break; 
....................             } 
....................             menu_atual = menu_dados_ponto; 
09886:  MOVLW  10
09888:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
0988A:  MOVFF  24,576
0988E:  CALL   7376
....................         break; 
09892:  BRA    9E80
....................         case 2: 
....................             if (habilitado[contador_lcd] == TRUE){ 
09894:  BCF    FD8.0
09896:  RLCF   24,W
09898:  CLRF   03
0989A:  ADDLW  2E
0989C:  MOVWF  FE9
0989E:  MOVLW  01
098A0:  ADDWFC 03,W
098A2:  MOVWF  FEA
098A4:  MOVFF  FEC,577
098A8:  MOVF   FED,F
098AA:  MOVFF  FEF,576
098AE:  MOVLB  5
098B0:  DECFSZ x76,W
098B2:  BRA    98D0
098B4:  MOVF   x77,F
098B6:  BNZ   98D0
....................                 habilitado[contador_lcd] = FALSE; 
098B8:  BCF    FD8.0
098BA:  RLCF   24,W
098BC:  CLRF   03
098BE:  ADDLW  2E
098C0:  MOVWF  FE9
098C2:  MOVLW  01
098C4:  ADDWFC 03,W
098C6:  MOVWF  FEA
098C8:  CLRF   FEC
098CA:  MOVF   FED,F
098CC:  CLRF   FEF
....................             } else { 
098CE:  BRA    98E8
....................                 habilitado[contador_lcd] = TRUE; 
098D0:  BCF    FD8.0
098D2:  RLCF   24,W
098D4:  CLRF   03
098D6:  ADDLW  2E
098D8:  MOVWF  FE9
098DA:  MOVLW  01
098DC:  ADDWFC 03,W
098DE:  MOVWF  FEA
098E0:  CLRF   FEC
098E2:  MOVF   FED,F
098E4:  MOVLW  01
098E6:  MOVWF  FEF
....................             }             
....................             menu_atual = menu_dados_ponto; 
098E8:  MOVLW  10
098EA:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
098EC:  MOVFF  24,576
098F0:  MOVLB  0
098F2:  CALL   7376
....................         break; 
098F6:  BRA    9E80
....................         case 8:           
....................             sobe_ferros(); 
098F8:  CALL   781C
....................             desliga_pressor(); 
098FC:  CALL   75AC
....................         break; 
09900:  BRA    9E80
....................         case 0: 
....................             sobe_ferros(); 
09902:  CALL   781C
....................             if (numeroFerros[contador_lcd] == 0){ 
09906:  BCF    FD8.0
09908:  RLCF   24,W
0990A:  CLRF   03
0990C:  ADDLW  58
0990E:  MOVWF  FE9
09910:  MOVLW  01
09912:  ADDWFC 03,W
09914:  MOVWF  FEA
09916:  MOVFF  FEC,577
0991A:  MOVF   FED,F
0991C:  MOVFF  FEF,576
09920:  MOVLB  5
09922:  MOVF   x76,F
09924:  BNZ   9934
09926:  MOVF   x77,F
09928:  BNZ   9934
....................                 desce_ferros(0); 
0992A:  CLRF   x7D
0992C:  MOVLB  0
0992E:  CALL   783A
09932:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){ 
09934:  BCF    FD8.0
09936:  RLCF   24,W
09938:  CLRF   03
0993A:  ADDLW  58
0993C:  MOVWF  FE9
0993E:  MOVLW  01
09940:  ADDWFC 03,W
09942:  MOVWF  FEA
09944:  MOVFF  FEC,577
09948:  MOVF   FED,F
0994A:  MOVFF  FEF,576
0994E:  DECFSZ x76,W
09950:  BRA    9962
09952:  MOVF   x77,F
09954:  BNZ   9962
....................                 desce_ferros(1); 
09956:  MOVLW  01
09958:  MOVWF  x7D
0995A:  MOVLB  0
0995C:  CALL   783A
09960:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){ 
09962:  BCF    FD8.0
09964:  RLCF   24,W
09966:  CLRF   03
09968:  ADDLW  58
0996A:  MOVWF  FE9
0996C:  MOVLW  01
0996E:  ADDWFC 03,W
09970:  MOVWF  FEA
09972:  MOVFF  FEC,577
09976:  MOVF   FED,F
09978:  MOVFF  FEF,576
0997C:  MOVF   x76,W
0997E:  SUBLW  02
09980:  BNZ   9992
09982:  MOVF   x77,F
09984:  BNZ   9992
....................                 desce_ferros(2); 
09986:  MOVLW  02
09988:  MOVWF  x7D
0998A:  MOVLB  0
0998C:  CALL   783A
09990:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
09992:  BCF    FD8.0
09994:  RLCF   24,W
09996:  CLRF   03
09998:  ADDLW  58
0999A:  MOVWF  FE9
0999C:  MOVLW  01
0999E:  ADDWFC 03,W
099A0:  MOVWF  FEA
099A2:  MOVFF  FEC,577
099A6:  MOVF   FED,F
099A8:  MOVFF  FEF,576
099AC:  MOVF   x76,W
099AE:  SUBLW  03
099B0:  BNZ   99C2
099B2:  MOVF   x77,F
099B4:  BNZ   99C2
....................                 desce_ferros(3); 
099B6:  MOVLW  03
099B8:  MOVWF  x7D
099BA:  MOVLB  0
099BC:  CALL   783A
099C0:  MOVLB  5
....................             } 
....................             liga_pressor(); 
099C2:  MOVLB  0
099C4:  CALL   788C
....................         break; 
099C8:  BRA    9E80
....................         case 3: 
....................             switch (numeroFerros[contador_lcd]){ 
099CA:  BCF    FD8.0
099CC:  RLCF   24,W
099CE:  CLRF   03
099D0:  ADDLW  58
099D2:  MOVWF  FE9
099D4:  MOVLW  01
099D6:  ADDWFC 03,W
099D8:  MOVWF  FEA
099DA:  MOVFF  FEF,00
099DE:  INCF   FE9,F
099E0:  MOVF   FEF,W
099E2:  DECF   FE9,F
099E4:  MOVWF  03
099E6:  MOVF   03,W
099E8:  BNZ   99EE
099EA:  MOVF   00,F
099EC:  BZ    9A0E
099EE:  MOVF   03,W
099F0:  BNZ   99F8
099F2:  MOVLW  01
099F4:  SUBWF  00,W
099F6:  BZ    9A28
099F8:  MOVF   03,W
099FA:  BNZ   9A02
099FC:  MOVLW  02
099FE:  SUBWF  00,W
09A00:  BZ    9A42
09A02:  MOVF   03,W
09A04:  BNZ   9A0C
09A06:  MOVLW  03
09A08:  SUBWF  00,W
09A0A:  BZ    9A5C
09A0C:  BRA    9A72
....................                 case 0: 
....................                     numeroFerros[contador_lcd] = 1; 
09A0E:  BCF    FD8.0
09A10:  RLCF   24,W
09A12:  CLRF   03
09A14:  ADDLW  58
09A16:  MOVWF  FE9
09A18:  MOVLW  01
09A1A:  ADDWFC 03,W
09A1C:  MOVWF  FEA
09A1E:  CLRF   FEC
09A20:  MOVF   FED,F
09A22:  MOVLW  01
09A24:  MOVWF  FEF
....................                 break; 
09A26:  BRA    9A72
....................                 case 1: 
....................                     numeroFerros[contador_lcd] = 2; 
09A28:  BCF    FD8.0
09A2A:  RLCF   24,W
09A2C:  CLRF   03
09A2E:  ADDLW  58
09A30:  MOVWF  FE9
09A32:  MOVLW  01
09A34:  ADDWFC 03,W
09A36:  MOVWF  FEA
09A38:  CLRF   FEC
09A3A:  MOVF   FED,F
09A3C:  MOVLW  02
09A3E:  MOVWF  FEF
....................                 break; 
09A40:  BRA    9A72
....................                 case 2: 
....................                     numeroFerros[contador_lcd] = 3; 
09A42:  BCF    FD8.0
09A44:  RLCF   24,W
09A46:  CLRF   03
09A48:  ADDLW  58
09A4A:  MOVWF  FE9
09A4C:  MOVLW  01
09A4E:  ADDWFC 03,W
09A50:  MOVWF  FEA
09A52:  CLRF   FEC
09A54:  MOVF   FED,F
09A56:  MOVLW  03
09A58:  MOVWF  FEF
....................                 break; 
09A5A:  BRA    9A72
....................                 case 3: 
....................                     numeroFerros[contador_lcd] = 0; 
09A5C:  BCF    FD8.0
09A5E:  RLCF   24,W
09A60:  CLRF   03
09A62:  ADDLW  58
09A64:  MOVWF  FE9
09A66:  MOVLW  01
09A68:  ADDWFC 03,W
09A6A:  MOVWF  FEA
09A6C:  CLRF   FEC
09A6E:  MOVF   FED,F
09A70:  CLRF   FEF
....................                 break; 
....................             }             
....................             menu_atual = menu_dados_ponto; 
09A72:  MOVLW  10
09A74:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
09A76:  MOVFF  24,576
09A7A:  CALL   7376
....................         break; 
09A7E:  BRA    9E80
....................         case 4: 
....................             switch (incremento){ 
09A80:  MOVF   25,W
09A82:  XORLW  01
09A84:  BZ    9A90
09A86:  XORLW  0B
09A88:  BZ    9A96
09A8A:  XORLW  38
09A8C:  BZ    9A9C
09A8E:  BRA    9AA0
....................                 case 1: 
....................                     incremento = 10; 
09A90:  MOVLW  0A
09A92:  MOVWF  25
....................                 break; 
09A94:  BRA    9AA0
....................                 case 10: 
....................                     incremento = 50; 
09A96:  MOVLW  32
09A98:  MOVWF  25
....................                 break; 
09A9A:  BRA    9AA0
....................                 case 50: 
....................                     incremento = 1; 
09A9C:  MOVLW  01
09A9E:  MOVWF  25
....................                 break; 
....................             }             
....................             menu_atual = menu_dados_ponto; 
09AA0:  MOVLW  10
09AA2:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
09AA4:  MOVFF  24,576
09AA8:  CALL   7376
....................         break; 
09AAC:  BRA    9E80
....................         case 5: 
....................             switch (limpar[contador_lcd]){ 
09AAE:  BCF    FD8.0
09AB0:  RLCF   24,W
09AB2:  CLRF   03
09AB4:  ADDLW  D6
09AB6:  MOVWF  FE9
09AB8:  MOVLW  01
09ABA:  ADDWFC 03,W
09ABC:  MOVWF  FEA
09ABE:  MOVFF  FEF,00
09AC2:  INCF   FE9,F
09AC4:  MOVF   FEF,W
09AC6:  DECF   FE9,F
09AC8:  MOVWF  03
09ACA:  MOVF   03,W
09ACC:  BNZ   9AD2
09ACE:  MOVF   00,F
09AD0:  BZ    9ADE
09AD2:  MOVF   03,W
09AD4:  BNZ   9ADC
09AD6:  MOVLW  01
09AD8:  SUBWF  00,W
09ADA:  BZ    9AF8
09ADC:  BRA    9B0E
....................                 case 0: 
....................                     limpar[contador_lcd] = 1; 
09ADE:  BCF    FD8.0
09AE0:  RLCF   24,W
09AE2:  CLRF   03
09AE4:  ADDLW  D6
09AE6:  MOVWF  FE9
09AE8:  MOVLW  01
09AEA:  ADDWFC 03,W
09AEC:  MOVWF  FEA
09AEE:  CLRF   FEC
09AF0:  MOVF   FED,F
09AF2:  MOVLW  01
09AF4:  MOVWF  FEF
....................                 break; 
09AF6:  BRA    9B0E
....................                 case 1: 
....................                     limpar[contador_lcd] = 0; 
09AF8:  BCF    FD8.0
09AFA:  RLCF   24,W
09AFC:  CLRF   03
09AFE:  ADDLW  D6
09B00:  MOVWF  FE9
09B02:  MOVLW  01
09B04:  ADDWFC 03,W
09B06:  MOVWF  FEA
09B08:  CLRF   FEC
09B0A:  MOVF   FED,F
09B0C:  CLRF   FEF
....................                 break; 
....................             }             
....................             menu_atual = menu_dados_ponto; 
09B0E:  MOVLW  10
09B10:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
09B12:  MOVFF  24,576
09B16:  CALL   7376
....................         break; 
09B1A:  BRA    9E80
....................         case F1: 
....................             if ((numeroFerros[contador_lcd] == 0)||(numeroFerros[contador_lcd] == 2)){ 
09B1C:  BCF    FD8.0
09B1E:  RLCF   24,W
09B20:  CLRF   03
09B22:  ADDLW  58
09B24:  MOVWF  FE9
09B26:  MOVLW  01
09B28:  ADDWFC 03,W
09B2A:  MOVWF  FEA
09B2C:  MOVFF  FEC,577
09B30:  MOVF   FED,F
09B32:  MOVFF  FEF,576
09B36:  MOVLB  5
09B38:  MOVF   x76,F
09B3A:  BNZ   9B40
09B3C:  MOVF   x77,F
09B3E:  BZ    9B64
09B40:  BCF    FD8.0
09B42:  RLCF   24,W
09B44:  CLRF   03
09B46:  ADDLW  58
09B48:  MOVWF  FE9
09B4A:  MOVLW  01
09B4C:  ADDWFC 03,W
09B4E:  MOVWF  FEA
09B50:  MOVFF  FEC,577
09B54:  MOVF   FED,F
09B56:  MOVFF  FEF,576
09B5A:  MOVF   x76,W
09B5C:  SUBLW  02
09B5E:  BNZ   9B7A
09B60:  MOVF   x77,F
09B62:  BNZ   9B7A
....................                 t_solda[contador_lcd] = 0; 
09B64:  BCF    FD8.0
09B66:  RLCF   24,W
09B68:  CLRF   03
09B6A:  ADDLW  AE
09B6C:  MOVWF  FE9
09B6E:  MOVLW  00
09B70:  ADDWFC 03,W
09B72:  MOVWF  FEA
09B74:  CLRF   FEC
09B76:  MOVF   FED,F
09B78:  CLRF   FEF
....................             } 
....................             if ((numeroFerros[contador_lcd] == 0)||(numeroFerros[contador_lcd] == 1)){ 
09B7A:  BCF    FD8.0
09B7C:  RLCF   24,W
09B7E:  CLRF   03
09B80:  ADDLW  58
09B82:  MOVWF  FE9
09B84:  MOVLW  01
09B86:  ADDWFC 03,W
09B88:  MOVWF  FEA
09B8A:  MOVFF  FEC,577
09B8E:  MOVF   FED,F
09B90:  MOVFF  FEF,576
09B94:  MOVF   x76,F
09B96:  BNZ   9B9C
09B98:  MOVF   x77,F
09B9A:  BZ    9BBE
09B9C:  BCF    FD8.0
09B9E:  RLCF   24,W
09BA0:  CLRF   03
09BA2:  ADDLW  58
09BA4:  MOVWF  FE9
09BA6:  MOVLW  01
09BA8:  ADDWFC 03,W
09BAA:  MOVWF  FEA
09BAC:  MOVFF  FEC,577
09BB0:  MOVF   FED,F
09BB2:  MOVFF  FEF,576
09BB6:  DECFSZ x76,W
09BB8:  BRA    9BD4
09BBA:  MOVF   x77,F
09BBC:  BNZ   9BD4
....................                 t_solda3[contador_lcd] = 0; 
09BBE:  BCF    FD8.0
09BC0:  RLCF   24,W
09BC2:  CLRF   03
09BC4:  ADDLW  AC
09BC6:  MOVWF  FE9
09BC8:  MOVLW  01
09BCA:  ADDWFC 03,W
09BCC:  MOVWF  FEA
09BCE:  CLRF   FEC
09BD0:  MOVF   FED,F
09BD2:  CLRF   FEF
....................             } 
....................             printf(lcd_putc, "\f"); // limpa display 
09BD4:  MOVLW  0C
09BD6:  MOVWF  x86
09BD8:  MOVLB  0
09BDA:  CALL   2D32
....................             printf(lcd_putc, "   GRAVANDO PONTO   \n\r"); 
09BDE:  MOVLW  42
09BE0:  MOVWF  FF6
09BE2:  MOVLW  0F
09BE4:  MOVWF  FF7
09BE6:  CALL   2D86
....................             delay_ms(2000); 
09BEA:  MOVLW  08
09BEC:  MOVLB  5
09BEE:  MOVWF  x76
09BF0:  MOVLW  FA
09BF2:  MOVWF  x92
09BF4:  MOVLB  0
09BF6:  CALL   2958
09BFA:  MOVLB  5
09BFC:  DECFSZ x76,F
09BFE:  BRA    9BF0
....................             escrever_ponto_memoria(modelo,contador_lcd); 
09C00:  CLRF   x77
09C02:  MOVFF  2F,576
09C06:  CLRF   x79
09C08:  MOVFF  24,578
09C0C:  MOVLB  0
09C0E:  CALL   789C
....................             printf(lcd_putc, "\f"); // limpa display 
09C12:  MOVLW  0C
09C14:  MOVLB  5
09C16:  MOVWF  x86
09C18:  MOVLB  0
09C1A:  CALL   2D32
....................             printf(lcd_putc, "    PONTO GRAVADO   \n\r"); 
09C1E:  MOVLW  5A
09C20:  MOVWF  FF6
09C22:  MOVLW  0F
09C24:  MOVWF  FF7
09C26:  CALL   2D86
....................             delay_ms(2000); 
09C2A:  MOVLW  08
09C2C:  MOVLB  5
09C2E:  MOVWF  x76
09C30:  MOVLW  FA
09C32:  MOVWF  x92
09C34:  MOVLB  0
09C36:  CALL   2958
09C3A:  MOVLB  5
09C3C:  DECFSZ x76,F
09C3E:  BRA    9C30
....................             menu_atual = menu_seleciona_pontos; 
09C40:  MOVLW  0F
09C42:  MOVWF  1C
....................             tela_seleciona_pontos(); 
09C44:  MOVLB  0
09C46:  CALL   727A
....................             contador_lcd = 0; 
09C4A:  CLRF   24
....................             incremento = 1; 
09C4C:  MOVLW  01
09C4E:  MOVWF  25
....................             motor_run_z(0, 19); 
09C50:  MOVLB  5
09C52:  CLRF   x80
09C54:  CLRF   x7F
09C56:  CLRF   x7E
09C58:  CLRF   x7D
09C5A:  MOVLW  13
09C5C:  MOVWF  x81
09C5E:  MOVLB  0
09C60:  CALL   5346
....................             while ((run_flg_z)); 
09C64:  MOVLB  3
09C66:  BTFSC  xB8.2
09C68:  BRA    9C66
....................             sobe_ferros(); 
09C6A:  MOVLB  0
09C6C:  CALL   781C
....................         break; 
09C70:  BRA    9E80
....................         case F3:             
....................             menu_atual = menu_dados_ponto_2; 
09C72:  MOVLW  12
09C74:  MOVWF  1C
....................             if (numeroFerros[contador_lcd] == 0){ 
09C76:  BCF    FD8.0
09C78:  RLCF   24,W
09C7A:  CLRF   03
09C7C:  ADDLW  58
09C7E:  MOVWF  FE9
09C80:  MOVLW  01
09C82:  ADDWFC 03,W
09C84:  MOVWF  FEA
09C86:  MOVFF  FEC,577
09C8A:  MOVF   FED,F
09C8C:  MOVFF  FEF,576
09C90:  MOVLB  5
09C92:  MOVF   x76,F
09C94:  BNZ   9CA6
09C96:  MOVF   x77,F
09C98:  BNZ   9CA6
....................                 tela_dados_ponto_5(contador_lcd); 
09C9A:  MOVFF  24,576
09C9E:  MOVLB  0
09CA0:  CALL   7DDE
09CA4:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){ 
09CA6:  BCF    FD8.0
09CA8:  RLCF   24,W
09CAA:  CLRF   03
09CAC:  ADDLW  58
09CAE:  MOVWF  FE9
09CB0:  MOVLW  01
09CB2:  ADDWFC 03,W
09CB4:  MOVWF  FEA
09CB6:  MOVFF  FEC,577
09CBA:  MOVF   FED,F
09CBC:  MOVFF  FEF,576
09CC0:  DECFSZ x76,W
09CC2:  BRA    9CD4
09CC4:  MOVF   x77,F
09CC6:  BNZ   9CD4
....................                 tela_dados_ponto_4(contador_lcd); 
09CC8:  MOVFF  24,576
09CCC:  MOVLB  0
09CCE:  CALL   7EBC
09CD2:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){ 
09CD4:  BCF    FD8.0
09CD6:  RLCF   24,W
09CD8:  CLRF   03
09CDA:  ADDLW  58
09CDC:  MOVWF  FE9
09CDE:  MOVLW  01
09CE0:  ADDWFC 03,W
09CE2:  MOVWF  FEA
09CE4:  MOVFF  FEC,577
09CE8:  MOVF   FED,F
09CEA:  MOVFF  FEF,576
09CEE:  MOVF   x76,W
09CF0:  SUBLW  02
09CF2:  BNZ   9D04
09CF4:  MOVF   x77,F
09CF6:  BNZ   9D04
....................                 tela_dados_ponto_3(contador_lcd); 
09CF8:  MOVFF  24,576
09CFC:  MOVLB  0
09CFE:  CALL   7FD8
09D02:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
09D04:  BCF    FD8.0
09D06:  RLCF   24,W
09D08:  CLRF   03
09D0A:  ADDLW  58
09D0C:  MOVWF  FE9
09D0E:  MOVLW  01
09D10:  ADDWFC 03,W
09D12:  MOVWF  FEA
09D14:  MOVFF  FEC,577
09D18:  MOVF   FED,F
09D1A:  MOVFF  FEF,576
09D1E:  MOVF   x76,W
09D20:  SUBLW  03
09D22:  BNZ   9D34
09D24:  MOVF   x77,F
09D26:  BNZ   9D34
....................                 tela_dados_ponto_2(contador_lcd); 
09D28:  MOVFF  24,576
09D2C:  MOVLB  0
09D2E:  CALL   80F4
09D32:  MOVLB  5
....................             } 
....................             incremento = 1; 
09D34:  MOVLW  01
09D36:  MOVWF  25
....................             motor_run_z(0, 19); 
09D38:  CLRF   x80
09D3A:  CLRF   x7F
09D3C:  CLRF   x7E
09D3E:  CLRF   x7D
09D40:  MOVLW  13
09D42:  MOVWF  x81
09D44:  MOVLB  0
09D46:  CALL   5346
....................             while ((run_flg_z)); 
09D4A:  MOVLB  3
09D4C:  BTFSC  xB8.2
09D4E:  BRA    9D4C
....................             sobe_ferros(); 
09D50:  MOVLB  0
09D52:  CALL   781C
....................         break; 
09D56:  BRA    9E80
....................         case ESC: 
....................             incremento = 1; 
09D58:  MOVLW  01
09D5A:  MOVWF  25
....................             contador_lcd = 0; 
09D5C:  CLRF   24
....................             motor_run_z(0, 19); 
09D5E:  MOVLB  5
09D60:  CLRF   x80
09D62:  CLRF   x7F
09D64:  CLRF   x7E
09D66:  CLRF   x7D
09D68:  MOVLW  13
09D6A:  MOVWF  x81
09D6C:  MOVLB  0
09D6E:  CALL   5346
....................             while ((run_flg_z)); 
09D72:  MOVLB  3
09D74:  BTFSC  xB8.2
09D76:  BRA    9D74
....................             sobe_ferros(); 
09D78:  MOVLB  0
09D7A:  CALL   781C
....................             menu_atual = menu_seleciona_pontos; 
09D7E:  MOVLW  0F
09D80:  MOVWF  1C
....................             tela_seleciona_pontos(); 
09D82:  CALL   727A
....................         break; 
09D86:  BRA    9E80
....................         case ENTER: 
....................             incremento = 1; 
09D88:  MOVLW  01
09D8A:  MOVWF  25
....................             f = statusSolda(); 
09D8C:  CALL   824E
09D90:  MOVLB  5
09D92:  BCF    x75.0
09D94:  BTFSC  01.0
09D96:  BSF    x75.0
....................             if (f == 1){ 
09D98:  BTFSS  x75.0
09D9A:  BRA    9DC8
....................                 soldar_teste(tipo[contador_lcd],contador_lcd); 
09D9C:  BCF    FD8.0
09D9E:  RLCF   24,W
09DA0:  CLRF   03
09DA2:  ADDLW  02
09DA4:  MOVWF  FE9
09DA6:  MOVLW  01
09DA8:  ADDWFC 03,W
09DAA:  MOVWF  FEA
09DAC:  MOVFF  FEC,577
09DB0:  MOVF   FED,F
09DB2:  MOVFF  FEF,576
09DB6:  MOVFF  576,578
09DBA:  MOVFF  24,579
09DBE:  MOVLB  0
09DC0:  CALL   8C3C
....................             } else { 
09DC4:  BRA    9E02
09DC6:  MOVLB  5
....................                 printf(lcd_putc, "\f"); // limpa display 
09DC8:  MOVLW  0C
09DCA:  MOVWF  x86
09DCC:  MOVLB  0
09DCE:  CALL   2D32
....................                 printf(lcd_putc, "    SEM SOLDA NOS   \n\r"); 
09DD2:  MOVLW  72
09DD4:  MOVWF  FF6
09DD6:  MOVLW  0F
09DD8:  MOVWF  FF7
09DDA:  CALL   2D86
....................                 printf(lcd_putc, "    ALIMENTADORES   \n\r"); 
09DDE:  MOVLW  8A
09DE0:  MOVWF  FF6
09DE2:  MOVLW  0F
09DE4:  MOVWF  FF7
09DE6:  CALL   2D86
....................                 delay_ms(1000); 
09DEA:  MOVLW  04
09DEC:  MOVLB  5
09DEE:  MOVWF  x76
09DF0:  MOVLW  FA
09DF2:  MOVWF  x92
09DF4:  MOVLB  0
09DF6:  CALL   2958
09DFA:  MOVLB  5
09DFC:  DECFSZ x76,F
09DFE:  BRA    9DF0
09E00:  MOVLB  0
....................             } 
....................             motor_run_y(y[contador_lcd],19); 
09E02:  BCF    FD8.0
09E04:  RLCF   24,W
09E06:  CLRF   03
09E08:  ADDLW  5A
09E0A:  MOVWF  FE9
09E0C:  MOVLW  00
09E0E:  ADDWFC 03,W
09E10:  MOVWF  FEA
09E12:  MOVFF  FEC,577
09E16:  MOVF   FED,F
09E18:  MOVFF  FEF,576
09E1C:  MOVLB  5
09E1E:  CLRF   x80
09E20:  CLRF   x7F
09E22:  MOVFF  577,57E
09E26:  MOVFF  576,57D
09E2A:  MOVLW  13
09E2C:  MOVWF  x81
09E2E:  MOVLB  0
09E30:  CALL   55A6
....................             while ((run_flg_y)); 
09E34:  MOVLB  2
09E36:  BTFSC  x0C.7
09E38:  BRA    9E36
....................             motor_run_x(x[contador_lcd],19); 
09E3A:  BCF    FD8.0
09E3C:  RLCF   24,W
09E3E:  CLRF   03
09E40:  ADDLW  30
09E42:  MOVWF  FE9
09E44:  MOVLW  00
09E46:  ADDWFC 03,W
09E48:  MOVWF  FEA
09E4A:  MOVFF  FEC,577
09E4E:  MOVF   FED,F
09E50:  MOVFF  FEF,576
09E54:  MOVLB  5
09E56:  CLRF   x80
09E58:  CLRF   x7F
09E5A:  MOVFF  577,57E
09E5E:  MOVFF  576,57D
09E62:  MOVLW  13
09E64:  MOVWF  x81
09E66:  MOVLB  0
09E68:  CALL   5968
....................             while ((run_flg_x)); 
09E6C:  MOVLB  2
09E6E:  BTFSC  x0C.5
09E70:  BRA    9E6E
....................             menu_atual = menu_dados_ponto; 
09E72:  MOVLW  10
09E74:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
09E76:  MOVFF  24,576
09E7A:  MOVLB  0
09E7C:  CALL   7376
....................         break;  
....................     } 
09E80:  GOTO   D892 (RETURN)
.................... } 
.................... void atualiza_tela_dados_ponto_2(){ 
....................     short f; 
....................     switch (Teclado()){ 
*
09ED0:  CALL   6564
09ED4:  MOVF   01,W
09ED6:  ADDLW  EC
09ED8:  BTFSC  FD8.0
09EDA:  GOTO   AEC0
09EDE:  ADDLW  14
09EE0:  GOTO   AEC4
....................         case 1: 
....................             if (numeroFerros[contador_lcd] == 1){ 
09EE4:  BCF    FD8.0
09EE6:  RLCF   24,W
09EE8:  CLRF   03
09EEA:  ADDLW  58
09EEC:  MOVWF  FE9
09EEE:  MOVLW  01
09EF0:  ADDWFC 03,W
09EF2:  MOVWF  FEA
09EF4:  MOVFF  FEC,577
09EF8:  MOVF   FED,F
09EFA:  MOVFF  FEF,576
09EFE:  MOVLB  5
09F00:  DECFSZ x76,W
09F02:  BRA    9F66
09F04:  MOVF   x77,F
09F06:  BNZ   9F66
....................                 t_solda[contador_lcd] = t_solda[contador_lcd] + incremento; 
09F08:  BCF    FD8.0
09F0A:  RLCF   24,W
09F0C:  CLRF   03
09F0E:  ADDLW  AE
09F10:  MOVWF  01
09F12:  MOVLW  00
09F14:  ADDWFC 03,F
09F16:  MOVFF  01,576
09F1A:  MOVFF  03,577
09F1E:  BCF    FD8.0
09F20:  RLCF   24,W
09F22:  CLRF   03
09F24:  ADDLW  AE
09F26:  MOVWF  FE9
09F28:  MOVLW  00
09F2A:  ADDWFC 03,W
09F2C:  MOVWF  FEA
09F2E:  MOVFF  FEC,579
09F32:  MOVF   FED,F
09F34:  MOVFF  FEF,578
09F38:  CLRF   03
09F3A:  MOVF   25,W
09F3C:  BTFSC  FE8.7
09F3E:  DECF   03,F
09F40:  ADDWF  x78,W
09F42:  MOVWF  01
09F44:  MOVF   x79,W
09F46:  ADDWFC 03,F
09F48:  MOVFF  577,FEA
09F4C:  MOVFF  576,FE9
09F50:  MOVFF  03,FEC
09F54:  MOVF   FED,F
09F56:  MOVFF  01,FEF
....................                 tela_dados_ponto_4(contador_lcd); 
09F5A:  MOVFF  24,576
09F5E:  MOVLB  0
09F60:  CALL   7EBC
09F64:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
09F66:  BCF    FD8.0
09F68:  RLCF   24,W
09F6A:  CLRF   03
09F6C:  ADDLW  58
09F6E:  MOVWF  FE9
09F70:  MOVLW  01
09F72:  ADDWFC 03,W
09F74:  MOVWF  FEA
09F76:  MOVFF  FEC,577
09F7A:  MOVF   FED,F
09F7C:  MOVFF  FEF,576
09F80:  MOVF   x76,W
09F82:  SUBLW  03
09F84:  BNZ   9FE8
09F86:  MOVF   x77,F
09F88:  BNZ   9FE8
....................                 t_solda[contador_lcd] = t_solda[contador_lcd] + incremento; 
09F8A:  BCF    FD8.0
09F8C:  RLCF   24,W
09F8E:  CLRF   03
09F90:  ADDLW  AE
09F92:  MOVWF  01
09F94:  MOVLW  00
09F96:  ADDWFC 03,F
09F98:  MOVFF  01,576
09F9C:  MOVFF  03,577
09FA0:  BCF    FD8.0
09FA2:  RLCF   24,W
09FA4:  CLRF   03
09FA6:  ADDLW  AE
09FA8:  MOVWF  FE9
09FAA:  MOVLW  00
09FAC:  ADDWFC 03,W
09FAE:  MOVWF  FEA
09FB0:  MOVFF  FEC,579
09FB4:  MOVF   FED,F
09FB6:  MOVFF  FEF,578
09FBA:  CLRF   03
09FBC:  MOVF   25,W
09FBE:  BTFSC  FE8.7
09FC0:  DECF   03,F
09FC2:  ADDWF  x78,W
09FC4:  MOVWF  01
09FC6:  MOVF   x79,W
09FC8:  ADDWFC 03,F
09FCA:  MOVFF  577,FEA
09FCE:  MOVFF  576,FE9
09FD2:  MOVFF  03,FEC
09FD6:  MOVF   FED,F
09FD8:  MOVFF  01,FEF
....................                 tela_dados_ponto_2(contador_lcd); 
09FDC:  MOVFF  24,576
09FE0:  MOVLB  0
09FE2:  CALL   80F4
09FE6:  MOVLB  5
....................             }             
....................             menu_atual = menu_dados_ponto_2; 
09FE8:  MOVLW  12
09FEA:  MOVWF  1C
....................         break; 
09FEC:  MOVLB  0
09FEE:  GOTO   AEC0
....................         case 4: 
....................             if (numeroFerros[contador_lcd] == 1){ 
09FF2:  BCF    FD8.0
09FF4:  RLCF   24,W
09FF6:  CLRF   03
09FF8:  ADDLW  58
09FFA:  MOVWF  FE9
09FFC:  MOVLW  01
09FFE:  ADDWFC 03,W
0A000:  MOVWF  FEA
0A002:  MOVFF  FEC,577
0A006:  MOVF   FED,F
0A008:  MOVFF  FEF,576
0A00C:  MOVLB  5
0A00E:  DECFSZ x76,W
0A010:  BRA    A092
0A012:  MOVF   x77,F
0A014:  BNZ   A092
....................                 if (t_solda[contador_lcd] > 0){ 
0A016:  BCF    FD8.0
0A018:  RLCF   24,W
0A01A:  CLRF   03
0A01C:  ADDLW  AE
0A01E:  MOVWF  FE9
0A020:  MOVLW  00
0A022:  ADDWFC 03,W
0A024:  MOVWF  FEA
0A026:  MOVFF  FEC,577
0A02A:  MOVF   FED,F
0A02C:  MOVFF  FEF,576
0A030:  MOVF   x76,F
0A032:  BNZ   A038
0A034:  MOVF   x77,F
0A036:  BZ    A086
....................                     t_solda[contador_lcd] = t_solda[contador_lcd] - incremento; 
0A038:  BCF    FD8.0
0A03A:  RLCF   24,W
0A03C:  CLRF   03
0A03E:  ADDLW  AE
0A040:  MOVWF  01
0A042:  MOVLW  00
0A044:  ADDWFC 03,F
0A046:  MOVFF  03,577
0A04A:  BCF    FD8.0
0A04C:  RLCF   24,W
0A04E:  CLRF   03
0A050:  ADDLW  AE
0A052:  MOVWF  FE9
0A054:  MOVLW  00
0A056:  ADDWFC 03,W
0A058:  MOVWF  FEA
0A05A:  MOVFF  FEC,579
0A05E:  MOVF   FED,F
0A060:  MOVFF  FEF,578
0A064:  CLRF   03
0A066:  MOVF   25,W
0A068:  MOVWF  00
0A06A:  BTFSC  FE8.7
0A06C:  DECF   03,F
0A06E:  SUBWF  x78,W
0A070:  MOVWF  00
0A072:  MOVF   03,W
0A074:  SUBWFB x79,W
0A076:  MOVFF  577,FEA
0A07A:  MOVFF  01,FE9
0A07E:  MOVWF  FEC
0A080:  MOVF   FED,F
0A082:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_4(contador_lcd); 
0A086:  MOVFF  24,576
0A08A:  MOVLB  0
0A08C:  CALL   7EBC
0A090:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
0A092:  BCF    FD8.0
0A094:  RLCF   24,W
0A096:  CLRF   03
0A098:  ADDLW  58
0A09A:  MOVWF  FE9
0A09C:  MOVLW  01
0A09E:  ADDWFC 03,W
0A0A0:  MOVWF  FEA
0A0A2:  MOVFF  FEC,577
0A0A6:  MOVF   FED,F
0A0A8:  MOVFF  FEF,576
0A0AC:  MOVF   x76,W
0A0AE:  SUBLW  03
0A0B0:  BNZ   A132
0A0B2:  MOVF   x77,F
0A0B4:  BNZ   A132
....................                 if (t_solda[contador_lcd] > 0){ 
0A0B6:  BCF    FD8.0
0A0B8:  RLCF   24,W
0A0BA:  CLRF   03
0A0BC:  ADDLW  AE
0A0BE:  MOVWF  FE9
0A0C0:  MOVLW  00
0A0C2:  ADDWFC 03,W
0A0C4:  MOVWF  FEA
0A0C6:  MOVFF  FEC,577
0A0CA:  MOVF   FED,F
0A0CC:  MOVFF  FEF,576
0A0D0:  MOVF   x76,F
0A0D2:  BNZ   A0D8
0A0D4:  MOVF   x77,F
0A0D6:  BZ    A126
....................                     t_solda[contador_lcd] = t_solda[contador_lcd] - incremento; 
0A0D8:  BCF    FD8.0
0A0DA:  RLCF   24,W
0A0DC:  CLRF   03
0A0DE:  ADDLW  AE
0A0E0:  MOVWF  01
0A0E2:  MOVLW  00
0A0E4:  ADDWFC 03,F
0A0E6:  MOVFF  03,577
0A0EA:  BCF    FD8.0
0A0EC:  RLCF   24,W
0A0EE:  CLRF   03
0A0F0:  ADDLW  AE
0A0F2:  MOVWF  FE9
0A0F4:  MOVLW  00
0A0F6:  ADDWFC 03,W
0A0F8:  MOVWF  FEA
0A0FA:  MOVFF  FEC,579
0A0FE:  MOVF   FED,F
0A100:  MOVFF  FEF,578
0A104:  CLRF   03
0A106:  MOVF   25,W
0A108:  MOVWF  00
0A10A:  BTFSC  FE8.7
0A10C:  DECF   03,F
0A10E:  SUBWF  x78,W
0A110:  MOVWF  00
0A112:  MOVF   03,W
0A114:  SUBWFB x79,W
0A116:  MOVFF  577,FEA
0A11A:  MOVFF  01,FE9
0A11E:  MOVWF  FEC
0A120:  MOVF   FED,F
0A122:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_2(contador_lcd); 
0A126:  MOVFF  24,576
0A12A:  MOVLB  0
0A12C:  CALL   80F4
0A130:  MOVLB  5
....................             }             
....................             menu_atual = menu_dados_ponto_2; 
0A132:  MOVLW  12
0A134:  MOVWF  1C
....................         break; 
0A136:  MOVLB  0
0A138:  GOTO   AEC0
....................         case 2: 
....................             if (numeroFerros[contador_lcd] == 0){ 
0A13C:  BCF    FD8.0
0A13E:  RLCF   24,W
0A140:  CLRF   03
0A142:  ADDLW  58
0A144:  MOVWF  FE9
0A146:  MOVLW  01
0A148:  ADDWFC 03,W
0A14A:  MOVWF  FEA
0A14C:  MOVFF  FEC,577
0A150:  MOVF   FED,F
0A152:  MOVFF  FEF,576
0A156:  MOVLB  5
0A158:  MOVF   x76,F
0A15A:  BNZ   A1BE
0A15C:  MOVF   x77,F
0A15E:  BNZ   A1BE
....................                 t_solda2[contador_lcd] = t_solda2[contador_lcd] + incremento; 
0A160:  BCF    FD8.0
0A162:  RLCF   24,W
0A164:  CLRF   03
0A166:  ADDLW  82
0A168:  MOVWF  01
0A16A:  MOVLW  01
0A16C:  ADDWFC 03,F
0A16E:  MOVFF  01,576
0A172:  MOVFF  03,577
0A176:  BCF    FD8.0
0A178:  RLCF   24,W
0A17A:  CLRF   03
0A17C:  ADDLW  82
0A17E:  MOVWF  FE9
0A180:  MOVLW  01
0A182:  ADDWFC 03,W
0A184:  MOVWF  FEA
0A186:  MOVFF  FEC,579
0A18A:  MOVF   FED,F
0A18C:  MOVFF  FEF,578
0A190:  CLRF   03
0A192:  MOVF   25,W
0A194:  BTFSC  FE8.7
0A196:  DECF   03,F
0A198:  ADDWF  x78,W
0A19A:  MOVWF  01
0A19C:  MOVF   x79,W
0A19E:  ADDWFC 03,F
0A1A0:  MOVFF  577,FEA
0A1A4:  MOVFF  576,FE9
0A1A8:  MOVFF  03,FEC
0A1AC:  MOVF   FED,F
0A1AE:  MOVFF  01,FEF
....................                 tela_dados_ponto_5(contador_lcd); 
0A1B2:  MOVFF  24,576
0A1B6:  MOVLB  0
0A1B8:  CALL   7DDE
0A1BC:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){ 
0A1BE:  BCF    FD8.0
0A1C0:  RLCF   24,W
0A1C2:  CLRF   03
0A1C4:  ADDLW  58
0A1C6:  MOVWF  FE9
0A1C8:  MOVLW  01
0A1CA:  ADDWFC 03,W
0A1CC:  MOVWF  FEA
0A1CE:  MOVFF  FEC,577
0A1D2:  MOVF   FED,F
0A1D4:  MOVFF  FEF,576
0A1D8:  DECFSZ x76,W
0A1DA:  BRA    A23E
0A1DC:  MOVF   x77,F
0A1DE:  BNZ   A23E
....................                 t_solda2[contador_lcd] = t_solda2[contador_lcd] + incremento; 
0A1E0:  BCF    FD8.0
0A1E2:  RLCF   24,W
0A1E4:  CLRF   03
0A1E6:  ADDLW  82
0A1E8:  MOVWF  01
0A1EA:  MOVLW  01
0A1EC:  ADDWFC 03,F
0A1EE:  MOVFF  01,576
0A1F2:  MOVFF  03,577
0A1F6:  BCF    FD8.0
0A1F8:  RLCF   24,W
0A1FA:  CLRF   03
0A1FC:  ADDLW  82
0A1FE:  MOVWF  FE9
0A200:  MOVLW  01
0A202:  ADDWFC 03,W
0A204:  MOVWF  FEA
0A206:  MOVFF  FEC,579
0A20A:  MOVF   FED,F
0A20C:  MOVFF  FEF,578
0A210:  CLRF   03
0A212:  MOVF   25,W
0A214:  BTFSC  FE8.7
0A216:  DECF   03,F
0A218:  ADDWF  x78,W
0A21A:  MOVWF  01
0A21C:  MOVF   x79,W
0A21E:  ADDWFC 03,F
0A220:  MOVFF  577,FEA
0A224:  MOVFF  576,FE9
0A228:  MOVFF  03,FEC
0A22C:  MOVF   FED,F
0A22E:  MOVFF  01,FEF
....................                 tela_dados_ponto_4(contador_lcd); 
0A232:  MOVFF  24,576
0A236:  MOVLB  0
0A238:  CALL   7EBC
0A23C:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){ 
0A23E:  BCF    FD8.0
0A240:  RLCF   24,W
0A242:  CLRF   03
0A244:  ADDLW  58
0A246:  MOVWF  FE9
0A248:  MOVLW  01
0A24A:  ADDWFC 03,W
0A24C:  MOVWF  FEA
0A24E:  MOVFF  FEC,577
0A252:  MOVF   FED,F
0A254:  MOVFF  FEF,576
0A258:  MOVF   x76,W
0A25A:  SUBLW  02
0A25C:  BNZ   A2C0
0A25E:  MOVF   x77,F
0A260:  BNZ   A2C0
....................                 t_solda2[contador_lcd] = t_solda2[contador_lcd] + incremento; 
0A262:  BCF    FD8.0
0A264:  RLCF   24,W
0A266:  CLRF   03
0A268:  ADDLW  82
0A26A:  MOVWF  01
0A26C:  MOVLW  01
0A26E:  ADDWFC 03,F
0A270:  MOVFF  01,576
0A274:  MOVFF  03,577
0A278:  BCF    FD8.0
0A27A:  RLCF   24,W
0A27C:  CLRF   03
0A27E:  ADDLW  82
0A280:  MOVWF  FE9
0A282:  MOVLW  01
0A284:  ADDWFC 03,W
0A286:  MOVWF  FEA
0A288:  MOVFF  FEC,579
0A28C:  MOVF   FED,F
0A28E:  MOVFF  FEF,578
0A292:  CLRF   03
0A294:  MOVF   25,W
0A296:  BTFSC  FE8.7
0A298:  DECF   03,F
0A29A:  ADDWF  x78,W
0A29C:  MOVWF  01
0A29E:  MOVF   x79,W
0A2A0:  ADDWFC 03,F
0A2A2:  MOVFF  577,FEA
0A2A6:  MOVFF  576,FE9
0A2AA:  MOVFF  03,FEC
0A2AE:  MOVF   FED,F
0A2B0:  MOVFF  01,FEF
....................                 tela_dados_ponto_3(contador_lcd); 
0A2B4:  MOVFF  24,576
0A2B8:  MOVLB  0
0A2BA:  CALL   7FD8
0A2BE:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
0A2C0:  BCF    FD8.0
0A2C2:  RLCF   24,W
0A2C4:  CLRF   03
0A2C6:  ADDLW  58
0A2C8:  MOVWF  FE9
0A2CA:  MOVLW  01
0A2CC:  ADDWFC 03,W
0A2CE:  MOVWF  FEA
0A2D0:  MOVFF  FEC,577
0A2D4:  MOVF   FED,F
0A2D6:  MOVFF  FEF,576
0A2DA:  MOVF   x76,W
0A2DC:  SUBLW  03
0A2DE:  BNZ   A342
0A2E0:  MOVF   x77,F
0A2E2:  BNZ   A342
....................                 t_solda2[contador_lcd] = t_solda2[contador_lcd] + incremento; 
0A2E4:  BCF    FD8.0
0A2E6:  RLCF   24,W
0A2E8:  CLRF   03
0A2EA:  ADDLW  82
0A2EC:  MOVWF  01
0A2EE:  MOVLW  01
0A2F0:  ADDWFC 03,F
0A2F2:  MOVFF  01,576
0A2F6:  MOVFF  03,577
0A2FA:  BCF    FD8.0
0A2FC:  RLCF   24,W
0A2FE:  CLRF   03
0A300:  ADDLW  82
0A302:  MOVWF  FE9
0A304:  MOVLW  01
0A306:  ADDWFC 03,W
0A308:  MOVWF  FEA
0A30A:  MOVFF  FEC,579
0A30E:  MOVF   FED,F
0A310:  MOVFF  FEF,578
0A314:  CLRF   03
0A316:  MOVF   25,W
0A318:  BTFSC  FE8.7
0A31A:  DECF   03,F
0A31C:  ADDWF  x78,W
0A31E:  MOVWF  01
0A320:  MOVF   x79,W
0A322:  ADDWFC 03,F
0A324:  MOVFF  577,FEA
0A328:  MOVFF  576,FE9
0A32C:  MOVFF  03,FEC
0A330:  MOVF   FED,F
0A332:  MOVFF  01,FEF
....................                 tela_dados_ponto_2(contador_lcd); 
0A336:  MOVFF  24,576
0A33A:  MOVLB  0
0A33C:  CALL   80F4
0A340:  MOVLB  5
....................             } 
....................             menu_atual = menu_dados_ponto_2; 
0A342:  MOVLW  12
0A344:  MOVWF  1C
....................         break; 
0A346:  MOVLB  0
0A348:  GOTO   AEC0
....................         case 5: 
....................             if (numeroFerros[contador_lcd] == 0){ 
0A34C:  BCF    FD8.0
0A34E:  RLCF   24,W
0A350:  CLRF   03
0A352:  ADDLW  58
0A354:  MOVWF  FE9
0A356:  MOVLW  01
0A358:  ADDWFC 03,W
0A35A:  MOVWF  FEA
0A35C:  MOVFF  FEC,577
0A360:  MOVF   FED,F
0A362:  MOVFF  FEF,576
0A366:  MOVLB  5
0A368:  MOVF   x76,F
0A36A:  BNZ   A3EC
0A36C:  MOVF   x77,F
0A36E:  BNZ   A3EC
....................                 if (t_solda2[contador_lcd] > 0){ 
0A370:  BCF    FD8.0
0A372:  RLCF   24,W
0A374:  CLRF   03
0A376:  ADDLW  82
0A378:  MOVWF  FE9
0A37A:  MOVLW  01
0A37C:  ADDWFC 03,W
0A37E:  MOVWF  FEA
0A380:  MOVFF  FEC,577
0A384:  MOVF   FED,F
0A386:  MOVFF  FEF,576
0A38A:  MOVF   x76,F
0A38C:  BNZ   A392
0A38E:  MOVF   x77,F
0A390:  BZ    A3E0
....................                     t_solda2[contador_lcd] = t_solda2[contador_lcd] - incremento; 
0A392:  BCF    FD8.0
0A394:  RLCF   24,W
0A396:  CLRF   03
0A398:  ADDLW  82
0A39A:  MOVWF  01
0A39C:  MOVLW  01
0A39E:  ADDWFC 03,F
0A3A0:  MOVFF  03,577
0A3A4:  BCF    FD8.0
0A3A6:  RLCF   24,W
0A3A8:  CLRF   03
0A3AA:  ADDLW  82
0A3AC:  MOVWF  FE9
0A3AE:  MOVLW  01
0A3B0:  ADDWFC 03,W
0A3B2:  MOVWF  FEA
0A3B4:  MOVFF  FEC,579
0A3B8:  MOVF   FED,F
0A3BA:  MOVFF  FEF,578
0A3BE:  CLRF   03
0A3C0:  MOVF   25,W
0A3C2:  MOVWF  00
0A3C4:  BTFSC  FE8.7
0A3C6:  DECF   03,F
0A3C8:  SUBWF  x78,W
0A3CA:  MOVWF  00
0A3CC:  MOVF   03,W
0A3CE:  SUBWFB x79,W
0A3D0:  MOVFF  577,FEA
0A3D4:  MOVFF  01,FE9
0A3D8:  MOVWF  FEC
0A3DA:  MOVF   FED,F
0A3DC:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_5(contador_lcd); 
0A3E0:  MOVFF  24,576
0A3E4:  MOVLB  0
0A3E6:  CALL   7DDE
0A3EA:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){ 
0A3EC:  BCF    FD8.0
0A3EE:  RLCF   24,W
0A3F0:  CLRF   03
0A3F2:  ADDLW  58
0A3F4:  MOVWF  FE9
0A3F6:  MOVLW  01
0A3F8:  ADDWFC 03,W
0A3FA:  MOVWF  FEA
0A3FC:  MOVFF  FEC,577
0A400:  MOVF   FED,F
0A402:  MOVFF  FEF,576
0A406:  DECFSZ x76,W
0A408:  BRA    A48A
0A40A:  MOVF   x77,F
0A40C:  BNZ   A48A
....................                 if (t_solda2[contador_lcd] > 0){ 
0A40E:  BCF    FD8.0
0A410:  RLCF   24,W
0A412:  CLRF   03
0A414:  ADDLW  82
0A416:  MOVWF  FE9
0A418:  MOVLW  01
0A41A:  ADDWFC 03,W
0A41C:  MOVWF  FEA
0A41E:  MOVFF  FEC,577
0A422:  MOVF   FED,F
0A424:  MOVFF  FEF,576
0A428:  MOVF   x76,F
0A42A:  BNZ   A430
0A42C:  MOVF   x77,F
0A42E:  BZ    A47E
....................                     t_solda2[contador_lcd] = t_solda2[contador_lcd] - incremento; 
0A430:  BCF    FD8.0
0A432:  RLCF   24,W
0A434:  CLRF   03
0A436:  ADDLW  82
0A438:  MOVWF  01
0A43A:  MOVLW  01
0A43C:  ADDWFC 03,F
0A43E:  MOVFF  03,577
0A442:  BCF    FD8.0
0A444:  RLCF   24,W
0A446:  CLRF   03
0A448:  ADDLW  82
0A44A:  MOVWF  FE9
0A44C:  MOVLW  01
0A44E:  ADDWFC 03,W
0A450:  MOVWF  FEA
0A452:  MOVFF  FEC,579
0A456:  MOVF   FED,F
0A458:  MOVFF  FEF,578
0A45C:  CLRF   03
0A45E:  MOVF   25,W
0A460:  MOVWF  00
0A462:  BTFSC  FE8.7
0A464:  DECF   03,F
0A466:  SUBWF  x78,W
0A468:  MOVWF  00
0A46A:  MOVF   03,W
0A46C:  SUBWFB x79,W
0A46E:  MOVFF  577,FEA
0A472:  MOVFF  01,FE9
0A476:  MOVWF  FEC
0A478:  MOVF   FED,F
0A47A:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_4(contador_lcd); 
0A47E:  MOVFF  24,576
0A482:  MOVLB  0
0A484:  CALL   7EBC
0A488:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){ 
0A48A:  BCF    FD8.0
0A48C:  RLCF   24,W
0A48E:  CLRF   03
0A490:  ADDLW  58
0A492:  MOVWF  FE9
0A494:  MOVLW  01
0A496:  ADDWFC 03,W
0A498:  MOVWF  FEA
0A49A:  MOVFF  FEC,577
0A49E:  MOVF   FED,F
0A4A0:  MOVFF  FEF,576
0A4A4:  MOVF   x76,W
0A4A6:  SUBLW  02
0A4A8:  BNZ   A52A
0A4AA:  MOVF   x77,F
0A4AC:  BNZ   A52A
....................                 if (t_solda2[contador_lcd] > 0){ 
0A4AE:  BCF    FD8.0
0A4B0:  RLCF   24,W
0A4B2:  CLRF   03
0A4B4:  ADDLW  82
0A4B6:  MOVWF  FE9
0A4B8:  MOVLW  01
0A4BA:  ADDWFC 03,W
0A4BC:  MOVWF  FEA
0A4BE:  MOVFF  FEC,577
0A4C2:  MOVF   FED,F
0A4C4:  MOVFF  FEF,576
0A4C8:  MOVF   x76,F
0A4CA:  BNZ   A4D0
0A4CC:  MOVF   x77,F
0A4CE:  BZ    A51E
....................                     t_solda2[contador_lcd] = t_solda2[contador_lcd] - incremento; 
0A4D0:  BCF    FD8.0
0A4D2:  RLCF   24,W
0A4D4:  CLRF   03
0A4D6:  ADDLW  82
0A4D8:  MOVWF  01
0A4DA:  MOVLW  01
0A4DC:  ADDWFC 03,F
0A4DE:  MOVFF  03,577
0A4E2:  BCF    FD8.0
0A4E4:  RLCF   24,W
0A4E6:  CLRF   03
0A4E8:  ADDLW  82
0A4EA:  MOVWF  FE9
0A4EC:  MOVLW  01
0A4EE:  ADDWFC 03,W
0A4F0:  MOVWF  FEA
0A4F2:  MOVFF  FEC,579
0A4F6:  MOVF   FED,F
0A4F8:  MOVFF  FEF,578
0A4FC:  CLRF   03
0A4FE:  MOVF   25,W
0A500:  MOVWF  00
0A502:  BTFSC  FE8.7
0A504:  DECF   03,F
0A506:  SUBWF  x78,W
0A508:  MOVWF  00
0A50A:  MOVF   03,W
0A50C:  SUBWFB x79,W
0A50E:  MOVFF  577,FEA
0A512:  MOVFF  01,FE9
0A516:  MOVWF  FEC
0A518:  MOVF   FED,F
0A51A:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_3(contador_lcd); 
0A51E:  MOVFF  24,576
0A522:  MOVLB  0
0A524:  CALL   7FD8
0A528:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
0A52A:  BCF    FD8.0
0A52C:  RLCF   24,W
0A52E:  CLRF   03
0A530:  ADDLW  58
0A532:  MOVWF  FE9
0A534:  MOVLW  01
0A536:  ADDWFC 03,W
0A538:  MOVWF  FEA
0A53A:  MOVFF  FEC,577
0A53E:  MOVF   FED,F
0A540:  MOVFF  FEF,576
0A544:  MOVF   x76,W
0A546:  SUBLW  03
0A548:  BNZ   A5CA
0A54A:  MOVF   x77,F
0A54C:  BNZ   A5CA
....................                 if (t_solda2[contador_lcd] > 0){ 
0A54E:  BCF    FD8.0
0A550:  RLCF   24,W
0A552:  CLRF   03
0A554:  ADDLW  82
0A556:  MOVWF  FE9
0A558:  MOVLW  01
0A55A:  ADDWFC 03,W
0A55C:  MOVWF  FEA
0A55E:  MOVFF  FEC,577
0A562:  MOVF   FED,F
0A564:  MOVFF  FEF,576
0A568:  MOVF   x76,F
0A56A:  BNZ   A570
0A56C:  MOVF   x77,F
0A56E:  BZ    A5BE
....................                     t_solda2[contador_lcd] = t_solda2[contador_lcd] - incremento; 
0A570:  BCF    FD8.0
0A572:  RLCF   24,W
0A574:  CLRF   03
0A576:  ADDLW  82
0A578:  MOVWF  01
0A57A:  MOVLW  01
0A57C:  ADDWFC 03,F
0A57E:  MOVFF  03,577
0A582:  BCF    FD8.0
0A584:  RLCF   24,W
0A586:  CLRF   03
0A588:  ADDLW  82
0A58A:  MOVWF  FE9
0A58C:  MOVLW  01
0A58E:  ADDWFC 03,W
0A590:  MOVWF  FEA
0A592:  MOVFF  FEC,579
0A596:  MOVF   FED,F
0A598:  MOVFF  FEF,578
0A59C:  CLRF   03
0A59E:  MOVF   25,W
0A5A0:  MOVWF  00
0A5A2:  BTFSC  FE8.7
0A5A4:  DECF   03,F
0A5A6:  SUBWF  x78,W
0A5A8:  MOVWF  00
0A5AA:  MOVF   03,W
0A5AC:  SUBWFB x79,W
0A5AE:  MOVFF  577,FEA
0A5B2:  MOVFF  01,FE9
0A5B6:  MOVWF  FEC
0A5B8:  MOVF   FED,F
0A5BA:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_2(contador_lcd); 
0A5BE:  MOVFF  24,576
0A5C2:  MOVLB  0
0A5C4:  CALL   80F4
0A5C8:  MOVLB  5
....................             } 
....................             menu_atual = menu_dados_ponto_2; 
0A5CA:  MOVLW  12
0A5CC:  MOVWF  1C
....................         break; 
0A5CE:  MOVLB  0
0A5D0:  GOTO   AEC0
....................         case 3: 
....................             if (numeroFerros[contador_lcd] == 2){ 
0A5D4:  BCF    FD8.0
0A5D6:  RLCF   24,W
0A5D8:  CLRF   03
0A5DA:  ADDLW  58
0A5DC:  MOVWF  FE9
0A5DE:  MOVLW  01
0A5E0:  ADDWFC 03,W
0A5E2:  MOVWF  FEA
0A5E4:  MOVFF  FEC,577
0A5E8:  MOVF   FED,F
0A5EA:  MOVFF  FEF,576
0A5EE:  MOVLB  5
0A5F0:  MOVF   x76,W
0A5F2:  SUBLW  02
0A5F4:  BNZ   A658
0A5F6:  MOVF   x77,F
0A5F8:  BNZ   A658
....................                 t_solda3[contador_lcd] = t_solda3[contador_lcd] + incremento; 
0A5FA:  BCF    FD8.0
0A5FC:  RLCF   24,W
0A5FE:  CLRF   03
0A600:  ADDLW  AC
0A602:  MOVWF  01
0A604:  MOVLW  01
0A606:  ADDWFC 03,F
0A608:  MOVFF  01,576
0A60C:  MOVFF  03,577
0A610:  BCF    FD8.0
0A612:  RLCF   24,W
0A614:  CLRF   03
0A616:  ADDLW  AC
0A618:  MOVWF  FE9
0A61A:  MOVLW  01
0A61C:  ADDWFC 03,W
0A61E:  MOVWF  FEA
0A620:  MOVFF  FEC,579
0A624:  MOVF   FED,F
0A626:  MOVFF  FEF,578
0A62A:  CLRF   03
0A62C:  MOVF   25,W
0A62E:  BTFSC  FE8.7
0A630:  DECF   03,F
0A632:  ADDWF  x78,W
0A634:  MOVWF  01
0A636:  MOVF   x79,W
0A638:  ADDWFC 03,F
0A63A:  MOVFF  577,FEA
0A63E:  MOVFF  576,FE9
0A642:  MOVFF  03,FEC
0A646:  MOVF   FED,F
0A648:  MOVFF  01,FEF
....................                 tela_dados_ponto_3(contador_lcd); 
0A64C:  MOVFF  24,576
0A650:  MOVLB  0
0A652:  CALL   7FD8
0A656:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
0A658:  BCF    FD8.0
0A65A:  RLCF   24,W
0A65C:  CLRF   03
0A65E:  ADDLW  58
0A660:  MOVWF  FE9
0A662:  MOVLW  01
0A664:  ADDWFC 03,W
0A666:  MOVWF  FEA
0A668:  MOVFF  FEC,577
0A66C:  MOVF   FED,F
0A66E:  MOVFF  FEF,576
0A672:  MOVF   x76,W
0A674:  SUBLW  03
0A676:  BNZ   A6DA
0A678:  MOVF   x77,F
0A67A:  BNZ   A6DA
....................                 t_solda3[contador_lcd] = t_solda3[contador_lcd] + incremento; 
0A67C:  BCF    FD8.0
0A67E:  RLCF   24,W
0A680:  CLRF   03
0A682:  ADDLW  AC
0A684:  MOVWF  01
0A686:  MOVLW  01
0A688:  ADDWFC 03,F
0A68A:  MOVFF  01,576
0A68E:  MOVFF  03,577
0A692:  BCF    FD8.0
0A694:  RLCF   24,W
0A696:  CLRF   03
0A698:  ADDLW  AC
0A69A:  MOVWF  FE9
0A69C:  MOVLW  01
0A69E:  ADDWFC 03,W
0A6A0:  MOVWF  FEA
0A6A2:  MOVFF  FEC,579
0A6A6:  MOVF   FED,F
0A6A8:  MOVFF  FEF,578
0A6AC:  CLRF   03
0A6AE:  MOVF   25,W
0A6B0:  BTFSC  FE8.7
0A6B2:  DECF   03,F
0A6B4:  ADDWF  x78,W
0A6B6:  MOVWF  01
0A6B8:  MOVF   x79,W
0A6BA:  ADDWFC 03,F
0A6BC:  MOVFF  577,FEA
0A6C0:  MOVFF  576,FE9
0A6C4:  MOVFF  03,FEC
0A6C8:  MOVF   FED,F
0A6CA:  MOVFF  01,FEF
....................                 tela_dados_ponto_2(contador_lcd); 
0A6CE:  MOVFF  24,576
0A6D2:  MOVLB  0
0A6D4:  CALL   80F4
0A6D8:  MOVLB  5
....................             }             
....................             menu_atual = menu_dados_ponto_2; 
0A6DA:  MOVLW  12
0A6DC:  MOVWF  1C
....................         break; 
0A6DE:  MOVLB  0
0A6E0:  GOTO   AEC0
....................         case 6: 
....................             if (numeroFerros[contador_lcd] == 2){ 
0A6E4:  BCF    FD8.0
0A6E6:  RLCF   24,W
0A6E8:  CLRF   03
0A6EA:  ADDLW  58
0A6EC:  MOVWF  FE9
0A6EE:  MOVLW  01
0A6F0:  ADDWFC 03,W
0A6F2:  MOVWF  FEA
0A6F4:  MOVFF  FEC,577
0A6F8:  MOVF   FED,F
0A6FA:  MOVFF  FEF,576
0A6FE:  MOVLB  5
0A700:  MOVF   x76,W
0A702:  SUBLW  02
0A704:  BNZ   A786
0A706:  MOVF   x77,F
0A708:  BNZ   A786
....................                 if (t_solda3[contador_lcd] > 0){ 
0A70A:  BCF    FD8.0
0A70C:  RLCF   24,W
0A70E:  CLRF   03
0A710:  ADDLW  AC
0A712:  MOVWF  FE9
0A714:  MOVLW  01
0A716:  ADDWFC 03,W
0A718:  MOVWF  FEA
0A71A:  MOVFF  FEC,577
0A71E:  MOVF   FED,F
0A720:  MOVFF  FEF,576
0A724:  MOVF   x76,F
0A726:  BNZ   A72C
0A728:  MOVF   x77,F
0A72A:  BZ    A77A
....................                     t_solda3[contador_lcd] = t_solda3[contador_lcd] - incremento; 
0A72C:  BCF    FD8.0
0A72E:  RLCF   24,W
0A730:  CLRF   03
0A732:  ADDLW  AC
0A734:  MOVWF  01
0A736:  MOVLW  01
0A738:  ADDWFC 03,F
0A73A:  MOVFF  03,577
0A73E:  BCF    FD8.0
0A740:  RLCF   24,W
0A742:  CLRF   03
0A744:  ADDLW  AC
0A746:  MOVWF  FE9
0A748:  MOVLW  01
0A74A:  ADDWFC 03,W
0A74C:  MOVWF  FEA
0A74E:  MOVFF  FEC,579
0A752:  MOVF   FED,F
0A754:  MOVFF  FEF,578
0A758:  CLRF   03
0A75A:  MOVF   25,W
0A75C:  MOVWF  00
0A75E:  BTFSC  FE8.7
0A760:  DECF   03,F
0A762:  SUBWF  x78,W
0A764:  MOVWF  00
0A766:  MOVF   03,W
0A768:  SUBWFB x79,W
0A76A:  MOVFF  577,FEA
0A76E:  MOVFF  01,FE9
0A772:  MOVWF  FEC
0A774:  MOVF   FED,F
0A776:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_3(contador_lcd); 
0A77A:  MOVFF  24,576
0A77E:  MOVLB  0
0A780:  CALL   7FD8
0A784:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
0A786:  BCF    FD8.0
0A788:  RLCF   24,W
0A78A:  CLRF   03
0A78C:  ADDLW  58
0A78E:  MOVWF  FE9
0A790:  MOVLW  01
0A792:  ADDWFC 03,W
0A794:  MOVWF  FEA
0A796:  MOVFF  FEC,577
0A79A:  MOVF   FED,F
0A79C:  MOVFF  FEF,576
0A7A0:  MOVF   x76,W
0A7A2:  SUBLW  03
0A7A4:  BNZ   A826
0A7A6:  MOVF   x77,F
0A7A8:  BNZ   A826
....................                 if (t_solda3[contador_lcd] > 0){ 
0A7AA:  BCF    FD8.0
0A7AC:  RLCF   24,W
0A7AE:  CLRF   03
0A7B0:  ADDLW  AC
0A7B2:  MOVWF  FE9
0A7B4:  MOVLW  01
0A7B6:  ADDWFC 03,W
0A7B8:  MOVWF  FEA
0A7BA:  MOVFF  FEC,577
0A7BE:  MOVF   FED,F
0A7C0:  MOVFF  FEF,576
0A7C4:  MOVF   x76,F
0A7C6:  BNZ   A7CC
0A7C8:  MOVF   x77,F
0A7CA:  BZ    A81A
....................                     t_solda3[contador_lcd] = t_solda3[contador_lcd] - incremento; 
0A7CC:  BCF    FD8.0
0A7CE:  RLCF   24,W
0A7D0:  CLRF   03
0A7D2:  ADDLW  AC
0A7D4:  MOVWF  01
0A7D6:  MOVLW  01
0A7D8:  ADDWFC 03,F
0A7DA:  MOVFF  03,577
0A7DE:  BCF    FD8.0
0A7E0:  RLCF   24,W
0A7E2:  CLRF   03
0A7E4:  ADDLW  AC
0A7E6:  MOVWF  FE9
0A7E8:  MOVLW  01
0A7EA:  ADDWFC 03,W
0A7EC:  MOVWF  FEA
0A7EE:  MOVFF  FEC,579
0A7F2:  MOVF   FED,F
0A7F4:  MOVFF  FEF,578
0A7F8:  CLRF   03
0A7FA:  MOVF   25,W
0A7FC:  MOVWF  00
0A7FE:  BTFSC  FE8.7
0A800:  DECF   03,F
0A802:  SUBWF  x78,W
0A804:  MOVWF  00
0A806:  MOVF   03,W
0A808:  SUBWFB x79,W
0A80A:  MOVFF  577,FEA
0A80E:  MOVFF  01,FE9
0A812:  MOVWF  FEC
0A814:  MOVF   FED,F
0A816:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_2(contador_lcd); 
0A81A:  MOVFF  24,576
0A81E:  MOVLB  0
0A820:  CALL   80F4
0A824:  MOVLB  5
....................             }             
....................             menu_atual = menu_dados_ponto_2; 
0A826:  MOVLW  12
0A828:  MOVWF  1C
....................         break; 
0A82A:  MOVLB  0
0A82C:  BRA    AEC0
....................         case 8: 
....................             t_wait[contador_lcd] = t_wait[contador_lcd] + incremento; 
0A82E:  BCF    FD8.0
0A830:  RLCF   24,W
0A832:  CLRF   03
0A834:  ADDLW  D8
0A836:  MOVWF  01
0A838:  MOVLW  00
0A83A:  ADDWFC 03,F
0A83C:  MOVFF  01,576
0A840:  MOVLB  5
0A842:  MOVFF  03,577
0A846:  BCF    FD8.0
0A848:  RLCF   24,W
0A84A:  CLRF   03
0A84C:  ADDLW  D8
0A84E:  MOVWF  FE9
0A850:  MOVLW  00
0A852:  ADDWFC 03,W
0A854:  MOVWF  FEA
0A856:  MOVFF  FEC,579
0A85A:  MOVF   FED,F
0A85C:  MOVFF  FEF,578
0A860:  CLRF   03
0A862:  MOVF   25,W
0A864:  BTFSC  FE8.7
0A866:  DECF   03,F
0A868:  ADDWF  x78,W
0A86A:  MOVWF  01
0A86C:  MOVF   x79,W
0A86E:  ADDWFC 03,F
0A870:  MOVFF  577,FEA
0A874:  MOVFF  576,FE9
0A878:  MOVFF  03,FEC
0A87C:  MOVF   FED,F
0A87E:  MOVFF  01,FEF
....................             if (numeroFerros[contador_lcd] == 0){                 
0A882:  BCF    FD8.0
0A884:  RLCF   24,W
0A886:  CLRF   03
0A888:  ADDLW  58
0A88A:  MOVWF  FE9
0A88C:  MOVLW  01
0A88E:  ADDWFC 03,W
0A890:  MOVWF  FEA
0A892:  MOVFF  FEC,577
0A896:  MOVF   FED,F
0A898:  MOVFF  FEF,576
0A89C:  MOVF   x76,F
0A89E:  BNZ   A8B0
0A8A0:  MOVF   x77,F
0A8A2:  BNZ   A8B0
....................                 tela_dados_ponto_5(contador_lcd); 
0A8A4:  MOVFF  24,576
0A8A8:  MOVLB  0
0A8AA:  CALL   7DDE
0A8AE:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){                 
0A8B0:  BCF    FD8.0
0A8B2:  RLCF   24,W
0A8B4:  CLRF   03
0A8B6:  ADDLW  58
0A8B8:  MOVWF  FE9
0A8BA:  MOVLW  01
0A8BC:  ADDWFC 03,W
0A8BE:  MOVWF  FEA
0A8C0:  MOVFF  FEC,577
0A8C4:  MOVF   FED,F
0A8C6:  MOVFF  FEF,576
0A8CA:  DECFSZ x76,W
0A8CC:  BRA    A8DE
0A8CE:  MOVF   x77,F
0A8D0:  BNZ   A8DE
....................                 tela_dados_ponto_4(contador_lcd); 
0A8D2:  MOVFF  24,576
0A8D6:  MOVLB  0
0A8D8:  CALL   7EBC
0A8DC:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){                 
0A8DE:  BCF    FD8.0
0A8E0:  RLCF   24,W
0A8E2:  CLRF   03
0A8E4:  ADDLW  58
0A8E6:  MOVWF  FE9
0A8E8:  MOVLW  01
0A8EA:  ADDWFC 03,W
0A8EC:  MOVWF  FEA
0A8EE:  MOVFF  FEC,577
0A8F2:  MOVF   FED,F
0A8F4:  MOVFF  FEF,576
0A8F8:  MOVF   x76,W
0A8FA:  SUBLW  02
0A8FC:  BNZ   A90E
0A8FE:  MOVF   x77,F
0A900:  BNZ   A90E
....................                 tela_dados_ponto_3(contador_lcd); 
0A902:  MOVFF  24,576
0A906:  MOVLB  0
0A908:  CALL   7FD8
0A90C:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){                 
0A90E:  BCF    FD8.0
0A910:  RLCF   24,W
0A912:  CLRF   03
0A914:  ADDLW  58
0A916:  MOVWF  FE9
0A918:  MOVLW  01
0A91A:  ADDWFC 03,W
0A91C:  MOVWF  FEA
0A91E:  MOVFF  FEC,577
0A922:  MOVF   FED,F
0A924:  MOVFF  FEF,576
0A928:  MOVF   x76,W
0A92A:  SUBLW  03
0A92C:  BNZ   A93E
0A92E:  MOVF   x77,F
0A930:  BNZ   A93E
....................                 tela_dados_ponto_2(contador_lcd); 
0A932:  MOVFF  24,576
0A936:  MOVLB  0
0A938:  CALL   80F4
0A93C:  MOVLB  5
....................             }             
....................             menu_atual = menu_dados_ponto_2; 
0A93E:  MOVLW  12
0A940:  MOVWF  1C
....................         break; 
0A942:  MOVLB  0
0A944:  BRA    AEC0
....................         case 0: 
....................             if (t_wait[contador_lcd] > 0){ 
0A946:  BCF    FD8.0
0A948:  RLCF   24,W
0A94A:  CLRF   03
0A94C:  ADDLW  D8
0A94E:  MOVWF  FE9
0A950:  MOVLW  00
0A952:  ADDWFC 03,W
0A954:  MOVWF  FEA
0A956:  MOVFF  FEC,577
0A95A:  MOVF   FED,F
0A95C:  MOVFF  FEF,576
0A960:  MOVLB  5
0A962:  MOVF   x76,F
0A964:  BNZ   A96A
0A966:  MOVF   x77,F
0A968:  BZ    A9B8
....................                 t_wait[contador_lcd] = t_wait[contador_lcd] - incremento; 
0A96A:  BCF    FD8.0
0A96C:  RLCF   24,W
0A96E:  CLRF   03
0A970:  ADDLW  D8
0A972:  MOVWF  01
0A974:  MOVLW  00
0A976:  ADDWFC 03,F
0A978:  MOVFF  03,577
0A97C:  BCF    FD8.0
0A97E:  RLCF   24,W
0A980:  CLRF   03
0A982:  ADDLW  D8
0A984:  MOVWF  FE9
0A986:  MOVLW  00
0A988:  ADDWFC 03,W
0A98A:  MOVWF  FEA
0A98C:  MOVFF  FEC,579
0A990:  MOVF   FED,F
0A992:  MOVFF  FEF,578
0A996:  CLRF   03
0A998:  MOVF   25,W
0A99A:  MOVWF  00
0A99C:  BTFSC  FE8.7
0A99E:  DECF   03,F
0A9A0:  SUBWF  x78,W
0A9A2:  MOVWF  00
0A9A4:  MOVF   03,W
0A9A6:  SUBWFB x79,W
0A9A8:  MOVFF  577,FEA
0A9AC:  MOVFF  01,FE9
0A9B0:  MOVWF  FEC
0A9B2:  MOVF   FED,F
0A9B4:  MOVFF  00,FEF
....................             } 
....................             if (numeroFerros[contador_lcd] == 0){                 
0A9B8:  BCF    FD8.0
0A9BA:  RLCF   24,W
0A9BC:  CLRF   03
0A9BE:  ADDLW  58
0A9C0:  MOVWF  FE9
0A9C2:  MOVLW  01
0A9C4:  ADDWFC 03,W
0A9C6:  MOVWF  FEA
0A9C8:  MOVFF  FEC,577
0A9CC:  MOVF   FED,F
0A9CE:  MOVFF  FEF,576
0A9D2:  MOVF   x76,F
0A9D4:  BNZ   A9E6
0A9D6:  MOVF   x77,F
0A9D8:  BNZ   A9E6
....................                 tela_dados_ponto_5(contador_lcd); 
0A9DA:  MOVFF  24,576
0A9DE:  MOVLB  0
0A9E0:  CALL   7DDE
0A9E4:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){                 
0A9E6:  BCF    FD8.0
0A9E8:  RLCF   24,W
0A9EA:  CLRF   03
0A9EC:  ADDLW  58
0A9EE:  MOVWF  FE9
0A9F0:  MOVLW  01
0A9F2:  ADDWFC 03,W
0A9F4:  MOVWF  FEA
0A9F6:  MOVFF  FEC,577
0A9FA:  MOVF   FED,F
0A9FC:  MOVFF  FEF,576
0AA00:  DECFSZ x76,W
0AA02:  BRA    AA14
0AA04:  MOVF   x77,F
0AA06:  BNZ   AA14
....................                 tela_dados_ponto_4(contador_lcd); 
0AA08:  MOVFF  24,576
0AA0C:  MOVLB  0
0AA0E:  CALL   7EBC
0AA12:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){                 
0AA14:  BCF    FD8.0
0AA16:  RLCF   24,W
0AA18:  CLRF   03
0AA1A:  ADDLW  58
0AA1C:  MOVWF  FE9
0AA1E:  MOVLW  01
0AA20:  ADDWFC 03,W
0AA22:  MOVWF  FEA
0AA24:  MOVFF  FEC,577
0AA28:  MOVF   FED,F
0AA2A:  MOVFF  FEF,576
0AA2E:  MOVF   x76,W
0AA30:  SUBLW  02
0AA32:  BNZ   AA44
0AA34:  MOVF   x77,F
0AA36:  BNZ   AA44
....................                 tela_dados_ponto_3(contador_lcd); 
0AA38:  MOVFF  24,576
0AA3C:  MOVLB  0
0AA3E:  CALL   7FD8
0AA42:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){                 
0AA44:  BCF    FD8.0
0AA46:  RLCF   24,W
0AA48:  CLRF   03
0AA4A:  ADDLW  58
0AA4C:  MOVWF  FE9
0AA4E:  MOVLW  01
0AA50:  ADDWFC 03,W
0AA52:  MOVWF  FEA
0AA54:  MOVFF  FEC,577
0AA58:  MOVF   FED,F
0AA5A:  MOVFF  FEF,576
0AA5E:  MOVF   x76,W
0AA60:  SUBLW  03
0AA62:  BNZ   AA74
0AA64:  MOVF   x77,F
0AA66:  BNZ   AA74
....................                 tela_dados_ponto_2(contador_lcd); 
0AA68:  MOVFF  24,576
0AA6C:  MOVLB  0
0AA6E:  CALL   80F4
0AA72:  MOVLB  5
....................             }             
....................             menu_atual = menu_dados_ponto_2; 
0AA74:  MOVLW  12
0AA76:  MOVWF  1C
....................         break; 
0AA78:  MOVLB  0
0AA7A:  BRA    AEC0
....................         case 7: 
....................             switch (incremento){ 
0AA7C:  MOVF   25,W
0AA7E:  XORLW  01
0AA80:  BZ    AA8C
0AA82:  XORLW  0B
0AA84:  BZ    AA92
0AA86:  XORLW  38
0AA88:  BZ    AA98
0AA8A:  BRA    AA9C
....................                 case 1: 
....................                     incremento = 10; 
0AA8C:  MOVLW  0A
0AA8E:  MOVWF  25
....................                 break; 
0AA90:  BRA    AA9C
....................                 case 10: 
....................                     incremento = 50; 
0AA92:  MOVLW  32
0AA94:  MOVWF  25
....................                 break; 
0AA96:  BRA    AA9C
....................                 case 50: 
....................                     incremento = 1; 
0AA98:  MOVLW  01
0AA9A:  MOVWF  25
....................                 break; 
....................             }             
....................             if (numeroFerros[contador_lcd] == 0){                 
0AA9C:  BCF    FD8.0
0AA9E:  RLCF   24,W
0AAA0:  CLRF   03
0AAA2:  ADDLW  58
0AAA4:  MOVWF  FE9
0AAA6:  MOVLW  01
0AAA8:  ADDWFC 03,W
0AAAA:  MOVWF  FEA
0AAAC:  MOVFF  FEC,577
0AAB0:  MOVF   FED,F
0AAB2:  MOVFF  FEF,576
0AAB6:  MOVLB  5
0AAB8:  MOVF   x76,F
0AABA:  BNZ   AACC
0AABC:  MOVF   x77,F
0AABE:  BNZ   AACC
....................                 tela_dados_ponto_5(contador_lcd); 
0AAC0:  MOVFF  24,576
0AAC4:  MOVLB  0
0AAC6:  CALL   7DDE
0AACA:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){                 
0AACC:  BCF    FD8.0
0AACE:  RLCF   24,W
0AAD0:  CLRF   03
0AAD2:  ADDLW  58
0AAD4:  MOVWF  FE9
0AAD6:  MOVLW  01
0AAD8:  ADDWFC 03,W
0AADA:  MOVWF  FEA
0AADC:  MOVFF  FEC,577
0AAE0:  MOVF   FED,F
0AAE2:  MOVFF  FEF,576
0AAE6:  DECFSZ x76,W
0AAE8:  BRA    AAFA
0AAEA:  MOVF   x77,F
0AAEC:  BNZ   AAFA
....................                 tela_dados_ponto_4(contador_lcd); 
0AAEE:  MOVFF  24,576
0AAF2:  MOVLB  0
0AAF4:  CALL   7EBC
0AAF8:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){                 
0AAFA:  BCF    FD8.0
0AAFC:  RLCF   24,W
0AAFE:  CLRF   03
0AB00:  ADDLW  58
0AB02:  MOVWF  FE9
0AB04:  MOVLW  01
0AB06:  ADDWFC 03,W
0AB08:  MOVWF  FEA
0AB0A:  MOVFF  FEC,577
0AB0E:  MOVF   FED,F
0AB10:  MOVFF  FEF,576
0AB14:  MOVF   x76,W
0AB16:  SUBLW  02
0AB18:  BNZ   AB2A
0AB1A:  MOVF   x77,F
0AB1C:  BNZ   AB2A
....................                 tela_dados_ponto_3(contador_lcd); 
0AB1E:  MOVFF  24,576
0AB22:  MOVLB  0
0AB24:  CALL   7FD8
0AB28:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){                 
0AB2A:  BCF    FD8.0
0AB2C:  RLCF   24,W
0AB2E:  CLRF   03
0AB30:  ADDLW  58
0AB32:  MOVWF  FE9
0AB34:  MOVLW  01
0AB36:  ADDWFC 03,W
0AB38:  MOVWF  FEA
0AB3A:  MOVFF  FEC,577
0AB3E:  MOVF   FED,F
0AB40:  MOVFF  FEF,576
0AB44:  MOVF   x76,W
0AB46:  SUBLW  03
0AB48:  BNZ   AB5A
0AB4A:  MOVF   x77,F
0AB4C:  BNZ   AB5A
....................                 tela_dados_ponto_2(contador_lcd); 
0AB4E:  MOVFF  24,576
0AB52:  MOVLB  0
0AB54:  CALL   80F4
0AB58:  MOVLB  5
....................             }             
....................             menu_atual = menu_dados_ponto_2; 
0AB5A:  MOVLW  12
0AB5C:  MOVWF  1C
....................         break; 
0AB5E:  MOVLB  0
0AB60:  BRA    AEC0
....................         case F3: 
....................             menu_atual = menu_dados_ponto; 
0AB62:  MOVLW  10
0AB64:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
0AB66:  MOVFF  24,576
0AB6A:  CALL   7376
....................             incremento = 1; 
0AB6E:  MOVLW  01
0AB70:  MOVWF  25
....................             motor_run_z(0, 19); 
0AB72:  MOVLB  5
0AB74:  CLRF   x80
0AB76:  CLRF   x7F
0AB78:  CLRF   x7E
0AB7A:  CLRF   x7D
0AB7C:  MOVLW  13
0AB7E:  MOVWF  x81
0AB80:  MOVLB  0
0AB82:  CALL   5346
....................             while ((run_flg_z)); 
0AB86:  MOVLB  3
0AB88:  BTFSC  xB8.2
0AB8A:  BRA    AB88
....................             sobe_ferros(); 
0AB8C:  MOVLB  0
0AB8E:  CALL   781C
....................         break; 
0AB92:  BRA    AEC0
....................         case F1: 
....................             if ((numeroFerros[contador_lcd] == 0)||(numeroFerros[contador_lcd] == 2)){ 
0AB94:  BCF    FD8.0
0AB96:  RLCF   24,W
0AB98:  CLRF   03
0AB9A:  ADDLW  58
0AB9C:  MOVWF  FE9
0AB9E:  MOVLW  01
0ABA0:  ADDWFC 03,W
0ABA2:  MOVWF  FEA
0ABA4:  MOVFF  FEC,577
0ABA8:  MOVF   FED,F
0ABAA:  MOVFF  FEF,576
0ABAE:  MOVLB  5
0ABB0:  MOVF   x76,F
0ABB2:  BNZ   ABB8
0ABB4:  MOVF   x77,F
0ABB6:  BZ    ABDC
0ABB8:  BCF    FD8.0
0ABBA:  RLCF   24,W
0ABBC:  CLRF   03
0ABBE:  ADDLW  58
0ABC0:  MOVWF  FE9
0ABC2:  MOVLW  01
0ABC4:  ADDWFC 03,W
0ABC6:  MOVWF  FEA
0ABC8:  MOVFF  FEC,577
0ABCC:  MOVF   FED,F
0ABCE:  MOVFF  FEF,576
0ABD2:  MOVF   x76,W
0ABD4:  SUBLW  02
0ABD6:  BNZ   ABF2
0ABD8:  MOVF   x77,F
0ABDA:  BNZ   ABF2
....................                 t_solda[contador_lcd] = 0; 
0ABDC:  BCF    FD8.0
0ABDE:  RLCF   24,W
0ABE0:  CLRF   03
0ABE2:  ADDLW  AE
0ABE4:  MOVWF  FE9
0ABE6:  MOVLW  00
0ABE8:  ADDWFC 03,W
0ABEA:  MOVWF  FEA
0ABEC:  CLRF   FEC
0ABEE:  MOVF   FED,F
0ABF0:  CLRF   FEF
....................             } 
....................             if ((numeroFerros[contador_lcd] == 0)||(numeroFerros[contador_lcd] == 1)){ 
0ABF2:  BCF    FD8.0
0ABF4:  RLCF   24,W
0ABF6:  CLRF   03
0ABF8:  ADDLW  58
0ABFA:  MOVWF  FE9
0ABFC:  MOVLW  01
0ABFE:  ADDWFC 03,W
0AC00:  MOVWF  FEA
0AC02:  MOVFF  FEC,577
0AC06:  MOVF   FED,F
0AC08:  MOVFF  FEF,576
0AC0C:  MOVF   x76,F
0AC0E:  BNZ   AC14
0AC10:  MOVF   x77,F
0AC12:  BZ    AC36
0AC14:  BCF    FD8.0
0AC16:  RLCF   24,W
0AC18:  CLRF   03
0AC1A:  ADDLW  58
0AC1C:  MOVWF  FE9
0AC1E:  MOVLW  01
0AC20:  ADDWFC 03,W
0AC22:  MOVWF  FEA
0AC24:  MOVFF  FEC,577
0AC28:  MOVF   FED,F
0AC2A:  MOVFF  FEF,576
0AC2E:  DECFSZ x76,W
0AC30:  BRA    AC4C
0AC32:  MOVF   x77,F
0AC34:  BNZ   AC4C
....................                 t_solda3[contador_lcd] = 0; 
0AC36:  BCF    FD8.0
0AC38:  RLCF   24,W
0AC3A:  CLRF   03
0AC3C:  ADDLW  AC
0AC3E:  MOVWF  FE9
0AC40:  MOVLW  01
0AC42:  ADDWFC 03,W
0AC44:  MOVWF  FEA
0AC46:  CLRF   FEC
0AC48:  MOVF   FED,F
0AC4A:  CLRF   FEF
....................             } 
....................             printf(lcd_putc, "\f"); // limpa display 
0AC4C:  MOVLW  0C
0AC4E:  MOVWF  x86
0AC50:  MOVLB  0
0AC52:  CALL   2D32
....................             printf(lcd_putc, "   GRAVANDO PONTO   \n\r"); 
0AC56:  MOVLW  A2
0AC58:  MOVWF  FF6
0AC5A:  MOVLW  0F
0AC5C:  MOVWF  FF7
0AC5E:  CALL   2D86
....................             delay_ms(1000); 
0AC62:  MOVLW  04
0AC64:  MOVLB  5
0AC66:  MOVWF  x76
0AC68:  MOVLW  FA
0AC6A:  MOVWF  x92
0AC6C:  MOVLB  0
0AC6E:  CALL   2958
0AC72:  MOVLB  5
0AC74:  DECFSZ x76,F
0AC76:  BRA    AC68
....................             escrever_ponto_memoria(modelo,contador_lcd); 
0AC78:  CLRF   x77
0AC7A:  MOVFF  2F,576
0AC7E:  CLRF   x79
0AC80:  MOVFF  24,578
0AC84:  MOVLB  0
0AC86:  CALL   789C
....................             printf(lcd_putc, "\f"); // limpa display 
0AC8A:  MOVLW  0C
0AC8C:  MOVLB  5
0AC8E:  MOVWF  x86
0AC90:  MOVLB  0
0AC92:  CALL   2D32
....................             printf(lcd_putc, "    PONTO GRAVADO   \n\r"); 
0AC96:  MOVLW  BA
0AC98:  MOVWF  FF6
0AC9A:  MOVLW  0F
0AC9C:  MOVWF  FF7
0AC9E:  CALL   2D86
....................             delay_ms(1000); 
0ACA2:  MOVLW  04
0ACA4:  MOVLB  5
0ACA6:  MOVWF  x76
0ACA8:  MOVLW  FA
0ACAA:  MOVWF  x92
0ACAC:  MOVLB  0
0ACAE:  CALL   2958
0ACB2:  MOVLB  5
0ACB4:  DECFSZ x76,F
0ACB6:  BRA    ACA8
....................             menu_atual = menu_seleciona_pontos; 
0ACB8:  MOVLW  0F
0ACBA:  MOVWF  1C
....................             tela_seleciona_pontos(); 
0ACBC:  MOVLB  0
0ACBE:  CALL   727A
....................             contador_lcd = 0; 
0ACC2:  CLRF   24
....................             motor_run_z(0, 19); 
0ACC4:  MOVLB  5
0ACC6:  CLRF   x80
0ACC8:  CLRF   x7F
0ACCA:  CLRF   x7E
0ACCC:  CLRF   x7D
0ACCE:  MOVLW  13
0ACD0:  MOVWF  x81
0ACD2:  MOVLB  0
0ACD4:  CALL   5346
....................             while ((run_flg_z)); 
0ACD8:  MOVLB  3
0ACDA:  BTFSC  xB8.2
0ACDC:  BRA    ACDA
....................             sobe_ferros(); 
0ACDE:  MOVLB  0
0ACE0:  CALL   781C
....................         break; 
0ACE4:  BRA    AEC0
....................         case ESC: 
....................             incremento = 1; 
0ACE6:  MOVLW  01
0ACE8:  MOVWF  25
....................             contador_lcd = 0; 
0ACEA:  CLRF   24
....................             motor_run_z(0, 19); 
0ACEC:  MOVLB  5
0ACEE:  CLRF   x80
0ACF0:  CLRF   x7F
0ACF2:  CLRF   x7E
0ACF4:  CLRF   x7D
0ACF6:  MOVLW  13
0ACF8:  MOVWF  x81
0ACFA:  MOVLB  0
0ACFC:  CALL   5346
....................             while ((run_flg_z)); 
0AD00:  MOVLB  3
0AD02:  BTFSC  xB8.2
0AD04:  BRA    AD02
....................             sobe_ferros(); 
0AD06:  MOVLB  0
0AD08:  CALL   781C
....................             menu_atual = menu_seleciona_pontos; 
0AD0C:  MOVLW  0F
0AD0E:  MOVWF  1C
....................             tela_seleciona_pontos(); 
0AD10:  CALL   727A
....................         break; 
0AD14:  BRA    AEC0
....................         case ENTER: 
....................             f = statusSolda(); 
0AD16:  CALL   824E
0AD1A:  MOVLB  5
0AD1C:  BCF    x75.0
0AD1E:  BTFSC  01.0
0AD20:  BSF    x75.0
....................             if (f == 1){ 
0AD22:  BTFSS  x75.0
0AD24:  BRA    AD52
....................                 soldar_teste(tipo[contador_lcd],contador_lcd); 
0AD26:  BCF    FD8.0
0AD28:  RLCF   24,W
0AD2A:  CLRF   03
0AD2C:  ADDLW  02
0AD2E:  MOVWF  FE9
0AD30:  MOVLW  01
0AD32:  ADDWFC 03,W
0AD34:  MOVWF  FEA
0AD36:  MOVFF  FEC,577
0AD3A:  MOVF   FED,F
0AD3C:  MOVFF  FEF,576
0AD40:  MOVFF  576,578
0AD44:  MOVFF  24,579
0AD48:  MOVLB  0
0AD4A:  CALL   8C3C
....................             } else { 
0AD4E:  BRA    AD8C
0AD50:  MOVLB  5
....................                 printf(lcd_putc, "\f"); // limpa display 
0AD52:  MOVLW  0C
0AD54:  MOVWF  x86
0AD56:  MOVLB  0
0AD58:  CALL   2D32
....................                 printf(lcd_putc, "    SEM SOLDA NOS   \n\r"); 
0AD5C:  MOVLW  D2
0AD5E:  MOVWF  FF6
0AD60:  MOVLW  0F
0AD62:  MOVWF  FF7
0AD64:  CALL   2D86
....................                 printf(lcd_putc, "    ALIMENTADORES   \n\r"); 
0AD68:  MOVLW  EA
0AD6A:  MOVWF  FF6
0AD6C:  MOVLW  0F
0AD6E:  MOVWF  FF7
0AD70:  CALL   2D86
....................                 delay_ms(1000); 
0AD74:  MOVLW  04
0AD76:  MOVLB  5
0AD78:  MOVWF  x76
0AD7A:  MOVLW  FA
0AD7C:  MOVWF  x92
0AD7E:  MOVLB  0
0AD80:  CALL   2958
0AD84:  MOVLB  5
0AD86:  DECFSZ x76,F
0AD88:  BRA    AD7A
0AD8A:  MOVLB  0
....................             } 
....................             motor_run_y(y[contador_lcd],19); 
0AD8C:  BCF    FD8.0
0AD8E:  RLCF   24,W
0AD90:  CLRF   03
0AD92:  ADDLW  5A
0AD94:  MOVWF  FE9
0AD96:  MOVLW  00
0AD98:  ADDWFC 03,W
0AD9A:  MOVWF  FEA
0AD9C:  MOVFF  FEC,577
0ADA0:  MOVF   FED,F
0ADA2:  MOVFF  FEF,576
0ADA6:  MOVLB  5
0ADA8:  CLRF   x80
0ADAA:  CLRF   x7F
0ADAC:  MOVFF  577,57E
0ADB0:  MOVFF  576,57D
0ADB4:  MOVLW  13
0ADB6:  MOVWF  x81
0ADB8:  MOVLB  0
0ADBA:  CALL   55A6
....................             while ((run_flg_y)); 
0ADBE:  MOVLB  2
0ADC0:  BTFSC  x0C.7
0ADC2:  BRA    ADC0
....................             motor_run_x(x[contador_lcd],19); 
0ADC4:  BCF    FD8.0
0ADC6:  RLCF   24,W
0ADC8:  CLRF   03
0ADCA:  ADDLW  30
0ADCC:  MOVWF  FE9
0ADCE:  MOVLW  00
0ADD0:  ADDWFC 03,W
0ADD2:  MOVWF  FEA
0ADD4:  MOVFF  FEC,577
0ADD8:  MOVF   FED,F
0ADDA:  MOVFF  FEF,576
0ADDE:  MOVLB  5
0ADE0:  CLRF   x80
0ADE2:  CLRF   x7F
0ADE4:  MOVFF  577,57E
0ADE8:  MOVFF  576,57D
0ADEC:  MOVLW  13
0ADEE:  MOVWF  x81
0ADF0:  MOVLB  0
0ADF2:  CALL   5968
....................             while ((run_flg_x)); 
0ADF6:  MOVLB  2
0ADF8:  BTFSC  x0C.5
0ADFA:  BRA    ADF8
....................             if (numeroFerros[contador_lcd] == 0){ 
0ADFC:  BCF    FD8.0
0ADFE:  RLCF   24,W
0AE00:  CLRF   03
0AE02:  ADDLW  58
0AE04:  MOVWF  FE9
0AE06:  MOVLW  01
0AE08:  ADDWFC 03,W
0AE0A:  MOVWF  FEA
0AE0C:  MOVFF  FEC,577
0AE10:  MOVF   FED,F
0AE12:  MOVFF  FEF,576
0AE16:  MOVLB  5
0AE18:  MOVF   x76,F
0AE1A:  BNZ   AE2C
0AE1C:  MOVF   x77,F
0AE1E:  BNZ   AE2C
....................                 tela_dados_ponto_5(contador_lcd); 
0AE20:  MOVFF  24,576
0AE24:  MOVLB  0
0AE26:  CALL   7DDE
0AE2A:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){ 
0AE2C:  BCF    FD8.0
0AE2E:  RLCF   24,W
0AE30:  CLRF   03
0AE32:  ADDLW  58
0AE34:  MOVWF  FE9
0AE36:  MOVLW  01
0AE38:  ADDWFC 03,W
0AE3A:  MOVWF  FEA
0AE3C:  MOVFF  FEC,577
0AE40:  MOVF   FED,F
0AE42:  MOVFF  FEF,576
0AE46:  DECFSZ x76,W
0AE48:  BRA    AE5A
0AE4A:  MOVF   x77,F
0AE4C:  BNZ   AE5A
....................                 tela_dados_ponto_4(contador_lcd); 
0AE4E:  MOVFF  24,576
0AE52:  MOVLB  0
0AE54:  CALL   7EBC
0AE58:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){ 
0AE5A:  BCF    FD8.0
0AE5C:  RLCF   24,W
0AE5E:  CLRF   03
0AE60:  ADDLW  58
0AE62:  MOVWF  FE9
0AE64:  MOVLW  01
0AE66:  ADDWFC 03,W
0AE68:  MOVWF  FEA
0AE6A:  MOVFF  FEC,577
0AE6E:  MOVF   FED,F
0AE70:  MOVFF  FEF,576
0AE74:  MOVF   x76,W
0AE76:  SUBLW  02
0AE78:  BNZ   AE8A
0AE7A:  MOVF   x77,F
0AE7C:  BNZ   AE8A
....................                 tela_dados_ponto_3(contador_lcd); 
0AE7E:  MOVFF  24,576
0AE82:  MOVLB  0
0AE84:  CALL   7FD8
0AE88:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
0AE8A:  BCF    FD8.0
0AE8C:  RLCF   24,W
0AE8E:  CLRF   03
0AE90:  ADDLW  58
0AE92:  MOVWF  FE9
0AE94:  MOVLW  01
0AE96:  ADDWFC 03,W
0AE98:  MOVWF  FEA
0AE9A:  MOVFF  FEC,577
0AE9E:  MOVF   FED,F
0AEA0:  MOVFF  FEF,576
0AEA4:  MOVF   x76,W
0AEA6:  SUBLW  03
0AEA8:  BNZ   AEBA
0AEAA:  MOVF   x77,F
0AEAC:  BNZ   AEBA
....................                 tela_dados_ponto_2(contador_lcd); 
0AEAE:  MOVFF  24,576
0AEB2:  MOVLB  0
0AEB4:  CALL   80F4
0AEB8:  MOVLB  5
....................             } 
....................             menu_atual = menu_dados_ponto_2;             
0AEBA:  MOVLW  12
0AEBC:  MOVWF  1C
....................         break;  
0AEBE:  MOVLB  5
....................     } 
0AEC0:  GOTO   D900 (RETURN)
.................... } 
....................  
.................... void atualiza_tela_faltaSolda(){ 
....................     short int x; 
....................     switch (Teclado()){ 
*
0B05E:  CALL   6564
0B062:  MOVF   01,W
0B064:  XORLW  13
0B066:  BZ    B06A
0B068:  BRA    B11E
....................         case ENTER: 
....................             x = statusSolda(); 
0B06A:  CALL   824E
0B06E:  MOVLB  5
0B070:  BCF    x75.0
0B072:  BTFSC  01.0
0B074:  BSF    x75.0
....................             printf(lcd_putc, "\f"); // limpa display 
0B076:  MOVLW  0C
0B078:  MOVWF  x86
0B07A:  MOVLB  0
0B07C:  CALL   2D32
....................             printf(lcd_putc, "  VERIFICANDO SOLDA \n\r"); 
0B080:  MOVLW  02
0B082:  MOVWF  FF6
0B084:  MOVLW  10
0B086:  MOVWF  FF7
0B088:  CALL   2D86
....................             delay_ms(1000); 
0B08C:  MOVLW  04
0B08E:  MOVLB  5
0B090:  MOVWF  x76
0B092:  MOVLW  FA
0B094:  MOVWF  x92
0B096:  MOVLB  0
0B098:  CALL   2958
0B09C:  MOVLB  5
0B09E:  DECFSZ x76,F
0B0A0:  BRA    B092
....................             if (x == 0){ 
0B0A2:  BTFSC  x75.0
0B0A4:  BRA    B0EA
....................                 printf(lcd_putc, "\f"); // limpa display 
0B0A6:  MOVLW  0C
0B0A8:  MOVWF  x86
0B0AA:  MOVLB  0
0B0AC:  CALL   2D32
....................                 printf(lcd_putc, " VERIFIQUE NOVAMENTE\n\r"); 
0B0B0:  MOVLW  1A
0B0B2:  MOVWF  FF6
0B0B4:  MOVLW  10
0B0B6:  MOVWF  FF7
0B0B8:  CALL   2D86
....................                 printf(lcd_putc, "       A SOLDA      \n\r"); 
0B0BC:  MOVLW  32
0B0BE:  MOVWF  FF6
0B0C0:  MOVLW  10
0B0C2:  MOVWF  FF7
0B0C4:  CALL   2D86
....................                 delay_ms(1000); 
0B0C8:  MOVLW  04
0B0CA:  MOVLB  5
0B0CC:  MOVWF  x76
0B0CE:  MOVLW  FA
0B0D0:  MOVWF  x92
0B0D2:  MOVLB  0
0B0D4:  CALL   2958
0B0D8:  MOVLB  5
0B0DA:  DECFSZ x76,F
0B0DC:  BRA    B0CE
....................                 menu_atual = menu_faltaSolda; 
0B0DE:  MOVLW  13
0B0E0:  MOVWF  1C
....................                 tela_faltaSolda(); 
0B0E2:  MOVLB  0
0B0E4:  RCALL  B020
....................             } else { 
0B0E6:  BRA    B11E
0B0E8:  MOVLB  5
....................                 printf(lcd_putc, "\f"); // limpa display 
0B0EA:  MOVLW  0C
0B0EC:  MOVWF  x86
0B0EE:  MOVLB  0
0B0F0:  CALL   2D32
....................                 printf(lcd_putc, "      SOLDA OK      \n\r"); 
0B0F4:  MOVLW  4A
0B0F6:  MOVWF  FF6
0B0F8:  MOVLW  10
0B0FA:  MOVWF  FF7
0B0FC:  CALL   2D86
....................                 delay_ms(1000); 
0B100:  MOVLW  04
0B102:  MOVLB  5
0B104:  MOVWF  x76
0B106:  MOVLW  FA
0B108:  MOVWF  x92
0B10A:  MOVLB  0
0B10C:  CALL   2958
0B110:  MOVLB  5
0B112:  DECFSZ x76,F
0B114:  BRA    B106
....................                 menu_atual = menu_principal; 
0B116:  CLRF   1C
....................                 tela_principal(); 
0B118:  MOVLB  0
0B11A:  CALL   63D4
....................             }           
....................         break; 
....................     } 
0B11E:  GOTO   D8AA (RETURN)
.................... } 
....................  
.................... void atualiza_tela_confirmaManutencao (){ 
....................     switch (Teclado()){ 
*
06E8C:  CALL   6564
06E90:  MOVF   01,W
06E92:  XORLW  13
06E94:  BZ    6E9C
06E96:  XORLW  01
06E98:  BZ    6EA4
06E9A:  BRA    6EAA
....................         case ENTER: 
....................             menu_atual = menu_seleciona_maquina; 
06E9C:  MOVLW  01
06E9E:  MOVWF  1C
....................             tela_seleciona_maquina();          
06EA0:  RCALL  6C46
....................         break; 
06EA2:  BRA    6EAA
....................         case ESC: 
....................             tela_manutencao_outra_maquina(); 
06EA4:  RCALL  6D82
....................             menu_atual = menu_manutencao_outra_maquina;       
06EA6:  MOVLW  07
06EA8:  MOVWF  1C
....................         break; 
....................     } 
06EAA:  GOTO   D86A (RETURN)
.................... } 
....................  
.................... void atualiza_tela_seleciona_manutencao(){ 
....................     switch(Teclado())    { 
*
0B58E:  CALL   6564
0B592:  MOVF   01,W
0B594:  XORLW  0A
0B596:  BZ    B5A2
0B598:  XORLW  01
0B59A:  BZ    B5AA
0B59C:  XORLW  19
0B59E:  BZ    B5B2
0B5A0:  BRA    B5BA
....................         case F1:  
....................             menu_atual = menu_debug_entrada_1; 
0B5A2:  MOVLW  04
0B5A4:  MOVWF  1C
....................             tela_debug_entrada_1(); 
0B5A6:  RCALL  B346
....................         break; 
0B5A8:  BRA    B5BA
....................         case F2: 
....................             menu_atual = menu_debug_saida_1; 
0B5AA:  MOVLW  08
0B5AC:  MOVWF  1C
....................             tela_debug_saida_1(); 
0B5AE:  RCALL  B534
....................         break; 
0B5B0:  BRA    B5BA
....................         case ESC: 
....................             menu_atual = menu_seleciona_debug; 
0B5B2:  MOVLW  02
0B5B4:  MOVWF  1C
....................             tela_seleciona_debug(); 
0B5B6:  CALL   6EAE
....................         break; 
....................     } 
0B5BA:  GOTO   D8BA (RETURN)
.................... } 
.................... void atualiza_tela_debug_entrada_1(){ 
....................     while (Teclado() == 0xff ){ 
*
0B7AC:  CALL   6564
0B7B0:  INCFSZ 01,W
0B7B2:  BRA    B804
....................         for (int i=0; i<9; i++){ 
0B7B4:  MOVLB  5
0B7B6:  CLRF   x75
0B7B8:  MOVF   x75,W
0B7BA:  SUBLW  08
0B7BC:  BNC   B7FE
....................             if (le_Input(i) == true){ 
0B7BE:  MOVFF  575,57A
0B7C2:  MOVLB  0
0B7C4:  CALL   49FA
0B7C8:  DECFSZ 01,W
0B7CA:  BRA    B7E4
....................                 entradas [i] = 1; 
0B7CC:  MOVFF  575,57E
0B7D0:  MOVLW  01
0B7D2:  MOVLB  5
0B7D4:  MOVWF  x7F
0B7D6:  CLRF   x81
0B7D8:  MOVLW  1D
0B7DA:  MOVWF  x80
0B7DC:  MOVLB  0
0B7DE:  CALL   5170
....................             } else { 
0B7E2:  BRA    B7F8
....................                 entradas [i] = 0; 
0B7E4:  MOVFF  575,57E
0B7E8:  MOVLB  5
0B7EA:  CLRF   x7F
0B7EC:  CLRF   x81
0B7EE:  MOVLW  1D
0B7F0:  MOVWF  x80
0B7F2:  MOVLB  0
0B7F4:  CALL   5170
....................             } 
0B7F8:  MOVLB  5
0B7FA:  INCF   x75,F
0B7FC:  BRA    B7B8
....................         } 
....................         tela_debug_entrada_1(); 
0B7FE:  MOVLB  0
0B800:  RCALL  B346
0B802:  BRA    B7AC
....................     } 
....................     switch(Teclado()){ 
0B804:  CALL   6564
0B808:  MOVF   01,W
0B80A:  XORLW  10
0B80C:  BZ    B814
0B80E:  XORLW  02
0B810:  BZ    B81C
0B812:  BRA    B824
....................         case SETA_DIREITA:  
....................             menu_atual = menu_debug_entrada_2; 
0B814:  MOVLW  05
0B816:  MOVWF  1C
....................             tela_debug_entrada_2(); 
0B818:  RCALL  B5BE
....................             break;         
0B81A:  BRA    B824
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
0B81C:  MOVLW  03
0B81E:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
0B820:  CALL   6FBC
....................         break; 
....................     } 
0B824:  GOTO   D8C2 (RETURN)
.................... } 
.................... void atualiza_tela_debug_entrada_2 () { 
....................     while (Teclado () == 0xff ){ 
*
0BA4A:  CALL   6564
0BA4E:  INCFSZ 01,W
0BA50:  BRA    BAA4
....................         for (int i=9; i<18; i++){ 
0BA52:  MOVLW  09
0BA54:  MOVLB  5
0BA56:  MOVWF  x75
0BA58:  MOVF   x75,W
0BA5A:  SUBLW  11
0BA5C:  BNC   BAA0
....................             if (le_Input(i) == true){ 
0BA5E:  MOVFF  575,57A
0BA62:  MOVLB  0
0BA64:  CALL   49FA
0BA68:  DECFSZ 01,W
0BA6A:  BRA    BA84
....................                 entradas [i] = 1; 
0BA6C:  MOVFF  575,57E
0BA70:  MOVLW  01
0BA72:  MOVLB  5
0BA74:  MOVWF  x7F
0BA76:  CLRF   x81
0BA78:  MOVLW  1D
0BA7A:  MOVWF  x80
0BA7C:  MOVLB  0
0BA7E:  CALL   5170
....................             } else { 
0BA82:  BRA    BA98
....................                 entradas [i] = 0; 
0BA84:  MOVFF  575,57E
0BA88:  MOVLB  5
0BA8A:  CLRF   x7F
0BA8C:  CLRF   x81
0BA8E:  MOVLW  1D
0BA90:  MOVWF  x80
0BA92:  MOVLB  0
0BA94:  CALL   5170
....................             } 
....................             tela_debug_entrada_2(); 
0BA98:  RCALL  B5BE
0BA9A:  MOVLB  5
0BA9C:  INCF   x75,F
0BA9E:  BRA    BA58
....................         } 
0BAA0:  MOVLB  0
0BAA2:  BRA    BA4A
....................     } 
....................     switch(Teclado()){ 
0BAA4:  CALL   6564
0BAA8:  MOVF   01,W
0BAAA:  XORLW  11
0BAAC:  BZ    BAB8
0BAAE:  XORLW  01
0BAB0:  BZ    BAC0
0BAB2:  XORLW  02
0BAB4:  BZ    BAC8
0BAB6:  BRA    BAD0
....................         case SETA_ESQUERDA:  
....................             menu_atual = menu_debug_entrada_1; 
0BAB8:  MOVLW  04
0BABA:  MOVWF  1C
....................             tela_debug_entrada_1(); 
0BABC:  RCALL  B346
....................             break; 
0BABE:  BRA    BAD0
....................         case SETA_DIREITA:  
....................             menu_atual = menu_debug_entrada_3; 
0BAC0:  MOVLW  06
0BAC2:  MOVWF  1C
....................             tela_debug_entrada_3(); 
0BAC4:  RCALL  B828
....................             break; 
0BAC6:  BRA    BAD0
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
0BAC8:  MOVLW  03
0BACA:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
0BACC:  CALL   6FBC
....................         break; 
....................     } 
0BAD0:  GOTO   D8CA (RETURN)
.................... } 
.................... void atualiza_tela_debug_entrada_3 (){ 
....................     while (Teclado() == 0xff){ 
0BAD4:  CALL   6564
0BAD8:  INCFSZ 01,W
0BADA:  BRA    BB2E
....................         for (int i=18; i<28; i++){ 
0BADC:  MOVLW  12
0BADE:  MOVLB  5
0BAE0:  MOVWF  x75
0BAE2:  MOVF   x75,W
0BAE4:  SUBLW  1B
0BAE6:  BNC   BB28
....................             if (le_Input(i) == true){ 
0BAE8:  MOVFF  575,57A
0BAEC:  MOVLB  0
0BAEE:  CALL   49FA
0BAF2:  DECFSZ 01,W
0BAF4:  BRA    BB0E
....................                 entradas [i] = 1; 
0BAF6:  MOVFF  575,57E
0BAFA:  MOVLW  01
0BAFC:  MOVLB  5
0BAFE:  MOVWF  x7F
0BB00:  CLRF   x81
0BB02:  MOVLW  1D
0BB04:  MOVWF  x80
0BB06:  MOVLB  0
0BB08:  CALL   5170
....................             } else { 
0BB0C:  BRA    BB22
....................                 entradas [i] = 0; 
0BB0E:  MOVFF  575,57E
0BB12:  MOVLB  5
0BB14:  CLRF   x7F
0BB16:  CLRF   x81
0BB18:  MOVLW  1D
0BB1A:  MOVWF  x80
0BB1C:  MOVLB  0
0BB1E:  CALL   5170
....................             } 
0BB22:  MOVLB  5
0BB24:  INCF   x75,F
0BB26:  BRA    BAE2
....................         } 
....................         tela_debug_entrada_3(); 
0BB28:  MOVLB  0
0BB2A:  RCALL  B828
0BB2C:  BRA    BAD4
....................     } 
....................     switch(Teclado()){ 
0BB2E:  CALL   6564
0BB32:  MOVF   01,W
0BB34:  XORLW  11
0BB36:  BZ    BB3E
0BB38:  XORLW  03
0BB3A:  BZ    BB46
0BB3C:  BRA    BB4E
....................         case SETA_ESQUERDA:  
....................             menu_atual = menu_debug_entrada_2; 
0BB3E:  MOVLW  05
0BB40:  MOVWF  1C
....................             tela_debug_entrada_2(); 
0BB42:  RCALL  B5BE
....................             break; 
0BB44:  BRA    BB4E
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
0BB46:  MOVLW  03
0BB48:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
0BB4A:  CALL   6FBC
....................         break; 
....................     } 
0BB4E:  GOTO   D8D2 (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_1(){ 
....................     switch(Teclado()){ 
*
0BC2E:  CALL   6564
0BC32:  MOVLW  0A
0BC34:  SUBWF  01,W
0BC36:  ADDLW  F7
0BC38:  BTFSC  FD8.0
0BC3A:  BRA    BD5C
0BC3C:  ADDLW  09
0BC3E:  GOTO   BD60
....................         case F1: 
....................             switch(ponteiro_lcd){ 
0BC42:  MOVF   21,W
0BC44:  XORLW  01
0BC46:  BZ    BC52
0BC48:  XORLW  03
0BC4A:  BZ    BC62
0BC4C:  XORLW  01
0BC4E:  BZ    BC72
0BC50:  BRA    BCA2
....................                 case 1: 
....................                     aciona_saida(RELE_ESTEIRA); 
0BC52:  MOVLB  5
0BC54:  CLRF   x90
0BC56:  MOVLW  0A
0BC58:  MOVWF  x8F
0BC5A:  MOVLB  0
0BC5C:  CALL   2E1E
....................                 break; 
0BC60:  BRA    BCA2
....................                 case 2: 
....................                     aciona_saida(DEDO_ENTRADA); 
0BC62:  MOVLB  5
0BC64:  CLRF   x90
0BC66:  MOVLW  07
0BC68:  MOVWF  x8F
0BC6A:  MOVLB  0
0BC6C:  CALL   2E1E
....................                 break; 
0BC70:  BRA    BCA2
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
0BC72:  MOVLB  5
0BC74:  CLRF   x90
0BC76:  MOVLW  06
0BC78:  MOVWF  x8F
0BC7A:  MOVLB  0
0BC7C:  CALL   2E1E
....................                     delay_ms(3000); 
0BC80:  MOVLW  0C
0BC82:  MOVLB  5
0BC84:  MOVWF  x75
0BC86:  MOVLW  FA
0BC88:  MOVWF  x92
0BC8A:  MOVLB  0
0BC8C:  CALL   2958
0BC90:  MOVLB  5
0BC92:  DECFSZ x75,F
0BC94:  BRA    BC86
....................                     desaciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
0BC96:  CLRF   x90
0BC98:  MOVLW  06
0BC9A:  MOVWF  x8F
0BC9C:  MOVLB  0
0BC9E:  CALL   2DDC
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_1; 
0BCA2:  MOVLW  08
0BCA4:  MOVWF  1C
....................             tela_debug_saida_1(); 
0BCA6:  RCALL  B534
....................         break; 
0BCA8:  BRA    BD5C
....................         case F2:             
....................             switch(ponteiro_lcd){ 
0BCAA:  MOVF   21,W
0BCAC:  XORLW  01
0BCAE:  BZ    BCBA
0BCB0:  XORLW  03
0BCB2:  BZ    BCCA
0BCB4:  XORLW  01
0BCB6:  BZ    BCDA
0BCB8:  BRA    BD0A
....................                 case 1: 
....................                     desaciona_saida(RELE_ESTEIRA); 
0BCBA:  MOVLB  5
0BCBC:  CLRF   x90
0BCBE:  MOVLW  0A
0BCC0:  MOVWF  x8F
0BCC2:  MOVLB  0
0BCC4:  CALL   2DDC
....................                 break; 
0BCC8:  BRA    BD0A
....................                 case 2: 
....................                     desaciona_saida(DEDO_ENTRADA); 
0BCCA:  MOVLB  5
0BCCC:  CLRF   x90
0BCCE:  MOVLW  07
0BCD0:  MOVWF  x8F
0BCD2:  MOVLB  0
0BCD4:  CALL   2DDC
....................                 break; 
0BCD8:  BRA    BD0A
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
0BCDA:  MOVLB  5
0BCDC:  CLRF   x90
0BCDE:  MOVLW  05
0BCE0:  MOVWF  x8F
0BCE2:  MOVLB  0
0BCE4:  CALL   2E1E
....................                     delay_ms(3000); 
0BCE8:  MOVLW  0C
0BCEA:  MOVLB  5
0BCEC:  MOVWF  x75
0BCEE:  MOVLW  FA
0BCF0:  MOVWF  x92
0BCF2:  MOVLB  0
0BCF4:  CALL   2958
0BCF8:  MOVLB  5
0BCFA:  DECFSZ x75,F
0BCFC:  BRA    BCEE
....................                     desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
0BCFE:  CLRF   x90
0BD00:  MOVLW  05
0BD02:  MOVWF  x8F
0BD04:  MOVLB  0
0BD06:  CALL   2DDC
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_1; 
0BD0A:  MOVLW  08
0BD0C:  MOVWF  1C
....................             tela_debug_saida_1(); 
0BD0E:  RCALL  B534
....................         break; 
0BD10:  BRA    BD5C
....................         case SETA_DIREITA: 
....................             ponteiro_lcd = 1; 
0BD12:  MOVLW  01
0BD14:  MOVWF  21
....................             menu_atual = menu_debug_saida_2; 
0BD16:  MOVLW  09
0BD18:  MOVWF  1C
....................             tela_debug_saida_2(); 
0BD1A:  RCALL  BB52
....................         break; 
0BD1C:  BRA    BD5C
....................         case SETA_SUPERIOR: 
....................             if (ponteiro_lcd > 1){ 
0BD1E:  MOVF   21,W
0BD20:  SUBLW  01
0BD22:  BC    BD26
....................                 ponteiro_lcd --; 
0BD24:  DECF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_1; 
0BD26:  MOVLW  08
0BD28:  MOVWF  1C
....................             tela_debug_saida_1(); 
0BD2A:  RCALL  B534
....................         break; 
0BD2C:  BRA    BD5C
....................         case SETA_INFERIOR: 
....................             if (ponteiro_lcd < 3){ 
0BD2E:  MOVF   21,W
0BD30:  SUBLW  02
0BD32:  BNC   BD36
....................                 ponteiro_lcd ++; 
0BD34:  INCF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_1; 
0BD36:  MOVLW  08
0BD38:  MOVWF  1C
....................             tela_debug_saida_1(); 
0BD3A:  CALL   B534
....................         break; 
0BD3E:  BRA    BD5C
....................         case ESC: 
....................             home_solenoides(); 
0BD40:  CALL   2E6A
....................             posicao_volta_manutencao(); 
0BD44:  RCALL  BBAC
....................             envia_maquina_para_posicao(ALIMENTADOR); 
0BD46:  MOVLB  5
0BD48:  CLRF   x78
0BD4A:  MOVLB  0
0BD4C:  CALL   5C9C
....................             ponteiro_lcd = 1; 
0BD50:  MOVLW  01
0BD52:  MOVWF  21
....................             menu_atual = menu_seleciona_manutencao; 
0BD54:  MOVLW  03
0BD56:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
0BD58:  CALL   6FBC
....................         break; 
....................     } 
0BD5C:  GOTO   D8DA (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_2(){ 
....................     switch(Teclado()){ 
*
0BDF0:  CALL   6564
0BDF4:  MOVLW  0A
0BDF6:  SUBWF  01,W
0BDF8:  ADDLW  F7
0BDFA:  BTFSC  FD8.0
0BDFC:  BRA    BF26
0BDFE:  ADDLW  09
0BE00:  GOTO   BF2A
....................         case F1: 
....................             switch(ponteiro_lcd){ 
0BE04:  MOVF   21,W
0BE06:  XORLW  01
0BE08:  BZ    BE14
0BE0A:  XORLW  03
0BE0C:  BZ    BE24
0BE0E:  XORLW  01
0BE10:  BZ    BE34
0BE12:  BRA    BE60
....................                 case 1: 
....................                     aciona_saida(PRESSOR); 
0BE14:  MOVLB  5
0BE16:  CLRF   x90
0BE18:  MOVLW  04
0BE1A:  MOVWF  x8F
0BE1C:  MOVLB  0
0BE1E:  CALL   2E1E
....................                 break; 
0BE22:  BRA    BE60
....................                 case 2: 
....................                     aciona_saida(DEDO_SAIDA); 
0BE24:  MOVLB  5
0BE26:  CLRF   x90
0BE28:  MOVLW  01
0BE2A:  MOVWF  x8F
0BE2C:  MOVLB  0
0BE2E:  CALL   2E1E
....................                 break; 
0BE32:  BRA    BE60
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
0BE34:  MOVLB  5
0BE36:  CLRF   x90
0BE38:  CLRF   x8F
0BE3A:  MOVLB  0
0BE3C:  CALL   2E1E
....................                     delay_ms(3000); 
0BE40:  MOVLW  0C
0BE42:  MOVLB  5
0BE44:  MOVWF  x75
0BE46:  MOVLW  FA
0BE48:  MOVWF  x92
0BE4A:  MOVLB  0
0BE4C:  CALL   2958
0BE50:  MOVLB  5
0BE52:  DECFSZ x75,F
0BE54:  BRA    BE46
....................                     desaciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
0BE56:  CLRF   x90
0BE58:  CLRF   x8F
0BE5A:  MOVLB  0
0BE5C:  CALL   2DDC
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_2; 
0BE60:  MOVLW  09
0BE62:  MOVWF  1C
....................             tela_debug_saida_2(); 
0BE64:  RCALL  BB52
....................         break; 
0BE66:  BRA    BF26
....................         case F2:             
....................             switch(ponteiro_lcd){ 
0BE68:  MOVF   21,W
0BE6A:  XORLW  01
0BE6C:  BZ    BE78
0BE6E:  XORLW  03
0BE70:  BZ    BE88
0BE72:  XORLW  01
0BE74:  BZ    BE98
0BE76:  BRA    BEC8
....................                 case 1: 
....................                     desaciona_saida(PRESSOR); 
0BE78:  MOVLB  5
0BE7A:  CLRF   x90
0BE7C:  MOVLW  04
0BE7E:  MOVWF  x8F
0BE80:  MOVLB  0
0BE82:  CALL   2DDC
....................                 break; 
0BE86:  BRA    BEC8
....................                 case 2: 
....................                     desaciona_saida(DEDO_SAIDA); 
0BE88:  MOVLB  5
0BE8A:  CLRF   x90
0BE8C:  MOVLW  01
0BE8E:  MOVWF  x8F
0BE90:  MOVLB  0
0BE92:  CALL   2DDC
....................                 break; 
0BE96:  BRA    BEC8
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
0BE98:  MOVLB  5
0BE9A:  CLRF   x90
0BE9C:  MOVLW  0F
0BE9E:  MOVWF  x8F
0BEA0:  MOVLB  0
0BEA2:  CALL   2E1E
....................                     delay_ms(3000); 
0BEA6:  MOVLW  0C
0BEA8:  MOVLB  5
0BEAA:  MOVWF  x75
0BEAC:  MOVLW  FA
0BEAE:  MOVWF  x92
0BEB0:  MOVLB  0
0BEB2:  CALL   2958
0BEB6:  MOVLB  5
0BEB8:  DECFSZ x75,F
0BEBA:  BRA    BEAC
....................                     desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
0BEBC:  CLRF   x90
0BEBE:  MOVLW  0F
0BEC0:  MOVWF  x8F
0BEC2:  MOVLB  0
0BEC4:  CALL   2DDC
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_2; 
0BEC8:  MOVLW  09
0BECA:  MOVWF  1C
....................             tela_debug_saida_2(); 
0BECC:  RCALL  BB52
....................         break; 
0BECE:  BRA    BF26
....................         case SETA_DIREITA: 
....................             ponteiro_lcd = 1; 
0BED0:  MOVLW  01
0BED2:  MOVWF  21
....................             menu_atual = menu_debug_saida_3; 
0BED4:  MOVLW  0A
0BED6:  MOVWF  1C
....................             tela_debug_saida_3(); 
0BED8:  RCALL  BD96
....................         break; 
0BEDA:  BRA    BF26
....................         case SETA_ESQUERDA: 
....................             ponteiro_lcd = 1; 
0BEDC:  MOVLW  01
0BEDE:  MOVWF  21
....................             menu_atual = menu_debug_saida_1; 
0BEE0:  MOVLW  08
0BEE2:  MOVWF  1C
....................             tela_debug_saida_1(); 
0BEE4:  CALL   B534
....................         break; 
0BEE8:  BRA    BF26
....................         case SETA_SUPERIOR: 
....................             if (ponteiro_lcd > 1){ 
0BEEA:  MOVF   21,W
0BEEC:  SUBLW  01
0BEEE:  BC    BEF2
....................                 ponteiro_lcd --; 
0BEF0:  DECF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_2; 
0BEF2:  MOVLW  09
0BEF4:  MOVWF  1C
....................             tela_debug_saida_2(); 
0BEF6:  RCALL  BB52
....................         break; 
0BEF8:  BRA    BF26
....................         case SETA_INFERIOR: 
....................             if (ponteiro_lcd < 3){ 
0BEFA:  MOVF   21,W
0BEFC:  SUBLW  02
0BEFE:  BNC   BF02
....................                 ponteiro_lcd ++; 
0BF00:  INCF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_2; 
0BF02:  MOVLW  09
0BF04:  MOVWF  1C
....................             tela_debug_saida_2(); 
0BF06:  RCALL  BB52
....................         break; 
0BF08:  BRA    BF26
....................         case ESC: 
....................             home_solenoides(); 
0BF0A:  CALL   2E6A
....................             posicao_volta_manutencao(); 
0BF0E:  RCALL  BBAC
....................             envia_maquina_para_posicao(ALIMENTADOR); 
0BF10:  MOVLB  5
0BF12:  CLRF   x78
0BF14:  MOVLB  0
0BF16:  CALL   5C9C
....................             ponteiro_lcd = 1; 
0BF1A:  MOVLW  01
0BF1C:  MOVWF  21
....................             menu_atual = menu_seleciona_manutencao; 
0BF1E:  MOVLW  03
0BF20:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
0BF22:  CALL   6FBC
....................         break; 
....................     } 
0BF26:  GOTO   D8E2 (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_3(){ 
....................     switch(Teclado()){ 
*
0C06A:  CALL   6564
0C06E:  MOVLW  0A
0C070:  SUBWF  01,W
0C072:  ADDLW  F7
0C074:  BTFSC  FD8.0
0C076:  BRA    C1CE
0C078:  ADDLW  09
0C07A:  GOTO   C1D2
....................         case F1: 
....................             switch(ponteiro_lcd){ 
0C07E:  MOVF   21,W
0C080:  XORLW  01
0C082:  BZ    C08E
0C084:  XORLW  03
0C086:  BZ    C0BA
0C088:  XORLW  01
0C08A:  BZ    C0D8
0C08C:  BRA    C0F4
....................                 case 1: 
....................                     aciona_saida(ALIMENTADOR1); 
0C08E:  MOVLB  5
0C090:  CLRF   x90
0C092:  MOVLW  0E
0C094:  MOVWF  x8F
0C096:  MOVLB  0
0C098:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR2); 
0C09C:  MOVLB  5
0C09E:  CLRF   x90
0C0A0:  MOVLW  0D
0C0A2:  MOVWF  x8F
0C0A4:  MOVLB  0
0C0A6:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR3); 
0C0AA:  MOVLB  5
0C0AC:  CLRF   x90
0C0AE:  MOVLW  0C
0C0B0:  MOVWF  x8F
0C0B2:  MOVLB  0
0C0B4:  CALL   2E1E
....................                 break; 
0C0B8:  BRA    C0F4
....................                 case 2: 
....................                     aciona_saida(LIMPA_BICO1); 
0C0BA:  MOVLB  5
0C0BC:  CLRF   x90
0C0BE:  MOVLW  08
0C0C0:  MOVWF  x8F
0C0C2:  MOVLB  0
0C0C4:  CALL   2E1E
....................                     aciona_saida(LIMPA_BICO2); 
0C0C8:  MOVLB  5
0C0CA:  CLRF   x90
0C0CC:  MOVLW  09
0C0CE:  MOVWF  x8F
0C0D0:  MOVLB  0
0C0D2:  CALL   2E1E
....................                 break; 
0C0D6:  BRA    C0F4
....................                 case 3: 
....................                     aciona_saida(FERRO_SOLDA1); 
0C0D8:  MOVLB  5
0C0DA:  CLRF   x90
0C0DC:  MOVLW  03
0C0DE:  MOVWF  x8F
0C0E0:  MOVLB  0
0C0E2:  CALL   2E1E
....................                     aciona_saida(FERRO_SOLDA2); 
0C0E6:  MOVLB  5
0C0E8:  CLRF   x90
0C0EA:  MOVLW  02
0C0EC:  MOVWF  x8F
0C0EE:  MOVLB  0
0C0F0:  CALL   2E1E
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_3; 
0C0F4:  MOVLW  0A
0C0F6:  MOVWF  1C
....................             tela_debug_saida_3(); 
0C0F8:  RCALL  BD96
....................         break; 
0C0FA:  BRA    C1CE
....................         case F2:             
....................             switch(ponteiro_lcd){ 
0C0FC:  MOVF   21,W
0C0FE:  XORLW  01
0C100:  BZ    C10C
0C102:  XORLW  03
0C104:  BZ    C138
0C106:  XORLW  01
0C108:  BZ    C156
0C10A:  BRA    C172
....................                 case 1: 
....................                     desaciona_saida(ALIMENTADOR1); 
0C10C:  MOVLB  5
0C10E:  CLRF   x90
0C110:  MOVLW  0E
0C112:  MOVWF  x8F
0C114:  MOVLB  0
0C116:  CALL   2DDC
....................                     desaciona_saida(ALIMENTADOR2); 
0C11A:  MOVLB  5
0C11C:  CLRF   x90
0C11E:  MOVLW  0D
0C120:  MOVWF  x8F
0C122:  MOVLB  0
0C124:  CALL   2DDC
....................                     desaciona_saida(ALIMENTADOR3); 
0C128:  MOVLB  5
0C12A:  CLRF   x90
0C12C:  MOVLW  0C
0C12E:  MOVWF  x8F
0C130:  MOVLB  0
0C132:  CALL   2DDC
....................                 break; 
0C136:  BRA    C172
....................                 case 2: 
....................                     desaciona_saida(LIMPA_BICO1); 
0C138:  MOVLB  5
0C13A:  CLRF   x90
0C13C:  MOVLW  08
0C13E:  MOVWF  x8F
0C140:  MOVLB  0
0C142:  CALL   2DDC
....................                     desaciona_saida(LIMPA_BICO2); 
0C146:  MOVLB  5
0C148:  CLRF   x90
0C14A:  MOVLW  09
0C14C:  MOVWF  x8F
0C14E:  MOVLB  0
0C150:  CALL   2DDC
....................                 break; 
0C154:  BRA    C172
....................                 case 3: 
....................                     desaciona_saida(FERRO_SOLDA1); 
0C156:  MOVLB  5
0C158:  CLRF   x90
0C15A:  MOVLW  03
0C15C:  MOVWF  x8F
0C15E:  MOVLB  0
0C160:  CALL   2DDC
....................                     desaciona_saida(FERRO_SOLDA2); 
0C164:  MOVLB  5
0C166:  CLRF   x90
0C168:  MOVLW  02
0C16A:  MOVWF  x8F
0C16C:  MOVLB  0
0C16E:  CALL   2DDC
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_3; 
0C172:  MOVLW  0A
0C174:  MOVWF  1C
....................             tela_debug_saida_3(); 
0C176:  RCALL  BD96
....................         break; 
0C178:  BRA    C1CE
....................         case SETA_DIREITA: 
....................             ponteiro_lcd = 1; 
0C17A:  MOVLW  01
0C17C:  MOVWF  21
....................             menu_atual = menu_debug_saida_4; 
0C17E:  MOVLW  0B
0C180:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C182:  RCALL  BF60
....................         break; 
0C184:  BRA    C1CE
....................         case SETA_ESQUERDA: 
....................             ponteiro_lcd = 1; 
0C186:  MOVLW  01
0C188:  MOVWF  21
....................             menu_atual = menu_debug_saida_2; 
0C18A:  MOVLW  09
0C18C:  MOVWF  1C
....................             tela_debug_saida_2(); 
0C18E:  RCALL  BB52
....................         break; 
0C190:  BRA    C1CE
....................         case SETA_SUPERIOR: 
....................             if (ponteiro_lcd > 1){ 
0C192:  MOVF   21,W
0C194:  SUBLW  01
0C196:  BC    C19A
....................                 ponteiro_lcd --; 
0C198:  DECF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_3; 
0C19A:  MOVLW  0A
0C19C:  MOVWF  1C
....................             tela_debug_saida_3(); 
0C19E:  RCALL  BD96
....................         break; 
0C1A0:  BRA    C1CE
....................         case SETA_INFERIOR: 
....................             if (ponteiro_lcd < 3){ 
0C1A2:  MOVF   21,W
0C1A4:  SUBLW  02
0C1A6:  BNC   C1AA
....................                 ponteiro_lcd ++; 
0C1A8:  INCF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_3; 
0C1AA:  MOVLW  0A
0C1AC:  MOVWF  1C
....................             tela_debug_saida_3(); 
0C1AE:  RCALL  BD96
....................         break; 
0C1B0:  BRA    C1CE
....................         case ESC: 
....................             home_solenoides(); 
0C1B2:  CALL   2E6A
....................             posicao_volta_manutencao(); 
0C1B6:  RCALL  BBAC
....................             envia_maquina_para_posicao(ALIMENTADOR); 
0C1B8:  MOVLB  5
0C1BA:  CLRF   x78
0C1BC:  MOVLB  0
0C1BE:  CALL   5C9C
....................             ponteiro_lcd = 1; 
0C1C2:  MOVLW  01
0C1C4:  MOVWF  21
....................             menu_atual = menu_seleciona_manutencao; 
0C1C6:  MOVLW  03
0C1C8:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
0C1CA:  CALL   6FBC
....................         break; 
....................     } 
0C1CE:  GOTO   D8EA (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_4(){ 
....................     signed long int posFlip; 
....................     signed long int posX; 
....................     signed long int posY; 
....................     signed long int posZ; 
....................     switch(Teclado()){ 
*
0C208:  CALL   6564
0C20C:  MOVF   01,W
0C20E:  ADDLW  ED
0C210:  BTFSC  FD8.0
0C212:  BRA    C604
0C214:  ADDLW  13
0C216:  GOTO   C608
....................         case SETA_SUPERIOR: 
....................             posY = motor_pos_y + incremento; 
0C21A:  CLRF   03
0C21C:  MOVF   25,W
0C21E:  BTFSC  FE8.7
0C220:  DECF   03,F
0C222:  MOVLB  2
0C224:  ADDWF  x06,W
0C226:  MOVLB  5
0C228:  MOVWF  x79
0C22A:  MOVF   03,W
0C22C:  MOVLB  2
0C22E:  ADDWFC x07,W
0C230:  MOVLB  5
0C232:  MOVWF  x7A
....................             if (posY >= 6110) { 
0C234:  BTFSC  x7A.7
0C236:  BRA    C252
0C238:  MOVF   x7A,W
0C23A:  SUBLW  16
0C23C:  BC    C252
0C23E:  XORLW  FF
0C240:  BNZ   C248
0C242:  MOVF   x79,W
0C244:  SUBLW  DD
0C246:  BC    C252
....................                 posY = 6110; 
0C248:  MOVLW  17
0C24A:  MOVWF  x7A
0C24C:  MOVLW  DE
0C24E:  MOVWF  x79
....................             } else { 
0C250:  BRA    C26C
....................                 posY = motor_pos_y + incremento; 
0C252:  CLRF   03
0C254:  MOVF   25,W
0C256:  BTFSC  FE8.7
0C258:  DECF   03,F
0C25A:  MOVLB  2
0C25C:  ADDWF  x06,W
0C25E:  MOVLB  5
0C260:  MOVWF  x79
0C262:  MOVF   03,W
0C264:  MOVLB  2
0C266:  ADDWFC x07,W
0C268:  MOVLB  5
0C26A:  MOVWF  x7A
....................             } 
....................             atras(); 
0C26C:  MOVLB  0
0C26E:  CALL   4DCA
....................             motor_run_y(posY, 19); 
0C272:  MOVLB  5
0C274:  CLRF   x80
0C276:  CLRF   x7F
0C278:  MOVFF  57A,57E
0C27C:  MOVFF  579,57D
0C280:  MOVLW  13
0C282:  MOVWF  x81
0C284:  MOVLB  0
0C286:  CALL   55A6
....................             while ((run_flg_y)); 
0C28A:  MOVLB  2
0C28C:  BTFSC  x0C.7
0C28E:  BRA    C28C
....................             menu_atual = menu_debug_saida_4; 
0C290:  MOVLW  0B
0C292:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C294:  MOVLB  0
0C296:  RCALL  BF60
....................         break; 
0C298:  BRA    C604
....................         case SETA_INFERIOR: 
....................             posY = motor_pos_y - incremento; 
0C29A:  CLRF   03
0C29C:  MOVF   25,W
0C29E:  BTFSC  FE8.7
0C2A0:  DECF   03,F
0C2A2:  MOVLB  2
0C2A4:  SUBWF  x06,W
0C2A6:  MOVLB  5
0C2A8:  MOVWF  x79
0C2AA:  MOVF   03,W
0C2AC:  MOVLB  2
0C2AE:  SUBWFB x07,W
0C2B0:  MOVLB  5
0C2B2:  MOVWF  x7A
....................             if (posY >= 0) { 
0C2B4:  BTFSC  x7A.7
0C2B6:  BRA    C2D4
....................                posY = motor_pos_y - incremento; 
0C2B8:  CLRF   03
0C2BA:  MOVF   25,W
0C2BC:  BTFSC  FE8.7
0C2BE:  DECF   03,F
0C2C0:  MOVLB  2
0C2C2:  SUBWF  x06,W
0C2C4:  MOVLB  5
0C2C6:  MOVWF  x79
0C2C8:  MOVF   03,W
0C2CA:  MOVLB  2
0C2CC:  SUBWFB x07,W
0C2CE:  MOVLB  5
0C2D0:  MOVWF  x7A
....................             } else { 
0C2D2:  BRA    C2D8
....................                posY = 0; 
0C2D4:  CLRF   x7A
0C2D6:  CLRF   x79
....................             } 
....................             frente(); 
0C2D8:  MOVLB  0
0C2DA:  CALL   4D82
....................             motor_run_y(posY, 19); 
0C2DE:  MOVLB  5
0C2E0:  CLRF   x80
0C2E2:  CLRF   x7F
0C2E4:  MOVFF  57A,57E
0C2E8:  MOVFF  579,57D
0C2EC:  MOVLW  13
0C2EE:  MOVWF  x81
0C2F0:  MOVLB  0
0C2F2:  CALL   55A6
....................             while ((run_flg_y)); 
0C2F6:  MOVLB  2
0C2F8:  BTFSC  x0C.7
0C2FA:  BRA    C2F8
....................             menu_atual = menu_debug_saida_4; 
0C2FC:  MOVLW  0B
0C2FE:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C300:  MOVLB  0
0C302:  RCALL  BF60
....................         break; 
0C304:  BRA    C604
....................         case SETA_DIREITA: 
....................             posX = motor_pos_x - incremento; 
0C306:  CLRF   03
0C308:  MOVF   25,W
0C30A:  BTFSC  FE8.7
0C30C:  DECF   03,F
0C30E:  MOVLB  2
0C310:  SUBWF  x04,W
0C312:  MOVLB  5
0C314:  MOVWF  x77
0C316:  MOVF   03,W
0C318:  MOVLB  2
0C31A:  SUBWFB x05,W
0C31C:  MOVLB  5
0C31E:  MOVWF  x78
....................             if (posX >= 0) { 
0C320:  BTFSC  x78.7
0C322:  BRA    C340
....................                 posX = motor_pos_x - incremento;                 
0C324:  CLRF   03
0C326:  MOVF   25,W
0C328:  BTFSC  FE8.7
0C32A:  DECF   03,F
0C32C:  MOVLB  2
0C32E:  SUBWF  x04,W
0C330:  MOVLB  5
0C332:  MOVWF  x77
0C334:  MOVF   03,W
0C336:  MOVLB  2
0C338:  SUBWFB x05,W
0C33A:  MOVLB  5
0C33C:  MOVWF  x78
....................             } else { 
0C33E:  BRA    C344
....................                posX = 0; 
0C340:  CLRF   x78
0C342:  CLRF   x77
....................             } 
....................             direita(); 
0C344:  MOVLB  0
0C346:  CALL   4F3A
....................             motor_run_x(posX, 19); 
0C34A:  MOVLB  5
0C34C:  CLRF   x80
0C34E:  CLRF   x7F
0C350:  MOVFF  578,57E
0C354:  MOVFF  577,57D
0C358:  MOVLW  13
0C35A:  MOVWF  x81
0C35C:  MOVLB  0
0C35E:  CALL   5968
....................             while ((run_flg_x)); 
0C362:  MOVLB  2
0C364:  BTFSC  x0C.5
0C366:  BRA    C364
....................             menu_atual = menu_debug_saida_4; 
0C368:  MOVLW  0B
0C36A:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C36C:  MOVLB  0
0C36E:  RCALL  BF60
....................         break; 
0C370:  BRA    C604
....................         case SETA_ESQUERDA: 
....................             posX = motor_pos_x + incremento; 
0C372:  CLRF   03
0C374:  MOVF   25,W
0C376:  BTFSC  FE8.7
0C378:  DECF   03,F
0C37A:  MOVLB  2
0C37C:  ADDWF  x04,W
0C37E:  MOVLB  5
0C380:  MOVWF  x77
0C382:  MOVF   03,W
0C384:  MOVLB  2
0C386:  ADDWFC x05,W
0C388:  MOVLB  5
0C38A:  MOVWF  x78
....................             if (posX >= 4250) { 
0C38C:  BTFSC  x78.7
0C38E:  BRA    C3AA
0C390:  MOVF   x78,W
0C392:  SUBLW  0F
0C394:  BC    C3AA
0C396:  XORLW  FF
0C398:  BNZ   C3A0
0C39A:  MOVF   x77,W
0C39C:  SUBLW  99
0C39E:  BC    C3AA
....................                 posX = 4250; 
0C3A0:  MOVLW  10
0C3A2:  MOVWF  x78
0C3A4:  MOVLW  9A
0C3A6:  MOVWF  x77
....................             } else { 
0C3A8:  BRA    C3C4
....................                 posX = motor_pos_x + incremento; 
0C3AA:  CLRF   03
0C3AC:  MOVF   25,W
0C3AE:  BTFSC  FE8.7
0C3B0:  DECF   03,F
0C3B2:  MOVLB  2
0C3B4:  ADDWF  x04,W
0C3B6:  MOVLB  5
0C3B8:  MOVWF  x77
0C3BA:  MOVF   03,W
0C3BC:  MOVLB  2
0C3BE:  ADDWFC x05,W
0C3C0:  MOVLB  5
0C3C2:  MOVWF  x78
....................             } 
....................             esquerda(); 
0C3C4:  MOVLB  0
0C3C6:  CALL   4EF8
....................             motor_run_x(posX, 19); 
0C3CA:  MOVLB  5
0C3CC:  CLRF   x80
0C3CE:  CLRF   x7F
0C3D0:  MOVFF  578,57E
0C3D4:  MOVFF  577,57D
0C3D8:  MOVLW  13
0C3DA:  MOVWF  x81
0C3DC:  MOVLB  0
0C3DE:  CALL   5968
....................             while ((run_flg_x)); 
0C3E2:  MOVLB  2
0C3E4:  BTFSC  x0C.5
0C3E6:  BRA    C3E4
....................             menu_atual = menu_debug_saida_4; 
0C3E8:  MOVLW  0B
0C3EA:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C3EC:  MOVLB  0
0C3EE:  RCALL  BF60
....................         break; 
0C3F0:  BRA    C604
....................         case F2: 
....................             posZ = motor_pos_z - incremento; 
0C3F2:  CLRF   03
0C3F4:  MOVF   25,W
0C3F6:  BTFSC  FE8.7
0C3F8:  DECF   03,F
0C3FA:  MOVLB  2
0C3FC:  SUBWF  x0A,W
0C3FE:  MOVLB  5
0C400:  MOVWF  x7B
0C402:  MOVF   03,W
0C404:  MOVLB  2
0C406:  SUBWFB x0B,W
0C408:  MOVLB  5
0C40A:  MOVWF  x7C
....................             if (posZ >= 0) { 
0C40C:  BTFSC  x7C.7
0C40E:  BRA    C42C
....................                 posZ = motor_pos_z - incremento;                 
0C410:  CLRF   03
0C412:  MOVF   25,W
0C414:  BTFSC  FE8.7
0C416:  DECF   03,F
0C418:  MOVLB  2
0C41A:  SUBWF  x0A,W
0C41C:  MOVLB  5
0C41E:  MOVWF  x7B
0C420:  MOVF   03,W
0C422:  MOVLB  2
0C424:  SUBWFB x0B,W
0C426:  MOVLB  5
0C428:  MOVWF  x7C
....................             } else { 
0C42A:  BRA    C430
....................                posZ = 0; 
0C42C:  CLRF   x7C
0C42E:  CLRF   x7B
....................             } 
....................             sobe(); 
0C430:  MOVLB  0
0C432:  CALL   4C78
....................             motor_run_z(posZ, 19); 
0C436:  MOVLB  5
0C438:  CLRF   x80
0C43A:  CLRF   x7F
0C43C:  MOVFF  57C,57E
0C440:  MOVFF  57B,57D
0C444:  MOVLW  13
0C446:  MOVWF  x81
0C448:  MOVLB  0
0C44A:  CALL   5346
....................             while ((run_flg_z)); 
0C44E:  MOVLB  3
0C450:  BTFSC  xB8.2
0C452:  BRA    C450
....................             menu_atual = menu_debug_saida_4; 
0C454:  MOVLW  0B
0C456:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C458:  MOVLB  0
0C45A:  RCALL  BF60
....................         break; 
0C45C:  BRA    C604
....................         case F4: 
....................             posZ = motor_pos_z + incremento; 
0C45E:  CLRF   03
0C460:  MOVF   25,W
0C462:  BTFSC  FE8.7
0C464:  DECF   03,F
0C466:  MOVLB  2
0C468:  ADDWF  x0A,W
0C46A:  MOVLB  5
0C46C:  MOVWF  x7B
0C46E:  MOVF   03,W
0C470:  MOVLB  2
0C472:  ADDWFC x0B,W
0C474:  MOVLB  5
0C476:  MOVWF  x7C
....................             if (posZ >= 370) { 
0C478:  BTFSC  x7C.7
0C47A:  BRA    C496
0C47C:  MOVF   x7C,W
0C47E:  SUBLW  00
0C480:  BC    C496
0C482:  XORLW  FF
0C484:  BNZ   C48C
0C486:  MOVF   x7B,W
0C488:  SUBLW  71
0C48A:  BC    C496
....................                 posZ = 370;                 
0C48C:  MOVLW  01
0C48E:  MOVWF  x7C
0C490:  MOVLW  72
0C492:  MOVWF  x7B
....................             } else { 
0C494:  BRA    C4B0
....................                posZ = motor_pos_z + incremento; 
0C496:  CLRF   03
0C498:  MOVF   25,W
0C49A:  BTFSC  FE8.7
0C49C:  DECF   03,F
0C49E:  MOVLB  2
0C4A0:  ADDWF  x0A,W
0C4A2:  MOVLB  5
0C4A4:  MOVWF  x7B
0C4A6:  MOVF   03,W
0C4A8:  MOVLB  2
0C4AA:  ADDWFC x0B,W
0C4AC:  MOVLB  5
0C4AE:  MOVWF  x7C
....................             } 
....................             desce(); 
0C4B0:  MOVLB  0
0C4B2:  CALL   4C36
....................             motor_run_z(posZ, 19); 
0C4B6:  MOVLB  5
0C4B8:  CLRF   x80
0C4BA:  CLRF   x7F
0C4BC:  MOVFF  57C,57E
0C4C0:  MOVFF  57B,57D
0C4C4:  MOVLW  13
0C4C6:  MOVWF  x81
0C4C8:  MOVLB  0
0C4CA:  CALL   5346
....................             while ((run_flg_z)); 
0C4CE:  MOVLB  3
0C4D0:  BTFSC  xB8.2
0C4D2:  BRA    C4D0
....................             menu_atual = menu_debug_saida_4; 
0C4D4:  MOVLW  0B
0C4D6:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C4D8:  MOVLB  0
0C4DA:  RCALL  BF60
....................         break; 
0C4DC:  BRA    C604
....................         case 8: 
....................             posFlip = motor_pos_flip + incremento; 
0C4DE:  CLRF   03
0C4E0:  MOVF   25,W
0C4E2:  BTFSC  FE8.7
0C4E4:  DECF   03,F
0C4E6:  MOVLB  2
0C4E8:  ADDWF  x08,W
0C4EA:  MOVLB  5
0C4EC:  MOVWF  x75
0C4EE:  MOVF   03,W
0C4F0:  MOVLB  2
0C4F2:  ADDWFC x09,W
0C4F4:  MOVLB  5
0C4F6:  MOVWF  x76
....................             if (posFlip >= 2000) { 
0C4F8:  BTFSC  x76.7
0C4FA:  BRA    C516
0C4FC:  MOVF   x76,W
0C4FE:  SUBLW  06
0C500:  BC    C516
0C502:  XORLW  FF
0C504:  BNZ   C50C
0C506:  MOVF   x75,W
0C508:  SUBLW  CF
0C50A:  BC    C516
....................                 posFlip = 2000;                 
0C50C:  MOVLW  07
0C50E:  MOVWF  x76
0C510:  MOVLW  D0
0C512:  MOVWF  x75
....................             } else { 
0C514:  BRA    C530
....................                posFlip = motor_pos_flip + incremento; 
0C516:  CLRF   03
0C518:  MOVF   25,W
0C51A:  BTFSC  FE8.7
0C51C:  DECF   03,F
0C51E:  MOVLB  2
0C520:  ADDWF  x08,W
0C522:  MOVLB  5
0C524:  MOVWF  x75
0C526:  MOVF   03,W
0C528:  MOVLB  2
0C52A:  ADDWFC x09,W
0C52C:  MOVLB  5
0C52E:  MOVWF  x76
....................             } 
....................             motor_run_flip(posFlip, 19); 
0C530:  CLRF   x80
0C532:  CLRF   x7F
0C534:  MOVFF  576,57E
0C538:  MOVFF  575,57D
0C53C:  MOVLW  13
0C53E:  MOVWF  x81
0C540:  MOVLB  0
0C542:  CALL   5790
....................             while ((run_flg_flip)); 
0C546:  BTFSC  2D.3
0C548:  BRA    C546
....................             menu_atual = menu_debug_saida_4; 
0C54A:  MOVLW  0B
0C54C:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C54E:  RCALL  BF60
....................         break; 
0C550:  BRA    C604
....................         case 0: 
....................             posFlip = motor_pos_flip - incremento; 
0C552:  CLRF   03
0C554:  MOVF   25,W
0C556:  BTFSC  FE8.7
0C558:  DECF   03,F
0C55A:  MOVLB  2
0C55C:  SUBWF  x08,W
0C55E:  MOVLB  5
0C560:  MOVWF  x75
0C562:  MOVF   03,W
0C564:  MOVLB  2
0C566:  SUBWFB x09,W
0C568:  MOVLB  5
0C56A:  MOVWF  x76
....................             if (posFlip >= 0) { 
0C56C:  BTFSC  x76.7
0C56E:  BRA    C58C
....................                 posFlip = motor_pos_flip - incremento;                                
0C570:  CLRF   03
0C572:  MOVF   25,W
0C574:  BTFSC  FE8.7
0C576:  DECF   03,F
0C578:  MOVLB  2
0C57A:  SUBWF  x08,W
0C57C:  MOVLB  5
0C57E:  MOVWF  x75
0C580:  MOVF   03,W
0C582:  MOVLB  2
0C584:  SUBWFB x09,W
0C586:  MOVLB  5
0C588:  MOVWF  x76
....................             } else { 
0C58A:  BRA    C590
....................                posFlip = 0;  
0C58C:  CLRF   x76
0C58E:  CLRF   x75
....................             } 
....................             motor_run_flip(posFlip, 19); 
0C590:  CLRF   x80
0C592:  CLRF   x7F
0C594:  MOVFF  576,57E
0C598:  MOVFF  575,57D
0C59C:  MOVLW  13
0C59E:  MOVWF  x81
0C5A0:  MOVLB  0
0C5A2:  CALL   5790
....................             while ((run_flg_flip)); 
0C5A6:  BTFSC  2D.3
0C5A8:  BRA    C5A6
....................             menu_atual = menu_debug_saida_4; 
0C5AA:  MOVLW  0B
0C5AC:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C5AE:  RCALL  BF60
....................         break; 
0C5B0:  BRA    C604
....................         case 2:           
....................             sobe_ferros(); 
0C5B2:  CALL   781C
....................             desliga_pressor(); 
0C5B6:  CALL   75AC
....................         break; 
0C5BA:  BRA    C604
....................         case 5: 
....................             desce_ferros(1); 
0C5BC:  MOVLW  01
0C5BE:  MOVLB  5
0C5C0:  MOVWF  x7D
0C5C2:  MOVLB  0
0C5C4:  CALL   783A
....................             liga_pressor(); 
0C5C8:  CALL   788C
....................         break; 
0C5CC:  BRA    C604
....................         case 9: 
....................             switch (incremento){ 
0C5CE:  MOVF   25,W
0C5D0:  XORLW  01
0C5D2:  BZ    C5DE
0C5D4:  XORLW  0B
0C5D6:  BZ    C5E4
0C5D8:  XORLW  6E
0C5DA:  BZ    C5EA
0C5DC:  BRA    C5EE
....................                 case 1: 
....................                     incremento = 10; 
0C5DE:  MOVLW  0A
0C5E0:  MOVWF  25
....................                 break; 
0C5E2:  BRA    C5EE
....................                 case 10: 
....................                     incremento = 100; 
0C5E4:  MOVLW  64
0C5E6:  MOVWF  25
....................                 break; 
0C5E8:  BRA    C5EE
....................                 case 100: 
....................                     incremento = 1; 
0C5EA:  MOVLW  01
0C5EC:  MOVWF  25
....................                 break; 
....................             }             
....................             menu_atual = menu_debug_saida_4; 
0C5EE:  MOVLW  0B
0C5F0:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C5F2:  RCALL  BF60
....................         break; 
0C5F4:  BRA    C604
....................         case ESC: 
....................             incremento = 1; 
0C5F6:  MOVLW  01
0C5F8:  MOVWF  25
....................             ponteiro_lcd = 1; 
0C5FA:  MOVWF  21
....................             menu_atual = menu_debug_saida_1; 
0C5FC:  MOVLW  08
0C5FE:  MOVWF  1C
....................             tela_debug_saida_1(); 
0C600:  CALL   B534
....................         break; 
....................     } 
0C604:  GOTO   D8F2 (RETURN)
.................... } 
....................  
.................... void programa_principal_teste(){ 
*
0CEC8:  MOVLB  5
0CECA:  CLRF   x75
....................     int i = 0; 
....................     short x; 
....................     short y; 
....................     short f; 
....................     short b; 
....................     int sair; 
....................     while (exit){ 
0CECC:  BTFSS  2D.1
0CECE:  BRA    D3F8
....................         switch (i){ 
0CED0:  MOVF   x75,W
0CED2:  ADDLW  F1
0CED4:  BTFSC  FD8.0
0CED6:  BRA    D3A6
0CED8:  ADDLW  0F
0CEDA:  MOVLB  0
0CEDC:  GOTO   D41A
....................             case 0: 
....................                 f = statusSolda(); 
0CEE0:  CALL   824E
0CEE4:  MOVLB  5
0CEE6:  BCF    x76.2
0CEE8:  BTFSC  01.0
0CEEA:  BSF    x76.2
....................                 if (f == 0){ 
0CEEC:  BTFSC  x76.2
0CEEE:  BRA    CEF6
....................                     sair = 1; 
0CEF0:  MOVLW  01
0CEF2:  MOVWF  x77
....................                 } else { 
0CEF4:  BRA    CEF8
....................                     sair = 0; 
0CEF6:  CLRF   x77
....................                 } 
....................                 i++; 
0CEF8:  INCF   x75,F
....................             break; 
0CEFA:  BRA    D3A6
....................             case 1: 
....................                 envia_maquina_para_posicao(ALIMENTADOR); 
0CEFC:  MOVLB  5
0CEFE:  CLRF   x78
0CF00:  MOVLB  0
0CF02:  CALL   5C9C
....................                 if (Teclado() == ESC){ 
0CF06:  CALL   6564
0CF0A:  MOVF   01,W
0CF0C:  SUBLW  12
0CF0E:  BNZ   CF56
....................                     printf(lcd_putc, "\f"); //limpa display 
0CF10:  MOVLW  0C
0CF12:  MOVLB  5
0CF14:  MOVWF  x86
0CF16:  MOVLB  0
0CF18:  CALL   2D32
....................                     printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0CF1C:  MOVLW  62
0CF1E:  MOVWF  FF6
0CF20:  MOVLW  10
0CF22:  MOVWF  FF7
0CF24:  CALL   2D86
....................                     printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0CF28:  MOVLW  7A
0CF2A:  MOVWF  FF6
0CF2C:  MOVLW  10
0CF2E:  MOVWF  FF7
0CF30:  CALL   2D86
....................                     delay_ms(2000); 
0CF34:  MOVLW  08
0CF36:  MOVLB  5
0CF38:  MOVWF  x78
0CF3A:  MOVLW  FA
0CF3C:  MOVWF  x92
0CF3E:  MOVLB  0
0CF40:  CALL   2958
0CF44:  MOVLB  5
0CF46:  DECFSZ x78,F
0CF48:  BRA    CF3A
....................                     sair = 1; 
0CF4A:  MOVLW  01
0CF4C:  MOVWF  x77
....................                     envia_maquina_para_posicao(HOME1); 
0CF4E:  MOVWF  x78
0CF50:  MOVLB  0
0CF52:  CALL   5C9C
....................                 } 
....................                 i++;                                
0CF56:  MOVLB  5
0CF58:  INCF   x75,F
....................             break; 
0CF5A:  BRA    D3A6
....................             case 2: 
....................                 b = le_Input(S_BANDEJA); 
0CF5C:  MOVLW  15
0CF5E:  MOVLB  5
0CF60:  MOVWF  x7A
0CF62:  MOVLB  0
0CF64:  CALL   49FA
0CF68:  MOVLB  5
0CF6A:  BCF    x76.3
0CF6C:  BTFSC  01.0
0CF6E:  BSF    x76.3
....................                 if (b == 0){ 
0CF70:  BTFSC  x76.3
0CF72:  BRA    CF80
....................                     liga_esteira(); 
0CF74:  MOVLB  0
0CF76:  CALL   B122
....................                     i++;  
0CF7A:  MOVLB  5
0CF7C:  INCF   x75,F
....................                 } else { 
0CF7E:  BRA    CF8C
....................                     liga_pressor(); 
0CF80:  MOVLB  0
0CF82:  CALL   788C
....................                     i = 5; 
0CF86:  MOVLW  05
0CF88:  MOVLB  5
0CF8A:  MOVWF  x75
....................                 }                 
....................             break; 
0CF8C:  BRA    D3A6
....................             case 3: 
....................                 x = le_Input(S_ESTEIRA); 
0CF8E:  MOVLW  19
0CF90:  MOVLB  5
0CF92:  MOVWF  x7A
0CF94:  MOVLB  0
0CF96:  CALL   49FA
0CF9A:  MOVLB  5
0CF9C:  BCF    x76.0
0CF9E:  BTFSC  01.0
0CFA0:  BSF    x76.0
....................                 while ((x == 0)&&(exit == 1)){ 
0CFA2:  BTFSC  x76.0
0CFA4:  BRA    D030
0CFA6:  BTFSS  2D.1
0CFA8:  BRA    D030
....................                     printf(lcd_putc, "\f"); //limpa display 
0CFAA:  MOVLW  0C
0CFAC:  MOVWF  x86
0CFAE:  MOVLB  0
0CFB0:  CALL   2D32
....................                     printf(lcd_putc, "   ESPERANDO PLACA   \n\r"); 
0CFB4:  MOVLW  92
0CFB6:  MOVWF  FF6
0CFB8:  MOVLW  10
0CFBA:  MOVWF  FF7
0CFBC:  CALL   2D86
....................                     printf(lcd_putc, "     NA ESTEIRA     \n\r");                     
0CFC0:  MOVLW  AA
0CFC2:  MOVWF  FF6
0CFC4:  MOVLW  10
0CFC6:  MOVWF  FF7
0CFC8:  CALL   2D86
....................                     x = le_Input(S_ESTEIRA); 
0CFCC:  MOVLW  19
0CFCE:  MOVLB  5
0CFD0:  MOVWF  x7A
0CFD2:  MOVLB  0
0CFD4:  CALL   49FA
0CFD8:  MOVLB  5
0CFDA:  BCF    x76.0
0CFDC:  BTFSC  01.0
0CFDE:  BSF    x76.0
....................                     if (Teclado() == ESC){ 
0CFE0:  MOVLB  0
0CFE2:  CALL   6564
0CFE6:  MOVF   01,W
0CFE8:  SUBLW  12
0CFEA:  BNZ   D02C
....................                         printf(lcd_putc, "\f"); //limpa display 
0CFEC:  MOVLW  0C
0CFEE:  MOVLB  5
0CFF0:  MOVWF  x86
0CFF2:  MOVLB  0
0CFF4:  CALL   2D32
....................                         printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0CFF8:  MOVLW  C2
0CFFA:  MOVWF  FF6
0CFFC:  MOVLW  10
0CFFE:  MOVWF  FF7
0D000:  CALL   2D86
....................                         printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D004:  MOVLW  DA
0D006:  MOVWF  FF6
0D008:  MOVLW  10
0D00A:  MOVWF  FF7
0D00C:  CALL   2D86
....................                         delay_ms(2000); 
0D010:  MOVLW  08
0D012:  MOVLB  5
0D014:  MOVWF  x78
0D016:  MOVLW  FA
0D018:  MOVWF  x92
0D01A:  MOVLB  0
0D01C:  CALL   2958
0D020:  MOVLB  5
0D022:  DECFSZ x78,F
0D024:  BRA    D016
....................                         sair = 1; 
0D026:  MOVLW  01
0D028:  MOVWF  x77
....................                         exit = FALSE; 
0D02A:  BCF    2D.1
....................                     } 
0D02C:  MOVLB  5
0D02E:  BRA    CFA2
....................                 } 
....................                 if (exit == 1){ 
0D030:  BTFSS  2D.1
0D032:  BRA    D044
....................                     desliga_esteira(); 
0D034:  MOVLB  0
0D036:  CALL   B132
....................                     empurra_placa(); 
0D03A:  CALL   B142
....................                     i++; 
0D03E:  MOVLB  5
0D040:  INCF   x75,F
....................                 } else { 
0D042:  BRA    D04C
....................                     desliga_esteira(); 
0D044:  MOVLB  0
0D046:  CALL   B132
0D04A:  MOVLB  5
....................                 }                                 
....................             break; 
0D04C:  BRA    D3A6
....................             case 4: 
....................                 y = le_Input(S_BANDEJA); 
0D04E:  MOVLW  15
0D050:  MOVLB  5
0D052:  MOVWF  x7A
0D054:  MOVLB  0
0D056:  CALL   49FA
0D05A:  MOVLB  5
0D05C:  BCF    x76.1
0D05E:  BTFSC  01.0
0D060:  BSF    x76.1
....................                 while ((y == 0)&&(exit ==1)){ 
0D062:  BTFSC  x76.1
0D064:  BRA    D0F0
0D066:  BTFSS  2D.1
0D068:  BRA    D0F0
....................                     printf(lcd_putc, "\f"); //limpa display 
0D06A:  MOVLW  0C
0D06C:  MOVWF  x86
0D06E:  MOVLB  0
0D070:  CALL   2D32
....................                     printf(lcd_putc, "      SEM PLACA     \n\r"); 
0D074:  MOVLW  F2
0D076:  MOVWF  FF6
0D078:  MOVLW  10
0D07A:  MOVWF  FF7
0D07C:  CALL   2D86
....................                     printf(lcd_putc, "     NA BANDEJA     \n\r");                  
0D080:  MOVLW  0A
0D082:  MOVWF  FF6
0D084:  MOVLW  11
0D086:  MOVWF  FF7
0D088:  CALL   2D86
....................                     y = le_Input(S_BANDEJA); 
0D08C:  MOVLW  15
0D08E:  MOVLB  5
0D090:  MOVWF  x7A
0D092:  MOVLB  0
0D094:  CALL   49FA
0D098:  MOVLB  5
0D09A:  BCF    x76.1
0D09C:  BTFSC  01.0
0D09E:  BSF    x76.1
....................                     if (Teclado() == ESC){ 
0D0A0:  MOVLB  0
0D0A2:  CALL   6564
0D0A6:  MOVF   01,W
0D0A8:  SUBLW  12
0D0AA:  BNZ   D0EC
....................                         printf(lcd_putc, "\f"); //limpa display 
0D0AC:  MOVLW  0C
0D0AE:  MOVLB  5
0D0B0:  MOVWF  x86
0D0B2:  MOVLB  0
0D0B4:  CALL   2D32
....................                         printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0D0B8:  MOVLW  22
0D0BA:  MOVWF  FF6
0D0BC:  MOVLW  11
0D0BE:  MOVWF  FF7
0D0C0:  CALL   2D86
....................                         printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D0C4:  MOVLW  3A
0D0C6:  MOVWF  FF6
0D0C8:  MOVLW  11
0D0CA:  MOVWF  FF7
0D0CC:  CALL   2D86
....................                         delay_ms(2000); 
0D0D0:  MOVLW  08
0D0D2:  MOVLB  5
0D0D4:  MOVWF  x78
0D0D6:  MOVLW  FA
0D0D8:  MOVWF  x92
0D0DA:  MOVLB  0
0D0DC:  CALL   2958
0D0E0:  MOVLB  5
0D0E2:  DECFSZ x78,F
0D0E4:  BRA    D0D6
....................                         exit = FALSE; 
0D0E6:  BCF    2D.1
....................                         sair = 1; 
0D0E8:  MOVLW  01
0D0EA:  MOVWF  x77
....................                     } 
0D0EC:  MOVLB  5
0D0EE:  BRA    D062
....................                 } 
....................                 if (exit == 1){ 
0D0F0:  BTFSS  2D.1
0D0F2:  BRA    D100
....................                     liga_pressor(); 
0D0F4:  MOVLB  0
0D0F6:  CALL   788C
....................                     i++; 
0D0FA:  MOVLB  5
0D0FC:  INCF   x75,F
....................                 } else { 
0D0FE:  BRA    D108
....................                     desliga_pressor(); 
0D100:  MOVLB  0
0D102:  CALL   75AC
0D106:  MOVLB  5
....................                 }                 
....................             break; 
0D108:  BRA    D3A6
....................             case 5: 
....................                 envia_maquina_para_posicao(HOME1); 
0D10A:  MOVLW  01
0D10C:  MOVLB  5
0D10E:  MOVWF  x78
0D110:  MOVLB  0
0D112:  CALL   5C9C
....................                 if (Teclado() == ESC){ 
0D116:  CALL   6564
0D11A:  MOVF   01,W
0D11C:  SUBLW  12
0D11E:  BNZ   D164
....................                     printf(lcd_putc, "\f"); //limpa display 
0D120:  MOVLW  0C
0D122:  MOVLB  5
0D124:  MOVWF  x86
0D126:  MOVLB  0
0D128:  CALL   2D32
....................                     printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0D12C:  MOVLW  52
0D12E:  MOVWF  FF6
0D130:  MOVLW  11
0D132:  MOVWF  FF7
0D134:  CALL   2D86
....................                     printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D138:  MOVLW  6A
0D13A:  MOVWF  FF6
0D13C:  MOVLW  11
0D13E:  MOVWF  FF7
0D140:  CALL   2D86
....................                     delay_ms(2000); 
0D144:  MOVLW  08
0D146:  MOVLB  5
0D148:  MOVWF  x78
0D14A:  MOVLW  FA
0D14C:  MOVWF  x92
0D14E:  MOVLB  0
0D150:  CALL   2958
0D154:  MOVLB  5
0D156:  DECFSZ x78,F
0D158:  BRA    D14A
....................                     sair = 1; 
0D15A:  MOVLW  01
0D15C:  MOVWF  x77
....................                     desliga_pressor(); 
0D15E:  MOVLB  0
0D160:  CALL   75AC
....................                 } 
....................                 i++; 
0D164:  MOVLB  5
0D166:  INCF   x75,F
....................             break;  
0D168:  BRA    D3A6
....................             case 6: 
....................                 envia_maquina_para_posicao(SOLDAGEM); 
0D16A:  MOVLW  03
0D16C:  MOVLB  5
0D16E:  MOVWF  x78
0D170:  MOVLB  0
0D172:  CALL   5C9C
....................                 if (Teclado() == ESC){ 
0D176:  CALL   6564
0D17A:  MOVF   01,W
0D17C:  SUBLW  12
0D17E:  BNZ   D1CA
....................                     printf(lcd_putc, "\f"); //limpa display 
0D180:  MOVLW  0C
0D182:  MOVLB  5
0D184:  MOVWF  x86
0D186:  MOVLB  0
0D188:  CALL   2D32
....................                     printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0D18C:  MOVLW  82
0D18E:  MOVWF  FF6
0D190:  MOVLW  11
0D192:  MOVWF  FF7
0D194:  CALL   2D86
....................                     printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D198:  MOVLW  9A
0D19A:  MOVWF  FF6
0D19C:  MOVLW  11
0D19E:  MOVWF  FF7
0D1A0:  CALL   2D86
....................                     delay_ms(2000); 
0D1A4:  MOVLW  08
0D1A6:  MOVLB  5
0D1A8:  MOVWF  x78
0D1AA:  MOVLW  FA
0D1AC:  MOVWF  x92
0D1AE:  MOVLB  0
0D1B0:  CALL   2958
0D1B4:  MOVLB  5
0D1B6:  DECFSZ x78,F
0D1B8:  BRA    D1AA
....................                     sair = 1; 
0D1BA:  MOVLW  01
0D1BC:  MOVWF  x77
....................                     envia_maquina_para_posicao(HOME1); 
0D1BE:  MOVWF  x78
0D1C0:  MOVLB  0
0D1C2:  CALL   5C9C
....................                     desliga_pressor(); 
0D1C6:  CALL   75AC
....................                 } 
....................                 i++; 
0D1CA:  MOVLB  5
0D1CC:  INCF   x75,F
....................             break; 
0D1CE:  BRA    D3A6
....................             case 7: 
....................                 soldar(); 
0D1D0:  GOTO   C652
....................                 motor_run_x(500, 19); 
0D1D4:  MOVLB  5
0D1D6:  CLRF   x80
0D1D8:  CLRF   x7F
0D1DA:  MOVLW  01
0D1DC:  MOVWF  x7E
0D1DE:  MOVLW  F4
0D1E0:  MOVWF  x7D
0D1E2:  MOVLW  13
0D1E4:  MOVWF  x81
0D1E6:  MOVLB  0
0D1E8:  CALL   5968
....................                 while ((run_flg_x)); 
0D1EC:  MOVLB  2
0D1EE:  BTFSC  x0C.5
0D1F0:  BRA    D1EE
....................                 motor_run_y(2450, 19); 
0D1F2:  MOVLB  5
0D1F4:  CLRF   x80
0D1F6:  CLRF   x7F
0D1F8:  MOVLW  09
0D1FA:  MOVWF  x7E
0D1FC:  MOVLW  92
0D1FE:  MOVWF  x7D
0D200:  MOVLW  13
0D202:  MOVWF  x81
0D204:  MOVLB  0
0D206:  CALL   55A6
....................                 while ((run_flg_y)); 
0D20A:  MOVLB  2
0D20C:  BTFSC  x0C.7
0D20E:  BRA    D20C
....................                 if (Teclado() == ESC){ 
0D210:  MOVLB  0
0D212:  CALL   6564
0D216:  MOVF   01,W
0D218:  SUBLW  12
0D21A:  BNZ   D224
....................                     sair = 1; 
0D21C:  MOVLW  01
0D21E:  MOVLB  5
0D220:  MOVWF  x77
0D222:  MOVLB  0
....................                 } 
....................                 i++; 
0D224:  MOVLB  5
0D226:  INCF   x75,F
....................             break; 
0D228:  BRA    D3A6
....................             case 8: 
....................                 envia_maquina_para_posicao(HOME2); 
0D22A:  MOVLW  04
0D22C:  MOVLB  5
0D22E:  MOVWF  x78
0D230:  MOVLB  0
0D232:  CALL   5C9C
....................                 if (Teclado() == ESC){ 
0D236:  CALL   6564
0D23A:  MOVF   01,W
0D23C:  SUBLW  12
0D23E:  BNZ   D280
....................                     printf(lcd_putc, "\f"); //limpa display 
0D240:  MOVLW  0C
0D242:  MOVLB  5
0D244:  MOVWF  x86
0D246:  MOVLB  0
0D248:  CALL   2D32
....................                     printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0D24C:  MOVLW  B2
0D24E:  MOVWF  FF6
0D250:  MOVLW  11
0D252:  MOVWF  FF7
0D254:  CALL   2D86
....................                     printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D258:  MOVLW  CA
0D25A:  MOVWF  FF6
0D25C:  MOVLW  11
0D25E:  MOVWF  FF7
0D260:  CALL   2D86
....................                     delay_ms(1000); 
0D264:  MOVLW  04
0D266:  MOVLB  5
0D268:  MOVWF  x78
0D26A:  MOVLW  FA
0D26C:  MOVWF  x92
0D26E:  MOVLB  0
0D270:  CALL   2958
0D274:  MOVLB  5
0D276:  DECFSZ x78,F
0D278:  BRA    D26A
....................                     sair = 1; 
0D27A:  MOVLW  01
0D27C:  MOVWF  x77
0D27E:  MOVLB  0
....................                 } 
....................                 i++; 
0D280:  MOVLB  5
0D282:  INCF   x75,F
....................             break; 
0D284:  BRA    D3A6
....................             case 9: 
....................                 envia_maquina_para_posicao(DISPENSADOR); 
0D286:  MOVLW  05
0D288:  MOVLB  5
0D28A:  MOVWF  x78
0D28C:  MOVLB  0
0D28E:  CALL   5C9C
....................                 if (Teclado() == ESC){ 
0D292:  CALL   6564
0D296:  MOVF   01,W
0D298:  SUBLW  12
0D29A:  BNZ   D2DC
....................                     printf(lcd_putc, "\f"); //limpa display 
0D29C:  MOVLW  0C
0D29E:  MOVLB  5
0D2A0:  MOVWF  x86
0D2A2:  MOVLB  0
0D2A4:  CALL   2D32
....................                     printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0D2A8:  MOVLW  E2
0D2AA:  MOVWF  FF6
0D2AC:  MOVLW  11
0D2AE:  MOVWF  FF7
0D2B0:  CALL   2D86
....................                     printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D2B4:  MOVLW  FA
0D2B6:  MOVWF  FF6
0D2B8:  MOVLW  11
0D2BA:  MOVWF  FF7
0D2BC:  CALL   2D86
....................                     delay_ms(1000); 
0D2C0:  MOVLW  04
0D2C2:  MOVLB  5
0D2C4:  MOVWF  x78
0D2C6:  MOVLW  FA
0D2C8:  MOVWF  x92
0D2CA:  MOVLB  0
0D2CC:  CALL   2958
0D2D0:  MOVLB  5
0D2D2:  DECFSZ x78,F
0D2D4:  BRA    D2C6
....................                     sair = 1; 
0D2D6:  MOVLW  01
0D2D8:  MOVWF  x77
0D2DA:  MOVLB  0
....................                 } 
....................                 i++; 
0D2DC:  MOVLB  5
0D2DE:  INCF   x75,F
....................             break; 
0D2E0:  BRA    D3A6
....................             case 10: 
....................                 desliga_pressor(); 
0D2E2:  CALL   75AC
....................                 dispensa_placa(); 
0D2E6:  BRA    CE20
....................                 if (Teclado() == ESC){ 
0D2E8:  CALL   6564
0D2EC:  MOVF   01,W
0D2EE:  SUBLW  12
0D2F0:  BNZ   D332
....................                     printf(lcd_putc, "\f"); //limpa display 
0D2F2:  MOVLW  0C
0D2F4:  MOVLB  5
0D2F6:  MOVWF  x86
0D2F8:  MOVLB  0
0D2FA:  CALL   2D32
....................                     printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0D2FE:  MOVLW  12
0D300:  MOVWF  FF6
0D302:  MOVLW  12
0D304:  MOVWF  FF7
0D306:  CALL   2D86
....................                     printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D30A:  MOVLW  2A
0D30C:  MOVWF  FF6
0D30E:  MOVLW  12
0D310:  MOVWF  FF7
0D312:  CALL   2D86
....................                     delay_ms(1000); 
0D316:  MOVLW  04
0D318:  MOVLB  5
0D31A:  MOVWF  x78
0D31C:  MOVLW  FA
0D31E:  MOVWF  x92
0D320:  MOVLB  0
0D322:  CALL   2958
0D326:  MOVLB  5
0D328:  DECFSZ x78,F
0D32A:  BRA    D31C
....................                     sair = 1; 
0D32C:  MOVLW  01
0D32E:  MOVWF  x77
0D330:  MOVLB  0
....................                 } 
....................                 i++; 
0D332:  MOVLB  5
0D334:  INCF   x75,F
....................             break; 
0D336:  BRA    D3A6
....................             case 11: 
....................                 //envia_maquina_para_posicao(HOME2); 
....................                 //if (Teclado() == ESC){ 
....................                 //    printf(lcd_putc, "\f"); //limpa display 
....................                 //    printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
....................                 //    printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
....................                 //    delay_ms(2000); 
....................                 //    sair = 1; 
....................                 //} 
....................                 i++; 
0D338:  MOVLB  5
0D33A:  INCF   x75,F
....................             break; 
0D33C:  BRA    D3A6
....................             case 12: 
....................                 //envia_maquina_para_posicao(LIMPEZA); 
....................                 //limpa_bicos(2000); 
....................                 //if (Teclado() == ESC){ 
....................                 //    printf(lcd_putc, "\f"); //limpa display 
....................                 //    printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
....................                 //    printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
....................                 //    delay_ms(2000); 
....................                 //    sair = 1; 
....................                 //} 
....................                 i++; 
0D33E:  MOVLB  5
0D340:  INCF   x75,F
....................             break; 
0D342:  BRA    D3A6
....................             case 13: 
....................                 //envia_maquina_para_posicao(LIMPEZA_2); 
....................                 //limpa_bicos(2000); 
....................                 //if (Teclado() == ESC){ 
....................                 //    printf(lcd_putc, "\f"); //limpa display 
....................                 //    printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
....................                 //    printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
....................                 //    delay_ms(2000); 
....................                 //    sair = 1; 
....................                 //} 
....................                 i++; 
0D344:  MOVLB  5
0D346:  INCF   x75,F
....................             break; 
0D348:  BRA    D3A6
....................             case 14: 
....................                 envia_maquina_para_posicao(ALIMENTADOR); 
0D34A:  MOVLB  5
0D34C:  CLRF   x78
0D34E:  MOVLB  0
0D350:  CALL   5C9C
....................                 if (Teclado() == ESC){ 
0D354:  CALL   6564
0D358:  MOVF   01,W
0D35A:  SUBLW  12
0D35C:  BNZ   D39E
....................                     printf(lcd_putc, "\f"); //limpa display 
0D35E:  MOVLW  0C
0D360:  MOVLB  5
0D362:  MOVWF  x86
0D364:  MOVLB  0
0D366:  CALL   2D32
....................                     printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0D36A:  MOVLW  42
0D36C:  MOVWF  FF6
0D36E:  MOVLW  12
0D370:  MOVWF  FF7
0D372:  CALL   2D86
....................                     printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D376:  MOVLW  5A
0D378:  MOVWF  FF6
0D37A:  MOVLW  12
0D37C:  MOVWF  FF7
0D37E:  CALL   2D86
....................                     delay_ms(1000); 
0D382:  MOVLW  04
0D384:  MOVLB  5
0D386:  MOVWF  x78
0D388:  MOVLW  FA
0D38A:  MOVWF  x92
0D38C:  MOVLB  0
0D38E:  CALL   2958
0D392:  MOVLB  5
0D394:  DECFSZ x78,F
0D396:  BRA    D388
....................                     sair = 1; 
0D398:  MOVLW  01
0D39A:  MOVWF  x77
0D39C:  MOVLB  0
....................                 } 
....................                 i++; 
0D39E:  MOVLB  5
0D3A0:  INCF   x75,F
....................             break; 
0D3A2:  BRA    D3A6
0D3A4:  MOVLB  5
....................         } 
....................         if (((i==15)||(i<7))&&(sair == 1)){ 
0D3A6:  MOVF   x75,W
0D3A8:  SUBLW  0F
0D3AA:  BZ    D3B2
0D3AC:  MOVF   x75,W
0D3AE:  SUBLW  06
0D3B0:  BNC   D3C6
0D3B2:  DECFSZ x77,W
0D3B4:  BRA    D3C6
....................             envia_maquina_para_posicao(HOME1); 
0D3B6:  MOVLW  01
0D3B8:  MOVWF  x78
0D3BA:  MOVLB  0
0D3BC:  CALL   5C9C
....................             exit = FALSE; 
0D3C0:  BCF    2D.1
....................         } else{ 
0D3C2:  BRA    D3F4
0D3C4:  MOVLB  5
....................             if ((i==15)&&(sair ==0)){ 
0D3C6:  MOVF   x75,W
0D3C8:  SUBLW  0F
0D3CA:  BNZ   D3D2
0D3CC:  MOVF   x77,F
0D3CE:  BNZ   D3D2
....................                 i =0; 
0D3D0:  CLRF   x75
....................             } 
....................             if ((i==11)&&(sair ==1)){ 
0D3D2:  MOVF   x75,W
0D3D4:  SUBLW  0B
0D3D6:  BNZ   D3F6
0D3D8:  DECFSZ x77,W
0D3DA:  BRA    D3F6
....................                 envia_maquina_para_posicao(HOME2); 
0D3DC:  MOVLW  04
0D3DE:  MOVWF  x78
0D3E0:  MOVLB  0
0D3E2:  CALL   5C9C
....................                 envia_maquina_para_posicao(HOME1); 
0D3E6:  MOVLW  01
0D3E8:  MOVLB  5
0D3EA:  MOVWF  x78
0D3EC:  MOVLB  0
0D3EE:  CALL   5C9C
....................                 exit = FALSE; 
0D3F2:  BCF    2D.1
0D3F4:  MOVLB  5
....................             } 
....................         } 
0D3F6:  BRA    CECC
....................     } 
....................     if ((i == 1)&&(exit == FALSE)){ 
0D3F8:  DECFSZ x75,W
0D3FA:  BRA    D40E
0D3FC:  BTFSC  2D.1
0D3FE:  BRA    D40E
....................         menu_atual = menu_faltaSolda; 
0D400:  MOVLW  13
0D402:  MOVWF  1C
....................         tela_faltaSolda(); 
0D404:  MOVLB  0
0D406:  CALL   B020
....................     } else { 
0D40A:  BRA    D416
0D40C:  MOVLB  5
....................        menu_atual = menu_principal; 
0D40E:  CLRF   1C
....................        tela_principal();  
0D410:  MOVLB  0
0D412:  CALL   63D4
....................     }     
0D416:  GOTO   D8FA (RETURN)
.................... } 
....................  
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Interrupoes de Tempo"> 
....................  
.................... #int_timer0 
....................  
.................... void trata_timer0(void) { 
....................     movimenta_eixo_x(); 
*
0180E:  BRA    1752
.................... } 
01810:  BCF    FF2.2
01812:  GOTO   0078
.................... #int_timer1 
....................  
.................... void trata_timer1(void) { 
....................     movimenta_eixo_y(); 
*
01DBA:  BRA    1CF6
.................... } 
01DBC:  BCF    F9E.0
01DBE:  GOTO   0078
.................... #int_timer2 
....................  
.................... void trata_timer2(void) {//Timer responsavel por contar tempo de execuo 
....................     set_timer2(0xff); 
01DC2:  SETF   FCC
....................     ciclo++; 
01DC4:  MOVLW  01
01DC6:  ADDWF  29,F
01DC8:  BTFSC  FD8.0
01DCA:  INCF   2A,F
01DCC:  BTFSC  FD8.2
01DCE:  INCF   2B,F
01DD0:  BTFSC  FD8.2
01DD2:  INCF   2C,F
.................... } 
01DD4:  BCF    F9E.1
01DD6:  GOTO   0078
.................... #int_timer3 
....................  
.................... void trata_timer3(void) { 
....................      if (flgMove){ 
*
028F6:  BTFSS  2D.2
028F8:  BRA    28FE
....................         movimenta_eixo_z(); 
028FA:  BRA    22BA
....................     } else { 
028FC:  BRA    2900
....................         movimenta_eixo_flip(); 
028FE:  BRA    282A
....................     }   
02900:  BCF    FA1.1
02902:  GOTO   0078
.................... } 
....................  
.................... // </editor-fold> 
....................  
.................... void main() {     
*
0D45C:  CLRF   FF8
0D45E:  BCF    FD0.7
0D460:  BSF    07.7
0D462:  BSF    F94.3
0D464:  BSF    F94.4
0D466:  MOVLW  31
0D468:  MOVWF  FC8
0D46A:  MOVLW  28
0D46C:  MOVWF  FC6
0D46E:  BSF    FC7.7
0D470:  BCF    FC7.6
0D472:  CLRF   1C
0D474:  MOVLW  01
0D476:  MOVWF  21
0D478:  CLRF   22
0D47A:  MOVLW  03
0D47C:  MOVWF  23
0D47E:  CLRF   24
0D480:  MOVLW  01
0D482:  MOVWF  25
0D484:  BSF    2D.0
0D486:  BSF    2D.1
0D488:  BSF    2D.2
0D48A:  BCF    2D.3
0D48C:  MOVWF  2E
0D48E:  MOVWF  2F
0D490:  MOVLB  1
0D492:  CLRF   x2D
0D494:  CLRF   x2C
0D496:  MOVLB  2
0D498:  MOVWF  x00
0D49A:  MOVWF  x01
0D49C:  CLRF   x13
0D49E:  CLRF   x12
0D4A0:  MOVLW  48
0D4A2:  MOVWF  x11
0D4A4:  MOVLW  86
0D4A6:  MOVWF  x10
0D4A8:  CLRF   x17
0D4AA:  CLRF   x16
0D4AC:  CLRF   x15
0D4AE:  MOVLW  7F
0D4B0:  MOVWF  x14
0D4B2:  CLRF   x1B
0D4B4:  CLRF   x1A
0D4B6:  MOVLW  10
0D4B8:  MOVWF  x19
0D4BA:  MOVLW  82
0D4BC:  MOVWF  x18
0D4BE:  CLRF   x1F
0D4C0:  CLRF   x1E
0D4C2:  MOVLW  16
0D4C4:  MOVWF  x1D
0D4C6:  MOVLW  86
0D4C8:  MOVWF  x1C
0D4CA:  CLRF   x23
0D4CC:  CLRF   x22
0D4CE:  MOVLW  16
0D4D0:  MOVWF  x21
0D4D2:  MOVLW  88
0D4D4:  MOVWF  x20
0D4D6:  CLRF   x27
0D4D8:  CLRF   x26
0D4DA:  MOVLW  48
0D4DC:  MOVWF  x25
0D4DE:  MOVLW  86
0D4E0:  MOVWF  x24
0D4E2:  CLRF   x2B
0D4E4:  CLRF   x2A
0D4E6:  MOVLW  61
0D4E8:  MOVWF  x29
0D4EA:  MOVLW  87
0D4EC:  MOVWF  x28
0D4EE:  CLRF   x2F
0D4F0:  CLRF   x2E
0D4F2:  CLRF   x2D
0D4F4:  CLRF   x2C
0D4F6:  MOVLW  14
0D4F8:  MOVWF  x30
0D4FA:  CLRF   x34
0D4FC:  CLRF   x33
0D4FE:  CLRF   x32
0D500:  CLRF   x31
0D502:  CLRF   x38
0D504:  CLRF   x37
0D506:  MOVLW  48
0D508:  MOVWF  x36
0D50A:  MOVLW  85
0D50C:  MOVWF  x35
0D50E:  CLRF   xDA
0D510:  CLRF   xD9
0D512:  CLRF   xDB
0D514:  CLRF   xDC
0D516:  BCF    x0C.5
0D518:  BCF    x0C.6
0D51A:  CLRF   xDE
0D51C:  CLRF   xDD
0D51E:  CLRF   xE0
0D520:  CLRF   xDF
0D522:  CLRF   xE2
0D524:  CLRF   xE1
0D526:  CLRF   xE4
0D528:  CLRF   xE3
0D52A:  CLRF   xE8
0D52C:  CLRF   xE7
0D52E:  CLRF   xE6
0D530:  CLRF   xE5
0D532:  CLRF   xE9
0D534:  MOVLW  13
0D536:  MOVWF  xEA
0D538:  CLRF   xEE
0D53A:  CLRF   xED
0D53C:  MOVLW  48
0D53E:  MOVWF  xEC
0D540:  MOVLW  86
0D542:  MOVWF  xEB
0D544:  CLRF   xF2
0D546:  CLRF   xF1
0D548:  CLRF   xF0
0D54A:  MOVLW  7F
0D54C:  MOVWF  xEF
0D54E:  CLRF   xF6
0D550:  CLRF   xF5
0D552:  MOVLW  10
0D554:  MOVWF  xF4
0D556:  MOVLW  82
0D558:  MOVWF  xF3
0D55A:  CLRF   xFA
0D55C:  CLRF   xF9
0D55E:  MOVLW  16
0D560:  MOVWF  xF8
0D562:  MOVLW  86
0D564:  MOVWF  xF7
0D566:  CLRF   xFE
0D568:  CLRF   xFD
0D56A:  MOVLW  16
0D56C:  MOVWF  xFC
0D56E:  MOVLW  88
0D570:  MOVWF  xFB
0D572:  MOVLB  3
0D574:  CLRF   x02
0D576:  CLRF   x01
0D578:  MOVLW  48
0D57A:  MOVWF  x00
0D57C:  MOVLW  86
0D57E:  MOVLB  2
0D580:  MOVWF  xFF
0D582:  MOVLB  3
0D584:  CLRF   x06
0D586:  MOVLW  80
0D588:  MOVWF  x05
0D58A:  MOVLW  6D
0D58C:  MOVWF  x04
0D58E:  MOVLW  87
0D590:  MOVWF  x03
0D592:  CLRF   x0A
0D594:  CLRF   x09
0D596:  CLRF   x08
0D598:  CLRF   x07
0D59A:  MOVLW  14
0D59C:  MOVWF  x0B
0D59E:  CLRF   x0F
0D5A0:  CLRF   x0E
0D5A2:  CLRF   x0D
0D5A4:  CLRF   x0C
0D5A6:  CLRF   x13
0D5A8:  CLRF   x12
0D5AA:  MOVLW  48
0D5AC:  MOVWF  x11
0D5AE:  MOVLW  85
0D5B0:  MOVWF  x10
0D5B2:  CLRF   xB5
0D5B4:  CLRF   xB4
0D5B6:  CLRF   xB6
0D5B8:  CLRF   xB7
0D5BA:  MOVLB  2
0D5BC:  BCF    x0C.7
0D5BE:  MOVLB  3
0D5C0:  BCF    xB8.0
0D5C2:  BCF    xB8.1
0D5C4:  CLRF   xBA
0D5C6:  CLRF   xB9
0D5C8:  CLRF   xBC
0D5CA:  CLRF   xBB
0D5CC:  CLRF   xBE
0D5CE:  CLRF   xBD
0D5D0:  CLRF   xC0
0D5D2:  CLRF   xBF
0D5D4:  CLRF   xC4
0D5D6:  CLRF   xC3
0D5D8:  CLRF   xC2
0D5DA:  CLRF   xC1
0D5DC:  CLRF   xC5
0D5DE:  MOVLW  13
0D5E0:  MOVWF  xC6
0D5E2:  CLRF   xC8
0D5E4:  CLRF   xC7
0D5E6:  CLRF   xCC
0D5E8:  CLRF   xCB
0D5EA:  MOVLW  48
0D5EC:  MOVWF  xCA
0D5EE:  MOVLW  86
0D5F0:  MOVWF  xC9
0D5F2:  CLRF   xD0
0D5F4:  CLRF   xCF
0D5F6:  CLRF   xCE
0D5F8:  MOVLW  7F
0D5FA:  MOVWF  xCD
0D5FC:  CLRF   xD4
0D5FE:  CLRF   xD3
0D600:  MOVLW  10
0D602:  MOVWF  xD2
0D604:  MOVLW  82
0D606:  MOVWF  xD1
0D608:  CLRF   xD8
0D60A:  CLRF   xD7
0D60C:  MOVLW  16
0D60E:  MOVWF  xD6
0D610:  MOVLW  86
0D612:  MOVWF  xD5
0D614:  CLRF   xDC
0D616:  CLRF   xDB
0D618:  MOVLW  48
0D61A:  MOVWF  xDA
0D61C:  MOVLW  87
0D61E:  MOVWF  xD9
0D620:  CLRF   xE0
0D622:  CLRF   xDF
0D624:  MOVLW  7A
0D626:  MOVWF  xDE
0D628:  MOVLW  86
0D62A:  MOVWF  xDD
0D62C:  CLRF   xE4
0D62E:  CLRF   xE3
0D630:  CLRF   xE2
0D632:  CLRF   xE1
0D634:  MOVLW  14
0D636:  MOVWF  xE5
0D638:  CLRF   xE9
0D63A:  CLRF   xE8
0D63C:  CLRF   xE7
0D63E:  CLRF   xE6
0D640:  MOVLB  4
0D642:  CLRF   x8B
0D644:  CLRF   x8A
0D646:  CLRF   x8C
0D648:  CLRF   x8D
0D64A:  MOVLB  3
0D64C:  BCF    xB8.2
0D64E:  BCF    xB8.3
0D650:  MOVLB  4
0D652:  CLRF   x8F
0D654:  CLRF   x8E
0D656:  CLRF   x91
0D658:  CLRF   x90
0D65A:  CLRF   x93
0D65C:  CLRF   x92
0D65E:  CLRF   x95
0D660:  CLRF   x94
0D662:  CLRF   x99
0D664:  CLRF   x98
0D666:  CLRF   x97
0D668:  CLRF   x96
0D66A:  CLRF   x9A
0D66C:  MOVLW  13
0D66E:  MOVWF  x9B
0D670:  CLRF   x9D
0D672:  CLRF   x9C
0D674:  CLRF   xA1
0D676:  CLRF   xA0
0D678:  MOVLW  48
0D67A:  MOVWF  x9F
0D67C:  MOVLW  86
0D67E:  MOVWF  x9E
0D680:  CLRF   xA5
0D682:  CLRF   xA4
0D684:  CLRF   xA3
0D686:  MOVLW  7F
0D688:  MOVWF  xA2
0D68A:  CLRF   xA9
0D68C:  CLRF   xA8
0D68E:  MOVLW  10
0D690:  MOVWF  xA7
0D692:  MOVLW  82
0D694:  MOVWF  xA6
0D696:  CLRF   xAD
0D698:  CLRF   xAC
0D69A:  MOVLW  16
0D69C:  MOVWF  xAB
0D69E:  MOVLW  86
0D6A0:  MOVWF  xAA
0D6A2:  CLRF   xB1
0D6A4:  CLRF   xB0
0D6A6:  MOVLW  16
0D6A8:  MOVWF  xAF
0D6AA:  MOVLW  88
0D6AC:  MOVWF  xAE
0D6AE:  CLRF   xB5
0D6B0:  CLRF   xB4
0D6B2:  MOVLW  16
0D6B4:  MOVWF  xB3
0D6B6:  MOVLW  87
0D6B8:  MOVWF  xB2
0D6BA:  CLRF   xB9
0D6BC:  CLRF   xB8
0D6BE:  CLRF   xB7
0D6C0:  CLRF   xB6
0D6C2:  MOVLW  14
0D6C4:  MOVWF  xBA
0D6C6:  CLRF   xBE
0D6C8:  CLRF   xBD
0D6CA:  CLRF   xBC
0D6CC:  CLRF   xBB
0D6CE:  MOVLB  5
0D6D0:  CLRF   x60
0D6D2:  CLRF   x5F
0D6D4:  CLRF   x61
0D6D6:  CLRF   x62
0D6D8:  MOVLB  3
0D6DA:  BCF    xB8.4
0D6DC:  MOVLB  5
0D6DE:  CLRF   x64
0D6E0:  CLRF   x63
0D6E2:  CLRF   x66
0D6E4:  CLRF   x65
0D6E6:  CLRF   x68
0D6E8:  CLRF   x67
0D6EA:  CLRF   x6A
0D6EC:  CLRF   x69
0D6EE:  CLRF   x6E
0D6F0:  CLRF   x6D
0D6F2:  CLRF   x6C
0D6F4:  CLRF   x6B
0D6F6:  CLRF   x6F
0D6F8:  MOVLW  13
0D6FA:  MOVWF  x70
0D6FC:  CLRF   x72
0D6FE:  CLRF   x71
0D700:  MOVLW  01
0D702:  MOVWF  x74
0D704:  MOVLW  66
0D706:  MOVWF  x73
0D708:  MOVF   FC1,W
0D70A:  ANDLW  C0
0D70C:  IORLW  0F
0D70E:  MOVWF  FC1
0D710:  MOVLW  07
0D712:  MOVWF  FB4
0D714:  BRA    D724
0D716:  DATA 02,00
0D718:  DATA 16,00
0D71A:  DATA 00,FC
0D71C:  DATA 40,30
0D71E:  DATA 00,D2
0D720:  DATA 41,2E
0D722:  DATA 00,00
0D724:  MOVLW  00
0D726:  MOVWF  FF8
0D728:  MOVLW  D7
0D72A:  MOVWF  FF7
0D72C:  MOVLW  16
0D72E:  MOVWF  FF6
0D730:  TBLRD*+
0D732:  MOVF   FF5,W
0D734:  MOVWF  00
0D736:  XORLW  00
0D738:  BZ    D760
0D73A:  TBLRD*+
0D73C:  MOVF   FF5,W
0D73E:  MOVWF  01
0D740:  BTFSC  FE8.7
0D742:  BRA    D74E
0D744:  ANDLW  0F
0D746:  MOVWF  FEA
0D748:  TBLRD*+
0D74A:  MOVFF  FF5,FE9
0D74E:  BTFSC  01.6
0D750:  TBLRD*+
0D752:  BTFSS  01.6
0D754:  TBLRD*+
0D756:  MOVFF  FF5,FEE
0D75A:  DCFSNZ 00,F
0D75C:  BRA    D730
0D75E:  BRA    D752
0D760:  CLRF   FF8
....................     // <editor-fold defaultstate="collapsed" desc="Inicializao saidas e entradas"> 
....................     setup_adc(ADC_OFF); 
0D762:  BCF    FC2.0
....................     setup_ccp1(CCP_OFF); 
0D764:  MOVLW  F0
0D766:  ANDWF  FBD,F
....................     setup_ccp2(CCP_OFF); 
0D768:  ANDWF  FBA,F
....................     enable_interrupts(GLOBAL); 
0D76A:  MOVLW  C0
0D76C:  IORWF  FF2,F
....................     setup_psp(PSP_DISABLED); 
0D76E:  BCF    F96.4
....................     output_low(step_y); 
0D770:  BCF    F94.2
0D772:  BCF    F8B.2
....................     output_low(dir_y); 
0D774:  BCF    F94.1
0D776:  BCF    F8B.1
....................     output_low(enable_y); 
0D778:  BCF    F94.0
0D77A:  BCF    F8B.0
....................     output_low(step_x); 
0D77C:  BCF    F95.2
0D77E:  BCF    F8C.2
....................     output_low(dir_x); 
0D780:  BCF    F95.1
0D782:  BCF    F8C.1
....................     output_high(enable_x); 
0D784:  BCF    F95.0
0D786:  BSF    F8C.0
....................     output_low(step_z); 
0D788:  BCF    F92.5
0D78A:  BCF    F89.5
....................     output_low(dir_z); 
0D78C:  BCF    F92.4
0D78E:  BCF    F89.4
....................     output_high(enable_z); 
0D790:  BCF    F92.3
0D792:  BSF    F89.3
....................     output_low(step_flip); 
0D794:  BCF    F96.2
0D796:  BCF    F8D.2
....................     output_low(dir_flip); 
0D798:  BCF    F96.1
0D79A:  BCF    F8D.1
....................     output_low(enable_flip); 
0D79C:  BCF    F96.0
0D79E:  BCF    F8D.0
....................     setup_timer_2(T2_DIV_BY_16, 255, 16); 
0D7A0:  MOVLW  78
0D7A2:  IORLW  06
0D7A4:  MOVWF  FCA
0D7A6:  MOVLW  FF
0D7A8:  MOVWF  FCB
....................     enable_interrupts(INT_TIMER2); 
0D7AA:  BSF    F9D.1
....................     inicializa_display(); 
0D7AC:  MOVLB  0
0D7AE:  GOTO   29CA
....................     Init_Keyboard(); 
0D7B2:  GOTO   2A82
....................     Init_Sensores_porta1(); 
0D7B6:  GOTO   2AAE
....................     Init_saidas(); 
0D7BA:  GOTO   2AC4
....................     desaciona_todas_saidas(); 
0D7BE:  GOTO   2ADA
....................     init_ext_eeprom(); 
0D7C2:  GOTO   2C8C
....................     // </editor-fold> 
....................     tela_apresentacao(); 
0D7C6:  GOTO   2DA6
....................     home_solenoides(); 
0D7CA:  CALL   2E6A
....................     tela_iniciando_maquina(); 
0D7CE:  GOTO   2F02
....................     init_axis_x(); 
0D7D2:  GOTO   34FC
....................     init_axis_y(); 
0D7D6:  GOTO   39D6
....................     init_axis_z(); 
0D7DA:  GOTO   3ED6
....................     init_axis_flip(); 
0D7DE:  GOTO   4316
....................     posicao_maquina_2_default();     
0D7E2:  GOTO   6236
....................     tela_principal();     
0D7E6:  CALL   63D4
....................     while(run_ok){ 
0D7EA:  BTFSS  2D.0
0D7EC:  BRA    D904
....................         if (ciclo % 15 == 0){ 
0D7EE:  BSF    FD8.1
0D7F0:  MOVLW  05
0D7F2:  MOVWF  FEA
0D7F4:  MOVLW  75
0D7F6:  MOVWF  FE9
0D7F8:  MOVFF  2C,57C
0D7FC:  MOVFF  2B,57B
0D800:  MOVFF  2A,57A
0D804:  MOVFF  29,579
0D808:  MOVLB  5
0D80A:  CLRF   x80
0D80C:  CLRF   x7F
0D80E:  CLRF   x7E
0D810:  MOVLW  0F
0D812:  MOVWF  x7D
0D814:  MOVLB  0
0D816:  GOTO   6438
0D81A:  MOVFF  578,57C
0D81E:  MOVFF  577,57B
0D822:  MOVFF  576,57A
0D826:  MOVFF  575,579
0D82A:  MOVLB  5
0D82C:  MOVF   x79,F
0D82E:  BTFSS  FD8.2
0D830:  BRA    D900
0D832:  MOVF   x7A,F
0D834:  BTFSS  FD8.2
0D836:  BRA    D900
0D838:  MOVF   x7B,F
0D83A:  BNZ   D900
0D83C:  MOVF   x7C,F
0D83E:  BNZ   D900
....................             switch(menu_atual){ 
0D840:  MOVF   1C,W
0D842:  ADDLW  EA
0D844:  BC    D900
0D846:  ADDLW  16
0D848:  MOVLB  0
0D84A:  GOTO   D906
....................                 case menu_principal:  
....................                     atualiza_tela_principal(); 
0D84E:  GOTO   6CF0
....................                 break;  
0D852:  MOVLB  5
0D854:  BRA    D900
....................                 case menu_seleciona_maquina: 
....................                     atualiza_tela_seleciona_maquina(); 
0D856:  GOTO   6DFE
....................                 break; 
0D85A:  MOVLB  5
0D85C:  BRA    D900
....................                 case menu_manutencao_outra_maquina: 
....................                     atualiza_tela_manutencao_outra_maquina(); 
0D85E:  GOTO   6E76
....................                 break; 
0D862:  MOVLB  5
0D864:  BRA    D900
....................                 case menu_confirmaManutencao: 
....................                     atualiza_tela_confirmaManutencao(); 
0D866:  GOTO   6E8C
....................                 break; 
0D86A:  MOVLB  5
0D86C:  BRA    D900
....................                 case menu_edita_modelo: 
....................                     atualiza_tela_edita_modelo(); 
0D86E:  GOTO   6F38
....................                 break; 
0D872:  MOVLB  5
0D874:  BRA    D900
....................                 case menu_seleciona_debug: 
....................                     atualiza_tela_seleciona_debug(); 
0D876:  GOTO   6FFA
....................                 break; 
0D87A:  MOVLB  5
0D87C:  BRA    D900
....................                 case menu_edita_pontos_no_modelo: 
....................                     atualiza_tela_edita_pontos_no_modelo(); 
0D87E:  GOTO   7186
....................                 break; 
0D882:  MOVLB  5
0D884:  BRA    D900
....................                 case menu_seleciona_pontos: 
....................                     atualiza_tela_seleciona_pontos(); 
0D886:  GOTO   75BC
....................                 break; 
0D88A:  MOVLB  5
0D88C:  BRA    D900
....................                 case menu_dados_ponto: 
....................                     atualiza_tela_dados_ponto(); 
0D88E:  GOTO   9354
....................                 break; 
0D892:  MOVLB  5
0D894:  BRA    D900
....................                 case menu_dados_ponto_2: 
....................                     atualiza_tela_dados_ponto_2(); 
0D896:  GOTO   9ED0
....................                 break; 
0D89A:  MOVLB  5
0D89C:  BRA    D900
....................                 case menu_excluir_modelo: 
....................                     atualiza_tela_excluir_modelo(); 
0D89E:  GOTO   AF84
....................                 break; 
0D8A2:  MOVLB  5
0D8A4:  BRA    D900
....................                 case menu_faltaSolda: 
....................                     atualiza_tela_faltaSolda(); 
0D8A6:  GOTO   B05E
....................                 break; 
0D8AA:  MOVLB  5
0D8AC:  BRA    D900
....................                 case menu_seleciona_debug_2: 
....................                     atualiza_tela_seleciona_debug_2(); 
0D8AE:  GOTO   B1EC
....................                 break; 
0D8B2:  MOVLB  5
0D8B4:  BRA    D900
....................                 case menu_seleciona_manutencao: 
....................                     atualiza_tela_seleciona_manutencao(); 
0D8B6:  GOTO   B58E
....................                 break;                 
0D8BA:  MOVLB  5
0D8BC:  BRA    D900
....................                 case menu_debug_entrada_1: 
....................                     atualiza_tela_debug_entrada_1(); 
0D8BE:  GOTO   B7AC
....................                 break; 
0D8C2:  MOVLB  5
0D8C4:  BRA    D900
....................                 case menu_debug_entrada_2: 
....................                     atualiza_tela_debug_entrada_2(); 
0D8C6:  GOTO   BA4A
....................                 break; 
0D8CA:  MOVLB  5
0D8CC:  BRA    D900
....................                 case menu_debug_entrada_3: 
....................                     atualiza_tela_debug_entrada_3(); 
0D8CE:  GOTO   BAD4
....................                 break; 
0D8D2:  MOVLB  5
0D8D4:  BRA    D900
....................                 case menu_debug_saida_1: 
....................                     atualiza_tela_debug_saida_1(); 
0D8D6:  GOTO   BC2E
....................                 break; 
0D8DA:  MOVLB  5
0D8DC:  BRA    D900
....................                 case menu_debug_saida_2: 
....................                     atualiza_tela_debug_saida_2(); 
0D8DE:  GOTO   BDF0
....................                 break; 
0D8E2:  MOVLB  5
0D8E4:  BRA    D900
....................                 case menu_debug_saida_3: 
....................                     atualiza_tela_debug_saida_3(); 
0D8E6:  GOTO   C06A
....................                 break; 
0D8EA:  MOVLB  5
0D8EC:  BRA    D900
....................                 case menu_debug_saida_4: 
....................                     atualiza_tela_debug_saida_4(); 
0D8EE:  GOTO   C208
....................                 break; 
0D8F2:  MOVLB  5
0D8F4:  BRA    D900
....................                 case menu_programa_principal: 
....................                     programa_principal_teste(); 
0D8F6:  GOTO   CEC8
....................                 break; 
0D8FA:  MOVLB  5
0D8FC:  BRA    D900
0D8FE:  MOVLB  5
....................             } 
....................         } 
0D900:  MOVLB  0
0D902:  BRA    D7EA
....................     }     
.................... } 
0D904:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C000   PROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
