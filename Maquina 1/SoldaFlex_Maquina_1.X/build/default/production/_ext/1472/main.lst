CCS PCH C Compiler, Version 5.007, 61971               18-mar-19 16:37

               Filename:   C:\Users\ICTS-0101\Desktop\software solda\Maquina 1\SoldaFlex_Maquina_1.X\build\default\production\_ext\1472\main.lst

               ROM used:   56202 bytes (86%)
                           Largest free fragment is 9330
               RAM used:   1404 (35%) at main() level
                           1450 (37%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   D698
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  FF2.5
0004A:  GOTO   0054
0004E:  BTFSC  FF2.2
00050:  GOTO   180C
00054:  BTFSS  F9D.0
00056:  GOTO   0060
0005A:  BTFSC  F9E.0
0005C:  GOTO   1DB8
00060:  BTFSS  F9D.1
00062:  GOTO   006C
00066:  BTFSC  F9E.1
00068:  GOTO   1DC0
0006C:  BTFSS  FA0.1
0006E:  GOTO   0078
00072:  BTFSC  FA1.1
00074:  GOTO   28F2
00078:  MOVFF  0E,00
0007C:  MOVFF  0F,01
00080:  MOVFF  10,02
00084:  MOVFF  11,03
00088:  MOVFF  0C,FE9
0008C:  MOVFF  07,FEA
00090:  BSF    07.7
00092:  MOVFF  08,FE1
00096:  MOVFF  09,FE2
0009A:  MOVFF  0A,FD9
0009E:  MOVFF  0B,FDA
000A2:  MOVFF  12,FF3
000A6:  MOVFF  13,FF4
000AA:  MOVFF  14,FFA
000AE:  MOVF   04,W
000B0:  MOVFF  06,FE0
000B4:  MOVFF  05,FD8
000B8:  RETFIE 0
.................... #include <18F4620.h> 
.................... //////// Standard Header file for the PIC18F4620 device //////////////// 
.................... #device PIC18F4620 
000BA:  DATA 65,72
000BC:  DATA 72,6F
000BE:  DATA 20,64
000C0:  DATA 65,20
000C2:  DATA 65,73
000C4:  DATA 63,72
000C6:  DATA 69,74
000C8:  DATA 61,20
000CA:  DATA 00,00
000CC:  DATA 20,20
000CE:  DATA 20,45
000D0:  DATA 45,50
000D2:  DATA 52,4F
000D4:  DATA 4D,20
000D6:  DATA 20,20
000D8:  DATA 20,20
000DA:  DATA 20,20
000DC:  DATA 00,00
000DE:  DATA 65,72
000E0:  DATA 72,6F
000E2:  DATA 20,64
000E4:  DATA 65,20
000E6:  DATA 6C,65
000E8:  DATA 69,74
000EA:  DATA 75,72
000EC:  DATA 61,20
000EE:  DATA 20,00
000F0:  DATA 20,20
000F2:  DATA 20,20
000F4:  DATA 20,45
000F6:  DATA 45,50
000F8:  DATA 52,4F
000FA:  DATA 4D,20
000FC:  DATA 20,20
000FE:  DATA 20,20
00100:  DATA 20,00
00102:  DATA 20,20
00104:  DATA 20,20
00106:  DATA 20,20
00108:  DATA 20,20
0010A:  DATA 49,43
0010C:  DATA 54,53
0010E:  DATA 20,20
00110:  DATA 20,20
00112:  DATA 20,20
00114:  DATA 20,20
00116:  DATA 0A,0D
00118:  DATA 00,00
0011A:  DATA 20,20
0011C:  DATA 49,4E
0011E:  DATA 53,54
00120:  DATA 49,54
00122:  DATA 55,54
00124:  DATA 4F,20
00126:  DATA 43,45
00128:  DATA 4E,54
0012A:  DATA 52,4F
0012C:  DATA 20,20
0012E:  DATA 0A,0D
00130:  DATA 00,00
00132:  DATA 20,20
00134:  DATA 20,20
00136:  DATA 54,45
00138:  DATA 43,4E
0013A:  DATA 4F,4C
0013C:  DATA 4F,47
0013E:  DATA 49,41
00140:  DATA 20,45
00142:  DATA 4D,20
00144:  DATA 20,20
00146:  DATA 0A,0D
00148:  DATA 00,00
0014A:  DATA 20,20
0014C:  DATA 20,20
0014E:  DATA 20,20
00150:  DATA 53,4F
00152:  DATA 46,54
00154:  DATA 57,41
00156:  DATA 52,45
00158:  DATA 20,20
0015A:  DATA 20,20
0015C:  DATA 20,20
0015E:  DATA 0A,0D
00160:  DATA 00,00
00162:  DATA 20,20
00164:  DATA 20,20
00166:  DATA 20,49
00168:  DATA 4E,49
0016A:  DATA 43,49
0016C:  DATA 41,4E
0016E:  DATA 44,4F
00170:  DATA 20,20
00172:  DATA 20,20
00174:  DATA 20,0A
00176:  DATA 0D,00
00178:  DATA 20,20
0017A:  DATA 20,20
0017C:  DATA 20,20
0017E:  DATA 42,41
00180:  DATA 4E,44
00182:  DATA 45,4A
00184:  DATA 41,53
00186:  DATA 20,20
00188:  DATA 20,20
0018A:  DATA 20,0A
0018C:  DATA 0D,00
0018E:  DATA 4D,4F
00190:  DATA 56,49
00192:  DATA 4D,45
00194:  DATA 4E,54
00196:  DATA 41,4E
00198:  DATA 44,4F
0019A:  DATA 20,42
0019C:  DATA 41,4E
0019E:  DATA 44,45
001A0:  DATA 4A,41
001A2:  DATA 0A,0D
001A4:  DATA 00,00
001A6:  DATA 20,20
001A8:  DATA 20,20
001AA:  DATA 50,41
001AC:  DATA 52,41
001AE:  DATA 20,50
001B0:  DATA 4F,53
001B2:  DATA 49,43
001B4:  DATA 41,4F
001B6:  DATA 20,20
001B8:  DATA 20,20
001BA:  DATA 0A,0D
001BC:  DATA 00,00
001BE:  DATA 20,20
001C0:  DATA 20,20
001C2:  DATA 20,41
001C4:  DATA 4C,49
001C6:  DATA 4D,45
001C8:  DATA 4E,54
001CA:  DATA 41,44
001CC:  DATA 4F,52
001CE:  DATA 20,20
001D0:  DATA 20,20
001D2:  DATA 0A,0D
001D4:  DATA 00,00
001D6:  DATA 4D,4F
001D8:  DATA 56,49
001DA:  DATA 4D,45
001DC:  DATA 4E,54
001DE:  DATA 41,4E
001E0:  DATA 44,4F
001E2:  DATA 20,42
001E4:  DATA 41,4E
001E6:  DATA 44,45
001E8:  DATA 4A,41
001EA:  DATA 0A,0D
001EC:  DATA 00,00
001EE:  DATA 20,20
001F0:  DATA 20,20
001F2:  DATA 50,41
001F4:  DATA 52,41
001F6:  DATA 20,50
001F8:  DATA 4F,53
001FA:  DATA 49,43
001FC:  DATA 41,4F
001FE:  DATA 20,20
00200:  DATA 20,20
00202:  DATA 0A,0D
00204:  DATA 00,00
00206:  DATA 20,20
00208:  DATA 20,20
0020A:  DATA 20,20
0020C:  DATA 20,48
0020E:  DATA 4F,4D
00210:  DATA 45,20
00212:  DATA 31,20
00214:  DATA 20,20
00216:  DATA 20,20
00218:  DATA 20,20
0021A:  DATA 0A,0D
0021C:  DATA 00,00
0021E:  DATA 4D,4F
00220:  DATA 56,49
00222:  DATA 4D,45
00224:  DATA 4E,54
00226:  DATA 41,4E
00228:  DATA 44,4F
0022A:  DATA 20,42
0022C:  DATA 41,4E
0022E:  DATA 44,45
00230:  DATA 4A,41
00232:  DATA 0A,0D
00234:  DATA 00,00
00236:  DATA 20,20
00238:  DATA 20,20
0023A:  DATA 50,41
0023C:  DATA 52,41
0023E:  DATA 20,50
00240:  DATA 4F,53
00242:  DATA 49,43
00244:  DATA 41,4F
00246:  DATA 20,20
00248:  DATA 20,20
0024A:  DATA 0A,0D
0024C:  DATA 00,00
0024E:  DATA 20,20
00250:  DATA 20,20
00252:  DATA 20,20
00254:  DATA 53,4F
00256:  DATA 4C,44
00258:  DATA 41,47
0025A:  DATA 45,4D
0025C:  DATA 20,20
0025E:  DATA 20,20
00260:  DATA 20,0A
00262:  DATA 0D,00
00264:  DATA 4D,4F
00266:  DATA 56,49
00268:  DATA 4D,45
0026A:  DATA 4E,54
0026C:  DATA 41,4E
0026E:  DATA 44,4F
00270:  DATA 20,42
00272:  DATA 41,4E
00274:  DATA 44,45
00276:  DATA 4A,41
00278:  DATA 0A,0D
0027A:  DATA 00,00
0027C:  DATA 20,20
0027E:  DATA 20,20
00280:  DATA 50,41
00282:  DATA 52,41
00284:  DATA 20,50
00286:  DATA 4F,53
00288:  DATA 49,43
0028A:  DATA 41,4F
0028C:  DATA 20,20
0028E:  DATA 20,20
00290:  DATA 0A,0D
00292:  DATA 00,00
00294:  DATA 20,20
00296:  DATA 20,20
00298:  DATA 20,20
0029A:  DATA 20,48
0029C:  DATA 4F,4D
0029E:  DATA 45,20
002A0:  DATA 32,20
002A2:  DATA 20,20
002A4:  DATA 20,20
002A6:  DATA 20,20
002A8:  DATA 0A,0D
002AA:  DATA 00,00
002AC:  DATA 4D,4F
002AE:  DATA 56,49
002B0:  DATA 4D,45
002B2:  DATA 4E,54
002B4:  DATA 41,4E
002B6:  DATA 44,4F
002B8:  DATA 20,42
002BA:  DATA 41,4E
002BC:  DATA 44,45
002BE:  DATA 4A,41
002C0:  DATA 0A,0D
002C2:  DATA 00,00
002C4:  DATA 20,20
002C6:  DATA 20,20
002C8:  DATA 50,41
002CA:  DATA 52,41
002CC:  DATA 20,50
002CE:  DATA 4F,53
002D0:  DATA 49,43
002D2:  DATA 41,4F
002D4:  DATA 20,20
002D6:  DATA 20,20
002D8:  DATA 0A,0D
002DA:  DATA 00,00
002DC:  DATA 20,20
002DE:  DATA 20,20
002E0:  DATA 44,49
002E2:  DATA 53,50
002E4:  DATA 45,4E
002E6:  DATA 53,41
002E8:  DATA 44,4F
002EA:  DATA 52,20
002EC:  DATA 20,20
002EE:  DATA 20,20
002F0:  DATA 0A,0D
002F2:  DATA 00,00
002F4:  DATA 20,20
002F6:  DATA 45,53
002F8:  DATA 50,45
002FA:  DATA 52,41
002FC:  DATA 4E,44
002FE:  DATA 4F,20
00300:  DATA 42,41
00302:  DATA 4E,44
00304:  DATA 45,4A
00306:  DATA 41,20
00308:  DATA 0A,0D
0030A:  DATA 00,00
0030C:  DATA 20,20
0030E:  DATA 20,49
00310:  DATA 52,20
00312:  DATA 50,41
00314:  DATA 52,41
00316:  DATA 20,50
00318:  DATA 4F,53
0031A:  DATA 49,43
0031C:  DATA 41,4F
0031E:  DATA 20,20
00320:  DATA 0A,0D
00322:  DATA 00,00
00324:  DATA 20,20
00326:  DATA 20,20
00328:  DATA 50,52
0032A:  DATA 45,2D
0032C:  DATA 52,45
0032E:  DATA 51,55
00330:  DATA 49,53
00332:  DATA 49,54
00334:  DATA 4F,20
00336:  DATA 20,20
00338:  DATA 0A,0D
0033A:  DATA 00,00
0033C:  DATA 20,20
0033E:  DATA 20,45
00340:  DATA 53,50
00342:  DATA 45,52
00344:  DATA 41,4E
00346:  DATA 44,4F
00348:  DATA 20,4F
0034A:  DATA 55,54
0034C:  DATA 52,41
0034E:  DATA 20,20
00350:  DATA 0A,0D
00352:  DATA 00,00
00354:  DATA 20,20
00356:  DATA 20,20
00358:  DATA 20,20
0035A:  DATA 20,42
0035C:  DATA 41,4E
0035E:  DATA 44,45
00360:  DATA 4A,41
00362:  DATA 20,20
00364:  DATA 20,20
00366:  DATA 20,20
00368:  DATA 0A,0D
0036A:  DATA 00,00
0036C:  DATA 20,20
0036E:  DATA 20,49
00370:  DATA 52,20
00372:  DATA 50,41
00374:  DATA 52,41
00376:  DATA 20,50
00378:  DATA 4F,53
0037A:  DATA 49,43
0037C:  DATA 41,4F
0037E:  DATA 20,20
00380:  DATA 0A,0D
00382:  DATA 00,00
00384:  DATA 20,20
00386:  DATA 20,20
00388:  DATA 20,41
0038A:  DATA 4C,49
0038C:  DATA 4D,45
0038E:  DATA 4E,54
00390:  DATA 41,44
00392:  DATA 4F,52
00394:  DATA 20,20
00396:  DATA 20,20
00398:  DATA 0A,0D
0039A:  DATA 00,00
0039C:  DATA 20,20
0039E:  DATA 20,45
003A0:  DATA 53,50
003A2:  DATA 45,52
003A4:  DATA 41,4E
003A6:  DATA 44,4F
003A8:  DATA 20,4F
003AA:  DATA 55,54
003AC:  DATA 52,41
003AE:  DATA 20,20
003B0:  DATA 0A,0D
003B2:  DATA 00,00
003B4:  DATA 20,20
003B6:  DATA 20,20
003B8:  DATA 20,20
003BA:  DATA 20,42
003BC:  DATA 41,4E
003BE:  DATA 44,45
003C0:  DATA 4A,41
003C2:  DATA 20,20
003C4:  DATA 20,20
003C6:  DATA 20,20
003C8:  DATA 0A,0D
003CA:  DATA 00,00
003CC:  DATA 20,20
003CE:  DATA 20,49
003D0:  DATA 52,20
003D2:  DATA 50,41
003D4:  DATA 52,41
003D6:  DATA 20,50
003D8:  DATA 4F,53
003DA:  DATA 49,43
003DC:  DATA 41,4F
003DE:  DATA 20,20
003E0:  DATA 0A,0D
003E2:  DATA 00,00
003E4:  DATA 20,20
003E6:  DATA 20,20
003E8:  DATA 20,20
003EA:  DATA 20,48
003EC:  DATA 4F,4D
003EE:  DATA 45,20
003F0:  DATA 31,20
003F2:  DATA 20,20
003F4:  DATA 20,20
003F6:  DATA 20,20
003F8:  DATA 0A,0D
003FA:  DATA 00,00
003FC:  DATA 20,20
003FE:  DATA 20,45
00400:  DATA 53,50
00402:  DATA 45,52
00404:  DATA 41,4E
00406:  DATA 44,4F
00408:  DATA 20,4F
0040A:  DATA 55,54
0040C:  DATA 52,41
0040E:  DATA 20,20
00410:  DATA 0A,0D
00412:  DATA 00,00
00414:  DATA 20,20
00416:  DATA 20,20
00418:  DATA 20,20
0041A:  DATA 20,42
0041C:  DATA 41,4E
0041E:  DATA 44,45
00420:  DATA 4A,41
00422:  DATA 20,20
00424:  DATA 20,20
00426:  DATA 20,20
00428:  DATA 0A,0D
0042A:  DATA 00,00
0042C:  DATA 20,20
0042E:  DATA 20,49
00430:  DATA 52,20
00432:  DATA 50,41
00434:  DATA 52,41
00436:  DATA 20,50
00438:  DATA 4F,53
0043A:  DATA 49,43
0043C:  DATA 41,4F
0043E:  DATA 20,20
00440:  DATA 0A,0D
00442:  DATA 00,00
00444:  DATA 20,20
00446:  DATA 20,20
00448:  DATA 20,53
0044A:  DATA 4F,4C
0044C:  DATA 44,41
0044E:  DATA 47,45
00450:  DATA 4D,20
00452:  DATA 31,20
00454:  DATA 20,20
00456:  DATA 20,20
00458:  DATA 0A,0D
0045A:  DATA 00,00
0045C:  DATA 20,20
0045E:  DATA 20,45
00460:  DATA 53,50
00462:  DATA 45,52
00464:  DATA 41,4E
00466:  DATA 44,4F
00468:  DATA 20,4F
0046A:  DATA 55,54
0046C:  DATA 52,41
0046E:  DATA 20,20
00470:  DATA 0A,0D
00472:  DATA 00,00
00474:  DATA 20,20
00476:  DATA 20,20
00478:  DATA 20,20
0047A:  DATA 20,42
0047C:  DATA 41,4E
0047E:  DATA 44,45
00480:  DATA 4A,41
00482:  DATA 20,20
00484:  DATA 20,20
00486:  DATA 20,20
00488:  DATA 0A,0D
0048A:  DATA 00,00
0048C:  DATA 20,20
0048E:  DATA 20,49
00490:  DATA 52,20
00492:  DATA 50,41
00494:  DATA 52,41
00496:  DATA 20,50
00498:  DATA 4F,53
0049A:  DATA 49,43
0049C:  DATA 41,4F
0049E:  DATA 20,20
004A0:  DATA 0A,0D
004A2:  DATA 00,00
004A4:  DATA 20,20
004A6:  DATA 20,20
004A8:  DATA 20,20
004AA:  DATA 20,48
004AC:  DATA 4F,4D
004AE:  DATA 45,20
004B0:  DATA 32,20
004B2:  DATA 20,20
004B4:  DATA 20,20
004B6:  DATA 20,20
004B8:  DATA 0A,0D
004BA:  DATA 00,00
004BC:  DATA 20,20
004BE:  DATA 20,45
004C0:  DATA 53,50
004C2:  DATA 45,52
004C4:  DATA 41,4E
004C6:  DATA 44,4F
004C8:  DATA 20,4F
004CA:  DATA 55,54
004CC:  DATA 52,41
004CE:  DATA 20,20
004D0:  DATA 0A,0D
004D2:  DATA 00,00
004D4:  DATA 20,20
004D6:  DATA 20,20
004D8:  DATA 20,20
004DA:  DATA 20,42
004DC:  DATA 41,4E
004DE:  DATA 44,45
004E0:  DATA 4A,41
004E2:  DATA 20,20
004E4:  DATA 20,20
004E6:  DATA 20,20
004E8:  DATA 0A,0D
004EA:  DATA 00,00
004EC:  DATA 20,20
004EE:  DATA 20,49
004F0:  DATA 52,20
004F2:  DATA 50,41
004F4:  DATA 52,41
004F6:  DATA 20,50
004F8:  DATA 4F,53
004FA:  DATA 49,43
004FC:  DATA 41,4F
004FE:  DATA 20,20
00500:  DATA 0A,0D
00502:  DATA 00,00
00504:  DATA 20,20
00506:  DATA 20,20
00508:  DATA 20,44
0050A:  DATA 49,53
0050C:  DATA 50,45
0050E:  DATA 4E,53
00510:  DATA 41,44
00512:  DATA 4F,52
00514:  DATA 20,20
00516:  DATA 20,20
00518:  DATA 0A,0D
0051A:  DATA 00,00
0051C:  DATA 20,20
0051E:  DATA 20,45
00520:  DATA 53,50
00522:  DATA 45,52
00524:  DATA 41,4E
00526:  DATA 44,4F
00528:  DATA 20,4F
0052A:  DATA 55,54
0052C:  DATA 52,41
0052E:  DATA 20,20
00530:  DATA 0A,0D
00532:  DATA 00,00
00534:  DATA 20,20
00536:  DATA 20,20
00538:  DATA 20,20
0053A:  DATA 20,42
0053C:  DATA 41,4E
0053E:  DATA 44,45
00540:  DATA 4A,41
00542:  DATA 20,20
00544:  DATA 20,20
00546:  DATA 20,20
00548:  DATA 0A,0D
0054A:  DATA 00,00
0054C:  DATA 20,20
0054E:  DATA 20,53
00550:  DATA 41,49
00552:  DATA 52,20
00554:  DATA 44,41
00556:  DATA 20,50
00558:  DATA 4F,53
0055A:  DATA 49,43
0055C:  DATA 41,4F
0055E:  DATA 20,20
00560:  DATA 0A,0D
00562:  DATA 00,00
00564:  DATA 20,20
00566:  DATA 20,20
00568:  DATA 20,20
0056A:  DATA 20,20
0056C:  DATA 41,54
0056E:  DATA 55,41
00570:  DATA 4C,20
00572:  DATA 20,20
00574:  DATA 20,20
00576:  DATA 20,20
00578:  DATA 0A,0D
0057A:  DATA 00,00
0057C:  DATA 20,53
0057E:  DATA 4F,4C
00580:  DATA 44,41
00582:  DATA 44,4F
00584:  DATA 52,20
00586:  DATA 41,55
00588:  DATA 54,4F
0058A:  DATA 4D,41
0058C:  DATA 54,49
0058E:  DATA 43,4F
00590:  DATA 0A,0D
00592:  DATA 00,00
00594:  DATA 20,20
00596:  DATA 20,20
00598:  DATA 20,20
0059A:  DATA 4D,4F
0059C:  DATA 44,45
0059E:  DATA 4C,4F
005A0:  DATA 3A,25
005A2:  DATA 30,32
005A4:  DATA 75,20
005A6:  DATA 20,20
005A8:  DATA 0A,0D
005AA:  DATA 00,00
005AC:  DATA 20,20
005AE:  DATA 20,20
005B0:  DATA 20,4D
005B2:  DATA 45,4E
005B4:  DATA 55,3A
005B6:  DATA 45,44
005B8:  DATA 49,54
005BA:  DATA 41,52
005BC:  DATA 20,20
005BE:  DATA 20,20
005C0:  DATA 0A,0D
005C2:  DATA 00,00
005C4:  DATA 20,20
005C6:  DATA 45,4E
005C8:  DATA 54,45
005CA:  DATA 52,3A
005CC:  DATA 41,55
005CE:  DATA 54,4F
005D0:  DATA 4D,41
005D2:  DATA 54,49
005D4:  DATA 43,4F
005D6:  DATA 20,20
005D8:  DATA 0A,0D
005DA:  DATA 00,00
005DC:  DATA 20,53
005DE:  DATA 45,4C
005E0:  DATA 45,43
005E2:  DATA 49,4F
005E4:  DATA 4E,45
005E6:  DATA 20,41
005E8:  DATA 20,42
005EA:  DATA 41,4E
005EC:  DATA 44,45
005EE:  DATA 4A,41
005F0:  DATA 0A,0D
005F2:  DATA 00,00
005F4:  DATA 20,20
005F6:  DATA 20,20
005F8:  DATA 46,31
005FA:  DATA 3A,20
005FC:  DATA 42,41
005FE:  DATA 4E,44
00600:  DATA 45,4A
00602:  DATA 41,20
00604:  DATA 31,20
00606:  DATA 20,20
00608:  DATA 0A,0D
0060A:  DATA 00,00
0060C:  DATA 20,20
0060E:  DATA 20,20
00610:  DATA 46,32
00612:  DATA 3A,20
00614:  DATA 42,41
00616:  DATA 4E,44
00618:  DATA 45,4A
0061A:  DATA 41,20
0061C:  DATA 32,20
0061E:  DATA 20,20
00620:  DATA 0A,0D
00622:  DATA 00,00
00624:  DATA 20,20
00626:  DATA 20,20
00628:  DATA 45,53
0062A:  DATA 43,3A
0062C:  DATA 42,41
0062E:  DATA 43,4B
00630:  DATA 20,20
00632:  DATA 20,20
00634:  DATA 20,20
00636:  DATA 20,20
00638:  DATA 0A,0D
0063A:  DATA 00,00
0063C:  DATA 20,20
0063E:  DATA 20,20
00640:  DATA 20,4D
00642:  DATA 41,4E
00644:  DATA 55,54
00646:  DATA 45,4E
00648:  DATA 43,41
0064A:  DATA 4F,20
0064C:  DATA 20,20
0064E:  DATA 20,20
00650:  DATA 0A,0D
00652:  DATA 00,00
00654:  DATA 20,20
00656:  DATA 20,20
00658:  DATA 20,20
0065A:  DATA 42,41
0065C:  DATA 4E,44
0065E:  DATA 45,4A
00660:  DATA 41,20
00662:  DATA 32,20
00664:  DATA 20,20
00666:  DATA 20,20
00668:  DATA 0A,0D
0066A:  DATA 00,00
0066C:  DATA 20,20
0066E:  DATA 20,20
00670:  DATA 20,20
00672:  DATA 20,20
00674:  DATA 20,20
00676:  DATA 20,20
00678:  DATA 20,20
0067A:  DATA 20,20
0067C:  DATA 20,20
0067E:  DATA 20,20
00680:  DATA 0A,0D
00682:  DATA 00,00
00684:  DATA 20,20
00686:  DATA 20,20
00688:  DATA 20,20
0068A:  DATA 45,53
0068C:  DATA 43,3A
0068E:  DATA 42,41
00690:  DATA 43,4B
00692:  DATA 20,20
00694:  DATA 20,20
00696:  DATA 20,20
00698:  DATA 0A,0D
0069A:  DATA 00,00
0069C:  DATA 20,20
0069E:  DATA 20,20
006A0:  DATA 45,53
006A2:  DATA 43,4F
006A4:  DATA 4C,48
006A6:  DATA 45,52
006A8:  DATA 20,41
006AA:  DATA 43,41
006AC:  DATA 4F,20
006AE:  DATA 20,20
006B0:  DATA 0A,0D
006B2:  DATA 00,00
006B4:  DATA 46,31
006B6:  DATA 3A,45
006B8:  DATA 44,49
006BA:  DATA 54,41
006BC:  DATA 52,2F
006BE:  DATA 4D,41
006C0:  DATA 4E,55
006C2:  DATA 54,45
006C4:  DATA 4E,43
006C6:  DATA 41,4F
006C8:  DATA 0A,0D
006CA:  DATA 00,00
006CC:  DATA 46,32
006CE:  DATA 3A,45
006D0:  DATA 58,43
006D2:  DATA 4C,55
006D4:  DATA 49,20
006D6:  DATA 4D,4F
006D8:  DATA 44,45
006DA:  DATA 4C,4F
006DC:  DATA 20,20
006DE:  DATA 0A,0D
006E0:  DATA 00,00
006E2:  DATA 45,53
006E4:  DATA 43,3A
006E6:  DATA 42,41
006E8:  DATA 43,4B
006EA:  DATA 20,20
006EC:  DATA 20,20
006EE:  DATA 20,20
006F0:  DATA 20,20
006F2:  DATA 20,20
006F4:  DATA 0A,0D
006F6:  DATA 00,00
006F8:  DATA 20,20
006FA:  DATA 46,31
006FC:  DATA 3A,20
006FE:  DATA 45,44
00700:  DATA 49,54
00702:  DATA 41,52
00704:  DATA 20,50
00706:  DATA 4F,4E
00708:  DATA 54,4F
0070A:  DATA 53,20
0070C:  DATA 0A,0D
0070E:  DATA 00,00
00710:  DATA 20,20
00712:  DATA 46,32
00714:  DATA 3A,20
00716:  DATA 4D,41
00718:  DATA 4E,55
0071A:  DATA 54,45
0071C:  DATA 4E,43
0071E:  DATA 41,4F
00720:  DATA 20,20
00722:  DATA 20,20
00724:  DATA 0A,0D
00726:  DATA 00,00
00728:  DATA 20,20
0072A:  DATA 45,53
0072C:  DATA 43,3A
0072E:  DATA 42,41
00730:  DATA 43,4B
00732:  DATA 20,20
00734:  DATA 20,20
00736:  DATA 20,20
00738:  DATA 20,20
0073A:  DATA 20,20
0073C:  DATA 0A,0D
0073E:  DATA 00,00
00740:  DATA 20,20
00742:  DATA 20,46
00744:  DATA 31,3A
00746:  DATA 20,4E
00748:  DATA 20,50
0074A:  DATA 4F,4E
0074C:  DATA 54,4F
0074E:  DATA 53,20
00750:  DATA 20,20
00752:  DATA 20,20
00754:  DATA 0A,0D
00756:  DATA 00,00
00758:  DATA 20,20
0075A:  DATA 46,32
0075C:  DATA 3A,20
0075E:  DATA 45,44
00760:  DATA 49,54
00762:  DATA 41,52
00764:  DATA 20,50
00766:  DATA 4F,4E
00768:  DATA 54,4F
0076A:  DATA 53,20
0076C:  DATA 0A,0D
0076E:  DATA 00,00
00770:  DATA 20,20
00772:  DATA 45,53
00774:  DATA 43,3A
00776:  DATA 42,41
00778:  DATA 43,4B
0077A:  DATA 20,20
0077C:  DATA 20,20
0077E:  DATA 20,20
00780:  DATA 20,20
00782:  DATA 20,20
00784:  DATA 0A,0D
00786:  DATA 00,00
00788:  DATA 20,20
0078A:  DATA 4E,55
0078C:  DATA 4D,45
0078E:  DATA 52,4F
00790:  DATA 20,44
00792:  DATA 45,20
00794:  DATA 50,4F
00796:  DATA 4E,54
00798:  DATA 4F,53
0079A:  DATA 20,20
0079C:  DATA 0A,0D
0079E:  DATA 00,00
007A0:  DATA 20,20
007A2:  DATA 20,20
007A4:  DATA 20,20
007A6:  DATA 20,20
007A8:  DATA 20,25
007AA:  DATA 30,34
007AC:  DATA 4C,75
007AE:  DATA 20,20
007B0:  DATA 20,20
007B2:  DATA 20,20
007B4:  DATA 20,0A
007B6:  DATA 0D,00
007B8:  DATA 20,45
007BA:  DATA 4E,54
007BC:  DATA 45,52
007BE:  DATA 3A,53
007C0:  DATA 41,56
007C2:  DATA 45,7C
007C4:  DATA 45,53
007C6:  DATA 43,3A
007C8:  DATA 42,41
007CA:  DATA 43,4B
007CC:  DATA 0A,0D
007CE:  DATA 00,00
007D0:  DATA 20,20
007D2:  DATA 20,44
007D4:  DATA 45,53
007D6:  DATA 45,4A
007D8:  DATA 41,20
007DA:  DATA 45,58
007DC:  DATA 43,4C
007DE:  DATA 55,49
007E0:  DATA 52,20
007E2:  DATA 20,20
007E4:  DATA 0A,0D
007E6:  DATA 00,00
007E8:  DATA 20,20
007EA:  DATA 20,20
007EC:  DATA 20,4F
007EE:  DATA 20,4D
007F0:  DATA 4F,44
007F2:  DATA 45,4C
007F4:  DATA 4F,20
007F6:  DATA 3F,20
007F8:  DATA 20,20
007FA:  DATA 20,20
007FC:  DATA 0A,0D
007FE:  DATA 00,00
00800:  DATA 20,20
00802:  DATA 20,20
00804:  DATA 20,20
00806:  DATA 45,4E
00808:  DATA 54,45
0080A:  DATA 52,3A
0080C:  DATA 4F,4B
0080E:  DATA 20,20
00810:  DATA 20,20
00812:  DATA 20,20
00814:  DATA 0A,0D
00816:  DATA 00,00
00818:  DATA 20,20
0081A:  DATA 20,20
0081C:  DATA 20,20
0081E:  DATA 45,53
00820:  DATA 43,3A
00822:  DATA 42,41
00824:  DATA 43,4B
00826:  DATA 20,20
00828:  DATA 20,20
0082A:  DATA 20,0A
0082C:  DATA 0D,00
0082E:  DATA 50,25
00830:  DATA 30,32
00832:  DATA 75,20
00834:  DATA 20,20
00836:  DATA 20,20
00838:  DATA 20,20
0083A:  DATA 20,20
0083C:  DATA 45,4E
0083E:  DATA 54,3A
00840:  DATA 45,44
00842:  DATA 49,54
00844:  DATA 0A,0D
00846:  DATA 00,00
00848:  DATA 50,25
0084A:  DATA 30,32
0084C:  DATA 75,20
0084E:  DATA 20,20
00850:  DATA 20,20
00852:  DATA 20,20
00854:  DATA 20,20
00856:  DATA 45,53
00858:  DATA 43,3A
0085A:  DATA 42,41
0085C:  DATA 43,4B
0085E:  DATA 0A,0D
00860:  DATA 00,00
00862:  DATA 50,25
00864:  DATA 30,32
00866:  DATA 75,20
00868:  DATA 20,20
0086A:  DATA 20,20
0086C:  DATA 20,20
0086E:  DATA 20,20
00870:  DATA 20,20
00872:  DATA 20,20
00874:  DATA 20,20
00876:  DATA 20,20
00878:  DATA 0A,0D
0087A:  DATA 00,00
0087C:  DATA 50,25
0087E:  DATA 30,32
00880:  DATA 75,20
00882:  DATA 20,20
00884:  DATA 20,20
00886:  DATA 20,20
00888:  DATA 20,20
0088A:  DATA 20,20
0088C:  DATA 20,20
0088E:  DATA 20,20
00890:  DATA 20,20
00892:  DATA 0A,0D
00894:  DATA 00,00
00896:  DATA 58,3A
00898:  DATA 25,30
0089A:  DATA 34,4C
0089C:  DATA 75,20
0089E:  DATA 54,3A
008A0:  DATA 25,30
008A2:  DATA 34,4C
008A4:  DATA 75,0A
008A6:  DATA 0D,00
008A8:  DATA 59,3A
008AA:  DATA 25,30
008AC:  DATA 34,4C
008AE:  DATA 75,20
008B0:  DATA 48,3A
008B2:  DATA 25,30
008B4:  DATA 34,4C
008B6:  DATA 75,20
008B8:  DATA 46,3A
008BA:  DATA 25,30
008BC:  DATA 34,4C
008BE:  DATA 75,0A
008C0:  DATA 0D,00
008C2:  DATA 5A,3A
008C4:  DATA 25,30
008C6:  DATA 34,4C
008C8:  DATA 75,20
008CA:  DATA 49,3A
008CC:  DATA 25,30
008CE:  DATA 32,75
008D0:  DATA 20,4C
008D2:  DATA 3A,25
008D4:  DATA 30,34
008D6:  DATA 4C,75
008D8:  DATA 0A,0D
008DA:  DATA 00,00
008DC:  DATA 46,31
008DE:  DATA 3A,47
008E0:  DATA 52,41
008E2:  DATA 56,41
008E4:  DATA 7C,46
008E6:  DATA 33,3A
008E8:  DATA 50,52
008EA:  DATA 4F,58
008EC:  DATA 0A,0D
008EE:  DATA 00,00
008F0:  DATA 53,31
008F2:  DATA 3A,25
008F4:  DATA 30,34
008F6:  DATA 4C,75
008F8:  DATA 0A,0D
008FA:  DATA 00,00
008FC:  DATA 53,32
008FE:  DATA 3A,25
00900:  DATA 30,34
00902:  DATA 4C,75
00904:  DATA 20,45
00906:  DATA 3A,25
00908:  DATA 30,34
0090A:  DATA 4C,75
0090C:  DATA 0A,0D
0090E:  DATA 00,00
00910:  DATA 53,33
00912:  DATA 3A,25
00914:  DATA 30,34
00916:  DATA 4C,75
00918:  DATA 20,49
0091A:  DATA 3A,25
0091C:  DATA 30,32
0091E:  DATA 75,0A
00920:  DATA 0D,00
00922:  DATA 46,31
00924:  DATA 3A,52
00926:  DATA 45,43
00928:  DATA 7C,46
0092A:  DATA 33,3A
0092C:  DATA 42,41
0092E:  DATA 43,4B
00930:  DATA 0A,0D
00932:  DATA 00,00
00934:  DATA 53,32
00936:  DATA 3A,25
00938:  DATA 30,34
0093A:  DATA 4C,75
0093C:  DATA 20,45
0093E:  DATA 3A,25
00940:  DATA 30,34
00942:  DATA 4C,75
00944:  DATA 0A,0D
00946:  DATA 00,00
00948:  DATA 53,33
0094A:  DATA 3A,25
0094C:  DATA 30,34
0094E:  DATA 4C,75
00950:  DATA 20,49
00952:  DATA 3A,25
00954:  DATA 30,32
00956:  DATA 75,0A
00958:  DATA 0D,00
0095A:  DATA 46,31
0095C:  DATA 3A,52
0095E:  DATA 45,43
00960:  DATA 7C,46
00962:  DATA 33,3A
00964:  DATA 42,41
00966:  DATA 43,4B
00968:  DATA 0A,0D
0096A:  DATA 00,00
0096C:  DATA 53,31
0096E:  DATA 3A,25
00970:  DATA 30,34
00972:  DATA 4C,75
00974:  DATA 0A,0D
00976:  DATA 00,00
00978:  DATA 53,32
0097A:  DATA 3A,25
0097C:  DATA 30,34
0097E:  DATA 4C,75
00980:  DATA 20,45
00982:  DATA 3A,25
00984:  DATA 30,34
00986:  DATA 4C,75
00988:  DATA 0A,0D
0098A:  DATA 00,00
0098C:  DATA 20,20
0098E:  DATA 20,20
00990:  DATA 20,20
00992:  DATA 20,49
00994:  DATA 3A,25
00996:  DATA 30,32
00998:  DATA 75,0A
0099A:  DATA 0D,00
0099C:  DATA 46,31
0099E:  DATA 3A,52
009A0:  DATA 45,43
009A2:  DATA 7C,46
009A4:  DATA 33,3A
009A6:  DATA 42,41
009A8:  DATA 43,4B
009AA:  DATA 0A,0D
009AC:  DATA 00,00
009AE:  DATA 53,32
009B0:  DATA 3A,25
009B2:  DATA 30,34
009B4:  DATA 4C,75
009B6:  DATA 20,45
009B8:  DATA 3A,25
009BA:  DATA 30,34
009BC:  DATA 4C,75
009BE:  DATA 0A,0D
009C0:  DATA 00,00
009C2:  DATA 20,20
009C4:  DATA 20,20
009C6:  DATA 20,20
009C8:  DATA 20,49
009CA:  DATA 3A,25
009CC:  DATA 30,32
009CE:  DATA 75,0A
009D0:  DATA 0D,00
009D2:  DATA 46,31
009D4:  DATA 3A,52
009D6:  DATA 45,43
009D8:  DATA 7C,46
009DA:  DATA 33,3A
009DC:  DATA 42,41
009DE:  DATA 43,4B
009E0:  DATA 0A,0D
009E2:  DATA 00,00
009E4:  DATA 20,20
009E6:  DATA 20,20
009E8:  DATA 20,20
009EA:  DATA 56,45
009EC:  DATA 52,49
009EE:  DATA 46,49
009F0:  DATA 51,55
009F2:  DATA 45,20
009F4:  DATA 20,20
009F6:  DATA 20,20
009F8:  DATA 0A,0D
009FA:  DATA 00,00
009FC:  DATA 20,20
009FE:  DATA 4F,53
00A00:  DATA 20,41
00A02:  DATA 4C,49
00A04:  DATA 4D,45
00A06:  DATA 4E,54
00A08:  DATA 41,44
00A0A:  DATA 4F,52
00A0C:  DATA 45,53
00A0E:  DATA 20,20
00A10:  DATA 0A,0D
00A12:  DATA 00,00
00A14:  DATA 20,20
00A16:  DATA 20,20
00A18:  DATA 20,20
00A1A:  DATA 44,45
00A1C:  DATA 20,53
00A1E:  DATA 4F,4C
00A20:  DATA 44,41
00A22:  DATA 20,20
00A24:  DATA 20,20
00A26:  DATA 20,20
00A28:  DATA 0A,0D
00A2A:  DATA 00,00
00A2C:  DATA 20,20
00A2E:  DATA 20,20
00A30:  DATA 20,20
00A32:  DATA 45,4E
00A34:  DATA 54,45
00A36:  DATA 52,3A
00A38:  DATA 4F,4B
00A3A:  DATA 20,20
00A3C:  DATA 20,20
00A3E:  DATA 20,20
00A40:  DATA 0A,0D
00A42:  DATA 00,00
00A44:  DATA 4D,41
00A46:  DATA 4E,55
00A48:  DATA 54,45
00A4A:  DATA 4E,43
00A4C:  DATA 41,4F
00A4E:  DATA 20,42
00A50:  DATA 41,4E
00A52:  DATA 44,45
00A54:  DATA 4A,41
00A56:  DATA 20,32
00A58:  DATA 0A,0D
00A5A:  DATA 00,00
00A5C:  DATA 20,20
00A5E:  DATA 20,4A
00A60:  DATA 41,20
00A62:  DATA 46,49
00A64:  DATA 4E,41
00A66:  DATA 4C,49
00A68:  DATA 5A,41
00A6A:  DATA 44,41
00A6C:  DATA 20,3F
00A6E:  DATA 20,20
00A70:  DATA 0A,0D
00A72:  DATA 00,00
00A74:  DATA 20,20
00A76:  DATA 20,20
00A78:  DATA 20,20
00A7A:  DATA 45,4E
00A7C:  DATA 54,45
00A7E:  DATA 52,3A
00A80:  DATA 4F,4B
00A82:  DATA 20,20
00A84:  DATA 20,20
00A86:  DATA 20,20
00A88:  DATA 0A,0D
00A8A:  DATA 00,00
00A8C:  DATA 20,20
00A8E:  DATA 20,20
00A90:  DATA 20,20
00A92:  DATA 20,45
00A94:  DATA 53,43
00A96:  DATA 3A,4E
00A98:  DATA 4F,20
00A9A:  DATA 20,20
00A9C:  DATA 20,20
00A9E:  DATA 20,20
00AA0:  DATA 0A,0D
00AA2:  DATA 00,00
00AA4:  DATA 20,46
00AA6:  DATA 31,3A
00AA8:  DATA 20,44
00AAA:  DATA 45,42
00AAC:  DATA 55,47
00AAE:  DATA 20,45
00AB0:  DATA 4E,54
00AB2:  DATA 52,41
00AB4:  DATA 44,41
00AB6:  DATA 53,20
00AB8:  DATA 0A,0D
00ABA:  DATA 00,00
00ABC:  DATA 20,46
00ABE:  DATA 32,3A
00AC0:  DATA 20,20
00AC2:  DATA 44,45
00AC4:  DATA 42,55
00AC6:  DATA 47,20
00AC8:  DATA 53,41
00ACA:  DATA 49,44
00ACC:  DATA 41,53
00ACE:  DATA 20,20
00AD0:  DATA 0A,0D
00AD2:  DATA 00,00
00AD4:  DATA 20,20
00AD6:  DATA 20,20
00AD8:  DATA 20,20
00ADA:  DATA 20,20
00ADC:  DATA 20,20
00ADE:  DATA 20,20
00AE0:  DATA 20,20
00AE2:  DATA 20,20
00AE4:  DATA 20,20
00AE6:  DATA 20,20
00AE8:  DATA 0A,0D
00AEA:  DATA 00,00
00AEC:  DATA 20,20
00AEE:  DATA 20,20
00AF0:  DATA 20,20
00AF2:  DATA 45,53
00AF4:  DATA 43,3A
00AF6:  DATA 42,41
00AF8:  DATA 43,4B
00AFA:  DATA 20,20
00AFC:  DATA 20,20
00AFE:  DATA 20,20
00B00:  DATA 0A,0D
00B02:  DATA 00,00
00B04:  DATA 45,30
00B06:  DATA 30,3A
00B08:  DATA 25,30
00B0A:  DATA 32,75
00B0C:  DATA 20,45
00B0E:  DATA 30,31
00B10:  DATA 3A,25
00B12:  DATA 30,32
00B14:  DATA 75,20
00B16:  DATA 45,30
00B18:  DATA 32,3A
00B1A:  DATA 25,30
00B1C:  DATA 32,75
00B1E:  DATA 0A,0D
00B20:  DATA 00,00
00B22:  DATA 45,30
00B24:  DATA 33,3A
00B26:  DATA 25,30
00B28:  DATA 32,75
00B2A:  DATA 20,45
00B2C:  DATA 30,34
00B2E:  DATA 3A,25
00B30:  DATA 30,32
00B32:  DATA 75,20
00B34:  DATA 45,30
00B36:  DATA 35,3A
00B38:  DATA 25,30
00B3A:  DATA 32,75
00B3C:  DATA 0A,0D
00B3E:  DATA 00,00
00B40:  DATA 45,30
00B42:  DATA 36,3A
00B44:  DATA 25,30
00B46:  DATA 32,75
00B48:  DATA 20,45
00B4A:  DATA 30,37
00B4C:  DATA 3A,25
00B4E:  DATA 30,32
00B50:  DATA 75,20
00B52:  DATA 45,30
00B54:  DATA 38,3A
00B56:  DATA 25,30
00B58:  DATA 32,75
00B5A:  DATA 0A,0D
00B5C:  DATA 00,00
00B5E:  DATA 20,20
00B60:  DATA 20,3E
00B62:  DATA 3A,50
00B64:  DATA 52,4F
00B66:  DATA 58,7C
00B68:  DATA 45,53
00B6A:  DATA 43,3A
00B6C:  DATA 42,41
00B6E:  DATA 43,4B
00B70:  DATA 20,20
00B72:  DATA 0A,0D
00B74:  DATA 00,00
00B76:  DATA 45,30
00B78:  DATA 39,3A
00B7A:  DATA 25,30
00B7C:  DATA 32,75
00B7E:  DATA 20,45
00B80:  DATA 31,30
00B82:  DATA 3A,25
00B84:  DATA 30,32
00B86:  DATA 75,20
00B88:  DATA 45,31
00B8A:  DATA 31,3A
00B8C:  DATA 25,30
00B8E:  DATA 32,75
00B90:  DATA 0A,0D
00B92:  DATA 00,00
00B94:  DATA 45,31
00B96:  DATA 32,3A
00B98:  DATA 25,30
00B9A:  DATA 32,75
00B9C:  DATA 20,45
00B9E:  DATA 31,33
00BA0:  DATA 3A,25
00BA2:  DATA 30,32
00BA4:  DATA 75,20
00BA6:  DATA 45,31
00BA8:  DATA 34,3A
00BAA:  DATA 25,30
00BAC:  DATA 32,75
00BAE:  DATA 0A,0D
00BB0:  DATA 00,00
00BB2:  DATA 45,31
00BB4:  DATA 35,3A
00BB6:  DATA 25,30
00BB8:  DATA 32,75
00BBA:  DATA 20,45
00BBC:  DATA 31,36
00BBE:  DATA 3A,25
00BC0:  DATA 30,32
00BC2:  DATA 75,20
00BC4:  DATA 45,31
00BC6:  DATA 37,3A
00BC8:  DATA 25,30
00BCA:  DATA 32,75
00BCC:  DATA 0A,0D
00BCE:  DATA 00,00
00BD0:  DATA 20,20
00BD2:  DATA 3C,7C
00BD4:  DATA 3E,3A
00BD6:  DATA 50,52
00BD8:  DATA 4F,58
00BDA:  DATA 7C,45
00BDC:  DATA 53,43
00BDE:  DATA 3A,42
00BE0:  DATA 41,43
00BE2:  DATA 4B,20
00BE4:  DATA 0A,0D
00BE6:  DATA 00,00
00BE8:  DATA 45,31
00BEA:  DATA 38,3A
00BEC:  DATA 25,30
00BEE:  DATA 32,75
00BF0:  DATA 20,45
00BF2:  DATA 31,39
00BF4:  DATA 3A,25
00BF6:  DATA 30,32
00BF8:  DATA 75,20
00BFA:  DATA 45,32
00BFC:  DATA 30,3A
00BFE:  DATA 25,30
00C00:  DATA 32,75
00C02:  DATA 0A,0D
00C04:  DATA 00,00
00C06:  DATA 45,32
00C08:  DATA 31,3A
00C0A:  DATA 25,30
00C0C:  DATA 32,75
00C0E:  DATA 20,45
00C10:  DATA 32,32
00C12:  DATA 3A,25
00C14:  DATA 30,32
00C16:  DATA 75,20
00C18:  DATA 45,32
00C1A:  DATA 33,3A
00C1C:  DATA 25,30
00C1E:  DATA 32,75
00C20:  DATA 0A,0D
00C22:  DATA 00,00
00C24:  DATA 45,32
00C26:  DATA 34,3A
00C28:  DATA 25,30
00C2A:  DATA 32,75
00C2C:  DATA 20,45
00C2E:  DATA 32,35
00C30:  DATA 3A,25
00C32:  DATA 30,32
00C34:  DATA 75,20
00C36:  DATA 45,32
00C38:  DATA 36,3A
00C3A:  DATA 25,30
00C3C:  DATA 32,75
00C3E:  DATA 0A,0D
00C40:  DATA 00,00
00C42:  DATA 45,32
00C44:  DATA 37,3A
00C46:  DATA 25,30
00C48:  DATA 32,75
00C4A:  DATA 20,3C
00C4C:  DATA 3A,41
00C4E:  DATA 4E,54
00C50:  DATA 7C,45
00C52:  DATA 53,43
00C54:  DATA 3A,42
00C56:  DATA 41,43
00C58:  DATA 4B,0A
00C5A:  DATA 0D,00
00C5C:  DATA 45,53
00C5E:  DATA 54,45
00C60:  DATA 49,52
00C62:  DATA 41,20
00C64:  DATA 20,20
00C66:  DATA 20,20
00C68:  DATA 20,20
00C6A:  DATA 20,20
00C6C:  DATA 20,20
00C6E:  DATA 20,20
00C70:  DATA 0A,0D
00C72:  DATA 00,00
00C74:  DATA 44,45
00C76:  DATA 44,4F
00C78:  DATA 53,20
00C7A:  DATA 45,4E
00C7C:  DATA 54,52
00C7E:  DATA 41,44
00C80:  DATA 41,20
00C82:  DATA 20,20
00C84:  DATA 20,20
00C86:  DATA 20,20
00C88:  DATA 0A,0D
00C8A:  DATA 00,00
00C8C:  DATA 41,4C
00C8E:  DATA 49,4D
00C90:  DATA 45,4E
00C92:  DATA 54,41
00C94:  DATA 44,4F
00C96:  DATA 52,5F
00C98:  DATA 50,4C
00C9A:  DATA 41,43
00C9C:  DATA 41,20
00C9E:  DATA 20,20
00CA0:  DATA 0A,0D
00CA2:  DATA 00,00
00CA4:  DATA 46,31
00CA6:  DATA 3A,4F
00CA8:  DATA 4E,7C
00CAA:  DATA 46,32
00CAC:  DATA 3A,4F
00CAE:  DATA 46,7C
00CB0:  DATA 45,53
00CB2:  DATA 43,3A
00CB4:  DATA 42,41
00CB6:  DATA 43,4B
00CB8:  DATA 0A,0D
00CBA:  DATA 00,00
00CBC:  DATA 50,52
00CBE:  DATA 45,53
00CC0:  DATA 53,4F
00CC2:  DATA 52,20
00CC4:  DATA 20,20
00CC6:  DATA 20,20
00CC8:  DATA 20,20
00CCA:  DATA 20,20
00CCC:  DATA 20,20
00CCE:  DATA 20,20
00CD0:  DATA 0A,0D
00CD2:  DATA 00,00
00CD4:  DATA 44,45
00CD6:  DATA 44,4F
00CD8:  DATA 53,5F
00CDA:  DATA 53,41
00CDC:  DATA 49,44
00CDE:  DATA 41,20
00CE0:  DATA 20,20
00CE2:  DATA 20,20
00CE4:  DATA 20,20
00CE6:  DATA 20,20
00CE8:  DATA 0A,0D
00CEA:  DATA 00,00
00CEC:  DATA 44,49
00CEE:  DATA 53,50
00CF0:  DATA 45,4E
00CF2:  DATA 53,41
00CF4:  DATA 44,4F
00CF6:  DATA 52,5F
00CF8:  DATA 50,4C
00CFA:  DATA 41,43
00CFC:  DATA 41,20
00CFE:  DATA 20,20
00D00:  DATA 0A,0D
00D02:  DATA 00,00
00D04:  DATA 46,31
00D06:  DATA 3A,4F
00D08:  DATA 4E,7C
00D0A:  DATA 46,32
00D0C:  DATA 3A,4F
00D0E:  DATA 46,7C
00D10:  DATA 45,53
00D12:  DATA 43,3A
00D14:  DATA 42,41
00D16:  DATA 43,4B
00D18:  DATA 0A,0D
00D1A:  DATA 00,00
00D1C:  DATA 41,4C
00D1E:  DATA 49,4D
00D20:  DATA 45,4E
00D22:  DATA 54,41
00D24:  DATA 44,4F
00D26:  DATA 52,5F
00D28:  DATA 53,4F
00D2A:  DATA 4C,44
00D2C:  DATA 41,20
00D2E:  DATA 20,20
00D30:  DATA 0A,0D
00D32:  DATA 00,00
00D34:  DATA 4C,49
00D36:  DATA 4D,50
00D38:  DATA 41,44
00D3A:  DATA 4F,52
00D3C:  DATA 5F,42
00D3E:  DATA 49,43
00D40:  DATA 4F,20
00D42:  DATA 20,20
00D44:  DATA 20,20
00D46:  DATA 20,20
00D48:  DATA 0A,0D
00D4A:  DATA 00,00
00D4C:  DATA 46,45
00D4E:  DATA 52,52
00D50:  DATA 4F,53
00D52:  DATA 5F,44
00D54:  DATA 45,5F
00D56:  DATA 53,4F
00D58:  DATA 4C,44
00D5A:  DATA 41,20
00D5C:  DATA 20,20
00D5E:  DATA 20,20
00D60:  DATA 0A,0D
00D62:  DATA 00,00
00D64:  DATA 46,31
00D66:  DATA 3A,4F
00D68:  DATA 4E,7C
00D6A:  DATA 46,32
00D6C:  DATA 3A,4F
00D6E:  DATA 46,7C
00D70:  DATA 45,53
00D72:  DATA 43,3A
00D74:  DATA 42,41
00D76:  DATA 43,4B
00D78:  DATA 0A,0D
00D7A:  DATA 00,00
00D7C:  DATA 20,20
00D7E:  DATA 20,58
00D80:  DATA 3A,25
00D82:  DATA 30,34
00D84:  DATA 4C,75
00D86:  DATA 20,20
00D88:  DATA 59,3A
00D8A:  DATA 25,30
00D8C:  DATA 34,4C
00D8E:  DATA 75,20
00D90:  DATA 20,0A
00D92:  DATA 0D,00
00D94:  DATA 20,20
00D96:  DATA 20,5A
00D98:  DATA 3A,25
00D9A:  DATA 30,34
00D9C:  DATA 4C,75
00D9E:  DATA 20,20
00DA0:  DATA 46,3A
00DA2:  DATA 25,30
00DA4:  DATA 34,4C
00DA6:  DATA 75,20
00DA8:  DATA 20,0A
00DAA:  DATA 0D,00
00DAC:  DATA 20,20
00DAE:  DATA 20,20
00DB0:  DATA 20,20
00DB2:  DATA 20,49
00DB4:  DATA 4E,43
00DB6:  DATA 3A,25
00DB8:  DATA 32,75
00DBA:  DATA 20,20
00DBC:  DATA 20,20
00DBE:  DATA 20,0A
00DC0:  DATA 0D,00
00DC2:  DATA 20,20
00DC4:  DATA 20,20
00DC6:  DATA 20,20
00DC8:  DATA 20,45
00DCA:  DATA 53,43
00DCC:  DATA 3A,42
00DCE:  DATA 41,43
00DD0:  DATA 4B,20
00DD2:  DATA 20,20
00DD4:  DATA 20,20
00DD6:  DATA 20,0A
00DD8:  DATA 0D,00
00DDA:  DATA 20,45
00DDC:  DATA 58,45
00DDE:  DATA 43,55
00DE0:  DATA 54,41
00DE2:  DATA 4E,44
00DE4:  DATA 4F,20
00DE6:  DATA 50,52
00DE8:  DATA 4F,47
00DEA:  DATA 52,41
00DEC:  DATA 4D,41
00DEE:  DATA 0A,0D
00DF0:  DATA 00,00
00DF2:  DATA 20,20
00DF4:  DATA 20,20
00DF6:  DATA 20,4D
00DF8:  DATA 4F,44
00DFA:  DATA 45,4C
00DFC:  DATA 4F,3A
00DFE:  DATA 25,30
00E00:  DATA 32,75
00E02:  DATA 20,20
00E04:  DATA 20,20
00E06:  DATA 0A,0D
00E08:  DATA 00,00
00E0A:  DATA 20,20
00E0C:  DATA 20,20
00E0E:  DATA 20,20
00E10:  DATA 20,20
00E12:  DATA 20,20
00E14:  DATA 20,20
00E16:  DATA 20,20
00E18:  DATA 20,20
00E1A:  DATA 20,20
00E1C:  DATA 20,20
00E1E:  DATA 0A,0D
00E20:  DATA 00,00
00E22:  DATA 20,20
00E24:  DATA 20,20
00E26:  DATA 20,20
00E28:  DATA 45,53
00E2A:  DATA 43,3A
00E2C:  DATA 53,54
00E2E:  DATA 4F,50
00E30:  DATA 20,20
00E32:  DATA 20,20
00E34:  DATA 20,20
00E36:  DATA 0A,0D
00E38:  DATA 00,00
00E3A:  DATA 20,20
00E3C:  DATA 50,4F
00E3E:  DATA 53,49
00E40:  DATA 43,41
00E42:  DATA 4F,20
00E44:  DATA 49,52
00E46:  DATA 52,45
00E48:  DATA 47,55
00E4A:  DATA 4C,41
00E4C:  DATA 52,20
00E4E:  DATA 0A,0D
00E50:  DATA 00,00
00E52:  DATA 20,20
00E54:  DATA 20,58
00E56:  DATA 20,44
00E58:  DATA 45,56
00E5A:  DATA 45,20
00E5C:  DATA 53,45
00E5E:  DATA 52,20
00E60:  DATA 3E,20
00E62:  DATA 30,20
00E64:  DATA 20,20
00E66:  DATA 0A,0D
00E68:  DATA 00,00
00E6A:  DATA 20,20
00E6C:  DATA 59,20
00E6E:  DATA 44,45
00E70:  DATA 56,45
00E72:  DATA 20,53
00E74:  DATA 45,52
00E76:  DATA 20,3E
00E78:  DATA 20,37
00E7A:  DATA 30,30
00E7C:  DATA 20,20
00E7E:  DATA 0A,0D
00E80:  DATA 00,00
00E82:  DATA 20,20
00E84:  DATA 43,41
00E86:  DATA 52,52
00E88:  DATA 45,47
00E8A:  DATA 41,4E
00E8C:  DATA 44,4F
00E8E:  DATA 20,4D
00E90:  DATA 4F,44
00E92:  DATA 45,4C
00E94:  DATA 4F,20
00E96:  DATA 0A,0D
00E98:  DATA 00,00
00E9A:  DATA 20,20
00E9C:  DATA 43,41
00E9E:  DATA 52,52
00EA0:  DATA 45,47
00EA2:  DATA 41,4E
00EA4:  DATA 44,4F
00EA6:  DATA 20,4D
00EA8:  DATA 4F,44
00EAA:  DATA 45,4C
00EAC:  DATA 4F,20
00EAE:  DATA 0A,0D
00EB0:  DATA 00,00
00EB2:  DATA 20,20
00EB4:  DATA 20,45
00EB6:  DATA 53,50
00EB8:  DATA 45,52
00EBA:  DATA 41,4E
00EBC:  DATA 44,4F
00EBE:  DATA 20,50
00EC0:  DATA 4C,41
00EC2:  DATA 43,41
00EC4:  DATA 20,20
00EC6:  DATA 20,0A
00EC8:  DATA 0D,00
00ECA:  DATA 20,20
00ECC:  DATA 20,20
00ECE:  DATA 20,4E
00ED0:  DATA 41,20
00ED2:  DATA 45,53
00ED4:  DATA 54,45
00ED6:  DATA 49,52
00ED8:  DATA 41,20
00EDA:  DATA 20,20
00EDC:  DATA 20,20
00EDE:  DATA 0A,0D
00EE0:  DATA 00,00
00EE2:  DATA 20,56
00EE4:  DATA 45,52
00EE6:  DATA 49,46
00EE8:  DATA 49,51
00EEA:  DATA 55,45
00EEC:  DATA 20,4F
00EEE:  DATA 20,4E
00EF0:  DATA 55,4D
00EF2:  DATA 45,52
00EF4:  DATA 4F,20
00EF6:  DATA 0A,0D
00EF8:  DATA 00,00
00EFA:  DATA 20,44
00EFC:  DATA 45,20
00EFE:  DATA 50,4F
00F00:  DATA 4E,54
00F02:  DATA 4F,53
00F04:  DATA 20,4E
00F06:  DATA 4F,20
00F08:  DATA 4D,4F
00F0A:  DATA 44,45
00F0C:  DATA 4C,4F
00F0E:  DATA 0A,0D
00F10:  DATA 00,00
00F12:  DATA 20,20
00F14:  DATA 20,47
00F16:  DATA 52,41
00F18:  DATA 56,41
00F1A:  DATA 4E,44
00F1C:  DATA 4F,20
00F1E:  DATA 50,4F
00F20:  DATA 4E,54
00F22:  DATA 4F,53
00F24:  DATA 20,20
00F26:  DATA 0A,0D
00F28:  DATA 00,00
00F2A:  DATA 50,4F
00F2C:  DATA 4E,54
00F2E:  DATA 4F,53
00F30:  DATA 20,41
00F32:  DATA 54,55
00F34:  DATA 41,4C
00F36:  DATA 49,5A
00F38:  DATA 41,44
00F3A:  DATA 4F,53
00F3C:  DATA 0A,0D
00F3E:  DATA 00,00
00F40:  DATA 20,20
00F42:  DATA 45,58
00F44:  DATA 43,4C
00F46:  DATA 55,49
00F48:  DATA 4E,44
00F4A:  DATA 4F,20
00F4C:  DATA 4D,4F
00F4E:  DATA 44,45
00F50:  DATA 4C,4F
00F52:  DATA 20,20
00F54:  DATA 0A,0D
00F56:  DATA 00,00
00F58:  DATA 20,20
00F5A:  DATA 20,4D
00F5C:  DATA 4F,44
00F5E:  DATA 45,4C
00F60:  DATA 4F,20
00F62:  DATA 45,58
00F64:  DATA 43,55
00F66:  DATA 49,44
00F68:  DATA 4F,20
00F6A:  DATA 20,20
00F6C:  DATA 0A,0D
00F6E:  DATA 00,00
00F70:  DATA 20,20
00F72:  DATA 20,47
00F74:  DATA 52,41
00F76:  DATA 56,41
00F78:  DATA 4E,44
00F7A:  DATA 4F,20
00F7C:  DATA 50,4F
00F7E:  DATA 4E,54
00F80:  DATA 4F,20
00F82:  DATA 20,20
00F84:  DATA 0A,0D
00F86:  DATA 00,00
00F88:  DATA 20,20
00F8A:  DATA 20,20
00F8C:  DATA 50,4F
00F8E:  DATA 4E,54
00F90:  DATA 4F,20
00F92:  DATA 47,52
00F94:  DATA 41,56
00F96:  DATA 41,44
00F98:  DATA 4F,20
00F9A:  DATA 20,20
00F9C:  DATA 0A,0D
00F9E:  DATA 00,00
00FA0:  DATA 20,20
00FA2:  DATA 20,20
00FA4:  DATA 53,45
00FA6:  DATA 4D,20
00FA8:  DATA 53,4F
00FAA:  DATA 4C,44
00FAC:  DATA 41,20
00FAE:  DATA 4E,4F
00FB0:  DATA 53,20
00FB2:  DATA 20,20
00FB4:  DATA 0A,0D
00FB6:  DATA 00,00
00FB8:  DATA 20,20
00FBA:  DATA 20,20
00FBC:  DATA 41,4C
00FBE:  DATA 49,4D
00FC0:  DATA 45,4E
00FC2:  DATA 54,41
00FC4:  DATA 44,4F
00FC6:  DATA 52,45
00FC8:  DATA 53,20
00FCA:  DATA 20,20
00FCC:  DATA 0A,0D
00FCE:  DATA 00,00
00FD0:  DATA 20,20
00FD2:  DATA 20,47
00FD4:  DATA 52,41
00FD6:  DATA 56,41
00FD8:  DATA 4E,44
00FDA:  DATA 4F,20
00FDC:  DATA 50,4F
00FDE:  DATA 4E,54
00FE0:  DATA 4F,20
00FE2:  DATA 20,20
00FE4:  DATA 0A,0D
00FE6:  DATA 00,00
00FE8:  DATA 20,20
00FEA:  DATA 20,20
00FEC:  DATA 50,4F
00FEE:  DATA 4E,54
00FF0:  DATA 4F,20
00FF2:  DATA 47,52
00FF4:  DATA 41,56
00FF6:  DATA 41,44
00FF8:  DATA 4F,20
00FFA:  DATA 20,20
00FFC:  DATA 0A,0D
00FFE:  DATA 00,00
01000:  DATA 20,20
01002:  DATA 20,20
01004:  DATA 53,45
01006:  DATA 4D,20
01008:  DATA 53,4F
0100A:  DATA 4C,44
0100C:  DATA 41,20
0100E:  DATA 4E,4F
01010:  DATA 53,20
01012:  DATA 20,20
01014:  DATA 0A,0D
01016:  DATA 00,00
01018:  DATA 20,20
0101A:  DATA 20,20
0101C:  DATA 41,4C
0101E:  DATA 49,4D
01020:  DATA 45,4E
01022:  DATA 54,41
01024:  DATA 44,4F
01026:  DATA 52,45
01028:  DATA 53,20
0102A:  DATA 20,20
0102C:  DATA 0A,0D
0102E:  DATA 00,00
01030:  DATA 20,20
01032:  DATA 56,45
01034:  DATA 52,49
01036:  DATA 46,49
01038:  DATA 43,41
0103A:  DATA 4E,44
0103C:  DATA 4F,20
0103E:  DATA 53,4F
01040:  DATA 4C,44
01042:  DATA 41,20
01044:  DATA 0A,0D
01046:  DATA 00,00
01048:  DATA 20,56
0104A:  DATA 45,52
0104C:  DATA 49,46
0104E:  DATA 49,51
01050:  DATA 55,45
01052:  DATA 20,4E
01054:  DATA 4F,56
01056:  DATA 41,4D
01058:  DATA 45,4E
0105A:  DATA 54,45
0105C:  DATA 0A,0D
0105E:  DATA 00,00
01060:  DATA 20,20
01062:  DATA 20,20
01064:  DATA 20,20
01066:  DATA 20,41
01068:  DATA 20,53
0106A:  DATA 4F,4C
0106C:  DATA 44,41
0106E:  DATA 20,20
01070:  DATA 20,20
01072:  DATA 20,20
01074:  DATA 0A,0D
01076:  DATA 00,00
01078:  DATA 20,20
0107A:  DATA 20,20
0107C:  DATA 20,20
0107E:  DATA 53,4F
01080:  DATA 4C,44
01082:  DATA 41,20
01084:  DATA 4F,4B
01086:  DATA 20,20
01088:  DATA 20,20
0108A:  DATA 20,20
0108C:  DATA 0A,0D
0108E:  DATA 00,00
01090:  DATA 20,20
01092:  DATA 20,45
01094:  DATA 53,50
01096:  DATA 45,52
01098:  DATA 41,4E
0109A:  DATA 44,4F
0109C:  DATA 20,50
0109E:  DATA 4C,41
010A0:  DATA 43,41
010A2:  DATA 20,20
010A4:  DATA 20,0A
010A6:  DATA 0D,00
010A8:  DATA 20,20
010AA:  DATA 20,20
010AC:  DATA 20,4E
010AE:  DATA 41,20
010B0:  DATA 45,53
010B2:  DATA 54,45
010B4:  DATA 49,52
010B6:  DATA 41,20
010B8:  DATA 20,20
010BA:  DATA 20,20
010BC:  DATA 0A,0D
010BE:  DATA 00,00
010C0:  DATA 52,45
010C2:  DATA 49,4E
010C4:  DATA 49,43
010C6:  DATA 49,4F
010C8:  DATA 20,44
010CA:  DATA 4F,20
010CC:  DATA 50,52
010CE:  DATA 4F,47
010D0:  DATA 52,41
010D2:  DATA 4D,41
010D4:  DATA 0A,0D
010D6:  DATA 00,00
010D8:  DATA 20,20
010DA:  DATA 20,41
010DC:  DATA 4F,20
010DE:  DATA 46,49
010E0:  DATA 4D,20
010E2:  DATA 44,4F
010E4:  DATA 20,43
010E6:  DATA 49,43
010E8:  DATA 4C,4F
010EA:  DATA 20,20
010EC:  DATA 0A,0D
010EE:  DATA 00,00
010F0:  DATA 20,20
010F2:  DATA 20,20
010F4:  DATA 20,20
010F6:  DATA 53,45
010F8:  DATA 4D,20
010FA:  DATA 50,4C
010FC:  DATA 41,43
010FE:  DATA 41,20
01100:  DATA 20,20
01102:  DATA 20,20
01104:  DATA 0A,0D
01106:  DATA 00,00
01108:  DATA 20,20
0110A:  DATA 20,20
0110C:  DATA 20,4E
0110E:  DATA 41,20
01110:  DATA 42,41
01112:  DATA 4E,44
01114:  DATA 45,4A
01116:  DATA 41,20
01118:  DATA 20,20
0111A:  DATA 20,20
0111C:  DATA 0A,0D
0111E:  DATA 00,00
01120:  DATA 52,45
01122:  DATA 49,4E
01124:  DATA 49,43
01126:  DATA 49,4F
01128:  DATA 20,44
0112A:  DATA 4F,20
0112C:  DATA 50,52
0112E:  DATA 4F,47
01130:  DATA 52,41
01132:  DATA 4D,41
01134:  DATA 0A,0D
01136:  DATA 00,00
01138:  DATA 20,20
0113A:  DATA 20,41
0113C:  DATA 4F,20
0113E:  DATA 46,49
01140:  DATA 4D,20
01142:  DATA 44,4F
01144:  DATA 20,43
01146:  DATA 49,43
01148:  DATA 4C,4F
0114A:  DATA 20,20
0114C:  DATA 0A,0D
0114E:  DATA 00,00
01150:  DATA 52,45
01152:  DATA 49,4E
01154:  DATA 49,43
01156:  DATA 49,4F
01158:  DATA 20,44
0115A:  DATA 4F,20
0115C:  DATA 50,52
0115E:  DATA 4F,47
01160:  DATA 52,41
01162:  DATA 4D,41
01164:  DATA 0A,0D
01166:  DATA 00,00
01168:  DATA 20,20
0116A:  DATA 20,41
0116C:  DATA 4F,20
0116E:  DATA 46,49
01170:  DATA 4D,20
01172:  DATA 44,4F
01174:  DATA 20,43
01176:  DATA 49,43
01178:  DATA 4C,4F
0117A:  DATA 20,20
0117C:  DATA 0A,0D
0117E:  DATA 00,00
01180:  DATA 52,45
01182:  DATA 49,4E
01184:  DATA 49,43
01186:  DATA 49,4F
01188:  DATA 20,44
0118A:  DATA 4F,20
0118C:  DATA 50,52
0118E:  DATA 4F,47
01190:  DATA 52,41
01192:  DATA 4D,41
01194:  DATA 0A,0D
01196:  DATA 00,00
01198:  DATA 20,20
0119A:  DATA 20,41
0119C:  DATA 4F,20
0119E:  DATA 46,49
011A0:  DATA 4D,20
011A2:  DATA 44,4F
011A4:  DATA 20,43
011A6:  DATA 49,43
011A8:  DATA 4C,4F
011AA:  DATA 20,20
011AC:  DATA 0A,0D
011AE:  DATA 00,00
011B0:  DATA 52,45
011B2:  DATA 49,4E
011B4:  DATA 49,43
011B6:  DATA 49,4F
011B8:  DATA 20,44
011BA:  DATA 4F,20
011BC:  DATA 50,52
011BE:  DATA 4F,47
011C0:  DATA 52,41
011C2:  DATA 4D,41
011C4:  DATA 0A,0D
011C6:  DATA 00,00
011C8:  DATA 20,20
011CA:  DATA 20,41
011CC:  DATA 4F,20
011CE:  DATA 46,49
011D0:  DATA 4D,20
011D2:  DATA 44,4F
011D4:  DATA 20,43
011D6:  DATA 49,43
011D8:  DATA 4C,4F
011DA:  DATA 20,20
011DC:  DATA 0A,0D
011DE:  DATA 00,00
011E0:  DATA 52,45
011E2:  DATA 49,4E
011E4:  DATA 49,43
011E6:  DATA 49,4F
011E8:  DATA 20,44
011EA:  DATA 4F,20
011EC:  DATA 50,52
011EE:  DATA 4F,47
011F0:  DATA 52,41
011F2:  DATA 4D,41
011F4:  DATA 0A,0D
011F6:  DATA 00,00
011F8:  DATA 20,20
011FA:  DATA 20,41
011FC:  DATA 4F,20
011FE:  DATA 46,49
01200:  DATA 4D,20
01202:  DATA 44,4F
01204:  DATA 20,43
01206:  DATA 49,43
01208:  DATA 4C,4F
0120A:  DATA 20,20
0120C:  DATA 0A,0D
0120E:  DATA 00,00
01210:  DATA 52,45
01212:  DATA 49,4E
01214:  DATA 49,43
01216:  DATA 49,4F
01218:  DATA 20,44
0121A:  DATA 4F,20
0121C:  DATA 50,52
0121E:  DATA 4F,47
01220:  DATA 52,41
01222:  DATA 4D,41
01224:  DATA 0A,0D
01226:  DATA 00,00
01228:  DATA 20,20
0122A:  DATA 20,41
0122C:  DATA 4F,20
0122E:  DATA 46,49
01230:  DATA 4D,20
01232:  DATA 44,4F
01234:  DATA 20,43
01236:  DATA 49,43
01238:  DATA 4C,4F
0123A:  DATA 20,20
0123C:  DATA 0A,0D
0123E:  DATA 00,00
01240:  DATA 52,45
01242:  DATA 49,4E
01244:  DATA 49,43
01246:  DATA 49,4F
01248:  DATA 20,44
0124A:  DATA 4F,20
0124C:  DATA 50,52
0124E:  DATA 4F,47
01250:  DATA 52,41
01252:  DATA 4D,41
01254:  DATA 0A,0D
01256:  DATA 00,00
01258:  DATA 20,20
0125A:  DATA 20,41
0125C:  DATA 4F,20
0125E:  DATA 46,49
01260:  DATA 4D,20
01262:  DATA 44,4F
01264:  DATA 20,43
01266:  DATA 49,43
01268:  DATA 4C,4F
0126A:  DATA 20,20
0126C:  DATA 0A,0D
0126E:  DATA 00,00
*
02BE2:  TBLRD*+
02BE4:  MOVF   FF5,F
02BE6:  BZ    2C00
02BE8:  MOVFF  FF6,575
02BEC:  MOVFF  FF7,576
02BF0:  MOVFF  FF5,586
02BF4:  RCALL  2BD6
02BF6:  MOVFF  575,FF6
02BFA:  MOVFF  576,FF7
02BFE:  BRA    2BE2
02C00:  RETURN 0
*
02D86:  TBLRD*+
02D88:  MOVF   FF5,F
02D8A:  BZ    2DA4
02D8C:  MOVFF  FF6,57C
02D90:  MOVFF  FF7,57D
02D94:  MOVFF  FF5,585
02D98:  RCALL  2D30
02D9A:  MOVFF  57C,FF6
02D9E:  MOVFF  57D,FF7
02DA2:  BRA    2D86
02DA4:  RETURN 0
*
02F24:  MOVLB  5
02F26:  MOVF   x8F,W
02F28:  BTFSC  FD8.2
02F2A:  BRA    300E
02F2C:  MOVWF  00
02F2E:  MOVF   x93,W
02F30:  BTFSC  FD8.2
02F32:  BRA    300E
02F34:  ADDWF  00,F
02F36:  BNC   2F40
02F38:  MOVLW  81
02F3A:  ADDWF  00,F
02F3C:  BC    300E
02F3E:  BRA    2F48
02F40:  MOVLW  7F
02F42:  SUBWF  00,F
02F44:  BNC   300E
02F46:  BZ    300E
02F48:  MOVFF  590,597
02F4C:  MOVF   x94,W
02F4E:  XORWF  x97,F
02F50:  BSF    x90.7
02F52:  BSF    x94.7
02F54:  MOVF   x92,W
02F56:  MULWF  x96
02F58:  MOVFF  FF4,599
02F5C:  MOVF   x91,W
02F5E:  MULWF  x95
02F60:  MOVFF  FF4,03
02F64:  MOVFF  FF3,598
02F68:  MULWF  x96
02F6A:  MOVF   FF3,W
02F6C:  ADDWF  x99,F
02F6E:  MOVF   FF4,W
02F70:  ADDWFC x98,F
02F72:  MOVLW  00
02F74:  ADDWFC 03,F
02F76:  MOVF   x92,W
02F78:  MULWF  x95
02F7A:  MOVF   FF3,W
02F7C:  ADDWF  x99,F
02F7E:  MOVF   FF4,W
02F80:  ADDWFC x98,F
02F82:  MOVLW  00
02F84:  CLRF   02
02F86:  ADDWFC 03,F
02F88:  ADDWFC 02,F
02F8A:  MOVF   x90,W
02F8C:  MULWF  x96
02F8E:  MOVF   FF3,W
02F90:  ADDWF  x98,F
02F92:  MOVF   FF4,W
02F94:  ADDWFC 03,F
02F96:  MOVLW  00
02F98:  ADDWFC 02,F
02F9A:  MOVF   x90,W
02F9C:  MULWF  x95
02F9E:  MOVF   FF3,W
02FA0:  ADDWF  03,F
02FA2:  MOVF   FF4,W
02FA4:  ADDWFC 02,F
02FA6:  MOVLW  00
02FA8:  CLRF   01
02FAA:  ADDWFC 01,F
02FAC:  MOVF   x92,W
02FAE:  MULWF  x94
02FB0:  MOVF   FF3,W
02FB2:  ADDWF  x98,F
02FB4:  MOVF   FF4,W
02FB6:  ADDWFC 03,F
02FB8:  MOVLW  00
02FBA:  ADDWFC 02,F
02FBC:  ADDWFC 01,F
02FBE:  MOVF   x91,W
02FC0:  MULWF  x94
02FC2:  MOVF   FF3,W
02FC4:  ADDWF  03,F
02FC6:  MOVF   FF4,W
02FC8:  ADDWFC 02,F
02FCA:  MOVLW  00
02FCC:  ADDWFC 01,F
02FCE:  MOVF   x90,W
02FD0:  MULWF  x94
02FD2:  MOVF   FF3,W
02FD4:  ADDWF  02,F
02FD6:  MOVF   FF4,W
02FD8:  ADDWFC 01,F
02FDA:  INCF   00,F
02FDC:  BTFSC  01.7
02FDE:  BRA    2FEA
02FE0:  RLCF   x98,F
02FE2:  RLCF   03,F
02FE4:  RLCF   02,F
02FE6:  RLCF   01,F
02FE8:  DECF   00,F
02FEA:  MOVLW  00
02FEC:  BTFSS  x98.7
02FEE:  BRA    3004
02FF0:  INCF   03,F
02FF2:  ADDWFC 02,F
02FF4:  ADDWFC 01,F
02FF6:  MOVF   01,W
02FF8:  BNZ   3004
02FFA:  MOVF   02,W
02FFC:  BNZ   3004
02FFE:  MOVF   03,W
03000:  BNZ   3004
03002:  INCF   00,F
03004:  BTFSC  x97.7
03006:  BSF    01.7
03008:  BTFSS  x97.7
0300A:  BCF    01.7
0300C:  BRA    3016
0300E:  CLRF   00
03010:  CLRF   01
03012:  CLRF   02
03014:  CLRF   03
03016:  MOVLB  0
03018:  RETURN 0
0301A:  MOVLB  5
0301C:  MOVF   x95,W
0301E:  BTFSC  FD8.2
03020:  BRA    316C
03022:  MOVWF  xA1
03024:  MOVF   x99,W
03026:  BTFSC  FD8.2
03028:  BRA    316C
0302A:  SUBWF  xA1,F
0302C:  BNC   3038
0302E:  MOVLW  7F
03030:  ADDWF  xA1,F
03032:  BTFSC  FD8.0
03034:  BRA    316C
03036:  BRA    3044
03038:  MOVLW  81
0303A:  SUBWF  xA1,F
0303C:  BTFSS  FD8.0
0303E:  BRA    316C
03040:  BTFSC  FD8.2
03042:  BRA    316C
03044:  MOVFF  5A1,00
03048:  CLRF   01
0304A:  CLRF   02
0304C:  CLRF   03
0304E:  CLRF   xA0
03050:  MOVFF  596,59F
03054:  BSF    x9F.7
03056:  MOVFF  597,59E
0305A:  MOVFF  598,59D
0305E:  MOVLW  19
03060:  MOVWF  xA1
03062:  MOVF   x9C,W
03064:  SUBWF  x9D,F
03066:  BC    3082
03068:  MOVLW  01
0306A:  SUBWF  x9E,F
0306C:  BC    3082
0306E:  SUBWF  x9F,F
03070:  BC    3082
03072:  SUBWF  xA0,F
03074:  BC    3082
03076:  INCF   xA0,F
03078:  INCF   x9F,F
0307A:  INCF   x9E,F
0307C:  MOVF   x9C,W
0307E:  ADDWF  x9D,F
03080:  BRA    30D2
03082:  MOVF   x9B,W
03084:  SUBWF  x9E,F
03086:  BC    30AC
03088:  MOVLW  01
0308A:  SUBWF  x9F,F
0308C:  BC    30AC
0308E:  SUBWF  xA0,F
03090:  BC    30AC
03092:  INCF   xA0,F
03094:  INCF   x9F,F
03096:  MOVF   x9B,W
03098:  ADDWF  x9E,F
0309A:  MOVF   x9C,W
0309C:  ADDWF  x9D,F
0309E:  BNC   30D2
030A0:  INCF   x9E,F
030A2:  BNZ   30D2
030A4:  INCF   x9F,F
030A6:  BNZ   30D2
030A8:  INCF   xA0,F
030AA:  BRA    30D2
030AC:  MOVF   x9A,W
030AE:  IORLW  80
030B0:  SUBWF  x9F,F
030B2:  BC    30D0
030B4:  MOVLW  01
030B6:  SUBWF  xA0,F
030B8:  BC    30D0
030BA:  INCF   xA0,F
030BC:  MOVF   x9A,W
030BE:  IORLW  80
030C0:  ADDWF  x9F,F
030C2:  MOVF   x9B,W
030C4:  ADDWF  x9E,F
030C6:  BNC   309A
030C8:  INCF   x9F,F
030CA:  BNZ   309A
030CC:  INCF   xA0,F
030CE:  BRA    309A
030D0:  BSF    03.0
030D2:  DECFSZ xA1,F
030D4:  BRA    30D8
030D6:  BRA    30EE
030D8:  BCF    FD8.0
030DA:  RLCF   x9D,F
030DC:  RLCF   x9E,F
030DE:  RLCF   x9F,F
030E0:  RLCF   xA0,F
030E2:  BCF    FD8.0
030E4:  RLCF   03,F
030E6:  RLCF   02,F
030E8:  RLCF   01,F
030EA:  RLCF   xA2,F
030EC:  BRA    3062
030EE:  BTFSS  xA2.0
030F0:  BRA    30FE
030F2:  BCF    FD8.0
030F4:  RRCF   01,F
030F6:  RRCF   02,F
030F8:  RRCF   03,F
030FA:  RRCF   xA2,F
030FC:  BRA    3102
030FE:  DECF   00,F
03100:  BZ    316C
03102:  BTFSC  xA2.7
03104:  BRA    3142
03106:  BCF    FD8.0
03108:  RLCF   x9D,F
0310A:  RLCF   x9E,F
0310C:  RLCF   x9F,F
0310E:  RLCF   xA0,F
03110:  MOVF   x9C,W
03112:  SUBWF  x9D,F
03114:  BC    3124
03116:  MOVLW  01
03118:  SUBWF  x9E,F
0311A:  BC    3124
0311C:  SUBWF  x9F,F
0311E:  BC    3124
03120:  SUBWF  xA0,F
03122:  BNC   3158
03124:  MOVF   x9B,W
03126:  SUBWF  x9E,F
03128:  BC    3134
0312A:  MOVLW  01
0312C:  SUBWF  x9F,F
0312E:  BC    3134
03130:  SUBWF  xA0,F
03132:  BNC   3158
03134:  MOVF   x9A,W
03136:  IORLW  80
03138:  SUBWF  x9F,F
0313A:  BC    3142
0313C:  MOVLW  01
0313E:  SUBWF  xA0,F
03140:  BNC   3158
03142:  INCF   03,F
03144:  BNZ   3158
03146:  INCF   02,F
03148:  BNZ   3158
0314A:  INCF   01,F
0314C:  BNZ   3158
0314E:  INCF   00,F
03150:  BZ    316C
03152:  RRCF   01,F
03154:  RRCF   02,F
03156:  RRCF   03,F
03158:  MOVFF  596,5A1
0315C:  MOVF   x9A,W
0315E:  XORWF  xA1,F
03160:  BTFSS  xA1.7
03162:  BRA    3168
03164:  BSF    01.7
03166:  BRA    3174
03168:  BCF    01.7
0316A:  BRA    3174
0316C:  CLRF   00
0316E:  CLRF   01
03170:  CLRF   02
03172:  CLRF   03
03174:  MOVLB  0
03176:  RETURN 0
03178:  MOVLW  8E
0317A:  MOVWF  00
0317C:  MOVFF  590,01
03180:  MOVFF  58F,02
03184:  CLRF   03
03186:  MOVF   01,F
03188:  BNZ   319C
0318A:  MOVFF  02,01
0318E:  CLRF   02
03190:  MOVLW  08
03192:  SUBWF  00,F
03194:  MOVF   01,F
03196:  BNZ   319C
03198:  CLRF   00
0319A:  BRA    31AC
0319C:  BCF    FD8.0
0319E:  BTFSC  01.7
031A0:  BRA    31AA
031A2:  RLCF   02,F
031A4:  RLCF   01,F
031A6:  DECF   00,F
031A8:  BRA    319C
031AA:  BCF    01.7
031AC:  RETURN 0
031AE:  MOVLW  80
031B0:  BTFSS  FD8.1
031B2:  BRA    31B8
031B4:  MOVLB  5
031B6:  XORWF  x9A,F
031B8:  MOVLB  5
031BA:  CLRF   x9F
031BC:  CLRF   xA0
031BE:  MOVFF  596,59E
031C2:  MOVF   x9A,W
031C4:  XORWF  x9E,F
031C6:  MOVF   x95,W
031C8:  BTFSC  FD8.2
031CA:  BRA    338A
031CC:  MOVWF  x9D
031CE:  MOVWF  00
031D0:  MOVF   x99,W
031D2:  BTFSC  FD8.2
031D4:  BRA    339C
031D6:  SUBWF  x9D,F
031D8:  BTFSC  FD8.2
031DA:  BRA    32E2
031DC:  BNC   325A
031DE:  MOVFF  59A,5A3
031E2:  BSF    xA3.7
031E4:  MOVFF  59B,5A2
031E8:  MOVFF  59C,5A1
031EC:  CLRF   xA0
031EE:  BCF    FD8.0
031F0:  RRCF   xA3,F
031F2:  RRCF   xA2,F
031F4:  RRCF   xA1,F
031F6:  RRCF   xA0,F
031F8:  DECFSZ x9D,F
031FA:  BRA    31EC
031FC:  BTFSS  x9E.7
031FE:  BRA    3206
03200:  BSF    x9F.0
03202:  BRA    33C4
03204:  BCF    x9F.0
03206:  BCF    x9D.0
03208:  BSF    x9F.4
0320A:  MOVLW  05
0320C:  MOVWF  FEA
0320E:  MOVLW  98
03210:  MOVWF  FE9
03212:  BRA    33EA
03214:  BCF    x9F.4
03216:  BTFSC  x9E.7
03218:  BRA    322E
0321A:  BTFSS  x9D.0
0321C:  BRA    3244
0321E:  RRCF   xA3,F
03220:  RRCF   xA2,F
03222:  RRCF   xA1,F
03224:  RRCF   xA0,F
03226:  INCF   00,F
03228:  BTFSC  FD8.2
0322A:  BRA    33BA
0322C:  BRA    3244
0322E:  BTFSC  xA3.7
03230:  BRA    324A
03232:  BCF    FD8.0
03234:  RLCF   xA0,F
03236:  RLCF   xA1,F
03238:  RLCF   xA2,F
0323A:  RLCF   xA3,F
0323C:  DECF   00,F
0323E:  BTFSC  FD8.2
03240:  BRA    33BA
03242:  BRA    322E
03244:  BSF    x9F.6
03246:  BRA    3322
03248:  BCF    x9F.6
0324A:  MOVFF  596,59E
0324E:  BTFSS  x96.7
03250:  BRA    3256
03252:  BSF    xA3.7
03254:  BRA    33AC
03256:  BCF    xA3.7
03258:  BRA    33AC
0325A:  MOVFF  599,59D
0325E:  MOVFF  599,00
03262:  MOVF   x95,W
03264:  SUBWF  x9D,F
03266:  MOVFF  596,5A3
0326A:  BSF    xA3.7
0326C:  MOVFF  597,5A2
03270:  MOVFF  598,5A1
03274:  CLRF   xA0
03276:  BCF    FD8.0
03278:  RRCF   xA3,F
0327A:  RRCF   xA2,F
0327C:  RRCF   xA1,F
0327E:  RRCF   xA0,F
03280:  DECFSZ x9D,F
03282:  BRA    3274
03284:  BTFSS  x9E.7
03286:  BRA    328E
03288:  BSF    x9F.1
0328A:  BRA    33C4
0328C:  BCF    x9F.1
0328E:  BCF    x9D.0
03290:  BSF    x9F.5
03292:  MOVLW  05
03294:  MOVWF  FEA
03296:  MOVLW  9C
03298:  MOVWF  FE9
0329A:  BRA    33EA
0329C:  BCF    x9F.5
0329E:  BTFSC  x9E.7
032A0:  BRA    32B6
032A2:  BTFSS  x9D.0
032A4:  BRA    32CC
032A6:  RRCF   xA3,F
032A8:  RRCF   xA2,F
032AA:  RRCF   xA1,F
032AC:  RRCF   xA0,F
032AE:  INCF   00,F
032B0:  BTFSC  FD8.2
032B2:  BRA    33BA
032B4:  BRA    32CC
032B6:  BTFSC  xA3.7
032B8:  BRA    32D2
032BA:  BCF    FD8.0
032BC:  RLCF   xA0,F
032BE:  RLCF   xA1,F
032C0:  RLCF   xA2,F
032C2:  RLCF   xA3,F
032C4:  DECF   00,F
032C6:  BTFSC  FD8.2
032C8:  BRA    33BA
032CA:  BRA    32B6
032CC:  BSF    x9F.7
032CE:  BRA    3322
032D0:  BCF    x9F.7
032D2:  MOVFF  59A,59E
032D6:  BTFSS  x9A.7
032D8:  BRA    32DE
032DA:  BSF    xA3.7
032DC:  BRA    33AC
032DE:  BCF    xA3.7
032E0:  BRA    33AC
032E2:  MOVFF  59A,5A3
032E6:  BSF    xA3.7
032E8:  MOVFF  59B,5A2
032EC:  MOVFF  59C,5A1
032F0:  BTFSS  x9E.7
032F2:  BRA    32FC
032F4:  BCF    xA3.7
032F6:  BSF    x9F.2
032F8:  BRA    33C4
032FA:  BCF    x9F.2
032FC:  CLRF   xA0
032FE:  BCF    x9D.0
03300:  MOVLW  05
03302:  MOVWF  FEA
03304:  MOVLW  98
03306:  MOVWF  FE9
03308:  BRA    33EA
0330A:  BTFSC  x9E.7
0330C:  BRA    3346
0330E:  MOVFF  596,59E
03312:  BTFSS  x9D.0
03314:  BRA    3322
03316:  RRCF   xA3,F
03318:  RRCF   xA2,F
0331A:  RRCF   xA1,F
0331C:  RRCF   xA0,F
0331E:  INCF   00,F
03320:  BZ    33BA
03322:  BTFSS  xA0.7
03324:  BRA    333C
03326:  INCF   xA1,F
03328:  BNZ   333C
0332A:  INCF   xA2,F
0332C:  BNZ   333C
0332E:  INCF   xA3,F
03330:  BNZ   333C
03332:  RRCF   xA3,F
03334:  RRCF   xA2,F
03336:  RRCF   xA1,F
03338:  INCF   00,F
0333A:  BZ    33BA
0333C:  BTFSC  x9F.6
0333E:  BRA    3248
03340:  BTFSC  x9F.7
03342:  BRA    32D0
03344:  BRA    337E
03346:  MOVLW  80
03348:  XORWF  xA3,F
0334A:  BTFSS  xA3.7
0334C:  BRA    3356
0334E:  BRA    33C4
03350:  MOVFF  59A,59E
03354:  BRA    336A
03356:  MOVFF  596,59E
0335A:  MOVF   xA3,F
0335C:  BNZ   336A
0335E:  MOVF   xA2,F
03360:  BNZ   336A
03362:  MOVF   xA1,F
03364:  BNZ   336A
03366:  CLRF   00
03368:  BRA    33AC
0336A:  BTFSC  xA3.7
0336C:  BRA    337E
0336E:  BCF    FD8.0
03370:  RLCF   xA0,F
03372:  RLCF   xA1,F
03374:  RLCF   xA2,F
03376:  RLCF   xA3,F
03378:  DECFSZ 00,F
0337A:  BRA    336A
0337C:  BRA    33BA
0337E:  BTFSS  x9E.7
03380:  BRA    3386
03382:  BSF    xA3.7
03384:  BRA    33AC
03386:  BCF    xA3.7
03388:  BRA    33AC
0338A:  MOVFF  599,00
0338E:  MOVFF  59A,5A3
03392:  MOVFF  59B,5A2
03396:  MOVFF  59C,5A1
0339A:  BRA    33AC
0339C:  MOVFF  595,00
033A0:  MOVFF  596,5A3
033A4:  MOVFF  597,5A2
033A8:  MOVFF  598,5A1
033AC:  MOVFF  5A3,01
033B0:  MOVFF  5A2,02
033B4:  MOVFF  5A1,03
033B8:  BRA    3422
033BA:  CLRF   00
033BC:  CLRF   01
033BE:  CLRF   02
033C0:  CLRF   03
033C2:  BRA    3422
033C4:  CLRF   xA0
033C6:  COMF   xA1,F
033C8:  COMF   xA2,F
033CA:  COMF   xA3,F
033CC:  COMF   xA0,F
033CE:  INCF   xA0,F
033D0:  BNZ   33DC
033D2:  INCF   xA1,F
033D4:  BNZ   33DC
033D6:  INCF   xA2,F
033D8:  BNZ   33DC
033DA:  INCF   xA3,F
033DC:  BTFSC  x9F.0
033DE:  BRA    3204
033E0:  BTFSC  x9F.1
033E2:  BRA    328C
033E4:  BTFSC  x9F.2
033E6:  BRA    32FA
033E8:  BRA    3350
033EA:  MOVF   FEF,W
033EC:  ADDWF  xA1,F
033EE:  BNC   33FA
033F0:  INCF   xA2,F
033F2:  BNZ   33FA
033F4:  INCF   xA3,F
033F6:  BTFSC  FD8.2
033F8:  BSF    x9D.0
033FA:  MOVF   FED,F
033FC:  MOVF   FEF,W
033FE:  ADDWF  xA2,F
03400:  BNC   3408
03402:  INCF   xA3,F
03404:  BTFSC  FD8.2
03406:  BSF    x9D.0
03408:  MOVF   FED,F
0340A:  MOVF   FEF,W
0340C:  BTFSC  FEF.7
0340E:  BRA    3412
03410:  XORLW  80
03412:  ADDWF  xA3,F
03414:  BTFSC  FD8.0
03416:  BSF    x9D.0
03418:  BTFSC  x9F.4
0341A:  BRA    3214
0341C:  BTFSC  x9F.5
0341E:  BRA    329C
03420:  BRA    330A
03422:  MOVLB  0
03424:  RETURN 0
03426:  MOVLB  5
03428:  CLRF   x8D
0342A:  CLRF   x8E
0342C:  MOVLW  01
0342E:  MOVWF  x8F
03430:  CLRF   FDA
03432:  CLRF   FD9
03434:  MOVLW  05
03436:  MOVWF  x92
03438:  MOVLW  85
0343A:  MOVWF  x91
0343C:  MOVLW  05
0343E:  MOVWF  FEA
03440:  MOVLW  89
03442:  MOVWF  FE9
03444:  MOVFF  592,FE2
03448:  MOVFF  591,FE1
0344C:  MOVFF  58F,590
03450:  BCF    FD8.0
03452:  MOVF   FE5,W
03454:  MULWF  FEE
03456:  MOVF   FF3,W
03458:  ADDWFC x8D,F
0345A:  MOVF   FF4,W
0345C:  ADDWFC x8E,F
0345E:  DECFSZ x90,F
03460:  BRA    3450
03462:  MOVFF  58D,FDE
03466:  MOVFF  58E,58D
0346A:  CLRF   x8E
0346C:  BTFSC  FD8.0
0346E:  INCF   x8E,F
03470:  INCF   x91,F
03472:  BTFSC  FD8.2
03474:  INCF   x92,F
03476:  INCF   x8F,F
03478:  MOVF   x8F,W
0347A:  SUBLW  05
0347C:  BNZ   343C
0347E:  MOVLB  0
03480:  RETURN 0
03482:  MOVLW  B6
03484:  MOVWF  00
03486:  CLRF   03
03488:  CLRF   02
0348A:  CLRF   01
0348C:  MOVLB  5
0348E:  MOVF   x95,W
03490:  IORWF  x96,W
03492:  IORWF  x97,W
03494:  IORWF  x98,W
03496:  BNZ   349C
03498:  CLRF   00
0349A:  BRA    34B6
0349C:  BCF    FD8.0
0349E:  BTFSC  01.7
034A0:  BRA    34B4
034A2:  RLCF   x95,F
034A4:  RLCF   x96,F
034A6:  RLCF   x97,F
034A8:  RLCF   x98,F
034AA:  RLCF   03,F
034AC:  RLCF   02,F
034AE:  RLCF   01,F
034B0:  DECFSZ 00,F
034B2:  BRA    349C
034B4:  BCF    01.7
034B6:  MOVLB  0
034B8:  RETURN 0
034BA:  MOVLB  5
034BC:  MOVF   x95,W
034BE:  SUBLW  B6
034C0:  MOVWF  x95
034C2:  CLRF   03
034C4:  MOVFF  596,599
034C8:  BSF    x96.7
034CA:  BCF    FD8.0
034CC:  RRCF   x96,F
034CE:  RRCF   x97,F
034D0:  RRCF   x98,F
034D2:  RRCF   03,F
034D4:  RRCF   02,F
034D6:  RRCF   01,F
034D8:  RRCF   00,F
034DA:  DECFSZ x95,F
034DC:  BRA    34CA
034DE:  BTFSS  x99.7
034E0:  BRA    34F8
034E2:  COMF   00,F
034E4:  COMF   01,F
034E6:  COMF   02,F
034E8:  COMF   03,F
034EA:  INCF   00,F
034EC:  BTFSC  FD8.2
034EE:  INCF   01,F
034F0:  BTFSC  FD8.2
034F2:  INCF   02,F
034F4:  BTFSC  FD8.2
034F6:  INCF   03,F
034F8:  MOVLB  0
034FA:  RETURN 0
*
047B8:  MOVFF  FF2,0D
047BC:  BCF    FF2.7
047BE:  ADDWF  FE8,W
047C0:  CLRF   FF7
047C2:  RLCF   FF7,F
047C4:  ADDLW  DD
047C6:  MOVWF  FF6
047C8:  MOVLW  47
047CA:  ADDWFC FF7,F
047CC:  TBLRD*-
047CE:  MOVF   FF5,W
047D0:  MOVWF  FFA
047D2:  TBLRD*
047D4:  MOVF   FF5,W
047D6:  BTFSC  0D.7
047D8:  BSF    FF2.7
047DA:  MOVWF  FF9
047DC:  DATA 62,47
047DE:  DATA 72,47
047E0:  DATA B2,47
047E2:  DATA 82,47
047E4:  DATA 92,47
047E6:  DATA A2,47
*
04904:  MOVFF  FF2,0D
04908:  BCF    FF2.7
0490A:  ADDWF  FE8,W
0490C:  CLRF   FF7
0490E:  RLCF   FF7,F
04910:  ADDLW  29
04912:  MOVWF  FF6
04914:  MOVLW  49
04916:  ADDWFC FF7,F
04918:  TBLRD*-
0491A:  MOVF   FF5,W
0491C:  MOVWF  FFA
0491E:  TBLRD*
04920:  MOVF   FF5,W
04922:  BTFSC  0D.7
04924:  BSF    FF2.7
04926:  MOVWF  FF9
04928:  DATA FA,47
0492A:  DATA 2E,48
0492C:  DATA FE,48
0492E:  DATA 62,48
04930:  DATA 96,48
04932:  DATA CA,48
*
04C0A:  MOVFF  FF2,0D
04C0E:  BCF    FF2.7
04C10:  ADDWF  FE8,W
04C12:  CLRF   FF7
04C14:  RLCF   FF7,F
04C16:  ADDLW  2F
04C18:  MOVWF  FF6
04C1A:  MOVLW  4C
04C1C:  ADDWFC FF7,F
04C1E:  TBLRD*-
04C20:  MOVF   FF5,W
04C22:  MOVWF  FFA
04C24:  TBLRD*
04C26:  MOVF   FF5,W
04C28:  BTFSC  0D.7
04C2A:  BSF    FF2.7
04C2C:  MOVWF  FF9
04C2E:  DATA 14,4B
04C30:  DATA 50,4B
04C32:  DATA 8C,4B
04C34:  DATA C8,4B
*
0516C:  MOVLB  5
0516E:  MOVF   x7D,W
05170:  ANDLW  07
05172:  MOVWF  00
05174:  RRCF   x7D,W
05176:  MOVWF  01
05178:  RRCF   01,F
0517A:  RRCF   01,F
0517C:  MOVLW  1F
0517E:  ANDWF  01,F
05180:  MOVF   01,W
05182:  ADDWF  x7F,W
05184:  MOVWF  FE9
05186:  MOVLW  00
05188:  ADDWFC x80,W
0518A:  MOVWF  FEA
0518C:  CLRF   01
0518E:  INCF   01,F
05190:  INCF   00,F
05192:  BRA    5196
05194:  RLCF   01,F
05196:  DECFSZ 00,F
05198:  BRA    5194
0519A:  MOVF   x7E,F
0519C:  BZ    51A4
0519E:  MOVF   01,W
051A0:  IORWF  FEF,F
051A2:  BRA    51AA
051A4:  COMF   01,F
051A6:  MOVF   01,W
051A8:  ANDWF  FEF,F
051AA:  MOVLB  0
051AC:  RETURN 0
051AE:  MOVLB  5
051B0:  MOVF   x7D,W
051B2:  ANDLW  07
051B4:  MOVWF  00
051B6:  RRCF   x7D,W
051B8:  MOVWF  01
051BA:  RRCF   01,F
051BC:  RRCF   01,F
051BE:  MOVLW  1F
051C0:  ANDWF  01,F
051C2:  MOVF   01,W
051C4:  ADDWF  x7E,W
051C6:  MOVWF  FE9
051C8:  MOVLW  00
051CA:  ADDWFC x7F,W
051CC:  MOVWF  FEA
051CE:  MOVFF  FEF,01
051D2:  INCF   00,F
051D4:  BRA    51D8
051D6:  RRCF   01,F
051D8:  DECFSZ 00,F
051DA:  BRA    51D6
051DC:  MOVLB  0
051DE:  RETURN 0
*
058FE:  TBLRD*+
05900:  MOVFF  FF6,57D
05904:  MOVFF  FF7,57E
05908:  MOVFF  FF5,585
0590C:  CALL   2D30
05910:  MOVFF  57D,FF6
05914:  MOVFF  57E,FF7
05918:  MOVLB  5
0591A:  DECFSZ x7C,F
0591C:  BRA    5920
0591E:  BRA    5924
05920:  MOVLB  0
05922:  BRA    58FE
05924:  MOVLB  0
05926:  RETURN 0
05928:  MOVLB  5
0592A:  MOVF   x7F,W
0592C:  CLRF   01
0592E:  SUBWF  x7E,W
05930:  BC    5938
05932:  MOVFF  57E,00
05936:  BRA    5950
05938:  CLRF   00
0593A:  MOVLW  08
0593C:  MOVWF  x80
0593E:  RLCF   x7E,F
05940:  RLCF   00,F
05942:  MOVF   x7F,W
05944:  SUBWF  00,W
05946:  BTFSC  FD8.0
05948:  MOVWF  00
0594A:  RLCF   01,F
0594C:  DECFSZ x80,F
0594E:  BRA    593E
05950:  MOVLB  0
05952:  RETURN 0
05954:  MOVF   01,W
05956:  MOVFF  57C,57E
0595A:  MOVLW  64
0595C:  MOVLB  5
0595E:  MOVWF  x7F
05960:  MOVLB  0
05962:  RCALL  5928
05964:  MOVFF  00,57C
05968:  MOVF   01,W
0596A:  MOVLW  30
0596C:  BNZ   597E
0596E:  MOVLB  5
05970:  BTFSS  x7D.1
05972:  BRA    5994
05974:  BTFSC  x7D.3
05976:  BRA    5994
05978:  BTFSC  x7D.4
0597A:  MOVLW  20
0597C:  BRA    5986
0597E:  MOVLB  5
05980:  BCF    x7D.3
05982:  BCF    x7D.4
05984:  BSF    x7D.0
05986:  ADDWF  01,F
05988:  MOVFF  01,585
0598C:  MOVLB  0
0598E:  CALL   2D30
05992:  MOVLB  5
05994:  MOVFF  57C,57E
05998:  MOVLW  0A
0599A:  MOVWF  x7F
0599C:  MOVLB  0
0599E:  RCALL  5928
059A0:  MOVFF  00,57C
059A4:  MOVF   01,W
059A6:  MOVLW  30
059A8:  BNZ   59BA
059AA:  MOVLB  5
059AC:  BTFSC  x7D.3
059AE:  BRA    59C6
059B0:  BTFSS  x7D.0
059B2:  BRA    59C6
059B4:  BTFSC  x7D.4
059B6:  MOVLW  20
059B8:  MOVLB  0
059BA:  ADDWF  01,F
059BC:  MOVFF  01,585
059C0:  CALL   2D30
059C4:  MOVLB  5
059C6:  MOVLW  30
059C8:  ADDWF  x7C,F
059CA:  MOVFF  57C,585
059CE:  MOVLB  0
059D0:  CALL   2D30
059D4:  RETURN 0
*
05A3A:  BTFSC  FD8.1
05A3C:  BRA    5A46
05A3E:  MOVLW  05
05A40:  MOVWF  FEA
05A42:  MOVLW  80
05A44:  MOVWF  FE9
05A46:  CLRF   00
05A48:  CLRF   01
05A4A:  CLRF   02
05A4C:  CLRF   03
05A4E:  MOVLB  5
05A50:  CLRF   x80
05A52:  CLRF   x81
05A54:  CLRF   x82
05A56:  CLRF   x83
05A58:  MOVF   x7F,W
05A5A:  IORWF  x7E,W
05A5C:  IORWF  x7D,W
05A5E:  IORWF  x7C,W
05A60:  BZ    5ABA
05A62:  MOVLW  20
05A64:  MOVWF  x84
05A66:  BCF    FD8.0
05A68:  RLCF   x78,F
05A6A:  RLCF   x79,F
05A6C:  RLCF   x7A,F
05A6E:  RLCF   x7B,F
05A70:  RLCF   x80,F
05A72:  RLCF   x81,F
05A74:  RLCF   x82,F
05A76:  RLCF   x83,F
05A78:  MOVF   x7F,W
05A7A:  SUBWF  x83,W
05A7C:  BNZ   5A8E
05A7E:  MOVF   x7E,W
05A80:  SUBWF  x82,W
05A82:  BNZ   5A8E
05A84:  MOVF   x7D,W
05A86:  SUBWF  x81,W
05A88:  BNZ   5A8E
05A8A:  MOVF   x7C,W
05A8C:  SUBWF  x80,W
05A8E:  BNC   5AAE
05A90:  MOVF   x7C,W
05A92:  SUBWF  x80,F
05A94:  MOVF   x7D,W
05A96:  BTFSS  FD8.0
05A98:  INCFSZ x7D,W
05A9A:  SUBWF  x81,F
05A9C:  MOVF   x7E,W
05A9E:  BTFSS  FD8.0
05AA0:  INCFSZ x7E,W
05AA2:  SUBWF  x82,F
05AA4:  MOVF   x7F,W
05AA6:  BTFSS  FD8.0
05AA8:  INCFSZ x7F,W
05AAA:  SUBWF  x83,F
05AAC:  BSF    FD8.0
05AAE:  RLCF   00,F
05AB0:  RLCF   01,F
05AB2:  RLCF   02,F
05AB4:  RLCF   03,F
05AB6:  DECFSZ x84,F
05AB8:  BRA    5A66
05ABA:  MOVFF  580,FEF
05ABE:  MOVFF  581,FEC
05AC2:  MOVFF  582,FEC
05AC6:  MOVFF  583,FEC
05ACA:  MOVLB  0
05ACC:  GOTO   DA52 (RETURN)
*
05DA8:  MOVLB  5
05DAA:  MOVF   x80,W
05DAC:  MULWF  x82
05DAE:  MOVFF  FF3,01
05DB2:  MOVFF  FF4,00
05DB6:  MULWF  x83
05DB8:  MOVF   FF3,W
05DBA:  ADDWF  00,F
05DBC:  MOVF   x81,W
05DBE:  MULWF  x82
05DC0:  MOVF   FF3,W
05DC2:  ADDWFC 00,W
05DC4:  MOVWF  02
05DC6:  MOVLB  0
05DC8:  RETURN 0
*
06F70:  MOVFF  FF2,0D
06F74:  BCF    FF2.7
06F76:  ADDWF  FE8,W
06F78:  CLRF   FF7
06F7A:  RLCF   FF7,F
06F7C:  ADDLW  95
06F7E:  MOVWF  FF6
06F80:  MOVLW  6F
06F82:  ADDWFC FF7,F
06F84:  TBLRD*-
06F86:  MOVF   FF5,W
06F88:  MOVWF  FFA
06F8A:  TBLRD*
06F8C:  MOVF   FF5,W
06F8E:  BTFSC  0D.7
06F90:  BSF    FF2.7
06F92:  MOVWF  FF9
06F94:  DATA 0E,6A
06F96:  DATA 42,6B
06F98:  DATA 6A,6F
06F9A:  DATA 98,6C
06F9C:  DATA 9C,6D
06F9E:  DATA DC,6E
*
07212:  MOVFF  FEA,584
07216:  MOVFF  FE9,583
0721A:  MOVLB  5
0721C:  SWAPF  x7D,W
0721E:  IORLW  F0
07220:  MOVWF  x7F
07222:  ADDWF  x7F,F
07224:  ADDLW  E2
07226:  MOVWF  x80
07228:  ADDLW  32
0722A:  MOVWF  x82
0722C:  MOVF   x7D,W
0722E:  ANDLW  0F
07230:  ADDWF  x80,F
07232:  ADDWF  x80,F
07234:  ADDWF  x82,F
07236:  ADDLW  E9
07238:  MOVWF  x81
0723A:  ADDWF  x81,F
0723C:  ADDWF  x81,F
0723E:  SWAPF  x7C,W
07240:  ANDLW  0F
07242:  ADDWF  x81,F
07244:  ADDWF  x82,F
07246:  RLCF   x81,F
07248:  RLCF   x82,F
0724A:  COMF   x82,F
0724C:  RLCF   x82,F
0724E:  MOVF   x7C,W
07250:  ANDLW  0F
07252:  ADDWF  x82,F
07254:  RLCF   x7F,F
07256:  MOVLW  07
07258:  MOVWF  x7E
0725A:  MOVLW  0A
0725C:  DECF   x81,F
0725E:  ADDWF  x82,F
07260:  BNC   725C
07262:  DECF   x80,F
07264:  ADDWF  x81,F
07266:  BNC   7262
07268:  DECF   x7F,F
0726A:  ADDWF  x80,F
0726C:  BNC   7268
0726E:  DECF   x7E,F
07270:  ADDWF  x7F,F
07272:  BNC   726E
07274:  MOVLW  05
07276:  MOVWF  FEA
07278:  MOVLW  7E
0727A:  MOVWF  FE9
0727C:  MOVLW  07
0727E:  ANDWF  x83,W
07280:  BCF    x83.6
07282:  ADDWF  FE9,F
07284:  MOVLW  82
07286:  SUBWF  FE9,W
07288:  BTFSC  FD8.2
0728A:  BSF    x83.6
0728C:  MOVF   FEF,W
0728E:  MOVWF  00
07290:  BNZ   72A2
07292:  BTFSC  x83.6
07294:  BRA    72A2
07296:  BTFSC  x83.4
07298:  BRA    72C6
0729A:  BTFSC  x83.3
0729C:  BRA    72A2
0729E:  MOVLW  20
072A0:  BRA    72A8
072A2:  BSF    x83.3
072A4:  BCF    x83.4
072A6:  MOVLW  30
072A8:  ADDWF  00,F
072AA:  MOVFF  FEA,57D
072AE:  MOVFF  FE9,57C
072B2:  MOVFF  00,585
072B6:  MOVLB  0
072B8:  CALL   2D30
072BC:  MOVFF  57D,FEA
072C0:  MOVFF  57C,FE9
072C4:  MOVLB  5
072C6:  MOVF   FEE,W
072C8:  BTFSS  x83.6
072CA:  BRA    7284
072CC:  MOVLB  0
072CE:  RETURN 0
*
07434:  MOVFF  FF2,0D
07438:  BCF    FF2.7
0743A:  ADDWF  FE8,W
0743C:  CLRF   FF7
0743E:  RLCF   FF7,F
07440:  ADDLW  59
07442:  MOVWF  FF6
07444:  MOVLW  74
07446:  ADDWFC FF7,F
07448:  TBLRD*-
0744A:  MOVF   FF5,W
0744C:  MOVWF  FFA
0744E:  TBLRD*
07450:  MOVF   FF5,W
07452:  BTFSC  0D.7
07454:  BSF    FF2.7
07456:  MOVWF  FF9
07458:  DATA 82,73
0745A:  DATA A0,73
0745C:  DATA 30,74
0745E:  DATA 30,74
07460:  DATA BC,73
07462:  DATA C4,73
*
079D6:  MOVFF  FF2,0D
079DA:  BCF    FF2.7
079DC:  ADDWF  FE8,W
079DE:  CLRF   FF7
079E0:  RLCF   FF7,F
079E2:  ADDLW  FB
079E4:  MOVWF  FF6
079E6:  MOVLW  79
079E8:  ADDWFC FF7,F
079EA:  TBLRD*-
079EC:  MOVF   FF5,W
079EE:  MOVWF  FFA
079F0:  TBLRD*
079F2:  MOVF   FF5,W
079F4:  BTFSC  0D.7
079F6:  BSF    FF2.7
079F8:  MOVWF  FF9
079FA:  DATA BA,77
079FC:  DATA FE,77
079FE:  DATA D2,79
07A00:  DATA D2,79
07A02:  DATA 8A,79
07A04:  DATA 30,78
*
08E8A:  MOVFF  FF2,0D
08E8E:  BCF    FF2.7
08E90:  ADDWF  FE8,W
08E92:  CLRF   FF7
08E94:  RLCF   FF7,F
08E96:  ADDLW  AF
08E98:  MOVWF  FF6
08E9A:  MOVLW  8E
08E9C:  ADDWFC FF7,F
08E9E:  TBLRD*-
08EA0:  MOVF   FF5,W
08EA2:  MOVWF  FFA
08EA4:  TBLRD*
08EA6:  MOVF   FF5,W
08EA8:  BTFSC  0D.7
08EAA:  BSF    FF2.7
08EAC:  MOVWF  FF9
08EAE:  DATA 30,85
08EB0:  DATA 76,85
08EB2:  DATA 08,87
08EB4:  DATA 9A,88
*
0A0FE:  MOVFF  FF2,0D
0A102:  BCF    FF2.7
0A104:  ADDWF  FE8,W
0A106:  CLRF   FF7
0A108:  RLCF   FF7,F
0A10A:  ADDLW  23
0A10C:  MOVWF  FF6
0A10E:  MOVLW  A1
0A110:  ADDWFC FF7,F
0A112:  TBLRD*-
0A114:  MOVF   FF5,W
0A116:  MOVWF  FFA
0A118:  TBLRD*
0A11A:  MOVF   FF5,W
0A11C:  BTFSC  0D.7
0A11E:  BSF    FF2.7
0A120:  MOVWF  FF9
0A122:  DATA 7C,9B
0A124:  DATA A0,9A
0A126:  DATA 0E,9B
0A128:  DATA 44,9C
0A12A:  DATA FA,9C
0A12C:  DATA 28,9D
0A12E:  DATA FA,A0
0A130:  DATA FA,A0
0A132:  DATA 72,9B
0A134:  DATA FA,A0
0A136:  DATA 96,9D
0A138:  DATA 0E,99
0A13A:  DATA EC,9E
0A13C:  DATA 06,9A
0A13E:  DATA E2,95
0A140:  DATA DC,96
0A142:  DATA 78,97
0A144:  DATA 14,98
0A146:  DATA D2,9F
0A148:  DATA 02,A0
*
0B13E:  MOVFF  FF2,0D
0B142:  BCF    FF2.7
0B144:  ADDWF  FE8,W
0B146:  CLRF   FF7
0B148:  RLCF   FF7,F
0B14A:  ADDLW  63
0B14C:  MOVWF  FF6
0B14E:  MOVLW  B1
0B150:  ADDWFC FF7,F
0B152:  TBLRD*-
0B154:  MOVF   FF5,W
0B156:  MOVWF  FFA
0B158:  TBLRD*
0B15A:  MOVF   FF5,W
0B15C:  BTFSC  0D.7
0B15E:  BSF    FF2.7
0B160:  MOVWF  FF9
0B162:  DATA C0,AB
0B164:  DATA 5E,A1
0B166:  DATA B6,A3
0B168:  DATA 4E,A8
0B16A:  DATA 6C,A2
0B16C:  DATA C6,A5
0B16E:  DATA 5E,A9
0B170:  DATA F6,AC
0B172:  DATA A8,AA
0B174:  DATA 3A,B1
0B176:  DATA 0E,AE
0B178:  DATA 3A,B1
0B17A:  DATA DC,AD
0B17C:  DATA 3A,B1
0B17E:  DATA 3A,B1
0B180:  DATA 3A,B1
0B182:  DATA 3A,B1
0B184:  DATA 3A,B1
0B186:  DATA 60,AF
0B188:  DATA 90,AF
*
0C040:  MOVFF  FF2,0D
0C044:  BCF    FF2.7
0C046:  ADDWF  FE8,W
0C048:  CLRF   FF7
0C04A:  RLCF   FF7,F
0C04C:  ADDLW  65
0C04E:  MOVWF  FF6
0C050:  MOVLW  C0
0C052:  ADDWFC FF7,F
0C054:  TBLRD*-
0C056:  MOVF   FF5,W
0C058:  MOVWF  FFA
0C05A:  TBLRD*
0C05C:  MOVF   FF5,W
0C05E:  BTFSC  0D.7
0C060:  BSF    FF2.7
0C062:  MOVWF  FF9
0C064:  DATA 28,BF
0C066:  DATA 90,BF
0C068:  DATA 3C,C0
0C06A:  DATA 3C,C0
0C06C:  DATA 06,C0
0C06E:  DATA 18,C0
0C070:  DATA FA,BF
0C072:  DATA 3C,C0
0C074:  DATA 2A,C0
*
0C200:  MOVFF  FF2,0D
0C204:  BCF    FF2.7
0C206:  ADDWF  FE8,W
0C208:  CLRF   FF7
0C20A:  RLCF   FF7,F
0C20C:  ADDLW  25
0C20E:  MOVWF  FF6
0C210:  MOVLW  C2
0C212:  ADDWFC FF7,F
0C214:  TBLRD*-
0C216:  MOVF   FF5,W
0C218:  MOVWF  FFA
0C21A:  TBLRD*
0C21C:  MOVF   FF5,W
0C21E:  BTFSC  0D.7
0C220:  BSF    FF2.7
0C222:  MOVWF  FF9
0C224:  DATA E4,C0
0C226:  DATA 48,C1
0C228:  DATA FC,C1
0C22A:  DATA FC,C1
0C22C:  DATA CA,C1
0C22E:  DATA DA,C1
0C230:  DATA B0,C1
0C232:  DATA BC,C1
0C234:  DATA EA,C1
*
0C49E:  MOVFF  FF2,0D
0C4A2:  BCF    FF2.7
0C4A4:  ADDWF  FE8,W
0C4A6:  CLRF   FF7
0C4A8:  RLCF   FF7,F
0C4AA:  ADDLW  C3
0C4AC:  MOVWF  FF6
0C4AE:  MOVLW  C4
0C4B0:  ADDWFC FF7,F
0C4B2:  TBLRD*-
0C4B4:  MOVF   FF5,W
0C4B6:  MOVWF  FFA
0C4B8:  TBLRD*
0C4BA:  MOVF   FF5,W
0C4BC:  BTFSC  0D.7
0C4BE:  BSF    FF2.7
0C4C0:  MOVWF  FF9
0C4C2:  DATA 54,C3
0C4C4:  DATA D2,C3
0C4C6:  DATA 9A,C4
0C4C8:  DATA 9A,C4
0C4CA:  DATA 68,C4
0C4CC:  DATA 78,C4
0C4CE:  DATA 50,C4
0C4D0:  DATA 5C,C4
0C4D2:  DATA 88,C4
*
0C8D4:  MOVFF  FF2,0D
0C8D8:  BCF    FF2.7
0C8DA:  ADDWF  FE8,W
0C8DC:  CLRF   FF7
0C8DE:  RLCF   FF7,F
0C8E0:  ADDLW  F9
0C8E2:  MOVWF  FF6
0C8E4:  MOVLW  C8
0C8E6:  ADDWFC FF7,F
0C8E8:  TBLRD*-
0C8EA:  MOVF   FF5,W
0C8EC:  MOVWF  FFA
0C8EE:  TBLRD*
0C8F0:  MOVF   FF5,W
0C8F2:  BTFSC  0D.7
0C8F4:  BSF    FF2.7
0C8F6:  MOVWF  FF9
0C8F8:  DATA 1E,C8
0C8FA:  DATA D0,C8
0C8FC:  DATA 7E,C8
0C8FE:  DATA D0,C8
0C900:  DATA D0,C8
0C902:  DATA 88,C8
0C904:  DATA D0,C8
0C906:  DATA D0,C8
0C908:  DATA AA,C7
0C90A:  DATA 9A,C8
0C90C:  DATA D0,C8
0C90E:  DATA BE,C6
0C910:  DATA D0,C8
0C912:  DATA 2A,C7
0C914:  DATA E6,C4
0C916:  DATA 66,C5
0C918:  DATA D2,C5
0C91A:  DATA 3E,C6
0C91C:  DATA C2,C8
*
0D656:  MOVFF  FF2,0D
0D65A:  BCF    FF2.7
0D65C:  ADDWF  FE8,W
0D65E:  CLRF   FF7
0D660:  RLCF   FF7,F
0D662:  ADDLW  7B
0D664:  MOVWF  FF6
0D666:  MOVLW  D6
0D668:  ADDWFC FF7,F
0D66A:  TBLRD*-
0D66C:  MOVF   FF5,W
0D66E:  MOVWF  FFA
0D670:  TBLRD*
0D672:  MOVF   FF5,W
0D674:  BTFSC  0D.7
0D676:  BSF    FF2.7
0D678:  MOVWF  FF9
0D67A:  DATA AC,D1
0D67C:  DATA C8,D1
0D67E:  DATA FA,D1
0D680:  DATA B6,D2
0D682:  DATA 6E,D3
0D684:  DATA D4,D3
0D686:  DATA 44,D4
0D688:  DATA 90,D4
0D68A:  DATA EC,D4
0D68C:  DATA 48,D5
0D68E:  DATA 9E,D5
0D690:  DATA A4,D5
0D692:  DATA AA,D5
0D694:  DATA B0,D5
0D696:  DATA B6,D5
*
0DB3E:  MOVFF  FF2,0D
0DB42:  BCF    FF2.7
0DB44:  ADDWF  FE8,W
0DB46:  CLRF   FF7
0DB48:  RLCF   FF7,F
0DB4A:  ADDLW  63
0DB4C:  MOVWF  FF6
0DB4E:  MOVLW  DB
0DB50:  ADDWFC FF7,F
0DB52:  TBLRD*-
0DB54:  MOVF   FF5,W
0DB56:  MOVWF  FFA
0DB58:  TBLRD*
0DB5A:  MOVF   FF5,W
0DB5C:  BTFSC  0D.7
0DB5E:  BSF    FF2.7
0DB60:  MOVWF  FF9
0DB62:  DATA 86,DA
0DB64:  DATA 8E,DA
0DB66:  DATA AE,DA
0DB68:  DATA EE,DA
0DB6A:  DATA F6,DA
0DB6C:  DATA FE,DA
0DB6E:  DATA 06,DB
0DB70:  DATA 96,DA
0DB72:  DATA 0E,DB
0DB74:  DATA 16,DB
0DB76:  DATA 1E,DB
0DB78:  DATA 26,DB
0DB7A:  DATA 2E,DB
0DB7C:  DATA A6,DA
0DB7E:  DATA D6,DA
0DB80:  DATA BE,DA
0DB82:  DATA C6,DA
0DB84:  DATA B6,DA
0DB86:  DATA CE,DA
0DB88:  DATA DE,DA
0DB8A:  DATA E6,DA
0DB8C:  DATA 9E,DA
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "main.h" 
.................... #fuses HS,NOWDT,PROTECT,NOLVP,NODEBUG,MCLR 
.................... #use delay(clock=20000000) 
*
02954:  MOVLW  05
02956:  MOVWF  FEA
02958:  MOVLW  91
0295A:  MOVWF  FE9
0295C:  MOVF   FEF,W
0295E:  BZ    297A
02960:  MOVLW  06
02962:  MOVWF  01
02964:  CLRF   00
02966:  DECFSZ 00,F
02968:  BRA    2966
0296A:  DECFSZ 01,F
0296C:  BRA    2964
0296E:  MOVLW  7B
02970:  MOVWF  00
02972:  DECFSZ 00,F
02974:  BRA    2972
02976:  DECFSZ FEF,F
02978:  BRA    2960
0297A:  RETURN 0
.................... #use i2c(master,sda = pin_C4,scl = pin_C3,force_hw) 
*
02902:  BCF    FC6.7
02904:  BCF    F9E.3
02906:  MOVFF  597,FC9
0290A:  MOVLW  02
0290C:  BTFSC  FC6.7
0290E:  BRA    291A
02910:  BTFSS  F9E.3
02912:  BRA    2910
02914:  MOVLW  00
02916:  BTFSC  FC5.6
02918:  MOVLW  01
0291A:  MOVWF  01
0291C:  RETURN 0
*
02C02:  BCF    FC6.6
02C04:  BSF    FC5.3
02C06:  BTFSC  FC5.3
02C08:  BRA    2C06
02C0A:  BTFSC  00.0
02C0C:  BCF    FC5.5
02C0E:  BTFSS  00.0
02C10:  BSF    FC5.5
02C12:  BSF    FC5.4
02C14:  BTFSC  FC5.4
02C16:  BRA    2C14
02C18:  MOVFF  FC9,01
02C1C:  RETURN 0
....................  
.................... #use 		standard_io(a) 
.................... #use 		standard_io(b) 
.................... #use 		standard_io(c) 
.................... #use 		standard_io(d) 
.................... #use 		standard_io(e) 
....................  
....................  
.................... #DEFINE   	RS    pin_B5			 
.................... #DEFINE	  	E	  pin_A0 
....................  
....................  
.................... #DEFINE		EEPROM_SCL	    	pin_C3 
.................... #DEFINE 	EEPROM_SDA		    pin_C4 
....................  
....................  
.................... #DEFINE     in24_bit			pin_B0 
.................... #DEFINE     in25_bit			pin_B1 
.................... #DEFINE     in26_bit			pin_B3 
.................... #DEFINE     in27_bit			pin_B4 
....................  
.................... #DEFINE     H0					pin_D7 
.................... #DEFINE     H1					pin_D6 
.................... #DEFINE     H2					pin_D5 
.................... #DEFINE     H3					pin_D4 
.................... #DEFINE     H4					pin_C7	 
.................... #DEFINE     H5					pin_C6 
....................  
.................... #DEFINE ALIMENTADOR        0 // 000          
.................... #DEFINE HOME1              1 // 001 
.................... #DEFINE SOLDAGEM           3 // 010 
.................... #DEFINE HOME2              4 // 011 
.................... #DEFINE DISPENSADOR        5 // 100 
....................  
.................... #define ramp_idle 0 
.................... #define ramp_up   1 
.................... #define ramp_max  2 
.................... #define ramp_down 3 
.................... #define ramp_last 4 
....................  
.................... int menu_atual = 0; 
.................... short int entradas[27]; 
....................  
.................... int ponteiro_lcd = 1; 
.................... int inicial_lcd = 0; 
.................... int final_lcd = 3; 
.................... int contador_lcd = 0; 
.................... signed int incremento = 1; 
....................  
.................... int posicao_atual; 
.................... int posicao_futura; 
.................... int posicao_outra_maquina; 
.................... int32 ciclo; 
.................... short run_ok = 1; 
.................... short exit = TRUE; 
.................... short flgMove = TRUE; 
.................... short run_flg_flip = FALSE; 
....................  
.................... int modelo = 1; 
.................... long int x[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int y[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int z[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int t_solda[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int t_wait[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int tipo[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int pontos_no_modelo = 0; 
.................... long int habilitado[21] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int numeroFerros[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int t_solda2[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int t_solda3[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... long int limpar[21]  = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
....................  
....................  
.................... #include "pcf8574.c" 
.................... short int ack; 
.................... int	lcdcoluna = 1; 
.................... int	lcdlinha  = 1; 
....................  
.................... void escreve_pcf8574(int dispositivo,int data) { 
....................    i2c_start(); 
*
0291E:  BSF    FC5.0
02920:  BTFSC  FC5.0
02922:  BRA    2920
....................    ack=i2c_write(0x40 |(dispositivo << 1)); 
02924:  BCF    FD8.0
02926:  MOVLB  5
02928:  RLCF   x8B,W
0292A:  IORLW  40
0292C:  MOVWF  x8D
0292E:  MOVWF  x97
02930:  MOVLB  0
02932:  RCALL  2902
02934:  MOVF   01,W
02936:  BCF    2D.4
02938:  BTFSC  01.0
0293A:  BSF    2D.4
....................    ack=i2c_write(data); 
0293C:  MOVFF  58C,597
02940:  RCALL  2902
02942:  MOVF   01,W
02944:  BCF    2D.4
02946:  BTFSC  01.0
02948:  BSF    2D.4
....................    i2c_stop(); 
0294A:  BSF    FC5.2
0294C:  BTFSC  FC5.2
0294E:  BRA    294C
....................    ack=!ack; 
02950:  BTG    2D.4
02952:  RETURN 0
.................... } 
....................  
.................... int le_pcf8574(int dispositivo) { 
....................     int data; 
....................     i2c_start(); 
....................     i2c_write(0x41 |(dispositivo << 1)); 
....................     data=i2c_read(0); 
....................     i2c_stop(); 
....................     ack=!ack; 
....................     return(data); 
.................... } 
....................  
.................... int le_pcf8574A(int dispositivo) { 
....................     int data; 
....................     i2c_start(); 
*
049C4:  BSF    FC5.0
049C6:  BTFSC  FC5.0
049C8:  BRA    49C6
....................     i2c_write(0x71 |(dispositivo << 1)); 
049CA:  BCF    FD8.0
049CC:  MOVLB  5
049CE:  RLCF   x7D,W
049D0:  IORLW  71
049D2:  MOVWF  x7F
049D4:  MOVWF  x97
049D6:  MOVLB  0
049D8:  CALL   2902
....................     data=i2c_read(0); 
049DC:  CLRF   00
049DE:  CALL   2C02
049E2:  MOVFF  01,57E
....................     i2c_stop(); 
049E6:  BSF    FC5.2
049E8:  BTFSC  FC5.2
049EA:  BRA    49E8
....................     ack=!ack; 
049EC:  BTG    2D.4
.................... 	return(data); 
049EE:  MOVLB  5
049F0:  MOVFF  57E,01
049F4:  MOVLB  0
049F6:  GOTO   4A90 (RETURN)
.................... } 
....................  
....................  
.................... #include "pca9555.c" 
.................... void escreve_PCA9555(int dispositivo,int comando,int data1,int data2) { 
....................    i2c_start(); 
*
02A2E:  BSF    FC5.0
02A30:  BTFSC  FC5.0
02A32:  BRA    2A30
....................    ack=i2c_write(0x40 |(dispositivo << 1)); 
02A34:  BCF    FD8.0
02A36:  MOVLB  5
02A38:  RLCF   x92,W
02A3A:  IORLW  40
02A3C:  MOVWF  x96
02A3E:  MOVWF  x97
02A40:  MOVLB  0
02A42:  RCALL  2902
02A44:  MOVF   01,W
02A46:  BCF    2D.4
02A48:  BTFSC  01.0
02A4A:  BSF    2D.4
....................    ack=i2c_write(comando); 
02A4C:  MOVFF  593,597
02A50:  RCALL  2902
02A52:  MOVF   01,W
02A54:  BCF    2D.4
02A56:  BTFSC  01.0
02A58:  BSF    2D.4
....................    ack=i2c_write(data2); 
02A5A:  MOVFF  595,597
02A5E:  RCALL  2902
02A60:  MOVF   01,W
02A62:  BCF    2D.4
02A64:  BTFSC  01.0
02A66:  BSF    2D.4
....................    ack=i2c_write(data1); 
02A68:  MOVFF  594,597
02A6C:  RCALL  2902
02A6E:  MOVF   01,W
02A70:  BCF    2D.4
02A72:  BTFSC  01.0
02A74:  BSF    2D.4
....................    i2c_stop(); 
02A76:  BSF    FC5.2
02A78:  BTFSC  FC5.2
02A7A:  BRA    2A78
....................    ack=!ack; 
02A7C:  BTG    2D.4
02A7E:  RETURN 0
.................... }   
....................  
.................... unsigned long  int le_PCA9555(int dispositivo,int comando) {     
*
0493C:  MOVLB  5
0493E:  CLRF   x88
04940:  CLRF   x87
04942:  CLRF   x89
....................    unsigned long int data1 = 0x0000;  
....................    int data2= 0x00; 
....................    i2c_start(); 	 
04944:  BSF    FC5.0
04946:  BTFSC  FC5.0
04948:  BRA    4946
....................    ack=i2c_write(0x40 |(dispositivo << 1));  
0494A:  BCF    FD8.0
0494C:  RLCF   x85,W
0494E:  IORLW  40
04950:  MOVWF  x8A
04952:  MOVWF  x97
04954:  MOVLB  0
04956:  CALL   2902
0495A:  MOVF   01,W
0495C:  BCF    2D.4
0495E:  BTFSC  01.0
04960:  BSF    2D.4
....................    ack=i2c_write(comando); 
04962:  MOVFF  586,597
04966:  CALL   2902
0496A:  MOVF   01,W
0496C:  BCF    2D.4
0496E:  BTFSC  01.0
04970:  BSF    2D.4
....................    i2c_start(); 
04972:  BSF    FC5.1
04974:  BTFSC  FC5.1
04976:  BRA    4974
....................    ack=i2c_write(0x41 |(dispositivo << 1)); 
04978:  BCF    FD8.0
0497A:  MOVLB  5
0497C:  RLCF   x85,W
0497E:  IORLW  41
04980:  MOVWF  x8A
04982:  MOVWF  x97
04984:  MOVLB  0
04986:  CALL   2902
0498A:  MOVF   01,W
0498C:  BCF    2D.4
0498E:  BTFSC  01.0
04990:  BSF    2D.4
....................    data2=i2c_read(1);            // acknoledgment 
04992:  MOVLW  01
04994:  MOVWF  00
04996:  CALL   2C02
0499A:  MOVFF  01,589
....................    data1=i2c_read(0) << 8;      // no  acknoledgment 
0499E:  CLRF   00
049A0:  CALL   2C02
049A4:  MOVFF  01,588
049A8:  MOVLB  5
049AA:  CLRF   x87
....................    i2c_stop(); 
049AC:  BSF    FC5.2
049AE:  BTFSC  FC5.2
049B0:  BRA    49AE
....................    ack=!ack; 
049B2:  BTG    2D.4
....................    data1|=data2; 
049B4:  MOVF   x89,W
049B6:  IORWF  x87,F
....................    return(data1); 
049B8:  MOVFF  587,01
049BC:  MOVFF  588,02
049C0:  MOVLB  0
049C2:  RETURN 0
.................... }     
....................  
.................... #include "display_maq.c"  
.................... void write (char dado){ 
.................... 	delay_us(30); 
*
0297C:  MOVLW  31
0297E:  MOVWF  00
02980:  DECFSZ 00,F
02982:  BRA    2980
02984:  BRA    2986
.................... 	escreve_pcf8574(0x00,dado); 
02986:  MOVLB  5
02988:  CLRF   x8B
0298A:  MOVFF  58A,58C
0298E:  MOVLB  0
02990:  RCALL  291E
.................... 	delay_us(30); 
02992:  MOVLW  31
02994:  MOVWF  00
02996:  DECFSZ 00,F
02998:  BRA    2996
0299A:  BRA    299C
.................... 	output_high (E); 
0299C:  BCF    F92.0
0299E:  BSF    F89.0
.................... 	delay_us(30); 
029A0:  MOVLW  31
029A2:  MOVWF  00
029A4:  DECFSZ 00,F
029A6:  BRA    29A4
029A8:  BRA    29AA
.................... 	output_low  (E) ; 
029AA:  BCF    F92.0
029AC:  BCF    F89.0
.................... 	delay_us(30); 
029AE:  MOVLW  31
029B0:  MOVWF  00
029B2:  DECFSZ 00,F
029B4:  BRA    29B2
029B6:  BRA    29B8
029B8:  RETURN 0
.................... } 
.................... void displayprog (int valor) { 
.................... 	output_low (RS); 
029BA:  BCF    F93.5
029BC:  BCF    F8A.5
.................... 	write (valor); 
029BE:  MOVFF  589,58A
029C2:  RCALL  297C
029C4:  RETURN 0
.................... } 
.................... void limpa_display (void){ 
....................  	displayprog (0x1); 
*
02B6C:  MOVLW  01
02B6E:  MOVLB  5
02B70:  MOVWF  x89
02B72:  MOVLB  0
02B74:  RCALL  29BA
.................... 	delay_ms(5); 
02B76:  MOVLW  05
02B78:  MOVLB  5
02B7A:  MOVWF  x91
02B7C:  MOVLB  0
02B7E:  RCALL  2954
02B80:  RETURN 0
.................... } 
.................... void inicializa_display(void){ 
....................     escreve_pcf8574(0x00,0Xff); //;output_b(0xff);				//	porta_display (0XFF); 
*
029C6:  MOVLB  5
029C8:  CLRF   x8B
029CA:  SETF   x8C
029CC:  MOVLB  0
029CE:  RCALL  291E
.................... 	output_low(E); 
029D0:  BCF    F92.0
029D2:  BCF    F89.0
.................... 	output_high(RS); 
029D4:  BCF    F93.5
029D6:  BSF    F8A.5
.................... 	delay_ms(15); 
029D8:  MOVLW  0F
029DA:  MOVLB  5
029DC:  MOVWF  x91
029DE:  MOVLB  0
029E0:  RCALL  2954
.................... 	displayprog(0x38);      // 2 linha / 5x7 /8 bit 
029E2:  MOVLW  38
029E4:  MOVLB  5
029E6:  MOVWF  x89
029E8:  MOVLB  0
029EA:  RCALL  29BA
.................... 	delay_ms(15); 
029EC:  MOVLW  0F
029EE:  MOVLB  5
029F0:  MOVWF  x91
029F2:  MOVLB  0
029F4:  RCALL  2954
.................... 	displayprog(0x0c);		// display aceso s/ cursor 
029F6:  MOVLW  0C
029F8:  MOVLB  5
029FA:  MOVWF  x89
029FC:  MOVLB  0
029FE:  RCALL  29BA
.................... 	delay_ms(15); 
02A00:  MOVLW  0F
02A02:  MOVLB  5
02A04:  MOVWF  x91
02A06:  MOVLB  0
02A08:  RCALL  2954
.................... 	displayprog(0x06);      // escreve deslocando o cursor para direita 
02A0A:  MOVLW  06
02A0C:  MOVLB  5
02A0E:  MOVWF  x89
02A10:  MOVLB  0
02A12:  RCALL  29BA
.................... 	delay_ms(15); 
02A14:  MOVLW  0F
02A16:  MOVLB  5
02A18:  MOVWF  x91
02A1A:  MOVLB  0
02A1C:  RCALL  2954
.................... 	lcdcoluna = 1; 
02A1E:  MOVLW  01
02A20:  MOVLB  1
02A22:  MOVWF  xFF
.................... 	lcdlinha = 1; 
02A24:  MOVLB  2
02A26:  MOVWF  x00
02A28:  MOVLB  0
02A2A:  GOTO   D9EA (RETURN)
.................... } 
.................... void posiciona_cursor (int linha,int coluna){ 
.................... 	lcdcoluna = coluna; 
*
02B82:  MOVFF  587,1FF
.................... 	lcdlinha  = linha; 
02B86:  MOVFF  586,200
.................... 	int	x; 
.................... 	if (linha == 1)	x=(0x00 + coluna) - 1; 
02B8A:  MOVLB  5
02B8C:  DECFSZ x86,W
02B8E:  BRA    2B96
02B90:  MOVLW  01
02B92:  SUBWF  x87,W
02B94:  MOVWF  x88
.................... 	if (linha == 2) x=(0x40 + coluna) - 1;  
02B96:  MOVF   x86,W
02B98:  SUBLW  02
02B9A:  BNZ   2BA4
02B9C:  MOVLW  40
02B9E:  ADDWF  x87,W
02BA0:  ADDLW  FF
02BA2:  MOVWF  x88
....................     if (linha == 3) x=(0x14 + coluna) - 1; 
02BA4:  MOVF   x86,W
02BA6:  SUBLW  03
02BA8:  BNZ   2BB2
02BAA:  MOVLW  14
02BAC:  ADDWF  x87,W
02BAE:  ADDLW  FF
02BB0:  MOVWF  x88
.................... 	if (linha == 4) x=(0x54 + coluna) - 1; 
02BB2:  MOVF   x86,W
02BB4:  SUBLW  04
02BB6:  BNZ   2BC0
02BB8:  MOVLW  54
02BBA:  ADDWF  x87,W
02BBC:  ADDLW  FF
02BBE:  MOVWF  x88
.................... 	x =x | 0x80; 
02BC0:  BSF    x88.7
.................... 	displayprog (x); 
02BC2:  MOVFF  588,589
02BC6:  MOVLB  0
02BC8:  RCALL  29BA
.................... 	delay_us(100); 
02BCA:  MOVLW  A6
02BCC:  MOVWF  00
02BCE:  DECFSZ 00,F
02BD0:  BRA    2BCE
02BD2:  NOP   
02BD4:  RETURN 0
.................... } 
.................... void display (char  c){ 
.................... 	output_high (RS); 
02BD6:  BCF    F93.5
02BD8:  BSF    F8A.5
.................... 	write (c); 
02BDA:  MOVFF  586,58A
02BDE:  RCALL  297C
02BE0:  RETURN 0
.................... } 
.................... void lcd_putc(char c) { 
.................... 	// \n nova linha muda o cursor para uma linha abaixo 
....................     // \r retorno 
....................     // \f limpa display 
....................  
....................  
....................    switch (c) { 
*
02D30:  MOVLB  5
02D32:  MOVF   x85,W
02D34:  XORLW  0C
02D36:  MOVLB  0
02D38:  BZ    2D44
02D3A:  XORLW  06
02D3C:  BZ    2D52
02D3E:  XORLW  07
02D40:  BZ    2D66
02D42:  BRA    2D7A
....................      case '\f'   : limpa_display(); 
02D44:  RCALL  2B6C
....................                    lcdlinha = 1; 
02D46:  MOVLW  01
02D48:  MOVLB  2
02D4A:  MOVWF  x00
.................... 				   lcdcoluna= 1; 
02D4C:  MOVLB  1
02D4E:  MOVWF  xFF
....................                    break; 
02D50:  BRA    2D82
....................  
....................      case '\n'   : posiciona_cursor(++lcdlinha,lcdcoluna);  
02D52:  MOVLB  2
02D54:  INCF   x00,F
02D56:  MOVFF  200,586
02D5A:  MOVFF  1FF,587
02D5E:  MOVLB  0
02D60:  RCALL  2B82
.................... 			       break; 
02D62:  MOVLB  1
02D64:  BRA    2D82
....................  
....................      case '\r'   : posiciona_cursor(lcdlinha,1);  
02D66:  MOVFF  200,586
02D6A:  MOVLW  01
02D6C:  MOVLB  5
02D6E:  MOVWF  x87
02D70:  MOVLB  0
02D72:  RCALL  2B82
....................                    break; 
02D74:  MOVLB  1
02D76:  BRA    2D82
02D78:  MOVLB  0
....................  
....................      default     : display(c);   
02D7A:  MOVFF  585,586
02D7E:  RCALL  2BD6
....................                    break; 
02D80:  MOVLB  1
....................    } 
02D82:  MOVLB  0
02D84:  RETURN 0
.................... } 
.................... void Show_String(char matriz[]) { 
.................... 	int result; 
.................... 	int	a; 
.................... 	char x1[21]; 
.................... 	strcpy (x1,matriz); 
.................... 	result = strlen(x1); 
.................... 	for (a=0;a < result;a++){ 
....................         display(x1[a]); 
....................     } 
.................... } 
....................  
.................... #include "24c64.c" 
.................... void write_ext_eeprom(long int address,long int data) { 
....................  
....................    disable_interrupts(GLOBAL); 
*
02B00:  BCF    FF2.6
02B02:  BCF    FF2.7
02B04:  BTFSC  FF2.7
02B06:  BRA    2B02
....................    i2c_start(); 
02B08:  BSF    FC5.0
02B0A:  BTFSC  FC5.0
02B0C:  BRA    2B0A
....................    ack=i2c_write(0xa0); 
02B0E:  MOVLW  A0
02B10:  MOVLB  5
02B12:  MOVWF  x97
02B14:  MOVLB  0
02B16:  RCALL  2902
02B18:  MOVF   01,W
02B1A:  BCF    2D.4
02B1C:  BTFSC  01.0
02B1E:  BSF    2D.4
....................    ack=i2c_write(address >> 8); 
02B20:  MOVFF  580,583
02B24:  MOVLB  5
02B26:  CLRF   x84
02B28:  MOVFF  580,597
02B2C:  MOVLB  0
02B2E:  RCALL  2902
02B30:  MOVF   01,W
02B32:  BCF    2D.4
02B34:  BTFSC  01.0
02B36:  BSF    2D.4
....................    ack=i2c_write(address); 
02B38:  MOVFF  57F,597
02B3C:  RCALL  2902
02B3E:  MOVF   01,W
02B40:  BCF    2D.4
02B42:  BTFSC  01.0
02B44:  BSF    2D.4
....................    ack=i2c_write(data); 
02B46:  MOVFF  581,597
02B4A:  RCALL  2902
02B4C:  MOVF   01,W
02B4E:  BCF    2D.4
02B50:  BTFSC  01.0
02B52:  BSF    2D.4
....................    i2c_stop(); 
02B54:  BSF    FC5.2
02B56:  BTFSC  FC5.2
02B58:  BRA    2B56
....................    ack=!ack; 
02B5A:  BTG    2D.4
....................    delay_ms(5); 
02B5C:  MOVLW  05
02B5E:  MOVLB  5
02B60:  MOVWF  x91
02B62:  MOVLB  0
02B64:  RCALL  2954
....................    enable_interrupts(GLOBAL); 
02B66:  MOVLW  C0
02B68:  IORWF  FF2,F
02B6A:  RETURN 0
....................  
.................... } 
.................... long int read_ext_eeprom(long int address) { 
....................    long int data; 
....................  
....................    disable_interrupts(GLOBAL); 
*
02C1E:  BCF    FF2.6
02C20:  BCF    FF2.7
02C22:  BTFSC  FF2.7
02C24:  BRA    2C20
....................    i2c_start(); 
02C26:  BSF    FC5.0
02C28:  BTFSC  FC5.0
02C2A:  BRA    2C28
....................    i2c_write(0xa0); 
02C2C:  MOVLW  A0
02C2E:  MOVLB  5
02C30:  MOVWF  x97
02C32:  MOVLB  0
02C34:  RCALL  2902
....................    i2c_write(address >> 8); 
02C36:  MOVFF  585,588
02C3A:  MOVLB  5
02C3C:  CLRF   x89
02C3E:  MOVFF  585,597
02C42:  MOVLB  0
02C44:  RCALL  2902
....................    i2c_write(address); 
02C46:  MOVFF  584,597
02C4A:  RCALL  2902
....................    i2c_start(); 
02C4C:  BSF    FC5.1
02C4E:  BTFSC  FC5.1
02C50:  BRA    2C4E
....................    i2c_write(0xa1); 
02C52:  MOVLW  A1
02C54:  MOVLB  5
02C56:  MOVWF  x97
02C58:  MOVLB  0
02C5A:  RCALL  2902
....................    data=i2c_read(0); 
02C5C:  CLRF   00
02C5E:  RCALL  2C02
02C60:  MOVLB  5
02C62:  CLRF   x87
02C64:  MOVFF  01,586
....................    i2c_stop(); 
02C68:  BSF    FC5.2
02C6A:  BTFSC  FC5.2
02C6C:  BRA    2C6A
....................    ack=!ack; 
02C6E:  BTG    2D.4
....................    delay_ms(5); 
02C70:  MOVLW  05
02C72:  MOVWF  x91
02C74:  MOVLB  0
02C76:  RCALL  2954
....................    enable_interrupts(GLOBAL); 
02C78:  MOVLW  C0
02C7A:  IORWF  FF2,F
....................  
....................    return(data); 
02C7C:  MOVLB  5
02C7E:  MOVFF  586,01
02C82:  MOVFF  587,02
02C86:  MOVLB  0
02C88:  RETURN 0
....................  
.................... } 
.................... void init_ext_eeprom() { 
.................... 	int a; 
....................  
....................     output_float(EEPROM_SCL); 
02C8A:  BSF    F94.3
....................     output_float(EEPROM_SDA); 
02C8C:  BSF    F94.4
....................  
.................... 	write_ext_eeprom(0x00ff,0xAA); 
02C8E:  MOVLB  5
02C90:  CLRF   x80
02C92:  SETF   x7F
02C94:  CLRF   x82
02C96:  MOVLW  AA
02C98:  MOVWF  x81
02C9A:  MOVLB  0
02C9C:  RCALL  2B00
.................... 	if (ack == false) 
02C9E:  BTFSC  2D.4
02CA0:  BRA    2CD4
.................... 	{ 
.................... 	limpa_display(); 
02CA2:  RCALL  2B6C
.................... 	posiciona_cursor(1,1); 
02CA4:  MOVLW  01
02CA6:  MOVLB  5
02CA8:  MOVWF  x86
02CAA:  MOVWF  x87
02CAC:  MOVLB  0
02CAE:  RCALL  2B82
.................... 	display("erro de escrita "); 
02CB0:  MOVLW  BA
02CB2:  MOVWF  FF6
02CB4:  MOVLW  00
02CB6:  MOVWF  FF7
02CB8:  RCALL  2BE2
.................... 	posiciona_cursor(2,1); 
02CBA:  MOVLW  02
02CBC:  MOVLB  5
02CBE:  MOVWF  x86
02CC0:  MOVLW  01
02CC2:  MOVWF  x87
02CC4:  MOVLB  0
02CC6:  RCALL  2B82
.................... 	display("   EEPROM       "); 
02CC8:  MOVLW  CC
02CCA:  MOVWF  FF6
02CCC:  MOVLW  00
02CCE:  MOVWF  FF7
02CD0:  RCALL  2BE2
.................... 	while(true){} 
02CD2:  BRA    2CD2
.................... 	} 
.................... 	 
.................... 	delay_ms(5);	 
02CD4:  MOVLW  05
02CD6:  MOVLB  5
02CD8:  MOVWF  x91
02CDA:  MOVLB  0
02CDC:  RCALL  2954
....................  
.................... 	a = read_ext_eeprom(0x00ff); 
02CDE:  MOVLB  5
02CE0:  CLRF   x85
02CE2:  SETF   x84
02CE4:  MOVLB  0
02CE6:  RCALL  2C1E
02CE8:  MOVFF  01,574
.................... 	if (a != 0xAA) 
02CEC:  MOVLB  5
02CEE:  MOVF   x74,W
02CF0:  SUBLW  AA
02CF2:  BZ    2D2A
.................... 	{ 
.................... 	limpa_display(); 
02CF4:  MOVLB  0
02CF6:  RCALL  2B6C
.................... 	posiciona_cursor(1,1); 
02CF8:  MOVLW  01
02CFA:  MOVLB  5
02CFC:  MOVWF  x86
02CFE:  MOVWF  x87
02D00:  MOVLB  0
02D02:  RCALL  2B82
.................... 	display("erro de leitura  "); 
02D04:  MOVLW  DE
02D06:  MOVWF  FF6
02D08:  MOVLW  00
02D0A:  MOVWF  FF7
02D0C:  RCALL  2BE2
.................... 	posiciona_cursor(2,1); 
02D0E:  MOVLW  02
02D10:  MOVLB  5
02D12:  MOVWF  x86
02D14:  MOVLW  01
02D16:  MOVWF  x87
02D18:  MOVLB  0
02D1A:  RCALL  2B82
.................... 	display("     EEPROM      "); 
02D1C:  MOVLW  F0
02D1E:  MOVWF  FF6
02D20:  MOVLW  00
02D22:  MOVWF  FF7
02D24:  RCALL  2BE2
.................... 	while(true){} 
02D26:  BRA    2D26
02D28:  MOVLB  5
.................... 	} 
02D2A:  MOVLB  0
02D2C:  GOTO   D9FE (RETURN)
....................  
....................  
....................      
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
.................... #include "teclado_21_teclas.c" 
.................... #define		F1					10 
.................... #define		F2					11 
.................... #define     F3					12 
.................... #define		F4					13 
.................... #define     SETA_SUPERIOR   	14 
.................... #define     SETA_INFERIOR   	15  
.................... #define		SETA_DIREITA    	16  
.................... #define     SETA_ESQUERDA  	    17 
.................... #define     ESC					18 
.................... #define     ENTER				19	 
.................... #define     MENU				20 
....................  
.................... void Init_Keyboard(void){ 
.................... 	escreve_PCA9555(0X01,0X06,0Xff,0xf8);// programa bit 0,bit 1,bit 2  como saida e os demais como entrada 
*
02A80:  MOVLW  01
02A82:  MOVLB  5
02A84:  MOVWF  x92
02A86:  MOVLW  06
02A88:  MOVWF  x93
02A8A:  SETF   x94
02A8C:  MOVLW  F8
02A8E:  MOVWF  x95
02A90:  MOVLB  0
02A92:  RCALL  2A2E
....................  	escreve_PCA9555(0X01,0X02,0X00,0X07);//coloca colunas em  high level 
02A94:  MOVLW  01
02A96:  MOVLB  5
02A98:  MOVWF  x92
02A9A:  MOVLW  02
02A9C:  MOVWF  x93
02A9E:  CLRF   x94
02AA0:  MOVLW  07
02AA2:  MOVWF  x95
02AA4:  MOVLB  0
02AA6:  RCALL  2A2E
02AA8:  GOTO   D9EE (RETURN)
.................... } 
.................... unsigned long int  Get_Key(void){	 
*
05AD0:  MOVLB  5
05AD2:  CLRF   x80
05AD4:  CLRF   x7F
05AD6:  MOVLW  06
05AD8:  MOVWF  x81
05ADA:  MOVLW  7F
05ADC:  MOVWF  x82
.................... 	long int dado = 0x0000; 
.................... 	int    coluna = 0x06; 
....................     int    mascara = 0x7f; 
.................... 	long int i; 
.................... 	for (i = 0 ; i < 3 ; i++) { 
05ADE:  CLRF   x84
05AE0:  CLRF   x83
05AE2:  MOVF   x84,F
05AE4:  BNZ   5B58
05AE6:  MOVF   x83,W
05AE8:  SUBLW  02
05AEA:  BNC   5B58
....................     	coluna -= i; 
05AEC:  MOVF   x83,W
05AEE:  SUBWF  x81,F
.................... 		escreve_PCA9555(0X01,0X02,0X00,coluna);     // coloca coluna  em  low level 
05AF0:  MOVLW  01
05AF2:  MOVWF  x92
05AF4:  MOVLW  02
05AF6:  MOVWF  x93
05AF8:  CLRF   x94
05AFA:  MOVFF  581,595
05AFE:  MOVLB  0
05B00:  CALL   2A2E
.................... 		dado =  le_PCA9555(0X01,0X00) >> 3;         // desloca bits 
05B04:  MOVLW  01
05B06:  MOVLB  5
05B08:  MOVWF  x85
05B0A:  CLRF   x86
05B0C:  MOVLB  0
05B0E:  CALL   493C
05B12:  MOVLB  5
05B14:  RRCF   02,W
05B16:  MOVWF  x80
05B18:  RRCF   01,W
05B1A:  MOVWF  x7F
05B1C:  RRCF   x80,F
05B1E:  RRCF   x7F,F
05B20:  RRCF   x80,F
05B22:  RRCF   x7F,F
05B24:  MOVLW  1F
05B26:  ANDWF  x80,F
.................... 		dado &= mascara;  							// mascara bits 
05B28:  MOVF   x82,W
05B2A:  ANDWF  x7F,F
05B2C:  CLRF   x80
....................         dado = 127 - dado;                            
05B2E:  MOVLW  7F
05B30:  BSF    FD8.0
05B32:  SUBFWB x7F,F
05B34:  MOVLW  00
05B36:  SUBFWB x80,F
.................... 		if(dado != 0) { 
05B38:  MOVF   x7F,F
05B3A:  BNZ   5B40
05B3C:  MOVF   x80,F
05B3E:  BZ    5B50
....................             i = i << 8; 
05B40:  MOVFF  583,584
05B44:  CLRF   x83
....................             dado |= i ; 
05B46:  MOVF   x83,W
05B48:  IORWF  x7F,F
05B4A:  MOVF   x84,W
05B4C:  IORWF  x80,F
....................             break; 
05B4E:  BRA    5B58
.................... 		}		 
05B50:  INCF   x83,F
05B52:  BTFSC  FD8.2
05B54:  INCF   x84,F
05B56:  BRA    5AE2
.................... 	}		 
....................     return(dado); 
05B58:  MOVFF  57F,01
05B5C:  MOVFF  580,02
05B60:  MOVLB  0
05B62:  GOTO   5B72 (RETURN)
.................... } 
.................... int Teclado(void) { 
05B66:  MOVLB  5
05B68:  CLRF   x7D
05B6A:  CLRF   x7C
05B6C:  CLRF   x7E
....................  // l o teclado 
....................  // se nenhuma tecla acionada retorna 0xff 
....................  // se acionada retorna o codigo da tecla 
....................    unsigned long int codigo_teclado = 0x0000; 
....................    int key_code = 0x00; 
....................    codigo_teclado = Get_Key(); 
05B6E:  MOVLB  0
05B70:  BRA    5AD0
05B72:  MOVFF  02,57D
05B76:  MOVFF  01,57C
....................    if(codigo_teclado == 0x00) return( key_code =0xff);	 
05B7A:  MOVLB  5
05B7C:  MOVF   x7C,F
05B7E:  BNZ   5B8C
05B80:  MOVF   x7D,F
05B82:  BNZ   5B8C
05B84:  SETF   x7E
05B86:  MOVFF  57E,01
05B8A:  BRA    5DA4
.................... 	switch(codigo_teclado){ 
05B8C:  MOVF   x7C,W
05B8E:  MOVWF  00
05B90:  MOVF   x7D,W
05B92:  MOVWF  03
05B94:  MOVLW  01
05B96:  SUBWF  03,W
05B98:  BNZ   5BA6
05B9A:  MOVLW  40
05B9C:  SUBWF  00,W
05B9E:  MOVLB  0
05BA0:  BTFSC  FD8.2
05BA2:  BRA    5CFA
05BA4:  MOVLB  5
05BA6:  MOVF   03,W
05BA8:  BNZ   5BB6
05BAA:  MOVLW  08
05BAC:  SUBWF  00,W
05BAE:  MOVLB  0
05BB0:  BTFSC  FD8.2
05BB2:  BRA    5D00
05BB4:  MOVLB  5
05BB6:  MOVLW  01
05BB8:  SUBWF  03,W
05BBA:  BNZ   5BC8
05BBC:  MOVLW  08
05BBE:  SUBWF  00,W
05BC0:  MOVLB  0
05BC2:  BTFSC  FD8.2
05BC4:  BRA    5D08
05BC6:  MOVLB  5
05BC8:  MOVLW  02
05BCA:  SUBWF  03,W
05BCC:  BNZ   5BDA
05BCE:  MOVLW  08
05BD0:  SUBWF  00,W
05BD2:  MOVLB  0
05BD4:  BTFSC  FD8.2
05BD6:  BRA    5D10
05BD8:  MOVLB  5
05BDA:  MOVF   03,W
05BDC:  BNZ   5BEA
05BDE:  MOVLW  10
05BE0:  SUBWF  00,W
05BE2:  MOVLB  0
05BE4:  BTFSC  FD8.2
05BE6:  BRA    5D18
05BE8:  MOVLB  5
05BEA:  MOVLW  01
05BEC:  SUBWF  03,W
05BEE:  BNZ   5BFC
05BF0:  MOVLW  10
05BF2:  SUBWF  00,W
05BF4:  MOVLB  0
05BF6:  BTFSC  FD8.2
05BF8:  BRA    5D20
05BFA:  MOVLB  5
05BFC:  MOVLW  02
05BFE:  SUBWF  03,W
05C00:  BNZ   5C0E
05C02:  MOVLW  10
05C04:  SUBWF  00,W
05C06:  MOVLB  0
05C08:  BTFSC  FD8.2
05C0A:  BRA    5D28
05C0C:  MOVLB  5
05C0E:  MOVF   03,W
05C10:  BNZ   5C1E
05C12:  MOVLW  20
05C14:  SUBWF  00,W
05C16:  MOVLB  0
05C18:  BTFSC  FD8.2
05C1A:  BRA    5D30
05C1C:  MOVLB  5
05C1E:  MOVLW  01
05C20:  SUBWF  03,W
05C22:  BNZ   5C30
05C24:  MOVLW  20
05C26:  SUBWF  00,W
05C28:  MOVLB  0
05C2A:  BTFSC  FD8.2
05C2C:  BRA    5D38
05C2E:  MOVLB  5
05C30:  MOVLW  02
05C32:  SUBWF  03,W
05C34:  BNZ   5C42
05C36:  MOVLW  20
05C38:  SUBWF  00,W
05C3A:  MOVLB  0
05C3C:  BTFSC  FD8.2
05C3E:  BRA    5D40
05C40:  MOVLB  5
05C42:  MOVF   03,W
05C44:  BNZ   5C52
05C46:  MOVLW  01
05C48:  SUBWF  00,W
05C4A:  MOVLB  0
05C4C:  BTFSC  FD8.2
05C4E:  BRA    5D48
05C50:  MOVLB  5
05C52:  MOVLW  02
05C54:  SUBWF  03,W
05C56:  BNZ   5C64
05C58:  MOVLW  01
05C5A:  SUBWF  00,W
05C5C:  MOVLB  0
05C5E:  BTFSC  FD8.2
05C60:  BRA    5D50
05C62:  MOVLB  5
05C64:  MOVF   03,W
05C66:  BNZ   5C74
05C68:  MOVLW  04
05C6A:  SUBWF  00,W
05C6C:  MOVLB  0
05C6E:  BTFSC  FD8.2
05C70:  BRA    5D58
05C72:  MOVLB  5
05C74:  MOVLW  02
05C76:  SUBWF  03,W
05C78:  BNZ   5C86
05C7A:  MOVLW  04
05C7C:  SUBWF  00,W
05C7E:  MOVLB  0
05C80:  BTFSC  FD8.2
05C82:  BRA    5D60
05C84:  MOVLB  5
05C86:  MOVF   03,W
05C88:  BNZ   5C96
05C8A:  MOVLW  40
05C8C:  SUBWF  00,W
05C8E:  MOVLB  0
05C90:  BTFSC  FD8.2
05C92:  BRA    5D68
05C94:  MOVLB  5
05C96:  MOVLW  02
05C98:  SUBWF  03,W
05C9A:  BNZ   5CA8
05C9C:  MOVLW  40
05C9E:  SUBWF  00,W
05CA0:  MOVLB  0
05CA2:  BTFSC  FD8.2
05CA4:  BRA    5D70
05CA6:  MOVLB  5
05CA8:  MOVLW  01
05CAA:  SUBWF  03,W
05CAC:  BNZ   5CBA
05CAE:  MOVLW  01
05CB0:  SUBWF  00,W
05CB2:  MOVLB  0
05CB4:  BTFSC  FD8.2
05CB6:  BRA    5D78
05CB8:  MOVLB  5
05CBA:  MOVF   03,W
05CBC:  BNZ   5CC8
05CBE:  MOVLW  02
05CC0:  SUBWF  00,W
05CC2:  MOVLB  0
05CC4:  BZ    5D80
05CC6:  MOVLB  5
05CC8:  MOVLW  02
05CCA:  SUBWF  03,W
05CCC:  BNZ   5CD8
05CCE:  MOVLW  02
05CD0:  SUBWF  00,W
05CD2:  MOVLB  0
05CD4:  BZ    5D88
05CD6:  MOVLB  5
05CD8:  MOVLW  01
05CDA:  SUBWF  03,W
05CDC:  BNZ   5CE8
05CDE:  MOVLW  04
05CE0:  SUBWF  00,W
05CE2:  MOVLB  0
05CE4:  BZ    5D90
05CE6:  MOVLB  5
05CE8:  MOVLW  01
05CEA:  SUBWF  03,W
05CEC:  BNZ   5CF8
05CEE:  MOVLW  02
05CF0:  SUBWF  00,W
05CF2:  MOVLB  0
05CF4:  BZ    5D98
05CF6:  MOVLB  5
05CF8:  BRA    5DA0
.................... 		case 320:key_code=0; 
05CFA:  MOVLB  5
05CFC:  CLRF   x7E
.................... 				break; 
05CFE:  BRA    5DA0
.................... 		case 8:	key_code=1; 
05D00:  MOVLW  01
05D02:  MOVLB  5
05D04:  MOVWF  x7E
.................... 				break; 
05D06:  BRA    5DA0
.................... 		case 264:key_code=2; 
05D08:  MOVLW  02
05D0A:  MOVLB  5
05D0C:  MOVWF  x7E
.................... 				break; 
05D0E:  BRA    5DA0
.................... 		case 520:key_code=3; 
05D10:  MOVLW  03
05D12:  MOVLB  5
05D14:  MOVWF  x7E
.................... 				break;	 
05D16:  BRA    5DA0
.................... 		case 16: key_code=4; 
05D18:  MOVLW  04
05D1A:  MOVLB  5
05D1C:  MOVWF  x7E
.................... 				break; 
05D1E:  BRA    5DA0
.................... 		case 272:key_code=5; 
05D20:  MOVLW  05
05D22:  MOVLB  5
05D24:  MOVWF  x7E
.................... 				break; 
05D26:  BRA    5DA0
.................... 		case 528:key_code=6; 
05D28:  MOVLW  06
05D2A:  MOVLB  5
05D2C:  MOVWF  x7E
.................... 				break; 
05D2E:  BRA    5DA0
.................... 		case 32:key_code=7; 
05D30:  MOVLW  07
05D32:  MOVLB  5
05D34:  MOVWF  x7E
.................... 				break; 
05D36:  BRA    5DA0
.................... 		case 288:key_code=8; 
05D38:  MOVLW  08
05D3A:  MOVLB  5
05D3C:  MOVWF  x7E
.................... 				break; 
05D3E:  BRA    5DA0
.................... 		case 544:key_code=9; 
05D40:  MOVLW  09
05D42:  MOVLB  5
05D44:  MOVWF  x7E
....................                 break; 
05D46:  BRA    5DA0
.................... 		case 1:	key_code=F1; 
05D48:  MOVLW  0A
05D4A:  MOVLB  5
05D4C:  MOVWF  x7E
....................                 break; 
05D4E:  BRA    5DA0
.................... 		case 513:key_code=F2; 
05D50:  MOVLW  0B
05D52:  MOVLB  5
05D54:  MOVWF  x7E
....................                 break; 
05D56:  BRA    5DA0
.................... 		case 4:	key_code=F3; 
05D58:  MOVLW  0C
05D5A:  MOVLB  5
05D5C:  MOVWF  x7E
....................                 break; 
05D5E:  BRA    5DA0
.................... 		case 516:key_code=F4; 
05D60:  MOVLW  0D
05D62:  MOVLB  5
05D64:  MOVWF  x7E
....................                 break; 
05D66:  BRA    5DA0
.................... 		case 64:key_code=ESC; 
05D68:  MOVLW  12
05D6A:  MOVLB  5
05D6C:  MOVWF  x7E
....................                 break; 
05D6E:  BRA    5DA0
.................... 		case 576:key_code=ENTER; 
05D70:  MOVLW  13
05D72:  MOVLB  5
05D74:  MOVWF  x7E
....................                 break; 
05D76:  BRA    5DA0
.................... 		case 257:key_code=SETA_SUPERIOR ; 
05D78:  MOVLW  0E
05D7A:  MOVLB  5
05D7C:  MOVWF  x7E
....................                 break; 
05D7E:  BRA    5DA0
.................... 		case 2:	key_code=SETA_ESQUERDA ; 
05D80:  MOVLW  11
05D82:  MOVLB  5
05D84:  MOVWF  x7E
....................                 break; 
05D86:  BRA    5DA0
.................... 		case 514:key_code=SETA_DIREITA ; 
05D88:  MOVLW  10
05D8A:  MOVLB  5
05D8C:  MOVWF  x7E
....................                 break; 
05D8E:  BRA    5DA0
.................... 		case 260:key_code=SETA_INFERIOR; 
05D90:  MOVLW  0F
05D92:  MOVLB  5
05D94:  MOVWF  x7E
....................                 break; 
05D96:  BRA    5DA0
.................... 		case 258:key_code=MENU; 
05D98:  MOVLW  14
05D9A:  MOVLB  5
05D9C:  MOVWF  x7E
....................                 break; 
05D9E:  BRA    5DA0
.................... 	    default: 
.................... 				break; 
.................... 	} 
.................... 	return( key_code ); 
05DA0:  MOVFF  57E,01
05DA4:  MOVLB  0
05DA6:  RETURN 0
.................... } 
.................... void espera_desacionar_teclas(void) { 
....................   int key_code = 0x00; 
....................   key_code = Teclado(); 
....................   while(key_code != 0xff){ 
....................     key_code = Teclado(); 
....................   } 
.................... } 
....................  
.................... #include "stepper_motor.c" 
.................... #DEFINE     step_y			    pin_C2 
.................... #DEFINE     dir_y				pin_C1 
.................... #DEFINE     enable_y			pin_C0 
....................  
.................... #DEFINE     step_x 		        pin_D2 
.................... #DEFINE     dir_x				pin_D1 
.................... #DEFINE     enable_x			pin_D0 
.................... #DEFINE     step_z              pin_A5              
.................... #DEFINE     dir_z               pin_A4 
.................... #DEFINE     enable_z            pin_A3 
.................... #DEFINE     step_flip           pin_E2 
.................... #DEFINE     dir_flip            pin_E1  
.................... #DEFINE     enable_flip         pin_E0 
....................  
.................... long int buffer_saida; 
.................... signed int16 motor_pos_x; 
.................... signed int16 motor_pos_y; 
.................... signed int16 motor_pos_flip; 
.................... signed int16 motor_pos_z; 
.................... short int direita_flag; 
.................... short int esquerda_flag; 
.................... short int frente_flag; 
.................... short int atras_flag; 
.................... short int sobe_flag; 
.................... short int desce_flag; 
.................... short int sentido_horario_flag; 
.................... short int sentido_antihorario_flag; 
....................  
.................... void direita(void) { 
....................     direita_flag = true; 
*
04EF6:  BSF    2D.5
....................     esquerda_flag = false; 
04EF8:  BCF    2D.6
....................     output_low(dir_x); 
04EFA:  BCF    F95.1
04EFC:  BCF    F8C.1
04EFE:  RETURN 0
.................... } 
.................... void esquerda(void) { 
....................     direita_flag = false; 
*
04F38:  BCF    2D.5
....................     esquerda_flag = true; 
04F3A:  BSF    2D.6
....................     output_high(dir_x); 
04F3C:  BCF    F95.1
04F3E:  BSF    F8C.1
04F40:  RETURN 0
.................... } 
.................... void frente(void) { 
....................     frente_flag = true; 
*
04D88:  BSF    2D.7
....................     atras_flag = false; 
04D8A:  MOVLB  2
04D8C:  BCF    x0B.0
....................     output_low(dir_y); 
04D8E:  BCF    F94.1
04D90:  BCF    F8B.1
04D92:  MOVLB  0
04D94:  RETURN 0
.................... } 
.................... void atras(void) { 
....................     frente_flag = false; 
*
04DCA:  BCF    2D.7
....................     atras_flag = true; 
04DCC:  MOVLB  2
04DCE:  BSF    x0B.0
....................     output_high(dir_y); 
04DD0:  BCF    F94.1
04DD2:  BSF    F8B.1
04DD4:  MOVLB  0
04DD6:  RETURN 0
.................... } 
.................... void sentido_horario(void) { 
....................     sentido_horario_flag = true; 
*
05464:  MOVLB  2
05466:  BSF    x0B.3
....................     sentido_antihorario_flag = false; 
05468:  BCF    x0B.4
....................     output_low(dir_flip); 
0546A:  BCF    F96.1
0546C:  BCF    F8D.1
0546E:  MOVLB  0
05470:  RETURN 0
.................... } 
.................... void sentido_antihorario(void) { 
....................     sentido_horario_flag = false; 
*
054A6:  MOVLB  2
054A8:  BCF    x0B.3
....................     sentido_antihorario_flag = true; 
054AA:  BSF    x0B.4
....................     output_high(dir_flip); 
054AC:  BCF    F96.1
054AE:  BSF    F8D.1
054B0:  MOVLB  0
054B2:  RETURN 0
.................... } 
.................... void sobe(void) { 
....................     sobe_flag = true; 
*
04C78:  MOVLB  2
04C7A:  BSF    x0B.1
....................     desce_flag = false; 
04C7C:  BCF    x0B.2
....................     output_low(dir_z); 
04C7E:  BCF    F92.4
04C80:  BCF    F89.4
04C82:  MOVLB  0
04C84:  RETURN 0
.................... } 
.................... void desce(void) { 
....................     sobe_flag = false; 
*
04C36:  MOVLB  2
04C38:  BCF    x0B.1
....................     desce_flag = true; 
04C3A:  BSF    x0B.2
....................     output_high(dir_z); 
04C3C:  BCF    F92.4
04C3E:  BSF    F89.4
04C40:  MOVLB  0
04C42:  RETURN 0
.................... } 
....................  
.................... void one_step_x(void) { 
....................     output_high(step_x); 
*
04F00:  BCF    F95.2
04F02:  BSF    F8C.2
....................     delay_us(10); 
04F04:  MOVLW  10
04F06:  MOVWF  00
04F08:  DECFSZ 00,F
04F0A:  BRA    4F08
04F0C:  NOP   
....................     output_low(step_x); 
04F0E:  BCF    F95.2
04F10:  BCF    F8C.2
....................     if (esquerda_flag == true) { 
04F12:  BTFSS  2D.6
04F14:  BRA    4F22
....................         motor_pos_x++; 
04F16:  MOVLB  2
04F18:  INCF   x03,F
04F1A:  BTFSC  FD8.2
04F1C:  INCF   x04,F
....................     } else { 
04F1E:  BRA    4F34
04F20:  MOVLB  0
....................         if (motor_pos_x != 0000){ 
04F22:  MOVLB  2
04F24:  MOVF   x03,F
04F26:  BNZ   4F2C
04F28:  MOVF   x04,F
04F2A:  BZ    4F34
....................             motor_pos_x--; 
04F2C:  MOVF   x03,W
04F2E:  BTFSC  FD8.2
04F30:  DECF   x04,F
04F32:  DECF   x03,F
....................         } 
....................     } 
04F34:  MOVLB  0
04F36:  RETURN 0
.................... } 
.................... void one_step_y(void) { 
....................     output_high(step_y); 
*
04D96:  BCF    F94.2
04D98:  BSF    F8B.2
....................     delay_us(10); 
04D9A:  MOVLW  10
04D9C:  MOVWF  00
04D9E:  DECFSZ 00,F
04DA0:  BRA    4D9E
04DA2:  NOP   
....................     output_low(step_y); 
04DA4:  BCF    F94.2
04DA6:  BCF    F8B.2
....................     if (atras_flag == true) { 
04DA8:  MOVLB  2
04DAA:  BTFSS  x0B.0
04DAC:  BRA    4DB6
....................         motor_pos_y++; 
04DAE:  INCF   x05,F
04DB0:  BTFSC  FD8.2
04DB2:  INCF   x06,F
....................     } else { 
04DB4:  BRA    4DC6
....................         if (motor_pos_y != 0000) { 
04DB6:  MOVF   x05,F
04DB8:  BNZ   4DBE
04DBA:  MOVF   x06,F
04DBC:  BZ    4DC6
....................             motor_pos_y--; 
04DBE:  MOVF   x05,W
04DC0:  BTFSC  FD8.2
04DC2:  DECF   x06,F
04DC4:  DECF   x05,F
....................         } 
....................     } 
04DC6:  MOVLB  0
04DC8:  RETURN 0
.................... } 
.................... void one_step_flip(void) { 
....................     output_high(step_flip); 
*
05472:  BCF    F96.2
05474:  BSF    F8D.2
....................     delay_us(10); 
05476:  MOVLW  10
05478:  MOVWF  00
0547A:  DECFSZ 00,F
0547C:  BRA    547A
0547E:  NOP   
....................     output_low(step_flip); 
05480:  BCF    F96.2
05482:  BCF    F8D.2
....................     if (sentido_horario_flag == true) { 
05484:  MOVLB  2
05486:  BTFSS  x0B.3
05488:  BRA    5492
....................         motor_pos_flip++; 
0548A:  INCF   x07,F
0548C:  BTFSC  FD8.2
0548E:  INCF   x08,F
....................     } else { 
05490:  BRA    54A2
....................         if (motor_pos_flip != 0000) { 
05492:  MOVF   x07,F
05494:  BNZ   549A
05496:  MOVF   x08,F
05498:  BZ    54A2
....................             motor_pos_flip--; 
0549A:  MOVF   x07,W
0549C:  BTFSC  FD8.2
0549E:  DECF   x08,F
054A0:  DECF   x07,F
....................         } 
....................     } 
054A2:  MOVLB  0
054A4:  RETURN 0
.................... } 
.................... void one_step_z(void) { 
....................     output_high(step_z); 
*
04C44:  BCF    F92.5
04C46:  BSF    F89.5
....................     delay_us(10); 
04C48:  MOVLW  10
04C4A:  MOVWF  00
04C4C:  DECFSZ 00,F
04C4E:  BRA    4C4C
04C50:  NOP   
....................     output_low(step_z); 
04C52:  BCF    F92.5
04C54:  BCF    F89.5
....................     if (desce_flag == true) { 
04C56:  MOVLB  2
04C58:  BTFSS  x0B.2
04C5A:  BRA    4C64
....................         motor_pos_z++; 
04C5C:  INCF   x09,F
04C5E:  BTFSC  FD8.2
04C60:  INCF   x0A,F
....................     } else { 
04C62:  BRA    4C74
....................         if (motor_pos_z != 0000) { 
04C64:  MOVF   x09,F
04C66:  BNZ   4C6C
04C68:  MOVF   x0A,F
04C6A:  BZ    4C74
....................             motor_pos_z--; 
04C6C:  MOVF   x09,W
04C6E:  BTFSC  FD8.2
04C70:  DECF   x0A,F
04C72:  DECF   x09,F
....................         } 
....................     } 
04C74:  MOVLB  0
04C76:  RETURN 0
.................... } 
....................  
.................... void chopper_x(void) { 
....................     output_low(enable_x); 
*
04EF0:  BCF    F95.0
04EF2:  BCF    F8C.0
04EF4:  RETURN 0
.................... } 
.................... void chopper_y(void) { 
....................     output_low(enable_y); 
*
04D82:  BCF    F94.0
04D84:  BCF    F8B.0
04D86:  RETURN 0
.................... } 
.................... void chopper_flip(void) { 
....................     output_low(enable_flip); 
*
0545C:  BCF    F96.0
0545E:  BCF    F8D.0
05460:  GOTO   54BC (RETURN)
.................... } 
.................... void chopper_z(void) { 
....................     output_low(enable_z); 
*
04934:  BCF    F92.3
04936:  BCF    F89.3
04938:  GOTO   4C90 (RETURN)
.................... } 
.................... void stop_x(void) { 
....................     output_low(enable_x); 
*
04F42:  BCF    F95.0
04F44:  BCF    F8C.0
04F46:  RETURN 0
.................... } 
.................... void stop_y(void) { 
....................    output_low(enable_y); 
*
04DD8:  BCF    F94.0
04DDA:  BCF    F8B.0
04DDC:  RETURN 0
.................... } 
.................... void stop_flip(void) { 
....................     output_low(enable_flip); 
.................... } 
.................... void stop_z(void) { 
....................     output_low(enable_z); 
*
04C86:  BCF    F92.3
04C88:  BCF    F89.3
04C8A:  GOTO   4D80 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "I_O.c" 
.................... #define     IN0				0 
.................... #define     IN1				1 
.................... #define     IN2				2 
.................... #define     IN3				3 
.................... #define     IN4				4 
.................... #define     IN5				5 
.................... #define     IN6				6 
.................... #define     IN7				7 
.................... #define     IN8				8 
.................... #define     IN9				9 
.................... #define     IN10			10 
.................... #define     IN11			11 
.................... #define     IN12			12 
.................... #define     IN13			13 
.................... #define     IN14			14 
.................... #define     IN15			15 
.................... #define     IN16			16 
.................... #define     IN17			17 
.................... #define     IN18			18 
.................... #define     IN19			19 
.................... #define     IN20			20 
.................... #define     IN21			21	 
.................... #define     IN22			22 
.................... #define     IN23			23 
.................... #define     IN24			24 
.................... #define     IN25			25 
.................... #define     IN26    		26 
.................... #define     IN27	    	27 
.................... 	 
.................... #define     S_DEDO_IN_LS1      	    IN0  	//SENSOR AVANO CILINRO  1		 
.................... #define     S_DEDO_IN_LS2      	    IN1	 	//SENSOR AVANO CILINDRO 2			 
.................... #define     S_EMPURRADOR_IN_LS1	    IN2	 	//NT 
.................... #define     S_EMPURRADOR_IN_LS2     IN3	 	//SENSOR RECUO  CLP1			 
.................... #define     S_PRESSOR_LS2           IN4	 	//SENSOR AVANCO 
.................... #define     S_X_DIREITA			    IN5	 	//LIMITE DIREITA			 
.................... #define     S_X_ESQUERDA		    IN6	 	//LIMITE ESQUERDA			 
.................... #define     S_Y_FRENTE   		    IN7  	//LIMITE FRENTE			 
.................... #define     S_Y_ATRAS               IN8  	//LIMITE ATRAS	 
.................... #define     S_Y_DIREITA_PROT  	    IN9  	//LIMITE DIREITA DA OUTRA PLACA			 
.................... #define     S_Y_ESQUERDA_PROT       IN10 	//LIMITE ESQUERDA DA OUTRA PLACA	 
.................... #define     S_ROTACAO_LS1           IN11 	//SENSOR LIMITE GIRO HORARIO			 
.................... #define     S_FERRO_SOLDA1          IN12 	//SENSOR FERRO DE SOLDA 1 			 
.................... #define     S_Z_TOP	    		    IN13 	//SENSOR LIMITE  SUPEIOR			 
.................... #define     S_Z_BOTTOM			    IN14 	//SENSOR LIMITE  INFERIOR			 
.................... #define     S_FERRO_SOLDA2          IN15 	//SENSOR FERRO DE SOLDA 2			 
.................... #define     S_DEDO_OUT_LS1		    IN16 	//SENSOR AVANO 
.................... #define     S_DEDO_OUT_LS2	        IN17 	//SENSOR AVANO 
.................... #define     S_EMPURRADOR_OUT_LS1    IN18 	//SENSOR AVANO 			 
.................... #define     S_EMPURRADOR_OUT_LS2    IN19 	//SENSOR recuo	 
.................... #define     SENSOR_BOARD   			IN20 	 
.................... #define     S_BANDEJA               IN21 	//SENSOR BANDEJA CLP1 & CLP2 
.................... #define     S_FIO_SOLDA1	        IN22 	//SENSOR FIO DE SOLDA 1 
.................... #define     S_FIO_SOLDA2	        IN23 	//SENSOR FIO DE SOLDA 2 
.................... #define     S_FIO_SOLDA3	        IN24 	//SENSOR FIO DE SOLDA 3 
.................... #define     S_ESTEIRA               IN25 	//SENSOR DESLIGA ESTEIRA 
.................... #define     RESERVADO2 				IN26 	 
.................... #define     RESERVADO3              IN27    //RESET 
....................    	  
.................... // definio das saidas de comandos 
....................  
.................... #define     DEDO_ENTRADA				     7  //OUT 0 
.................... #define     EMPURRADOR_ENTRADA_SOL_EMPURRA   6  //OUT 1 
.................... #define     EMPURRADOR_ENTRADA_SOL_RETORNA 	 5  //OUT 2 
.................... #define     PRESSOR						     4  //OUT 3 
.................... #define     FERRO_SOLDA1				     3  //OUT 4 
.................... #define     FERRO_SOLDA2				     2  //OUT 5 
.................... #define     DEDO_SAIDA					     1  //OUT 6 
.................... #define     EMPURRADOR_SAIDA_SOL_EMPURRA     0  //OUT 7 
.................... #define     EMPURRADOR_SAIDA_SOL_RETORNA     15 //OUT 8 
.................... #define     ALIMENTADOR1					 14 //OUT 9  RL2 
.................... #define     ALIMENTADOR2					 13 //OUT 10 RL3 
.................... #define     ALIMENTADOR3					 12	//OUT 11 RL4  
.................... #define     LIMPADOR					     11	//OUT 12 RL5 
.................... #define     RELE_ESTEIRA                     10 //OUT 13  
.................... #define     LIMPA_BICO1                       8 //OUT 15    
.................... #define     LIMPA_BICO2                       9 //OUT 14  
....................  
.................... short int le_Input(int input_number){ 
*
049FA:  MOVLB  5
049FC:  CLRF   x7B
049FE:  CLRF   x7A
04A00:  CLRF   x7C
.................... 	short int retorno; 
....................     long int  data_sensores  = 0x0000; 
.................... 	int		  data_sensores2 = 0x00;	 
.................... 	if(input_number < 16) { 
04A02:  MOVF   x78,W
04A04:  SUBLW  0F
04A06:  BNC   4A7C
.................... 	 	data_sensores = le_PCA9555(0X03,0X00); 
04A08:  MOVLW  03
04A0A:  MOVWF  x85
04A0C:  CLRF   x86
04A0E:  MOVLB  0
04A10:  RCALL  493C
04A12:  MOVFF  02,57B
04A16:  MOVFF  01,57A
.................... 		if(bit_test (data_sensores,input_number) == 0){ 
04A1A:  MOVFF  57B,03
04A1E:  MOVLB  5
04A20:  MOVFF  57A,02
04A24:  MOVF   x78,W
04A26:  MOVWF  00
04A28:  BZ    4A34
04A2A:  BCF    FD8.0
04A2C:  RRCF   03,F
04A2E:  RRCF   02,F
04A30:  DECFSZ 00,F
04A32:  BRA    4A2A
04A34:  MOVF   02,W
04A36:  BTFSC  02.0
04A38:  BRA    4A74
.................... 			delay_us(30); 
04A3A:  MOVLW  31
04A3C:  MOVWF  00
04A3E:  DECFSZ 00,F
04A40:  BRA    4A3E
04A42:  BRA    4A44
.................... 			if(bit_test (data_sensores,input_number) == 0) return retorno = true; 
04A44:  MOVFF  57B,03
04A48:  MOVFF  57A,02
04A4C:  MOVF   x78,W
04A4E:  MOVWF  00
04A50:  BZ    4A5C
04A52:  BCF    FD8.0
04A54:  RRCF   03,F
04A56:  RRCF   02,F
04A58:  DECFSZ 00,F
04A5A:  BRA    4A52
04A5C:  MOVF   02,W
04A5E:  BTFSC  02.0
04A60:  BRA    4A6A
04A62:  BSF    x79.0
04A64:  MOVLW  01
04A66:  MOVWF  01
04A68:  BRA    4C06
.................... 			return  retorno = false; 
04A6A:  BCF    x79.0
04A6C:  MOVLW  00
04A6E:  MOVWF  01
04A70:  BRA    4C06
.................... 		} 
04A72:  BRA    4A7C
....................         else  
....................             return  retorno = false; 
04A74:  BCF    x79.0
04A76:  MOVLW  00
04A78:  MOVWF  01
04A7A:  BRA    4C06
.................... 	}		 
.................... 	if((input_number >= 16) && (input_number < 24)){ 
04A7C:  MOVF   x78,W
04A7E:  SUBLW  0F
04A80:  BC    4AF2
04A82:  MOVF   x78,W
04A84:  SUBLW  17
04A86:  BNC   4AF2
.................... 		data_sensores2 = le_pcf8574A(0x04); 
04A88:  MOVLW  04
04A8A:  MOVWF  x7D
04A8C:  MOVLB  0
04A8E:  BRA    49C4
04A90:  MOVFF  01,57C
.................... 		if(bit_test (data_sensores2,input_number - 16) == 0) { 
04A94:  MOVLW  10
04A96:  MOVLB  5
04A98:  SUBWF  x78,W
04A9A:  MOVWF  x7D
04A9C:  MOVFF  57C,00
04AA0:  MOVF   x7D,W
04AA2:  MOVWF  01
04AA4:  BZ    4AAE
04AA6:  BCF    FD8.0
04AA8:  RRCF   00,F
04AAA:  DECFSZ 01,F
04AAC:  BRA    4AA6
04AAE:  BTFSC  00.0
04AB0:  BRA    4AEA
.................... 			delay_us(30); 
04AB2:  MOVLW  31
04AB4:  MOVWF  00
04AB6:  DECFSZ 00,F
04AB8:  BRA    4AB6
04ABA:  BRA    4ABC
.................... 			if(bit_test (data_sensores2,input_number - 16) == 0) return retorno = true; 
04ABC:  MOVLW  10
04ABE:  SUBWF  x78,W
04AC0:  MOVWF  x7D
04AC2:  MOVFF  57C,00
04AC6:  MOVF   x7D,W
04AC8:  MOVWF  01
04ACA:  BZ    4AD4
04ACC:  BCF    FD8.0
04ACE:  RRCF   00,F
04AD0:  DECFSZ 01,F
04AD2:  BRA    4ACC
04AD4:  BTFSC  00.0
04AD6:  BRA    4AE0
04AD8:  BSF    x79.0
04ADA:  MOVLW  01
04ADC:  MOVWF  01
04ADE:  BRA    4C06
.................... 			return    retorno = false; 
04AE0:  BCF    x79.0
04AE2:  MOVLW  00
04AE4:  MOVWF  01
04AE6:  BRA    4C06
.................... 		} 
04AE8:  BRA    4AF2
....................         else { 
....................             return  retorno = false; 
04AEA:  BCF    x79.0
04AEC:  MOVLW  00
04AEE:  MOVWF  01
04AF0:  BRA    4C06
....................         } 
.................... 	} 
.................... 	if((input_number >= 24) && (input_number <= 27)) {	 
04AF2:  MOVF   x78,W
04AF4:  SUBLW  17
04AF6:  BTFSC  FD8.0
04AF8:  BRA    4C06
04AFA:  MOVF   x78,W
04AFC:  SUBLW  1B
04AFE:  BTFSS  FD8.0
04B00:  BRA    4C06
.................... 		switch(input_number) { 
04B02:  MOVLW  18
04B04:  SUBWF  x78,W
04B06:  ADDLW  FC
04B08:  BTFSC  FD8.0
04B0A:  BRA    4C06
04B0C:  ADDLW  04
04B0E:  MOVLB  0
04B10:  GOTO   4C0A
.................... 			case 24: 
....................                 if(input(in24_bit) == 0) { 
04B14:  BSF    F93.0
04B16:  BTFSC  F81.0
04B18:  BRA    4B40
....................                     delay_us(30); 
04B1A:  MOVLW  31
04B1C:  MOVWF  00
04B1E:  DECFSZ 00,F
04B20:  BRA    4B1E
04B22:  BRA    4B24
....................                     if(input(in24_bit) == 0) { 
04B24:  BSF    F93.0
04B26:  BTFSC  F81.0
04B28:  BRA    4B3E
....................                         return retorno	= true;		 
04B2A:  MOVLB  5
04B2C:  BSF    x79.0
04B2E:  MOVLW  01
04B30:  MOVWF  01
04B32:  BRA    4C06
....................                         return retorno	= false;	 
04B34:  BCF    x79.0
04B36:  MOVLW  00
04B38:  MOVWF  01
04B3A:  BRA    4C06
04B3C:  MOVLB  0
....................                     } 
....................                 } 
04B3E:  BRA    4B4C
....................                 else {	 
....................                     return retorno	= false; 
04B40:  MOVLB  5
04B42:  BCF    x79.0
04B44:  MOVLW  00
04B46:  MOVWF  01
04B48:  BRA    4C06
04B4A:  MOVLB  0
....................                 } 
....................             break; 
04B4C:  MOVLB  5
04B4E:  BRA    4C06
.................... 			case 25: 
....................                 if(input(in25_bit) == 0){ 
04B50:  BSF    F93.1
04B52:  BTFSC  F81.1
04B54:  BRA    4B7C
....................                     delay_us(30); 
04B56:  MOVLW  31
04B58:  MOVWF  00
04B5A:  DECFSZ 00,F
04B5C:  BRA    4B5A
04B5E:  BRA    4B60
....................                     if(input(in25_bit) == 0) { 
04B60:  BSF    F93.1
04B62:  BTFSC  F81.1
04B64:  BRA    4B7A
....................                         return retorno	= true;		 
04B66:  MOVLB  5
04B68:  BSF    x79.0
04B6A:  MOVLW  01
04B6C:  MOVWF  01
04B6E:  BRA    4C06
....................                         return retorno	= false;	 
04B70:  BCF    x79.0
04B72:  MOVLW  00
04B74:  MOVWF  01
04B76:  BRA    4C06
04B78:  MOVLB  0
....................                     } 
....................                 }else {	 
04B7A:  BRA    4B88
....................                     return retorno	= false; 
04B7C:  MOVLB  5
04B7E:  BCF    x79.0
04B80:  MOVLW  00
04B82:  MOVWF  01
04B84:  BRA    4C06
04B86:  MOVLB  0
....................                 } 
....................             break; 
04B88:  MOVLB  5
04B8A:  BRA    4C06
.................... 			case 26: 
....................                 if(input(in26_bit) == 0){ 
04B8C:  BSF    F93.3
04B8E:  BTFSC  F81.3
04B90:  BRA    4BB8
....................                     delay_us(30); 
04B92:  MOVLW  31
04B94:  MOVWF  00
04B96:  DECFSZ 00,F
04B98:  BRA    4B96
04B9A:  BRA    4B9C
....................                     if(input(in26_bit) == 0) { 
04B9C:  BSF    F93.3
04B9E:  BTFSC  F81.3
04BA0:  BRA    4BB6
....................                         return retorno	= true;		 
04BA2:  MOVLB  5
04BA4:  BSF    x79.0
04BA6:  MOVLW  01
04BA8:  MOVWF  01
04BAA:  BRA    4C06
....................                         return retorno	= false;	 
04BAC:  BCF    x79.0
04BAE:  MOVLW  00
04BB0:  MOVWF  01
04BB2:  BRA    4C06
04BB4:  MOVLB  0
....................                     } 
....................                 }else{ 	 
04BB6:  BRA    4BC4
....................                     return retorno	= false; 
04BB8:  MOVLB  5
04BBA:  BCF    x79.0
04BBC:  MOVLW  00
04BBE:  MOVWF  01
04BC0:  BRA    4C06
04BC2:  MOVLB  0
....................                 } 
....................             break; 
04BC4:  MOVLB  5
04BC6:  BRA    4C06
.................... 			case 27: 
....................                 if(input(in27_bit) == 0) { 
04BC8:  BSF    F93.4
04BCA:  BTFSC  F81.4
04BCC:  BRA    4BF4
....................                     delay_us(30); 
04BCE:  MOVLW  31
04BD0:  MOVWF  00
04BD2:  DECFSZ 00,F
04BD4:  BRA    4BD2
04BD6:  BRA    4BD8
....................                     if(input(in27_bit) == 0) { 
04BD8:  BSF    F93.4
04BDA:  BTFSC  F81.4
04BDC:  BRA    4BF2
....................                         return retorno	= true;		 
04BDE:  MOVLB  5
04BE0:  BSF    x79.0
04BE2:  MOVLW  01
04BE4:  MOVWF  01
04BE6:  BRA    4C06
....................                         return retorno	= false;	 
04BE8:  BCF    x79.0
04BEA:  MOVLW  00
04BEC:  MOVWF  01
04BEE:  BRA    4C06
04BF0:  MOVLB  0
....................                     } 
....................                 }else{ 	 
04BF2:  BRA    4C00
....................                     return retorno	= false; 
04BF4:  MOVLB  5
04BF6:  BCF    x79.0
04BF8:  MOVLW  00
04BFA:  MOVWF  01
04BFC:  BRA    4C06
04BFE:  MOVLB  0
....................                 } 
....................             break; 
04C00:  MOVLB  5
04C02:  BRA    4C06
04C04:  MOVLB  5
.................... 	 	} 
.................... 	} 
04C06:  MOVLB  0
04C08:  RETURN 0
.................... } 
.................... void aciona_saida(long int output_word){ 
.................... 	int valor_lsb; 
.................... 	int valor_msb; 
.................... 	bit_clear(buffer_saida,output_word); 
*
02E1E:  CLRF   03
02E20:  MOVLW  01
02E22:  MOVWF  02
02E24:  MOVLB  5
02E26:  MOVF   x8E,W
02E28:  MOVWF  00
02E2A:  BZ    2E36
02E2C:  BCF    FD8.0
02E2E:  RLCF   02,F
02E30:  RLCF   03,F
02E32:  DECFSZ 00,F
02E34:  BRA    2E2C
02E36:  MOVF   02,W
02E38:  XORLW  FF
02E3A:  MOVWF  00
02E3C:  MOVLW  FF
02E3E:  XORWF  03,F
02E40:  MOVF   00,W
02E42:  MOVLB  2
02E44:  ANDWF  x01,F
02E46:  MOVF   03,W
02E48:  ANDWF  x02,F
.................... 	valor_lsb = make8(buffer_saida,0);   
02E4A:  MOVFF  201,590
02E4E:  MOVLB  5
.................... 	valor_msb = make8(buffer_saida,1); 
02E50:  MOVFF  202,591
02E54:  MOVLB  5
.................... 	escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
02E56:  MOVLW  02
02E58:  MOVWF  x92
02E5A:  MOVWF  x93
02E5C:  MOVFF  591,594
02E60:  MOVFF  590,595
02E64:  MOVLB  0
02E66:  RCALL  2A2E
02E68:  RETURN 0
.................... } 
.................... void desaciona_saida(long int output_word){ 
.................... 	int valor_lsb; 
.................... 	int valor_msb; 
.................... 	bit_set(buffer_saida,output_word); 
*
02DDC:  CLRF   03
02DDE:  MOVLW  01
02DE0:  MOVWF  02
02DE2:  MOVLB  5
02DE4:  MOVF   x8E,W
02DE6:  MOVWF  00
02DE8:  BZ    2DF4
02DEA:  BCF    FD8.0
02DEC:  RLCF   02,F
02DEE:  RLCF   03,F
02DF0:  DECFSZ 00,F
02DF2:  BRA    2DEA
02DF4:  MOVF   02,W
02DF6:  MOVLB  2
02DF8:  IORWF  x01,F
02DFA:  MOVF   03,W
02DFC:  IORWF  x02,F
.................... 	valor_lsb = make8(buffer_saida,0);   
02DFE:  MOVFF  201,590
02E02:  MOVLB  5
.................... 	valor_msb = make8(buffer_saida,1); 
02E04:  MOVFF  202,591
02E08:  MOVLB  5
.................... 	escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
02E0A:  MOVLW  02
02E0C:  MOVWF  x92
02E0E:  MOVWF  x93
02E10:  MOVFF  591,594
02E14:  MOVFF  590,595
02E18:  MOVLB  0
02E1A:  RCALL  2A2E
02E1C:  RETURN 0
.................... } 
.................... void desaciona_todas_saidas(void){ 
.................... 	int valor_lsb; 
.................... 	int valor_msb; 
.................... 	buffer_saida = 0x0ffff; 
*
02AD8:  MOVLB  2
02ADA:  SETF   x02
02ADC:  SETF   x01
.................... 	valor_lsb = make8(buffer_saida,0);   
02ADE:  MOVFF  201,574
02AE2:  MOVLB  5
.................... 	valor_msb = make8(buffer_saida,1); 
02AE4:  MOVFF  202,575
02AE8:  MOVLB  5
.................... 	escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
02AEA:  MOVLW  02
02AEC:  MOVWF  x92
02AEE:  MOVWF  x93
02AF0:  MOVFF  575,594
02AF4:  MOVFF  574,595
02AF8:  MOVLB  0
02AFA:  RCALL  2A2E
02AFC:  GOTO   D9FA (RETURN)
.................... } 
.................... void Init_Sensores_porta1(void){ 
.................... 	escreve_PCA9555(0X03,0X06,0Xff,0xff);	// programa bits entradas  
*
02AAC:  MOVLW  03
02AAE:  MOVLB  5
02AB0:  MOVWF  x92
02AB2:  MOVLW  06
02AB4:  MOVWF  x93
02AB6:  SETF   x94
02AB8:  SETF   x95
02ABA:  MOVLB  0
02ABC:  RCALL  2A2E
02ABE:  GOTO   D9F2 (RETURN)
.................... } 
.................... void Init_saidas(void){ 
.................... 	escreve_PCA9555(0X02,0X06,0X00,0x00);	// programa bits saidas //como saida e os demais como entrada     
02AC2:  MOVLW  02
02AC4:  MOVLB  5
02AC6:  MOVWF  x92
02AC8:  MOVLW  06
02ACA:  MOVWF  x93
02ACC:  CLRF   x94
02ACE:  CLRF   x95
02AD0:  MOVLB  0
02AD2:  RCALL  2A2E
02AD4:  GOTO   D9F6 (RETURN)
.................... } 
....................  
.................... #include "comunicacao_entre_maquinas.c" 
.................... #include "comunicacao_entre_maquinas.h" 
.................... /*  
....................  * File:   comunicacao_entre_maquinas.h 
....................  * Author: ictsam0100 
....................  * 
....................  * Created on 6 de Dezembro de 2018, 11:13 
....................  */ 
....................  
.................... int posicao_maq; 
.................... int n_posicao; 
.................... int n_bit; 
....................  
.................... short int le_bit(int n_bit); //l bit especifico e verifica o valor "0 ou 1" 
.................... int ler_posicao_maquina_1 (void); //le os bits H3, H4 e H5 para verificar a posicao da maquina 1 
.................... void enviar_posicao_para_maquina_1 (int n_posicao); //aciona os outputs H0, H1 e H2 para enviar posicao para maquina 1    
....................  
....................  
.................... short int le_bit(int n_bit) { 
....................     short int retorno; 
....................  
....................     if (input(n_bit) == 1) { 
*
051E0:  MOVFF  57B,57D
051E4:  MOVLW  01
051E6:  MOVLB  5
051E8:  MOVWF  x7E
051EA:  MOVLW  0F
051EC:  MOVWF  x80
051EE:  MOVLW  92
051F0:  MOVWF  x7F
051F2:  MOVLB  0
051F4:  RCALL  516C
051F6:  MOVFF  57B,57D
051FA:  MOVLW  0F
051FC:  MOVLB  5
051FE:  MOVWF  x7F
05200:  MOVLW  80
05202:  MOVWF  x7E
05204:  MOVLB  0
05206:  RCALL  51AE
05208:  BTFSS  01.0
0520A:  BRA    5222
....................         return retorno = 1; 
0520C:  MOVLB  5
0520E:  BSF    x7C.0
05210:  MOVLW  01
05212:  MOVWF  01
05214:  BRA    5262
....................         delay_us(30); 
05216:  MOVLW  31
05218:  MOVWF  00
0521A:  DECFSZ 00,F
0521C:  BRA    521A
0521E:  BRA    5220
05220:  MOVLB  0
....................     } 
....................     if (input(n_bit) == 0) { 
05222:  MOVFF  57B,57D
05226:  MOVLW  01
05228:  MOVLB  5
0522A:  MOVWF  x7E
0522C:  MOVLW  0F
0522E:  MOVWF  x80
05230:  MOVLW  92
05232:  MOVWF  x7F
05234:  MOVLB  0
05236:  RCALL  516C
05238:  MOVFF  57B,57D
0523C:  MOVLW  0F
0523E:  MOVLB  5
05240:  MOVWF  x7F
05242:  MOVLW  80
05244:  MOVWF  x7E
05246:  MOVLB  0
05248:  RCALL  51AE
0524A:  BTFSC  01.0
0524C:  BRA    5264
....................         return retorno = 0; 
0524E:  MOVLB  5
05250:  BCF    x7C.0
05252:  MOVLW  00
05254:  MOVWF  01
05256:  BRA    5262
....................         delay_us(30); 
05258:  MOVLW  31
0525A:  MOVWF  00
0525C:  DECFSZ 00,F
0525E:  BRA    525C
05260:  BRA    5262
05262:  MOVLB  0
....................     } 
05264:  RETURN 0
.................... } 
.................... int le_posicao_outra_maquina (void){ 
05266:  MOVLW  1F
05268:  MOVLB  5
0526A:  MOVWF  x7B
0526C:  MOVLB  0
0526E:  RCALL  51E0
05270:  MOVFF  01,578
05274:  MOVLW  1E
05276:  MOVLB  5
05278:  MOVWF  x7B
0527A:  MOVLB  0
0527C:  RCALL  51E0
0527E:  MOVFF  01,579
05282:  MOVLW  1D
05284:  MOVLB  5
05286:  MOVWF  x7B
05288:  MOVLB  0
0528A:  RCALL  51E0
0528C:  MOVFF  01,57A
....................     int x = le_bit(H0); 
....................     int y = le_bit(H1); 
....................     int z = le_bit(H2); 
....................      
....................     switch (z) { 
05290:  MOVLB  5
05292:  MOVF   x7A,W
05294:  XORLW  00
05296:  MOVLB  0
05298:  BZ    52A0
0529A:  XORLW  01
0529C:  BZ    52F8
0529E:  BRA    5338
....................         case 0: 
....................             switch (y) { 
052A0:  MOVLB  5
052A2:  MOVF   x79,W
052A4:  XORLW  00
052A6:  MOVLB  0
052A8:  BZ    52B0
052AA:  XORLW  01
052AC:  BZ    52D2
052AE:  BRA    52F6
....................                 case 0: 
....................                     switch (x) { 
052B0:  MOVLB  5
052B2:  MOVF   x78,W
052B4:  XORLW  00
052B6:  MOVLB  0
052B8:  BZ    52C0
052BA:  XORLW  01
052BC:  BZ    52C8
052BE:  BRA    52D0
....................                         case 0: 
....................                             posicao_maq = ALIMENTADOR; 
052C0:  MOVLB  2
052C2:  CLRF   x0C
....................                         break; 
052C4:  MOVLB  0
052C6:  BRA    52D0
....................                         case 1: 
....................                             posicao_maq = HOME1; 
052C8:  MOVLW  01
052CA:  MOVLB  2
052CC:  MOVWF  x0C
....................                         break; 
052CE:  MOVLB  0
....................                     } 
....................                 break; 
052D0:  BRA    52F6
....................                 case 1: 
....................                     switch (x) { 
052D2:  MOVLB  5
052D4:  MOVF   x78,W
052D6:  XORLW  00
052D8:  MOVLB  0
052DA:  BZ    52E2
052DC:  XORLW  01
052DE:  BZ    52EC
052E0:  BRA    52F4
....................                         case 0: 
....................                             posicao_maq = SOLDAGEM; 
052E2:  MOVLW  03
052E4:  MOVLB  2
052E6:  MOVWF  x0C
....................                         break; 
052E8:  MOVLB  0
052EA:  BRA    52F4
....................                         case 1: 
....................                             posicao_maq = HOME2; 
052EC:  MOVLW  04
052EE:  MOVLB  2
052F0:  MOVWF  x0C
....................                         break; 
052F2:  MOVLB  0
....................                     } 
....................                 break;                     
052F4:  BRA    52F6
....................             } 
....................         break; 
052F6:  BRA    5338
....................         case 1: 
....................             switch (y) { 
052F8:  MOVLB  5
052FA:  MOVF   x79,W
052FC:  XORLW  00
052FE:  MOVLB  0
05300:  BZ    5308
05302:  XORLW  01
05304:  BZ    5324
05306:  BRA    5338
....................                 case 0: 
....................                     switch (x) { 
05308:  MOVLB  5
0530A:  MOVF   x78,W
0530C:  XORLW  00
0530E:  MOVLB  0
05310:  BZ    5318
05312:  XORLW  01
05314:  BZ    5322
05316:  BRA    5322
....................                         case 0: 
....................                             posicao_maq = DISPENSADOR; 
05318:  MOVLW  05
0531A:  MOVLB  2
0531C:  MOVWF  x0C
....................                         break; 
0531E:  MOVLB  0
05320:  BRA    5322
....................                         case 1: 
....................                              
....................                         break; 
....................                     } 
....................                 break; 
05322:  BRA    5338
....................                 case 1: 
....................                     switch (x) { 
05324:  MOVLB  5
05326:  MOVF   x78,W
05328:  XORLW  00
0532A:  MOVLB  0
0532C:  BZ    5334
0532E:  XORLW  01
05330:  BZ    5336
05332:  BRA    5336
....................                         case 0: 
....................                              
....................                         break; 
05334:  BRA    5336
....................                         case 1: 
....................                              
....................                         break; 
....................                     } 
....................                 break;  
05336:  BRA    5338
....................             }                 
....................         break; 
....................     } 
....................     return posicao_maq; 
05338:  MOVLB  2
0533A:  MOVFF  20C,01
0533E:  MOVLB  0
05340:  RETURN 0
.................... } 
.................... void envia_posicao_para_outra_maquina (int n_posicao) { 
....................     switch (n_posicao){ 
*
04752:  MOVLB  5
04754:  MOVF   x78,W
04756:  ADDLW  FA
04758:  BC    47B4
0475A:  ADDLW  06
0475C:  MOVLB  0
0475E:  GOTO   47B8
....................         case ALIMENTADOR: 
....................             output_low(H3); 
04762:  BCF    F95.4
04764:  BCF    F8C.4
....................             output_low(H4); 
04766:  BCF    F94.7
04768:  BCF    F8B.7
....................             output_low(H5); 
0476A:  BCF    F94.6
0476C:  BCF    F8B.6
....................         break; 
0476E:  MOVLB  5
04770:  BRA    47B4
....................         case HOME1: 
....................             output_high(H3); 
04772:  BCF    F95.4
04774:  BSF    F8C.4
....................             output_low (H4); 
04776:  BCF    F94.7
04778:  BCF    F8B.7
....................             output_low (H5); 
0477A:  BCF    F94.6
0477C:  BCF    F8B.6
....................         break; 
0477E:  MOVLB  5
04780:  BRA    47B4
....................         case SOLDAGEM: 
....................             output_low (H3); 
04782:  BCF    F95.4
04784:  BCF    F8C.4
....................             output_high(H4); 
04786:  BCF    F94.7
04788:  BSF    F8B.7
....................             output_low (H5); 
0478A:  BCF    F94.6
0478C:  BCF    F8B.6
....................         break; 
0478E:  MOVLB  5
04790:  BRA    47B4
....................         case HOME2: 
....................             output_high (H3); 
04792:  BCF    F95.4
04794:  BSF    F8C.4
....................             output_high(H4); 
04796:  BCF    F94.7
04798:  BSF    F8B.7
....................             output_low (H5); 
0479A:  BCF    F94.6
0479C:  BCF    F8B.6
....................         break; 
0479E:  MOVLB  5
047A0:  BRA    47B4
....................         case DISPENSADOR: 
....................             output_low (H3); 
047A2:  BCF    F95.4
047A4:  BCF    F8C.4
....................             output_low (H4); 
047A6:  BCF    F94.7
047A8:  BCF    F8B.7
....................             output_high(H5); 
047AA:  BCF    F94.6
047AC:  BSF    F8B.6
....................         break; 
047AE:  MOVLB  5
047B0:  BRA    47B4
047B2:  MOVLB  5
....................     } 
047B4:  MOVLB  0
047B6:  RETURN 0
.................... } 
....................  
.................... #include "telas_maquina_1.c" 
.................... #include "telas_maquina_1.h" 
.................... #define menu_principal                          0 
.................... #define menu_seleciona_maquina                  1 
.................... #define menu_seleciona_debug                    2 
.................... #define menu_seleciona_manutencao               3 
.................... #define menu_debug_entrada_1                    4 
.................... #define menu_debug_entrada_2                    5 
.................... #define menu_debug_entrada_3                    6 
.................... #define menu_manutencao_outra_maquina           7 
.................... #define menu_debug_saida_1                      8 
.................... #define menu_debug_saida_2                      9 
.................... #define menu_debug_saida_3                      10 
.................... #define menu_debug_saida_4                      11 
....................  
.................... #define menu_programa_principal                 12 
....................  
.................... #define menu_edita_modelo                       13 
.................... #define menu_excluir_modelo                     14 
.................... #define menu_seleciona_pontos                   15 
.................... #define menu_dados_ponto                        16 
.................... #define menu_edita_pontos_no_modelo             17 
.................... #define menu_dados_ponto_2                      18 
.................... #define menu_faltaSolda                         19 
.................... #define menu_seleciona_debug_2                  20 
.................... #define menu_confirmaManutencao                 21 
....................  
.................... void tela_apresentacao(void); //Tela que aparece quando liga a maquina 
.................... void tela_iniciando_maquina (void); //tela que aparece quando a maquina esta iniciando 
.................... void tela_movimentando_maquina (int posicao); //tela de movimentacao que aparece na maquina 2 
.................... void tela_esperando_mov_maquina(void); //tela esperando movimentacao da maquina 
.................... void tela_esperando_mov_outra_maquina (int posicao); //tela de espera de movimentacao da maquina 1 
.................... void tela_esperando_sair_posicao_outra_maquina(void); //tela de espera a outra maquina sair da posicao atual 
....................  
.................... void tela_principal(void); //tela principal 
.................... void tela_seleciona_maquina(void); // tela de selecao maquina 1 ou maquina 2 
.................... void tela_manutencao_outra_maquina(void); //tela de manutencao na outra maquina 
.................... void tela_edita_modelo (void); //tela que escolhe entre edicao e exclusao do modelo escolhido 
.................... void tela_seleciona_debug(void); //tela de selecao de debug: manutencao ou pontos 
.................... void tela_edita_pontos_no_modelo(void); //tela de edicao dos pontos no modelo 
.................... void tela_excluir_modelo(void); //tela que pergunta se voce quer realmente exlcuir o modelo 
.................... void tela_seleciona_pontos(void); //tela de escolha do ponto a ser editado 
.................... void tela_dados_ponto (void); //tela que mostra todos os dados do respectivo ponto da placa 
.................... void tela_dados_ponto_2 (void); //tela que mostra todos os dados do respectivo ponto da placa 
....................  
.................... void tela_seleciona_debug_2(void); //tela de selecao de debug: manutencao ou pontos 
.................... void tela_faltaSolda(void); //tela que mostra a necessidade de verificacao dos alimentados de solda 
....................  
.................... void tela_seleciona_manutencao (void); //tela que mostra as opcoes sensores de entrada e atuadores de saida 
.................... void tela_debug_entrada_1 (void); //tela 1 de sensores da maquina 
.................... void tela_debug_entrada_2 (void); //tela 2 de sensores da maquina 
.................... void tela_debug_entrada_3 (void); //tela 3 de sensores da maquina 
.................... void tela_debug_saida_1(void); //tela que podemos acionar a esteira, pinos de entrada, e o alimentador de placa 
.................... void tela_debug_saida_2(void); //tela que podemos acionar o pressor da placa, pinos de saida e dispensador de placa 
.................... void tela_debug_saida_3(void); //tela que podemos acionar os alimentadores de solda, limpar os bicos e acionar os ferros 
.................... void tela_debug_saida_4(void); //tela que podemos realizar a movimentacao do eixo x, y, z e o flip individualmenta 
....................  
....................  
.................... void tela_programa_principal(void);//tela que aparece quando estamos no programa principal 
....................  
....................  
.................... void tela_apresentacao(){ 
....................     printf(lcd_putc, "\f"); //limpa display 
*
02DA6:  MOVLW  0C
02DA8:  MOVLB  5
02DAA:  MOVWF  x85
02DAC:  MOVLB  0
02DAE:  RCALL  2D30
....................     printf(lcd_putc, "        ICTS        \n\r"); 
02DB0:  MOVLW  02
02DB2:  MOVWF  FF6
02DB4:  MOVLW  01
02DB6:  MOVWF  FF7
02DB8:  RCALL  2D86
....................     printf(lcd_putc, "  INSTITUTO CENTRO  \n\r"); 
02DBA:  MOVLW  1A
02DBC:  MOVWF  FF6
02DBE:  MOVLW  01
02DC0:  MOVWF  FF7
02DC2:  RCALL  2D86
....................     printf(lcd_putc, "    TECNOLOGIA EM   \n\r"); 
02DC4:  MOVLW  32
02DC6:  MOVWF  FF6
02DC8:  MOVLW  01
02DCA:  MOVWF  FF7
02DCC:  RCALL  2D86
....................     printf(lcd_putc, "      SOFTWARE      \n\r"); 
02DCE:  MOVLW  4A
02DD0:  MOVWF  FF6
02DD2:  MOVLW  01
02DD4:  MOVWF  FF7
02DD6:  RCALL  2D86
02DD8:  GOTO   DA02 (RETURN)
.................... } 
.................... void tela_iniciando_maquina(){ 
....................     printf(lcd_putc, "\f"); //limpa display 
*
02F02:  MOVLW  0C
02F04:  MOVLB  5
02F06:  MOVWF  x85
02F08:  MOVLB  0
02F0A:  RCALL  2D30
....................     printf(lcd_putc, "     INICIANDO     \n\r"); 
02F0C:  MOVLW  62
02F0E:  MOVWF  FF6
02F10:  MOVLW  01
02F12:  MOVWF  FF7
02F14:  RCALL  2D86
....................     printf(lcd_putc, "      BANDEJAS     \n\r"); 
02F16:  MOVLW  78
02F18:  MOVWF  FF6
02F1A:  MOVLW  01
02F1C:  MOVWF  FF7
02F1E:  RCALL  2D86
02F20:  GOTO   DA0A (RETURN)
.................... } 
.................... void tela_movimentando_maquina (int posicao) { 
....................     switch (posicao){ 
*
047E8:  MOVLB  5
047EA:  MOVF   x78,W
047EC:  ADDLW  FA
047EE:  BTFSC  FD8.0
047F0:  BRA    4900
047F2:  ADDLW  06
047F4:  MOVLB  0
047F6:  GOTO   4904
....................         case ALIMENTADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
047FA:  MOVLW  0C
047FC:  MOVLB  5
047FE:  MOVWF  x85
04800:  MOVLB  0
04802:  CALL   2D30
....................             printf(lcd_putc, "MOVIMENTANDO BANDEJA\n\r"); 
04806:  MOVLW  8E
04808:  MOVWF  FF6
0480A:  MOVLW  01
0480C:  MOVWF  FF7
0480E:  CALL   2D86
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
04812:  MOVLW  A6
04814:  MOVWF  FF6
04816:  MOVLW  01
04818:  MOVWF  FF7
0481A:  CALL   2D86
....................             printf(lcd_putc, "     ALIMENTADOR    \n\r"); 
0481E:  MOVLW  BE
04820:  MOVWF  FF6
04822:  MOVLW  01
04824:  MOVWF  FF7
04826:  CALL   2D86
....................         break; 
0482A:  MOVLB  5
0482C:  BRA    4900
....................         case HOME1: 
....................             printf(lcd_putc, "\f"); //limpa display 
0482E:  MOVLW  0C
04830:  MOVLB  5
04832:  MOVWF  x85
04834:  MOVLB  0
04836:  CALL   2D30
....................             printf(lcd_putc, "MOVIMENTANDO BANDEJA\n\r"); 
0483A:  MOVLW  D6
0483C:  MOVWF  FF6
0483E:  MOVLW  01
04840:  MOVWF  FF7
04842:  CALL   2D86
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
04846:  MOVLW  EE
04848:  MOVWF  FF6
0484A:  MOVLW  01
0484C:  MOVWF  FF7
0484E:  CALL   2D86
....................             printf(lcd_putc, "       HOME 1       \n\r"); 
04852:  MOVLW  06
04854:  MOVWF  FF6
04856:  MOVLW  02
04858:  MOVWF  FF7
0485A:  CALL   2D86
....................         break; 
0485E:  MOVLB  5
04860:  BRA    4900
....................         case SOLDAGEM: 
....................             printf(lcd_putc, "\f"); //limpa display 
04862:  MOVLW  0C
04864:  MOVLB  5
04866:  MOVWF  x85
04868:  MOVLB  0
0486A:  CALL   2D30
....................             printf(lcd_putc, "MOVIMENTANDO BANDEJA\n\r"); 
0486E:  MOVLW  1E
04870:  MOVWF  FF6
04872:  MOVLW  02
04874:  MOVWF  FF7
04876:  CALL   2D86
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
0487A:  MOVLW  36
0487C:  MOVWF  FF6
0487E:  MOVLW  02
04880:  MOVWF  FF7
04882:  CALL   2D86
....................             printf(lcd_putc, "      SOLDAGEM     \n\r"); 
04886:  MOVLW  4E
04888:  MOVWF  FF6
0488A:  MOVLW  02
0488C:  MOVWF  FF7
0488E:  CALL   2D86
....................         break; 
04892:  MOVLB  5
04894:  BRA    4900
....................         case HOME2: 
....................             printf(lcd_putc, "\f"); //limpa display 
04896:  MOVLW  0C
04898:  MOVLB  5
0489A:  MOVWF  x85
0489C:  MOVLB  0
0489E:  CALL   2D30
....................             printf(lcd_putc, "MOVIMENTANDO BANDEJA\n\r"); 
048A2:  MOVLW  64
048A4:  MOVWF  FF6
048A6:  MOVLW  02
048A8:  MOVWF  FF7
048AA:  CALL   2D86
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
048AE:  MOVLW  7C
048B0:  MOVWF  FF6
048B2:  MOVLW  02
048B4:  MOVWF  FF7
048B6:  CALL   2D86
....................             printf(lcd_putc, "       HOME 2       \n\r"); 
048BA:  MOVLW  94
048BC:  MOVWF  FF6
048BE:  MOVLW  02
048C0:  MOVWF  FF7
048C2:  CALL   2D86
....................         break; 
048C6:  MOVLB  5
048C8:  BRA    4900
....................         case DISPENSADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
048CA:  MOVLW  0C
048CC:  MOVLB  5
048CE:  MOVWF  x85
048D0:  MOVLB  0
048D2:  CALL   2D30
....................             printf(lcd_putc, "MOVIMENTANDO BANDEJA\n\r"); 
048D6:  MOVLW  AC
048D8:  MOVWF  FF6
048DA:  MOVLW  02
048DC:  MOVWF  FF7
048DE:  CALL   2D86
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
048E2:  MOVLW  C4
048E4:  MOVWF  FF6
048E6:  MOVLW  02
048E8:  MOVWF  FF7
048EA:  CALL   2D86
....................             printf(lcd_putc, "    DISPENSADOR     \n\r"); 
048EE:  MOVLW  DC
048F0:  MOVWF  FF6
048F2:  MOVLW  02
048F4:  MOVWF  FF7
048F6:  CALL   2D86
....................         break; 
048FA:  MOVLB  5
048FC:  BRA    4900
048FE:  MOVLB  5
....................     } 
04900:  MOVLB  0
04902:  RETURN 0
.................... } 
.................... void tela_esperando_mov_maquina(void) { 
....................     printf(lcd_putc, "\f"); //limpa display 
*
065B2:  MOVLW  0C
065B4:  MOVLB  5
065B6:  MOVWF  x85
065B8:  MOVLB  0
065BA:  CALL   2D30
....................     printf(lcd_putc, "  ESPERANDO BANDEJA \n\r"); 
065BE:  MOVLW  F4
065C0:  MOVWF  FF6
065C2:  MOVLW  02
065C4:  MOVWF  FF7
065C6:  CALL   2D86
....................     printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
065CA:  MOVLW  0C
065CC:  MOVWF  FF6
065CE:  MOVLW  03
065D0:  MOVWF  FF7
065D2:  CALL   2D86
....................     printf(lcd_putc, "    PRE-REQUISITO   \n\r"); 
065D6:  MOVLW  24
065D8:  MOVWF  FF6
065DA:  MOVLW  03
065DC:  MOVWF  FF7
065DE:  CALL   2D86
065E2:  RETURN 0
.................... } 
.................... void tela_esperando_mov_outra_maquina(int posicao) { 
....................     switch (posicao){ 
....................         case ALIMENTADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
....................             printf(lcd_putc, "       BANDEJA      \n\r"); 
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
....................             printf(lcd_putc, "     ALIMENTADOR    \n\r"); 
....................         case HOME1: 
....................             printf(lcd_putc, "\f"); //limpa display 
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
....................             printf(lcd_putc, "       BANDEJA      \n\r"); 
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
....................             printf(lcd_putc, "       HOME 1       \n\r"); 
....................         break; 
....................         case SOLDAGEM: 
....................             printf(lcd_putc, "\f"); //limpa display 
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
....................             printf(lcd_putc, "       BANDEJA      \n\r"); 
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
....................             printf(lcd_putc, "     SOLDAGEM 1     \n\r"); 
....................         break; 
....................         case HOME2: 
....................             printf(lcd_putc, "\f"); //limpa display 
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
....................             printf(lcd_putc, "       BANDEJA      \n\r"); 
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
....................             printf(lcd_putc, "       HOME 2       \n\r"); 
....................         break; 
....................         case DISPENSADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
....................             printf(lcd_putc, "       BANDEJA      \n\r"); 
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
....................             printf(lcd_putc, "     DISPENSADOR    \n\r"); 
....................         break; 
....................     } 
.................... } 
.................... void tela_esperando_sair_posicao_outra_maquina(void){ 
....................     printf(lcd_putc, "\f"); //limpa display 
065E4:  MOVLW  0C
065E6:  MOVLB  5
065E8:  MOVWF  x85
065EA:  MOVLB  0
065EC:  CALL   2D30
....................     printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
065F0:  MOVLW  1C
065F2:  MOVWF  FF6
065F4:  MOVLW  05
065F6:  MOVWF  FF7
065F8:  CALL   2D86
....................     printf(lcd_putc, "       BANDEJA      \n\r"); 
065FC:  MOVLW  34
065FE:  MOVWF  FF6
06600:  MOVLW  05
06602:  MOVWF  FF7
06604:  CALL   2D86
....................     printf(lcd_putc, "   SAIR DA POSICAO  \n\r"); 
06608:  MOVLW  4C
0660A:  MOVWF  FF6
0660C:  MOVLW  05
0660E:  MOVWF  FF7
06610:  CALL   2D86
....................     printf(lcd_putc, "        ATUAL       \n\r"); 
06614:  MOVLW  64
06616:  MOVWF  FF6
06618:  MOVLW  05
0661A:  MOVWF  FF7
0661C:  CALL   2D86
06620:  RETURN 0
.................... } 
....................  
.................... void tela_principal() { 
....................     printf(lcd_putc, "\f"); // limpa display 
*
059D6:  MOVLW  0C
059D8:  MOVLB  5
059DA:  MOVWF  x85
059DC:  MOVLB  0
059DE:  CALL   2D30
....................     printf(lcd_putc, " SOLDADOR AUTOMATICO\n\r"); 
059E2:  MOVLW  7C
059E4:  MOVWF  FF6
059E6:  MOVLW  05
059E8:  MOVWF  FF7
059EA:  CALL   2D86
....................     printf(lcd_putc, "      MODELO:%02u   \n\r",modelo); 
059EE:  MOVLW  94
059F0:  MOVWF  FF6
059F2:  MOVLW  05
059F4:  MOVWF  FF7
059F6:  MOVLW  0D
059F8:  MOVLB  5
059FA:  MOVWF  x7C
059FC:  MOVLB  0
059FE:  RCALL  58FE
05A00:  MOVFF  2E,57C
05A04:  MOVLW  01
05A06:  MOVLB  5
05A08:  MOVWF  x7D
05A0A:  MOVLB  0
05A0C:  RCALL  5954
05A0E:  MOVLW  A5
05A10:  MOVWF  FF6
05A12:  MOVLW  05
05A14:  MOVWF  FF7
05A16:  MOVLW  05
05A18:  MOVLB  5
05A1A:  MOVWF  x7C
05A1C:  MOVLB  0
05A1E:  RCALL  58FE
....................     printf(lcd_putc, "     MENU:EDITAR    \n\r"); 
05A20:  MOVLW  AC
05A22:  MOVWF  FF6
05A24:  MOVLW  05
05A26:  MOVWF  FF7
05A28:  CALL   2D86
....................     printf(lcd_putc, "  ENTER:AUTOMATICO  \n\r"); 
05A2C:  MOVLW  C4
05A2E:  MOVWF  FF6
05A30:  MOVLW  05
05A32:  MOVWF  FF7
05A34:  CALL   2D86
05A38:  RETURN 0
.................... } 
.................... void tela_seleciona_maquina(){ 
....................     printf(lcd_putc, "\f"); 
*
06248:  MOVLW  0C
0624A:  MOVLB  5
0624C:  MOVWF  x85
0624E:  MOVLB  0
06250:  CALL   2D30
....................     printf(lcd_putc, " SELECIONE A BANDEJA\n\r"); 
06254:  MOVLW  DC
06256:  MOVWF  FF6
06258:  MOVLW  05
0625A:  MOVWF  FF7
0625C:  CALL   2D86
....................     printf(lcd_putc, "    F1: BANDEJA 1   \n\r"); 
06260:  MOVLW  F4
06262:  MOVWF  FF6
06264:  MOVLW  05
06266:  MOVWF  FF7
06268:  CALL   2D86
....................     printf(lcd_putc, "    F2: BANDEJA 2   \n\r"); 
0626C:  MOVLW  0C
0626E:  MOVWF  FF6
06270:  MOVLW  06
06272:  MOVWF  FF7
06274:  CALL   2D86
....................     printf(lcd_putc, "    ESC:BACK        \n\r"); 
06278:  MOVLW  24
0627A:  MOVWF  FF6
0627C:  MOVLW  06
0627E:  MOVWF  FF7
06280:  CALL   2D86
06284:  RETURN 0
.................... } 
.................... void tela_manutencao_outra_maquina() { 
....................     printf(lcd_putc, "\f"); // limpa display 
*
06FA0:  MOVLW  0C
06FA2:  MOVLB  5
06FA4:  MOVWF  x85
06FA6:  MOVLB  0
06FA8:  CALL   2D30
....................     printf(lcd_putc, "     MANUTENCAO     \n\r"); 
06FAC:  MOVLW  3C
06FAE:  MOVWF  FF6
06FB0:  MOVLW  06
06FB2:  MOVWF  FF7
06FB4:  CALL   2D86
....................     printf(lcd_putc, "      BANDEJA 2     \n\r"); 
06FB8:  MOVLW  54
06FBA:  MOVWF  FF6
06FBC:  MOVLW  06
06FBE:  MOVWF  FF7
06FC0:  CALL   2D86
....................     printf(lcd_putc, "                    \n\r"); 
06FC4:  MOVLW  6C
06FC6:  MOVWF  FF6
06FC8:  MOVLW  06
06FCA:  MOVWF  FF7
06FCC:  CALL   2D86
....................     printf(lcd_putc, "      ESC:BACK      \n\r"); 
06FD0:  MOVLW  84
06FD2:  MOVWF  FF6
06FD4:  MOVLW  06
06FD6:  MOVWF  FF7
06FD8:  CALL   2D86
06FDC:  RETURN 0
.................... } 
.................... void tela_edita_modelo(){ 
....................     printf(lcd_putc, "\f"); 
*
06384:  MOVLW  0C
06386:  MOVLB  5
06388:  MOVWF  x85
0638A:  MOVLB  0
0638C:  CALL   2D30
....................     printf(lcd_putc, "    ESCOLHER ACAO   \n\r"); 
06390:  MOVLW  9C
06392:  MOVWF  FF6
06394:  MOVLW  06
06396:  MOVWF  FF7
06398:  CALL   2D86
....................     printf(lcd_putc, "F1:EDITAR/MANUTENCAO\n\r"); 
0639C:  MOVLW  B4
0639E:  MOVWF  FF6
063A0:  MOVLW  06
063A2:  MOVWF  FF7
063A4:  CALL   2D86
....................     printf(lcd_putc, "F2:EXCLUI MODELO  \n\r"); 
063A8:  MOVLW  CC
063AA:  MOVWF  FF6
063AC:  MOVLW  06
063AE:  MOVWF  FF7
063B0:  CALL   2D86
....................     printf(lcd_putc, "ESC:BACK          \n\r"); 
063B4:  MOVLW  E2
063B6:  MOVWF  FF6
063B8:  MOVLW  06
063BA:  MOVWF  FF7
063BC:  CALL   2D86
063C0:  RETURN 0
.................... } 
.................... void tela_seleciona_debug(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0709A:  MOVLW  0C
0709C:  MOVLB  5
0709E:  MOVWF  x85
070A0:  MOVLB  0
070A2:  CALL   2D30
....................     printf(lcd_putc, "  F1: EDITAR PONTOS \n\r"); 
070A6:  MOVLW  F8
070A8:  MOVWF  FF6
070AA:  MOVLW  06
070AC:  MOVWF  FF7
070AE:  CALL   2D86
....................     printf(lcd_putc, "  F2: MANUTENCAO    \n\r"); 
070B2:  MOVLW  10
070B4:  MOVWF  FF6
070B6:  MOVLW  07
070B8:  MOVWF  FF7
070BA:  CALL   2D86
....................     printf(lcd_putc, "\n\r"); 
070BE:  MOVLW  0A
070C0:  MOVLB  5
070C2:  MOVWF  x85
070C4:  MOVLB  0
070C6:  CALL   2D30
070CA:  MOVLW  0D
070CC:  MOVLB  5
070CE:  MOVWF  x85
070D0:  MOVLB  0
070D2:  CALL   2D30
....................     printf(lcd_putc, "  ESC:BACK          \n\r"); 
070D6:  MOVLW  28
070D8:  MOVWF  FF6
070DA:  MOVLW  07
070DC:  MOVWF  FF7
070DE:  CALL   2D86
070E2:  RETURN 0
.................... } 
.................... void tela_seleciona_debug_2(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0715A:  MOVLW  0C
0715C:  MOVLB  5
0715E:  MOVWF  x85
07160:  MOVLB  0
07162:  CALL   2D30
....................     printf(lcd_putc, "   F1: N PONTOS     \n\r"); 
07166:  MOVLW  40
07168:  MOVWF  FF6
0716A:  MOVLW  07
0716C:  MOVWF  FF7
0716E:  CALL   2D86
....................     printf(lcd_putc, "  F2: EDITAR PONTOS \n\r"); 
07172:  MOVLW  58
07174:  MOVWF  FF6
07176:  MOVLW  07
07178:  MOVWF  FF7
0717A:  CALL   2D86
....................     printf(lcd_putc, "\n\r"); 
0717E:  MOVLW  0A
07180:  MOVLB  5
07182:  MOVWF  x85
07184:  MOVLB  0
07186:  CALL   2D30
0718A:  MOVLW  0D
0718C:  MOVLB  5
0718E:  MOVWF  x85
07190:  MOVLB  0
07192:  CALL   2D30
....................     printf(lcd_putc, "  ESC:BACK          \n\r"); 
07196:  MOVLW  70
07198:  MOVWF  FF6
0719A:  MOVLW  07
0719C:  MOVWF  FF7
0719E:  CALL   2D86
071A2:  RETURN 0
.................... } 
.................... void tela_edita_pontos_no_modelo(){ 
....................     printf(lcd_putc, "\f"); 
*
072D0:  MOVLW  0C
072D2:  MOVLB  5
072D4:  MOVWF  x85
072D6:  MOVLB  0
072D8:  CALL   2D30
....................     printf(lcd_putc, "  NUMERO DE PONTOS  \n\r"); 
072DC:  MOVLW  88
072DE:  MOVWF  FF6
072E0:  MOVLW  07
072E2:  MOVWF  FF7
072E4:  CALL   2D86
....................     printf(lcd_putc, "         %04Lu       \n\r",pontos_no_modelo); 
072E8:  MOVLW  A0
072EA:  MOVWF  FF6
072EC:  MOVLW  07
072EE:  MOVWF  FF7
072F0:  MOVLW  09
072F2:  MOVLB  5
072F4:  MOVWF  x7C
072F6:  MOVLB  0
072F8:  CALL   58FE
072FC:  MOVLW  09
072FE:  MOVWF  FE9
07300:  MOVFF  12C,57D
07304:  MOVFF  12B,57C
07308:  RCALL  7212
0730A:  MOVLW  AE
0730C:  MOVWF  FF6
0730E:  MOVLW  07
07310:  MOVWF  FF7
07312:  MOVLW  09
07314:  MOVLB  5
07316:  MOVWF  x7C
07318:  MOVLB  0
0731A:  CALL   58FE
....................     printf(lcd_putc, " ENTER:SAVE|ESC:BACK\n\r"); 
0731E:  MOVLW  B8
07320:  MOVWF  FF6
07322:  MOVLW  07
07324:  MOVWF  FF7
07326:  CALL   2D86
0732A:  RETURN 0
.................... } 
.................... void tela_excluir_modelo(){ 
....................     printf(lcd_putc, "\f"); 
*
070E4:  MOVLW  0C
070E6:  MOVLB  5
070E8:  MOVWF  x85
070EA:  MOVLB  0
070EC:  CALL   2D30
....................     printf(lcd_putc, "   DESEJA EXCLUIR   \n\r"); 
070F0:  MOVLW  D0
070F2:  MOVWF  FF6
070F4:  MOVLW  07
070F6:  MOVWF  FF7
070F8:  CALL   2D86
....................     printf(lcd_putc, "     O MODELO ?     \n\r"); 
070FC:  MOVLW  E8
070FE:  MOVWF  FF6
07100:  MOVLW  07
07102:  MOVWF  FF7
07104:  CALL   2D86
....................     printf(lcd_putc, "      ENTER:OK      \n\r"); 
07108:  MOVLW  00
0710A:  MOVWF  FF6
0710C:  MOVLW  08
0710E:  MOVWF  FF7
07110:  CALL   2D86
....................     printf(lcd_putc, "      ESC:BACK     \n\r"); 
07114:  MOVLW  18
07116:  MOVWF  FF6
07118:  MOVLW  08
0711A:  MOVWF  FF7
0711C:  CALL   2D86
07120:  GOTO   7156 (RETURN)
.................... } 
.................... void tela_seleciona_pontos(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
07464:  MOVLW  0C
07466:  MOVLB  5
07468:  MOVWF  x85
0746A:  MOVLB  0
0746C:  CALL   2D30
....................     printf(lcd_putc, "P%02u         ENT:EDIT\n\r",inicial_lcd); 
07470:  MOVLW  50
07472:  MOVLB  5
07474:  MOVWF  x85
07476:  MOVLB  0
07478:  CALL   2D30
0747C:  MOVFF  22,57C
07480:  MOVLW  01
07482:  MOVLB  5
07484:  MOVWF  x7D
07486:  MOVLB  0
07488:  CALL   5954
0748C:  MOVLW  33
0748E:  MOVWF  FF6
07490:  MOVLW  08
07492:  MOVWF  FF7
07494:  MOVLW  13
07496:  MOVLB  5
07498:  MOVWF  x7C
0749A:  MOVLB  0
0749C:  CALL   58FE
....................     printf(lcd_putc, "P%02u         ESC:BACK\n\r",inicial_lcd+1); 
074A0:  MOVLW  01
074A2:  ADDWF  22,W
074A4:  MOVLB  5
074A6:  MOVWF  x75
074A8:  MOVLW  50
074AA:  MOVWF  x85
074AC:  MOVLB  0
074AE:  CALL   2D30
074B2:  MOVFF  575,57C
074B6:  MOVLW  01
074B8:  MOVLB  5
074BA:  MOVWF  x7D
074BC:  MOVLB  0
074BE:  CALL   5954
074C2:  MOVLW  4D
074C4:  MOVWF  FF6
074C6:  MOVLW  08
074C8:  MOVWF  FF7
074CA:  MOVLW  13
074CC:  MOVLB  5
074CE:  MOVWF  x7C
074D0:  MOVLB  0
074D2:  CALL   58FE
....................     printf(lcd_putc, "P%02u                 \n\r",inicial_lcd+2); 
074D6:  MOVLW  02
074D8:  ADDWF  22,W
074DA:  MOVLB  5
074DC:  MOVWF  x75
074DE:  MOVLW  50
074E0:  MOVWF  x85
074E2:  MOVLB  0
074E4:  CALL   2D30
074E8:  MOVFF  575,57C
074EC:  MOVLW  01
074EE:  MOVLB  5
074F0:  MOVWF  x7D
074F2:  MOVLB  0
074F4:  CALL   5954
074F8:  MOVLW  67
074FA:  MOVWF  FF6
074FC:  MOVLW  08
074FE:  MOVWF  FF7
07500:  MOVLW  13
07502:  MOVLB  5
07504:  MOVWF  x7C
07506:  MOVLB  0
07508:  CALL   58FE
....................     printf(lcd_putc, "P%02u                 \n\r",inicial_lcd+3); 
0750C:  MOVLW  03
0750E:  ADDWF  22,W
07510:  MOVLB  5
07512:  MOVWF  x75
07514:  MOVLW  50
07516:  MOVWF  x85
07518:  MOVLB  0
0751A:  CALL   2D30
0751E:  MOVFF  575,57C
07522:  MOVLW  01
07524:  MOVLB  5
07526:  MOVWF  x7D
07528:  MOVLB  0
0752A:  CALL   5954
0752E:  MOVLW  81
07530:  MOVWF  FF6
07532:  MOVLW  08
07534:  MOVWF  FF7
07536:  MOVLW  13
07538:  MOVLB  5
0753A:  MOVWF  x7C
0753C:  MOVLB  0
0753E:  CALL   58FE
....................     posiciona_cursor(ponteiro_lcd,5); 
07542:  MOVFF  21,586
07546:  MOVLW  05
07548:  MOVLB  5
0754A:  MOVWF  x87
0754C:  MOVLB  0
0754E:  CALL   2B82
....................     printf(lcd_putc,"<"); 
07552:  MOVLW  3C
07554:  MOVLB  5
07556:  MOVWF  x85
07558:  MOVLB  0
0755A:  CALL   2D30
0755E:  RETURN 0
.................... } 
.................... void tela_dados_ponto (contador_lcd){ 
....................     printf(lcd_putc, "\f"); // limpa display 
07560:  MOVLW  0C
07562:  MOVLB  5
07564:  MOVWF  x85
07566:  MOVLB  0
07568:  CALL   2D30
....................     printf(lcd_putc, "X:%04Lu T:%04Lu\n\r",x[contador_lcd],tipo[contador_lcd]); 
0756C:  BCF    FD8.0
0756E:  MOVLB  5
07570:  RLCF   x75,W
07572:  CLRF   03
07574:  ADDLW  2F
07576:  MOVWF  FE9
07578:  MOVLW  00
0757A:  ADDWFC 03,W
0757C:  MOVWF  FEA
0757E:  MOVFF  FEC,577
07582:  MOVF   FED,F
07584:  MOVFF  FEF,576
07588:  BCF    FD8.0
0758A:  RLCF   x75,W
0758C:  CLRF   03
0758E:  ADDLW  01
07590:  MOVWF  FE9
07592:  MOVLW  01
07594:  ADDWFC 03,W
07596:  MOVWF  FEA
07598:  MOVFF  FEC,579
0759C:  MOVF   FED,F
0759E:  MOVFF  FEF,578
075A2:  MOVLW  58
075A4:  MOVWF  x85
075A6:  MOVLB  0
075A8:  CALL   2D30
075AC:  MOVLW  3A
075AE:  MOVLB  5
075B0:  MOVWF  x85
075B2:  MOVLB  0
075B4:  CALL   2D30
075B8:  MOVLW  09
075BA:  MOVWF  FE9
075BC:  MOVFF  577,57D
075C0:  MOVFF  576,57C
075C4:  RCALL  7212
075C6:  MOVLW  9D
075C8:  MOVWF  FF6
075CA:  MOVLW  08
075CC:  MOVWF  FF7
075CE:  MOVLW  03
075D0:  MOVLB  5
075D2:  MOVWF  x7C
075D4:  MOVLB  0
075D6:  CALL   58FE
075DA:  MOVLW  09
075DC:  MOVWF  FE9
075DE:  MOVFF  579,57D
075E2:  MOVFF  578,57C
075E6:  RCALL  7212
075E8:  MOVLW  0A
075EA:  MOVLB  5
075EC:  MOVWF  x85
075EE:  MOVLB  0
075F0:  CALL   2D30
075F4:  MOVLW  0D
075F6:  MOVLB  5
075F8:  MOVWF  x85
075FA:  MOVLB  0
075FC:  CALL   2D30
....................     printf(lcd_putc, "Y:%04Lu H:%04Lu F:%04Lu\n\r",y[contador_lcd],habilitado[contador_lcd],numeroFerros[contador_lcd]); 
07600:  BCF    FD8.0
07602:  MOVLB  5
07604:  RLCF   x75,W
07606:  CLRF   03
07608:  ADDLW  59
0760A:  MOVWF  FE9
0760C:  MOVLW  00
0760E:  ADDWFC 03,W
07610:  MOVWF  FEA
07612:  MOVFF  FEC,577
07616:  MOVF   FED,F
07618:  MOVFF  FEF,576
0761C:  BCF    FD8.0
0761E:  RLCF   x75,W
07620:  CLRF   03
07622:  ADDLW  2D
07624:  MOVWF  FE9
07626:  MOVLW  01
07628:  ADDWFC 03,W
0762A:  MOVWF  FEA
0762C:  MOVFF  FEC,579
07630:  MOVF   FED,F
07632:  MOVFF  FEF,578
07636:  BCF    FD8.0
07638:  RLCF   x75,W
0763A:  CLRF   03
0763C:  ADDLW  57
0763E:  MOVWF  FE9
07640:  MOVLW  01
07642:  ADDWFC 03,W
07644:  MOVWF  FEA
07646:  MOVFF  FEC,57B
0764A:  MOVF   FED,F
0764C:  MOVFF  FEF,57A
07650:  MOVLW  59
07652:  MOVWF  x85
07654:  MOVLB  0
07656:  CALL   2D30
0765A:  MOVLW  3A
0765C:  MOVLB  5
0765E:  MOVWF  x85
07660:  MOVLB  0
07662:  CALL   2D30
07666:  MOVLW  09
07668:  MOVWF  FE9
0766A:  MOVFF  577,57D
0766E:  MOVFF  576,57C
07672:  RCALL  7212
07674:  MOVLW  AF
07676:  MOVWF  FF6
07678:  MOVLW  08
0767A:  MOVWF  FF7
0767C:  MOVLW  03
0767E:  MOVLB  5
07680:  MOVWF  x7C
07682:  MOVLB  0
07684:  CALL   58FE
07688:  MOVLW  09
0768A:  MOVWF  FE9
0768C:  MOVFF  579,57D
07690:  MOVFF  578,57C
07694:  RCALL  7212
07696:  MOVLW  B7
07698:  MOVWF  FF6
0769A:  MOVLW  08
0769C:  MOVWF  FF7
0769E:  MOVLW  03
076A0:  MOVLB  5
076A2:  MOVWF  x7C
076A4:  MOVLB  0
076A6:  CALL   58FE
076AA:  MOVLW  09
076AC:  MOVWF  FE9
076AE:  MOVFF  57B,57D
076B2:  MOVFF  57A,57C
076B6:  RCALL  7212
076B8:  MOVLW  0A
076BA:  MOVLB  5
076BC:  MOVWF  x85
076BE:  MOVLB  0
076C0:  CALL   2D30
076C4:  MOVLW  0D
076C6:  MOVLB  5
076C8:  MOVWF  x85
076CA:  MOVLB  0
076CC:  CALL   2D30
....................     printf(lcd_putc, "Z:%04Lu I:%02u L:%04Lu\n\r",z[contador_lcd],incremento,limpar[contador_lcd]); 
076D0:  BCF    FD8.0
076D2:  MOVLB  5
076D4:  RLCF   x75,W
076D6:  CLRF   03
076D8:  ADDLW  83
076DA:  MOVWF  FE9
076DC:  MOVLW  00
076DE:  ADDWFC 03,W
076E0:  MOVWF  FEA
076E2:  MOVFF  FEC,577
076E6:  MOVF   FED,F
076E8:  MOVFF  FEF,576
076EC:  BCF    FD8.0
076EE:  RLCF   x75,W
076F0:  CLRF   03
076F2:  ADDLW  D5
076F4:  MOVWF  FE9
076F6:  MOVLW  01
076F8:  ADDWFC 03,W
076FA:  MOVWF  FEA
076FC:  MOVFF  FEC,579
07700:  MOVF   FED,F
07702:  MOVFF  FEF,578
07706:  MOVLW  5A
07708:  MOVWF  x85
0770A:  MOVLB  0
0770C:  CALL   2D30
07710:  MOVLW  3A
07712:  MOVLB  5
07714:  MOVWF  x85
07716:  MOVLB  0
07718:  CALL   2D30
0771C:  MOVLW  09
0771E:  MOVWF  FE9
07720:  MOVFF  577,57D
07724:  MOVFF  576,57C
07728:  RCALL  7212
0772A:  MOVLW  C9
0772C:  MOVWF  FF6
0772E:  MOVLW  08
07730:  MOVWF  FF7
07732:  MOVLW  03
07734:  MOVLB  5
07736:  MOVWF  x7C
07738:  MOVLB  0
0773A:  CALL   58FE
0773E:  MOVFF  25,57C
07742:  MOVLW  01
07744:  MOVLB  5
07746:  MOVWF  x7D
07748:  MOVLB  0
0774A:  CALL   5954
0774E:  MOVLW  D0
07750:  MOVWF  FF6
07752:  MOVLW  08
07754:  MOVWF  FF7
07756:  MOVLW  03
07758:  MOVLB  5
0775A:  MOVWF  x7C
0775C:  MOVLB  0
0775E:  CALL   58FE
07762:  MOVLW  09
07764:  MOVWF  FE9
07766:  MOVFF  579,57D
0776A:  MOVFF  578,57C
0776E:  RCALL  7212
07770:  MOVLW  0A
07772:  MOVLB  5
07774:  MOVWF  x85
07776:  MOVLB  0
07778:  CALL   2D30
0777C:  MOVLW  0D
0777E:  MOVLB  5
07780:  MOVWF  x85
07782:  MOVLB  0
07784:  CALL   2D30
....................     printf(lcd_putc, "F1:GRAVA|F3:PROX\n\r"); 
07788:  MOVLW  DC
0778A:  MOVWF  FF6
0778C:  MOVLW  08
0778E:  MOVWF  FF7
07790:  CALL   2D86
07794:  RETURN 0
.................... }  
.................... void tela_dados_ponto_2 (contador_lcd){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0834A:  MOVLW  0C
0834C:  MOVLB  5
0834E:  MOVWF  x85
08350:  MOVLB  0
08352:  CALL   2D30
....................     printf(lcd_putc, "S1:%04Lu\n\r",t_solda[contador_lcd]); 
08356:  BCF    FD8.0
08358:  MOVLB  5
0835A:  RLCF   x75,W
0835C:  CLRF   03
0835E:  ADDLW  AD
08360:  MOVWF  FE9
08362:  MOVLW  00
08364:  ADDWFC 03,W
08366:  MOVWF  FEA
08368:  MOVFF  FEC,577
0836C:  MOVF   FED,F
0836E:  MOVFF  FEF,576
08372:  MOVLW  F0
08374:  MOVWF  FF6
08376:  MOVLW  08
08378:  MOVWF  FF7
0837A:  MOVLW  03
0837C:  MOVWF  x7C
0837E:  MOVLB  0
08380:  CALL   58FE
08384:  MOVLW  09
08386:  MOVWF  FE9
08388:  MOVFF  577,57D
0838C:  MOVFF  576,57C
08390:  CALL   7212
08394:  MOVLW  0A
08396:  MOVLB  5
08398:  MOVWF  x85
0839A:  MOVLB  0
0839C:  CALL   2D30
083A0:  MOVLW  0D
083A2:  MOVLB  5
083A4:  MOVWF  x85
083A6:  MOVLB  0
083A8:  CALL   2D30
....................     printf(lcd_putc, "S2:%04Lu E:%04Lu\n\r",t_solda2[contador_lcd],t_wait[contador_lcd]); 
083AC:  BCF    FD8.0
083AE:  MOVLB  5
083B0:  RLCF   x75,W
083B2:  CLRF   03
083B4:  ADDLW  81
083B6:  MOVWF  FE9
083B8:  MOVLW  01
083BA:  ADDWFC 03,W
083BC:  MOVWF  FEA
083BE:  MOVFF  FEC,577
083C2:  MOVF   FED,F
083C4:  MOVFF  FEF,576
083C8:  BCF    FD8.0
083CA:  RLCF   x75,W
083CC:  CLRF   03
083CE:  ADDLW  D7
083D0:  MOVWF  FE9
083D2:  MOVLW  00
083D4:  ADDWFC 03,W
083D6:  MOVWF  FEA
083D8:  MOVFF  FEC,579
083DC:  MOVF   FED,F
083DE:  MOVFF  FEF,578
083E2:  MOVLW  FC
083E4:  MOVWF  FF6
083E6:  MOVLW  08
083E8:  MOVWF  FF7
083EA:  MOVLW  03
083EC:  MOVWF  x7C
083EE:  MOVLB  0
083F0:  CALL   58FE
083F4:  MOVLW  09
083F6:  MOVWF  FE9
083F8:  MOVFF  577,57D
083FC:  MOVFF  576,57C
08400:  CALL   7212
08404:  MOVLW  04
08406:  MOVWF  FF6
08408:  MOVLW  09
0840A:  MOVWF  FF7
0840C:  MOVLW  03
0840E:  MOVLB  5
08410:  MOVWF  x7C
08412:  MOVLB  0
08414:  CALL   58FE
08418:  MOVLW  09
0841A:  MOVWF  FE9
0841C:  MOVFF  579,57D
08420:  MOVFF  578,57C
08424:  CALL   7212
08428:  MOVLW  0A
0842A:  MOVLB  5
0842C:  MOVWF  x85
0842E:  MOVLB  0
08430:  CALL   2D30
08434:  MOVLW  0D
08436:  MOVLB  5
08438:  MOVWF  x85
0843A:  MOVLB  0
0843C:  CALL   2D30
....................     printf(lcd_putc, "S3:%04Lu I:%02u\n\r",t_solda3[contador_lcd],incremento); 
08440:  BCF    FD8.0
08442:  MOVLB  5
08444:  RLCF   x75,W
08446:  CLRF   03
08448:  ADDLW  AB
0844A:  MOVWF  FE9
0844C:  MOVLW  01
0844E:  ADDWFC 03,W
08450:  MOVWF  FEA
08452:  MOVFF  FEC,577
08456:  MOVF   FED,F
08458:  MOVFF  FEF,576
0845C:  MOVLW  10
0845E:  MOVWF  FF6
08460:  MOVLW  09
08462:  MOVWF  FF7
08464:  MOVLW  03
08466:  MOVWF  x7C
08468:  MOVLB  0
0846A:  CALL   58FE
0846E:  MOVLW  09
08470:  MOVWF  FE9
08472:  MOVFF  577,57D
08476:  MOVFF  576,57C
0847A:  CALL   7212
0847E:  MOVLW  18
08480:  MOVWF  FF6
08482:  MOVLW  09
08484:  MOVWF  FF7
08486:  MOVLW  03
08488:  MOVLB  5
0848A:  MOVWF  x7C
0848C:  MOVLB  0
0848E:  CALL   58FE
08492:  MOVFF  25,57C
08496:  MOVLW  01
08498:  MOVLB  5
0849A:  MOVWF  x7D
0849C:  MOVLB  0
0849E:  CALL   5954
084A2:  MOVLW  0A
084A4:  MOVLB  5
084A6:  MOVWF  x85
084A8:  MOVLB  0
084AA:  CALL   2D30
084AE:  MOVLW  0D
084B0:  MOVLB  5
084B2:  MOVWF  x85
084B4:  MOVLB  0
084B6:  CALL   2D30
....................     printf(lcd_putc, "F1:REC|F3:BACK\n\r"); 
084BA:  MOVLW  22
084BC:  MOVWF  FF6
084BE:  MOVLW  09
084C0:  MOVWF  FF7
084C2:  CALL   2D86
084C6:  RETURN 0
.................... } 
.................... void tela_dados_ponto_3 (contador_lcd){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0820A:  MOVLW  0C
0820C:  MOVLB  5
0820E:  MOVWF  x85
08210:  MOVLB  0
08212:  CALL   2D30
....................     printf(lcd_putc, "\n\r"); 
08216:  MOVLW  0A
08218:  MOVLB  5
0821A:  MOVWF  x85
0821C:  MOVLB  0
0821E:  CALL   2D30
08222:  MOVLW  0D
08224:  MOVLB  5
08226:  MOVWF  x85
08228:  MOVLB  0
0822A:  CALL   2D30
....................     printf(lcd_putc, "S2:%04Lu E:%04Lu\n\r",t_solda2[contador_lcd],t_wait[contador_lcd]); 
0822E:  BCF    FD8.0
08230:  MOVLB  5
08232:  RLCF   x75,W
08234:  CLRF   03
08236:  ADDLW  81
08238:  MOVWF  FE9
0823A:  MOVLW  01
0823C:  ADDWFC 03,W
0823E:  MOVWF  FEA
08240:  MOVFF  FEC,577
08244:  MOVF   FED,F
08246:  MOVFF  FEF,576
0824A:  BCF    FD8.0
0824C:  RLCF   x75,W
0824E:  CLRF   03
08250:  ADDLW  D7
08252:  MOVWF  FE9
08254:  MOVLW  00
08256:  ADDWFC 03,W
08258:  MOVWF  FEA
0825A:  MOVFF  FEC,579
0825E:  MOVF   FED,F
08260:  MOVFF  FEF,578
08264:  MOVLW  34
08266:  MOVWF  FF6
08268:  MOVLW  09
0826A:  MOVWF  FF7
0826C:  MOVLW  03
0826E:  MOVWF  x7C
08270:  MOVLB  0
08272:  CALL   58FE
08276:  MOVLW  09
08278:  MOVWF  FE9
0827A:  MOVFF  577,57D
0827E:  MOVFF  576,57C
08282:  CALL   7212
08286:  MOVLW  3C
08288:  MOVWF  FF6
0828A:  MOVLW  09
0828C:  MOVWF  FF7
0828E:  MOVLW  03
08290:  MOVLB  5
08292:  MOVWF  x7C
08294:  MOVLB  0
08296:  CALL   58FE
0829A:  MOVLW  09
0829C:  MOVWF  FE9
0829E:  MOVFF  579,57D
082A2:  MOVFF  578,57C
082A6:  CALL   7212
082AA:  MOVLW  0A
082AC:  MOVLB  5
082AE:  MOVWF  x85
082B0:  MOVLB  0
082B2:  CALL   2D30
082B6:  MOVLW  0D
082B8:  MOVLB  5
082BA:  MOVWF  x85
082BC:  MOVLB  0
082BE:  CALL   2D30
....................     printf(lcd_putc, "S3:%04Lu I:%02u\n\r",t_solda3[contador_lcd],incremento); 
082C2:  BCF    FD8.0
082C4:  MOVLB  5
082C6:  RLCF   x75,W
082C8:  CLRF   03
082CA:  ADDLW  AB
082CC:  MOVWF  FE9
082CE:  MOVLW  01
082D0:  ADDWFC 03,W
082D2:  MOVWF  FEA
082D4:  MOVFF  FEC,577
082D8:  MOVF   FED,F
082DA:  MOVFF  FEF,576
082DE:  MOVLW  48
082E0:  MOVWF  FF6
082E2:  MOVLW  09
082E4:  MOVWF  FF7
082E6:  MOVLW  03
082E8:  MOVWF  x7C
082EA:  MOVLB  0
082EC:  CALL   58FE
082F0:  MOVLW  09
082F2:  MOVWF  FE9
082F4:  MOVFF  577,57D
082F8:  MOVFF  576,57C
082FC:  CALL   7212
08300:  MOVLW  50
08302:  MOVWF  FF6
08304:  MOVLW  09
08306:  MOVWF  FF7
08308:  MOVLW  03
0830A:  MOVLB  5
0830C:  MOVWF  x7C
0830E:  MOVLB  0
08310:  CALL   58FE
08314:  MOVFF  25,57C
08318:  MOVLW  01
0831A:  MOVLB  5
0831C:  MOVWF  x7D
0831E:  MOVLB  0
08320:  CALL   5954
08324:  MOVLW  0A
08326:  MOVLB  5
08328:  MOVWF  x85
0832A:  MOVLB  0
0832C:  CALL   2D30
08330:  MOVLW  0D
08332:  MOVLB  5
08334:  MOVWF  x85
08336:  MOVLB  0
08338:  CALL   2D30
....................     printf(lcd_putc, "F1:REC|F3:BACK\n\r"); 
0833C:  MOVLW  5A
0833E:  MOVWF  FF6
08340:  MOVLW  09
08342:  MOVWF  FF7
08344:  CALL   2D86
08348:  RETURN 0
.................... } 
.................... void tela_dados_ponto_4 (contador_lcd){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
080CA:  MOVLW  0C
080CC:  MOVLB  5
080CE:  MOVWF  x85
080D0:  MOVLB  0
080D2:  CALL   2D30
....................     printf(lcd_putc, "S1:%04Lu\n\r",t_solda[contador_lcd]); 
080D6:  BCF    FD8.0
080D8:  MOVLB  5
080DA:  RLCF   x75,W
080DC:  CLRF   03
080DE:  ADDLW  AD
080E0:  MOVWF  FE9
080E2:  MOVLW  00
080E4:  ADDWFC 03,W
080E6:  MOVWF  FEA
080E8:  MOVFF  FEC,577
080EC:  MOVF   FED,F
080EE:  MOVFF  FEF,576
080F2:  MOVLW  6C
080F4:  MOVWF  FF6
080F6:  MOVLW  09
080F8:  MOVWF  FF7
080FA:  MOVLW  03
080FC:  MOVWF  x7C
080FE:  MOVLB  0
08100:  CALL   58FE
08104:  MOVLW  09
08106:  MOVWF  FE9
08108:  MOVFF  577,57D
0810C:  MOVFF  576,57C
08110:  CALL   7212
08114:  MOVLW  0A
08116:  MOVLB  5
08118:  MOVWF  x85
0811A:  MOVLB  0
0811C:  CALL   2D30
08120:  MOVLW  0D
08122:  MOVLB  5
08124:  MOVWF  x85
08126:  MOVLB  0
08128:  CALL   2D30
....................     printf(lcd_putc, "S2:%04Lu E:%04Lu\n\r",t_solda2[contador_lcd],t_wait[contador_lcd]); 
0812C:  BCF    FD8.0
0812E:  MOVLB  5
08130:  RLCF   x75,W
08132:  CLRF   03
08134:  ADDLW  81
08136:  MOVWF  FE9
08138:  MOVLW  01
0813A:  ADDWFC 03,W
0813C:  MOVWF  FEA
0813E:  MOVFF  FEC,577
08142:  MOVF   FED,F
08144:  MOVFF  FEF,576
08148:  BCF    FD8.0
0814A:  RLCF   x75,W
0814C:  CLRF   03
0814E:  ADDLW  D7
08150:  MOVWF  FE9
08152:  MOVLW  00
08154:  ADDWFC 03,W
08156:  MOVWF  FEA
08158:  MOVFF  FEC,579
0815C:  MOVF   FED,F
0815E:  MOVFF  FEF,578
08162:  MOVLW  78
08164:  MOVWF  FF6
08166:  MOVLW  09
08168:  MOVWF  FF7
0816A:  MOVLW  03
0816C:  MOVWF  x7C
0816E:  MOVLB  0
08170:  CALL   58FE
08174:  MOVLW  09
08176:  MOVWF  FE9
08178:  MOVFF  577,57D
0817C:  MOVFF  576,57C
08180:  CALL   7212
08184:  MOVLW  80
08186:  MOVWF  FF6
08188:  MOVLW  09
0818A:  MOVWF  FF7
0818C:  MOVLW  03
0818E:  MOVLB  5
08190:  MOVWF  x7C
08192:  MOVLB  0
08194:  CALL   58FE
08198:  MOVLW  09
0819A:  MOVWF  FE9
0819C:  MOVFF  579,57D
081A0:  MOVFF  578,57C
081A4:  CALL   7212
081A8:  MOVLW  0A
081AA:  MOVLB  5
081AC:  MOVWF  x85
081AE:  MOVLB  0
081B0:  CALL   2D30
081B4:  MOVLW  0D
081B6:  MOVLB  5
081B8:  MOVWF  x85
081BA:  MOVLB  0
081BC:  CALL   2D30
....................     printf(lcd_putc, "       I:%02u\n\r",incremento); 
081C0:  MOVLW  8C
081C2:  MOVWF  FF6
081C4:  MOVLW  09
081C6:  MOVWF  FF7
081C8:  MOVLW  09
081CA:  MOVLB  5
081CC:  MOVWF  x7C
081CE:  MOVLB  0
081D0:  CALL   58FE
081D4:  MOVFF  25,57C
081D8:  MOVLW  01
081DA:  MOVLB  5
081DC:  MOVWF  x7D
081DE:  MOVLB  0
081E0:  CALL   5954
081E4:  MOVLW  0A
081E6:  MOVLB  5
081E8:  MOVWF  x85
081EA:  MOVLB  0
081EC:  CALL   2D30
081F0:  MOVLW  0D
081F2:  MOVLB  5
081F4:  MOVWF  x85
081F6:  MOVLB  0
081F8:  CALL   2D30
....................     printf(lcd_putc, "F1:REC|F3:BACK\n\r"); 
081FC:  MOVLW  9C
081FE:  MOVWF  FF6
08200:  MOVLW  09
08202:  MOVWF  FF7
08204:  CALL   2D86
08208:  RETURN 0
.................... } 
.................... void tela_dados_ponto_5 (contador_lcd){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
07FC8:  MOVLW  0C
07FCA:  MOVLB  5
07FCC:  MOVWF  x85
07FCE:  MOVLB  0
07FD0:  CALL   2D30
....................     printf(lcd_putc, "\n\r"); 
07FD4:  MOVLW  0A
07FD6:  MOVLB  5
07FD8:  MOVWF  x85
07FDA:  MOVLB  0
07FDC:  CALL   2D30
07FE0:  MOVLW  0D
07FE2:  MOVLB  5
07FE4:  MOVWF  x85
07FE6:  MOVLB  0
07FE8:  CALL   2D30
....................     printf(lcd_putc, "S2:%04Lu E:%04Lu\n\r",t_solda2[contador_lcd],t_wait[contador_lcd]); 
07FEC:  BCF    FD8.0
07FEE:  MOVLB  5
07FF0:  RLCF   x75,W
07FF2:  CLRF   03
07FF4:  ADDLW  81
07FF6:  MOVWF  FE9
07FF8:  MOVLW  01
07FFA:  ADDWFC 03,W
07FFC:  MOVWF  FEA
07FFE:  MOVFF  FEC,577
08002:  MOVF   FED,F
08004:  MOVFF  FEF,576
08008:  BCF    FD8.0
0800A:  RLCF   x75,W
0800C:  CLRF   03
0800E:  ADDLW  D7
08010:  MOVWF  FE9
08012:  MOVLW  00
08014:  ADDWFC 03,W
08016:  MOVWF  FEA
08018:  MOVFF  FEC,579
0801C:  MOVF   FED,F
0801E:  MOVFF  FEF,578
08022:  MOVLW  AE
08024:  MOVWF  FF6
08026:  MOVLW  09
08028:  MOVWF  FF7
0802A:  MOVLW  03
0802C:  MOVWF  x7C
0802E:  MOVLB  0
08030:  CALL   58FE
08034:  MOVLW  09
08036:  MOVWF  FE9
08038:  MOVFF  577,57D
0803C:  MOVFF  576,57C
08040:  CALL   7212
08044:  MOVLW  B6
08046:  MOVWF  FF6
08048:  MOVLW  09
0804A:  MOVWF  FF7
0804C:  MOVLW  03
0804E:  MOVLB  5
08050:  MOVWF  x7C
08052:  MOVLB  0
08054:  CALL   58FE
08058:  MOVLW  09
0805A:  MOVWF  FE9
0805C:  MOVFF  579,57D
08060:  MOVFF  578,57C
08064:  CALL   7212
08068:  MOVLW  0A
0806A:  MOVLB  5
0806C:  MOVWF  x85
0806E:  MOVLB  0
08070:  CALL   2D30
08074:  MOVLW  0D
08076:  MOVLB  5
08078:  MOVWF  x85
0807A:  MOVLB  0
0807C:  CALL   2D30
....................     printf(lcd_putc, "       I:%02u\n\r",incremento); 
08080:  MOVLW  C2
08082:  MOVWF  FF6
08084:  MOVLW  09
08086:  MOVWF  FF7
08088:  MOVLW  09
0808A:  MOVLB  5
0808C:  MOVWF  x7C
0808E:  MOVLB  0
08090:  CALL   58FE
08094:  MOVFF  25,57C
08098:  MOVLW  01
0809A:  MOVLB  5
0809C:  MOVWF  x7D
0809E:  MOVLB  0
080A0:  CALL   5954
080A4:  MOVLW  0A
080A6:  MOVLB  5
080A8:  MOVWF  x85
080AA:  MOVLB  0
080AC:  CALL   2D30
080B0:  MOVLW  0D
080B2:  MOVLB  5
080B4:  MOVWF  x85
080B6:  MOVLB  0
080B8:  CALL   2D30
....................     printf(lcd_putc, "F1:REC|F3:BACK\n\r"); 
080BC:  MOVLW  D2
080BE:  MOVWF  FF6
080C0:  MOVLW  09
080C2:  MOVWF  FF7
080C4:  CALL   2D86
080C8:  RETURN 0
.................... } 
....................  
.................... void tela_faltaSolda(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0B29A:  MOVLW  0C
0B29C:  MOVLB  5
0B29E:  MOVWF  x85
0B2A0:  MOVLB  0
0B2A2:  CALL   2D30
....................     printf(lcd_putc, "      VERIFIQUE     \n\r"); 
0B2A6:  MOVLW  E4
0B2A8:  MOVWF  FF6
0B2AA:  MOVLW  09
0B2AC:  MOVWF  FF7
0B2AE:  CALL   2D86
....................     printf(lcd_putc, "  OS ALIMENTADORES  \n\r"); 
0B2B2:  MOVLW  FC
0B2B4:  MOVWF  FF6
0B2B6:  MOVLW  09
0B2B8:  MOVWF  FF7
0B2BA:  CALL   2D86
....................     printf(lcd_putc, "      DE SOLDA      \n\r"); 
0B2BE:  MOVLW  14
0B2C0:  MOVWF  FF6
0B2C2:  MOVLW  0A
0B2C4:  MOVWF  FF7
0B2C6:  CALL   2D86
....................     printf(lcd_putc, "      ENTER:OK      \n\r"); 
0B2CA:  MOVLW  2C
0B2CC:  MOVWF  FF6
0B2CE:  MOVLW  0A
0B2D0:  MOVWF  FF7
0B2D2:  CALL   2D86
0B2D6:  RETURN 0
.................... } 
....................  
.................... void tela_confirmaManutencao(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
07018:  MOVLW  0C
0701A:  MOVLB  5
0701C:  MOVWF  x85
0701E:  MOVLB  0
07020:  CALL   2D30
....................     printf(lcd_putc, "MANUTENCAO BANDEJA 2\n\r"); 
07024:  MOVLW  44
07026:  MOVWF  FF6
07028:  MOVLW  0A
0702A:  MOVWF  FF7
0702C:  CALL   2D86
....................     printf(lcd_putc, "   JA FINALIZADA ?  \n\r"); 
07030:  MOVLW  5C
07032:  MOVWF  FF6
07034:  MOVLW  0A
07036:  MOVWF  FF7
07038:  CALL   2D86
....................     printf(lcd_putc, "      ENTER:OK      \n\r"); 
0703C:  MOVLW  74
0703E:  MOVWF  FF6
07040:  MOVLW  0A
07042:  MOVWF  FF7
07044:  CALL   2D86
....................     printf(lcd_putc, "       ESC:NO       \n\r"); 
07048:  MOVLW  8C
0704A:  MOVWF  FF6
0704C:  MOVLW  0A
0704E:  MOVWF  FF7
07050:  CALL   2D86
07054:  GOTO   706A (RETURN)
.................... } 
....................  
.................... void tela_seleciona_manutencao(){ 
....................     printf(lcd_putc, "\f"); 
*
071A4:  MOVLW  0C
071A6:  MOVLB  5
071A8:  MOVWF  x85
071AA:  MOVLB  0
071AC:  CALL   2D30
....................     printf(lcd_putc, " F1: DEBUG ENTRADAS \n\r"); 
071B0:  MOVLW  A4
071B2:  MOVWF  FF6
071B4:  MOVLW  0A
071B6:  MOVWF  FF7
071B8:  CALL   2D86
....................     printf(lcd_putc, " F2:  DEBUG SAIDAS  \n\r"); 
071BC:  MOVLW  BC
071BE:  MOVWF  FF6
071C0:  MOVLW  0A
071C2:  MOVWF  FF7
071C4:  CALL   2D86
....................     printf(lcd_putc, "                    \n\r"); 
071C8:  MOVLW  D4
071CA:  MOVWF  FF6
071CC:  MOVLW  0A
071CE:  MOVWF  FF7
071D0:  CALL   2D86
....................     printf(lcd_putc, "      ESC:BACK      \n\r"); 
071D4:  MOVLW  EC
071D6:  MOVWF  FF6
071D8:  MOVLW  0A
071DA:  MOVWF  FF7
071DC:  CALL   2D86
071E0:  RETURN 0
.................... } 
.................... void tela_debug_entrada_1 (){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0B5C0:  MOVLW  0C
0B5C2:  MOVLB  5
0B5C4:  MOVWF  x85
0B5C6:  MOVLB  0
0B5C8:  CALL   2D30
....................     printf(lcd_putc, "E00:%02u E01:%02u E02:%02u\n\r", entradas[0], entradas[1], entradas[2]); 
0B5CC:  MOVLW  00
0B5CE:  BTFSC  1D.0
0B5D0:  MOVLW  01
0B5D2:  MOVLB  5
0B5D4:  MOVWF  x75
0B5D6:  MOVLW  00
0B5D8:  BTFSC  1D.1
0B5DA:  MOVLW  01
0B5DC:  MOVWF  x76
0B5DE:  MOVLW  00
0B5E0:  BTFSC  1D.2
0B5E2:  MOVLW  01
0B5E4:  MOVWF  x77
0B5E6:  MOVLW  04
0B5E8:  MOVWF  FF6
0B5EA:  MOVLW  0B
0B5EC:  MOVWF  FF7
0B5EE:  MOVLW  04
0B5F0:  MOVWF  x7C
0B5F2:  MOVLB  0
0B5F4:  CALL   58FE
0B5F8:  MOVFF  575,57C
0B5FC:  MOVLW  01
0B5FE:  MOVLB  5
0B600:  MOVWF  x7D
0B602:  MOVLB  0
0B604:  CALL   5954
0B608:  MOVLW  0C
0B60A:  MOVWF  FF6
0B60C:  MOVLW  0B
0B60E:  MOVWF  FF7
0B610:  MOVLW  05
0B612:  MOVLB  5
0B614:  MOVWF  x7C
0B616:  MOVLB  0
0B618:  CALL   58FE
0B61C:  MOVFF  576,57C
0B620:  MOVLW  01
0B622:  MOVLB  5
0B624:  MOVWF  x7D
0B626:  MOVLB  0
0B628:  CALL   5954
0B62C:  MOVLW  15
0B62E:  MOVWF  FF6
0B630:  MOVLW  0B
0B632:  MOVWF  FF7
0B634:  MOVLW  05
0B636:  MOVLB  5
0B638:  MOVWF  x7C
0B63A:  MOVLB  0
0B63C:  CALL   58FE
0B640:  MOVFF  577,57C
0B644:  MOVLW  01
0B646:  MOVLB  5
0B648:  MOVWF  x7D
0B64A:  MOVLB  0
0B64C:  CALL   5954
0B650:  MOVLW  0A
0B652:  MOVLB  5
0B654:  MOVWF  x85
0B656:  MOVLB  0
0B658:  CALL   2D30
0B65C:  MOVLW  0D
0B65E:  MOVLB  5
0B660:  MOVWF  x85
0B662:  MOVLB  0
0B664:  CALL   2D30
....................     printf(lcd_putc, "E03:%02u E04:%02u E05:%02u\n\r", entradas[3], entradas[4], entradas[5]); 
0B668:  MOVLW  00
0B66A:  BTFSC  1D.3
0B66C:  MOVLW  01
0B66E:  MOVLB  5
0B670:  MOVWF  x75
0B672:  MOVLW  00
0B674:  BTFSC  1D.4
0B676:  MOVLW  01
0B678:  MOVWF  x76
0B67A:  MOVLW  00
0B67C:  BTFSC  1D.5
0B67E:  MOVLW  01
0B680:  MOVWF  x77
0B682:  MOVLW  22
0B684:  MOVWF  FF6
0B686:  MOVLW  0B
0B688:  MOVWF  FF7
0B68A:  MOVLW  04
0B68C:  MOVWF  x7C
0B68E:  MOVLB  0
0B690:  CALL   58FE
0B694:  MOVFF  575,57C
0B698:  MOVLW  01
0B69A:  MOVLB  5
0B69C:  MOVWF  x7D
0B69E:  MOVLB  0
0B6A0:  CALL   5954
0B6A4:  MOVLW  2A
0B6A6:  MOVWF  FF6
0B6A8:  MOVLW  0B
0B6AA:  MOVWF  FF7
0B6AC:  MOVLW  05
0B6AE:  MOVLB  5
0B6B0:  MOVWF  x7C
0B6B2:  MOVLB  0
0B6B4:  CALL   58FE
0B6B8:  MOVFF  576,57C
0B6BC:  MOVLW  01
0B6BE:  MOVLB  5
0B6C0:  MOVWF  x7D
0B6C2:  MOVLB  0
0B6C4:  CALL   5954
0B6C8:  MOVLW  33
0B6CA:  MOVWF  FF6
0B6CC:  MOVLW  0B
0B6CE:  MOVWF  FF7
0B6D0:  MOVLW  05
0B6D2:  MOVLB  5
0B6D4:  MOVWF  x7C
0B6D6:  MOVLB  0
0B6D8:  CALL   58FE
0B6DC:  MOVFF  577,57C
0B6E0:  MOVLW  01
0B6E2:  MOVLB  5
0B6E4:  MOVWF  x7D
0B6E6:  MOVLB  0
0B6E8:  CALL   5954
0B6EC:  MOVLW  0A
0B6EE:  MOVLB  5
0B6F0:  MOVWF  x85
0B6F2:  MOVLB  0
0B6F4:  CALL   2D30
0B6F8:  MOVLW  0D
0B6FA:  MOVLB  5
0B6FC:  MOVWF  x85
0B6FE:  MOVLB  0
0B700:  CALL   2D30
....................     printf(lcd_putc, "E06:%02u E07:%02u E08:%02u\n\r", entradas[6], entradas[7], entradas[8]);     
0B704:  MOVLW  00
0B706:  BTFSC  1D.6
0B708:  MOVLW  01
0B70A:  MOVLB  5
0B70C:  MOVWF  x75
0B70E:  MOVLW  00
0B710:  BTFSC  1D.7
0B712:  MOVLW  01
0B714:  MOVWF  x76
0B716:  MOVLW  00
0B718:  BTFSC  1E.0
0B71A:  MOVLW  01
0B71C:  MOVWF  x77
0B71E:  MOVLW  40
0B720:  MOVWF  FF6
0B722:  MOVLW  0B
0B724:  MOVWF  FF7
0B726:  MOVLW  04
0B728:  MOVWF  x7C
0B72A:  MOVLB  0
0B72C:  CALL   58FE
0B730:  MOVFF  575,57C
0B734:  MOVLW  01
0B736:  MOVLB  5
0B738:  MOVWF  x7D
0B73A:  MOVLB  0
0B73C:  CALL   5954
0B740:  MOVLW  48
0B742:  MOVWF  FF6
0B744:  MOVLW  0B
0B746:  MOVWF  FF7
0B748:  MOVLW  05
0B74A:  MOVLB  5
0B74C:  MOVWF  x7C
0B74E:  MOVLB  0
0B750:  CALL   58FE
0B754:  MOVFF  576,57C
0B758:  MOVLW  01
0B75A:  MOVLB  5
0B75C:  MOVWF  x7D
0B75E:  MOVLB  0
0B760:  CALL   5954
0B764:  MOVLW  51
0B766:  MOVWF  FF6
0B768:  MOVLW  0B
0B76A:  MOVWF  FF7
0B76C:  MOVLW  05
0B76E:  MOVLB  5
0B770:  MOVWF  x7C
0B772:  MOVLB  0
0B774:  CALL   58FE
0B778:  MOVFF  577,57C
0B77C:  MOVLW  01
0B77E:  MOVLB  5
0B780:  MOVWF  x7D
0B782:  MOVLB  0
0B784:  CALL   5954
0B788:  MOVLW  0A
0B78A:  MOVLB  5
0B78C:  MOVWF  x85
0B78E:  MOVLB  0
0B790:  CALL   2D30
0B794:  MOVLW  0D
0B796:  MOVLB  5
0B798:  MOVWF  x85
0B79A:  MOVLB  0
0B79C:  CALL   2D30
....................     printf(lcd_putc, "   >:PROX|ESC:BACK  \n\r"); 
0B7A0:  MOVLW  5E
0B7A2:  MOVWF  FF6
0B7A4:  MOVLW  0B
0B7A6:  MOVWF  FF7
0B7A8:  CALL   2D86
0B7AC:  RETURN 0
.................... } 
.................... void tela_debug_entrada_2 (){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0B838:  MOVLW  0C
0B83A:  MOVLB  5
0B83C:  MOVWF  x85
0B83E:  MOVLB  0
0B840:  CALL   2D30
....................     printf(lcd_putc, "E09:%02u E10:%02u E11:%02u\n\r", entradas[9], entradas[10], entradas[11]); 
0B844:  MOVLW  00
0B846:  BTFSC  1E.1
0B848:  MOVLW  01
0B84A:  MOVLB  5
0B84C:  MOVWF  x75
0B84E:  MOVLW  00
0B850:  BTFSC  1E.2
0B852:  MOVLW  01
0B854:  MOVWF  x76
0B856:  MOVLW  00
0B858:  BTFSC  1E.3
0B85A:  MOVLW  01
0B85C:  MOVWF  x77
0B85E:  MOVLW  76
0B860:  MOVWF  FF6
0B862:  MOVLW  0B
0B864:  MOVWF  FF7
0B866:  MOVLW  04
0B868:  MOVWF  x7C
0B86A:  MOVLB  0
0B86C:  CALL   58FE
0B870:  MOVFF  575,57C
0B874:  MOVLW  01
0B876:  MOVLB  5
0B878:  MOVWF  x7D
0B87A:  MOVLB  0
0B87C:  CALL   5954
0B880:  MOVLW  7E
0B882:  MOVWF  FF6
0B884:  MOVLW  0B
0B886:  MOVWF  FF7
0B888:  MOVLW  05
0B88A:  MOVLB  5
0B88C:  MOVWF  x7C
0B88E:  MOVLB  0
0B890:  CALL   58FE
0B894:  MOVFF  576,57C
0B898:  MOVLW  01
0B89A:  MOVLB  5
0B89C:  MOVWF  x7D
0B89E:  MOVLB  0
0B8A0:  CALL   5954
0B8A4:  MOVLW  87
0B8A6:  MOVWF  FF6
0B8A8:  MOVLW  0B
0B8AA:  MOVWF  FF7
0B8AC:  MOVLW  05
0B8AE:  MOVLB  5
0B8B0:  MOVWF  x7C
0B8B2:  MOVLB  0
0B8B4:  CALL   58FE
0B8B8:  MOVFF  577,57C
0B8BC:  MOVLW  01
0B8BE:  MOVLB  5
0B8C0:  MOVWF  x7D
0B8C2:  MOVLB  0
0B8C4:  CALL   5954
0B8C8:  MOVLW  0A
0B8CA:  MOVLB  5
0B8CC:  MOVWF  x85
0B8CE:  MOVLB  0
0B8D0:  CALL   2D30
0B8D4:  MOVLW  0D
0B8D6:  MOVLB  5
0B8D8:  MOVWF  x85
0B8DA:  MOVLB  0
0B8DC:  CALL   2D30
....................     printf(lcd_putc, "E12:%02u E13:%02u E14:%02u\n\r", entradas[12], entradas[13], entradas[14]); 
0B8E0:  MOVLW  00
0B8E2:  BTFSC  1E.4
0B8E4:  MOVLW  01
0B8E6:  MOVLB  5
0B8E8:  MOVWF  x75
0B8EA:  MOVLW  00
0B8EC:  BTFSC  1E.5
0B8EE:  MOVLW  01
0B8F0:  MOVWF  x76
0B8F2:  MOVLW  00
0B8F4:  BTFSC  1E.6
0B8F6:  MOVLW  01
0B8F8:  MOVWF  x77
0B8FA:  MOVLW  94
0B8FC:  MOVWF  FF6
0B8FE:  MOVLW  0B
0B900:  MOVWF  FF7
0B902:  MOVLW  04
0B904:  MOVWF  x7C
0B906:  MOVLB  0
0B908:  CALL   58FE
0B90C:  MOVFF  575,57C
0B910:  MOVLW  01
0B912:  MOVLB  5
0B914:  MOVWF  x7D
0B916:  MOVLB  0
0B918:  CALL   5954
0B91C:  MOVLW  9C
0B91E:  MOVWF  FF6
0B920:  MOVLW  0B
0B922:  MOVWF  FF7
0B924:  MOVLW  05
0B926:  MOVLB  5
0B928:  MOVWF  x7C
0B92A:  MOVLB  0
0B92C:  CALL   58FE
0B930:  MOVFF  576,57C
0B934:  MOVLW  01
0B936:  MOVLB  5
0B938:  MOVWF  x7D
0B93A:  MOVLB  0
0B93C:  CALL   5954
0B940:  MOVLW  A5
0B942:  MOVWF  FF6
0B944:  MOVLW  0B
0B946:  MOVWF  FF7
0B948:  MOVLW  05
0B94A:  MOVLB  5
0B94C:  MOVWF  x7C
0B94E:  MOVLB  0
0B950:  CALL   58FE
0B954:  MOVFF  577,57C
0B958:  MOVLW  01
0B95A:  MOVLB  5
0B95C:  MOVWF  x7D
0B95E:  MOVLB  0
0B960:  CALL   5954
0B964:  MOVLW  0A
0B966:  MOVLB  5
0B968:  MOVWF  x85
0B96A:  MOVLB  0
0B96C:  CALL   2D30
0B970:  MOVLW  0D
0B972:  MOVLB  5
0B974:  MOVWF  x85
0B976:  MOVLB  0
0B978:  CALL   2D30
....................     printf(lcd_putc, "E15:%02u E16:%02u E17:%02u\n\r", entradas[15], entradas[16], entradas[17]);     
0B97C:  MOVLW  00
0B97E:  BTFSC  1E.7
0B980:  MOVLW  01
0B982:  MOVLB  5
0B984:  MOVWF  x75
0B986:  MOVLW  00
0B988:  BTFSC  1F.0
0B98A:  MOVLW  01
0B98C:  MOVWF  x76
0B98E:  MOVLW  00
0B990:  BTFSC  1F.1
0B992:  MOVLW  01
0B994:  MOVWF  x77
0B996:  MOVLW  B2
0B998:  MOVWF  FF6
0B99A:  MOVLW  0B
0B99C:  MOVWF  FF7
0B99E:  MOVLW  04
0B9A0:  MOVWF  x7C
0B9A2:  MOVLB  0
0B9A4:  CALL   58FE
0B9A8:  MOVFF  575,57C
0B9AC:  MOVLW  01
0B9AE:  MOVLB  5
0B9B0:  MOVWF  x7D
0B9B2:  MOVLB  0
0B9B4:  CALL   5954
0B9B8:  MOVLW  BA
0B9BA:  MOVWF  FF6
0B9BC:  MOVLW  0B
0B9BE:  MOVWF  FF7
0B9C0:  MOVLW  05
0B9C2:  MOVLB  5
0B9C4:  MOVWF  x7C
0B9C6:  MOVLB  0
0B9C8:  CALL   58FE
0B9CC:  MOVFF  576,57C
0B9D0:  MOVLW  01
0B9D2:  MOVLB  5
0B9D4:  MOVWF  x7D
0B9D6:  MOVLB  0
0B9D8:  CALL   5954
0B9DC:  MOVLW  C3
0B9DE:  MOVWF  FF6
0B9E0:  MOVLW  0B
0B9E2:  MOVWF  FF7
0B9E4:  MOVLW  05
0B9E6:  MOVLB  5
0B9E8:  MOVWF  x7C
0B9EA:  MOVLB  0
0B9EC:  CALL   58FE
0B9F0:  MOVFF  577,57C
0B9F4:  MOVLW  01
0B9F6:  MOVLB  5
0B9F8:  MOVWF  x7D
0B9FA:  MOVLB  0
0B9FC:  CALL   5954
0BA00:  MOVLW  0A
0BA02:  MOVLB  5
0BA04:  MOVWF  x85
0BA06:  MOVLB  0
0BA08:  CALL   2D30
0BA0C:  MOVLW  0D
0BA0E:  MOVLB  5
0BA10:  MOVWF  x85
0BA12:  MOVLB  0
0BA14:  CALL   2D30
....................     printf(lcd_putc, "  <|>:PROX|ESC:BACK \n\r"); 
0BA18:  MOVLW  D0
0BA1A:  MOVWF  FF6
0BA1C:  MOVLW  0B
0BA1E:  MOVWF  FF7
0BA20:  CALL   2D86
0BA24:  RETURN 0
.................... } 
.................... void tela_debug_entrada_3 (){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0BAA2:  MOVLW  0C
0BAA4:  MOVLB  5
0BAA6:  MOVWF  x85
0BAA8:  MOVLB  0
0BAAA:  CALL   2D30
....................     printf(lcd_putc, "E18:%02u E19:%02u E20:%02u\n\r", entradas[18], entradas[19], entradas[20]); 
0BAAE:  MOVLW  00
0BAB0:  BTFSC  1F.2
0BAB2:  MOVLW  01
0BAB4:  MOVLB  5
0BAB6:  MOVWF  x75
0BAB8:  MOVLW  00
0BABA:  BTFSC  1F.3
0BABC:  MOVLW  01
0BABE:  MOVWF  x76
0BAC0:  MOVLW  00
0BAC2:  BTFSC  1F.4
0BAC4:  MOVLW  01
0BAC6:  MOVWF  x77
0BAC8:  MOVLW  E8
0BACA:  MOVWF  FF6
0BACC:  MOVLW  0B
0BACE:  MOVWF  FF7
0BAD0:  MOVLW  04
0BAD2:  MOVWF  x7C
0BAD4:  MOVLB  0
0BAD6:  CALL   58FE
0BADA:  MOVFF  575,57C
0BADE:  MOVLW  01
0BAE0:  MOVLB  5
0BAE2:  MOVWF  x7D
0BAE4:  MOVLB  0
0BAE6:  CALL   5954
0BAEA:  MOVLW  F0
0BAEC:  MOVWF  FF6
0BAEE:  MOVLW  0B
0BAF0:  MOVWF  FF7
0BAF2:  MOVLW  05
0BAF4:  MOVLB  5
0BAF6:  MOVWF  x7C
0BAF8:  MOVLB  0
0BAFA:  CALL   58FE
0BAFE:  MOVFF  576,57C
0BB02:  MOVLW  01
0BB04:  MOVLB  5
0BB06:  MOVWF  x7D
0BB08:  MOVLB  0
0BB0A:  CALL   5954
0BB0E:  MOVLW  F9
0BB10:  MOVWF  FF6
0BB12:  MOVLW  0B
0BB14:  MOVWF  FF7
0BB16:  MOVLW  05
0BB18:  MOVLB  5
0BB1A:  MOVWF  x7C
0BB1C:  MOVLB  0
0BB1E:  CALL   58FE
0BB22:  MOVFF  577,57C
0BB26:  MOVLW  01
0BB28:  MOVLB  5
0BB2A:  MOVWF  x7D
0BB2C:  MOVLB  0
0BB2E:  CALL   5954
0BB32:  MOVLW  0A
0BB34:  MOVLB  5
0BB36:  MOVWF  x85
0BB38:  MOVLB  0
0BB3A:  CALL   2D30
0BB3E:  MOVLW  0D
0BB40:  MOVLB  5
0BB42:  MOVWF  x85
0BB44:  MOVLB  0
0BB46:  CALL   2D30
....................     printf(lcd_putc, "E21:%02u E22:%02u E23:%02u\n\r", entradas[21], entradas[22], entradas[23]); 
0BB4A:  MOVLW  00
0BB4C:  BTFSC  1F.5
0BB4E:  MOVLW  01
0BB50:  MOVLB  5
0BB52:  MOVWF  x75
0BB54:  MOVLW  00
0BB56:  BTFSC  1F.6
0BB58:  MOVLW  01
0BB5A:  MOVWF  x76
0BB5C:  MOVLW  00
0BB5E:  BTFSC  1F.7
0BB60:  MOVLW  01
0BB62:  MOVWF  x77
0BB64:  MOVLW  06
0BB66:  MOVWF  FF6
0BB68:  MOVLW  0C
0BB6A:  MOVWF  FF7
0BB6C:  MOVLW  04
0BB6E:  MOVWF  x7C
0BB70:  MOVLB  0
0BB72:  CALL   58FE
0BB76:  MOVFF  575,57C
0BB7A:  MOVLW  01
0BB7C:  MOVLB  5
0BB7E:  MOVWF  x7D
0BB80:  MOVLB  0
0BB82:  CALL   5954
0BB86:  MOVLW  0E
0BB88:  MOVWF  FF6
0BB8A:  MOVLW  0C
0BB8C:  MOVWF  FF7
0BB8E:  MOVLW  05
0BB90:  MOVLB  5
0BB92:  MOVWF  x7C
0BB94:  MOVLB  0
0BB96:  CALL   58FE
0BB9A:  MOVFF  576,57C
0BB9E:  MOVLW  01
0BBA0:  MOVLB  5
0BBA2:  MOVWF  x7D
0BBA4:  MOVLB  0
0BBA6:  CALL   5954
0BBAA:  MOVLW  17
0BBAC:  MOVWF  FF6
0BBAE:  MOVLW  0C
0BBB0:  MOVWF  FF7
0BBB2:  MOVLW  05
0BBB4:  MOVLB  5
0BBB6:  MOVWF  x7C
0BBB8:  MOVLB  0
0BBBA:  CALL   58FE
0BBBE:  MOVFF  577,57C
0BBC2:  MOVLW  01
0BBC4:  MOVLB  5
0BBC6:  MOVWF  x7D
0BBC8:  MOVLB  0
0BBCA:  CALL   5954
0BBCE:  MOVLW  0A
0BBD0:  MOVLB  5
0BBD2:  MOVWF  x85
0BBD4:  MOVLB  0
0BBD6:  CALL   2D30
0BBDA:  MOVLW  0D
0BBDC:  MOVLB  5
0BBDE:  MOVWF  x85
0BBE0:  MOVLB  0
0BBE2:  CALL   2D30
....................     printf(lcd_putc, "E24:%02u E25:%02u E26:%02u\n\r", entradas[24], entradas[25], entradas[26]); 
0BBE6:  MOVLW  00
0BBE8:  BTFSC  20.0
0BBEA:  MOVLW  01
0BBEC:  MOVLB  5
0BBEE:  MOVWF  x75
0BBF0:  MOVLW  00
0BBF2:  BTFSC  20.1
0BBF4:  MOVLW  01
0BBF6:  MOVWF  x76
0BBF8:  MOVLW  00
0BBFA:  BTFSC  20.2
0BBFC:  MOVLW  01
0BBFE:  MOVWF  x77
0BC00:  MOVLW  24
0BC02:  MOVWF  FF6
0BC04:  MOVLW  0C
0BC06:  MOVWF  FF7
0BC08:  MOVLW  04
0BC0A:  MOVWF  x7C
0BC0C:  MOVLB  0
0BC0E:  CALL   58FE
0BC12:  MOVFF  575,57C
0BC16:  MOVLW  01
0BC18:  MOVLB  5
0BC1A:  MOVWF  x7D
0BC1C:  MOVLB  0
0BC1E:  CALL   5954
0BC22:  MOVLW  2C
0BC24:  MOVWF  FF6
0BC26:  MOVLW  0C
0BC28:  MOVWF  FF7
0BC2A:  MOVLW  05
0BC2C:  MOVLB  5
0BC2E:  MOVWF  x7C
0BC30:  MOVLB  0
0BC32:  CALL   58FE
0BC36:  MOVFF  576,57C
0BC3A:  MOVLW  01
0BC3C:  MOVLB  5
0BC3E:  MOVWF  x7D
0BC40:  MOVLB  0
0BC42:  CALL   5954
0BC46:  MOVLW  35
0BC48:  MOVWF  FF6
0BC4A:  MOVLW  0C
0BC4C:  MOVWF  FF7
0BC4E:  MOVLW  05
0BC50:  MOVLB  5
0BC52:  MOVWF  x7C
0BC54:  MOVLB  0
0BC56:  CALL   58FE
0BC5A:  MOVFF  577,57C
0BC5E:  MOVLW  01
0BC60:  MOVLB  5
0BC62:  MOVWF  x7D
0BC64:  MOVLB  0
0BC66:  CALL   5954
0BC6A:  MOVLW  0A
0BC6C:  MOVLB  5
0BC6E:  MOVWF  x85
0BC70:  MOVLB  0
0BC72:  CALL   2D30
0BC76:  MOVLW  0D
0BC78:  MOVLB  5
0BC7A:  MOVWF  x85
0BC7C:  MOVLB  0
0BC7E:  CALL   2D30
....................     printf(lcd_putc, "E27:%02u <:ANT|ESC:BACK\n\r", entradas[27]); 
0BC82:  MOVLW  00
0BC84:  BTFSC  20.3
0BC86:  MOVLW  01
0BC88:  MOVLB  5
0BC8A:  MOVWF  x75
0BC8C:  MOVLW  42
0BC8E:  MOVWF  FF6
0BC90:  MOVLW  0C
0BC92:  MOVWF  FF7
0BC94:  MOVLW  04
0BC96:  MOVWF  x7C
0BC98:  MOVLB  0
0BC9A:  CALL   58FE
0BC9E:  MOVFF  575,57C
0BCA2:  MOVLW  01
0BCA4:  MOVLB  5
0BCA6:  MOVWF  x7D
0BCA8:  MOVLB  0
0BCAA:  CALL   5954
0BCAE:  MOVLW  4A
0BCB0:  MOVWF  FF6
0BCB2:  MOVLW  0C
0BCB4:  MOVWF  FF7
0BCB6:  MOVLW  11
0BCB8:  MOVLB  5
0BCBA:  MOVWF  x7C
0BCBC:  MOVLB  0
0BCBE:  CALL   58FE
0BCC2:  RETURN 0
.................... } 
.................... void tela_debug_saida_1 (){ 
....................     printf(lcd_putc, "\f"); 
*
0B7AE:  MOVLW  0C
0B7B0:  MOVLB  5
0B7B2:  MOVWF  x85
0B7B4:  MOVLB  0
0B7B6:  CALL   2D30
....................     printf(lcd_putc, "ESTEIRA             \n\r"); 
0B7BA:  MOVLW  5C
0B7BC:  MOVWF  FF6
0B7BE:  MOVLW  0C
0B7C0:  MOVWF  FF7
0B7C2:  CALL   2D86
....................     printf(lcd_putc, "DEDOS ENTRADA       \n\r"); 
0B7C6:  MOVLW  74
0B7C8:  MOVWF  FF6
0B7CA:  MOVLW  0C
0B7CC:  MOVWF  FF7
0B7CE:  CALL   2D86
....................     printf(lcd_putc, "ALIMENTADOR_PLACA   \n\r"); 
0B7D2:  MOVLW  8C
0B7D4:  MOVWF  FF6
0B7D6:  MOVLW  0C
0B7D8:  MOVWF  FF7
0B7DA:  CALL   2D86
....................     printf(lcd_putc, "F1:ON|F2:OF|ESC:BACK\n\r"); 
0B7DE:  MOVLW  A4
0B7E0:  MOVWF  FF6
0B7E2:  MOVLW  0C
0B7E4:  MOVWF  FF7
0B7E6:  CALL   2D86
....................     posiciona_cursor(ponteiro_lcd,19); 
0B7EA:  MOVFF  21,586
0B7EE:  MOVLW  13
0B7F0:  MOVLB  5
0B7F2:  MOVWF  x87
0B7F4:  MOVLB  0
0B7F6:  CALL   2B82
....................     printf(lcd_putc,"<"); 
0B7FA:  MOVLW  3C
0B7FC:  MOVLB  5
0B7FE:  MOVWF  x85
0B800:  MOVLB  0
0B802:  CALL   2D30
0B806:  RETURN 0
.................... } 
.................... void tela_debug_saida_2 (){ 
....................     printf(lcd_putc, "\f"); 
*
0BDCC:  MOVLW  0C
0BDCE:  MOVLB  5
0BDD0:  MOVWF  x85
0BDD2:  MOVLB  0
0BDD4:  CALL   2D30
....................     printf(lcd_putc, "PRESSOR             \n\r"); 
0BDD8:  MOVLW  BC
0BDDA:  MOVWF  FF6
0BDDC:  MOVLW  0C
0BDDE:  MOVWF  FF7
0BDE0:  CALL   2D86
....................     printf(lcd_putc, "DEDOS_SAIDA         \n\r"); 
0BDE4:  MOVLW  D4
0BDE6:  MOVWF  FF6
0BDE8:  MOVLW  0C
0BDEA:  MOVWF  FF7
0BDEC:  CALL   2D86
....................     printf(lcd_putc, "DISPENSADOR_PLACA   \n\r"); 
0BDF0:  MOVLW  EC
0BDF2:  MOVWF  FF6
0BDF4:  MOVLW  0C
0BDF6:  MOVWF  FF7
0BDF8:  CALL   2D86
....................     printf(lcd_putc, "F1:ON|F2:OF|ESC:BACK\n\r"); 
0BDFC:  MOVLW  04
0BDFE:  MOVWF  FF6
0BE00:  MOVLW  0D
0BE02:  MOVWF  FF7
0BE04:  CALL   2D86
....................     posiciona_cursor(ponteiro_lcd,19); 
0BE08:  MOVFF  21,586
0BE0C:  MOVLW  13
0BE0E:  MOVLB  5
0BE10:  MOVWF  x87
0BE12:  MOVLB  0
0BE14:  CALL   2B82
....................     printf(lcd_putc,"<"); 
0BE18:  MOVLW  3C
0BE1A:  MOVLB  5
0BE1C:  MOVWF  x85
0BE1E:  MOVLB  0
0BE20:  CALL   2D30
0BE24:  RETURN 0
.................... } 
.................... void tela_debug_saida_3 (){ 
....................     printf(lcd_putc, "\f"); 
*
0C076:  MOVLW  0C
0C078:  MOVLB  5
0C07A:  MOVWF  x85
0C07C:  MOVLB  0
0C07E:  CALL   2D30
....................     printf(lcd_putc, "ALIMENTADOR_SOLDA   \n\r"); 
0C082:  MOVLW  1C
0C084:  MOVWF  FF6
0C086:  MOVLW  0D
0C088:  MOVWF  FF7
0C08A:  CALL   2D86
....................     printf(lcd_putc, "LIMPADOR_BICO       \n\r"); 
0C08E:  MOVLW  34
0C090:  MOVWF  FF6
0C092:  MOVLW  0D
0C094:  MOVWF  FF7
0C096:  CALL   2D86
....................     printf(lcd_putc, "FERROS_DE_SOLDA     \n\r"); 
0C09A:  MOVLW  4C
0C09C:  MOVWF  FF6
0C09E:  MOVLW  0D
0C0A0:  MOVWF  FF7
0C0A2:  CALL   2D86
....................     printf(lcd_putc, "F1:ON|F2:OF|ESC:BACK\n\r"); 
0C0A6:  MOVLW  64
0C0A8:  MOVWF  FF6
0C0AA:  MOVLW  0D
0C0AC:  MOVWF  FF7
0C0AE:  CALL   2D86
....................     posiciona_cursor(ponteiro_lcd,19); 
0C0B2:  MOVFF  21,586
0C0B6:  MOVLW  13
0C0B8:  MOVLB  5
0C0BA:  MOVWF  x87
0C0BC:  MOVLB  0
0C0BE:  CALL   2B82
....................     printf(lcd_putc,"<"); 
0C0C2:  MOVLW  3C
0C0C4:  MOVLB  5
0C0C6:  MOVWF  x85
0C0C8:  MOVLB  0
0C0CA:  CALL   2D30
0C0CE:  RETURN 0
.................... } 
.................... void tela_debug_saida_4(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0C236:  MOVLW  0C
0C238:  MOVLB  5
0C23A:  MOVWF  x85
0C23C:  MOVLB  0
0C23E:  CALL   2D30
....................     printf(lcd_putc, "   X:%04Lu  Y:%04Lu  \n\r",motor_pos_x,motor_pos_y); 
0C242:  MOVLW  7C
0C244:  MOVWF  FF6
0C246:  MOVLW  0D
0C248:  MOVWF  FF7
0C24A:  MOVLW  05
0C24C:  MOVLB  5
0C24E:  MOVWF  x7C
0C250:  MOVLB  0
0C252:  CALL   58FE
0C256:  MOVLW  09
0C258:  MOVWF  FE9
0C25A:  MOVFF  204,57D
0C25E:  MOVFF  203,57C
0C262:  CALL   7212
0C266:  MOVLW  86
0C268:  MOVWF  FF6
0C26A:  MOVLW  0D
0C26C:  MOVWF  FF7
0C26E:  MOVLW  04
0C270:  MOVLB  5
0C272:  MOVWF  x7C
0C274:  MOVLB  0
0C276:  CALL   58FE
0C27A:  MOVLW  09
0C27C:  MOVWF  FE9
0C27E:  MOVFF  206,57D
0C282:  MOVFF  205,57C
0C286:  CALL   7212
0C28A:  MOVLW  8F
0C28C:  MOVWF  FF6
0C28E:  MOVLW  0D
0C290:  MOVWF  FF7
0C292:  MOVLW  04
0C294:  MOVLB  5
0C296:  MOVWF  x7C
0C298:  MOVLB  0
0C29A:  CALL   58FE
....................     printf(lcd_putc, "   Z:%04Lu  F:%04Lu  \n\r",motor_pos_z,motor_pos_flip); 
0C29E:  MOVLW  94
0C2A0:  MOVWF  FF6
0C2A2:  MOVLW  0D
0C2A4:  MOVWF  FF7
0C2A6:  MOVLW  05
0C2A8:  MOVLB  5
0C2AA:  MOVWF  x7C
0C2AC:  MOVLB  0
0C2AE:  CALL   58FE
0C2B2:  MOVLW  09
0C2B4:  MOVWF  FE9
0C2B6:  MOVFF  20A,57D
0C2BA:  MOVFF  209,57C
0C2BE:  CALL   7212
0C2C2:  MOVLW  9E
0C2C4:  MOVWF  FF6
0C2C6:  MOVLW  0D
0C2C8:  MOVWF  FF7
0C2CA:  MOVLW  04
0C2CC:  MOVLB  5
0C2CE:  MOVWF  x7C
0C2D0:  MOVLB  0
0C2D2:  CALL   58FE
0C2D6:  MOVLW  09
0C2D8:  MOVWF  FE9
0C2DA:  MOVFF  208,57D
0C2DE:  MOVFF  207,57C
0C2E2:  CALL   7212
0C2E6:  MOVLW  A7
0C2E8:  MOVWF  FF6
0C2EA:  MOVLW  0D
0C2EC:  MOVWF  FF7
0C2EE:  MOVLW  04
0C2F0:  MOVLB  5
0C2F2:  MOVWF  x7C
0C2F4:  MOVLB  0
0C2F6:  CALL   58FE
....................     printf(lcd_putc, "       INC:%2u     \n\r",incremento); 
0C2FA:  MOVLW  AC
0C2FC:  MOVWF  FF6
0C2FE:  MOVLW  0D
0C300:  MOVWF  FF7
0C302:  MOVLW  0B
0C304:  MOVLB  5
0C306:  MOVWF  x7C
0C308:  MOVLB  0
0C30A:  CALL   58FE
0C30E:  MOVFF  25,57C
0C312:  MOVLW  11
0C314:  MOVLB  5
0C316:  MOVWF  x7D
0C318:  MOVLB  0
0C31A:  CALL   5954
0C31E:  MOVLW  BA
0C320:  MOVWF  FF6
0C322:  MOVLW  0D
0C324:  MOVWF  FF7
0C326:  MOVLW  07
0C328:  MOVLB  5
0C32A:  MOVWF  x7C
0C32C:  MOVLB  0
0C32E:  CALL   58FE
....................     printf(lcd_putc, "       ESC:BACK      \n\r"); 
0C332:  MOVLW  C2
0C334:  MOVWF  FF6
0C336:  MOVLW  0D
0C338:  MOVWF  FF7
0C33A:  CALL   2D86
0C33E:  RETURN 0
.................... } 
....................  
.................... void tela_programa_principal(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
06286:  MOVLW  0C
06288:  MOVLB  5
0628A:  MOVWF  x85
0628C:  MOVLB  0
0628E:  CALL   2D30
....................     printf(lcd_putc, " EXECUTANDO PROGRAMA\n\r"); 
06292:  MOVLW  DA
06294:  MOVWF  FF6
06296:  MOVLW  0D
06298:  MOVWF  FF7
0629A:  CALL   2D86
....................     printf(lcd_putc, "     MODELO:%02u    \n\r",modelo); 
0629E:  MOVLW  F2
062A0:  MOVWF  FF6
062A2:  MOVLW  0D
062A4:  MOVWF  FF7
062A6:  MOVLW  0C
062A8:  MOVLB  5
062AA:  MOVWF  x7C
062AC:  MOVLB  0
062AE:  CALL   58FE
062B2:  MOVFF  2E,57C
062B6:  MOVLW  01
062B8:  MOVLB  5
062BA:  MOVWF  x7D
062BC:  MOVLB  0
062BE:  CALL   5954
062C2:  MOVLW  02
062C4:  MOVWF  FF6
062C6:  MOVLW  0E
062C8:  MOVWF  FF7
062CA:  MOVLW  06
062CC:  MOVLB  5
062CE:  MOVWF  x7C
062D0:  MOVLB  0
062D2:  CALL   58FE
....................     printf(lcd_putc, "                    \n\r"); 
062D6:  MOVLW  0A
062D8:  MOVWF  FF6
062DA:  MOVLW  0E
062DC:  MOVWF  FF7
062DE:  CALL   2D86
....................     printf(lcd_putc, "      ESC:STOP      \n\r"); 
062E2:  MOVLW  22
062E4:  MOVWF  FF6
062E6:  MOVLW  0E
062E8:  MOVWF  FF7
062EA:  CALL   2D86
062EE:  GOTO   6380 (RETURN)
.................... } 
....................  
.................... #include "Axis_x.c" 
.................... // <editor-fold defaultstate="collapsed" desc="Valores que devem ser inseridos"> 
.................... float stepbyrev_x = 200; //pulso por volta (datasheet) 
.................... float driver_u_step_x = 1; //divisao entre chave/pulso por volta 
.................... float Leadscrew_x = 9; //tipo de redutor 
.................... float Leadscrew_Pich_x = 150; //comprimento da polia (datasheet) 
.................... float Vmax_x = 600;//esse valor deve ser em mm por segundo 600 
.................... float Vmin_x = 200; //200 
.................... float Amax_x = 450; //esse valor deve ser em mm por segundo 500 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Valores calculo rampa"> 
.................... float MMbyStep_x = 0; 
.................... int8 StepinAcc_x = 20; 
.................... float Fmax_x = 0; 
.................... float Fmin_x = 100; 
.................... int32 Ts_x[20]; 
.................... int32 StepbyF_x[20]; 
.................... int16 total_acc_step_x = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Flags e Controles de Movimento"> 
.................... signed int8 pos_inc_x = 0; 
.................... int8 ramp_sts_x = ramp_idle; 
.................... short run_flg_x = FALSE; 
.................... short rest_x = FALSE; 
.................... int16 step_no_x = 0; 
.................... int16 step_down_x = 0; 
.................... int16 move_x = 0; 
.................... int16 midpt_x = 0; 
.................... int32 step_acumulado_x = 0; 
.................... int atual_frequencia_x = 0; 
.................... int vel_x = 19; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Pinos Motor"> 
.................... #DEFINE     i_limite_x            5 
.................... #DEFINE     s_limite_x            6 
.................... // </editor-fold>    
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Inicializa Motor"> 
.................... void init_axis_x(){ 
....................     set_tris_d(0xf8); 
*
034FC:  MOVLW  F8
034FE:  MOVWF  F95
....................     output_high(step_x); 
03500:  BCF    F95.2
03502:  BSF    F8C.2
....................     output_high(enable_x); 
03504:  BCF    F95.0
03506:  BSF    F8C.0
....................     output_high(dir_x); 
03508:  BCF    F95.1
0350A:  BSF    F8C.1
....................      
....................     MMbyStep_x = Leadscrew_Pich_x/(stepbyrev_x*driver_u_step_x*Leadscrew_x); 
0350C:  MOVFF  212,592
03510:  MOVFF  211,591
03514:  MOVFF  210,590
03518:  MOVFF  20F,58F
0351C:  MOVFF  216,596
03520:  MOVFF  215,595
03524:  MOVFF  214,594
03528:  MOVFF  213,593
0352C:  RCALL  2F24
0352E:  MOVFF  03,584
03532:  MOVFF  02,583
03536:  MOVFF  01,582
0353A:  MOVFF  00,581
0353E:  MOVFF  03,592
03542:  MOVFF  02,591
03546:  MOVFF  01,590
0354A:  MOVFF  00,58F
0354E:  MOVFF  21A,596
03552:  MOVFF  219,595
03556:  MOVFF  218,594
0355A:  MOVFF  217,593
0355E:  RCALL  2F24
03560:  MOVFF  21E,598
03564:  MOVFF  21D,597
03568:  MOVFF  21C,596
0356C:  MOVFF  21B,595
03570:  MOVFF  03,59C
03574:  MOVFF  02,59B
03578:  MOVFF  01,59A
0357C:  MOVFF  00,599
03580:  RCALL  301A
03582:  MOVFF  03,22E
03586:  MOVFF  02,22D
0358A:  MOVFF  01,22C
0358E:  MOVFF  00,22B
....................     Fmax_x = Vmax_x/MMbyStep_x; //Valor de ferequencia adiquirido em hz 
03592:  MOVFF  222,598
03596:  MOVFF  221,597
0359A:  MOVFF  220,596
0359E:  MOVFF  21F,595
035A2:  MOVFF  22E,59C
035A6:  MOVFF  22D,59B
035AA:  MOVFF  22C,59A
035AE:  MOVFF  22B,599
035B2:  RCALL  301A
035B4:  MOVFF  03,233
035B8:  MOVFF  02,232
035BC:  MOVFF  01,231
035C0:  MOVFF  00,230
....................     //Fmin_x = Vmin_x/MMbyStep_x; 
....................      
....................     float den = Amax_x*StepinAcc_x; 
....................     float num = (Vmax_x - Vmin_x)*1000000; 
....................     float TbyF = num/den;//tempo em us 
....................      
....................     int i = 0; 
035C4:  MOVLB  5
035C6:  CLRF   x90
035C8:  MOVFF  22F,58F
035CC:  MOVLB  0
035CE:  RCALL  3178
035D0:  MOVFF  22A,592
035D4:  MOVFF  229,591
035D8:  MOVFF  228,590
035DC:  MOVFF  227,58F
035E0:  MOVFF  03,596
035E4:  MOVFF  02,595
035E8:  MOVFF  01,594
035EC:  MOVFF  00,593
035F0:  RCALL  2F24
035F2:  MOVFF  03,577
035F6:  MOVFF  02,576
035FA:  MOVFF  01,575
035FE:  MOVFF  00,574
03602:  BSF    FD8.1
03604:  MOVFF  222,598
03608:  MOVFF  221,597
0360C:  MOVFF  220,596
03610:  MOVFF  21F,595
03614:  MOVFF  226,59C
03618:  MOVFF  225,59B
0361C:  MOVFF  224,59A
03620:  MOVFF  223,599
03624:  RCALL  31AE
03626:  MOVFF  03,584
0362A:  MOVFF  02,583
0362E:  MOVFF  01,582
03632:  MOVFF  00,581
03636:  MOVFF  03,592
0363A:  MOVFF  02,591
0363E:  MOVFF  01,590
03642:  MOVFF  00,58F
03646:  MOVLB  5
03648:  CLRF   x96
0364A:  MOVLW  24
0364C:  MOVWF  x95
0364E:  MOVLW  74
03650:  MOVWF  x94
03652:  MOVLW  92
03654:  MOVWF  x93
03656:  MOVLB  0
03658:  RCALL  2F24
0365A:  MOVFF  03,57B
0365E:  MOVFF  02,57A
03662:  MOVFF  01,579
03666:  MOVFF  00,578
0366A:  MOVFF  57B,598
0366E:  MOVFF  57A,597
03672:  MOVFF  579,596
03676:  MOVFF  578,595
0367A:  MOVFF  577,59C
0367E:  MOVFF  576,59B
03682:  MOVFF  575,59A
03686:  MOVFF  574,599
0368A:  RCALL  301A
0368C:  MOVFF  03,57F
03690:  MOVFF  02,57E
03694:  MOVFF  01,57D
03698:  MOVFF  00,57C
0369C:  MOVLB  5
0369E:  CLRF   x80
....................     for(i = 1; i <=StepinAcc_x;i++) 
036A0:  MOVLW  01
036A2:  MOVWF  x80
036A4:  MOVF   x80,W
036A6:  MOVLB  2
036A8:  SUBWF  x2F,W
036AA:  BTFSS  FD8.0
036AC:  BRA    39D0
....................     { 
....................         Ts_x[i-1]=(1000000*StepinAcc_x)/(i*(Fmax_x-Fmin_x)+Fmin_x); 
036AE:  MOVLW  01
036B0:  MOVLB  5
036B2:  SUBWF  x80,W
036B4:  MULLW  04
036B6:  MOVF   FF3,W
036B8:  CLRF   03
036BA:  ADDLW  38
036BC:  MOVWF  FE9
036BE:  MOVLW  02
036C0:  ADDWFC 03,W
036C2:  MOVWF  FEA
036C4:  MOVFF  FEA,584
036C8:  MOVFF  FE9,583
036CC:  CLRF   x88
036CE:  MOVLW  0F
036D0:  MOVWF  x87
036D2:  MOVLW  42
036D4:  MOVWF  x86
036D6:  MOVLW  40
036D8:  MOVWF  x85
036DA:  CLRF   x8C
036DC:  CLRF   x8B
036DE:  CLRF   x8A
036E0:  MOVFF  22F,589
036E4:  MOVLB  0
036E6:  RCALL  3426
036E8:  MOVFF  584,FEA
036EC:  MOVFF  583,FE9
036F0:  MOVFF  03,588
036F4:  MOVFF  02,587
036F8:  MOVFF  01,586
036FC:  MOVFF  00,585
03700:  MOVFF  FEA,58A
03704:  MOVFF  FE9,589
03708:  BSF    FD8.1
0370A:  MOVFF  233,598
0370E:  MOVFF  232,597
03712:  MOVFF  231,596
03716:  MOVFF  230,595
0371A:  MOVFF  237,59C
0371E:  MOVFF  236,59B
03722:  MOVFF  235,59A
03726:  MOVFF  234,599
0372A:  RCALL  31AE
0372C:  MOVFF  58A,FEA
03730:  MOVFF  589,FE9
03734:  MOVFF  03,58E
03738:  MOVFF  02,58D
0373C:  MOVFF  01,58C
03740:  MOVFF  00,58B
03744:  MOVLB  5
03746:  CLRF   x90
03748:  MOVFF  580,58F
0374C:  MOVLB  0
0374E:  RCALL  3178
03750:  MOVFF  03,592
03754:  MOVFF  02,591
03758:  MOVFF  01,590
0375C:  MOVFF  00,58F
03760:  MOVFF  58E,596
03764:  MOVFF  58D,595
03768:  MOVFF  58C,594
0376C:  MOVFF  58B,593
03770:  CALL   2F24
03774:  MOVFF  03,592
03778:  MOVFF  02,591
0377C:  MOVFF  01,590
03780:  MOVFF  00,58F
03784:  MOVFF  FEA,594
03788:  MOVFF  FE9,593
0378C:  BCF    FD8.1
0378E:  MOVFF  03,598
03792:  MOVFF  02,597
03796:  MOVFF  01,596
0379A:  MOVFF  00,595
0379E:  MOVFF  237,59C
037A2:  MOVFF  236,59B
037A6:  MOVFF  235,59A
037AA:  MOVFF  234,599
037AE:  RCALL  31AE
037B0:  MOVFF  594,FEA
037B4:  MOVFF  593,FE9
037B8:  MOVFF  03,592
037BC:  MOVFF  02,591
037C0:  MOVFF  01,590
037C4:  MOVFF  00,58F
037C8:  MOVFF  588,598
037CC:  MOVFF  587,597
037D0:  MOVFF  586,596
037D4:  MOVFF  585,595
037D8:  RCALL  3482
037DA:  MOVFF  03,598
037DE:  MOVFF  02,597
037E2:  MOVFF  01,596
037E6:  MOVFF  00,595
037EA:  MOVFF  592,59C
037EE:  MOVFF  591,59B
037F2:  MOVFF  590,59A
037F6:  MOVFF  58F,599
037FA:  RCALL  301A
037FC:  MOVFF  03,598
03800:  MOVFF  02,597
03804:  MOVFF  01,596
03808:  MOVFF  00,595
0380C:  RCALL  34BA
0380E:  MOVFF  00,FEF
03812:  MOVFF  01,FEC
03816:  MOVFF  02,FEC
0381A:  MOVFF  03,FEC
....................         StepbyF_x[i-1] = 2*TbyF/Ts_x[i-1]; 
0381E:  MOVLW  01
03820:  MOVLB  5
03822:  SUBWF  x80,W
03824:  MULLW  04
03826:  MOVF   FF3,W
03828:  CLRF   03
0382A:  ADDLW  88
0382C:  MOVWF  01
0382E:  MOVLW  02
03830:  ADDWFC 03,F
03832:  MOVFF  01,581
03836:  MOVFF  03,582
0383A:  CLRF   x92
0383C:  CLRF   x91
0383E:  CLRF   x90
03840:  MOVLW  80
03842:  MOVWF  x8F
03844:  MOVFF  57F,596
03848:  MOVFF  57E,595
0384C:  MOVFF  57D,594
03850:  MOVFF  57C,593
03854:  MOVLB  0
03856:  CALL   2F24
0385A:  MOVFF  03,586
0385E:  MOVFF  02,585
03862:  MOVFF  01,584
03866:  MOVFF  00,583
0386A:  MOVLW  01
0386C:  MOVLB  5
0386E:  SUBWF  x80,W
03870:  MULLW  04
03872:  MOVF   FF3,W
03874:  CLRF   03
03876:  ADDLW  38
03878:  MOVWF  FE9
0387A:  MOVLW  02
0387C:  ADDWFC 03,W
0387E:  MOVWF  FEA
03880:  MOVFF  FEF,00
03884:  MOVFF  FEC,01
03888:  MOVFF  FEC,02
0388C:  MOVFF  FEC,03
03890:  MOVFF  03,598
03894:  MOVFF  02,597
03898:  MOVFF  01,596
0389C:  MOVFF  00,595
038A0:  MOVLB  0
038A2:  RCALL  3482
038A4:  MOVFF  586,598
038A8:  MOVFF  585,597
038AC:  MOVFF  584,596
038B0:  MOVFF  583,595
038B4:  MOVFF  03,59C
038B8:  MOVFF  02,59B
038BC:  MOVFF  01,59A
038C0:  MOVFF  00,599
038C4:  CALL   301A
038C8:  MOVFF  03,598
038CC:  MOVFF  02,597
038D0:  MOVFF  01,596
038D4:  MOVFF  00,595
038D8:  RCALL  34BA
038DA:  MOVFF  582,FEA
038DE:  MOVFF  581,FE9
038E2:  MOVFF  00,FEF
038E6:  MOVFF  01,FEC
038EA:  MOVFF  02,FEC
038EE:  MOVFF  03,FEC
....................         total_acc_step_x += StepbyF_x[i-1]; 
038F2:  MOVLW  01
038F4:  MOVLB  5
038F6:  SUBWF  x80,W
038F8:  MULLW  04
038FA:  MOVF   FF3,W
038FC:  CLRF   03
038FE:  ADDLW  88
03900:  MOVWF  FE9
03902:  MOVLW  02
03904:  ADDWFC 03,W
03906:  MOVWF  FEA
03908:  MOVFF  FEF,00
0390C:  MOVFF  FEC,01
03910:  MOVFF  FEC,02
03914:  MOVFF  FEC,03
03918:  MOVF   00,W
0391A:  MOVLB  2
0391C:  ADDWF  xD8,F
0391E:  MOVF   01,W
03920:  ADDWFC xD9,F
....................         Ts_x[i-1] = Ts_x[i-1]/(8*0.2*2);//Tempo/(prescale*ciclodemaquina*metadedociclo) 
03922:  MOVLW  01
03924:  MOVLB  5
03926:  SUBWF  x80,W
03928:  MULLW  04
0392A:  MOVF   FF3,W
0392C:  CLRF   03
0392E:  ADDLW  38
03930:  MOVWF  01
03932:  MOVLW  02
03934:  ADDWFC 03,F
03936:  MOVFF  01,581
0393A:  MOVFF  03,582
0393E:  MOVLW  01
03940:  SUBWF  x80,W
03942:  MULLW  04
03944:  MOVF   FF3,W
03946:  CLRF   03
03948:  ADDLW  38
0394A:  MOVWF  FE9
0394C:  MOVLW  02
0394E:  ADDWFC 03,W
03950:  MOVWF  FEA
03952:  MOVFF  FEF,583
03956:  MOVFF  FEC,584
0395A:  MOVFF  FEC,585
0395E:  MOVFF  FEC,586
03962:  MOVFF  586,598
03966:  MOVFF  585,597
0396A:  MOVFF  584,596
0396E:  MOVFF  583,595
03972:  MOVLB  0
03974:  RCALL  3482
03976:  MOVFF  03,598
0397A:  MOVFF  02,597
0397E:  MOVFF  01,596
03982:  MOVFF  00,595
03986:  MOVLW  CD
03988:  MOVLB  5
0398A:  MOVWF  x9C
0398C:  MOVLW  CC
0398E:  MOVWF  x9B
03990:  MOVLW  4C
03992:  MOVWF  x9A
03994:  MOVLW  80
03996:  MOVWF  x99
03998:  MOVLB  0
0399A:  CALL   301A
0399E:  MOVFF  03,598
039A2:  MOVFF  02,597
039A6:  MOVFF  01,596
039AA:  MOVFF  00,595
039AE:  RCALL  34BA
039B0:  MOVFF  582,FEA
039B4:  MOVFF  581,FE9
039B8:  MOVFF  00,FEF
039BC:  MOVFF  01,FEC
039C0:  MOVFF  02,FEC
039C4:  MOVFF  03,FEC
039C8:  MOVLB  5
039CA:  INCF   x80,F
039CC:  BRA    36A4
039CE:  MOVLB  2
....................     } 
039D0:  MOVLB  0
039D2:  GOTO   DA0E (RETURN)
.................... } 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Movimento Motor"> 
.................... void motor_stop_x(){ 
....................     step_no_x = step_down_x; 
....................     ramp_sts_x = ramp_down; 
.................... } 
....................  
.................... void motor_disable_x(){ 
....................     output_high(enable_x); 
....................     disable_interrupts(INT_TIMER0); 
.................... } 
....................  
.................... void motor_run_x(int32 pos_new, int velocidade) { // set up to drive motor to pos_new (absolute step#) 
....................      
....................     vel_x = velocidade; 
*
055F6:  MOVFF  580,2E9
....................     total_acc_step_x = 0; 
055FA:  MOVLB  2
055FC:  CLRF   xD9
055FE:  CLRF   xD8
....................      
....................     /*Obtem a Direo do motor*/ 
....................     if (pos_new < motor_pos_x)  
05600:  MOVFF  203,00
05604:  MOVFF  204,01
05608:  CLRF   02
0560A:  CLRF   03
0560C:  BTFSS  x04.7
0560E:  BRA    5614
05610:  DECF   02,F
05612:  DECF   03,F
05614:  BTFSC  03.7
05616:  BRA    5686
05618:  MOVLB  5
0561A:  MOVF   x7F,W
0561C:  SUBWF  03,W
0561E:  BTFSC  FD8.0
05620:  BRA    5626
05622:  MOVLB  2
05624:  BRA    5686
05626:  BNZ   5650
05628:  MOVF   x7E,W
0562A:  SUBWF  02,W
0562C:  BTFSC  FD8.0
0562E:  BRA    5634
05630:  MOVLB  2
05632:  BRA    5686
05634:  BNZ   5650
05636:  MOVF   x7D,W
05638:  SUBWF  01,W
0563A:  BTFSC  FD8.0
0563C:  BRA    5642
0563E:  MOVLB  2
05640:  BRA    5686
05642:  BNZ   5650
05644:  MOVF   00,W
05646:  SUBWF  x7C,W
05648:  BTFSS  FD8.0
0564A:  BRA    5650
0564C:  MOVLB  2
0564E:  BRA    5686
....................     { 
....................         output_low(dir_x); 
05650:  BCF    F95.1
05652:  BCF    F8C.1
....................         move_x = motor_pos_x - pos_new; 
05654:  MOVFF  203,00
05658:  MOVFF  204,01
0565C:  CLRF   02
0565E:  CLRF   03
05660:  BTFSS  01.7
05662:  BRA    5668
05664:  DECF   02,F
05666:  DECF   03,F
05668:  MOVF   x7C,W
0566A:  SUBWF  00,F
0566C:  MOVF   x7D,W
0566E:  SUBWFB 01,F
05670:  MOVF   x7E,W
05672:  SUBWFB 02,F
05674:  MOVF   x7F,W
05676:  SUBWFB 03,F
05678:  MOVFF  01,2E1
0567C:  MOVFF  00,2E0
....................         pos_inc_x = -1; 
05680:  MOVLB  2
05682:  SETF   xDA
....................     } else if (pos_new != motor_pos_x) { 
05684:  BRA    56F6
05686:  MOVFF  203,00
0568A:  MOVFF  204,01
0568E:  CLRF   02
05690:  CLRF   03
05692:  BTFSS  x04.7
05694:  BRA    569A
05696:  DECF   02,F
05698:  DECF   03,F
0569A:  MOVF   00,W
0569C:  MOVLB  5
0569E:  SUBWF  x7C,W
056A0:  BNZ   56B4
056A2:  MOVF   01,W
056A4:  SUBWF  x7D,W
056A6:  BNZ   56B4
056A8:  MOVF   02,W
056AA:  SUBWF  x7E,W
056AC:  BNZ   56B4
056AE:  MOVF   03,W
056B0:  SUBWF  x7F,W
056B2:  BZ    56F2
....................         output_high(dir_x); 
056B4:  BCF    F95.1
056B6:  BSF    F8C.1
....................         move_x = pos_new - motor_pos_x; 
056B8:  MOVFF  203,00
056BC:  MOVFF  204,01
056C0:  CLRF   02
056C2:  CLRF   03
056C4:  BTFSS  01.7
056C6:  BRA    56CC
056C8:  DECF   02,F
056CA:  DECF   03,F
056CC:  MOVF   00,W
056CE:  SUBWF  x7C,W
056D0:  MOVWF  00
056D2:  MOVF   01,W
056D4:  SUBWFB x7D,W
056D6:  MOVWF  01
056D8:  MOVF   02,W
056DA:  SUBWFB x7E,W
056DC:  MOVF   03,W
056DE:  SUBWFB x7F,W
056E0:  MOVFF  01,2E1
056E4:  MOVFF  00,2E0
....................         pos_inc_x = 1; 
056E8:  MOVLW  01
056EA:  MOVLB  2
056EC:  MOVWF  xDA
....................     } else return; 
056EE:  BRA    56F6
056F0:  MOVLB  5
056F2:  BRA    57D8
056F4:  MOVLB  2
....................      
....................     /*Calcula a quantidade de passos para chegar na velocidade desejada*/ 
....................     for(int j = 0; j <= velocidade;j++) 
056F6:  MOVLB  5
056F8:  CLRF   x81
056FA:  MOVF   x81,W
056FC:  SUBWF  x80,W
056FE:  BNC   5732
....................     { 
....................         total_acc_step_x += StepbyF_x[j]; 
05700:  MOVF   x81,W
05702:  MULLW  04
05704:  MOVF   FF3,W
05706:  CLRF   03
05708:  ADDLW  88
0570A:  MOVWF  FE9
0570C:  MOVLW  02
0570E:  ADDWFC 03,W
05710:  MOVWF  FEA
05712:  MOVFF  FEF,00
05716:  MOVFF  FEC,01
0571A:  MOVFF  FEC,02
0571E:  MOVFF  FEC,03
05722:  MOVF   00,W
05724:  MOVLB  2
05726:  ADDWF  xD8,F
05728:  MOVF   01,W
0572A:  ADDWFC xD9,F
0572C:  MOVLB  5
0572E:  INCF   x81,F
05730:  BRA    56FA
....................     } 
....................     /*Define Formato da Rampa(Trapezio,triangulo ou constante)*/ 
....................     if (move_x > 2 * total_acc_step_x) { 
05732:  BCF    FD8.0
05734:  MOVLB  2
05736:  RLCF   xD8,W
05738:  MOVWF  02
0573A:  RLCF   xD9,W
0573C:  MOVWF  03
0573E:  MOVFF  02,01
05742:  MOVF   03,W
05744:  SUBWF  xE1,W
05746:  BNC   5766
05748:  BNZ   5750
0574A:  MOVF   xE0,W
0574C:  SUBWF  01,W
0574E:  BC    5766
....................         midpt_x = total_acc_step_x; 
05750:  MOVFF  2D9,2E3
05754:  MOVFF  2D8,2E2
....................         step_down_x = move_x - total_acc_step_x; 
05758:  MOVF   xD8,W
0575A:  SUBWF  xE0,W
0575C:  MOVWF  xDE
0575E:  MOVF   xD9,W
05760:  SUBWFB xE1,W
05762:  MOVWF  xDF
....................     }  
05764:  BRA    5790
....................     else 
....................     { 
....................         midpt_x = (move_x - 1) >> 1; 
05766:  MOVLW  01
05768:  SUBWF  xE0,W
0576A:  MOVLB  5
0576C:  MOVWF  x82
0576E:  MOVLW  00
05770:  MOVLB  2
05772:  SUBWFB xE1,W
05774:  MOVLB  5
05776:  MOVWF  x83
05778:  BCF    FD8.0
0577A:  RRCF   x83,W
0577C:  MOVLB  2
0577E:  MOVWF  xE3
05780:  MOVLB  5
05782:  RRCF   x82,W
05784:  MOVLB  2
05786:  MOVWF  xE2
....................         step_down_x = midpt_x; 
05788:  MOVFF  2E3,2DF
0578C:  MOVFF  2E2,2DE
....................     } 
....................     step_no_x = 0; 
05790:  CLRF   xDD
05792:  CLRF   xDC
....................     step_acumulado_x = 0; 
05794:  CLRF   xE7
05796:  CLRF   xE6
05798:  CLRF   xE5
0579A:  CLRF   xE4
....................     atual_frequencia_x = 0; 
0579C:  CLRF   xE8
....................     ramp_sts_x = ramp_up; // start ramp state-machine 
0579E:  MOVLW  01
057A0:  MOVWF  xDB
....................     run_flg_x = TRUE; 
057A2:  BSF    x0B.5
....................     output_low(enable_x); 
057A4:  BCF    F95.0
057A6:  BCF    F8C.0
....................     setup_timer_0(T0_INTERNAL | T0_DIV_8); 
057A8:  MOVLW  82
057AA:  MOVWF  FD5
....................     set_timer0(65535 - Ts_x[0]); 
057AC:  MOVLW  FF
057AE:  BSF    FD8.0
057B0:  SUBFWB x38,W
057B2:  MOVLB  5
057B4:  MOVWF  x82
057B6:  MOVLW  FF
057B8:  MOVLB  2
057BA:  SUBFWB x39,W
057BC:  MOVLB  5
057BE:  MOVWF  x83
057C0:  MOVLW  00
057C2:  MOVLB  2
057C4:  SUBFWB x3A,W
057C6:  MOVLW  00
057C8:  MOVLB  2
057CA:  SUBFWB x3B,W
057CC:  MOVLB  5
057CE:  MOVFF  583,FD7
057D2:  MOVFF  582,FD6
....................     enable_interrupts(INT_TIMER0); 
057D6:  BSF    FF2.5
057D8:  MOVLB  0
057DA:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_subida_x() { 
....................     if (atual_frequencia_x == 0) { 
*
01270:  MOVLB  2
01272:  MOVF   xE8,F
01274:  BTFSS  FD8.2
01276:  BRA    13A6
....................         if (step_no_x == StepbyF_x[atual_frequencia_x]) { 
01278:  MOVF   xE8,W
0127A:  MULLW  04
0127C:  MOVF   FF3,W
0127E:  CLRF   03
01280:  ADDLW  88
01282:  MOVWF  FE9
01284:  MOVLW  02
01286:  ADDWFC 03,W
01288:  MOVWF  FEA
0128A:  MOVFF  FEF,00
0128E:  MOVFF  FEC,01
01292:  MOVFF  FEC,02
01296:  MOVFF  FEC,03
0129A:  MOVF   00,W
0129C:  SUBWF  xDC,W
0129E:  BNZ   1360
012A0:  MOVF   01,W
012A2:  SUBWF  xDD,W
012A4:  BNZ   1360
012A6:  MOVF   02,F
012A8:  BNZ   1360
012AA:  MOVF   03,F
012AC:  BNZ   1360
....................             step_acumulado_x += StepbyF_x[atual_frequencia_x] + StepbyF_x[atual_frequencia_x + 1]; 
012AE:  MOVF   xE8,W
012B0:  MULLW  04
012B2:  MOVF   FF3,W
012B4:  CLRF   03
012B6:  ADDLW  88
012B8:  MOVWF  FE9
012BA:  MOVLW  02
012BC:  ADDWFC 03,W
012BE:  MOVWF  FEA
012C0:  MOVFF  FEF,5A5
012C4:  MOVFF  FEC,5A6
012C8:  MOVFF  FEC,5A7
012CC:  MOVFF  FEC,5A8
012D0:  MOVLW  01
012D2:  ADDWF  xE8,W
012D4:  MULLW  04
012D6:  MOVF   FF3,W
012D8:  CLRF   03
012DA:  ADDLW  88
012DC:  MOVWF  FE9
012DE:  MOVLW  02
012E0:  ADDWFC 03,W
012E2:  MOVWF  FEA
012E4:  MOVFF  FEF,00
012E8:  MOVFF  FEC,01
012EC:  MOVFF  FEC,02
012F0:  MOVFF  FEC,03
012F4:  MOVLB  5
012F6:  MOVF   xA5,W
012F8:  ADDWF  00,F
012FA:  MOVF   xA6,W
012FC:  ADDWFC 01,F
012FE:  MOVF   xA7,W
01300:  ADDWFC 02,F
01302:  MOVF   xA8,W
01304:  ADDWFC 03,F
01306:  MOVF   00,W
01308:  MOVLB  2
0130A:  ADDWF  xE4,F
0130C:  MOVF   01,W
0130E:  ADDWFC xE5,F
01310:  MOVF   02,W
01312:  ADDWFC xE6,F
01314:  MOVF   03,W
01316:  ADDWFC xE7,F
....................             atual_frequencia_x++; 
01318:  INCF   xE8,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
0131A:  MOVF   xE8,W
0131C:  MULLW  04
0131E:  MOVF   FF3,W
01320:  CLRF   03
01322:  ADDLW  38
01324:  MOVWF  FE9
01326:  MOVLW  02
01328:  ADDWFC 03,W
0132A:  MOVWF  FEA
0132C:  MOVFF  FEF,00
01330:  MOVFF  FEC,01
01334:  MOVFF  FEC,02
01338:  MOVFF  FEC,03
0133C:  MOVLW  FF
0133E:  BSF    FD8.0
01340:  SUBFWB 00,W
01342:  MOVLB  5
01344:  MOVWF  xA5
01346:  MOVLW  FF
01348:  SUBFWB 01,W
0134A:  MOVWF  xA6
0134C:  MOVLW  00
0134E:  SUBFWB 02,W
01350:  MOVLW  00
01352:  SUBFWB 03,W
01354:  MOVFF  5A6,FD7
01358:  MOVFF  5A5,FD6
....................         } else { 
0135C:  BRA    13A2
0135E:  MOVLB  2
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
01360:  MOVF   xE8,W
01362:  MULLW  04
01364:  MOVF   FF3,W
01366:  CLRF   03
01368:  ADDLW  38
0136A:  MOVWF  FE9
0136C:  MOVLW  02
0136E:  ADDWFC 03,W
01370:  MOVWF  FEA
01372:  MOVFF  FEF,00
01376:  MOVFF  FEC,01
0137A:  MOVFF  FEC,02
0137E:  MOVFF  FEC,03
01382:  MOVLW  FF
01384:  BSF    FD8.0
01386:  SUBFWB 00,W
01388:  MOVLB  5
0138A:  MOVWF  xA5
0138C:  MOVLW  FF
0138E:  SUBFWB 01,W
01390:  MOVWF  xA6
01392:  MOVLW  00
01394:  SUBFWB 02,W
01396:  MOVLW  00
01398:  SUBFWB 03,W
0139A:  MOVFF  5A6,FD7
0139E:  MOVFF  5A5,FD6
....................         } 
....................     } else if (atual_frequencia_x == vel_x) { 
013A2:  BRA    14C2
013A4:  MOVLB  2
013A6:  MOVF   xE9,W
013A8:  SUBWF  xE8,W
013AA:  BNZ   13F2
....................         set_timer0(65535 - Ts_x[atual_frequencia_x]); 
013AC:  MOVF   xE8,W
013AE:  MULLW  04
013B0:  MOVF   FF3,W
013B2:  CLRF   03
013B4:  ADDLW  38
013B6:  MOVWF  FE9
013B8:  MOVLW  02
013BA:  ADDWFC 03,W
013BC:  MOVWF  FEA
013BE:  MOVFF  FEF,00
013C2:  MOVFF  FEC,01
013C6:  MOVFF  FEC,02
013CA:  MOVFF  FEC,03
013CE:  MOVLW  FF
013D0:  BSF    FD8.0
013D2:  SUBFWB 00,W
013D4:  MOVLB  5
013D6:  MOVWF  xA5
013D8:  MOVLW  FF
013DA:  SUBFWB 01,W
013DC:  MOVWF  xA6
013DE:  MOVLW  00
013E0:  SUBFWB 02,W
013E2:  MOVLW  00
013E4:  SUBFWB 03,W
013E6:  MOVFF  5A6,FD7
013EA:  MOVFF  5A5,FD6
....................     } else { 
013EE:  BRA    14C2
013F0:  MOVLB  2
....................         if (step_no_x == step_acumulado_x) { 
013F2:  MOVF   xE4,W
013F4:  SUBWF  xDC,W
013F6:  BNZ   1480
013F8:  MOVF   xE5,W
013FA:  SUBWF  xDD,W
013FC:  BNZ   1480
013FE:  MOVF   xE6,F
01400:  BNZ   1480
01402:  MOVF   xE7,F
01404:  BNZ   1480
....................             atual_frequencia_x++; 
01406:  INCF   xE8,F
....................             step_acumulado_x += StepbyF_x[atual_frequencia_x]; 
01408:  MOVF   xE8,W
0140A:  MULLW  04
0140C:  MOVF   FF3,W
0140E:  CLRF   03
01410:  ADDLW  88
01412:  MOVWF  FE9
01414:  MOVLW  02
01416:  ADDWFC 03,W
01418:  MOVWF  FEA
0141A:  MOVFF  FEF,00
0141E:  MOVFF  FEC,01
01422:  MOVFF  FEC,02
01426:  MOVFF  FEC,03
0142A:  MOVF   00,W
0142C:  ADDWF  xE4,F
0142E:  MOVF   01,W
01430:  ADDWFC xE5,F
01432:  MOVF   02,W
01434:  ADDWFC xE6,F
01436:  MOVF   03,W
01438:  ADDWFC xE7,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
0143A:  MOVF   xE8,W
0143C:  MULLW  04
0143E:  MOVF   FF3,W
01440:  CLRF   03
01442:  ADDLW  38
01444:  MOVWF  FE9
01446:  MOVLW  02
01448:  ADDWFC 03,W
0144A:  MOVWF  FEA
0144C:  MOVFF  FEF,00
01450:  MOVFF  FEC,01
01454:  MOVFF  FEC,02
01458:  MOVFF  FEC,03
0145C:  MOVLW  FF
0145E:  BSF    FD8.0
01460:  SUBFWB 00,W
01462:  MOVLB  5
01464:  MOVWF  xA5
01466:  MOVLW  FF
01468:  SUBFWB 01,W
0146A:  MOVWF  xA6
0146C:  MOVLW  00
0146E:  SUBFWB 02,W
01470:  MOVLW  00
01472:  SUBFWB 03,W
01474:  MOVFF  5A6,FD7
01478:  MOVFF  5A5,FD6
....................         } else { 
0147C:  BRA    14C2
0147E:  MOVLB  2
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
01480:  MOVF   xE8,W
01482:  MULLW  04
01484:  MOVF   FF3,W
01486:  CLRF   03
01488:  ADDLW  38
0148A:  MOVWF  FE9
0148C:  MOVLW  02
0148E:  ADDWFC 03,W
01490:  MOVWF  FEA
01492:  MOVFF  FEF,00
01496:  MOVFF  FEC,01
0149A:  MOVFF  FEC,02
0149E:  MOVFF  FEC,03
014A2:  MOVLW  FF
014A4:  BSF    FD8.0
014A6:  SUBFWB 00,W
014A8:  MOVLB  5
014AA:  MOVWF  xA5
014AC:  MOVLW  FF
014AE:  SUBFWB 01,W
014B0:  MOVWF  xA6
014B2:  MOVLW  00
014B4:  SUBFWB 02,W
014B6:  MOVLW  00
014B8:  SUBFWB 03,W
014BA:  MOVFF  5A6,FD7
014BE:  MOVFF  5A5,FD6
....................         } 
....................         break; 
....................     } 
014C2:  MOVLB  0
014C4:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_descida_x() { 
....................     if (atual_frequencia_x == 0) { 
014C6:  MOVLB  2
014C8:  MOVF   xE8,F
014CA:  BNZ   1512
....................         set_timer0(65535 - Ts_x[atual_frequencia_x]); 
014CC:  MOVF   xE8,W
014CE:  MULLW  04
014D0:  MOVF   FF3,W
014D2:  CLRF   03
014D4:  ADDLW  38
014D6:  MOVWF  FE9
014D8:  MOVLW  02
014DA:  ADDWFC 03,W
014DC:  MOVWF  FEA
014DE:  MOVFF  FEF,00
014E2:  MOVFF  FEC,01
014E6:  MOVFF  FEC,02
014EA:  MOVFF  FEC,03
014EE:  MOVLW  FF
014F0:  BSF    FD8.0
014F2:  SUBFWB 00,W
014F4:  MOVLB  5
014F6:  MOVWF  xA5
014F8:  MOVLW  FF
014FA:  SUBFWB 01,W
014FC:  MOVWF  xA6
014FE:  MOVLW  00
01500:  SUBFWB 02,W
01502:  MOVLW  00
01504:  SUBFWB 03,W
01506:  MOVFF  5A6,FD7
0150A:  MOVFF  5A5,FD6
....................     }  
0150E:  BRA    174A
01510:  MOVLB  2
....................     else if (atual_frequencia_x == vel_x) { 
01512:  MOVF   xE9,W
01514:  SUBWF  xE8,W
01516:  BTFSS  FD8.2
01518:  BRA    167A
....................         if (step_no_x == (step_down_x + StepbyF_x[atual_frequencia_x])) { 
0151A:  MOVF   xE8,W
0151C:  MULLW  04
0151E:  MOVF   FF3,W
01520:  CLRF   03
01522:  ADDLW  88
01524:  MOVWF  FE9
01526:  MOVLW  02
01528:  ADDWFC 03,W
0152A:  MOVWF  FEA
0152C:  MOVFF  FEF,00
01530:  MOVFF  FEC,01
01534:  MOVFF  FEC,02
01538:  MOVFF  FEC,03
0153C:  MOVF   xDE,W
0153E:  ADDWF  00,F
01540:  MOVF   xDF,W
01542:  ADDWFC 01,F
01544:  MOVLW  00
01546:  ADDWFC 02,F
01548:  ADDWFC 03,F
0154A:  MOVF   00,W
0154C:  SUBWF  xDC,W
0154E:  BNZ   1634
01550:  MOVF   01,W
01552:  SUBWF  xDD,W
01554:  BNZ   1634
01556:  MOVF   02,F
01558:  BNZ   1634
0155A:  MOVF   03,F
0155C:  BNZ   1634
....................             step_acumulado_x = step_down_x + StepbyF_x[atual_frequencia_x] + StepbyF_x[atual_frequencia_x - 1]; 
0155E:  MOVF   xE8,W
01560:  MULLW  04
01562:  MOVF   FF3,W
01564:  CLRF   03
01566:  ADDLW  88
01568:  MOVWF  FE9
0156A:  MOVLW  02
0156C:  ADDWFC 03,W
0156E:  MOVWF  FEA
01570:  MOVFF  FEF,00
01574:  MOVFF  FEC,01
01578:  MOVFF  FEC,02
0157C:  MOVFF  FEC,03
01580:  MOVF   00,W
01582:  ADDWF  xDE,W
01584:  MOVLB  5
01586:  MOVWF  xA5
01588:  MOVF   01,W
0158A:  MOVLB  2
0158C:  ADDWFC xDF,W
0158E:  MOVLB  5
01590:  MOVWF  xA6
01592:  MOVLW  00
01594:  ADDWFC 02,W
01596:  MOVWF  xA7
01598:  MOVLW  00
0159A:  ADDWFC 03,W
0159C:  MOVWF  xA8
0159E:  MOVLW  01
015A0:  MOVLB  2
015A2:  SUBWF  xE8,W
015A4:  MULLW  04
015A6:  MOVF   FF3,W
015A8:  CLRF   03
015AA:  ADDLW  88
015AC:  MOVWF  FE9
015AE:  MOVLW  02
015B0:  ADDWFC 03,W
015B2:  MOVWF  FEA
015B4:  MOVFF  FEF,00
015B8:  MOVFF  FEC,01
015BC:  MOVFF  FEC,02
015C0:  MOVFF  FEC,03
015C4:  MOVF   00,W
015C6:  MOVLB  5
015C8:  ADDWF  xA5,W
015CA:  MOVLB  2
015CC:  MOVWF  xE4
015CE:  MOVF   01,W
015D0:  MOVLB  5
015D2:  ADDWFC xA6,W
015D4:  MOVLB  2
015D6:  MOVWF  xE5
015D8:  MOVF   02,W
015DA:  MOVLB  5
015DC:  ADDWFC xA7,W
015DE:  MOVLB  2
015E0:  MOVWF  xE6
015E2:  MOVF   03,W
015E4:  MOVLB  5
015E6:  ADDWFC xA8,W
015E8:  MOVLB  2
015EA:  MOVWF  xE7
....................             atual_frequencia_x--; 
015EC:  DECF   xE8,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
015EE:  MOVF   xE8,W
015F0:  MULLW  04
015F2:  MOVF   FF3,W
015F4:  CLRF   03
015F6:  ADDLW  38
015F8:  MOVWF  FE9
015FA:  MOVLW  02
015FC:  ADDWFC 03,W
015FE:  MOVWF  FEA
01600:  MOVFF  FEF,00
01604:  MOVFF  FEC,01
01608:  MOVFF  FEC,02
0160C:  MOVFF  FEC,03
01610:  MOVLW  FF
01612:  BSF    FD8.0
01614:  SUBFWB 00,W
01616:  MOVLB  5
01618:  MOVWF  xA5
0161A:  MOVLW  FF
0161C:  SUBFWB 01,W
0161E:  MOVWF  xA6
01620:  MOVLW  00
01622:  SUBFWB 02,W
01624:  MOVLW  00
01626:  SUBFWB 03,W
01628:  MOVFF  5A6,FD7
0162C:  MOVFF  5A5,FD6
....................         } else { 
01630:  BRA    1676
01632:  MOVLB  2
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
01634:  MOVF   xE8,W
01636:  MULLW  04
01638:  MOVF   FF3,W
0163A:  CLRF   03
0163C:  ADDLW  38
0163E:  MOVWF  FE9
01640:  MOVLW  02
01642:  ADDWFC 03,W
01644:  MOVWF  FEA
01646:  MOVFF  FEF,00
0164A:  MOVFF  FEC,01
0164E:  MOVFF  FEC,02
01652:  MOVFF  FEC,03
01656:  MOVLW  FF
01658:  BSF    FD8.0
0165A:  SUBFWB 00,W
0165C:  MOVLB  5
0165E:  MOVWF  xA5
01660:  MOVLW  FF
01662:  SUBFWB 01,W
01664:  MOVWF  xA6
01666:  MOVLW  00
01668:  SUBFWB 02,W
0166A:  MOVLW  00
0166C:  SUBFWB 03,W
0166E:  MOVFF  5A6,FD7
01672:  MOVFF  5A5,FD6
....................         } 
....................     } else { 
01676:  BRA    174A
01678:  MOVLB  2
....................         if (step_no_x == step_acumulado_x) { 
0167A:  MOVF   xE4,W
0167C:  SUBWF  xDC,W
0167E:  BNZ   1708
01680:  MOVF   xE5,W
01682:  SUBWF  xDD,W
01684:  BNZ   1708
01686:  MOVF   xE6,F
01688:  BNZ   1708
0168A:  MOVF   xE7,F
0168C:  BNZ   1708
....................             atual_frequencia_x--; 
0168E:  DECF   xE8,F
....................             step_acumulado_x += StepbyF_x[atual_frequencia_x]; 
01690:  MOVF   xE8,W
01692:  MULLW  04
01694:  MOVF   FF3,W
01696:  CLRF   03
01698:  ADDLW  88
0169A:  MOVWF  FE9
0169C:  MOVLW  02
0169E:  ADDWFC 03,W
016A0:  MOVWF  FEA
016A2:  MOVFF  FEF,00
016A6:  MOVFF  FEC,01
016AA:  MOVFF  FEC,02
016AE:  MOVFF  FEC,03
016B2:  MOVF   00,W
016B4:  ADDWF  xE4,F
016B6:  MOVF   01,W
016B8:  ADDWFC xE5,F
016BA:  MOVF   02,W
016BC:  ADDWFC xE6,F
016BE:  MOVF   03,W
016C0:  ADDWFC xE7,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
016C2:  MOVF   xE8,W
016C4:  MULLW  04
016C6:  MOVF   FF3,W
016C8:  CLRF   03
016CA:  ADDLW  38
016CC:  MOVWF  FE9
016CE:  MOVLW  02
016D0:  ADDWFC 03,W
016D2:  MOVWF  FEA
016D4:  MOVFF  FEF,00
016D8:  MOVFF  FEC,01
016DC:  MOVFF  FEC,02
016E0:  MOVFF  FEC,03
016E4:  MOVLW  FF
016E6:  BSF    FD8.0
016E8:  SUBFWB 00,W
016EA:  MOVLB  5
016EC:  MOVWF  xA5
016EE:  MOVLW  FF
016F0:  SUBFWB 01,W
016F2:  MOVWF  xA6
016F4:  MOVLW  00
016F6:  SUBFWB 02,W
016F8:  MOVLW  00
016FA:  SUBFWB 03,W
016FC:  MOVFF  5A6,FD7
01700:  MOVFF  5A5,FD6
....................         } else { 
01704:  BRA    174A
01706:  MOVLB  2
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
01708:  MOVF   xE8,W
0170A:  MULLW  04
0170C:  MOVF   FF3,W
0170E:  CLRF   03
01710:  ADDLW  38
01712:  MOVWF  FE9
01714:  MOVLW  02
01716:  ADDWFC 03,W
01718:  MOVWF  FEA
0171A:  MOVFF  FEF,00
0171E:  MOVFF  FEC,01
01722:  MOVFF  FEC,02
01726:  MOVFF  FEC,03
0172A:  MOVLW  FF
0172C:  BSF    FD8.0
0172E:  SUBFWB 00,W
01730:  MOVLB  5
01732:  MOVWF  xA5
01734:  MOVLW  FF
01736:  SUBFWB 01,W
01738:  MOVWF  xA6
0173A:  MOVLW  00
0173C:  SUBFWB 02,W
0173E:  MOVLW  00
01740:  SUBFWB 03,W
01742:  MOVFF  5A6,FD7
01746:  MOVFF  5A5,FD6
....................         } 
....................     } 
0174A:  MOVLB  0
0174C:  GOTO   17A4 (RETURN)
.................... } 
....................  
.................... void movimenta_eixo_x() { 
....................   
....................     switch (ramp_sts_x) { 
01750:  MOVLB  2
01752:  MOVF   xDB,W
01754:  XORLW  01
01756:  MOVLB  0
01758:  BZ    1764
0175A:  XORLW  02
0175C:  BZ    17A2
0175E:  XORLW  01
01760:  BZ    17BE
01762:  BRA    17DC
....................         case ramp_up: // accel 
....................             proximo_valor_subida_x(); 
01764:  RCALL  1270
....................             if (step_no_x == midpt_x) { // midpoint: decel 
01766:  MOVLB  2
01768:  MOVF   xE2,W
0176A:  SUBWF  xDC,W
0176C:  BNZ   179A
0176E:  MOVF   xE3,W
01770:  SUBWF  xDD,W
01772:  BNZ   179A
....................                 if (move_x > 2 * total_acc_step_x) 
01774:  BCF    FD8.0
01776:  RLCF   xD8,W
01778:  MOVWF  02
0177A:  RLCF   xD9,W
0177C:  MOVWF  03
0177E:  MOVFF  02,01
01782:  MOVF   03,W
01784:  SUBWF  xE1,W
01786:  BNC   1796
01788:  BNZ   1790
0178A:  MOVF   xE0,W
0178C:  SUBWF  01,W
0178E:  BC    1796
....................                     ramp_sts_x = ramp_max; 
01790:  MOVLW  02
01792:  MOVWF  xDB
01794:  BRA    179A
....................                 else 
....................                     ramp_sts_x = ramp_down; 
01796:  MOVLW  03
01798:  MOVWF  xDB
....................             } 
....................             output_toggle(step_x); 
0179A:  BCF    F95.2
0179C:  BTG    F8C.2
....................             rest_x = ~rest_x; 
0179E:  BTG    x0B.6
....................             break; 
017A0:  BRA    17E4
....................  
....................         case ramp_down: // decel 
....................             proximo_valor_descida_x(); 
017A2:  BRA    14C6
....................             if (step_no_x == move_x) 
017A4:  MOVLB  2
017A6:  MOVF   xE0,W
017A8:  SUBWF  xDC,W
017AA:  BNZ   17B6
017AC:  MOVF   xE1,W
017AE:  SUBWF  xDD,W
017B0:  BNZ   17B6
....................                 ramp_sts_x = ramp_last; 
017B2:  MOVLW  04
017B4:  MOVWF  xDB
....................             output_toggle(step_x); 
017B6:  BCF    F95.2
017B8:  BTG    F8C.2
....................             rest_x = ~rest_x; 
017BA:  BTG    x0B.6
....................             break; 
017BC:  BRA    17E4
....................  
....................         case ramp_max: // constant speed 
....................             proximo_valor_subida_x(); 
017BE:  RCALL  1270
....................             if (step_no_x == step_down_x) // start decel 
017C0:  MOVLB  2
017C2:  MOVF   xDE,W
017C4:  SUBWF  xDC,W
017C6:  BNZ   17D2
017C8:  MOVF   xDF,W
017CA:  SUBWF  xDD,W
017CC:  BNZ   17D2
....................                 ramp_sts_x = ramp_down; 
017CE:  MOVLW  03
017D0:  MOVWF  xDB
....................             output_toggle(step_x); 
017D2:  BCF    F95.2
017D4:  BTG    F8C.2
....................             rest_x = ~rest_x; 
017D6:  BTG    x0B.6
....................             break; 
017D8:  BRA    17E4
017DA:  MOVLB  0
....................  
....................         default: // last step: cleanup 
....................             ramp_sts_x = ramp_idle; 
017DC:  MOVLB  2
017DE:  CLRF   xDB
....................             disable_interrupts(INT_TIMER0); 
017E0:  BCF    FF2.5
....................             run_flg_x = FALSE; // move_x complete 
017E2:  BCF    x0B.5
....................             break; 
....................     } // switch (ramp_sts_x) 
....................     if ((ramp_sts_x != ramp_idle)&&(ramp_sts_x != ramp_last)) { 
017E4:  MOVF   xDB,F
017E6:  BZ    1806
017E8:  MOVF   xDB,W
017EA:  SUBLW  04
017EC:  BZ    1806
....................         if (rest_x) { 
017EE:  BTFSS  x0B.6
017F0:  BRA    1806
....................             motor_pos_x += pos_inc_x; 
017F2:  CLRF   03
017F4:  MOVF   xDA,W
017F6:  BTFSC  FE8.7
017F8:  DECF   03,F
017FA:  ADDWF  x03,F
017FC:  MOVF   03,W
017FE:  ADDWFC x04,F
....................             ++step_no_x;    
01800:  INCF   xDC,F
01802:  BTFSC  FD8.2
01804:  INCF   xDD,F
....................         } 
....................     } 
01806:  MOVLB  0
01808:  GOTO   180E (RETURN)
.................... } 
....................  
.................... void umpasso_x(int16 descanco, short dir) { 
....................     output_low(enable_x); 
....................     if (dir) { 
....................         output_high(dir_x); 
....................         motor_pos_x++; 
....................     } else { 
....................         output_low(dir_x); 
....................         motor_pos_x--; 
....................     } 
....................     output_high(step_x); 
....................     delay_us(descanco); 
....................     output_low(step_x); 
....................     delay_us(descanco); 
....................      
.................... } 
....................  
.................... void zerar_x() { 
....................     while(le_Input(i_limite_x)==1){ 
....................         delay_us(200); 
....................         umpasso_x(600, TRUE); 
....................     } 
....................     while (le_Input(i_limite_x)==0){ 
....................         umpasso_x(900, FALSE); 
....................         delay_us(200); 
....................     } 
....................     while(le_Input(i_limite_x)==1){ 
....................         delay_us(200); 
....................         umpasso_x(1000, TRUE); 
....................     } 
....................     motor_pos_x = 0; 
....................     output_high(enable_x); 
.................... } 
.................... // </editor-fold> 
....................  
.................... #include "Axis_y.c" 
.................... // <editor-fold defaultstate="collapsed" desc="Valores que devem ser inseridos"> 
.................... float stepbyrev_y = 200; 
.................... float driver_u_step_y = 1; // caso o driver esteja em 400 
.................... float Leadscrew_y = 9; //redutor de voltas do motor 
.................... float Leadscrew_Pich_y = 150; //esse valor deve ser em mm/revoluo 
.................... float Vmax_y = 600; //esse valor deve ser em mm por segundo 
.................... float Vmin_y = 200; 
.................... float Amax_y = 450; //esse valor deve ser em mm por segundo 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Valores calculo rampa"> 
.................... float MMbyStep_y = 0; 
.................... int8 StepinAcc_y = 20; 
.................... float Fmax_y = 0; 
.................... float Fmin_y = 100; 
.................... int32 Ts_y[20]; 
.................... int32 StepbyF_y[20]; 
.................... int16 total_acc_step_y = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Flags e Controles de Movimento"> 
.................... signed int8 pos_inc_y = 0; 
.................... int8 ramp_sts_y = ramp_idle; 
.................... short run_flg_y = FALSE; 
.................... short rest_y = FALSE; 
.................... short stop_yf = FALSE; 
.................... int16 step_no_y = 0; 
.................... int16 step_down_y = 0; 
.................... int16 move_y = 0; 
.................... int16 midpt_y = 0; 
.................... int32 step_acumulado_y = 0; 
.................... int atual_frequencia_y = 0; 
.................... int vel_y = 19; 
.................... int16 max_posicao_y=0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Pinos Motor"> 
....................  
.................... #DEFINE     i_limite_y            7 
.................... #DEFINE     s_limite_y            8 
....................  
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Inicializa Motor"> 
.................... void init_axis_y() { 
....................     set_tris_c(0xf8); 
*
039D6:  MOVLW  F8
039D8:  MOVWF  F94
....................     output_high(step_y); 
039DA:  BCF    F94.2
039DC:  BSF    F8B.2
....................     output_high(enable_y); 
039DE:  BCF    F94.0
039E0:  BSF    F8B.0
....................     output_high(dir_y); 
039E2:  BCF    F94.1
039E4:  BSF    F8B.1
....................  
....................     MMbyStep_y = Leadscrew_Pich_y / (stepbyrev_y * driver_u_step_y * Leadscrew_y); 
039E6:  MOVFF  2ED,592
039EA:  MOVFF  2EC,591
039EE:  MOVFF  2EB,590
039F2:  MOVFF  2EA,58F
039F6:  MOVFF  2F1,596
039FA:  MOVFF  2F0,595
039FE:  MOVFF  2EF,594
03A02:  MOVFF  2EE,593
03A06:  CALL   2F24
03A0A:  MOVFF  03,584
03A0E:  MOVFF  02,583
03A12:  MOVFF  01,582
03A16:  MOVFF  00,581
03A1A:  MOVFF  03,592
03A1E:  MOVFF  02,591
03A22:  MOVFF  01,590
03A26:  MOVFF  00,58F
03A2A:  MOVFF  2F5,596
03A2E:  MOVFF  2F4,595
03A32:  MOVFF  2F3,594
03A36:  MOVFF  2F2,593
03A3A:  CALL   2F24
03A3E:  MOVFF  2F9,598
03A42:  MOVFF  2F8,597
03A46:  MOVFF  2F7,596
03A4A:  MOVFF  2F6,595
03A4E:  MOVFF  03,59C
03A52:  MOVFF  02,59B
03A56:  MOVFF  01,59A
03A5A:  MOVFF  00,599
03A5E:  CALL   301A
03A62:  MOVFF  03,309
03A66:  MOVFF  02,308
03A6A:  MOVFF  01,307
03A6E:  MOVFF  00,306
....................     Fmax_y = Vmax_y/MMbyStep_y; //Valor de ferequencia adiquirido em hz 
03A72:  MOVFF  2FD,598
03A76:  MOVFF  2FC,597
03A7A:  MOVFF  2FB,596
03A7E:  MOVFF  2FA,595
03A82:  MOVFF  309,59C
03A86:  MOVFF  308,59B
03A8A:  MOVFF  307,59A
03A8E:  MOVFF  306,599
03A92:  CALL   301A
03A96:  MOVFF  03,30E
03A9A:  MOVFF  02,30D
03A9E:  MOVFF  01,30C
03AA2:  MOVFF  00,30B
....................      
....................     float den = Amax_y*StepinAcc_y; 
....................     float num = (Vmax_y-Vmin_y)*1000000; 
....................     float TbyF = num/den;//tempo em us 
....................      
....................     int i = 0; 
03AA6:  MOVLB  5
03AA8:  CLRF   x90
03AAA:  MOVFF  30A,58F
03AAE:  MOVLB  0
03AB0:  CALL   3178
03AB4:  MOVFF  305,592
03AB8:  MOVFF  304,591
03ABC:  MOVFF  303,590
03AC0:  MOVFF  302,58F
03AC4:  MOVFF  03,596
03AC8:  MOVFF  02,595
03ACC:  MOVFF  01,594
03AD0:  MOVFF  00,593
03AD4:  CALL   2F24
03AD8:  MOVFF  03,577
03ADC:  MOVFF  02,576
03AE0:  MOVFF  01,575
03AE4:  MOVFF  00,574
03AE8:  BSF    FD8.1
03AEA:  MOVFF  2FD,598
03AEE:  MOVFF  2FC,597
03AF2:  MOVFF  2FB,596
03AF6:  MOVFF  2FA,595
03AFA:  MOVFF  301,59C
03AFE:  MOVFF  300,59B
03B02:  MOVFF  2FF,59A
03B06:  MOVFF  2FE,599
03B0A:  CALL   31AE
03B0E:  MOVFF  03,584
03B12:  MOVFF  02,583
03B16:  MOVFF  01,582
03B1A:  MOVFF  00,581
03B1E:  MOVFF  03,592
03B22:  MOVFF  02,591
03B26:  MOVFF  01,590
03B2A:  MOVFF  00,58F
03B2E:  MOVLB  5
03B30:  CLRF   x96
03B32:  MOVLW  24
03B34:  MOVWF  x95
03B36:  MOVLW  74
03B38:  MOVWF  x94
03B3A:  MOVLW  92
03B3C:  MOVWF  x93
03B3E:  MOVLB  0
03B40:  CALL   2F24
03B44:  MOVFF  03,57B
03B48:  MOVFF  02,57A
03B4C:  MOVFF  01,579
03B50:  MOVFF  00,578
03B54:  MOVFF  57B,598
03B58:  MOVFF  57A,597
03B5C:  MOVFF  579,596
03B60:  MOVFF  578,595
03B64:  MOVFF  577,59C
03B68:  MOVFF  576,59B
03B6C:  MOVFF  575,59A
03B70:  MOVFF  574,599
03B74:  CALL   301A
03B78:  MOVFF  03,57F
03B7C:  MOVFF  02,57E
03B80:  MOVFF  01,57D
03B84:  MOVFF  00,57C
03B88:  MOVLB  5
03B8A:  CLRF   x80
....................     for(i = 1; i <=StepinAcc_y;i++) 
03B8C:  MOVLW  01
03B8E:  MOVWF  x80
03B90:  MOVF   x80,W
03B92:  MOVLB  3
03B94:  SUBWF  x0A,W
03B96:  BTFSS  FD8.0
03B98:  BRA    3ED0
....................     { 
....................         Ts_y[i-1]=(1000000*StepinAcc_y)/((i*(Fmax_y-Fmin_y)+Fmin_y)); 
03B9A:  MOVLW  01
03B9C:  MOVLB  5
03B9E:  SUBWF  x80,W
03BA0:  MULLW  04
03BA2:  MOVF   FF3,W
03BA4:  CLRF   03
03BA6:  ADDLW  13
03BA8:  MOVWF  FE9
03BAA:  MOVLW  03
03BAC:  ADDWFC 03,W
03BAE:  MOVWF  FEA
03BB0:  MOVFF  FEA,584
03BB4:  MOVFF  FE9,583
03BB8:  CLRF   x88
03BBA:  MOVLW  0F
03BBC:  MOVWF  x87
03BBE:  MOVLW  42
03BC0:  MOVWF  x86
03BC2:  MOVLW  40
03BC4:  MOVWF  x85
03BC6:  CLRF   x8C
03BC8:  CLRF   x8B
03BCA:  CLRF   x8A
03BCC:  MOVFF  30A,589
03BD0:  MOVLB  0
03BD2:  RCALL  3426
03BD4:  MOVFF  584,FEA
03BD8:  MOVFF  583,FE9
03BDC:  MOVFF  03,588
03BE0:  MOVFF  02,587
03BE4:  MOVFF  01,586
03BE8:  MOVFF  00,585
03BEC:  MOVFF  FEA,58A
03BF0:  MOVFF  FE9,589
03BF4:  BSF    FD8.1
03BF6:  MOVFF  30E,598
03BFA:  MOVFF  30D,597
03BFE:  MOVFF  30C,596
03C02:  MOVFF  30B,595
03C06:  MOVFF  312,59C
03C0A:  MOVFF  311,59B
03C0E:  MOVFF  310,59A
03C12:  MOVFF  30F,599
03C16:  CALL   31AE
03C1A:  MOVFF  58A,FEA
03C1E:  MOVFF  589,FE9
03C22:  MOVFF  03,58E
03C26:  MOVFF  02,58D
03C2A:  MOVFF  01,58C
03C2E:  MOVFF  00,58B
03C32:  MOVLB  5
03C34:  CLRF   x90
03C36:  MOVFF  580,58F
03C3A:  MOVLB  0
03C3C:  CALL   3178
03C40:  MOVFF  03,592
03C44:  MOVFF  02,591
03C48:  MOVFF  01,590
03C4C:  MOVFF  00,58F
03C50:  MOVFF  58E,596
03C54:  MOVFF  58D,595
03C58:  MOVFF  58C,594
03C5C:  MOVFF  58B,593
03C60:  CALL   2F24
03C64:  MOVFF  03,592
03C68:  MOVFF  02,591
03C6C:  MOVFF  01,590
03C70:  MOVFF  00,58F
03C74:  MOVFF  FEA,594
03C78:  MOVFF  FE9,593
03C7C:  BCF    FD8.1
03C7E:  MOVFF  03,598
03C82:  MOVFF  02,597
03C86:  MOVFF  01,596
03C8A:  MOVFF  00,595
03C8E:  MOVFF  312,59C
03C92:  MOVFF  311,59B
03C96:  MOVFF  310,59A
03C9A:  MOVFF  30F,599
03C9E:  CALL   31AE
03CA2:  MOVFF  594,FEA
03CA6:  MOVFF  593,FE9
03CAA:  MOVFF  03,592
03CAE:  MOVFF  02,591
03CB2:  MOVFF  01,590
03CB6:  MOVFF  00,58F
03CBA:  MOVFF  588,598
03CBE:  MOVFF  587,597
03CC2:  MOVFF  586,596
03CC6:  MOVFF  585,595
03CCA:  CALL   3482
03CCE:  MOVFF  03,598
03CD2:  MOVFF  02,597
03CD6:  MOVFF  01,596
03CDA:  MOVFF  00,595
03CDE:  MOVFF  592,59C
03CE2:  MOVFF  591,59B
03CE6:  MOVFF  590,59A
03CEA:  MOVFF  58F,599
03CEE:  CALL   301A
03CF2:  MOVFF  03,598
03CF6:  MOVFF  02,597
03CFA:  MOVFF  01,596
03CFE:  MOVFF  00,595
03D02:  CALL   34BA
03D06:  MOVFF  00,FEF
03D0A:  MOVFF  01,FEC
03D0E:  MOVFF  02,FEC
03D12:  MOVFF  03,FEC
....................         StepbyF_y[i-1] = 2*TbyF/Ts_y[i-1]; 
03D16:  MOVLW  01
03D18:  MOVLB  5
03D1A:  SUBWF  x80,W
03D1C:  MULLW  04
03D1E:  MOVF   FF3,W
03D20:  CLRF   03
03D22:  ADDLW  63
03D24:  MOVWF  01
03D26:  MOVLW  03
03D28:  ADDWFC 03,F
03D2A:  MOVFF  01,581
03D2E:  MOVFF  03,582
03D32:  CLRF   x92
03D34:  CLRF   x91
03D36:  CLRF   x90
03D38:  MOVLW  80
03D3A:  MOVWF  x8F
03D3C:  MOVFF  57F,596
03D40:  MOVFF  57E,595
03D44:  MOVFF  57D,594
03D48:  MOVFF  57C,593
03D4C:  MOVLB  0
03D4E:  CALL   2F24
03D52:  MOVFF  03,586
03D56:  MOVFF  02,585
03D5A:  MOVFF  01,584
03D5E:  MOVFF  00,583
03D62:  MOVLW  01
03D64:  MOVLB  5
03D66:  SUBWF  x80,W
03D68:  MULLW  04
03D6A:  MOVF   FF3,W
03D6C:  CLRF   03
03D6E:  ADDLW  13
03D70:  MOVWF  FE9
03D72:  MOVLW  03
03D74:  ADDWFC 03,W
03D76:  MOVWF  FEA
03D78:  MOVFF  FEF,00
03D7C:  MOVFF  FEC,01
03D80:  MOVFF  FEC,02
03D84:  MOVFF  FEC,03
03D88:  MOVFF  03,598
03D8C:  MOVFF  02,597
03D90:  MOVFF  01,596
03D94:  MOVFF  00,595
03D98:  MOVLB  0
03D9A:  CALL   3482
03D9E:  MOVFF  586,598
03DA2:  MOVFF  585,597
03DA6:  MOVFF  584,596
03DAA:  MOVFF  583,595
03DAE:  MOVFF  03,59C
03DB2:  MOVFF  02,59B
03DB6:  MOVFF  01,59A
03DBA:  MOVFF  00,599
03DBE:  CALL   301A
03DC2:  MOVFF  03,598
03DC6:  MOVFF  02,597
03DCA:  MOVFF  01,596
03DCE:  MOVFF  00,595
03DD2:  CALL   34BA
03DD6:  MOVFF  582,FEA
03DDA:  MOVFF  581,FE9
03DDE:  MOVFF  00,FEF
03DE2:  MOVFF  01,FEC
03DE6:  MOVFF  02,FEC
03DEA:  MOVFF  03,FEC
....................         total_acc_step_y += StepbyF_y[i-1]; 
03DEE:  MOVLW  01
03DF0:  MOVLB  5
03DF2:  SUBWF  x80,W
03DF4:  MULLW  04
03DF6:  MOVF   FF3,W
03DF8:  CLRF   03
03DFA:  ADDLW  63
03DFC:  MOVWF  FE9
03DFE:  MOVLW  03
03E00:  ADDWFC 03,W
03E02:  MOVWF  FEA
03E04:  MOVFF  FEF,00
03E08:  MOVFF  FEC,01
03E0C:  MOVFF  FEC,02
03E10:  MOVFF  FEC,03
03E14:  MOVF   00,W
03E16:  MOVLB  3
03E18:  ADDWF  xB3,F
03E1A:  MOVF   01,W
03E1C:  ADDWFC xB4,F
....................         Ts_y[i-1] = Ts_y[i-1]/(8*0.2*2);//Tempo/(prescale*ciclodemaquina*metadedociclo) 
03E1E:  MOVLW  01
03E20:  MOVLB  5
03E22:  SUBWF  x80,W
03E24:  MULLW  04
03E26:  MOVF   FF3,W
03E28:  CLRF   03
03E2A:  ADDLW  13
03E2C:  MOVWF  01
03E2E:  MOVLW  03
03E30:  ADDWFC 03,F
03E32:  MOVFF  01,581
03E36:  MOVFF  03,582
03E3A:  MOVLW  01
03E3C:  SUBWF  x80,W
03E3E:  MULLW  04
03E40:  MOVF   FF3,W
03E42:  CLRF   03
03E44:  ADDLW  13
03E46:  MOVWF  FE9
03E48:  MOVLW  03
03E4A:  ADDWFC 03,W
03E4C:  MOVWF  FEA
03E4E:  MOVFF  FEF,583
03E52:  MOVFF  FEC,584
03E56:  MOVFF  FEC,585
03E5A:  MOVFF  FEC,586
03E5E:  MOVFF  586,598
03E62:  MOVFF  585,597
03E66:  MOVFF  584,596
03E6A:  MOVFF  583,595
03E6E:  MOVLB  0
03E70:  CALL   3482
03E74:  MOVFF  03,598
03E78:  MOVFF  02,597
03E7C:  MOVFF  01,596
03E80:  MOVFF  00,595
03E84:  MOVLW  CD
03E86:  MOVLB  5
03E88:  MOVWF  x9C
03E8A:  MOVLW  CC
03E8C:  MOVWF  x9B
03E8E:  MOVLW  4C
03E90:  MOVWF  x9A
03E92:  MOVLW  80
03E94:  MOVWF  x99
03E96:  MOVLB  0
03E98:  CALL   301A
03E9C:  MOVFF  03,598
03EA0:  MOVFF  02,597
03EA4:  MOVFF  01,596
03EA8:  MOVFF  00,595
03EAC:  CALL   34BA
03EB0:  MOVFF  582,FEA
03EB4:  MOVFF  581,FE9
03EB8:  MOVFF  00,FEF
03EBC:  MOVFF  01,FEC
03EC0:  MOVFF  02,FEC
03EC4:  MOVFF  03,FEC
03EC8:  MOVLB  5
03ECA:  INCF   x80,F
03ECC:  BRA    3B90
03ECE:  MOVLB  3
....................     } 
03ED0:  MOVLB  0
03ED2:  GOTO   DA12 (RETURN)
.................... } 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Movimento Motor"> 
.................... void motor_stop_y(){ 
....................     step_no_y = step_down_y; 
....................     ramp_sts_y = ramp_down; 
.................... } 
....................  
.................... void motor_disable_y(){ 
....................     output_high(enable_y); 
....................     disable_interrupts(INT_TIMER1); 
.................... } 
....................  
.................... void motor_run_y(int32 pos_new, int velocidade) { // set up to drive motor to pos_new (absolute step#) 
....................     vel_y = velocidade; 
*
06622:  MOVFF  580,3C5
....................     total_acc_step_y = 0; 
06626:  MOVLB  3
06628:  CLRF   xB4
0662A:  CLRF   xB3
....................      
....................     if (pos_new < motor_pos_y) // get dir_yection & #steps 
0662C:  MOVFF  205,00
06630:  MOVFF  206,01
06634:  CLRF   02
06636:  CLRF   03
06638:  BTFSS  01.7
0663A:  BRA    6640
0663C:  DECF   02,F
0663E:  DECF   03,F
06640:  BTFSC  03.7
06642:  BRA    66B2
06644:  MOVLB  5
06646:  MOVF   x7F,W
06648:  SUBWF  03,W
0664A:  BTFSC  FD8.0
0664C:  BRA    6652
0664E:  MOVLB  3
06650:  BRA    66B2
06652:  BNZ   667C
06654:  MOVF   x7E,W
06656:  SUBWF  02,W
06658:  BTFSC  FD8.0
0665A:  BRA    6660
0665C:  MOVLB  3
0665E:  BRA    66B2
06660:  BNZ   667C
06662:  MOVF   x7D,W
06664:  SUBWF  01,W
06666:  BTFSC  FD8.0
06668:  BRA    666E
0666A:  MOVLB  3
0666C:  BRA    66B2
0666E:  BNZ   667C
06670:  MOVF   00,W
06672:  SUBWF  x7C,W
06674:  BTFSS  FD8.0
06676:  BRA    667C
06678:  MOVLB  3
0667A:  BRA    66B2
....................     { 
....................         output_low(dir_y); 
0667C:  BCF    F94.1
0667E:  BCF    F8B.1
....................         move_y = motor_pos_y - pos_new; 
06680:  MOVFF  205,00
06684:  MOVFF  206,01
06688:  CLRF   02
0668A:  CLRF   03
0668C:  BTFSS  01.7
0668E:  BRA    6694
06690:  DECF   02,F
06692:  DECF   03,F
06694:  MOVF   x7C,W
06696:  SUBWF  00,F
06698:  MOVF   x7D,W
0669A:  SUBWFB 01,F
0669C:  MOVF   x7E,W
0669E:  SUBWFB 02,F
066A0:  MOVF   x7F,W
066A2:  SUBWFB 03,F
066A4:  MOVFF  01,3BD
066A8:  MOVFF  00,3BC
....................         pos_inc_y = -1; 
066AC:  MOVLB  3
066AE:  SETF   xB5
....................     } else if (pos_new != motor_pos_y) { 
066B0:  BRA    6722
066B2:  MOVFF  205,00
066B6:  MOVFF  206,01
066BA:  CLRF   02
066BC:  CLRF   03
066BE:  BTFSS  01.7
066C0:  BRA    66C6
066C2:  DECF   02,F
066C4:  DECF   03,F
066C6:  MOVF   00,W
066C8:  MOVLB  5
066CA:  SUBWF  x7C,W
066CC:  BNZ   66E0
066CE:  MOVF   01,W
066D0:  SUBWF  x7D,W
066D2:  BNZ   66E0
066D4:  MOVF   02,W
066D6:  SUBWF  x7E,W
066D8:  BNZ   66E0
066DA:  MOVF   03,W
066DC:  SUBWF  x7F,W
066DE:  BZ    671E
....................         output_high(dir_y); 
066E0:  BCF    F94.1
066E2:  BSF    F8B.1
....................         move_y = pos_new - motor_pos_y; 
066E4:  MOVFF  205,00
066E8:  MOVFF  206,01
066EC:  CLRF   02
066EE:  CLRF   03
066F0:  BTFSS  01.7
066F2:  BRA    66F8
066F4:  DECF   02,F
066F6:  DECF   03,F
066F8:  MOVF   00,W
066FA:  SUBWF  x7C,W
066FC:  MOVWF  00
066FE:  MOVF   01,W
06700:  SUBWFB x7D,W
06702:  MOVWF  01
06704:  MOVF   02,W
06706:  SUBWFB x7E,W
06708:  MOVF   03,W
0670A:  SUBWFB x7F,W
0670C:  MOVFF  01,3BD
06710:  MOVFF  00,3BC
....................         pos_inc_y = 1; 
06714:  MOVLW  01
06716:  MOVLB  3
06718:  MOVWF  xB5
....................     } else return; 
0671A:  BRA    6722
0671C:  MOVLB  5
0671E:  BRA    6808
06720:  MOVLB  3
....................  
....................     for(int j = 0; j <= velocidade;j++) 
06722:  MOVLB  5
06724:  CLRF   x81
06726:  MOVF   x81,W
06728:  SUBWF  x80,W
0672A:  BNC   675E
....................     { 
....................         total_acc_step_y += StepbyF_y[j]; 
0672C:  MOVF   x81,W
0672E:  MULLW  04
06730:  MOVF   FF3,W
06732:  CLRF   03
06734:  ADDLW  63
06736:  MOVWF  FE9
06738:  MOVLW  03
0673A:  ADDWFC 03,W
0673C:  MOVWF  FEA
0673E:  MOVFF  FEF,00
06742:  MOVFF  FEC,01
06746:  MOVFF  FEC,02
0674A:  MOVFF  FEC,03
0674E:  MOVF   00,W
06750:  MOVLB  3
06752:  ADDWF  xB3,F
06754:  MOVF   01,W
06756:  ADDWFC xB4,F
06758:  MOVLB  5
0675A:  INCF   x81,F
0675C:  BRA    6726
....................     } 
....................     if (move_y > 2 * total_acc_step_y) { 
0675E:  BCF    FD8.0
06760:  MOVLB  3
06762:  RLCF   xB3,W
06764:  MOVWF  02
06766:  RLCF   xB4,W
06768:  MOVWF  03
0676A:  MOVFF  02,01
0676E:  MOVF   03,W
06770:  SUBWF  xBD,W
06772:  BNC   6792
06774:  BNZ   677C
06776:  MOVF   xBC,W
06778:  SUBWF  01,W
0677A:  BC    6792
....................         midpt_y = total_acc_step_y; 
0677C:  MOVFF  3B4,3BF
06780:  MOVFF  3B3,3BE
....................         step_down_y = move_y - total_acc_step_y; 
06784:  MOVF   xB3,W
06786:  SUBWF  xBC,W
06788:  MOVWF  xBA
0678A:  MOVF   xB4,W
0678C:  SUBWFB xBD,W
0678E:  MOVWF  xBB
....................     }  
06790:  BRA    67BC
....................     else 
....................     { 
....................         midpt_y = (move_y - 1) >> 1; 
06792:  MOVLW  01
06794:  SUBWF  xBC,W
06796:  MOVLB  5
06798:  MOVWF  x82
0679A:  MOVLW  00
0679C:  MOVLB  3
0679E:  SUBWFB xBD,W
067A0:  MOVLB  5
067A2:  MOVWF  x83
067A4:  BCF    FD8.0
067A6:  RRCF   x83,W
067A8:  MOVLB  3
067AA:  MOVWF  xBF
067AC:  MOVLB  5
067AE:  RRCF   x82,W
067B0:  MOVLB  3
067B2:  MOVWF  xBE
....................         step_down_y = midpt_y; 
067B4:  MOVFF  3BF,3BB
067B8:  MOVFF  3BE,3BA
....................     } 
....................     step_no_y = 0; 
067BC:  CLRF   xB9
067BE:  CLRF   xB8
....................     step_acumulado_y = 0; 
067C0:  CLRF   xC3
067C2:  CLRF   xC2
067C4:  CLRF   xC1
067C6:  CLRF   xC0
....................     atual_frequencia_y = 0; 
067C8:  CLRF   xC4
....................     ramp_sts_y = ramp_up; // start ramp state-machine 
067CA:  MOVLW  01
067CC:  MOVWF  xB6
....................     run_flg_y = TRUE; 
067CE:  MOVLB  2
067D0:  BSF    x0B.7
....................     output_low(enable_y); 
067D2:  BCF    F94.0
067D4:  BCF    F8B.0
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
067D6:  MOVLW  B5
067D8:  MOVWF  FCD
....................     set_timer1(65535 - Ts_y[0]); 
067DA:  MOVLW  FF
067DC:  BSF    FD8.0
067DE:  MOVLB  3
067E0:  SUBFWB x13,W
067E2:  MOVLB  5
067E4:  MOVWF  x82
067E6:  MOVLW  FF
067E8:  MOVLB  3
067EA:  SUBFWB x14,W
067EC:  MOVLB  5
067EE:  MOVWF  x83
067F0:  MOVLW  00
067F2:  MOVLB  3
067F4:  SUBFWB x15,W
067F6:  MOVLW  00
067F8:  MOVLB  3
067FA:  SUBFWB x16,W
067FC:  MOVLB  5
067FE:  MOVFF  583,FCF
06802:  MOVFF  582,FCE
....................     enable_interrupts(INT_TIMER1); 
06806:  BSF    F9D.0
06808:  MOVLB  0
0680A:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_subida_y() { 
....................     if (atual_frequencia_y == 0) { 
*
01814:  MOVLB  3
01816:  MOVF   xC4,F
01818:  BTFSS  FD8.2
0181A:  BRA    194A
....................         if (step_no_y == StepbyF_y[atual_frequencia_y]) { 
0181C:  MOVF   xC4,W
0181E:  MULLW  04
01820:  MOVF   FF3,W
01822:  CLRF   03
01824:  ADDLW  63
01826:  MOVWF  FE9
01828:  MOVLW  03
0182A:  ADDWFC 03,W
0182C:  MOVWF  FEA
0182E:  MOVFF  FEF,00
01832:  MOVFF  FEC,01
01836:  MOVFF  FEC,02
0183A:  MOVFF  FEC,03
0183E:  MOVF   00,W
01840:  SUBWF  xB8,W
01842:  BNZ   1904
01844:  MOVF   01,W
01846:  SUBWF  xB9,W
01848:  BNZ   1904
0184A:  MOVF   02,F
0184C:  BNZ   1904
0184E:  MOVF   03,F
01850:  BNZ   1904
....................             step_acumulado_y += StepbyF_y[atual_frequencia_y] + StepbyF_y[atual_frequencia_y + 1]; 
01852:  MOVF   xC4,W
01854:  MULLW  04
01856:  MOVF   FF3,W
01858:  CLRF   03
0185A:  ADDLW  63
0185C:  MOVWF  FE9
0185E:  MOVLW  03
01860:  ADDWFC 03,W
01862:  MOVWF  FEA
01864:  MOVFF  FEF,5A5
01868:  MOVFF  FEC,5A6
0186C:  MOVFF  FEC,5A7
01870:  MOVFF  FEC,5A8
01874:  MOVLW  01
01876:  ADDWF  xC4,W
01878:  MULLW  04
0187A:  MOVF   FF3,W
0187C:  CLRF   03
0187E:  ADDLW  63
01880:  MOVWF  FE9
01882:  MOVLW  03
01884:  ADDWFC 03,W
01886:  MOVWF  FEA
01888:  MOVFF  FEF,00
0188C:  MOVFF  FEC,01
01890:  MOVFF  FEC,02
01894:  MOVFF  FEC,03
01898:  MOVLB  5
0189A:  MOVF   xA5,W
0189C:  ADDWF  00,F
0189E:  MOVF   xA6,W
018A0:  ADDWFC 01,F
018A2:  MOVF   xA7,W
018A4:  ADDWFC 02,F
018A6:  MOVF   xA8,W
018A8:  ADDWFC 03,F
018AA:  MOVF   00,W
018AC:  MOVLB  3
018AE:  ADDWF  xC0,F
018B0:  MOVF   01,W
018B2:  ADDWFC xC1,F
018B4:  MOVF   02,W
018B6:  ADDWFC xC2,F
018B8:  MOVF   03,W
018BA:  ADDWFC xC3,F
....................             atual_frequencia_y++; 
018BC:  INCF   xC4,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
018BE:  MOVF   xC4,W
018C0:  MULLW  04
018C2:  MOVF   FF3,W
018C4:  CLRF   03
018C6:  ADDLW  13
018C8:  MOVWF  FE9
018CA:  MOVLW  03
018CC:  ADDWFC 03,W
018CE:  MOVWF  FEA
018D0:  MOVFF  FEF,00
018D4:  MOVFF  FEC,01
018D8:  MOVFF  FEC,02
018DC:  MOVFF  FEC,03
018E0:  MOVLW  FF
018E2:  BSF    FD8.0
018E4:  SUBFWB 00,W
018E6:  MOVLB  5
018E8:  MOVWF  xA5
018EA:  MOVLW  FF
018EC:  SUBFWB 01,W
018EE:  MOVWF  xA6
018F0:  MOVLW  00
018F2:  SUBFWB 02,W
018F4:  MOVLW  00
018F6:  SUBFWB 03,W
018F8:  MOVFF  5A6,FCF
018FC:  MOVFF  5A5,FCE
....................         } else { 
01900:  BRA    1946
01902:  MOVLB  3
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01904:  MOVF   xC4,W
01906:  MULLW  04
01908:  MOVF   FF3,W
0190A:  CLRF   03
0190C:  ADDLW  13
0190E:  MOVWF  FE9
01910:  MOVLW  03
01912:  ADDWFC 03,W
01914:  MOVWF  FEA
01916:  MOVFF  FEF,00
0191A:  MOVFF  FEC,01
0191E:  MOVFF  FEC,02
01922:  MOVFF  FEC,03
01926:  MOVLW  FF
01928:  BSF    FD8.0
0192A:  SUBFWB 00,W
0192C:  MOVLB  5
0192E:  MOVWF  xA5
01930:  MOVLW  FF
01932:  SUBFWB 01,W
01934:  MOVWF  xA6
01936:  MOVLW  00
01938:  SUBFWB 02,W
0193A:  MOVLW  00
0193C:  SUBFWB 03,W
0193E:  MOVFF  5A6,FCF
01942:  MOVFF  5A5,FCE
....................         } 
....................     } else if (atual_frequencia_y == vel_y) { 
01946:  BRA    1A66
01948:  MOVLB  3
0194A:  MOVF   xC5,W
0194C:  SUBWF  xC4,W
0194E:  BNZ   1996
....................         set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01950:  MOVF   xC4,W
01952:  MULLW  04
01954:  MOVF   FF3,W
01956:  CLRF   03
01958:  ADDLW  13
0195A:  MOVWF  FE9
0195C:  MOVLW  03
0195E:  ADDWFC 03,W
01960:  MOVWF  FEA
01962:  MOVFF  FEF,00
01966:  MOVFF  FEC,01
0196A:  MOVFF  FEC,02
0196E:  MOVFF  FEC,03
01972:  MOVLW  FF
01974:  BSF    FD8.0
01976:  SUBFWB 00,W
01978:  MOVLB  5
0197A:  MOVWF  xA5
0197C:  MOVLW  FF
0197E:  SUBFWB 01,W
01980:  MOVWF  xA6
01982:  MOVLW  00
01984:  SUBFWB 02,W
01986:  MOVLW  00
01988:  SUBFWB 03,W
0198A:  MOVFF  5A6,FCF
0198E:  MOVFF  5A5,FCE
....................     } else { 
01992:  BRA    1A66
01994:  MOVLB  3
....................         if (step_no_y == step_acumulado_y) { 
01996:  MOVF   xC0,W
01998:  SUBWF  xB8,W
0199A:  BNZ   1A24
0199C:  MOVF   xC1,W
0199E:  SUBWF  xB9,W
019A0:  BNZ   1A24
019A2:  MOVF   xC2,F
019A4:  BNZ   1A24
019A6:  MOVF   xC3,F
019A8:  BNZ   1A24
....................             atual_frequencia_y++; 
019AA:  INCF   xC4,F
....................             step_acumulado_y += StepbyF_y[atual_frequencia_y]; 
019AC:  MOVF   xC4,W
019AE:  MULLW  04
019B0:  MOVF   FF3,W
019B2:  CLRF   03
019B4:  ADDLW  63
019B6:  MOVWF  FE9
019B8:  MOVLW  03
019BA:  ADDWFC 03,W
019BC:  MOVWF  FEA
019BE:  MOVFF  FEF,00
019C2:  MOVFF  FEC,01
019C6:  MOVFF  FEC,02
019CA:  MOVFF  FEC,03
019CE:  MOVF   00,W
019D0:  ADDWF  xC0,F
019D2:  MOVF   01,W
019D4:  ADDWFC xC1,F
019D6:  MOVF   02,W
019D8:  ADDWFC xC2,F
019DA:  MOVF   03,W
019DC:  ADDWFC xC3,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
019DE:  MOVF   xC4,W
019E0:  MULLW  04
019E2:  MOVF   FF3,W
019E4:  CLRF   03
019E6:  ADDLW  13
019E8:  MOVWF  FE9
019EA:  MOVLW  03
019EC:  ADDWFC 03,W
019EE:  MOVWF  FEA
019F0:  MOVFF  FEF,00
019F4:  MOVFF  FEC,01
019F8:  MOVFF  FEC,02
019FC:  MOVFF  FEC,03
01A00:  MOVLW  FF
01A02:  BSF    FD8.0
01A04:  SUBFWB 00,W
01A06:  MOVLB  5
01A08:  MOVWF  xA5
01A0A:  MOVLW  FF
01A0C:  SUBFWB 01,W
01A0E:  MOVWF  xA6
01A10:  MOVLW  00
01A12:  SUBFWB 02,W
01A14:  MOVLW  00
01A16:  SUBFWB 03,W
01A18:  MOVFF  5A6,FCF
01A1C:  MOVFF  5A5,FCE
....................         } else { 
01A20:  BRA    1A66
01A22:  MOVLB  3
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01A24:  MOVF   xC4,W
01A26:  MULLW  04
01A28:  MOVF   FF3,W
01A2A:  CLRF   03
01A2C:  ADDLW  13
01A2E:  MOVWF  FE9
01A30:  MOVLW  03
01A32:  ADDWFC 03,W
01A34:  MOVWF  FEA
01A36:  MOVFF  FEF,00
01A3A:  MOVFF  FEC,01
01A3E:  MOVFF  FEC,02
01A42:  MOVFF  FEC,03
01A46:  MOVLW  FF
01A48:  BSF    FD8.0
01A4A:  SUBFWB 00,W
01A4C:  MOVLB  5
01A4E:  MOVWF  xA5
01A50:  MOVLW  FF
01A52:  SUBFWB 01,W
01A54:  MOVWF  xA6
01A56:  MOVLW  00
01A58:  SUBFWB 02,W
01A5A:  MOVLW  00
01A5C:  SUBFWB 03,W
01A5E:  MOVFF  5A6,FCF
01A62:  MOVFF  5A5,FCE
....................         } 
....................         break; 
....................     } 
01A66:  MOVLB  0
01A68:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_descida_y() { 
....................     if (atual_frequencia_y == 0) { 
01A6A:  MOVLB  3
01A6C:  MOVF   xC4,F
01A6E:  BNZ   1AB6
....................         set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01A70:  MOVF   xC4,W
01A72:  MULLW  04
01A74:  MOVF   FF3,W
01A76:  CLRF   03
01A78:  ADDLW  13
01A7A:  MOVWF  FE9
01A7C:  MOVLW  03
01A7E:  ADDWFC 03,W
01A80:  MOVWF  FEA
01A82:  MOVFF  FEF,00
01A86:  MOVFF  FEC,01
01A8A:  MOVFF  FEC,02
01A8E:  MOVFF  FEC,03
01A92:  MOVLW  FF
01A94:  BSF    FD8.0
01A96:  SUBFWB 00,W
01A98:  MOVLB  5
01A9A:  MOVWF  xA5
01A9C:  MOVLW  FF
01A9E:  SUBFWB 01,W
01AA0:  MOVWF  xA6
01AA2:  MOVLW  00
01AA4:  SUBFWB 02,W
01AA6:  MOVLW  00
01AA8:  SUBFWB 03,W
01AAA:  MOVFF  5A6,FCF
01AAE:  MOVFF  5A5,FCE
....................     }  
01AB2:  BRA    1CEE
01AB4:  MOVLB  3
....................     else if (atual_frequencia_y == vel_y) { 
01AB6:  MOVF   xC5,W
01AB8:  SUBWF  xC4,W
01ABA:  BTFSS  FD8.2
01ABC:  BRA    1C1E
....................         if (step_no_y == (step_down_y + StepbyF_y[atual_frequencia_y])) { 
01ABE:  MOVF   xC4,W
01AC0:  MULLW  04
01AC2:  MOVF   FF3,W
01AC4:  CLRF   03
01AC6:  ADDLW  63
01AC8:  MOVWF  FE9
01ACA:  MOVLW  03
01ACC:  ADDWFC 03,W
01ACE:  MOVWF  FEA
01AD0:  MOVFF  FEF,00
01AD4:  MOVFF  FEC,01
01AD8:  MOVFF  FEC,02
01ADC:  MOVFF  FEC,03
01AE0:  MOVF   xBA,W
01AE2:  ADDWF  00,F
01AE4:  MOVF   xBB,W
01AE6:  ADDWFC 01,F
01AE8:  MOVLW  00
01AEA:  ADDWFC 02,F
01AEC:  ADDWFC 03,F
01AEE:  MOVF   00,W
01AF0:  SUBWF  xB8,W
01AF2:  BNZ   1BD8
01AF4:  MOVF   01,W
01AF6:  SUBWF  xB9,W
01AF8:  BNZ   1BD8
01AFA:  MOVF   02,F
01AFC:  BNZ   1BD8
01AFE:  MOVF   03,F
01B00:  BNZ   1BD8
....................             step_acumulado_y = step_down_y + StepbyF_y[atual_frequencia_y] + StepbyF_y[atual_frequencia_y - 1]; 
01B02:  MOVF   xC4,W
01B04:  MULLW  04
01B06:  MOVF   FF3,W
01B08:  CLRF   03
01B0A:  ADDLW  63
01B0C:  MOVWF  FE9
01B0E:  MOVLW  03
01B10:  ADDWFC 03,W
01B12:  MOVWF  FEA
01B14:  MOVFF  FEF,00
01B18:  MOVFF  FEC,01
01B1C:  MOVFF  FEC,02
01B20:  MOVFF  FEC,03
01B24:  MOVF   00,W
01B26:  ADDWF  xBA,W
01B28:  MOVLB  5
01B2A:  MOVWF  xA5
01B2C:  MOVF   01,W
01B2E:  MOVLB  3
01B30:  ADDWFC xBB,W
01B32:  MOVLB  5
01B34:  MOVWF  xA6
01B36:  MOVLW  00
01B38:  ADDWFC 02,W
01B3A:  MOVWF  xA7
01B3C:  MOVLW  00
01B3E:  ADDWFC 03,W
01B40:  MOVWF  xA8
01B42:  MOVLW  01
01B44:  MOVLB  3
01B46:  SUBWF  xC4,W
01B48:  MULLW  04
01B4A:  MOVF   FF3,W
01B4C:  CLRF   03
01B4E:  ADDLW  63
01B50:  MOVWF  FE9
01B52:  MOVLW  03
01B54:  ADDWFC 03,W
01B56:  MOVWF  FEA
01B58:  MOVFF  FEF,00
01B5C:  MOVFF  FEC,01
01B60:  MOVFF  FEC,02
01B64:  MOVFF  FEC,03
01B68:  MOVF   00,W
01B6A:  MOVLB  5
01B6C:  ADDWF  xA5,W
01B6E:  MOVLB  3
01B70:  MOVWF  xC0
01B72:  MOVF   01,W
01B74:  MOVLB  5
01B76:  ADDWFC xA6,W
01B78:  MOVLB  3
01B7A:  MOVWF  xC1
01B7C:  MOVF   02,W
01B7E:  MOVLB  5
01B80:  ADDWFC xA7,W
01B82:  MOVLB  3
01B84:  MOVWF  xC2
01B86:  MOVF   03,W
01B88:  MOVLB  5
01B8A:  ADDWFC xA8,W
01B8C:  MOVLB  3
01B8E:  MOVWF  xC3
....................             atual_frequencia_y--; 
01B90:  DECF   xC4,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01B92:  MOVF   xC4,W
01B94:  MULLW  04
01B96:  MOVF   FF3,W
01B98:  CLRF   03
01B9A:  ADDLW  13
01B9C:  MOVWF  FE9
01B9E:  MOVLW  03
01BA0:  ADDWFC 03,W
01BA2:  MOVWF  FEA
01BA4:  MOVFF  FEF,00
01BA8:  MOVFF  FEC,01
01BAC:  MOVFF  FEC,02
01BB0:  MOVFF  FEC,03
01BB4:  MOVLW  FF
01BB6:  BSF    FD8.0
01BB8:  SUBFWB 00,W
01BBA:  MOVLB  5
01BBC:  MOVWF  xA5
01BBE:  MOVLW  FF
01BC0:  SUBFWB 01,W
01BC2:  MOVWF  xA6
01BC4:  MOVLW  00
01BC6:  SUBFWB 02,W
01BC8:  MOVLW  00
01BCA:  SUBFWB 03,W
01BCC:  MOVFF  5A6,FCF
01BD0:  MOVFF  5A5,FCE
....................         } else { 
01BD4:  BRA    1C1A
01BD6:  MOVLB  3
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01BD8:  MOVF   xC4,W
01BDA:  MULLW  04
01BDC:  MOVF   FF3,W
01BDE:  CLRF   03
01BE0:  ADDLW  13
01BE2:  MOVWF  FE9
01BE4:  MOVLW  03
01BE6:  ADDWFC 03,W
01BE8:  MOVWF  FEA
01BEA:  MOVFF  FEF,00
01BEE:  MOVFF  FEC,01
01BF2:  MOVFF  FEC,02
01BF6:  MOVFF  FEC,03
01BFA:  MOVLW  FF
01BFC:  BSF    FD8.0
01BFE:  SUBFWB 00,W
01C00:  MOVLB  5
01C02:  MOVWF  xA5
01C04:  MOVLW  FF
01C06:  SUBFWB 01,W
01C08:  MOVWF  xA6
01C0A:  MOVLW  00
01C0C:  SUBFWB 02,W
01C0E:  MOVLW  00
01C10:  SUBFWB 03,W
01C12:  MOVFF  5A6,FCF
01C16:  MOVFF  5A5,FCE
....................         } 
....................     } else { 
01C1A:  BRA    1CEE
01C1C:  MOVLB  3
....................         if (step_no_y == step_acumulado_y) { 
01C1E:  MOVF   xC0,W
01C20:  SUBWF  xB8,W
01C22:  BNZ   1CAC
01C24:  MOVF   xC1,W
01C26:  SUBWF  xB9,W
01C28:  BNZ   1CAC
01C2A:  MOVF   xC2,F
01C2C:  BNZ   1CAC
01C2E:  MOVF   xC3,F
01C30:  BNZ   1CAC
....................             atual_frequencia_y--; 
01C32:  DECF   xC4,F
....................             step_acumulado_y += StepbyF_y[atual_frequencia_y]; 
01C34:  MOVF   xC4,W
01C36:  MULLW  04
01C38:  MOVF   FF3,W
01C3A:  CLRF   03
01C3C:  ADDLW  63
01C3E:  MOVWF  FE9
01C40:  MOVLW  03
01C42:  ADDWFC 03,W
01C44:  MOVWF  FEA
01C46:  MOVFF  FEF,00
01C4A:  MOVFF  FEC,01
01C4E:  MOVFF  FEC,02
01C52:  MOVFF  FEC,03
01C56:  MOVF   00,W
01C58:  ADDWF  xC0,F
01C5A:  MOVF   01,W
01C5C:  ADDWFC xC1,F
01C5E:  MOVF   02,W
01C60:  ADDWFC xC2,F
01C62:  MOVF   03,W
01C64:  ADDWFC xC3,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01C66:  MOVF   xC4,W
01C68:  MULLW  04
01C6A:  MOVF   FF3,W
01C6C:  CLRF   03
01C6E:  ADDLW  13
01C70:  MOVWF  FE9
01C72:  MOVLW  03
01C74:  ADDWFC 03,W
01C76:  MOVWF  FEA
01C78:  MOVFF  FEF,00
01C7C:  MOVFF  FEC,01
01C80:  MOVFF  FEC,02
01C84:  MOVFF  FEC,03
01C88:  MOVLW  FF
01C8A:  BSF    FD8.0
01C8C:  SUBFWB 00,W
01C8E:  MOVLB  5
01C90:  MOVWF  xA5
01C92:  MOVLW  FF
01C94:  SUBFWB 01,W
01C96:  MOVWF  xA6
01C98:  MOVLW  00
01C9A:  SUBFWB 02,W
01C9C:  MOVLW  00
01C9E:  SUBFWB 03,W
01CA0:  MOVFF  5A6,FCF
01CA4:  MOVFF  5A5,FCE
....................         } else { 
01CA8:  BRA    1CEE
01CAA:  MOVLB  3
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01CAC:  MOVF   xC4,W
01CAE:  MULLW  04
01CB0:  MOVF   FF3,W
01CB2:  CLRF   03
01CB4:  ADDLW  13
01CB6:  MOVWF  FE9
01CB8:  MOVLW  03
01CBA:  ADDWFC 03,W
01CBC:  MOVWF  FEA
01CBE:  MOVFF  FEF,00
01CC2:  MOVFF  FEC,01
01CC6:  MOVFF  FEC,02
01CCA:  MOVFF  FEC,03
01CCE:  MOVLW  FF
01CD0:  BSF    FD8.0
01CD2:  SUBFWB 00,W
01CD4:  MOVLB  5
01CD6:  MOVWF  xA5
01CD8:  MOVLW  FF
01CDA:  SUBFWB 01,W
01CDC:  MOVWF  xA6
01CDE:  MOVLW  00
01CE0:  SUBFWB 02,W
01CE2:  MOVLW  00
01CE4:  SUBFWB 03,W
01CE6:  MOVFF  5A6,FCF
01CEA:  MOVFF  5A5,FCE
....................         } 
....................     } 
01CEE:  MOVLB  0
01CF0:  GOTO   1D4C (RETURN)
.................... } 
....................  
.................... void movimenta_eixo_y() { 
....................      
....................     switch (ramp_sts_y) { 
01CF4:  MOVLB  3
01CF6:  MOVF   xB6,W
01CF8:  XORLW  01
01CFA:  MOVLB  0
01CFC:  BZ    1D08
01CFE:  XORLW  02
01D00:  BZ    1D4A
01D02:  XORLW  01
01D04:  BZ    1D66
01D06:  BRA    1D84
....................  
....................         case ramp_up: // accel 
....................             output_toggle(step_y); 
01D08:  BCF    F94.2
01D0A:  BTG    F8B.2
....................             rest_y = ~rest_y; 
01D0C:  MOVLB  3
01D0E:  BTG    xB7.0
....................             proximo_valor_subida_y(); 
01D10:  MOVLB  0
01D12:  RCALL  1814
....................             if (step_no_y == midpt_y) { // midpoint: decel 
01D14:  MOVLB  3
01D16:  MOVF   xBE,W
01D18:  SUBWF  xB8,W
01D1A:  BNZ   1D48
01D1C:  MOVF   xBF,W
01D1E:  SUBWF  xB9,W
01D20:  BNZ   1D48
....................                 if (move_y > 2 * total_acc_step_y) 
01D22:  BCF    FD8.0
01D24:  RLCF   xB3,W
01D26:  MOVWF  02
01D28:  RLCF   xB4,W
01D2A:  MOVWF  03
01D2C:  MOVFF  02,01
01D30:  MOVF   03,W
01D32:  SUBWF  xBD,W
01D34:  BNC   1D44
01D36:  BNZ   1D3E
01D38:  MOVF   xBC,W
01D3A:  SUBWF  01,W
01D3C:  BC    1D44
....................                     ramp_sts_y = ramp_max; 
01D3E:  MOVLW  02
01D40:  MOVWF  xB6
01D42:  BRA    1D48
....................                 else 
....................                     ramp_sts_y = ramp_down; 
01D44:  MOVLW  03
01D46:  MOVWF  xB6
....................             } 
....................             break; 
01D48:  BRA    1D92
....................  
....................         case ramp_down: // decel 
....................             proximo_valor_descida_y(); 
01D4A:  BRA    1A6A
....................             if (step_no_y == move_y) 
01D4C:  MOVLB  3
01D4E:  MOVF   xBC,W
01D50:  SUBWF  xB8,W
01D52:  BNZ   1D5E
01D54:  MOVF   xBD,W
01D56:  SUBWF  xB9,W
01D58:  BNZ   1D5E
....................                 ramp_sts_y = ramp_last; 
01D5A:  MOVLW  04
01D5C:  MOVWF  xB6
....................             output_toggle(step_y); 
01D5E:  BCF    F94.2
01D60:  BTG    F8B.2
....................             rest_y = ~rest_y; 
01D62:  BTG    xB7.0
....................             break; 
01D64:  BRA    1D92
....................  
....................         case ramp_max: // constant speed 
....................             proximo_valor_subida_y(); 
01D66:  RCALL  1814
....................             if (step_no_y == step_down_y) // start decel 
01D68:  MOVLB  3
01D6A:  MOVF   xBA,W
01D6C:  SUBWF  xB8,W
01D6E:  BNZ   1D7A
01D70:  MOVF   xBB,W
01D72:  SUBWF  xB9,W
01D74:  BNZ   1D7A
....................                 ramp_sts_y = ramp_down; 
01D76:  MOVLW  03
01D78:  MOVWF  xB6
....................             output_toggle(step_y); 
01D7A:  BCF    F94.2
01D7C:  BTG    F8B.2
....................             rest_y = ~rest_y; 
01D7E:  BTG    xB7.0
....................             break; 
01D80:  BRA    1D92
01D82:  MOVLB  0
....................  
....................         default: // last step: cleanup 
....................             ramp_sts_y = ramp_idle; 
01D84:  MOVLB  3
01D86:  CLRF   xB6
....................             stop_yf = FALSE; 
01D88:  BCF    xB7.1
....................             disable_interrupts(INT_TIMER1); 
01D8A:  BCF    F9D.0
....................             run_flg_y = FALSE; // move_y complete 
01D8C:  MOVLB  2
01D8E:  BCF    x0B.7
....................             break; 
01D90:  MOVLB  3
....................     } // switch (ramp_sts_y) 
....................     if (ramp_sts_y != ramp_idle) { 
01D92:  MOVF   xB6,F
01D94:  BZ    1DB2
....................         if (rest_y) { 
01D96:  BTFSS  xB7.0
01D98:  BRA    1DB2
....................             motor_pos_y += pos_inc_y; 
01D9A:  CLRF   03
01D9C:  MOVF   xB5,W
01D9E:  BTFSC  FE8.7
01DA0:  DECF   03,F
01DA2:  MOVLB  2
01DA4:  ADDWF  x05,F
01DA6:  MOVF   03,W
01DA8:  ADDWFC x06,F
....................             ++step_no_y; 
01DAA:  MOVLB  3
01DAC:  INCF   xB8,F
01DAE:  BTFSC  FD8.2
01DB0:  INCF   xB9,F
....................         } 
....................     } 
01DB2:  MOVLB  0
01DB4:  GOTO   1DBA (RETURN)
.................... } 
....................  
.................... void umpasso_y(int16 descanco, short dir) { 
....................     output_low(enable_y); 
....................     if (dir) { 
....................         output_high(dir_y); 
....................         motor_pos_y--; 
....................     } else { 
....................         output_low(dir_y); 
....................         motor_pos_y++; 
....................     } 
....................     output_high(step_y); 
....................     delay_us(descanco); 
....................     output_low(step_y); 
....................     delay_us(descanco); 
....................     //output_high(enable_y); 
.................... } 
....................  
.................... void zerar_y() { 
....................     while(le_Input(i_limite_y)==1){ 
....................         umpasso_y(600, FALSE); 
....................         delay_us(200); 
....................     } 
....................     while (le_Input(i_limite_y)==0){ 
....................         umpasso_y(900,TRUE); 
....................         delay_us(200); 
....................     } 
....................     while(le_Input(i_limite_y)==1){ 
....................         umpasso_y(1000, FALSE); 
....................         delay_us(200); 
....................     } 
....................     motor_pos_y = 0; 
....................     output_high(enable_y); 
.................... } 
.................... void medir_y(){ 
....................     while (le_Input(s_limite_y)==0){ 
....................         umpasso_y(900,FALSE); 
....................         delay_us(200); 
....................     } 
....................     while (le_Input(s_limite_y)==1){ 
....................         umpasso_y(900,TRUE); 
....................         delay_us(200); 
....................     } 
....................     max_posicao_y = motor_pos_y; 
....................     output_high(enable_y); 
.................... } 
.................... // </editor-fold> 
....................  
.................... #include "Axis_z.c" 
.................... // <editor-fold defaultstate="collapsed" desc="Valores que devem ser inseridos"> 
.................... float stepbyrev_z = 200; 
.................... float driver_u_step_z = 1; // caso o driver esteja em 400 
.................... float Leadscrew_z = 9; //redutor de voltas do motor 
.................... float Leadscrew_Pich_z = 150; //esse valor deve ser em mm/revoluo 
.................... float Vmax_z = 600; //esse valor deve ser em mm por segundo 
.................... float Amax_z = 300; //esse valor deve ser em mm por segundo 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Valores calculo rampa"> 
.................... float MMbyStep_z = 0; 
.................... int8 StepinAcc_z = 20; 
.................... float Fmax_z = 0; 
.................... int32 Ts_z[20]; 
.................... int32 StepbyF_z[20]; 
.................... int16 total_acc_step_z = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Flags e Controles de Movimento"> 
.................... signed int8 pos_inc_z = 0; 
.................... int8 ramp_sts_z = ramp_idle; 
.................... short run_flg_z = FALSE; 
.................... short rest_z = false; 
.................... int16 step_no_z = 0; 
.................... int16 step_down_z = 0; 
.................... int16 move_z = 0; 
.................... int16 midpt_z = 0; 
.................... int32 step_acumulado_z = 0; 
.................... int atual_frequencia_z = 0; 
.................... int vel_z = 19; 
.................... int16 max_posicao_z = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Pinos Motor"> 
.................... #DEFINE     i_limite_z            13 
.................... #DEFINE     s_limite_z            14 
....................  
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Inicializa Motor"> 
.................... void init_axis_z() { 
....................     set_tris_a(0x00); 
*
03ED6:  MOVLW  00
03ED8:  MOVWF  F92
....................     output_high(step_z); 
03EDA:  BCF    F92.5
03EDC:  BSF    F89.5
....................     output_high(enable_z); 
03EDE:  BCF    F92.3
03EE0:  BSF    F89.3
....................     output_high(dir_z); 
03EE2:  BCF    F92.4
03EE4:  BSF    F89.4
....................  
....................     MMbyStep_z = Leadscrew_Pich_z / (stepbyrev_z * driver_u_step_z * Leadscrew_z); 
03EE6:  MOVFF  3CB,592
03EEA:  MOVFF  3CA,591
03EEE:  MOVFF  3C9,590
03EF2:  MOVFF  3C8,58F
03EF6:  MOVFF  3CF,596
03EFA:  MOVFF  3CE,595
03EFE:  MOVFF  3CD,594
03F02:  MOVFF  3CC,593
03F06:  CALL   2F24
03F0A:  MOVFF  03,584
03F0E:  MOVFF  02,583
03F12:  MOVFF  01,582
03F16:  MOVFF  00,581
03F1A:  MOVFF  03,592
03F1E:  MOVFF  02,591
03F22:  MOVFF  01,590
03F26:  MOVFF  00,58F
03F2A:  MOVFF  3D3,596
03F2E:  MOVFF  3D2,595
03F32:  MOVFF  3D1,594
03F36:  MOVFF  3D0,593
03F3A:  CALL   2F24
03F3E:  MOVFF  3D7,598
03F42:  MOVFF  3D6,597
03F46:  MOVFF  3D5,596
03F4A:  MOVFF  3D4,595
03F4E:  MOVFF  03,59C
03F52:  MOVFF  02,59B
03F56:  MOVFF  01,59A
03F5A:  MOVFF  00,599
03F5E:  CALL   301A
03F62:  MOVFF  03,3E3
03F66:  MOVFF  02,3E2
03F6A:  MOVFF  01,3E1
03F6E:  MOVFF  00,3E0
....................     Fmax_z = Vmax_z / MMbyStep_z; //Valor de ferequencia adiquirido em hz 
03F72:  MOVFF  3DB,598
03F76:  MOVFF  3DA,597
03F7A:  MOVFF  3D9,596
03F7E:  MOVFF  3D8,595
03F82:  MOVFF  3E3,59C
03F86:  MOVFF  3E2,59B
03F8A:  MOVFF  3E1,59A
03F8E:  MOVFF  3E0,599
03F92:  CALL   301A
03F96:  MOVFF  03,3E8
03F9A:  MOVFF  02,3E7
03F9E:  MOVFF  01,3E6
03FA2:  MOVFF  00,3E5
....................  
....................     float den = Amax_z*StepinAcc_z; 
....................     float num = Vmax_z * 1000000; 
....................     float TbyF = num / den; //tempo em us 
....................  
....................     int i = 0; 
03FA6:  MOVLB  5
03FA8:  CLRF   x90
03FAA:  MOVFF  3E4,58F
03FAE:  MOVLB  0
03FB0:  CALL   3178
03FB4:  MOVFF  3DF,592
03FB8:  MOVFF  3DE,591
03FBC:  MOVFF  3DD,590
03FC0:  MOVFF  3DC,58F
03FC4:  MOVFF  03,596
03FC8:  MOVFF  02,595
03FCC:  MOVFF  01,594
03FD0:  MOVFF  00,593
03FD4:  CALL   2F24
03FD8:  MOVFF  03,577
03FDC:  MOVFF  02,576
03FE0:  MOVFF  01,575
03FE4:  MOVFF  00,574
03FE8:  MOVFF  3DB,592
03FEC:  MOVFF  3DA,591
03FF0:  MOVFF  3D9,590
03FF4:  MOVFF  3D8,58F
03FF8:  MOVLB  5
03FFA:  CLRF   x96
03FFC:  MOVLW  24
03FFE:  MOVWF  x95
04000:  MOVLW  74
04002:  MOVWF  x94
04004:  MOVLW  92
04006:  MOVWF  x93
04008:  MOVLB  0
0400A:  CALL   2F24
0400E:  MOVFF  03,57B
04012:  MOVFF  02,57A
04016:  MOVFF  01,579
0401A:  MOVFF  00,578
0401E:  MOVFF  57B,598
04022:  MOVFF  57A,597
04026:  MOVFF  579,596
0402A:  MOVFF  578,595
0402E:  MOVFF  577,59C
04032:  MOVFF  576,59B
04036:  MOVFF  575,59A
0403A:  MOVFF  574,599
0403E:  CALL   301A
04042:  MOVFF  03,57F
04046:  MOVFF  02,57E
0404A:  MOVFF  01,57D
0404E:  MOVFF  00,57C
04052:  MOVLB  5
04054:  CLRF   x80
....................     for (i = 1; i <= StepinAcc_z; i++) { 
04056:  MOVLW  01
04058:  MOVWF  x80
0405A:  MOVF   x80,W
0405C:  MOVLB  3
0405E:  SUBWF  xE4,W
04060:  BTFSS  FD8.0
04062:  BRA    4310
....................         Ts_z[i - 1] = (1000000 * StepinAcc_z) / (i * Fmax_z); 
04064:  MOVLW  01
04066:  MOVLB  5
04068:  SUBWF  x80,W
0406A:  MULLW  04
0406C:  MOVF   FF3,W
0406E:  CLRF   03
04070:  ADDLW  E9
04072:  MOVWF  FE9
04074:  MOVLW  03
04076:  ADDWFC 03,W
04078:  MOVWF  FEA
0407A:  MOVFF  FEA,584
0407E:  MOVFF  FE9,583
04082:  CLRF   x88
04084:  MOVLW  0F
04086:  MOVWF  x87
04088:  MOVLW  42
0408A:  MOVWF  x86
0408C:  MOVLW  40
0408E:  MOVWF  x85
04090:  CLRF   x8C
04092:  CLRF   x8B
04094:  CLRF   x8A
04096:  MOVFF  3E4,589
0409A:  MOVLB  0
0409C:  CALL   3426
040A0:  MOVFF  584,FEA
040A4:  MOVFF  583,FE9
040A8:  MOVFF  03,588
040AC:  MOVFF  02,587
040B0:  MOVFF  01,586
040B4:  MOVFF  00,585
040B8:  MOVLB  5
040BA:  CLRF   x90
040BC:  MOVFF  580,58F
040C0:  MOVLB  0
040C2:  CALL   3178
040C6:  MOVFF  03,592
040CA:  MOVFF  02,591
040CE:  MOVFF  01,590
040D2:  MOVFF  00,58F
040D6:  MOVFF  3E8,596
040DA:  MOVFF  3E7,595
040DE:  MOVFF  3E6,594
040E2:  MOVFF  3E5,593
040E6:  CALL   2F24
040EA:  MOVFF  03,58C
040EE:  MOVFF  02,58B
040F2:  MOVFF  01,58A
040F6:  MOVFF  00,589
040FA:  MOVFF  588,598
040FE:  MOVFF  587,597
04102:  MOVFF  586,596
04106:  MOVFF  585,595
0410A:  CALL   3482
0410E:  MOVFF  03,598
04112:  MOVFF  02,597
04116:  MOVFF  01,596
0411A:  MOVFF  00,595
0411E:  MOVFF  58C,59C
04122:  MOVFF  58B,59B
04126:  MOVFF  58A,59A
0412A:  MOVFF  589,599
0412E:  CALL   301A
04132:  MOVFF  03,598
04136:  MOVFF  02,597
0413A:  MOVFF  01,596
0413E:  MOVFF  00,595
04142:  CALL   34BA
04146:  MOVFF  00,FEF
0414A:  MOVFF  01,FEC
0414E:  MOVFF  02,FEC
04152:  MOVFF  03,FEC
....................         StepbyF_z[i - 1] = 2 * TbyF / Ts_z[i - 1]; 
04156:  MOVLW  01
04158:  MOVLB  5
0415A:  SUBWF  x80,W
0415C:  MULLW  04
0415E:  MOVF   FF3,W
04160:  CLRF   03
04162:  ADDLW  39
04164:  MOVWF  01
04166:  MOVLW  04
04168:  ADDWFC 03,F
0416A:  MOVFF  01,581
0416E:  MOVFF  03,582
04172:  CLRF   x92
04174:  CLRF   x91
04176:  CLRF   x90
04178:  MOVLW  80
0417A:  MOVWF  x8F
0417C:  MOVFF  57F,596
04180:  MOVFF  57E,595
04184:  MOVFF  57D,594
04188:  MOVFF  57C,593
0418C:  MOVLB  0
0418E:  CALL   2F24
04192:  MOVFF  03,586
04196:  MOVFF  02,585
0419A:  MOVFF  01,584
0419E:  MOVFF  00,583
041A2:  MOVLW  01
041A4:  MOVLB  5
041A6:  SUBWF  x80,W
041A8:  MULLW  04
041AA:  MOVF   FF3,W
041AC:  CLRF   03
041AE:  ADDLW  E9
041B0:  MOVWF  FE9
041B2:  MOVLW  03
041B4:  ADDWFC 03,W
041B6:  MOVWF  FEA
041B8:  MOVFF  FEF,00
041BC:  MOVFF  FEC,01
041C0:  MOVFF  FEC,02
041C4:  MOVFF  FEC,03
041C8:  MOVFF  03,598
041CC:  MOVFF  02,597
041D0:  MOVFF  01,596
041D4:  MOVFF  00,595
041D8:  MOVLB  0
041DA:  CALL   3482
041DE:  MOVFF  586,598
041E2:  MOVFF  585,597
041E6:  MOVFF  584,596
041EA:  MOVFF  583,595
041EE:  MOVFF  03,59C
041F2:  MOVFF  02,59B
041F6:  MOVFF  01,59A
041FA:  MOVFF  00,599
041FE:  CALL   301A
04202:  MOVFF  03,598
04206:  MOVFF  02,597
0420A:  MOVFF  01,596
0420E:  MOVFF  00,595
04212:  CALL   34BA
04216:  MOVFF  582,FEA
0421A:  MOVFF  581,FE9
0421E:  MOVFF  00,FEF
04222:  MOVFF  01,FEC
04226:  MOVFF  02,FEC
0422A:  MOVFF  03,FEC
....................         total_acc_step_z += StepbyF_z[i - 1]; 
0422E:  MOVLW  01
04230:  MOVLB  5
04232:  SUBWF  x80,W
04234:  MULLW  04
04236:  MOVF   FF3,W
04238:  CLRF   03
0423A:  ADDLW  39
0423C:  MOVWF  FE9
0423E:  MOVLW  04
04240:  ADDWFC 03,W
04242:  MOVWF  FEA
04244:  MOVFF  FEF,00
04248:  MOVFF  FEC,01
0424C:  MOVFF  FEC,02
04250:  MOVFF  FEC,03
04254:  MOVF   00,W
04256:  MOVLB  4
04258:  ADDWF  x89,F
0425A:  MOVF   01,W
0425C:  ADDWFC x8A,F
....................         Ts_z[i - 1] = Ts_z[i - 1] / (8 * 0.2 * 2); //Tempo/(prescale*ciclodemaquina*metadedociclo) 
0425E:  MOVLW  01
04260:  MOVLB  5
04262:  SUBWF  x80,W
04264:  MULLW  04
04266:  MOVF   FF3,W
04268:  CLRF   03
0426A:  ADDLW  E9
0426C:  MOVWF  01
0426E:  MOVLW  03
04270:  ADDWFC 03,F
04272:  MOVFF  01,581
04276:  MOVFF  03,582
0427A:  MOVLW  01
0427C:  SUBWF  x80,W
0427E:  MULLW  04
04280:  MOVF   FF3,W
04282:  CLRF   03
04284:  ADDLW  E9
04286:  MOVWF  FE9
04288:  MOVLW  03
0428A:  ADDWFC 03,W
0428C:  MOVWF  FEA
0428E:  MOVFF  FEF,583
04292:  MOVFF  FEC,584
04296:  MOVFF  FEC,585
0429A:  MOVFF  FEC,586
0429E:  MOVFF  586,598
042A2:  MOVFF  585,597
042A6:  MOVFF  584,596
042AA:  MOVFF  583,595
042AE:  MOVLB  0
042B0:  CALL   3482
042B4:  MOVFF  03,598
042B8:  MOVFF  02,597
042BC:  MOVFF  01,596
042C0:  MOVFF  00,595
042C4:  MOVLW  CD
042C6:  MOVLB  5
042C8:  MOVWF  x9C
042CA:  MOVLW  CC
042CC:  MOVWF  x9B
042CE:  MOVLW  4C
042D0:  MOVWF  x9A
042D2:  MOVLW  80
042D4:  MOVWF  x99
042D6:  MOVLB  0
042D8:  CALL   301A
042DC:  MOVFF  03,598
042E0:  MOVFF  02,597
042E4:  MOVFF  01,596
042E8:  MOVFF  00,595
042EC:  CALL   34BA
042F0:  MOVFF  582,FEA
042F4:  MOVFF  581,FE9
042F8:  MOVFF  00,FEF
042FC:  MOVFF  01,FEC
04300:  MOVFF  02,FEC
04304:  MOVFF  03,FEC
04308:  MOVLB  5
0430A:  INCF   x80,F
0430C:  BRA    405A
0430E:  MOVLB  3
....................     } 
04310:  MOVLB  0
04312:  GOTO   DA16 (RETURN)
.................... } 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Movimento Motor"> 
.................... void motor_stop_z() { 
....................     step_no_z = step_down_z; 
....................     ramp_sts_z = ramp_down; 
.................... } 
....................  
.................... void motor_disable_z() { 
....................     output_high(enable_z); 
....................     disable_interrupts(INT_TIMER3); 
.................... } 
....................  
.................... void motor_run_z(int32 pos_new, int velocidade) { // set up to drive motor to pos_new (absolute step#) 
....................     vel_z = velocidade; 
*
063C2:  MOVFF  580,49A
....................     total_acc_step_z = 0; 
063C6:  MOVLB  4
063C8:  CLRF   x8A
063CA:  CLRF   x89
....................  
....................     if (!run_flg_flip) { 
063CC:  BTFSC  2D.3
063CE:  BRA    65AE
....................         flgMove = TRUE; 
063D0:  BSF    2D.2
....................         if (pos_new < motor_pos_z) // get dir_yection & #steps 
063D2:  MOVFF  209,00
063D6:  MOVFF  20A,01
063DA:  CLRF   02
063DC:  CLRF   03
063DE:  BTFSS  01.7
063E0:  BRA    63E6
063E2:  DECF   02,F
063E4:  DECF   03,F
063E6:  BTFSC  03.7
063E8:  BRA    6458
063EA:  MOVLB  5
063EC:  MOVF   x7F,W
063EE:  SUBWF  03,W
063F0:  BTFSC  FD8.0
063F2:  BRA    63F8
063F4:  MOVLB  4
063F6:  BRA    6458
063F8:  BNZ   6422
063FA:  MOVF   x7E,W
063FC:  SUBWF  02,W
063FE:  BTFSC  FD8.0
06400:  BRA    6406
06402:  MOVLB  4
06404:  BRA    6458
06406:  BNZ   6422
06408:  MOVF   x7D,W
0640A:  SUBWF  01,W
0640C:  BTFSC  FD8.0
0640E:  BRA    6414
06410:  MOVLB  4
06412:  BRA    6458
06414:  BNZ   6422
06416:  MOVF   00,W
06418:  SUBWF  x7C,W
0641A:  BTFSS  FD8.0
0641C:  BRA    6422
0641E:  MOVLB  4
06420:  BRA    6458
....................         { 
....................             output_low(dir_z); 
06422:  BCF    F92.4
06424:  BCF    F89.4
....................             move_z = motor_pos_z - pos_new; 
06426:  MOVFF  209,00
0642A:  MOVFF  20A,01
0642E:  CLRF   02
06430:  CLRF   03
06432:  BTFSS  01.7
06434:  BRA    643A
06436:  DECF   02,F
06438:  DECF   03,F
0643A:  MOVF   x7C,W
0643C:  SUBWF  00,F
0643E:  MOVF   x7D,W
06440:  SUBWFB 01,F
06442:  MOVF   x7E,W
06444:  SUBWFB 02,F
06446:  MOVF   x7F,W
06448:  SUBWFB 03,F
0644A:  MOVFF  01,492
0644E:  MOVFF  00,491
....................             pos_inc_z = -1; 
06452:  MOVLB  4
06454:  SETF   x8B
....................         } else if (pos_new != motor_pos_z) { 
06456:  BRA    64C8
06458:  MOVFF  209,00
0645C:  MOVFF  20A,01
06460:  CLRF   02
06462:  CLRF   03
06464:  BTFSS  01.7
06466:  BRA    646C
06468:  DECF   02,F
0646A:  DECF   03,F
0646C:  MOVF   00,W
0646E:  MOVLB  5
06470:  SUBWF  x7C,W
06472:  BNZ   6486
06474:  MOVF   01,W
06476:  SUBWF  x7D,W
06478:  BNZ   6486
0647A:  MOVF   02,W
0647C:  SUBWF  x7E,W
0647E:  BNZ   6486
06480:  MOVF   03,W
06482:  SUBWF  x7F,W
06484:  BZ    64C4
....................             output_high(dir_z); 
06486:  BCF    F92.4
06488:  BSF    F89.4
....................             move_z = pos_new - motor_pos_z; 
0648A:  MOVFF  209,00
0648E:  MOVFF  20A,01
06492:  CLRF   02
06494:  CLRF   03
06496:  BTFSS  01.7
06498:  BRA    649E
0649A:  DECF   02,F
0649C:  DECF   03,F
0649E:  MOVF   00,W
064A0:  SUBWF  x7C,W
064A2:  MOVWF  00
064A4:  MOVF   01,W
064A6:  SUBWFB x7D,W
064A8:  MOVWF  01
064AA:  MOVF   02,W
064AC:  SUBWFB x7E,W
064AE:  MOVF   03,W
064B0:  SUBWFB x7F,W
064B2:  MOVFF  01,492
064B6:  MOVFF  00,491
....................             pos_inc_z = 1; 
064BA:  MOVLW  01
064BC:  MOVLB  4
064BE:  MOVWF  x8B
....................         } else return; 
064C0:  BRA    64C8
064C2:  MOVLB  5
064C4:  BRA    65AC
064C6:  MOVLB  4
....................  
....................         for (int j = 0; j <= velocidade; j++) { 
064C8:  MOVLB  5
064CA:  CLRF   x81
064CC:  MOVF   x81,W
064CE:  SUBWF  x80,W
064D0:  BNC   6504
....................             total_acc_step_z += StepbyF_z[j]; 
064D2:  MOVF   x81,W
064D4:  MULLW  04
064D6:  MOVF   FF3,W
064D8:  CLRF   03
064DA:  ADDLW  39
064DC:  MOVWF  FE9
064DE:  MOVLW  04
064E0:  ADDWFC 03,W
064E2:  MOVWF  FEA
064E4:  MOVFF  FEF,00
064E8:  MOVFF  FEC,01
064EC:  MOVFF  FEC,02
064F0:  MOVFF  FEC,03
064F4:  MOVF   00,W
064F6:  MOVLB  4
064F8:  ADDWF  x89,F
064FA:  MOVF   01,W
064FC:  ADDWFC x8A,F
064FE:  MOVLB  5
06500:  INCF   x81,F
06502:  BRA    64CC
....................         } 
....................  
....................         if (move_z > 2 * total_acc_step_z) { 
06504:  BCF    FD8.0
06506:  MOVLB  4
06508:  RLCF   x89,W
0650A:  MOVWF  02
0650C:  RLCF   x8A,W
0650E:  MOVWF  03
06510:  MOVFF  02,01
06514:  MOVF   03,W
06516:  SUBWF  x92,W
06518:  BNC   6538
0651A:  BNZ   6522
0651C:  MOVF   x91,W
0651E:  SUBWF  01,W
06520:  BC    6538
....................             midpt_z = total_acc_step_z; 
06522:  MOVFF  48A,494
06526:  MOVFF  489,493
....................             step_down_z = move_z - total_acc_step_z; 
0652A:  MOVF   x89,W
0652C:  SUBWF  x91,W
0652E:  MOVWF  x8F
06530:  MOVF   x8A,W
06532:  SUBWFB x92,W
06534:  MOVWF  x90
....................         } else { 
06536:  BRA    6562
....................             midpt_z = (move_z - 1) >> 1; 
06538:  MOVLW  01
0653A:  SUBWF  x91,W
0653C:  MOVLB  5
0653E:  MOVWF  x82
06540:  MOVLW  00
06542:  MOVLB  4
06544:  SUBWFB x92,W
06546:  MOVLB  5
06548:  MOVWF  x83
0654A:  BCF    FD8.0
0654C:  RRCF   x83,W
0654E:  MOVLB  4
06550:  MOVWF  x94
06552:  MOVLB  5
06554:  RRCF   x82,W
06556:  MOVLB  4
06558:  MOVWF  x93
....................             step_down_z = midpt_z; 
0655A:  MOVFF  494,490
0655E:  MOVFF  493,48F
....................         } 
....................         step_no_z = 0; 
06562:  CLRF   x8E
06564:  CLRF   x8D
....................         step_acumulado_z = 0; 
06566:  CLRF   x98
06568:  CLRF   x97
0656A:  CLRF   x96
0656C:  CLRF   x95
....................         atual_frequencia_z = 0; 
0656E:  CLRF   x99
....................         ramp_sts_z = ramp_up; // start ramp state-machine 
06570:  MOVLW  01
06572:  MOVWF  x8C
....................         run_flg_z = TRUE; 
06574:  MOVLB  3
06576:  BSF    xB7.2
....................         output_low(enable_z); 
06578:  BCF    F92.3
0657A:  BCF    F89.3
....................         setup_timer_3(T3_INTERNAL | T3_DIV_BY_8); 
0657C:  MOVLW  B5
0657E:  MOVWF  FB1
....................         set_timer3(65535 - Ts_z[0]); 
06580:  MOVLW  FF
06582:  BSF    FD8.0
06584:  SUBFWB xE9,W
06586:  MOVLB  5
06588:  MOVWF  x82
0658A:  MOVLW  FF
0658C:  MOVLB  3
0658E:  SUBFWB xEA,W
06590:  MOVLB  5
06592:  MOVWF  x83
06594:  MOVLW  00
06596:  MOVLB  3
06598:  SUBFWB xEB,W
0659A:  MOVLW  00
0659C:  MOVLB  3
0659E:  SUBFWB xEC,W
065A0:  MOVLB  5
065A2:  MOVFF  583,FB3
065A6:  MOVFF  582,FB2
....................         enable_interrupts(INT_TIMER3); 
065AA:  BSF    FA0.1
065AC:  MOVLB  4
....................     } 
065AE:  MOVLB  0
065B0:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_subida_z() { 
....................     if (atual_frequencia_z == 0) { 
*
01DD6:  MOVLB  4
01DD8:  MOVF   x99,F
01DDA:  BTFSS  FD8.2
01DDC:  BRA    1F0C
....................         if (step_no_z == StepbyF_z[atual_frequencia_z]) { 
01DDE:  MOVF   x99,W
01DE0:  MULLW  04
01DE2:  MOVF   FF3,W
01DE4:  CLRF   03
01DE6:  ADDLW  39
01DE8:  MOVWF  FE9
01DEA:  MOVLW  04
01DEC:  ADDWFC 03,W
01DEE:  MOVWF  FEA
01DF0:  MOVFF  FEF,00
01DF4:  MOVFF  FEC,01
01DF8:  MOVFF  FEC,02
01DFC:  MOVFF  FEC,03
01E00:  MOVF   00,W
01E02:  SUBWF  x8D,W
01E04:  BNZ   1EC6
01E06:  MOVF   01,W
01E08:  SUBWF  x8E,W
01E0A:  BNZ   1EC6
01E0C:  MOVF   02,F
01E0E:  BNZ   1EC6
01E10:  MOVF   03,F
01E12:  BNZ   1EC6
....................             step_acumulado_z += StepbyF_z[atual_frequencia_z] + StepbyF_z[atual_frequencia_z + 1]; 
01E14:  MOVF   x99,W
01E16:  MULLW  04
01E18:  MOVF   FF3,W
01E1A:  CLRF   03
01E1C:  ADDLW  39
01E1E:  MOVWF  FE9
01E20:  MOVLW  04
01E22:  ADDWFC 03,W
01E24:  MOVWF  FEA
01E26:  MOVFF  FEF,5A5
01E2A:  MOVFF  FEC,5A6
01E2E:  MOVFF  FEC,5A7
01E32:  MOVFF  FEC,5A8
01E36:  MOVLW  01
01E38:  ADDWF  x99,W
01E3A:  MULLW  04
01E3C:  MOVF   FF3,W
01E3E:  CLRF   03
01E40:  ADDLW  39
01E42:  MOVWF  FE9
01E44:  MOVLW  04
01E46:  ADDWFC 03,W
01E48:  MOVWF  FEA
01E4A:  MOVFF  FEF,00
01E4E:  MOVFF  FEC,01
01E52:  MOVFF  FEC,02
01E56:  MOVFF  FEC,03
01E5A:  MOVLB  5
01E5C:  MOVF   xA5,W
01E5E:  ADDWF  00,F
01E60:  MOVF   xA6,W
01E62:  ADDWFC 01,F
01E64:  MOVF   xA7,W
01E66:  ADDWFC 02,F
01E68:  MOVF   xA8,W
01E6A:  ADDWFC 03,F
01E6C:  MOVF   00,W
01E6E:  MOVLB  4
01E70:  ADDWF  x95,F
01E72:  MOVF   01,W
01E74:  ADDWFC x96,F
01E76:  MOVF   02,W
01E78:  ADDWFC x97,F
01E7A:  MOVF   03,W
01E7C:  ADDWFC x98,F
....................             atual_frequencia_z++; 
01E7E:  INCF   x99,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01E80:  MOVF   x99,W
01E82:  MULLW  04
01E84:  MOVF   FF3,W
01E86:  CLRF   03
01E88:  ADDLW  E9
01E8A:  MOVWF  FE9
01E8C:  MOVLW  03
01E8E:  ADDWFC 03,W
01E90:  MOVWF  FEA
01E92:  MOVFF  FEF,00
01E96:  MOVFF  FEC,01
01E9A:  MOVFF  FEC,02
01E9E:  MOVFF  FEC,03
01EA2:  MOVLW  FF
01EA4:  BSF    FD8.0
01EA6:  SUBFWB 00,W
01EA8:  MOVLB  5
01EAA:  MOVWF  xA5
01EAC:  MOVLW  FF
01EAE:  SUBFWB 01,W
01EB0:  MOVWF  xA6
01EB2:  MOVLW  00
01EB4:  SUBFWB 02,W
01EB6:  MOVLW  00
01EB8:  SUBFWB 03,W
01EBA:  MOVFF  5A6,FB3
01EBE:  MOVFF  5A5,FB2
....................         } else { 
01EC2:  BRA    1F08
01EC4:  MOVLB  4
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01EC6:  MOVF   x99,W
01EC8:  MULLW  04
01ECA:  MOVF   FF3,W
01ECC:  CLRF   03
01ECE:  ADDLW  E9
01ED0:  MOVWF  FE9
01ED2:  MOVLW  03
01ED4:  ADDWFC 03,W
01ED6:  MOVWF  FEA
01ED8:  MOVFF  FEF,00
01EDC:  MOVFF  FEC,01
01EE0:  MOVFF  FEC,02
01EE4:  MOVFF  FEC,03
01EE8:  MOVLW  FF
01EEA:  BSF    FD8.0
01EEC:  SUBFWB 00,W
01EEE:  MOVLB  5
01EF0:  MOVWF  xA5
01EF2:  MOVLW  FF
01EF4:  SUBFWB 01,W
01EF6:  MOVWF  xA6
01EF8:  MOVLW  00
01EFA:  SUBFWB 02,W
01EFC:  MOVLW  00
01EFE:  SUBFWB 03,W
01F00:  MOVFF  5A6,FB3
01F04:  MOVFF  5A5,FB2
....................         } 
....................     } else if (atual_frequencia_z == vel_z) { 
01F08:  BRA    2028
01F0A:  MOVLB  4
01F0C:  MOVF   x9A,W
01F0E:  SUBWF  x99,W
01F10:  BNZ   1F58
....................         set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01F12:  MOVF   x99,W
01F14:  MULLW  04
01F16:  MOVF   FF3,W
01F18:  CLRF   03
01F1A:  ADDLW  E9
01F1C:  MOVWF  FE9
01F1E:  MOVLW  03
01F20:  ADDWFC 03,W
01F22:  MOVWF  FEA
01F24:  MOVFF  FEF,00
01F28:  MOVFF  FEC,01
01F2C:  MOVFF  FEC,02
01F30:  MOVFF  FEC,03
01F34:  MOVLW  FF
01F36:  BSF    FD8.0
01F38:  SUBFWB 00,W
01F3A:  MOVLB  5
01F3C:  MOVWF  xA5
01F3E:  MOVLW  FF
01F40:  SUBFWB 01,W
01F42:  MOVWF  xA6
01F44:  MOVLW  00
01F46:  SUBFWB 02,W
01F48:  MOVLW  00
01F4A:  SUBFWB 03,W
01F4C:  MOVFF  5A6,FB3
01F50:  MOVFF  5A5,FB2
....................     } else { 
01F54:  BRA    2028
01F56:  MOVLB  4
....................         if (step_no_z == step_acumulado_z) { 
01F58:  MOVF   x95,W
01F5A:  SUBWF  x8D,W
01F5C:  BNZ   1FE6
01F5E:  MOVF   x96,W
01F60:  SUBWF  x8E,W
01F62:  BNZ   1FE6
01F64:  MOVF   x97,F
01F66:  BNZ   1FE6
01F68:  MOVF   x98,F
01F6A:  BNZ   1FE6
....................             atual_frequencia_z++; 
01F6C:  INCF   x99,F
....................             step_acumulado_z += StepbyF_z[atual_frequencia_z]; 
01F6E:  MOVF   x99,W
01F70:  MULLW  04
01F72:  MOVF   FF3,W
01F74:  CLRF   03
01F76:  ADDLW  39
01F78:  MOVWF  FE9
01F7A:  MOVLW  04
01F7C:  ADDWFC 03,W
01F7E:  MOVWF  FEA
01F80:  MOVFF  FEF,00
01F84:  MOVFF  FEC,01
01F88:  MOVFF  FEC,02
01F8C:  MOVFF  FEC,03
01F90:  MOVF   00,W
01F92:  ADDWF  x95,F
01F94:  MOVF   01,W
01F96:  ADDWFC x96,F
01F98:  MOVF   02,W
01F9A:  ADDWFC x97,F
01F9C:  MOVF   03,W
01F9E:  ADDWFC x98,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01FA0:  MOVF   x99,W
01FA2:  MULLW  04
01FA4:  MOVF   FF3,W
01FA6:  CLRF   03
01FA8:  ADDLW  E9
01FAA:  MOVWF  FE9
01FAC:  MOVLW  03
01FAE:  ADDWFC 03,W
01FB0:  MOVWF  FEA
01FB2:  MOVFF  FEF,00
01FB6:  MOVFF  FEC,01
01FBA:  MOVFF  FEC,02
01FBE:  MOVFF  FEC,03
01FC2:  MOVLW  FF
01FC4:  BSF    FD8.0
01FC6:  SUBFWB 00,W
01FC8:  MOVLB  5
01FCA:  MOVWF  xA5
01FCC:  MOVLW  FF
01FCE:  SUBFWB 01,W
01FD0:  MOVWF  xA6
01FD2:  MOVLW  00
01FD4:  SUBFWB 02,W
01FD6:  MOVLW  00
01FD8:  SUBFWB 03,W
01FDA:  MOVFF  5A6,FB3
01FDE:  MOVFF  5A5,FB2
....................         } else { 
01FE2:  BRA    2028
01FE4:  MOVLB  4
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01FE6:  MOVF   x99,W
01FE8:  MULLW  04
01FEA:  MOVF   FF3,W
01FEC:  CLRF   03
01FEE:  ADDLW  E9
01FF0:  MOVWF  FE9
01FF2:  MOVLW  03
01FF4:  ADDWFC 03,W
01FF6:  MOVWF  FEA
01FF8:  MOVFF  FEF,00
01FFC:  MOVFF  FEC,01
02000:  MOVFF  FEC,02
02004:  MOVFF  FEC,03
02008:  MOVLW  FF
0200A:  BSF    FD8.0
0200C:  SUBFWB 00,W
0200E:  MOVLB  5
02010:  MOVWF  xA5
02012:  MOVLW  FF
02014:  SUBFWB 01,W
02016:  MOVWF  xA6
02018:  MOVLW  00
0201A:  SUBFWB 02,W
0201C:  MOVLW  00
0201E:  SUBFWB 03,W
02020:  MOVFF  5A6,FB3
02024:  MOVFF  5A5,FB2
....................         } 
....................         break; 
....................     } 
02028:  MOVLB  0
0202A:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_descida_z() { 
....................     if (atual_frequencia_z == 0) { 
0202C:  MOVLB  4
0202E:  MOVF   x99,F
02030:  BNZ   2078
....................         set_timer3(65535 - Ts_z[atual_frequencia_z]); 
02032:  MOVF   x99,W
02034:  MULLW  04
02036:  MOVF   FF3,W
02038:  CLRF   03
0203A:  ADDLW  E9
0203C:  MOVWF  FE9
0203E:  MOVLW  03
02040:  ADDWFC 03,W
02042:  MOVWF  FEA
02044:  MOVFF  FEF,00
02048:  MOVFF  FEC,01
0204C:  MOVFF  FEC,02
02050:  MOVFF  FEC,03
02054:  MOVLW  FF
02056:  BSF    FD8.0
02058:  SUBFWB 00,W
0205A:  MOVLB  5
0205C:  MOVWF  xA5
0205E:  MOVLW  FF
02060:  SUBFWB 01,W
02062:  MOVWF  xA6
02064:  MOVLW  00
02066:  SUBFWB 02,W
02068:  MOVLW  00
0206A:  SUBFWB 03,W
0206C:  MOVFF  5A6,FB3
02070:  MOVFF  5A5,FB2
....................     } 
02074:  BRA    22B0
02076:  MOVLB  4
....................     else if (atual_frequencia_z == vel_z) { 
02078:  MOVF   x9A,W
0207A:  SUBWF  x99,W
0207C:  BTFSS  FD8.2
0207E:  BRA    21E0
....................         if (step_no_z == (step_down_z + StepbyF_z[atual_frequencia_z])) { 
02080:  MOVF   x99,W
02082:  MULLW  04
02084:  MOVF   FF3,W
02086:  CLRF   03
02088:  ADDLW  39
0208A:  MOVWF  FE9
0208C:  MOVLW  04
0208E:  ADDWFC 03,W
02090:  MOVWF  FEA
02092:  MOVFF  FEF,00
02096:  MOVFF  FEC,01
0209A:  MOVFF  FEC,02
0209E:  MOVFF  FEC,03
020A2:  MOVF   x8F,W
020A4:  ADDWF  00,F
020A6:  MOVF   x90,W
020A8:  ADDWFC 01,F
020AA:  MOVLW  00
020AC:  ADDWFC 02,F
020AE:  ADDWFC 03,F
020B0:  MOVF   00,W
020B2:  SUBWF  x8D,W
020B4:  BNZ   219A
020B6:  MOVF   01,W
020B8:  SUBWF  x8E,W
020BA:  BNZ   219A
020BC:  MOVF   02,F
020BE:  BNZ   219A
020C0:  MOVF   03,F
020C2:  BNZ   219A
....................             step_acumulado_z = step_down_z + StepbyF_z[atual_frequencia_z] + StepbyF_z[atual_frequencia_z - 1]; 
020C4:  MOVF   x99,W
020C6:  MULLW  04
020C8:  MOVF   FF3,W
020CA:  CLRF   03
020CC:  ADDLW  39
020CE:  MOVWF  FE9
020D0:  MOVLW  04
020D2:  ADDWFC 03,W
020D4:  MOVWF  FEA
020D6:  MOVFF  FEF,00
020DA:  MOVFF  FEC,01
020DE:  MOVFF  FEC,02
020E2:  MOVFF  FEC,03
020E6:  MOVF   00,W
020E8:  ADDWF  x8F,W
020EA:  MOVLB  5
020EC:  MOVWF  xA5
020EE:  MOVF   01,W
020F0:  MOVLB  4
020F2:  ADDWFC x90,W
020F4:  MOVLB  5
020F6:  MOVWF  xA6
020F8:  MOVLW  00
020FA:  ADDWFC 02,W
020FC:  MOVWF  xA7
020FE:  MOVLW  00
02100:  ADDWFC 03,W
02102:  MOVWF  xA8
02104:  MOVLW  01
02106:  MOVLB  4
02108:  SUBWF  x99,W
0210A:  MULLW  04
0210C:  MOVF   FF3,W
0210E:  CLRF   03
02110:  ADDLW  39
02112:  MOVWF  FE9
02114:  MOVLW  04
02116:  ADDWFC 03,W
02118:  MOVWF  FEA
0211A:  MOVFF  FEF,00
0211E:  MOVFF  FEC,01
02122:  MOVFF  FEC,02
02126:  MOVFF  FEC,03
0212A:  MOVF   00,W
0212C:  MOVLB  5
0212E:  ADDWF  xA5,W
02130:  MOVLB  4
02132:  MOVWF  x95
02134:  MOVF   01,W
02136:  MOVLB  5
02138:  ADDWFC xA6,W
0213A:  MOVLB  4
0213C:  MOVWF  x96
0213E:  MOVF   02,W
02140:  MOVLB  5
02142:  ADDWFC xA7,W
02144:  MOVLB  4
02146:  MOVWF  x97
02148:  MOVF   03,W
0214A:  MOVLB  5
0214C:  ADDWFC xA8,W
0214E:  MOVLB  4
02150:  MOVWF  x98
....................             atual_frequencia_z--; 
02152:  DECF   x99,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
02154:  MOVF   x99,W
02156:  MULLW  04
02158:  MOVF   FF3,W
0215A:  CLRF   03
0215C:  ADDLW  E9
0215E:  MOVWF  FE9
02160:  MOVLW  03
02162:  ADDWFC 03,W
02164:  MOVWF  FEA
02166:  MOVFF  FEF,00
0216A:  MOVFF  FEC,01
0216E:  MOVFF  FEC,02
02172:  MOVFF  FEC,03
02176:  MOVLW  FF
02178:  BSF    FD8.0
0217A:  SUBFWB 00,W
0217C:  MOVLB  5
0217E:  MOVWF  xA5
02180:  MOVLW  FF
02182:  SUBFWB 01,W
02184:  MOVWF  xA6
02186:  MOVLW  00
02188:  SUBFWB 02,W
0218A:  MOVLW  00
0218C:  SUBFWB 03,W
0218E:  MOVFF  5A6,FB3
02192:  MOVFF  5A5,FB2
....................         } else { 
02196:  BRA    21DC
02198:  MOVLB  4
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
0219A:  MOVF   x99,W
0219C:  MULLW  04
0219E:  MOVF   FF3,W
021A0:  CLRF   03
021A2:  ADDLW  E9
021A4:  MOVWF  FE9
021A6:  MOVLW  03
021A8:  ADDWFC 03,W
021AA:  MOVWF  FEA
021AC:  MOVFF  FEF,00
021B0:  MOVFF  FEC,01
021B4:  MOVFF  FEC,02
021B8:  MOVFF  FEC,03
021BC:  MOVLW  FF
021BE:  BSF    FD8.0
021C0:  SUBFWB 00,W
021C2:  MOVLB  5
021C4:  MOVWF  xA5
021C6:  MOVLW  FF
021C8:  SUBFWB 01,W
021CA:  MOVWF  xA6
021CC:  MOVLW  00
021CE:  SUBFWB 02,W
021D0:  MOVLW  00
021D2:  SUBFWB 03,W
021D4:  MOVFF  5A6,FB3
021D8:  MOVFF  5A5,FB2
....................         } 
....................     } else { 
021DC:  BRA    22B0
021DE:  MOVLB  4
....................         if (step_no_z == step_acumulado_z) { 
021E0:  MOVF   x95,W
021E2:  SUBWF  x8D,W
021E4:  BNZ   226E
021E6:  MOVF   x96,W
021E8:  SUBWF  x8E,W
021EA:  BNZ   226E
021EC:  MOVF   x97,F
021EE:  BNZ   226E
021F0:  MOVF   x98,F
021F2:  BNZ   226E
....................             atual_frequencia_z--; 
021F4:  DECF   x99,F
....................             step_acumulado_z += StepbyF_z[atual_frequencia_z]; 
021F6:  MOVF   x99,W
021F8:  MULLW  04
021FA:  MOVF   FF3,W
021FC:  CLRF   03
021FE:  ADDLW  39
02200:  MOVWF  FE9
02202:  MOVLW  04
02204:  ADDWFC 03,W
02206:  MOVWF  FEA
02208:  MOVFF  FEF,00
0220C:  MOVFF  FEC,01
02210:  MOVFF  FEC,02
02214:  MOVFF  FEC,03
02218:  MOVF   00,W
0221A:  ADDWF  x95,F
0221C:  MOVF   01,W
0221E:  ADDWFC x96,F
02220:  MOVF   02,W
02222:  ADDWFC x97,F
02224:  MOVF   03,W
02226:  ADDWFC x98,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
02228:  MOVF   x99,W
0222A:  MULLW  04
0222C:  MOVF   FF3,W
0222E:  CLRF   03
02230:  ADDLW  E9
02232:  MOVWF  FE9
02234:  MOVLW  03
02236:  ADDWFC 03,W
02238:  MOVWF  FEA
0223A:  MOVFF  FEF,00
0223E:  MOVFF  FEC,01
02242:  MOVFF  FEC,02
02246:  MOVFF  FEC,03
0224A:  MOVLW  FF
0224C:  BSF    FD8.0
0224E:  SUBFWB 00,W
02250:  MOVLB  5
02252:  MOVWF  xA5
02254:  MOVLW  FF
02256:  SUBFWB 01,W
02258:  MOVWF  xA6
0225A:  MOVLW  00
0225C:  SUBFWB 02,W
0225E:  MOVLW  00
02260:  SUBFWB 03,W
02262:  MOVFF  5A6,FB3
02266:  MOVFF  5A5,FB2
....................         } else { 
0226A:  BRA    22B0
0226C:  MOVLB  4
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
0226E:  MOVF   x99,W
02270:  MULLW  04
02272:  MOVF   FF3,W
02274:  CLRF   03
02276:  ADDLW  E9
02278:  MOVWF  FE9
0227A:  MOVLW  03
0227C:  ADDWFC 03,W
0227E:  MOVWF  FEA
02280:  MOVFF  FEF,00
02284:  MOVFF  FEC,01
02288:  MOVFF  FEC,02
0228C:  MOVFF  FEC,03
02290:  MOVLW  FF
02292:  BSF    FD8.0
02294:  SUBFWB 00,W
02296:  MOVLB  5
02298:  MOVWF  xA5
0229A:  MOVLW  FF
0229C:  SUBFWB 01,W
0229E:  MOVWF  xA6
022A0:  MOVLW  00
022A2:  SUBFWB 02,W
022A4:  MOVLW  00
022A6:  SUBFWB 03,W
022A8:  MOVFF  5A6,FB3
022AC:  MOVFF  5A5,FB2
....................         } 
....................     } 
022B0:  MOVLB  0
022B2:  GOTO   2318 (RETURN)
.................... } 
....................  
.................... void movimenta_eixo_z() { 
....................  
....................     switch (ramp_sts_z) { 
022B6:  MOVLB  4
022B8:  MOVF   x8C,W
022BA:  XORLW  01
022BC:  MOVLB  0
022BE:  BZ    22CA
022C0:  XORLW  02
022C2:  BZ    230C
022C4:  XORLW  01
022C6:  BZ    232C
022C8:  BRA    234E
....................         case ramp_up: // accel 
....................             output_toggle(step_z); 
022CA:  BCF    F92.5
022CC:  BTG    F89.5
....................             rest_z = ~rest_z; 
022CE:  MOVLB  3
022D0:  BTG    xB7.3
....................             proximo_valor_subida_z(); 
022D2:  MOVLB  0
022D4:  RCALL  1DD6
....................             if (step_no_z == midpt_z) { // midpoint: decel 
022D6:  MOVLB  4
022D8:  MOVF   x93,W
022DA:  SUBWF  x8D,W
022DC:  BNZ   230A
022DE:  MOVF   x94,W
022E0:  SUBWF  x8E,W
022E2:  BNZ   230A
....................                 if (move_z > 2 * total_acc_step_z) 
022E4:  BCF    FD8.0
022E6:  RLCF   x89,W
022E8:  MOVWF  02
022EA:  RLCF   x8A,W
022EC:  MOVWF  03
022EE:  MOVFF  02,01
022F2:  MOVF   03,W
022F4:  SUBWF  x92,W
022F6:  BNC   2306
022F8:  BNZ   2300
022FA:  MOVF   x91,W
022FC:  SUBWF  01,W
022FE:  BC    2306
....................                     ramp_sts_z = ramp_max; 
02300:  MOVLW  02
02302:  MOVWF  x8C
02304:  BRA    230A
....................                 else 
....................                     ramp_sts_z = ramp_down; 
02306:  MOVLW  03
02308:  MOVWF  x8C
....................             } 
....................             break; 
0230A:  BRA    235A
....................  
....................         case ramp_down: // decel 
....................             output_toggle(step_z); 
0230C:  BCF    F92.5
0230E:  BTG    F89.5
....................             rest_z = ~rest_z; 
02310:  MOVLB  3
02312:  BTG    xB7.3
....................             proximo_valor_descida_z(); 
02314:  MOVLB  0
02316:  BRA    202C
....................             if (step_no_z == move_z) 
02318:  MOVLB  4
0231A:  MOVF   x91,W
0231C:  SUBWF  x8D,W
0231E:  BNZ   232A
02320:  MOVF   x92,W
02322:  SUBWF  x8E,W
02324:  BNZ   232A
....................                 ramp_sts_z = ramp_last; 
02326:  MOVLW  04
02328:  MOVWF  x8C
....................             break; 
0232A:  BRA    235A
....................  
....................         case ramp_max: // constant speed 
....................             output_toggle(step_z); 
0232C:  BCF    F92.5
0232E:  BTG    F89.5
....................             rest_z = ~rest_z; 
02330:  MOVLB  3
02332:  BTG    xB7.3
....................             proximo_valor_subida_z(); 
02334:  MOVLB  0
02336:  RCALL  1DD6
....................             if (step_no_z == step_down_z) // start decel 
02338:  MOVLB  4
0233A:  MOVF   x8F,W
0233C:  SUBWF  x8D,W
0233E:  BNZ   234A
02340:  MOVF   x90,W
02342:  SUBWF  x8E,W
02344:  BNZ   234A
....................                 ramp_sts_z = ramp_down; 
02346:  MOVLW  03
02348:  MOVWF  x8C
....................             break; 
0234A:  BRA    235A
0234C:  MOVLB  0
....................  
....................         default: // last step: cleanup 
....................             ramp_sts_z = ramp_idle; 
0234E:  MOVLB  4
02350:  CLRF   x8C
....................             disable_interrupts(INT_TIMER3); 
02352:  BCF    FA0.1
....................             run_flg_z = FALSE; // move_z complete 
02354:  MOVLB  3
02356:  BCF    xB7.2
....................             break; 
02358:  MOVLB  4
....................     } // switch (ramp_sts_z) 
....................     if (ramp_sts_z != ramp_idle) { 
0235A:  MOVF   x8C,F
0235C:  BZ    237E
....................         if (rest_z) { 
0235E:  MOVLB  3
02360:  BTFSS  xB7.3
02362:  BRA    2380
....................             motor_pos_z += pos_inc_z; 
02364:  CLRF   03
02366:  MOVLB  4
02368:  MOVF   x8B,W
0236A:  BTFSC  FE8.7
0236C:  DECF   03,F
0236E:  MOVLB  2
02370:  ADDWF  x09,F
02372:  MOVF   03,W
02374:  ADDWFC x0A,F
....................             ++step_no_z; 
02376:  MOVLB  4
02378:  INCF   x8D,F
0237A:  BTFSC  FD8.2
0237C:  INCF   x8E,F
0237E:  MOVLB  3
....................         } 
....................     } 
02380:  MOVLB  0
02382:  GOTO   28F8 (RETURN)
.................... } 
....................  
.................... void umpasso_z(int16 descanco, short dir) { 
....................     output_low(enable_z); 
....................     if (dir) { 
....................         output_high(dir_z); 
....................         motor_pos_z--; 
....................     } else { 
....................         output_low(dir_z); 
....................         motor_pos_z++; 
....................     } 
....................     output_high(step_z); 
....................     delay_us(descanco); 
....................     output_low(step_z); 
....................     delay_us(descanco); 
....................  
.................... } 
....................  
.................... void zerar_z() { 
....................  
....................     while (le_Input(s_limite_z) == 1) { 
....................         delay_us(200); 
....................         umpasso_z(600, FALSE);//600 
....................     } 
....................     while (le_Input(s_limite_z) == 0) { 
....................         delay_us(200); 
....................         umpasso_z(900, TRUE);//900 
....................     } 
....................     while (le_Input(s_limite_z) == 1) { 
....................         delay_us(200); 
....................         umpasso_z(1000, FALSE);//1000 
....................     } 
....................    // output_high(enable_z); 
....................     motor_pos_z = 0; 
.................... } 
....................  
.................... void medir_z() { 
....................     while (le_Input(i_limite_z) == 0) { 
....................         umpasso_z(900, FALSE); 
....................         delay_us(200); 
....................     } 
....................     while (le_Input(i_limite_z) == 1) { 
....................         umpasso_z(900, TRUE); 
....................         delay_us(200); 
....................     } 
....................     max_posicao_z = motor_pos_z; 
....................     output_high(enable_z); 
....................     printf(lcd_putc, "%04Lu", max_posicao_z); 
.................... } 
.................... // </editor-fold> 
....................  
.................... #include "Axis_flip.c" 
.................... // <editor-fold defaultstate="collapsed" desc="Valores que devem ser inseridos"> 
.................... float stepbyrev_flip = 200; 
.................... float driver_u_step_flip = 1; // caso o driver esteja em 400 
.................... float Leadscrew_flip = 9; //redutor de voltas do motor 
.................... float Leadscrew_Pich_flip = 150; //esse valor deve ser em mm/revoluo 
.................... float Vmax_flip = 600; //esse valor deve ser em mm por segundo 
.................... float Amax_flip = 300; //esse valor deve ser em mm por segundo 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Valores calculo rampa"> 
.................... float MMbyStep_flip = 0; 
.................... int8 StepinAcc_flip = 20; 
.................... float Fmax_flip = 0; 
.................... int32 Ts_flip[20]; 
.................... int32 StepbyF_flip[20]; 
.................... int16 total_acc_step_flip = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Flags e Controles de Movimento"> 
.................... signed int8 pos_inc_flip = 0; 
.................... int8 ramp_sts_flip = ramp_idle; 
.................... short rest_flip = false; 
.................... int16 step_no_flip = 0; 
.................... int16 step_down_flip = 0; 
.................... int16 move_flip = 0; 
.................... int16 midpt_flip = 0; 
.................... int32 step_acumulado_flip = 0; 
.................... int atual_frequencia_flip = 0; 
.................... int vel_flip = 19; 
.................... int16 max_posicao_flip = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Pinos Motor"> 
.................... #DEFINE     s_limite_flip            11 
.................... #DEFINE     i_limite_flip            11 
....................  
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Inicializa Motor"> 
.................... void init_axis_flip() { 
....................     set_tris_a(0x00); 
*
04316:  MOVLW  00
04318:  MOVWF  F92
....................     output_high(step_flip); 
0431A:  BCF    F96.2
0431C:  BSF    F8D.2
....................     output_high(enable_flip); 
0431E:  BCF    F96.0
04320:  BSF    F8D.0
....................     output_high(dir_flip); 
04322:  BCF    F96.1
04324:  BSF    F8D.1
....................  
....................     MMbyStep_flip = Leadscrew_Pich_flip / (stepbyrev_flip * driver_u_step_flip * Leadscrew_flip); 
04326:  MOVFF  4A0,592
0432A:  MOVFF  49F,591
0432E:  MOVFF  49E,590
04332:  MOVFF  49D,58F
04336:  MOVFF  4A4,596
0433A:  MOVFF  4A3,595
0433E:  MOVFF  4A2,594
04342:  MOVFF  4A1,593
04346:  CALL   2F24
0434A:  MOVFF  03,584
0434E:  MOVFF  02,583
04352:  MOVFF  01,582
04356:  MOVFF  00,581
0435A:  MOVFF  03,592
0435E:  MOVFF  02,591
04362:  MOVFF  01,590
04366:  MOVFF  00,58F
0436A:  MOVFF  4A8,596
0436E:  MOVFF  4A7,595
04372:  MOVFF  4A6,594
04376:  MOVFF  4A5,593
0437A:  CALL   2F24
0437E:  MOVFF  4AC,598
04382:  MOVFF  4AB,597
04386:  MOVFF  4AA,596
0438A:  MOVFF  4A9,595
0438E:  MOVFF  03,59C
04392:  MOVFF  02,59B
04396:  MOVFF  01,59A
0439A:  MOVFF  00,599
0439E:  CALL   301A
043A2:  MOVFF  03,4B8
043A6:  MOVFF  02,4B7
043AA:  MOVFF  01,4B6
043AE:  MOVFF  00,4B5
....................     Fmax_flip = Vmax_flip / MMbyStep_flip; //Valor de ferequencia adiquirido em hz 
043B2:  MOVFF  4B0,598
043B6:  MOVFF  4AF,597
043BA:  MOVFF  4AE,596
043BE:  MOVFF  4AD,595
043C2:  MOVFF  4B8,59C
043C6:  MOVFF  4B7,59B
043CA:  MOVFF  4B6,59A
043CE:  MOVFF  4B5,599
043D2:  CALL   301A
043D6:  MOVFF  03,4BD
043DA:  MOVFF  02,4BC
043DE:  MOVFF  01,4BB
043E2:  MOVFF  00,4BA
....................  
....................     float den = Amax_flip*StepinAcc_flip; 
....................     float num = Vmax_flip * 1000000; 
....................     float TbyF = num / den; //tempo em us 
....................  
....................     int i = 0; 
043E6:  MOVLB  5
043E8:  CLRF   x90
043EA:  MOVFF  4B9,58F
043EE:  MOVLB  0
043F0:  CALL   3178
043F4:  MOVFF  4B4,592
043F8:  MOVFF  4B3,591
043FC:  MOVFF  4B2,590
04400:  MOVFF  4B1,58F
04404:  MOVFF  03,596
04408:  MOVFF  02,595
0440C:  MOVFF  01,594
04410:  MOVFF  00,593
04414:  CALL   2F24
04418:  MOVFF  03,577
0441C:  MOVFF  02,576
04420:  MOVFF  01,575
04424:  MOVFF  00,574
04428:  MOVFF  4B0,592
0442C:  MOVFF  4AF,591
04430:  MOVFF  4AE,590
04434:  MOVFF  4AD,58F
04438:  MOVLB  5
0443A:  CLRF   x96
0443C:  MOVLW  24
0443E:  MOVWF  x95
04440:  MOVLW  74
04442:  MOVWF  x94
04444:  MOVLW  92
04446:  MOVWF  x93
04448:  MOVLB  0
0444A:  CALL   2F24
0444E:  MOVFF  03,57B
04452:  MOVFF  02,57A
04456:  MOVFF  01,579
0445A:  MOVFF  00,578
0445E:  MOVFF  57B,598
04462:  MOVFF  57A,597
04466:  MOVFF  579,596
0446A:  MOVFF  578,595
0446E:  MOVFF  577,59C
04472:  MOVFF  576,59B
04476:  MOVFF  575,59A
0447A:  MOVFF  574,599
0447E:  CALL   301A
04482:  MOVFF  03,57F
04486:  MOVFF  02,57E
0448A:  MOVFF  01,57D
0448E:  MOVFF  00,57C
04492:  MOVLB  5
04494:  CLRF   x80
....................     for (i = 1; i <= StepinAcc_flip; i++) { 
04496:  MOVLW  01
04498:  MOVWF  x80
0449A:  MOVF   x80,W
0449C:  MOVLB  4
0449E:  SUBWF  xB9,W
044A0:  BTFSS  FD8.0
044A2:  BRA    474C
....................         Ts_flip[i - 1] = (1000000 * StepinAcc_flip) / (i * Fmax_flip); 
044A4:  MOVLW  01
044A6:  MOVLB  5
044A8:  SUBWF  x80,W
044AA:  MULLW  04
044AC:  MOVF   FF3,W
044AE:  CLRF   03
044B0:  ADDLW  BE
044B2:  MOVWF  FE9
044B4:  MOVLW  04
044B6:  ADDWFC 03,W
044B8:  MOVWF  FEA
044BA:  MOVFF  FEA,584
044BE:  MOVFF  FE9,583
044C2:  CLRF   x88
044C4:  MOVLW  0F
044C6:  MOVWF  x87
044C8:  MOVLW  42
044CA:  MOVWF  x86
044CC:  MOVLW  40
044CE:  MOVWF  x85
044D0:  CLRF   x8C
044D2:  CLRF   x8B
044D4:  CLRF   x8A
044D6:  MOVFF  4B9,589
044DA:  MOVLB  0
044DC:  CALL   3426
044E0:  MOVFF  584,FEA
044E4:  MOVFF  583,FE9
044E8:  MOVFF  03,588
044EC:  MOVFF  02,587
044F0:  MOVFF  01,586
044F4:  MOVFF  00,585
044F8:  MOVLB  5
044FA:  CLRF   x90
044FC:  MOVFF  580,58F
04500:  MOVLB  0
04502:  CALL   3178
04506:  MOVFF  03,592
0450A:  MOVFF  02,591
0450E:  MOVFF  01,590
04512:  MOVFF  00,58F
04516:  MOVFF  4BD,596
0451A:  MOVFF  4BC,595
0451E:  MOVFF  4BB,594
04522:  MOVFF  4BA,593
04526:  CALL   2F24
0452A:  MOVFF  03,58C
0452E:  MOVFF  02,58B
04532:  MOVFF  01,58A
04536:  MOVFF  00,589
0453A:  MOVFF  588,598
0453E:  MOVFF  587,597
04542:  MOVFF  586,596
04546:  MOVFF  585,595
0454A:  CALL   3482
0454E:  MOVFF  03,598
04552:  MOVFF  02,597
04556:  MOVFF  01,596
0455A:  MOVFF  00,595
0455E:  MOVFF  58C,59C
04562:  MOVFF  58B,59B
04566:  MOVFF  58A,59A
0456A:  MOVFF  589,599
0456E:  CALL   301A
04572:  MOVFF  03,598
04576:  MOVFF  02,597
0457A:  MOVFF  01,596
0457E:  MOVFF  00,595
04582:  CALL   34BA
04586:  MOVFF  00,FEF
0458A:  MOVFF  01,FEC
0458E:  MOVFF  02,FEC
04592:  MOVFF  03,FEC
....................         StepbyF_flip[i - 1] = 2 * TbyF / Ts_flip[i - 1]; 
04596:  MOVLW  01
04598:  MOVLB  5
0459A:  SUBWF  x80,W
0459C:  MULLW  04
0459E:  MOVF   FF3,W
045A0:  CLRF   03
045A2:  ADDLW  0E
045A4:  MOVWF  01
045A6:  MOVLW  05
045A8:  ADDWFC 03,F
045AA:  MOVFF  01,581
045AE:  MOVFF  03,582
045B2:  CLRF   x92
045B4:  CLRF   x91
045B6:  CLRF   x90
045B8:  MOVLW  80
045BA:  MOVWF  x8F
045BC:  MOVFF  57F,596
045C0:  MOVFF  57E,595
045C4:  MOVFF  57D,594
045C8:  MOVFF  57C,593
045CC:  MOVLB  0
045CE:  CALL   2F24
045D2:  MOVFF  03,586
045D6:  MOVFF  02,585
045DA:  MOVFF  01,584
045DE:  MOVFF  00,583
045E2:  MOVLW  01
045E4:  MOVLB  5
045E6:  SUBWF  x80,W
045E8:  MULLW  04
045EA:  MOVF   FF3,W
045EC:  CLRF   03
045EE:  ADDLW  BE
045F0:  MOVWF  FE9
045F2:  MOVLW  04
045F4:  ADDWFC 03,W
045F6:  MOVWF  FEA
045F8:  MOVFF  FEF,00
045FC:  MOVFF  FEC,01
04600:  MOVFF  FEC,02
04604:  MOVFF  FEC,03
04608:  MOVFF  03,598
0460C:  MOVFF  02,597
04610:  MOVFF  01,596
04614:  MOVFF  00,595
04618:  MOVLB  0
0461A:  CALL   3482
0461E:  MOVFF  586,598
04622:  MOVFF  585,597
04626:  MOVFF  584,596
0462A:  MOVFF  583,595
0462E:  MOVFF  03,59C
04632:  MOVFF  02,59B
04636:  MOVFF  01,59A
0463A:  MOVFF  00,599
0463E:  CALL   301A
04642:  MOVFF  03,598
04646:  MOVFF  02,597
0464A:  MOVFF  01,596
0464E:  MOVFF  00,595
04652:  CALL   34BA
04656:  MOVFF  582,FEA
0465A:  MOVFF  581,FE9
0465E:  MOVFF  00,FEF
04662:  MOVFF  01,FEC
04666:  MOVFF  02,FEC
0466A:  MOVFF  03,FEC
....................         total_acc_step_flip += StepbyF_flip[i - 1]; 
0466E:  MOVLW  01
04670:  MOVLB  5
04672:  SUBWF  x80,W
04674:  MULLW  04
04676:  MOVF   FF3,W
04678:  CLRF   03
0467A:  ADDLW  0E
0467C:  MOVWF  FE9
0467E:  MOVLW  05
04680:  ADDWFC 03,W
04682:  MOVWF  FEA
04684:  MOVFF  FEF,00
04688:  MOVFF  FEC,01
0468C:  MOVFF  FEC,02
04690:  MOVFF  FEC,03
04694:  MOVF   00,W
04696:  ADDWF  x5E,F
04698:  MOVF   01,W
0469A:  ADDWFC x5F,F
....................         Ts_flip[i - 1] = Ts_flip[i - 1] / (8 * 0.2 * 2); //Tempo/(prescale*ciclodemaquina*metadedociclo) 
0469C:  MOVLW  01
0469E:  SUBWF  x80,W
046A0:  MULLW  04
046A2:  MOVF   FF3,W
046A4:  CLRF   03
046A6:  ADDLW  BE
046A8:  MOVWF  01
046AA:  MOVLW  04
046AC:  ADDWFC 03,F
046AE:  MOVFF  01,581
046B2:  MOVFF  03,582
046B6:  MOVLW  01
046B8:  SUBWF  x80,W
046BA:  MULLW  04
046BC:  MOVF   FF3,W
046BE:  CLRF   03
046C0:  ADDLW  BE
046C2:  MOVWF  FE9
046C4:  MOVLW  04
046C6:  ADDWFC 03,W
046C8:  MOVWF  FEA
046CA:  MOVFF  FEF,583
046CE:  MOVFF  FEC,584
046D2:  MOVFF  FEC,585
046D6:  MOVFF  FEC,586
046DA:  MOVFF  586,598
046DE:  MOVFF  585,597
046E2:  MOVFF  584,596
046E6:  MOVFF  583,595
046EA:  MOVLB  0
046EC:  CALL   3482
046F0:  MOVFF  03,598
046F4:  MOVFF  02,597
046F8:  MOVFF  01,596
046FC:  MOVFF  00,595
04700:  MOVLW  CD
04702:  MOVLB  5
04704:  MOVWF  x9C
04706:  MOVLW  CC
04708:  MOVWF  x9B
0470A:  MOVLW  4C
0470C:  MOVWF  x9A
0470E:  MOVLW  80
04710:  MOVWF  x99
04712:  MOVLB  0
04714:  CALL   301A
04718:  MOVFF  03,598
0471C:  MOVFF  02,597
04720:  MOVFF  01,596
04724:  MOVFF  00,595
04728:  CALL   34BA
0472C:  MOVFF  582,FEA
04730:  MOVFF  581,FE9
04734:  MOVFF  00,FEF
04738:  MOVFF  01,FEC
0473C:  MOVFF  02,FEC
04740:  MOVFF  03,FEC
04744:  MOVLB  5
04746:  INCF   x80,F
04748:  BRA    449A
0474A:  MOVLB  4
....................     } 
0474C:  MOVLB  0
0474E:  GOTO   DA1A (RETURN)
.................... } 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Movimento Motor"> 
.................... void motor_stop_flip() { 
....................     step_no_flip = step_down_flip; 
....................     ramp_sts_flip = ramp_down; 
.................... } 
....................  
.................... void motor_disable_flip() { 
....................     output_high(enable_flip); 
....................     disable_interrupts(INT_TIMER3); 
.................... } 
....................  
.................... void motor_run_flip(int32 pos_new, int velocidade) { // set up to drive motor to pos_new (absolute step#) 
....................     vel_flip = velocidade; 
*
0680C:  MOVFF  580,56F
....................     total_acc_step_flip = 0; 
06810:  MOVLB  5
06812:  CLRF   x5F
06814:  CLRF   x5E
....................  
....................     if (!run_flg_z) { 
06816:  MOVLB  3
06818:  BTFSC  xB7.2
0681A:  BRA    69E0
....................         flgMove = FALSE; 
0681C:  BCF    2D.2
....................         if (pos_new < motor_pos_flip) // get dir_yection & #steps 
0681E:  MOVFF  207,00
06822:  MOVFF  208,01
06826:  CLRF   02
06828:  CLRF   03
0682A:  BTFSS  01.7
0682C:  BRA    6832
0682E:  DECF   02,F
06830:  DECF   03,F
06832:  BTFSC  03.7
06834:  BRA    68A4
06836:  MOVLB  5
06838:  MOVF   x7F,W
0683A:  SUBWF  03,W
0683C:  BTFSC  FD8.0
0683E:  BRA    6844
06840:  MOVLB  3
06842:  BRA    68A4
06844:  BNZ   686E
06846:  MOVF   x7E,W
06848:  SUBWF  02,W
0684A:  BTFSC  FD8.0
0684C:  BRA    6852
0684E:  MOVLB  3
06850:  BRA    68A4
06852:  BNZ   686E
06854:  MOVF   x7D,W
06856:  SUBWF  01,W
06858:  BTFSC  FD8.0
0685A:  BRA    6860
0685C:  MOVLB  3
0685E:  BRA    68A4
06860:  BNZ   686E
06862:  MOVF   00,W
06864:  SUBWF  x7C,W
06866:  BTFSS  FD8.0
06868:  BRA    686E
0686A:  MOVLB  3
0686C:  BRA    68A4
....................         { 
....................             output_high(dir_flip); 
0686E:  BCF    F96.1
06870:  BSF    F8D.1
....................             move_flip = motor_pos_flip - pos_new; 
06872:  MOVFF  207,00
06876:  MOVFF  208,01
0687A:  CLRF   02
0687C:  CLRF   03
0687E:  BTFSS  01.7
06880:  BRA    6886
06882:  DECF   02,F
06884:  DECF   03,F
06886:  MOVF   x7C,W
06888:  SUBWF  00,F
0688A:  MOVF   x7D,W
0688C:  SUBWFB 01,F
0688E:  MOVF   x7E,W
06890:  SUBWFB 02,F
06892:  MOVF   x7F,W
06894:  SUBWFB 03,F
06896:  MOVFF  01,567
0689A:  MOVFF  00,566
....................             pos_inc_flip = -1; 
0689E:  SETF   x60
....................         } else if (pos_new != motor_pos_flip) { 
068A0:  BRA    690E
068A2:  MOVLB  3
068A4:  MOVFF  207,00
068A8:  MOVFF  208,01
068AC:  CLRF   02
068AE:  CLRF   03
068B0:  BTFSS  01.7
068B2:  BRA    68B8
068B4:  DECF   02,F
068B6:  DECF   03,F
068B8:  MOVF   00,W
068BA:  MOVLB  5
068BC:  SUBWF  x7C,W
068BE:  BNZ   68D2
068C0:  MOVF   01,W
068C2:  SUBWF  x7D,W
068C4:  BNZ   68D2
068C6:  MOVF   02,W
068C8:  SUBWF  x7E,W
068CA:  BNZ   68D2
068CC:  MOVF   03,W
068CE:  SUBWF  x7F,W
068D0:  BZ    690C
....................             output_low(dir_flip); 
068D2:  BCF    F96.1
068D4:  BCF    F8D.1
....................             move_flip = pos_new - motor_pos_flip; 
068D6:  MOVFF  207,00
068DA:  MOVFF  208,01
068DE:  CLRF   02
068E0:  CLRF   03
068E2:  BTFSS  01.7
068E4:  BRA    68EA
068E6:  DECF   02,F
068E8:  DECF   03,F
068EA:  MOVF   00,W
068EC:  SUBWF  x7C,W
068EE:  MOVWF  00
068F0:  MOVF   01,W
068F2:  SUBWFB x7D,W
068F4:  MOVWF  01
068F6:  MOVF   02,W
068F8:  SUBWFB x7E,W
068FA:  MOVF   03,W
068FC:  SUBWFB x7F,W
068FE:  MOVFF  01,567
06902:  MOVFF  00,566
....................             pos_inc_flip = 1; 
06906:  MOVLW  01
06908:  MOVWF  x60
....................         } else return; 
0690A:  BRA    690E
0690C:  BRA    69DE
....................  
....................         for (int j = 0; j <= velocidade; j++) { 
0690E:  CLRF   x81
06910:  MOVF   x81,W
06912:  SUBWF  x80,W
06914:  BNC   6944
....................             total_acc_step_flip += StepbyF_flip[j]; 
06916:  MOVF   x81,W
06918:  MULLW  04
0691A:  MOVF   FF3,W
0691C:  CLRF   03
0691E:  ADDLW  0E
06920:  MOVWF  FE9
06922:  MOVLW  05
06924:  ADDWFC 03,W
06926:  MOVWF  FEA
06928:  MOVFF  FEF,00
0692C:  MOVFF  FEC,01
06930:  MOVFF  FEC,02
06934:  MOVFF  FEC,03
06938:  MOVF   00,W
0693A:  ADDWF  x5E,F
0693C:  MOVF   01,W
0693E:  ADDWFC x5F,F
06940:  INCF   x81,F
06942:  BRA    6910
....................         } 
....................          
....................         if (move_flip > 2 * total_acc_step_flip) { 
06944:  BCF    FD8.0
06946:  RLCF   x5E,W
06948:  MOVWF  02
0694A:  RLCF   x5F,W
0694C:  MOVWF  03
0694E:  MOVFF  02,01
06952:  MOVF   03,W
06954:  SUBWF  x67,W
06956:  BNC   6976
06958:  BNZ   6960
0695A:  MOVF   x66,W
0695C:  SUBWF  01,W
0695E:  BC    6976
....................             midpt_flip = total_acc_step_flip; 
06960:  MOVFF  55F,569
06964:  MOVFF  55E,568
....................             step_down_flip = move_flip - total_acc_step_flip; 
06968:  MOVF   x5E,W
0696A:  SUBWF  x66,W
0696C:  MOVWF  x64
0696E:  MOVF   x5F,W
06970:  SUBWFB x67,W
06972:  MOVWF  x65
....................         } else { 
06974:  BRA    6994
....................             midpt_flip = (move_flip - 1) >> 1; 
06976:  MOVLW  01
06978:  SUBWF  x66,W
0697A:  MOVWF  x82
0697C:  MOVLW  00
0697E:  SUBWFB x67,W
06980:  MOVWF  x83
06982:  BCF    FD8.0
06984:  RRCF   x83,W
06986:  MOVWF  x69
06988:  RRCF   x82,W
0698A:  MOVWF  x68
....................             step_down_flip = midpt_flip; 
0698C:  MOVFF  569,565
06990:  MOVFF  568,564
....................         } 
....................         step_no_flip = 0; 
06994:  CLRF   x63
06996:  CLRF   x62
....................         step_acumulado_flip = 0; 
06998:  CLRF   x6D
0699A:  CLRF   x6C
0699C:  CLRF   x6B
0699E:  CLRF   x6A
....................         atual_frequencia_flip = 0; 
069A0:  CLRF   x6E
....................         ramp_sts_flip = ramp_up; // start ramp state-machine 
069A2:  MOVLW  01
069A4:  MOVWF  x61
....................         run_flg_flip = TRUE; 
069A6:  BSF    2D.3
....................         output_low(enable_flip); 
069A8:  BCF    F96.0
069AA:  BCF    F8D.0
....................         setup_timer_3(T3_INTERNAL | T3_DIV_BY_8); 
069AC:  MOVLW  B5
069AE:  MOVWF  FB1
....................         set_timer3(65535 - Ts_flip[0]); 
069B0:  MOVLW  FF
069B2:  BSF    FD8.0
069B4:  MOVLB  4
069B6:  SUBFWB xBE,W
069B8:  MOVLB  5
069BA:  MOVWF  x82
069BC:  MOVLW  FF
069BE:  MOVLB  4
069C0:  SUBFWB xBF,W
069C2:  MOVLB  5
069C4:  MOVWF  x83
069C6:  MOVLW  00
069C8:  MOVLB  4
069CA:  SUBFWB xC0,W
069CC:  MOVLW  00
069CE:  MOVLB  4
069D0:  SUBFWB xC1,W
069D2:  MOVLB  5
069D4:  MOVFF  583,FB3
069D8:  MOVFF  582,FB2
....................         enable_interrupts(INT_TIMER3); 
069DC:  BSF    FA0.1
069DE:  MOVLB  3
....................     } 
069E0:  MOVLB  0
069E2:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_subida_flip() { 
....................     if (atual_frequencia_flip == 0) { 
*
02386:  MOVLB  5
02388:  MOVF   x6E,F
0238A:  BTFSS  FD8.2
0238C:  BRA    24B0
....................         if (step_no_flip == StepbyF_flip[atual_frequencia_flip]) { 
0238E:  MOVF   x6E,W
02390:  MULLW  04
02392:  MOVF   FF3,W
02394:  CLRF   03
02396:  ADDLW  0E
02398:  MOVWF  FE9
0239A:  MOVLW  05
0239C:  ADDWFC 03,W
0239E:  MOVWF  FEA
023A0:  MOVFF  FEF,00
023A4:  MOVFF  FEC,01
023A8:  MOVFF  FEC,02
023AC:  MOVFF  FEC,03
023B0:  MOVF   00,W
023B2:  SUBWF  x62,W
023B4:  BNZ   246E
023B6:  MOVF   01,W
023B8:  SUBWF  x63,W
023BA:  BNZ   246E
023BC:  MOVF   02,F
023BE:  BNZ   246E
023C0:  MOVF   03,F
023C2:  BNZ   246E
....................             step_acumulado_flip += StepbyF_flip[atual_frequencia_flip] + StepbyF_flip[atual_frequencia_flip + 1]; 
023C4:  MOVF   x6E,W
023C6:  MULLW  04
023C8:  MOVF   FF3,W
023CA:  CLRF   03
023CC:  ADDLW  0E
023CE:  MOVWF  FE9
023D0:  MOVLW  05
023D2:  ADDWFC 03,W
023D4:  MOVWF  FEA
023D6:  MOVFF  FEF,5A5
023DA:  MOVFF  FEC,5A6
023DE:  MOVFF  FEC,5A7
023E2:  MOVFF  FEC,5A8
023E6:  MOVLW  01
023E8:  ADDWF  x6E,W
023EA:  MULLW  04
023EC:  MOVF   FF3,W
023EE:  CLRF   03
023F0:  ADDLW  0E
023F2:  MOVWF  FE9
023F4:  MOVLW  05
023F6:  ADDWFC 03,W
023F8:  MOVWF  FEA
023FA:  MOVFF  FEF,00
023FE:  MOVFF  FEC,01
02402:  MOVFF  FEC,02
02406:  MOVFF  FEC,03
0240A:  MOVF   xA5,W
0240C:  ADDWF  00,F
0240E:  MOVF   xA6,W
02410:  ADDWFC 01,F
02412:  MOVF   xA7,W
02414:  ADDWFC 02,F
02416:  MOVF   xA8,W
02418:  ADDWFC 03,F
0241A:  MOVF   00,W
0241C:  ADDWF  x6A,F
0241E:  MOVF   01,W
02420:  ADDWFC x6B,F
02422:  MOVF   02,W
02424:  ADDWFC x6C,F
02426:  MOVF   03,W
02428:  ADDWFC x6D,F
....................             atual_frequencia_flip++; 
0242A:  INCF   x6E,F
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
0242C:  MOVF   x6E,W
0242E:  MULLW  04
02430:  MOVF   FF3,W
02432:  CLRF   03
02434:  ADDLW  BE
02436:  MOVWF  FE9
02438:  MOVLW  04
0243A:  ADDWFC 03,W
0243C:  MOVWF  FEA
0243E:  MOVFF  FEF,00
02442:  MOVFF  FEC,01
02446:  MOVFF  FEC,02
0244A:  MOVFF  FEC,03
0244E:  MOVLW  FF
02450:  BSF    FD8.0
02452:  SUBFWB 00,W
02454:  MOVWF  xA5
02456:  MOVLW  FF
02458:  SUBFWB 01,W
0245A:  MOVWF  xA6
0245C:  MOVLW  00
0245E:  SUBFWB 02,W
02460:  MOVLW  00
02462:  SUBFWB 03,W
02464:  MOVFF  5A6,FB3
02468:  MOVFF  5A5,FB2
....................         } else { 
0246C:  BRA    24AE
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
0246E:  MOVF   x6E,W
02470:  MULLW  04
02472:  MOVF   FF3,W
02474:  CLRF   03
02476:  ADDLW  BE
02478:  MOVWF  FE9
0247A:  MOVLW  04
0247C:  ADDWFC 03,W
0247E:  MOVWF  FEA
02480:  MOVFF  FEF,00
02484:  MOVFF  FEC,01
02488:  MOVFF  FEC,02
0248C:  MOVFF  FEC,03
02490:  MOVLW  FF
02492:  BSF    FD8.0
02494:  SUBFWB 00,W
02496:  MOVWF  xA5
02498:  MOVLW  FF
0249A:  SUBFWB 01,W
0249C:  MOVWF  xA6
0249E:  MOVLW  00
024A0:  SUBFWB 02,W
024A2:  MOVLW  00
024A4:  SUBFWB 03,W
024A6:  MOVFF  5A6,FB3
024AA:  MOVFF  5A5,FB2
....................         } 
....................     } else if (atual_frequencia_flip == vel_flip) { 
024AE:  BRA    25C2
024B0:  MOVF   x6F,W
024B2:  SUBWF  x6E,W
024B4:  BNZ   24F8
....................         set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
024B6:  MOVF   x6E,W
024B8:  MULLW  04
024BA:  MOVF   FF3,W
024BC:  CLRF   03
024BE:  ADDLW  BE
024C0:  MOVWF  FE9
024C2:  MOVLW  04
024C4:  ADDWFC 03,W
024C6:  MOVWF  FEA
024C8:  MOVFF  FEF,00
024CC:  MOVFF  FEC,01
024D0:  MOVFF  FEC,02
024D4:  MOVFF  FEC,03
024D8:  MOVLW  FF
024DA:  BSF    FD8.0
024DC:  SUBFWB 00,W
024DE:  MOVWF  xA5
024E0:  MOVLW  FF
024E2:  SUBFWB 01,W
024E4:  MOVWF  xA6
024E6:  MOVLW  00
024E8:  SUBFWB 02,W
024EA:  MOVLW  00
024EC:  SUBFWB 03,W
024EE:  MOVFF  5A6,FB3
024F2:  MOVFF  5A5,FB2
....................     } else { 
024F6:  BRA    25C2
....................         if (step_no_flip == step_acumulado_flip) { 
024F8:  MOVF   x6A,W
024FA:  SUBWF  x62,W
024FC:  BNZ   2582
024FE:  MOVF   x6B,W
02500:  SUBWF  x63,W
02502:  BNZ   2582
02504:  MOVF   x6C,F
02506:  BNZ   2582
02508:  MOVF   x6D,F
0250A:  BNZ   2582
....................             atual_frequencia_flip++; 
0250C:  INCF   x6E,F
....................             step_acumulado_flip += StepbyF_flip[atual_frequencia_flip]; 
0250E:  MOVF   x6E,W
02510:  MULLW  04
02512:  MOVF   FF3,W
02514:  CLRF   03
02516:  ADDLW  0E
02518:  MOVWF  FE9
0251A:  MOVLW  05
0251C:  ADDWFC 03,W
0251E:  MOVWF  FEA
02520:  MOVFF  FEF,00
02524:  MOVFF  FEC,01
02528:  MOVFF  FEC,02
0252C:  MOVFF  FEC,03
02530:  MOVF   00,W
02532:  ADDWF  x6A,F
02534:  MOVF   01,W
02536:  ADDWFC x6B,F
02538:  MOVF   02,W
0253A:  ADDWFC x6C,F
0253C:  MOVF   03,W
0253E:  ADDWFC x6D,F
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
02540:  MOVF   x6E,W
02542:  MULLW  04
02544:  MOVF   FF3,W
02546:  CLRF   03
02548:  ADDLW  BE
0254A:  MOVWF  FE9
0254C:  MOVLW  04
0254E:  ADDWFC 03,W
02550:  MOVWF  FEA
02552:  MOVFF  FEF,00
02556:  MOVFF  FEC,01
0255A:  MOVFF  FEC,02
0255E:  MOVFF  FEC,03
02562:  MOVLW  FF
02564:  BSF    FD8.0
02566:  SUBFWB 00,W
02568:  MOVWF  xA5
0256A:  MOVLW  FF
0256C:  SUBFWB 01,W
0256E:  MOVWF  xA6
02570:  MOVLW  00
02572:  SUBFWB 02,W
02574:  MOVLW  00
02576:  SUBFWB 03,W
02578:  MOVFF  5A6,FB3
0257C:  MOVFF  5A5,FB2
....................         } else { 
02580:  BRA    25C2
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
02582:  MOVF   x6E,W
02584:  MULLW  04
02586:  MOVF   FF3,W
02588:  CLRF   03
0258A:  ADDLW  BE
0258C:  MOVWF  FE9
0258E:  MOVLW  04
02590:  ADDWFC 03,W
02592:  MOVWF  FEA
02594:  MOVFF  FEF,00
02598:  MOVFF  FEC,01
0259C:  MOVFF  FEC,02
025A0:  MOVFF  FEC,03
025A4:  MOVLW  FF
025A6:  BSF    FD8.0
025A8:  SUBFWB 00,W
025AA:  MOVWF  xA5
025AC:  MOVLW  FF
025AE:  SUBFWB 01,W
025B0:  MOVWF  xA6
025B2:  MOVLW  00
025B4:  SUBFWB 02,W
025B6:  MOVLW  00
025B8:  SUBFWB 03,W
025BA:  MOVFF  5A6,FB3
025BE:  MOVFF  5A5,FB2
....................         } 
....................         break; 
....................     } 
025C2:  MOVLB  0
025C4:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_descida_flip() { 
....................     if (atual_frequencia_flip == 0) { 
025C6:  MOVLB  5
025C8:  MOVF   x6E,F
025CA:  BNZ   260E
....................         set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
025CC:  MOVF   x6E,W
025CE:  MULLW  04
025D0:  MOVF   FF3,W
025D2:  CLRF   03
025D4:  ADDLW  BE
025D6:  MOVWF  FE9
025D8:  MOVLW  04
025DA:  ADDWFC 03,W
025DC:  MOVWF  FEA
025DE:  MOVFF  FEF,00
025E2:  MOVFF  FEC,01
025E6:  MOVFF  FEC,02
025EA:  MOVFF  FEC,03
025EE:  MOVLW  FF
025F0:  BSF    FD8.0
025F2:  SUBFWB 00,W
025F4:  MOVWF  xA5
025F6:  MOVLW  FF
025F8:  SUBFWB 01,W
025FA:  MOVWF  xA6
025FC:  MOVLW  00
025FE:  SUBFWB 02,W
02600:  MOVLW  00
02602:  SUBFWB 03,W
02604:  MOVFF  5A6,FB3
02608:  MOVFF  5A5,FB2
....................     } 
0260C:  BRA    2820
....................     else if (atual_frequencia_flip == vel_flip) { 
0260E:  MOVF   x6F,W
02610:  SUBWF  x6E,W
02612:  BTFSS  FD8.2
02614:  BRA    2756
....................         if (step_no_flip == (step_down_flip + StepbyF_flip[atual_frequencia_flip])) { 
02616:  MOVF   x6E,W
02618:  MULLW  04
0261A:  MOVF   FF3,W
0261C:  CLRF   03
0261E:  ADDLW  0E
02620:  MOVWF  FE9
02622:  MOVLW  05
02624:  ADDWFC 03,W
02626:  MOVWF  FEA
02628:  MOVFF  FEF,00
0262C:  MOVFF  FEC,01
02630:  MOVFF  FEC,02
02634:  MOVFF  FEC,03
02638:  MOVF   x64,W
0263A:  ADDWF  00,F
0263C:  MOVF   x65,W
0263E:  ADDWFC 01,F
02640:  MOVLW  00
02642:  ADDWFC 02,F
02644:  ADDWFC 03,F
02646:  MOVF   00,W
02648:  SUBWF  x62,W
0264A:  BNZ   2714
0264C:  MOVF   01,W
0264E:  SUBWF  x63,W
02650:  BNZ   2714
02652:  MOVF   02,F
02654:  BNZ   2714
02656:  MOVF   03,F
02658:  BNZ   2714
....................             step_acumulado_flip = step_down_flip + StepbyF_flip[atual_frequencia_flip] + StepbyF_flip[atual_frequencia_flip - 1]; 
0265A:  MOVF   x6E,W
0265C:  MULLW  04
0265E:  MOVF   FF3,W
02660:  CLRF   03
02662:  ADDLW  0E
02664:  MOVWF  FE9
02666:  MOVLW  05
02668:  ADDWFC 03,W
0266A:  MOVWF  FEA
0266C:  MOVFF  FEF,00
02670:  MOVFF  FEC,01
02674:  MOVFF  FEC,02
02678:  MOVFF  FEC,03
0267C:  MOVF   00,W
0267E:  ADDWF  x64,W
02680:  MOVWF  xA5
02682:  MOVF   01,W
02684:  ADDWFC x65,W
02686:  MOVWF  xA6
02688:  MOVLW  00
0268A:  ADDWFC 02,W
0268C:  MOVWF  xA7
0268E:  MOVLW  00
02690:  ADDWFC 03,W
02692:  MOVWF  xA8
02694:  MOVLW  01
02696:  SUBWF  x6E,W
02698:  MULLW  04
0269A:  MOVF   FF3,W
0269C:  CLRF   03
0269E:  ADDLW  0E
026A0:  MOVWF  FE9
026A2:  MOVLW  05
026A4:  ADDWFC 03,W
026A6:  MOVWF  FEA
026A8:  MOVFF  FEF,00
026AC:  MOVFF  FEC,01
026B0:  MOVFF  FEC,02
026B4:  MOVFF  FEC,03
026B8:  MOVF   00,W
026BA:  ADDWF  xA5,W
026BC:  MOVWF  x6A
026BE:  MOVF   01,W
026C0:  ADDWFC xA6,W
026C2:  MOVWF  x6B
026C4:  MOVF   02,W
026C6:  ADDWFC xA7,W
026C8:  MOVWF  x6C
026CA:  MOVF   03,W
026CC:  ADDWFC xA8,W
026CE:  MOVWF  x6D
....................             atual_frequencia_flip--; 
026D0:  DECF   x6E,F
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
026D2:  MOVF   x6E,W
026D4:  MULLW  04
026D6:  MOVF   FF3,W
026D8:  CLRF   03
026DA:  ADDLW  BE
026DC:  MOVWF  FE9
026DE:  MOVLW  04
026E0:  ADDWFC 03,W
026E2:  MOVWF  FEA
026E4:  MOVFF  FEF,00
026E8:  MOVFF  FEC,01
026EC:  MOVFF  FEC,02
026F0:  MOVFF  FEC,03
026F4:  MOVLW  FF
026F6:  BSF    FD8.0
026F8:  SUBFWB 00,W
026FA:  MOVWF  xA5
026FC:  MOVLW  FF
026FE:  SUBFWB 01,W
02700:  MOVWF  xA6
02702:  MOVLW  00
02704:  SUBFWB 02,W
02706:  MOVLW  00
02708:  SUBFWB 03,W
0270A:  MOVFF  5A6,FB3
0270E:  MOVFF  5A5,FB2
....................         } else { 
02712:  BRA    2754
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
02714:  MOVF   x6E,W
02716:  MULLW  04
02718:  MOVF   FF3,W
0271A:  CLRF   03
0271C:  ADDLW  BE
0271E:  MOVWF  FE9
02720:  MOVLW  04
02722:  ADDWFC 03,W
02724:  MOVWF  FEA
02726:  MOVFF  FEF,00
0272A:  MOVFF  FEC,01
0272E:  MOVFF  FEC,02
02732:  MOVFF  FEC,03
02736:  MOVLW  FF
02738:  BSF    FD8.0
0273A:  SUBFWB 00,W
0273C:  MOVWF  xA5
0273E:  MOVLW  FF
02740:  SUBFWB 01,W
02742:  MOVWF  xA6
02744:  MOVLW  00
02746:  SUBFWB 02,W
02748:  MOVLW  00
0274A:  SUBFWB 03,W
0274C:  MOVFF  5A6,FB3
02750:  MOVFF  5A5,FB2
....................         } 
....................     } else { 
02754:  BRA    2820
....................         if (step_no_flip == step_acumulado_flip) { 
02756:  MOVF   x6A,W
02758:  SUBWF  x62,W
0275A:  BNZ   27E0
0275C:  MOVF   x6B,W
0275E:  SUBWF  x63,W
02760:  BNZ   27E0
02762:  MOVF   x6C,F
02764:  BNZ   27E0
02766:  MOVF   x6D,F
02768:  BNZ   27E0
....................             atual_frequencia_flip--; 
0276A:  DECF   x6E,F
....................             step_acumulado_flip += StepbyF_flip[atual_frequencia_flip]; 
0276C:  MOVF   x6E,W
0276E:  MULLW  04
02770:  MOVF   FF3,W
02772:  CLRF   03
02774:  ADDLW  0E
02776:  MOVWF  FE9
02778:  MOVLW  05
0277A:  ADDWFC 03,W
0277C:  MOVWF  FEA
0277E:  MOVFF  FEF,00
02782:  MOVFF  FEC,01
02786:  MOVFF  FEC,02
0278A:  MOVFF  FEC,03
0278E:  MOVF   00,W
02790:  ADDWF  x6A,F
02792:  MOVF   01,W
02794:  ADDWFC x6B,F
02796:  MOVF   02,W
02798:  ADDWFC x6C,F
0279A:  MOVF   03,W
0279C:  ADDWFC x6D,F
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
0279E:  MOVF   x6E,W
027A0:  MULLW  04
027A2:  MOVF   FF3,W
027A4:  CLRF   03
027A6:  ADDLW  BE
027A8:  MOVWF  FE9
027AA:  MOVLW  04
027AC:  ADDWFC 03,W
027AE:  MOVWF  FEA
027B0:  MOVFF  FEF,00
027B4:  MOVFF  FEC,01
027B8:  MOVFF  FEC,02
027BC:  MOVFF  FEC,03
027C0:  MOVLW  FF
027C2:  BSF    FD8.0
027C4:  SUBFWB 00,W
027C6:  MOVWF  xA5
027C8:  MOVLW  FF
027CA:  SUBFWB 01,W
027CC:  MOVWF  xA6
027CE:  MOVLW  00
027D0:  SUBFWB 02,W
027D2:  MOVLW  00
027D4:  SUBFWB 03,W
027D6:  MOVFF  5A6,FB3
027DA:  MOVFF  5A5,FB2
....................         } else { 
027DE:  BRA    2820
....................             set_timer3(65535 - Ts_flip[atual_frequencia_flip]); 
027E0:  MOVF   x6E,W
027E2:  MULLW  04
027E4:  MOVF   FF3,W
027E6:  CLRF   03
027E8:  ADDLW  BE
027EA:  MOVWF  FE9
027EC:  MOVLW  04
027EE:  ADDWFC 03,W
027F0:  MOVWF  FEA
027F2:  MOVFF  FEF,00
027F6:  MOVFF  FEC,01
027FA:  MOVFF  FEC,02
027FE:  MOVFF  FEC,03
02802:  MOVLW  FF
02804:  BSF    FD8.0
02806:  SUBFWB 00,W
02808:  MOVWF  xA5
0280A:  MOVLW  FF
0280C:  SUBFWB 01,W
0280E:  MOVWF  xA6
02810:  MOVLW  00
02812:  SUBFWB 02,W
02814:  MOVLW  00
02816:  SUBFWB 03,W
02818:  MOVFF  5A6,FB3
0281C:  MOVFF  5A5,FB2
....................         } 
....................     } 
02820:  MOVLB  0
02822:  GOTO   2888 (RETURN)
.................... } 
....................  
.................... void movimenta_eixo_flip() { 
....................  
....................     switch (ramp_sts_flip) { 
02826:  MOVLB  5
02828:  MOVF   x61,W
0282A:  XORLW  01
0282C:  MOVLB  0
0282E:  BZ    283A
02830:  XORLW  02
02832:  BZ    287C
02834:  XORLW  01
02836:  BZ    289C
02838:  BRA    28BE
....................         case ramp_up: // accel 
....................             output_toggle(step_flip); 
0283A:  BCF    F96.2
0283C:  BTG    F8D.2
....................             rest_flip = ~rest_flip; 
0283E:  MOVLB  3
02840:  BTG    xB7.4
....................             proximo_valor_subida_flip(); 
02842:  MOVLB  0
02844:  RCALL  2386
....................             if (step_no_flip == midpt_flip) { // midpoint: decel 
02846:  MOVLB  5
02848:  MOVF   x68,W
0284A:  SUBWF  x62,W
0284C:  BNZ   287A
0284E:  MOVF   x69,W
02850:  SUBWF  x63,W
02852:  BNZ   287A
....................                 if (move_flip > 2 * total_acc_step_flip) 
02854:  BCF    FD8.0
02856:  RLCF   x5E,W
02858:  MOVWF  02
0285A:  RLCF   x5F,W
0285C:  MOVWF  03
0285E:  MOVFF  02,01
02862:  MOVF   03,W
02864:  SUBWF  x67,W
02866:  BNC   2876
02868:  BNZ   2870
0286A:  MOVF   x66,W
0286C:  SUBWF  01,W
0286E:  BC    2876
....................                     ramp_sts_flip = ramp_max; 
02870:  MOVLW  02
02872:  MOVWF  x61
02874:  BRA    287A
....................                 else 
....................                     ramp_sts_flip = ramp_down; 
02876:  MOVLW  03
02878:  MOVWF  x61
....................             } 
....................             break; 
0287A:  BRA    28C6
....................  
....................         case ramp_down: // decel 
....................             output_toggle(step_flip); 
0287C:  BCF    F96.2
0287E:  BTG    F8D.2
....................             rest_flip = ~rest_flip; 
02880:  MOVLB  3
02882:  BTG    xB7.4
....................             proximo_valor_descida_flip(); 
02884:  MOVLB  0
02886:  BRA    25C6
....................             if (step_no_flip == move_flip) 
02888:  MOVLB  5
0288A:  MOVF   x66,W
0288C:  SUBWF  x62,W
0288E:  BNZ   289A
02890:  MOVF   x67,W
02892:  SUBWF  x63,W
02894:  BNZ   289A
....................                 ramp_sts_flip = ramp_last; 
02896:  MOVLW  04
02898:  MOVWF  x61
....................             break; 
0289A:  BRA    28C6
....................  
....................         case ramp_max: // constant speed 
....................             output_toggle(step_flip); 
0289C:  BCF    F96.2
0289E:  BTG    F8D.2
....................             rest_flip = ~rest_flip; 
028A0:  MOVLB  3
028A2:  BTG    xB7.4
....................             proximo_valor_subida_flip(); 
028A4:  MOVLB  0
028A6:  RCALL  2386
....................             if (step_no_flip == step_down_flip) // start decel 
028A8:  MOVLB  5
028AA:  MOVF   x64,W
028AC:  SUBWF  x62,W
028AE:  BNZ   28BA
028B0:  MOVF   x65,W
028B2:  SUBWF  x63,W
028B4:  BNZ   28BA
....................                 ramp_sts_flip = ramp_down; 
028B6:  MOVLW  03
028B8:  MOVWF  x61
....................             break; 
028BA:  BRA    28C6
028BC:  MOVLB  0
....................  
....................         default: // last step: cleanup 
....................             ramp_sts_flip = ramp_idle; 
028BE:  MOVLB  5
028C0:  CLRF   x61
....................             disable_interrupts(INT_TIMER3); 
028C2:  BCF    FA0.1
....................             run_flg_flip = FALSE; // move_z complete 
028C4:  BCF    2D.3
....................             break; 
....................     } // switch (ramp_sts_z) 
....................     if (ramp_sts_flip != ramp_idle) { 
028C6:  MOVF   x61,F
028C8:  BZ    28EA
....................         if (rest_flip) { 
028CA:  MOVLB  3
028CC:  BTFSS  xB7.4
028CE:  BRA    28EC
....................             motor_pos_flip += pos_inc_flip; 
028D0:  CLRF   03
028D2:  MOVLB  5
028D4:  MOVF   x60,W
028D6:  BTFSC  FE8.7
028D8:  DECF   03,F
028DA:  MOVLB  2
028DC:  ADDWF  x07,F
028DE:  MOVF   03,W
028E0:  ADDWFC x08,F
....................             ++step_no_flip; 
028E2:  MOVLB  5
028E4:  INCF   x62,F
028E6:  BTFSC  FD8.2
028E8:  INCF   x63,F
028EA:  MOVLB  3
....................         } 
....................     } 
028EC:  MOVLB  0
028EE:  GOTO   28FC (RETURN)
.................... } 
....................  
.................... void umpasso_flip(int16 descanco, short dir) { 
....................     output_low(enable_flip); 
....................     if (dir) { 
....................         output_high(dir_flip); 
....................         motor_pos_flip--; 
....................     } else { 
....................         output_low(dir_flip); 
....................         motor_pos_flip++; 
....................     } 
....................     output_high(step_flip); 
....................     delay_us(descanco); 
....................     output_low(step_flip); 
....................     delay_us(descanco); 
....................  
.................... } 
....................  
.................... void zerar_flip() { 
....................  
....................     while (le_Input(s_limite_flip) == 1) { 
....................         delay_us(200); 
....................         umpasso_flip(600, FALSE);//600 
....................     } 
....................     while (le_Input(s_limite_flip) == 0) { 
....................         delay_us(200); 
....................         umpasso_flip(900, TRUE);//900 
....................     } 
....................     while (le_Input(s_limite_flip) == 1) { 
....................         delay_us(200); 
....................         umpasso_flip(1000, FALSE);//1000 
....................     } 
....................    // output_high(enable_z); 
....................     motor_pos_flip = 0; 
.................... } 
....................  
.................... void medir_flip() { 
....................     while (le_Input(i_limite_flip) == 0) { 
....................         umpasso_flip(900, FALSE); 
....................         delay_us(200); 
....................     } 
....................     while (le_Input(i_limite_flip) == 1) { 
....................         umpasso_flip(900, TRUE); 
....................         delay_us(200); 
....................     } 
....................     max_posicao_flip = motor_pos_flip; 
....................     output_high(enable_flip); 
....................     printf(lcd_putc, "%04Lu", max_posicao_flip); 
.................... } 
.................... // </editor-fold> 
....................  
.................... #include "movimentos_maq_1.c" 
.................... int   flip_home(void) { 
*
054B4:  MOVLB  5
054B6:  CLRF   x77
.................... 	int i; 
....................     int erro=0; 
.................... 	chopper_flip(); 
054B8:  MOVLB  0
054BA:  BRA    545C
.................... 	delay_ms(50);	 
054BC:  MOVLW  32
054BE:  MOVLB  5
054C0:  MOVWF  x91
054C2:  MOVLB  0
054C4:  CALL   2954
.................... 	if(le_Input(S_ROTACAO_LS1) == true) { 
054C8:  MOVLW  0B
054CA:  MOVLB  5
054CC:  MOVWF  x78
054CE:  MOVLB  0
054D0:  CALL   49FA
054D4:  DECFSZ 01,W
054D6:  BRA    5568
.................... 		sentido_horario(); 
054D8:  RCALL  5464
.................... 		delay_ms(50); 
054DA:  MOVLW  32
054DC:  MOVLB  5
054DE:  MOVWF  x91
054E0:  MOVLB  0
054E2:  CALL   2954
.................... 	    for(i=0;i<=140;i++) {							 
054E6:  MOVLB  5
054E8:  CLRF   x76
054EA:  MOVF   x76,W
054EC:  SUBLW  8C
054EE:  BNC   5506
.................... 		    one_step_flip(); 
054F0:  MOVLB  0
054F2:  RCALL  5472
.................... 			delay_us(4000); 
054F4:  MOVLW  04
054F6:  MOVLB  5
054F8:  MOVWF  x91
054FA:  MOVLB  0
054FC:  CALL   2954
05500:  MOVLB  5
05502:  INCF   x76,F
05504:  BRA    54EA
.................... 		} 
.................... 		sentido_antihorario(); 
05506:  MOVLB  0
05508:  RCALL  54A6
.................... 		delay_ms(100); 
0550A:  MOVLW  64
0550C:  MOVLB  5
0550E:  MOVWF  x91
05510:  MOVLB  0
05512:  CALL   2954
.................... 	    while(le_Input(S_ROTACAO_LS1) == false) {				 
05516:  MOVLW  0B
05518:  MOVLB  5
0551A:  MOVWF  x78
0551C:  MOVLB  0
0551E:  CALL   49FA
05522:  MOVF   01,F
05524:  BNZ   5536
....................             one_step_flip(); 
05526:  RCALL  5472
....................             delay_us(4000); 
05528:  MOVLW  04
0552A:  MOVLB  5
0552C:  MOVWF  x91
0552E:  MOVLB  0
05530:  CALL   2954
05534:  BRA    5516
.................... 		}				 
....................         for(i=0;i<=36;i++) { 
05536:  MOVLB  5
05538:  CLRF   x76
0553A:  MOVF   x76,W
0553C:  SUBLW  24
0553E:  BNC   5556
....................             one_step_flip(); 
05540:  MOVLB  0
05542:  RCALL  5472
....................             delay_us(4000); 
05544:  MOVLW  04
05546:  MOVLB  5
05548:  MOVWF  x91
0554A:  MOVLB  0
0554C:  CALL   2954
05550:  MOVLB  5
05552:  INCF   x76,F
05554:  BRA    553A
....................         } 
....................         sentido_horario(); 
05556:  MOVLB  0
05558:  RCALL  5464
....................         delay_ms(50);		 
0555A:  MOVLW  32
0555C:  MOVLB  5
0555E:  MOVWF  x91
05560:  MOVLB  0
05562:  CALL   2954
.................... 	}else{			 
05566:  BRA    55B8
....................         sentido_antihorario(); 
05568:  RCALL  54A6
....................         delay_ms(50); 
0556A:  MOVLW  32
0556C:  MOVLB  5
0556E:  MOVWF  x91
05570:  MOVLB  0
05572:  CALL   2954
....................         while(le_Input(S_ROTACAO_LS1) == false){				 
05576:  MOVLW  0B
05578:  MOVLB  5
0557A:  MOVWF  x78
0557C:  MOVLB  0
0557E:  CALL   49FA
05582:  MOVF   01,F
05584:  BNZ   5596
....................             one_step_flip(); 
05586:  RCALL  5472
....................             delay_us(2000); 
05588:  MOVLW  02
0558A:  MOVLB  5
0558C:  MOVWF  x91
0558E:  MOVLB  0
05590:  CALL   2954
05594:  BRA    5576
....................         }				 
....................         for(i=0;i<=36;i++) { 
05596:  MOVLB  5
05598:  CLRF   x76
0559A:  MOVF   x76,W
0559C:  SUBLW  24
0559E:  BNC   55B6
....................             one_step_flip(); 
055A0:  MOVLB  0
055A2:  RCALL  5472
....................             delay_us(4000); 
055A4:  MOVLW  04
055A6:  MOVLB  5
055A8:  MOVWF  x91
055AA:  MOVLB  0
055AC:  CALL   2954
055B0:  MOVLB  5
055B2:  INCF   x76,F
055B4:  BRA    559A
055B6:  MOVLB  0
....................         } 
.................... 	}	  
....................     sentido_horario(); 
055B8:  RCALL  5464
....................     delay_ms(50); 
055BA:  MOVLW  32
055BC:  MOVLB  5
055BE:  MOVWF  x91
055C0:  MOVLB  0
055C2:  CALL   2954
....................     for(i=0;i<=71;i++) { 
055C6:  MOVLB  5
055C8:  CLRF   x76
055CA:  MOVF   x76,W
055CC:  SUBLW  47
055CE:  BNC   55E6
....................         one_step_flip(); 
055D0:  MOVLB  0
055D2:  RCALL  5472
....................         delay_us(4000); 
055D4:  MOVLW  04
055D6:  MOVLB  5
055D8:  MOVWF  x91
055DA:  MOVLB  0
055DC:  CALL   2954
055E0:  MOVLB  5
055E2:  INCF   x76,F
055E4:  BRA    55CA
....................     } 
....................     motor_pos_flip = 0;			 
055E6:  MOVLB  2
055E8:  CLRF   x08
055EA:  CLRF   x07
....................     return erro; 
055EC:  MOVLB  5
055EE:  MOVFF  577,01
055F2:  MOVLB  0
055F4:  RETURN 0
.................... } 
.................... void  x_home_esquerda() { 
.................... 	int i; 
.................... 	chopper_x(); 
*
04F48:  RCALL  4EF0
.................... 	delay_ms(50);	 
04F4A:  MOVLW  32
04F4C:  MOVLB  5
04F4E:  MOVWF  x91
04F50:  MOVLB  0
04F52:  CALL   2954
.................... 	if(le_Input(S_X_ESQUERDA) == true) { 
04F56:  MOVLW  06
04F58:  MOVLB  5
04F5A:  MOVWF  x78
04F5C:  MOVLB  0
04F5E:  RCALL  49FA
04F60:  DECFSZ 01,W
04F62:  BRA    5002
.................... 		direita(); 
04F64:  RCALL  4EF6
.................... 		delay_ms(50); 
04F66:  MOVLW  32
04F68:  MOVLB  5
04F6A:  MOVWF  x91
04F6C:  MOVLB  0
04F6E:  CALL   2954
....................         while(le_Input(S_X_ESQUERDA) == true) { 
04F72:  MOVLW  06
04F74:  MOVLB  5
04F76:  MOVWF  x78
04F78:  MOVLB  0
04F7A:  RCALL  49FA
04F7C:  DECFSZ 01,W
04F7E:  BRA    4F90
....................             one_step_x(); 
04F80:  RCALL  4F00
....................             delay_us(2000); 
04F82:  MOVLW  02
04F84:  MOVLB  5
04F86:  MOVWF  x91
04F88:  MOVLB  0
04F8A:  CALL   2954
04F8E:  BRA    4F72
....................         } 
....................         for(i=0;i<=40;i++) { 
04F90:  MOVLB  5
04F92:  CLRF   x76
04F94:  MOVF   x76,W
04F96:  SUBLW  28
04F98:  BNC   4FB0
....................             one_step_x(); 
04F9A:  MOVLB  0
04F9C:  RCALL  4F00
....................             delay_us(2000); 
04F9E:  MOVLW  02
04FA0:  MOVLB  5
04FA2:  MOVWF  x91
04FA4:  MOVLB  0
04FA6:  CALL   2954
04FAA:  MOVLB  5
04FAC:  INCF   x76,F
04FAE:  BRA    4F94
....................         } 
.................... 		esquerda(); 
04FB0:  MOVLB  0
04FB2:  RCALL  4F38
.................... 		delay_ms(50); 
04FB4:  MOVLW  32
04FB6:  MOVLB  5
04FB8:  MOVWF  x91
04FBA:  MOVLB  0
04FBC:  CALL   2954
....................         while(le_Input(S_X_ESQUERDA) == false) {				 
04FC0:  MOVLW  06
04FC2:  MOVLB  5
04FC4:  MOVWF  x78
04FC6:  MOVLB  0
04FC8:  RCALL  49FA
04FCA:  MOVF   01,F
04FCC:  BNZ   4FDE
....................             one_step_x(); 
04FCE:  RCALL  4F00
....................             delay_us(2000); 
04FD0:  MOVLW  02
04FD2:  MOVLB  5
04FD4:  MOVWF  x91
04FD6:  MOVLB  0
04FD8:  CALL   2954
04FDC:  BRA    4FC0
.................... 		}			 
....................         for(i=0;i<=40;i++) { 
04FDE:  MOVLB  5
04FE0:  CLRF   x76
04FE2:  MOVF   x76,W
04FE4:  SUBLW  28
04FE6:  BNC   4FFE
....................             one_step_x(); 
04FE8:  MOVLB  0
04FEA:  RCALL  4F00
....................             delay_us(2000); 
04FEC:  MOVLW  02
04FEE:  MOVLB  5
04FF0:  MOVWF  x91
04FF2:  MOVLB  0
04FF4:  CALL   2954
04FF8:  MOVLB  5
04FFA:  INCF   x76,F
04FFC:  BRA    4FE2
....................         } 
.................... 	}else{ 
04FFE:  BRA    504E
05000:  MOVLB  0
....................         esquerda(); 
05002:  RCALL  4F38
....................         delay_ms(50); 
05004:  MOVLW  32
05006:  MOVLB  5
05008:  MOVWF  x91
0500A:  MOVLB  0
0500C:  CALL   2954
....................         while(le_Input(S_X_ESQUERDA) == false) { 
05010:  MOVLW  06
05012:  MOVLB  5
05014:  MOVWF  x78
05016:  MOVLB  0
05018:  RCALL  49FA
0501A:  MOVF   01,F
0501C:  BNZ   502E
....................             one_step_x(); 
0501E:  RCALL  4F00
....................             delay_us(2000); 
05020:  MOVLW  02
05022:  MOVLB  5
05024:  MOVWF  x91
05026:  MOVLB  0
05028:  CALL   2954
0502C:  BRA    5010
....................         }				 
....................         for(i=0;i<=40;i++) { 
0502E:  MOVLB  5
05030:  CLRF   x76
05032:  MOVF   x76,W
05034:  SUBLW  28
05036:  BNC   504E
....................             one_step_x(); 
05038:  MOVLB  0
0503A:  RCALL  4F00
....................             delay_us(2000); 
0503C:  MOVLW  02
0503E:  MOVLB  5
05040:  MOVWF  x91
05042:  MOVLB  0
05044:  CALL   2954
05048:  MOVLB  5
0504A:  INCF   x76,F
0504C:  BRA    5032
....................         } 
.................... 	}	 
....................     motor_pos_x = 0;  
0504E:  MOVLB  2
05050:  CLRF   x04
05052:  CLRF   x03
....................     stop_x();			 
05054:  MOVLB  0
05056:  RCALL  4F42
05058:  RETURN 0
.................... } 
.................... void  y_home_frente(){ 
.................... 	int i; 
.................... 	chopper_y(); 
0505A:  RCALL  4D82
.................... 	delay_ms(50);	 
0505C:  MOVLW  32
0505E:  MOVLB  5
05060:  MOVWF  x91
05062:  MOVLB  0
05064:  CALL   2954
.................... 	if(le_Input(S_Y_FRENTE) == true) { 
05068:  MOVLW  07
0506A:  MOVLB  5
0506C:  MOVWF  x78
0506E:  MOVLB  0
05070:  RCALL  49FA
05072:  DECFSZ 01,W
05074:  BRA    5114
.................... 		atras(); 
05076:  RCALL  4DCA
.................... 		delay_ms(50); 
05078:  MOVLW  32
0507A:  MOVLB  5
0507C:  MOVWF  x91
0507E:  MOVLB  0
05080:  CALL   2954
....................         while(le_Input(S_Y_FRENTE) == true) { 
05084:  MOVLW  07
05086:  MOVLB  5
05088:  MOVWF  x78
0508A:  MOVLB  0
0508C:  RCALL  49FA
0508E:  DECFSZ 01,W
05090:  BRA    50A2
....................             one_step_y(); 
05092:  RCALL  4D96
....................             delay_us(2000); 
05094:  MOVLW  02
05096:  MOVLB  5
05098:  MOVWF  x91
0509A:  MOVLB  0
0509C:  CALL   2954
050A0:  BRA    5084
....................         } 
....................         for(i=0;i<=40;i++) { //para sair do histerese do sensor dando maior precisao 
050A2:  MOVLB  5
050A4:  CLRF   x76
050A6:  MOVF   x76,W
050A8:  SUBLW  28
050AA:  BNC   50C2
....................             one_step_y(); 
050AC:  MOVLB  0
050AE:  RCALL  4D96
....................             delay_us(2000); 
050B0:  MOVLW  02
050B2:  MOVLB  5
050B4:  MOVWF  x91
050B6:  MOVLB  0
050B8:  CALL   2954
050BC:  MOVLB  5
050BE:  INCF   x76,F
050C0:  BRA    50A6
....................         } 
.................... 		frente(); 
050C2:  MOVLB  0
050C4:  RCALL  4D88
.................... 		delay_ms(50); 
050C6:  MOVLW  32
050C8:  MOVLB  5
050CA:  MOVWF  x91
050CC:  MOVLB  0
050CE:  CALL   2954
....................         while(le_Input(S_Y_FRENTE) == false){				 
050D2:  MOVLW  07
050D4:  MOVLB  5
050D6:  MOVWF  x78
050D8:  MOVLB  0
050DA:  RCALL  49FA
050DC:  MOVF   01,F
050DE:  BNZ   50F0
....................             one_step_y(); 
050E0:  RCALL  4D96
....................             delay_us(2000); 
050E2:  MOVLW  02
050E4:  MOVLB  5
050E6:  MOVWF  x91
050E8:  MOVLB  0
050EA:  CALL   2954
050EE:  BRA    50D2
....................         }				 
....................         for(i=0;i<=40;i++){ 
050F0:  MOVLB  5
050F2:  CLRF   x76
050F4:  MOVF   x76,W
050F6:  SUBLW  28
050F8:  BNC   5110
....................             one_step_y(); 
050FA:  MOVLB  0
050FC:  RCALL  4D96
....................             delay_us(2000); 
050FE:  MOVLW  02
05100:  MOVLB  5
05102:  MOVWF  x91
05104:  MOVLB  0
05106:  CALL   2954
0510A:  MOVLB  5
0510C:  INCF   x76,F
0510E:  BRA    50F4
....................         } 
.................... 	}else{ 
05110:  BRA    5160
05112:  MOVLB  0
....................         frente(); 
05114:  RCALL  4D88
....................         delay_ms(50); 
05116:  MOVLW  32
05118:  MOVLB  5
0511A:  MOVWF  x91
0511C:  MOVLB  0
0511E:  CALL   2954
....................         while(le_Input(S_Y_FRENTE) == false) { 
05122:  MOVLW  07
05124:  MOVLB  5
05126:  MOVWF  x78
05128:  MOVLB  0
0512A:  RCALL  49FA
0512C:  MOVF   01,F
0512E:  BNZ   5140
....................             one_step_y(); 
05130:  RCALL  4D96
....................             delay_us(2000); 
05132:  MOVLW  02
05134:  MOVLB  5
05136:  MOVWF  x91
05138:  MOVLB  0
0513A:  CALL   2954
0513E:  BRA    5122
....................         }				 
....................         for(i=0;i<=40;i++) { 
05140:  MOVLB  5
05142:  CLRF   x76
05144:  MOVF   x76,W
05146:  SUBLW  28
05148:  BNC   5160
....................             one_step_y(); 
0514A:  MOVLB  0
0514C:  RCALL  4D96
....................             delay_us(2000); 
0514E:  MOVLW  02
05150:  MOVLB  5
05152:  MOVWF  x91
05154:  MOVLB  0
05156:  CALL   2954
0515A:  MOVLB  5
0515C:  INCF   x76,F
0515E:  BRA    5144
....................         } 
.................... 	}	 
....................     motor_pos_y = 0;   
05160:  MOVLB  2
05162:  CLRF   x06
05164:  CLRF   x05
....................     stop_y();			 
05166:  MOVLB  0
05168:  RCALL  4DD8
0516A:  RETURN 0
.................... } 
.................... void  y_home_atras() { 
.................... 	int i; 
.................... 	chopper_y(); 
*
04DDE:  RCALL  4D82
.................... 	delay_ms(50);	 
04DE0:  MOVLW  32
04DE2:  MOVLB  5
04DE4:  MOVWF  x91
04DE6:  MOVLB  0
04DE8:  CALL   2954
.................... 	if(le_Input(S_Y_ATRAS) == true) { 
04DEC:  MOVLW  08
04DEE:  MOVLB  5
04DF0:  MOVWF  x78
04DF2:  MOVLB  0
04DF4:  RCALL  49FA
04DF6:  DECFSZ 01,W
04DF8:  BRA    4E98
.................... 		frente(); 
04DFA:  RCALL  4D88
.................... 		delay_ms(50); 
04DFC:  MOVLW  32
04DFE:  MOVLB  5
04E00:  MOVWF  x91
04E02:  MOVLB  0
04E04:  CALL   2954
....................         while(le_Input(S_Y_ATRAS) == true){ 
04E08:  MOVLW  08
04E0A:  MOVLB  5
04E0C:  MOVWF  x78
04E0E:  MOVLB  0
04E10:  RCALL  49FA
04E12:  DECFSZ 01,W
04E14:  BRA    4E26
....................             one_step_y(); 
04E16:  RCALL  4D96
....................             delay_us(2000); 
04E18:  MOVLW  02
04E1A:  MOVLB  5
04E1C:  MOVWF  x91
04E1E:  MOVLB  0
04E20:  CALL   2954
04E24:  BRA    4E08
....................         } 
....................         for(i=0;i<=40;i++){ //para sair do histerese do sensor dando maior precisao 
04E26:  MOVLB  5
04E28:  CLRF   x76
04E2A:  MOVF   x76,W
04E2C:  SUBLW  28
04E2E:  BNC   4E46
....................             one_step_y(); 
04E30:  MOVLB  0
04E32:  RCALL  4D96
....................             delay_us(2000); 
04E34:  MOVLW  02
04E36:  MOVLB  5
04E38:  MOVWF  x91
04E3A:  MOVLB  0
04E3C:  CALL   2954
04E40:  MOVLB  5
04E42:  INCF   x76,F
04E44:  BRA    4E2A
....................         } 
.................... 		atras(); 
04E46:  MOVLB  0
04E48:  RCALL  4DCA
.................... 		delay_ms(50); 
04E4A:  MOVLW  32
04E4C:  MOVLB  5
04E4E:  MOVWF  x91
04E50:  MOVLB  0
04E52:  CALL   2954
....................         while(le_Input(S_Y_ATRAS) == false) {				 
04E56:  MOVLW  08
04E58:  MOVLB  5
04E5A:  MOVWF  x78
04E5C:  MOVLB  0
04E5E:  RCALL  49FA
04E60:  MOVF   01,F
04E62:  BNZ   4E74
....................             one_step_y(); 
04E64:  RCALL  4D96
....................             delay_us(2000); 
04E66:  MOVLW  02
04E68:  MOVLB  5
04E6A:  MOVWF  x91
04E6C:  MOVLB  0
04E6E:  CALL   2954
04E72:  BRA    4E56
....................         }				 
....................         for(i=0;i<=40;i++){ 
04E74:  MOVLB  5
04E76:  CLRF   x76
04E78:  MOVF   x76,W
04E7A:  SUBLW  28
04E7C:  BNC   4E94
....................             one_step_y(); 
04E7E:  MOVLB  0
04E80:  RCALL  4D96
....................             delay_us(2000); 
04E82:  MOVLW  02
04E84:  MOVLB  5
04E86:  MOVWF  x91
04E88:  MOVLB  0
04E8A:  CALL   2954
04E8E:  MOVLB  5
04E90:  INCF   x76,F
04E92:  BRA    4E78
....................         } 
.................... 	}else{ 
04E94:  BRA    4EE4
04E96:  MOVLB  0
....................         atras(); 
04E98:  RCALL  4DCA
....................         delay_ms(50); 
04E9A:  MOVLW  32
04E9C:  MOVLB  5
04E9E:  MOVWF  x91
04EA0:  MOVLB  0
04EA2:  CALL   2954
....................         while(le_Input(S_Y_ATRAS) == false) { 
04EA6:  MOVLW  08
04EA8:  MOVLB  5
04EAA:  MOVWF  x78
04EAC:  MOVLB  0
04EAE:  RCALL  49FA
04EB0:  MOVF   01,F
04EB2:  BNZ   4EC4
....................             one_step_y(); 
04EB4:  RCALL  4D96
....................             delay_us(2000); 
04EB6:  MOVLW  02
04EB8:  MOVLB  5
04EBA:  MOVWF  x91
04EBC:  MOVLB  0
04EBE:  CALL   2954
04EC2:  BRA    4EA6
....................         } 
....................         for(i=0;i<=40;i++) { 
04EC4:  MOVLB  5
04EC6:  CLRF   x76
04EC8:  MOVF   x76,W
04ECA:  SUBLW  28
04ECC:  BNC   4EE4
....................             one_step_y(); 
04ECE:  MOVLB  0
04ED0:  RCALL  4D96
....................             delay_us(2000); 
04ED2:  MOVLW  02
04ED4:  MOVLB  5
04ED6:  MOVWF  x91
04ED8:  MOVLB  0
04EDA:  CALL   2954
04EDE:  MOVLB  5
04EE0:  INCF   x76,F
04EE2:  BRA    4EC8
....................         } 
.................... 	}	 
....................     motor_pos_y = 0;    
04EE4:  MOVLB  2
04EE6:  CLRF   x06
04EE8:  CLRF   x05
....................     stop_y();			 
04EEA:  MOVLB  0
04EEC:  RCALL  4DD8
04EEE:  RETURN 0
.................... } 
.................... void  x_home_direita() {  
.................... 	int i; 
.................... 	chopper_x(); 
*
05342:  RCALL  4EF0
.................... 	delay_ms(50);	 
05344:  MOVLW  32
05346:  MOVLB  5
05348:  MOVWF  x91
0534A:  MOVLB  0
0534C:  CALL   2954
.................... 	if(le_Input(S_X_DIREITA) == true) { 
05350:  MOVLW  05
05352:  MOVLB  5
05354:  MOVWF  x78
05356:  MOVLB  0
05358:  CALL   49FA
0535C:  DECFSZ 01,W
0535E:  BRA    5402
.................... 		esquerda(); 
05360:  RCALL  4F38
.................... 		delay_ms(50); 
05362:  MOVLW  32
05364:  MOVLB  5
05366:  MOVWF  x91
05368:  MOVLB  0
0536A:  CALL   2954
....................         while(le_Input(S_X_DIREITA) == true) { 
0536E:  MOVLW  05
05370:  MOVLB  5
05372:  MOVWF  x78
05374:  MOVLB  0
05376:  CALL   49FA
0537A:  DECFSZ 01,W
0537C:  BRA    538E
....................             one_step_x(); 
0537E:  RCALL  4F00
....................             delay_us(2000); 
05380:  MOVLW  02
05382:  MOVLB  5
05384:  MOVWF  x91
05386:  MOVLB  0
05388:  CALL   2954
0538C:  BRA    536E
....................         } 
....................         for(i=0;i<=40;i++){ //para sair do histerese do sensor dando maior precisao 
0538E:  MOVLB  5
05390:  CLRF   x76
05392:  MOVF   x76,W
05394:  SUBLW  28
05396:  BNC   53AE
....................             one_step_x(); 
05398:  MOVLB  0
0539A:  RCALL  4F00
....................             delay_us(2000); 
0539C:  MOVLW  02
0539E:  MOVLB  5
053A0:  MOVWF  x91
053A2:  MOVLB  0
053A4:  CALL   2954
053A8:  MOVLB  5
053AA:  INCF   x76,F
053AC:  BRA    5392
....................         } 
.................... 		direita(); 
053AE:  MOVLB  0
053B0:  RCALL  4EF6
.................... 		delay_ms(50); 
053B2:  MOVLW  32
053B4:  MOVLB  5
053B6:  MOVWF  x91
053B8:  MOVLB  0
053BA:  CALL   2954
....................         while(le_Input(S_X_DIREITA) == false) {				 
053BE:  MOVLW  05
053C0:  MOVLB  5
053C2:  MOVWF  x78
053C4:  MOVLB  0
053C6:  CALL   49FA
053CA:  MOVF   01,F
053CC:  BNZ   53DE
....................             one_step_x(); 
053CE:  RCALL  4F00
....................             delay_us(2000); 
053D0:  MOVLW  02
053D2:  MOVLB  5
053D4:  MOVWF  x91
053D6:  MOVLB  0
053D8:  CALL   2954
053DC:  BRA    53BE
....................         }				 
....................         for(i=0;i<=40;i++) { 
053DE:  MOVLB  5
053E0:  CLRF   x76
053E2:  MOVF   x76,W
053E4:  SUBLW  28
053E6:  BNC   53FE
....................             one_step_x(); 
053E8:  MOVLB  0
053EA:  RCALL  4F00
....................             delay_us(2000); 
053EC:  MOVLW  02
053EE:  MOVLB  5
053F0:  MOVWF  x91
053F2:  MOVLB  0
053F4:  CALL   2954
053F8:  MOVLB  5
053FA:  INCF   x76,F
053FC:  BRA    53E2
....................         } 
.................... 	}else{			 
053FE:  BRA    5450
05400:  MOVLB  0
....................         direita(); 
05402:  RCALL  4EF6
....................         delay_ms(50); 
05404:  MOVLW  32
05406:  MOVLB  5
05408:  MOVWF  x91
0540A:  MOVLB  0
0540C:  CALL   2954
....................         while(le_Input(S_X_DIREITA) == false) { 
05410:  MOVLW  05
05412:  MOVLB  5
05414:  MOVWF  x78
05416:  MOVLB  0
05418:  CALL   49FA
0541C:  MOVF   01,F
0541E:  BNZ   5430
....................             one_step_x(); 
05420:  RCALL  4F00
....................             delay_us(2000); 
05422:  MOVLW  02
05424:  MOVLB  5
05426:  MOVWF  x91
05428:  MOVLB  0
0542A:  CALL   2954
0542E:  BRA    5410
....................         } 
....................         for(i=0;i<=40;i++) { 
05430:  MOVLB  5
05432:  CLRF   x76
05434:  MOVF   x76,W
05436:  SUBLW  28
05438:  BNC   5450
....................             one_step_x(); 
0543A:  MOVLB  0
0543C:  RCALL  4F00
....................             delay_us(2000); 
0543E:  MOVLW  02
05440:  MOVLB  5
05442:  MOVWF  x91
05444:  MOVLB  0
05446:  CALL   2954
0544A:  MOVLB  5
0544C:  INCF   x76,F
0544E:  BRA    5434
....................         } 
.................... 	} 
....................     motor_pos_x = 0;    
05450:  MOVLB  2
05452:  CLRF   x04
05454:  CLRF   x03
....................     stop_x();			 
05456:  MOVLB  0
05458:  RCALL  4F42
0545A:  RETURN 0
.................... } 
.................... void  z_home() { 
.................... 	int i; 
.................... 	chopper_z(); 
*
04C8E:  BRA    4934
.................... 	delay_ms(50);	 
04C90:  MOVLW  32
04C92:  MOVLB  5
04C94:  MOVWF  x91
04C96:  MOVLB  0
04C98:  CALL   2954
.................... 	if(le_Input(S_Z_TOP) == true) { 
04C9C:  MOVLW  0D
04C9E:  MOVLB  5
04CA0:  MOVWF  x78
04CA2:  MOVLB  0
04CA4:  RCALL  49FA
04CA6:  DECFSZ 01,W
04CA8:  BRA    4D2A
.................... 		desce(); 
04CAA:  RCALL  4C36
.................... 		delay_ms(50); 
04CAC:  MOVLW  32
04CAE:  MOVLB  5
04CB0:  MOVWF  x91
04CB2:  MOVLB  0
04CB4:  CALL   2954
....................         for(i=0;i<=50;i++){ 
04CB8:  MOVLB  5
04CBA:  CLRF   x76
04CBC:  MOVF   x76,W
04CBE:  SUBLW  32
04CC0:  BNC   4CD8
....................             one_step_z(); 
04CC2:  MOVLB  0
04CC4:  RCALL  4C44
....................             delay_us(2000); 
04CC6:  MOVLW  02
04CC8:  MOVLB  5
04CCA:  MOVWF  x91
04CCC:  MOVLB  0
04CCE:  CALL   2954
04CD2:  MOVLB  5
04CD4:  INCF   x76,F
04CD6:  BRA    4CBC
....................         } 
....................         sobe(); 
04CD8:  MOVLB  0
04CDA:  RCALL  4C78
....................         delay_ms(50); 
04CDC:  MOVLW  32
04CDE:  MOVLB  5
04CE0:  MOVWF  x91
04CE2:  MOVLB  0
04CE4:  CALL   2954
....................         while(le_Input(S_Z_TOP) == false) {				 
04CE8:  MOVLW  0D
04CEA:  MOVLB  5
04CEC:  MOVWF  x78
04CEE:  MOVLB  0
04CF0:  RCALL  49FA
04CF2:  MOVF   01,F
04CF4:  BNZ   4D06
....................             one_step_z(); 
04CF6:  RCALL  4C44
....................             delay_us(2000); 
04CF8:  MOVLW  02
04CFA:  MOVLB  5
04CFC:  MOVWF  x91
04CFE:  MOVLB  0
04D00:  CALL   2954
04D04:  BRA    4CE8
....................         }				 
....................         for(i=0;i<=18;i++){ 
04D06:  MOVLB  5
04D08:  CLRF   x76
04D0A:  MOVF   x76,W
04D0C:  SUBLW  12
04D0E:  BNC   4D26
....................             one_step_z(); 
04D10:  MOVLB  0
04D12:  RCALL  4C44
....................             delay_us(2000); 
04D14:  MOVLW  02
04D16:  MOVLB  5
04D18:  MOVWF  x91
04D1A:  MOVLB  0
04D1C:  CALL   2954
04D20:  MOVLB  5
04D22:  INCF   x76,F
04D24:  BRA    4D0A
....................         } 
.................... 	}else{ 
04D26:  BRA    4D76
04D28:  MOVLB  0
....................         sobe(); 
04D2A:  RCALL  4C78
....................         delay_ms(50); 
04D2C:  MOVLW  32
04D2E:  MOVLB  5
04D30:  MOVWF  x91
04D32:  MOVLB  0
04D34:  CALL   2954
....................         while(le_Input(S_Z_TOP) == false) { 
04D38:  MOVLW  0D
04D3A:  MOVLB  5
04D3C:  MOVWF  x78
04D3E:  MOVLB  0
04D40:  RCALL  49FA
04D42:  MOVF   01,F
04D44:  BNZ   4D56
....................             one_step_z(); 
04D46:  RCALL  4C44
....................             delay_us(2000); 
04D48:  MOVLW  02
04D4A:  MOVLB  5
04D4C:  MOVWF  x91
04D4E:  MOVLB  0
04D50:  CALL   2954
04D54:  BRA    4D38
....................         } 
....................         for(i=0;i<=18;i++) { 
04D56:  MOVLB  5
04D58:  CLRF   x76
04D5A:  MOVF   x76,W
04D5C:  SUBLW  12
04D5E:  BNC   4D76
....................             one_step_z(); 
04D60:  MOVLB  0
04D62:  RCALL  4C44
....................             delay_us(2000); 
04D64:  MOVLW  02
04D66:  MOVLB  5
04D68:  MOVWF  x91
04D6A:  MOVLB  0
04D6C:  CALL   2954
04D70:  MOVLB  5
04D72:  INCF   x76,F
04D74:  BRA    4D5A
....................         } 
.................... 	} 
....................     motor_pos_z = 0;    
04D76:  MOVLB  2
04D78:  CLRF   x0A
04D7A:  CLRF   x09
.................... 	stop_z();			 
04D7C:  MOVLB  0
04D7E:  BRA    4C86
04D80:  RETURN 0
.................... } 
....................  
.................... void envia_maquina_para_posicao(int posicao_futura){ 
....................     motor_run_z(0, 19); 
*
069E4:  MOVLB  5
069E6:  CLRF   x7F
069E8:  CLRF   x7E
069EA:  CLRF   x7D
069EC:  CLRF   x7C
069EE:  MOVLW  13
069F0:  MOVWF  x80
069F2:  MOVLB  0
069F4:  RCALL  63C2
....................     while ((run_flg_z)); 
069F6:  MOVLB  3
069F8:  BTFSC  xB7.2
069FA:  BRA    69F8
....................     switch (posicao_futura){ 
069FC:  MOVLB  5
069FE:  MOVF   x77,W
06A00:  ADDLW  FA
06A02:  BTFSC  FD8.0
06A04:  BRA    6F6C
06A06:  ADDLW  06
06A08:  MOVLB  0
06A0A:  GOTO   6F70
....................         case ALIMENTADOR: 
....................             if(posicao_atual != ALIMENTADOR){             
06A0E:  MOVF   26,F
06A10:  BTFSC  FD8.2
06A12:  BRA    6B3E
....................                 while ((posicao_atual == SOLDAGEM)||(posicao_atual == HOME2)){ 
06A14:  MOVF   26,W
06A16:  SUBLW  03
06A18:  BZ    6A20
06A1A:  MOVF   26,W
06A1C:  SUBLW  04
06A1E:  BNZ   6A24
....................                     tela_esperando_mov_maquina();                 
06A20:  RCALL  65B2
06A22:  BRA    6A14
....................                 } 
....................                 posicao_outra_maquina = le_posicao_outra_maquina(); 
06A24:  CALL   5266
06A28:  MOVFF  01,28
....................                 while ((posicao_outra_maquina == ALIMENTADOR)){ 
06A2C:  MOVF   28,F
06A2E:  BNZ   6A3C
....................                     tela_esperando_sair_posicao_outra_maquina(); 
06A30:  RCALL  65E4
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
06A32:  CALL   5266
06A36:  MOVFF  01,28
06A3A:  BRA    6A2C
....................                 } 
....................                 if (posicao_atual == DISPENSADOR){                     
06A3C:  MOVF   26,W
06A3E:  SUBLW  05
06A40:  BNZ   6ABE
....................                     tela_movimentando_maquina(ALIMENTADOR); 
06A42:  MOVLB  5
06A44:  CLRF   x78
06A46:  MOVLB  0
06A48:  CALL   47E8
....................                     motor_run_y(700, 19); 
06A4C:  MOVLB  5
06A4E:  CLRF   x7F
06A50:  CLRF   x7E
06A52:  MOVLW  02
06A54:  MOVWF  x7D
06A56:  MOVLW  BC
06A58:  MOVWF  x7C
06A5A:  MOVLW  13
06A5C:  MOVWF  x80
06A5E:  MOVLB  0
06A60:  RCALL  6622
....................                     while ((run_flg_y)); 
06A62:  MOVLB  2
06A64:  BTFSC  x0B.7
06A66:  BRA    6A64
....................                     envia_posicao_para_outra_maquina(ALIMENTADOR); 
06A68:  MOVLB  5
06A6A:  CLRF   x78
06A6C:  MOVLB  0
06A6E:  CALL   4752
....................                     motor_run_flip(0, 19); 
06A72:  MOVLB  5
06A74:  CLRF   x7F
06A76:  CLRF   x7E
06A78:  CLRF   x7D
06A7A:  CLRF   x7C
06A7C:  MOVLW  13
06A7E:  MOVWF  x80
06A80:  MOVLB  0
06A82:  RCALL  680C
....................                     while ((run_flg_flip)); 
06A84:  BTFSC  2D.3
06A86:  BRA    6A84
....................                     motor_run_y(0, 19); 
06A88:  MOVLB  5
06A8A:  CLRF   x7F
06A8C:  CLRF   x7E
06A8E:  CLRF   x7D
06A90:  CLRF   x7C
06A92:  MOVLW  13
06A94:  MOVWF  x80
06A96:  MOVLB  0
06A98:  RCALL  6622
....................                     while ((run_flg_y)); 
06A9A:  MOVLB  2
06A9C:  BTFSC  x0B.7
06A9E:  BRA    6A9C
....................                     motor_run_x(50, 19); 
06AA0:  MOVLB  5
06AA2:  CLRF   x7F
06AA4:  CLRF   x7E
06AA6:  CLRF   x7D
06AA8:  MOVLW  32
06AAA:  MOVWF  x7C
06AAC:  MOVLW  13
06AAE:  MOVWF  x80
06AB0:  MOVLB  0
06AB2:  CALL   55F6
....................                     while ((run_flg_x)); 
06AB6:  MOVLB  2
06AB8:  BTFSC  x0B.5
06ABA:  BRA    6AB8
06ABC:  MOVLB  0
....................                 } 
....................                 if (posicao_atual == HOME1){ 
06ABE:  DECFSZ 26,W
06AC0:  BRA    6B3C
....................                     envia_posicao_para_outra_maquina(ALIMENTADOR); 
06AC2:  MOVLB  5
06AC4:  CLRF   x78
06AC6:  MOVLB  0
06AC8:  CALL   4752
....................                     tela_movimentando_maquina(ALIMENTADOR); 
06ACC:  MOVLB  5
06ACE:  CLRF   x78
06AD0:  MOVLB  0
06AD2:  CALL   47E8
....................                     motor_run_x(0, 19); 
06AD6:  MOVLB  5
06AD8:  CLRF   x7F
06ADA:  CLRF   x7E
06ADC:  CLRF   x7D
06ADE:  CLRF   x7C
06AE0:  MOVLW  13
06AE2:  MOVWF  x80
06AE4:  MOVLB  0
06AE6:  CALL   55F6
....................                     while ((run_flg_x)); 
06AEA:  MOVLB  2
06AEC:  BTFSC  x0B.5
06AEE:  BRA    6AEC
....................                     motor_run_flip(0, 19); 
06AF0:  MOVLB  5
06AF2:  CLRF   x7F
06AF4:  CLRF   x7E
06AF6:  CLRF   x7D
06AF8:  CLRF   x7C
06AFA:  MOVLW  13
06AFC:  MOVWF  x80
06AFE:  MOVLB  0
06B00:  RCALL  680C
....................                     while ((run_flg_flip)); 
06B02:  BTFSC  2D.3
06B04:  BRA    6B02
....................                     motor_run_y(0, 19); 
06B06:  MOVLB  5
06B08:  CLRF   x7F
06B0A:  CLRF   x7E
06B0C:  CLRF   x7D
06B0E:  CLRF   x7C
06B10:  MOVLW  13
06B12:  MOVWF  x80
06B14:  MOVLB  0
06B16:  RCALL  6622
....................                     while ((run_flg_y)); 
06B18:  MOVLB  2
06B1A:  BTFSC  x0B.7
06B1C:  BRA    6B1A
....................                     motor_run_x(50, 19); 
06B1E:  MOVLB  5
06B20:  CLRF   x7F
06B22:  CLRF   x7E
06B24:  CLRF   x7D
06B26:  MOVLW  32
06B28:  MOVWF  x7C
06B2A:  MOVLW  13
06B2C:  MOVWF  x80
06B2E:  MOVLB  0
06B30:  CALL   55F6
....................                     while ((run_flg_x));                    
06B34:  MOVLB  2
06B36:  BTFSC  x0B.5
06B38:  BRA    6B36
06B3A:  MOVLB  0
....................                 } 
....................                 posicao_atual = ALIMENTADOR; 
06B3C:  CLRF   26
....................             } 
....................         break; 
06B3E:  MOVLB  5
06B40:  BRA    6F6C
....................         case HOME1: 
....................             if(posicao_atual != HOME1){             
06B42:  DECFSZ 26,W
06B44:  BRA    6B48
06B46:  BRA    6C94
....................                 while (posicao_atual == DISPENSADOR){ 
06B48:  MOVF   26,W
06B4A:  SUBLW  05
06B4C:  BNZ   6B52
....................                     tela_esperando_mov_maquina();                 
06B4E:  RCALL  65B2
06B50:  BRA    6B48
....................                 } 
....................                 if (posicao_atual == SOLDAGEM){ 
06B52:  MOVF   26,W
06B54:  SUBLW  03
06B56:  BNZ   6BAA
....................                     tela_movimentando_maquina(HOME1); 
06B58:  MOVLW  01
06B5A:  MOVLB  5
06B5C:  MOVWF  x78
06B5E:  MOVLB  0
06B60:  CALL   47E8
....................                     motor_run_y(800, 19); 
06B64:  MOVLB  5
06B66:  CLRF   x7F
06B68:  CLRF   x7E
06B6A:  MOVLW  03
06B6C:  MOVWF  x7D
06B6E:  MOVLW  20
06B70:  MOVWF  x7C
06B72:  MOVLW  13
06B74:  MOVWF  x80
06B76:  MOVLB  0
06B78:  RCALL  6622
....................                     while ((run_flg_y)); 
06B7A:  MOVLB  2
06B7C:  BTFSC  x0B.7
06B7E:  BRA    6B7C
....................                     motor_run_x(3835, 19); 
06B80:  MOVLB  5
06B82:  CLRF   x7F
06B84:  CLRF   x7E
06B86:  MOVLW  0E
06B88:  MOVWF  x7D
06B8A:  MOVLW  FB
06B8C:  MOVWF  x7C
06B8E:  MOVLW  13
06B90:  MOVWF  x80
06B92:  MOVLB  0
06B94:  CALL   55F6
....................                     while ((run_flg_x)); 
06B98:  MOVLB  2
06B9A:  BTFSC  x0B.5
06B9C:  BRA    6B9A
....................                     envia_posicao_para_outra_maquina(HOME1);                    
06B9E:  MOVLW  01
06BA0:  MOVLB  5
06BA2:  MOVWF  x78
06BA4:  MOVLB  0
06BA6:  CALL   4752
....................                 } 
....................                 if (posicao_atual == HOME2){ 
06BAA:  MOVF   26,W
06BAC:  SUBLW  04
06BAE:  BNZ   6C20
....................                     tela_movimentando_maquina(HOME1); 
06BB0:  MOVLW  01
06BB2:  MOVLB  5
06BB4:  MOVWF  x78
06BB6:  MOVLB  0
06BB8:  CALL   47E8
....................                     motor_run_x(3835, 19); 
06BBC:  MOVLB  5
06BBE:  CLRF   x7F
06BC0:  CLRF   x7E
06BC2:  MOVLW  0E
06BC4:  MOVWF  x7D
06BC6:  MOVLW  FB
06BC8:  MOVWF  x7C
06BCA:  MOVLW  13
06BCC:  MOVWF  x80
06BCE:  MOVLB  0
06BD0:  CALL   55F6
....................                     while ((run_flg_x)); 
06BD4:  MOVLB  2
06BD6:  BTFSC  x0B.5
06BD8:  BRA    6BD6
....................                     motor_run_y(800, 19); 
06BDA:  MOVLB  5
06BDC:  CLRF   x7F
06BDE:  CLRF   x7E
06BE0:  MOVLW  03
06BE2:  MOVWF  x7D
06BE4:  MOVLW  20
06BE6:  MOVWF  x7C
06BE8:  MOVLW  13
06BEA:  MOVWF  x80
06BEC:  MOVLB  0
06BEE:  RCALL  6622
....................                     while ((run_flg_y)); 
06BF0:  MOVLB  2
06BF2:  BTFSC  x0B.7
06BF4:  BRA    6BF2
....................                     motor_run_x(3835, 19); 
06BF6:  MOVLB  5
06BF8:  CLRF   x7F
06BFA:  CLRF   x7E
06BFC:  MOVLW  0E
06BFE:  MOVWF  x7D
06C00:  MOVLW  FB
06C02:  MOVWF  x7C
06C04:  MOVLW  13
06C06:  MOVWF  x80
06C08:  MOVLB  0
06C0A:  CALL   55F6
....................                     while ((run_flg_x)); 
06C0E:  MOVLB  2
06C10:  BTFSC  x0B.5
06C12:  BRA    6C10
....................                     envia_posicao_para_outra_maquina(HOME1);                    
06C14:  MOVLW  01
06C16:  MOVLB  5
06C18:  MOVWF  x78
06C1A:  MOVLB  0
06C1C:  CALL   4752
....................                 } 
....................                 if (posicao_atual == ALIMENTADOR){ 
06C20:  MOVF   26,F
06C22:  BNZ   6C90
....................                     tela_movimentando_maquina(HOME1); 
06C24:  MOVLW  01
06C26:  MOVLB  5
06C28:  MOVWF  x78
06C2A:  MOVLB  0
06C2C:  CALL   47E8
....................                     motor_run_y(800, 19); 
06C30:  MOVLB  5
06C32:  CLRF   x7F
06C34:  CLRF   x7E
06C36:  MOVLW  03
06C38:  MOVWF  x7D
06C3A:  MOVLW  20
06C3C:  MOVWF  x7C
06C3E:  MOVLW  13
06C40:  MOVWF  x80
06C42:  MOVLB  0
06C44:  RCALL  6622
....................                     while ((run_flg_y)); 
06C46:  MOVLB  2
06C48:  BTFSC  x0B.7
06C4A:  BRA    6C48
....................                     motor_run_flip(1869, 19); 
06C4C:  MOVLB  5
06C4E:  CLRF   x7F
06C50:  CLRF   x7E
06C52:  MOVLW  07
06C54:  MOVWF  x7D
06C56:  MOVLW  4D
06C58:  MOVWF  x7C
06C5A:  MOVLW  13
06C5C:  MOVWF  x80
06C5E:  MOVLB  0
06C60:  RCALL  680C
....................                     while ((run_flg_flip)); 
06C62:  BTFSC  2D.3
06C64:  BRA    6C62
....................                     motor_run_x(3835, 19); 
06C66:  MOVLB  5
06C68:  CLRF   x7F
06C6A:  CLRF   x7E
06C6C:  MOVLW  0E
06C6E:  MOVWF  x7D
06C70:  MOVLW  FB
06C72:  MOVWF  x7C
06C74:  MOVLW  13
06C76:  MOVWF  x80
06C78:  MOVLB  0
06C7A:  CALL   55F6
....................                     while ((run_flg_x)); 
06C7E:  MOVLB  2
06C80:  BTFSC  x0B.5
06C82:  BRA    6C80
....................                     envia_posicao_para_outra_maquina(HOME1);                    
06C84:  MOVLW  01
06C86:  MOVLB  5
06C88:  MOVWF  x78
06C8A:  MOVLB  0
06C8C:  CALL   4752
....................                 } 
....................                 posicao_atual = HOME1; 
06C90:  MOVLW  01
06C92:  MOVWF  26
....................             } 
....................         break; 
06C94:  MOVLB  5
06C96:  BRA    6F6C
....................         case SOLDAGEM: 
....................             if(posicao_atual != SOLDAGEM){ 
06C98:  MOVF   26,W
06C9A:  SUBLW  03
06C9C:  BTFSC  FD8.2
06C9E:  BRA    6D98
....................                 while ((posicao_atual == DISPENSADOR)||(posicao_atual == HOME2)){ 
06CA0:  MOVF   26,W
06CA2:  SUBLW  05
06CA4:  BZ    6CAC
06CA6:  MOVF   26,W
06CA8:  SUBLW  04
06CAA:  BNZ   6CB0
....................                     tela_esperando_mov_maquina();                 
06CAC:  RCALL  65B2
06CAE:  BRA    6CA0
....................                 } 
....................                 if (posicao_atual == HOME1){ 
06CB0:  DECFSZ 26,W
06CB2:  BRA    6D06
....................                     tela_movimentando_maquina(SOLDAGEM); 
06CB4:  MOVLW  03
06CB6:  MOVLB  5
06CB8:  MOVWF  x78
06CBA:  MOVLB  0
06CBC:  CALL   47E8
....................                     motor_run_x(3835, 19); 
06CC0:  MOVLB  5
06CC2:  CLRF   x7F
06CC4:  CLRF   x7E
06CC6:  MOVLW  0E
06CC8:  MOVWF  x7D
06CCA:  MOVLW  FB
06CCC:  MOVWF  x7C
06CCE:  MOVLW  13
06CD0:  MOVWF  x80
06CD2:  MOVLB  0
06CD4:  CALL   55F6
....................                     while ((run_flg_x)); 
06CD8:  MOVLB  2
06CDA:  BTFSC  x0B.5
06CDC:  BRA    6CDA
....................                     motor_run_y(2540, 19); 
06CDE:  MOVLB  5
06CE0:  CLRF   x7F
06CE2:  CLRF   x7E
06CE4:  MOVLW  09
06CE6:  MOVWF  x7D
06CE8:  MOVLW  EC
06CEA:  MOVWF  x7C
06CEC:  MOVLW  13
06CEE:  MOVWF  x80
06CF0:  MOVLB  0
06CF2:  RCALL  6622
....................                     while ((run_flg_y)); 
06CF4:  MOVLB  2
06CF6:  BTFSC  x0B.7
06CF8:  BRA    6CF6
....................                     envia_posicao_para_outra_maquina(SOLDAGEM);                    
06CFA:  MOVLW  03
06CFC:  MOVLB  5
06CFE:  MOVWF  x78
06D00:  MOVLB  0
06D02:  CALL   4752
....................                 } 
....................                 if (posicao_atual == ALIMENTADOR){ 
06D06:  MOVF   26,F
06D08:  BNZ   6D94
....................                     tela_movimentando_maquina(SOLDAGEM); 
06D0A:  MOVLW  03
06D0C:  MOVLB  5
06D0E:  MOVWF  x78
06D10:  MOVLB  0
06D12:  CALL   47E8
....................                     motor_run_y(800, 19); 
06D16:  MOVLB  5
06D18:  CLRF   x7F
06D1A:  CLRF   x7E
06D1C:  MOVLW  03
06D1E:  MOVWF  x7D
06D20:  MOVLW  20
06D22:  MOVWF  x7C
06D24:  MOVLW  13
06D26:  MOVWF  x80
06D28:  MOVLB  0
06D2A:  RCALL  6622
....................                     while ((run_flg_y)); 
06D2C:  MOVLB  2
06D2E:  BTFSC  x0B.7
06D30:  BRA    6D2E
....................                     motor_run_flip(1869, 19); 
06D32:  MOVLB  5
06D34:  CLRF   x7F
06D36:  CLRF   x7E
06D38:  MOVLW  07
06D3A:  MOVWF  x7D
06D3C:  MOVLW  4D
06D3E:  MOVWF  x7C
06D40:  MOVLW  13
06D42:  MOVWF  x80
06D44:  MOVLB  0
06D46:  RCALL  680C
....................                     while ((run_flg_flip)); 
06D48:  BTFSC  2D.3
06D4A:  BRA    6D48
....................                     motor_run_x(3835, 19); 
06D4C:  MOVLB  5
06D4E:  CLRF   x7F
06D50:  CLRF   x7E
06D52:  MOVLW  0E
06D54:  MOVWF  x7D
06D56:  MOVLW  FB
06D58:  MOVWF  x7C
06D5A:  MOVLW  13
06D5C:  MOVWF  x80
06D5E:  MOVLB  0
06D60:  CALL   55F6
....................                     while ((run_flg_x)); 
06D64:  MOVLB  2
06D66:  BTFSC  x0B.5
06D68:  BRA    6D66
....................                     envia_posicao_para_outra_maquina(SOLDAGEM); 
06D6A:  MOVLW  03
06D6C:  MOVLB  5
06D6E:  MOVWF  x78
06D70:  MOVLB  0
06D72:  CALL   4752
....................                     motor_run_y(2540, 19); 
06D76:  MOVLB  5
06D78:  CLRF   x7F
06D7A:  CLRF   x7E
06D7C:  MOVLW  09
06D7E:  MOVWF  x7D
06D80:  MOVLW  EC
06D82:  MOVWF  x7C
06D84:  MOVLW  13
06D86:  MOVWF  x80
06D88:  MOVLB  0
06D8A:  RCALL  6622
....................                     while ((run_flg_y));                    
06D8C:  MOVLB  2
06D8E:  BTFSC  x0B.7
06D90:  BRA    6D8E
06D92:  MOVLB  0
....................                 } 
....................                 posicao_atual = SOLDAGEM; 
06D94:  MOVLW  03
06D96:  MOVWF  26
....................             } 
....................         break; 
06D98:  MOVLB  5
06D9A:  BRA    6F6C
....................         case HOME2: 
....................             if(posicao_atual != HOME2){ 
06D9C:  MOVF   26,W
06D9E:  SUBLW  04
06DA0:  BTFSC  FD8.2
06DA2:  BRA    6ED8
....................                 while ((posicao_atual == ALIMENTADOR)){ 
06DA4:  MOVF   26,F
06DA6:  BNZ   6DAC
....................                     tela_esperando_mov_maquina();                 
06DA8:  RCALL  65B2
06DAA:  BRA    6DA4
....................                 } 
....................                 if (posicao_atual == DISPENSADOR){ 
06DAC:  MOVF   26,W
06DAE:  SUBLW  05
06DB0:  BNZ   6E04
....................                     tela_movimentando_maquina(HOME2); 
06DB2:  MOVLW  04
06DB4:  MOVLB  5
06DB6:  MOVWF  x78
06DB8:  MOVLB  0
06DBA:  CALL   47E8
....................                     motor_run_y(5500, 19); 
06DBE:  MOVLB  5
06DC0:  CLRF   x7F
06DC2:  CLRF   x7E
06DC4:  MOVLW  15
06DC6:  MOVWF  x7D
06DC8:  MOVLW  7C
06DCA:  MOVWF  x7C
06DCC:  MOVLW  13
06DCE:  MOVWF  x80
06DD0:  MOVLB  0
06DD2:  RCALL  6622
....................                     while ((run_flg_y)); 
06DD4:  MOVLB  2
06DD6:  BTFSC  x0B.7
06DD8:  BRA    6DD6
....................                     motor_run_x(3835, 19); 
06DDA:  MOVLB  5
06DDC:  CLRF   x7F
06DDE:  CLRF   x7E
06DE0:  MOVLW  0E
06DE2:  MOVWF  x7D
06DE4:  MOVLW  FB
06DE6:  MOVWF  x7C
06DE8:  MOVLW  13
06DEA:  MOVWF  x80
06DEC:  MOVLB  0
06DEE:  CALL   55F6
....................                     while ((run_flg_x)); 
06DF2:  MOVLB  2
06DF4:  BTFSC  x0B.5
06DF6:  BRA    6DF4
....................                     envia_posicao_para_outra_maquina(HOME2);                    
06DF8:  MOVLW  04
06DFA:  MOVLB  5
06DFC:  MOVWF  x78
06DFE:  MOVLB  0
06E00:  CALL   4752
....................                 } 
....................                 if (posicao_atual == SOLDAGEM){ 
06E04:  MOVF   26,W
06E06:  SUBLW  03
06E08:  BNZ   6E5E
....................                     tela_movimentando_maquina(HOME2); 
06E0A:  MOVLW  04
06E0C:  MOVLB  5
06E0E:  MOVWF  x78
06E10:  MOVLB  0
06E12:  CALL   47E8
....................                     motor_run_y(5500, 19); 
06E16:  MOVLB  5
06E18:  CLRF   x7F
06E1A:  CLRF   x7E
06E1C:  MOVLW  15
06E1E:  MOVWF  x7D
06E20:  MOVLW  7C
06E22:  MOVWF  x7C
06E24:  MOVLW  13
06E26:  MOVWF  x80
06E28:  MOVLB  0
06E2A:  CALL   6622
....................                     while ((run_flg_y)); 
06E2E:  MOVLB  2
06E30:  BTFSC  x0B.7
06E32:  BRA    6E30
....................                     motor_run_x(3835, 19); 
06E34:  MOVLB  5
06E36:  CLRF   x7F
06E38:  CLRF   x7E
06E3A:  MOVLW  0E
06E3C:  MOVWF  x7D
06E3E:  MOVLW  FB
06E40:  MOVWF  x7C
06E42:  MOVLW  13
06E44:  MOVWF  x80
06E46:  MOVLB  0
06E48:  CALL   55F6
....................                     while ((run_flg_x)); 
06E4C:  MOVLB  2
06E4E:  BTFSC  x0B.5
06E50:  BRA    6E4E
....................                     envia_posicao_para_outra_maquina(HOME2);                    
06E52:  MOVLW  04
06E54:  MOVLB  5
06E56:  MOVWF  x78
06E58:  MOVLB  0
06E5A:  CALL   4752
....................                 } 
....................                 if (posicao_atual == HOME1){ 
06E5E:  DECFSZ 26,W
06E60:  BRA    6ED4
....................                     tela_movimentando_maquina(HOME2); 
06E62:  MOVLW  04
06E64:  MOVLB  5
06E66:  MOVWF  x78
06E68:  MOVLB  0
06E6A:  CALL   47E8
....................                     motor_run_x(3835, 19); 
06E6E:  MOVLB  5
06E70:  CLRF   x7F
06E72:  CLRF   x7E
06E74:  MOVLW  0E
06E76:  MOVWF  x7D
06E78:  MOVLW  FB
06E7A:  MOVWF  x7C
06E7C:  MOVLW  13
06E7E:  MOVWF  x80
06E80:  MOVLB  0
06E82:  CALL   55F6
....................                     while ((run_flg_x)); 
06E86:  MOVLB  2
06E88:  BTFSC  x0B.5
06E8A:  BRA    6E88
....................                     motor_run_y(5500, 19); 
06E8C:  MOVLB  5
06E8E:  CLRF   x7F
06E90:  CLRF   x7E
06E92:  MOVLW  15
06E94:  MOVWF  x7D
06E96:  MOVLW  7C
06E98:  MOVWF  x7C
06E9A:  MOVLW  13
06E9C:  MOVWF  x80
06E9E:  MOVLB  0
06EA0:  CALL   6622
....................                     while ((run_flg_y)); 
06EA4:  MOVLB  2
06EA6:  BTFSC  x0B.7
06EA8:  BRA    6EA6
....................                     motor_run_x(3835, 19); 
06EAA:  MOVLB  5
06EAC:  CLRF   x7F
06EAE:  CLRF   x7E
06EB0:  MOVLW  0E
06EB2:  MOVWF  x7D
06EB4:  MOVLW  FB
06EB6:  MOVWF  x7C
06EB8:  MOVLW  13
06EBA:  MOVWF  x80
06EBC:  MOVLB  0
06EBE:  CALL   55F6
....................                     while ((run_flg_x)); 
06EC2:  MOVLB  2
06EC4:  BTFSC  x0B.5
06EC6:  BRA    6EC4
....................                     envia_posicao_para_outra_maquina(HOME2);                    
06EC8:  MOVLW  04
06ECA:  MOVLB  5
06ECC:  MOVWF  x78
06ECE:  MOVLB  0
06ED0:  CALL   4752
....................                 } 
....................                 posicao_atual = HOME2; 
06ED4:  MOVLW  04
06ED6:  MOVWF  26
....................             } 
....................         break; 
06ED8:  MOVLB  5
06EDA:  BRA    6F6C
....................         case DISPENSADOR: 
....................             if(posicao_atual != DISPENSADOR){ 
06EDC:  MOVF   26,W
06EDE:  SUBLW  05
06EE0:  BZ    6F66
....................                 while (posicao_atual != HOME2){ 
06EE2:  MOVF   26,W
06EE4:  SUBLW  04
06EE6:  BZ    6EEE
....................                     tela_esperando_mov_maquina();                 
06EE8:  CALL   65B2
06EEC:  BRA    6EE2
....................                 } 
....................                 envia_posicao_para_outra_maquina(DISPENSADOR); 
06EEE:  MOVLW  05
06EF0:  MOVLB  5
06EF2:  MOVWF  x78
06EF4:  MOVLB  0
06EF6:  CALL   4752
....................                 if (posicao_atual == HOME2){    
06EFA:  MOVF   26,W
06EFC:  SUBLW  04
06EFE:  BNZ   6F62
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
06F00:  CALL   5266
06F04:  MOVFF  01,28
....................                     while ((posicao_outra_maquina == DISPENSADOR)){ 
06F08:  MOVF   28,W
06F0A:  SUBLW  05
06F0C:  BNZ   6F1C
....................                         tela_esperando_sair_posicao_outra_maquina(); 
06F0E:  CALL   65E4
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
06F12:  CALL   5266
06F16:  MOVFF  01,28
06F1A:  BRA    6F08
....................                     } 
....................                     tela_movimentando_maquina(DISPENSADOR); 
06F1C:  MOVLW  05
06F1E:  MOVLB  5
06F20:  MOVWF  x78
06F22:  MOVLB  0
06F24:  CALL   47E8
....................                     motor_run_x(0, 19); 
06F28:  MOVLB  5
06F2A:  CLRF   x7F
06F2C:  CLRF   x7E
06F2E:  CLRF   x7D
06F30:  CLRF   x7C
06F32:  MOVLW  13
06F34:  MOVWF  x80
06F36:  MOVLB  0
06F38:  CALL   55F6
....................                     while ((run_flg_x)); 
06F3C:  MOVLB  2
06F3E:  BTFSC  x0B.5
06F40:  BRA    6F3E
....................                     motor_run_y(6110, 19); 
06F42:  MOVLB  5
06F44:  CLRF   x7F
06F46:  CLRF   x7E
06F48:  MOVLW  17
06F4A:  MOVWF  x7D
06F4C:  MOVLW  DE
06F4E:  MOVWF  x7C
06F50:  MOVLW  13
06F52:  MOVWF  x80
06F54:  MOVLB  0
06F56:  CALL   6622
....................                     while ((run_flg_y));                    
06F5A:  MOVLB  2
06F5C:  BTFSC  x0B.7
06F5E:  BRA    6F5C
06F60:  MOVLB  0
....................                 } 
....................                 posicao_atual = DISPENSADOR; 
06F62:  MOVLW  05
06F64:  MOVWF  26
....................             } 
....................         break; 
06F66:  MOVLB  5
06F68:  BRA    6F6C
06F6A:  MOVLB  5
....................     } 
06F6C:  MOVLB  0
06F6E:  RETURN 0
.................... } 
.................... void posicao_maquina_1_default(void) { 
....................     envia_posicao_para_outra_maquina(ALIMENTADOR); 
*
057DC:  MOVLB  5
057DE:  CLRF   x78
057E0:  MOVLB  0
057E2:  CALL   4752
....................     tela_movimentando_maquina(ALIMENTADOR); 
057E6:  MOVLB  5
057E8:  CLRF   x78
057EA:  MOVLB  0
057EC:  CALL   47E8
....................     long int i = 0; 
057F0:  MOVLB  5
057F2:  CLRF   x75
057F4:  CLRF   x74
....................     z_home(); 
057F6:  MOVLB  0
057F8:  CALL   4C8E
....................     if (le_Input(S_Y_ATRAS) == true) { 
057FC:  MOVLW  08
057FE:  MOVLB  5
05800:  MOVWF  x78
05802:  MOVLB  0
05804:  CALL   49FA
05808:  DECFSZ 01,W
0580A:  BRA    5818
....................         y_home_atras(); 
0580C:  CALL   4DDE
....................         x_home_esquerda(); 
05810:  CALL   4F48
....................         y_home_frente(); 
05814:  RCALL  505A
....................          
....................     } else { 
05816:  BRA    5836
....................         if (le_Input(S_Y_FRENTE) == true) { 
05818:  MOVLW  07
0581A:  MOVLB  5
0581C:  MOVWF  x78
0581E:  MOVLB  0
05820:  CALL   49FA
05824:  DECFSZ 01,W
05826:  BRA    5830
....................  
....................             y_home_frente(); 
05828:  RCALL  505A
....................             x_home_esquerda(); 
0582A:  CALL   4F48
....................         } else { 
0582E:  BRA    5836
....................             x_home_esquerda(); 
05830:  CALL   4F48
....................             y_home_frente(); 
05834:  RCALL  505A
....................         } 
....................     } 
....................     posicao_atual = HOME1; 
05836:  MOVLW  01
05838:  MOVWF  26
....................     envia_posicao_para_outra_maquina(HOME1); 
0583A:  MOVLB  5
0583C:  MOVWF  x78
0583E:  MOVLB  0
05840:  CALL   4752
....................     posicao_outra_maquina = le_posicao_outra_maquina(); 
05844:  RCALL  5266
05846:  MOVFF  01,28
....................     while ((posicao_outra_maquina != ALIMENTADOR)){ 
0584A:  MOVF   28,F
0584C:  BZ    5856
....................         posicao_outra_maquina = le_posicao_outra_maquina(); 
0584E:  RCALL  5266
05850:  MOVFF  01,28
05854:  BRA    584A
....................     } 
....................     posicao_outra_maquina = le_posicao_outra_maquina(); 
05856:  RCALL  5266
05858:  MOVFF  01,28
....................     while ((posicao_outra_maquina != HOME1)){ 
0585C:  DECFSZ 28,W
0585E:  BRA    5862
05860:  BRA    586A
....................         posicao_outra_maquina = le_posicao_outra_maquina(); 
05862:  RCALL  5266
05864:  MOVFF  01,28
05868:  BRA    585C
....................     } 
....................     x_home_direita(); 
0586A:  RCALL  5342
....................     flip_home(); 
0586C:  RCALL  54B4
....................     chopper_y(); 
0586E:  CALL   4D82
....................     frente(); 
05872:  CALL   4D88
....................     delay_ms(50); 
05876:  MOVLW  32
05878:  MOVLB  5
0587A:  MOVWF  x91
0587C:  MOVLB  0
0587E:  CALL   2954
....................     for (i = 0; i < 700; i++) { 
05882:  MOVLB  5
05884:  CLRF   x75
05886:  CLRF   x74
05888:  MOVF   x75,W
0588A:  SUBLW  02
0588C:  BNC   58B2
0588E:  BNZ   5896
05890:  MOVF   x74,W
05892:  SUBLW  BB
05894:  BNC   58B2
....................         one_step_y(); 
05896:  MOVLB  0
05898:  CALL   4D96
....................         delay_us(2000); 
0589C:  MOVLW  02
0589E:  MOVLB  5
058A0:  MOVWF  x91
058A2:  MOVLB  0
058A4:  CALL   2954
058A8:  MOVLB  5
058AA:  INCF   x74,F
058AC:  BTFSC  FD8.2
058AE:  INCF   x75,F
058B0:  BRA    5888
....................     } 
....................     chopper_x(); 
058B2:  MOVLB  0
058B4:  CALL   4EF0
....................     esquerda(); 
058B8:  CALL   4F38
....................     delay_ms(50);     
058BC:  MOVLW  32
058BE:  MOVLB  5
058C0:  MOVWF  x91
058C2:  MOVLB  0
058C4:  CALL   2954
....................     motor_pos_x = 0x0000; 
058C8:  MOVLB  2
058CA:  CLRF   x04
058CC:  CLRF   x03
....................     motor_pos_y = 0x0000; 
058CE:  CLRF   x06
058D0:  CLRF   x05
....................     motor_pos_flip = 0x0000; 
058D2:  CLRF   x08
058D4:  CLRF   x07
....................     motor_pos_z = 0x0000; 
058D6:  CLRF   x0A
058D8:  CLRF   x09
....................     motor_run_x(50, 19); 
058DA:  MOVLB  5
058DC:  CLRF   x7F
058DE:  CLRF   x7E
058E0:  CLRF   x7D
058E2:  MOVLW  32
058E4:  MOVWF  x7C
058E6:  MOVLW  13
058E8:  MOVWF  x80
058EA:  MOVLB  0
058EC:  RCALL  55F6
....................     posicao_atual = ALIMENTADOR; 
058EE:  CLRF   26
....................     envia_posicao_para_outra_maquina(ALIMENTADOR); 
058F0:  MOVLB  5
058F2:  CLRF   x78
058F4:  MOVLB  0
058F6:  CALL   4752
058FA:  GOTO   DA1E (RETURN)
.................... } 
.................... void posicao_volta_manutencao(void) { 
....................     tela_movimentando_maquina(ALIMENTADOR); 
*
0BE26:  MOVLB  5
0BE28:  CLRF   x78
0BE2A:  MOVLB  0
0BE2C:  CALL   47E8
....................     long int i = 0; 
0BE30:  MOVLB  5
0BE32:  CLRF   x75
0BE34:  CLRF   x74
....................     z_home(); 
0BE36:  MOVLB  0
0BE38:  CALL   4C8E
....................     if (le_Input(S_Y_ATRAS) == true) { 
0BE3C:  MOVLW  08
0BE3E:  MOVLB  5
0BE40:  MOVWF  x78
0BE42:  MOVLB  0
0BE44:  CALL   49FA
0BE48:  DECFSZ 01,W
0BE4A:  BRA    BE5A
....................         y_home_atras(); 
0BE4C:  CALL   4DDE
....................         x_home_esquerda(); 
0BE50:  CALL   4F48
....................         y_home_frente(); 
0BE54:  CALL   505A
....................          
....................     } else { 
0BE58:  BRA    BE7C
....................         if (le_Input(S_Y_FRENTE) == true) { 
0BE5A:  MOVLW  07
0BE5C:  MOVLB  5
0BE5E:  MOVWF  x78
0BE60:  MOVLB  0
0BE62:  CALL   49FA
0BE66:  DECFSZ 01,W
0BE68:  BRA    BE74
....................  
....................             y_home_frente(); 
0BE6A:  CALL   505A
....................             x_home_esquerda(); 
0BE6E:  CALL   4F48
....................         } else { 
0BE72:  BRA    BE7C
....................             x_home_esquerda(); 
0BE74:  CALL   4F48
....................             y_home_frente(); 
0BE78:  CALL   505A
....................         } 
....................     } 
....................     x_home_direita(); 
0BE7C:  CALL   5342
....................     flip_home(); 
0BE80:  CALL   54B4
....................     chopper_y(); 
0BE84:  CALL   4D82
....................     frente(); 
0BE88:  CALL   4D88
....................     delay_ms(50); 
0BE8C:  MOVLW  32
0BE8E:  MOVLB  5
0BE90:  MOVWF  x91
0BE92:  MOVLB  0
0BE94:  CALL   2954
....................     for (i = 0; i < 700; i++) { 
0BE98:  MOVLB  5
0BE9A:  CLRF   x75
0BE9C:  CLRF   x74
0BE9E:  MOVF   x75,W
0BEA0:  SUBLW  02
0BEA2:  BNC   BEC8
0BEA4:  BNZ   BEAC
0BEA6:  MOVF   x74,W
0BEA8:  SUBLW  BB
0BEAA:  BNC   BEC8
....................         one_step_y(); 
0BEAC:  MOVLB  0
0BEAE:  CALL   4D96
....................         delay_us(2000); 
0BEB2:  MOVLW  02
0BEB4:  MOVLB  5
0BEB6:  MOVWF  x91
0BEB8:  MOVLB  0
0BEBA:  CALL   2954
0BEBE:  MOVLB  5
0BEC0:  INCF   x74,F
0BEC2:  BTFSC  FD8.2
0BEC4:  INCF   x75,F
0BEC6:  BRA    BE9E
....................     } 
....................     chopper_x(); 
0BEC8:  MOVLB  0
0BECA:  CALL   4EF0
....................     esquerda(); 
0BECE:  CALL   4F38
....................     delay_ms(50);     
0BED2:  MOVLW  32
0BED4:  MOVLB  5
0BED6:  MOVWF  x91
0BED8:  MOVLB  0
0BEDA:  CALL   2954
....................     motor_pos_x = 0x0000; 
0BEDE:  MOVLB  2
0BEE0:  CLRF   x04
0BEE2:  CLRF   x03
....................     motor_pos_y = 0x0000; 
0BEE4:  CLRF   x06
0BEE6:  CLRF   x05
....................     motor_pos_flip = 0x0000; 
0BEE8:  CLRF   x08
0BEEA:  CLRF   x07
....................     motor_pos_z = 0x0000; 
0BEEC:  CLRF   x0A
0BEEE:  CLRF   x09
....................     motor_run_x(50, 19); 
0BEF0:  MOVLB  5
0BEF2:  CLRF   x7F
0BEF4:  CLRF   x7E
0BEF6:  CLRF   x7D
0BEF8:  MOVLW  32
0BEFA:  MOVWF  x7C
0BEFC:  MOVLW  13
0BEFE:  MOVWF  x80
0BF00:  MOVLB  0
0BF02:  CALL   55F6
....................     posicao_atual = ALIMENTADOR; 
0BF06:  CLRF   26
....................     envia_posicao_para_outra_maquina(ALIMENTADOR); 
0BF08:  MOVLB  5
0BF0A:  CLRF   x78
0BF0C:  MOVLB  0
0BF0E:  CALL   4752
0BF12:  RETURN 0
.................... } 
....................  
.................... #include "maquinas_maq_1.c" 
.................... void liga_pressor (void){ 
....................     aciona_saida(PRESSOR); 
*
07A76:  MOVLB  5
07A78:  CLRF   x8F
07A7A:  MOVLW  04
07A7C:  MOVWF  x8E
07A7E:  MOVLB  0
07A80:  CALL   2E1E
07A84:  RETURN 0
.................... } 
.................... void desliga_pressor (void){ 
....................     desaciona_saida(PRESSOR); 
*
07796:  MOVLB  5
07798:  CLRF   x8F
0779A:  MOVLW  04
0779C:  MOVWF  x8E
0779E:  MOVLB  0
077A0:  CALL   2DDC
077A4:  RETURN 0
.................... } 
.................... void empurra_placa(void){ 
....................     short int b; 
....................     short int c; 
....................     b = le_Input(S_BANDEJA); 
*
0B3BC:  MOVLW  15
0B3BE:  MOVLB  5
0B3C0:  MOVWF  x78
0B3C2:  MOVLB  0
0B3C4:  CALL   49FA
0B3C8:  MOVLB  5
0B3CA:  BCF    x77.0
0B3CC:  BTFSC  01.0
0B3CE:  BSF    x77.0
....................     while (b == 1){ 
0B3D0:  BTFSS  x77.0
0B3D2:  BRA    B404
....................         b = le_Input(S_BANDEJA); 
0B3D4:  MOVLW  15
0B3D6:  MOVWF  x78
0B3D8:  MOVLB  0
0B3DA:  CALL   49FA
0B3DE:  MOVLB  5
0B3E0:  BCF    x77.0
0B3E2:  BTFSC  01.0
0B3E4:  BSF    x77.0
....................         aciona_saida(DEDO_ENTRADA); 
0B3E6:  CLRF   x8F
0B3E8:  MOVLW  07
0B3EA:  MOVWF  x8E
0B3EC:  MOVLB  0
0B3EE:  CALL   2E1E
....................         aciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
0B3F2:  MOVLB  5
0B3F4:  CLRF   x8F
0B3F6:  MOVLW  06
0B3F8:  MOVWF  x8E
0B3FA:  MOVLB  0
0B3FC:  CALL   2E1E
0B400:  MOVLB  5
0B402:  BRA    B3D0
....................     } 
....................     desaciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
0B404:  CLRF   x8F
0B406:  MOVLW  06
0B408:  MOVWF  x8E
0B40A:  MOVLB  0
0B40C:  CALL   2DDC
....................     c = le_Input(S_EMPURRADOR_IN_LS2); 
0B410:  MOVLW  03
0B412:  MOVLB  5
0B414:  MOVWF  x78
0B416:  MOVLB  0
0B418:  CALL   49FA
0B41C:  MOVLB  5
0B41E:  BCF    x77.1
0B420:  BTFSC  01.0
0B422:  BSF    x77.1
....................     while (c == 0){ 
0B424:  BTFSC  x77.1
0B426:  BRA    B44A
....................         c = le_Input(S_EMPURRADOR_IN_LS2);        
0B428:  MOVLW  03
0B42A:  MOVWF  x78
0B42C:  MOVLB  0
0B42E:  CALL   49FA
0B432:  MOVLB  5
0B434:  BCF    x77.1
0B436:  BTFSC  01.0
0B438:  BSF    x77.1
....................         aciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
0B43A:  CLRF   x8F
0B43C:  MOVLW  05
0B43E:  MOVWF  x8E
0B440:  MOVLB  0
0B442:  CALL   2E1E
0B446:  MOVLB  5
0B448:  BRA    B424
....................     } 
....................     desaciona_saida(DEDO_ENTRADA); 
0B44A:  CLRF   x8F
0B44C:  MOVLW  07
0B44E:  MOVWF  x8E
0B450:  MOVLB  0
0B452:  CALL   2DDC
....................     desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
0B456:  MOVLB  5
0B458:  CLRF   x8F
0B45A:  MOVLW  05
0B45C:  MOVWF  x8E
0B45E:  MOVLB  0
0B460:  CALL   2DDC
0B464:  RETURN 0
.................... } 
.................... void dispensa_placa(void){ 
....................     short int b; 
....................     short int c; 
....................     b = le_Input(S_EMPURRADOR_OUT_LS1); 
*
0D0EC:  MOVLW  12
0D0EE:  MOVLB  5
0D0F0:  MOVWF  x78
0D0F2:  MOVLB  0
0D0F4:  CALL   49FA
0D0F8:  MOVLB  5
0D0FA:  BCF    x77.0
0D0FC:  BTFSC  01.0
0D0FE:  BSF    x77.0
....................     while (b == 0){         
0D100:  BTFSC  x77.0
0D102:  BRA    D132
....................         aciona_saida(DEDO_SAIDA); 
0D104:  CLRF   x8F
0D106:  MOVLW  01
0D108:  MOVWF  x8E
0D10A:  MOVLB  0
0D10C:  CALL   2E1E
....................         aciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
0D110:  MOVLB  5
0D112:  CLRF   x8F
0D114:  CLRF   x8E
0D116:  MOVLB  0
0D118:  CALL   2E1E
....................         b = le_Input(S_EMPURRADOR_OUT_LS1); 
0D11C:  MOVLW  12
0D11E:  MOVLB  5
0D120:  MOVWF  x78
0D122:  MOVLB  0
0D124:  CALL   49FA
0D128:  MOVLB  5
0D12A:  BCF    x77.0
0D12C:  BTFSC  01.0
0D12E:  BSF    x77.0
0D130:  BRA    D100
....................     } 
....................     desaciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
0D132:  CLRF   x8F
0D134:  CLRF   x8E
0D136:  MOVLB  0
0D138:  CALL   2DDC
....................     c = le_Input(S_EMPURRADOR_OUT_LS2); 
0D13C:  MOVLW  13
0D13E:  MOVLB  5
0D140:  MOVWF  x78
0D142:  MOVLB  0
0D144:  CALL   49FA
0D148:  MOVLB  5
0D14A:  BCF    x77.1
0D14C:  BTFSC  01.0
0D14E:  BSF    x77.1
....................     while (c == 0){         
0D150:  BTFSC  x77.1
0D152:  BRA    D176
....................         c = le_Input(S_EMPURRADOR_OUT_LS2); 
0D154:  MOVLW  13
0D156:  MOVWF  x78
0D158:  MOVLB  0
0D15A:  CALL   49FA
0D15E:  MOVLB  5
0D160:  BCF    x77.1
0D162:  BTFSC  01.0
0D164:  BSF    x77.1
....................         aciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
0D166:  CLRF   x8F
0D168:  MOVLW  0F
0D16A:  MOVWF  x8E
0D16C:  MOVLB  0
0D16E:  CALL   2E1E
0D172:  MOVLB  5
0D174:  BRA    D150
....................     } 
....................     desaciona_saida(DEDO_SAIDA); 
0D176:  CLRF   x8F
0D178:  MOVLW  01
0D17A:  MOVWF  x8E
0D17C:  MOVLB  0
0D17E:  CALL   2DDC
....................     desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
0D182:  MOVLB  5
0D184:  CLRF   x8F
0D186:  MOVLW  0F
0D188:  MOVWF  x8E
0D18A:  MOVLB  0
0D18C:  CALL   2DDC
0D190:  GOTO   D54E (RETURN)
.................... } 
.................... void desce_ferros(int quantidade){ 
....................     if (quantidade == 0){ 
*
07A24:  MOVLB  5
07A26:  MOVF   x7C,F
07A28:  BNZ   7A2A
....................     } 
....................     if (quantidade == 1){ 
07A2A:  DECFSZ x7C,W
07A2C:  BRA    7A3C
....................         aciona_saida(FERRO_SOLDA1); 
07A2E:  CLRF   x8F
07A30:  MOVLW  03
07A32:  MOVWF  x8E
07A34:  MOVLB  0
07A36:  CALL   2E1E
07A3A:  MOVLB  5
....................     } 
....................     if (quantidade == 2){ 
07A3C:  MOVF   x7C,W
07A3E:  SUBLW  02
07A40:  BNZ   7A50
....................         aciona_saida(FERRO_SOLDA2); 
07A42:  CLRF   x8F
07A44:  MOVLW  02
07A46:  MOVWF  x8E
07A48:  MOVLB  0
07A4A:  CALL   2E1E
07A4E:  MOVLB  5
....................     } 
....................     if (quantidade == 3){ 
07A50:  MOVF   x7C,W
07A52:  SUBLW  03
07A54:  BNZ   7A72
....................         aciona_saida(FERRO_SOLDA1); 
07A56:  CLRF   x8F
07A58:  MOVLW  03
07A5A:  MOVWF  x8E
07A5C:  MOVLB  0
07A5E:  CALL   2E1E
....................         aciona_saida(FERRO_SOLDA2); 
07A62:  MOVLB  5
07A64:  CLRF   x8F
07A66:  MOVLW  02
07A68:  MOVWF  x8E
07A6A:  MOVLB  0
07A6C:  CALL   2E1E
07A70:  MOVLB  5
....................     } 
07A72:  MOVLB  0
07A74:  RETURN 0
.................... } 
.................... void sobe_ferros(void){ 
....................     desaciona_saida(FERRO_SOLDA1); 
*
07A06:  MOVLB  5
07A08:  CLRF   x8F
07A0A:  MOVLW  03
07A0C:  MOVWF  x8E
07A0E:  MOVLB  0
07A10:  CALL   2DDC
....................     desaciona_saida(FERRO_SOLDA2); 
07A14:  MOVLB  5
07A16:  CLRF   x8F
07A18:  MOVLW  02
07A1A:  MOVWF  x8E
07A1C:  MOVLB  0
07A1E:  CALL   2DDC
07A22:  RETURN 0
.................... } 
.................... void liga_esteira(void){ 
....................     aciona_saida(RELE_ESTEIRA); 
*
0B39C:  MOVLB  5
0B39E:  CLRF   x8F
0B3A0:  MOVLW  0A
0B3A2:  MOVWF  x8E
0B3A4:  MOVLB  0
0B3A6:  CALL   2E1E
0B3AA:  RETURN 0
.................... } 
.................... void desliga_esteira(void){ 
....................     desaciona_saida(RELE_ESTEIRA); 
0B3AC:  MOVLB  5
0B3AE:  CLRF   x8F
0B3B0:  MOVLW  0A
0B3B2:  MOVWF  x8E
0B3B4:  MOVLB  0
0B3B6:  CALL   2DDC
0B3BA:  RETURN 0
.................... } 
.................... void limpa_bicos(long int tempo){ 
....................     aciona_saida(LIMPA_BICO1); 
....................     aciona_saida(LIMPA_BICO2); 
....................     delay_ms(tempo); 
....................     desaciona_saida(LIMPA_BICO1); 
....................     desaciona_saida(LIMPA_BICO2);     
.................... } 
.................... void home_solenoides(void){ 
....................     desaciona_saida(DEDO_ENTRADA); 
*
02E6A:  MOVLB  5
02E6C:  CLRF   x8F
02E6E:  MOVLW  07
02E70:  MOVWF  x8E
02E72:  MOVLB  0
02E74:  RCALL  2DDC
....................     desaciona_saida(DEDO_SAIDA); 
02E76:  MOVLB  5
02E78:  CLRF   x8F
02E7A:  MOVLW  01
02E7C:  MOVWF  x8E
02E7E:  MOVLB  0
02E80:  RCALL  2DDC
....................     desaciona_saida(FERRO_SOLDA1); 
02E82:  MOVLB  5
02E84:  CLRF   x8F
02E86:  MOVLW  03
02E88:  MOVWF  x8E
02E8A:  MOVLB  0
02E8C:  RCALL  2DDC
....................     desaciona_saida(FERRO_SOLDA2); 
02E8E:  MOVLB  5
02E90:  CLRF   x8F
02E92:  MOVLW  02
02E94:  MOVWF  x8E
02E96:  MOVLB  0
02E98:  RCALL  2DDC
....................     desaciona_saida(PRESSOR); 
02E9A:  MOVLB  5
02E9C:  CLRF   x8F
02E9E:  MOVLW  04
02EA0:  MOVWF  x8E
02EA2:  MOVLB  0
02EA4:  RCALL  2DDC
....................     desaciona_saida(LIMPA_BICO1); 
02EA6:  MOVLB  5
02EA8:  CLRF   x8F
02EAA:  MOVLW  08
02EAC:  MOVWF  x8E
02EAE:  MOVLB  0
02EB0:  RCALL  2DDC
....................     desaciona_saida(LIMPA_BICO2);     
02EB2:  MOVLB  5
02EB4:  CLRF   x8F
02EB6:  MOVLW  09
02EB8:  MOVWF  x8E
02EBA:  MOVLB  0
02EBC:  RCALL  2DDC
....................     aciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
02EBE:  MOVLB  5
02EC0:  CLRF   x8F
02EC2:  MOVLW  05
02EC4:  MOVWF  x8E
02EC6:  MOVLB  0
02EC8:  RCALL  2E1E
....................     aciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
02ECA:  MOVLB  5
02ECC:  CLRF   x8F
02ECE:  MOVLW  0F
02ED0:  MOVWF  x8E
02ED2:  MOVLB  0
02ED4:  RCALL  2E1E
....................     delay_ms(1800); 
02ED6:  MOVLW  08
02ED8:  MOVLB  5
02EDA:  MOVWF  x74
02EDC:  MOVLW  E1
02EDE:  MOVWF  x91
02EE0:  MOVLB  0
02EE2:  RCALL  2954
02EE4:  MOVLB  5
02EE6:  DECFSZ x74,F
02EE8:  BRA    2EDC
....................     desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
02EEA:  CLRF   x8F
02EEC:  MOVLW  05
02EEE:  MOVWF  x8E
02EF0:  MOVLB  0
02EF2:  RCALL  2DDC
....................     desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
02EF4:  MOVLB  5
02EF6:  CLRF   x8F
02EF8:  MOVLW  0F
02EFA:  MOVWF  x8E
02EFC:  MOVLB  0
02EFE:  RCALL  2DDC
02F00:  RETURN 0
.................... } 
.................... int statusSolda(void){ 
....................     short int x; 
....................     short int y; 
....................     short int z;     
....................     x = le_Input(S_FIO_SOLDA1); 
*
084C8:  MOVLW  16
084CA:  MOVLB  5
084CC:  MOVWF  x78
084CE:  MOVLB  0
084D0:  CALL   49FA
084D4:  MOVLB  5
084D6:  BCF    x77.0
084D8:  BTFSC  01.0
084DA:  BSF    x77.0
....................     y = le_Input(S_FIO_SOLDA2); 
084DC:  MOVLW  17
084DE:  MOVWF  x78
084E0:  MOVLB  0
084E2:  CALL   49FA
084E6:  MOVLB  5
084E8:  BCF    x77.1
084EA:  BTFSC  01.0
084EC:  BSF    x77.1
....................     z = le_Input(S_FIO_SOLDA3); 
084EE:  MOVLW  18
084F0:  MOVWF  x78
084F2:  MOVLB  0
084F4:  CALL   49FA
084F8:  MOVLB  5
084FA:  BCF    x77.2
084FC:  BTFSC  01.0
084FE:  BSF    x77.2
....................     if ((x==1)&&(y==1)&&(z==1)){ 
08500:  BTFSS  x77.0
08502:  BRA    8514
08504:  BTFSS  x77.1
08506:  BRA    8514
08508:  BTFSS  x77.2
0850A:  BRA    8514
....................         return 1; 
0850C:  MOVLW  01
0850E:  MOVWF  01
08510:  BRA    8518
....................     } else { 
08512:  BRA    8518
....................         return 0; 
08514:  MOVLW  00
08516:  MOVWF  01
....................     } 
08518:  MOVLB  0
0851A:  RETURN 0
.................... } 
.................... void ligar_alimentador_solda(int quantidade, long int tempo1, long int tempo2, long int tempo3){ 
....................     long int maior; 
....................     long int medio; 
....................     long int menor; 
....................     switch(quantidade){ 
0851C:  MOVLB  5
0851E:  MOVF   x81,W
08520:  ADDLW  FC
08522:  BTFSC  FD8.0
08524:  GOTO   8E86
08528:  ADDLW  04
0852A:  MOVLB  0
0852C:  GOTO   8E8A
....................         case 0: 
....................             aciona_saida(ALIMENTADOR2); 
08530:  MOVLB  5
08532:  CLRF   x8F
08534:  MOVLW  0D
08536:  MOVWF  x8E
08538:  MOVLB  0
0853A:  CALL   2E1E
....................             delay_ms(tempo2); 
0853E:  MOVFF  585,58E
08542:  MOVLB  5
08544:  INCF   x8E,F
08546:  DECF   x8E,F
08548:  BTFSC  FD8.2
0854A:  BRA    8558
0854C:  SETF   x91
0854E:  MOVLB  0
08550:  CALL   2954
08554:  MOVLB  5
08556:  BRA    8546
08558:  MOVFF  584,591
0855C:  MOVLB  0
0855E:  CALL   2954
....................             desaciona_saida(ALIMENTADOR2); 
08562:  MOVLB  5
08564:  CLRF   x8F
08566:  MOVLW  0D
08568:  MOVWF  x8E
0856A:  MOVLB  0
0856C:  CALL   2DDC
....................         break; 
08570:  MOVLB  5
08572:  GOTO   8E86
....................         case 1: 
....................             if (tempo1 == tempo2){ 
08576:  MOVLB  5
08578:  MOVF   x84,W
0857A:  SUBWF  x82,W
0857C:  BNZ   85E2
0857E:  MOVF   x85,W
08580:  SUBWF  x83,W
08582:  BNZ   85E2
....................                 aciona_saida(ALIMENTADOR1); 
08584:  CLRF   x8F
08586:  MOVLW  0E
08588:  MOVWF  x8E
0858A:  MOVLB  0
0858C:  CALL   2E1E
....................                 aciona_saida(ALIMENTADOR2); 
08590:  MOVLB  5
08592:  CLRF   x8F
08594:  MOVLW  0D
08596:  MOVWF  x8E
08598:  MOVLB  0
0859A:  CALL   2E1E
....................                 delay_ms(tempo1); 
0859E:  MOVFF  583,58E
085A2:  MOVLB  5
085A4:  INCF   x8E,F
085A6:  DECF   x8E,F
085A8:  BTFSC  FD8.2
085AA:  BRA    85B8
085AC:  SETF   x91
085AE:  MOVLB  0
085B0:  CALL   2954
085B4:  MOVLB  5
085B6:  BRA    85A6
085B8:  MOVFF  582,591
085BC:  MOVLB  0
085BE:  CALL   2954
....................                 desaciona_saida(ALIMENTADOR1); 
085C2:  MOVLB  5
085C4:  CLRF   x8F
085C6:  MOVLW  0E
085C8:  MOVWF  x8E
085CA:  MOVLB  0
085CC:  CALL   2DDC
....................                 desaciona_saida(ALIMENTADOR2); 
085D0:  MOVLB  5
085D2:  CLRF   x8F
085D4:  MOVLW  0D
085D6:  MOVWF  x8E
085D8:  MOVLB  0
085DA:  CALL   2DDC
....................             } else { 
085DE:  BRA    8704
085E0:  MOVLB  5
....................                 if (tempo1 > tempo2){ 
085E2:  MOVF   x85,W
085E4:  SUBWF  x83,W
085E6:  BNC   867C
085E8:  BNZ   85F0
085EA:  MOVF   x82,W
085EC:  SUBWF  x84,W
085EE:  BC    867C
....................                     aciona_saida(ALIMENTADOR1); 
085F0:  CLRF   x8F
085F2:  MOVLW  0E
085F4:  MOVWF  x8E
085F6:  MOVLB  0
085F8:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR2); 
085FC:  MOVLB  5
085FE:  CLRF   x8F
08600:  MOVLW  0D
08602:  MOVWF  x8E
08604:  MOVLB  0
08606:  CALL   2E1E
....................                     delay_ms(tempo2); 
0860A:  MOVFF  585,58E
0860E:  MOVLB  5
08610:  INCF   x8E,F
08612:  DECF   x8E,F
08614:  BTFSC  FD8.2
08616:  BRA    8624
08618:  SETF   x91
0861A:  MOVLB  0
0861C:  CALL   2954
08620:  MOVLB  5
08622:  BRA    8612
08624:  MOVFF  584,591
08628:  MOVLB  0
0862A:  CALL   2954
....................                     desaciona_saida(ALIMENTADOR2); 
0862E:  MOVLB  5
08630:  CLRF   x8F
08632:  MOVLW  0D
08634:  MOVWF  x8E
08636:  MOVLB  0
08638:  CALL   2DDC
....................                     delay_ms(tempo1 - tempo2); 
0863C:  MOVLB  5
0863E:  MOVF   x84,W
08640:  SUBWF  x82,W
08642:  MOVWF  x8E
08644:  MOVF   x85,W
08646:  SUBWFB x83,W
08648:  MOVWF  x8F
0864A:  MOVWF  x90
0864C:  INCF   x90,F
0864E:  DECF   x90,F
08650:  BTFSC  FD8.2
08652:  BRA    8660
08654:  SETF   x91
08656:  MOVLB  0
08658:  CALL   2954
0865C:  MOVLB  5
0865E:  BRA    864E
08660:  MOVFF  58E,591
08664:  MOVLB  0
08666:  CALL   2954
....................                     desaciona_saida(ALIMENTADOR1); 
0866A:  MOVLB  5
0866C:  CLRF   x8F
0866E:  MOVLW  0E
08670:  MOVWF  x8E
08672:  MOVLB  0
08674:  CALL   2DDC
....................                 } else { 
08678:  BRA    8704
0867A:  MOVLB  5
....................                     aciona_saida(ALIMENTADOR1); 
0867C:  CLRF   x8F
0867E:  MOVLW  0E
08680:  MOVWF  x8E
08682:  MOVLB  0
08684:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR2); 
08688:  MOVLB  5
0868A:  CLRF   x8F
0868C:  MOVLW  0D
0868E:  MOVWF  x8E
08690:  MOVLB  0
08692:  CALL   2E1E
....................                     delay_ms(tempo1); 
08696:  MOVFF  583,58E
0869A:  MOVLB  5
0869C:  INCF   x8E,F
0869E:  DECF   x8E,F
086A0:  BTFSC  FD8.2
086A2:  BRA    86B0
086A4:  SETF   x91
086A6:  MOVLB  0
086A8:  CALL   2954
086AC:  MOVLB  5
086AE:  BRA    869E
086B0:  MOVFF  582,591
086B4:  MOVLB  0
086B6:  CALL   2954
....................                     desaciona_saida(ALIMENTADOR1); 
086BA:  MOVLB  5
086BC:  CLRF   x8F
086BE:  MOVLW  0E
086C0:  MOVWF  x8E
086C2:  MOVLB  0
086C4:  CALL   2DDC
....................                     delay_ms(tempo2 - tempo1); 
086C8:  MOVLB  5
086CA:  MOVF   x82,W
086CC:  SUBWF  x84,W
086CE:  MOVWF  x8E
086D0:  MOVF   x83,W
086D2:  SUBWFB x85,W
086D4:  MOVWF  x8F
086D6:  MOVWF  x90
086D8:  INCF   x90,F
086DA:  DECF   x90,F
086DC:  BTFSC  FD8.2
086DE:  BRA    86EC
086E0:  SETF   x91
086E2:  MOVLB  0
086E4:  CALL   2954
086E8:  MOVLB  5
086EA:  BRA    86DA
086EC:  MOVFF  58E,591
086F0:  MOVLB  0
086F2:  CALL   2954
....................                     desaciona_saida(ALIMENTADOR2); 
086F6:  MOVLB  5
086F8:  CLRF   x8F
086FA:  MOVLW  0D
086FC:  MOVWF  x8E
086FE:  MOVLB  0
08700:  CALL   2DDC
....................                 } 
....................             } 
....................         break; 
08704:  MOVLB  5
08706:  BRA    8E86
....................         case 2: 
....................             if (tempo2 == tempo3){ 
08708:  MOVLB  5
0870A:  MOVF   x86,W
0870C:  SUBWF  x84,W
0870E:  BNZ   8774
08710:  MOVF   x87,W
08712:  SUBWF  x85,W
08714:  BNZ   8774
....................                 aciona_saida(ALIMENTADOR2); 
08716:  CLRF   x8F
08718:  MOVLW  0D
0871A:  MOVWF  x8E
0871C:  MOVLB  0
0871E:  CALL   2E1E
....................                 aciona_saida(ALIMENTADOR3); 
08722:  MOVLB  5
08724:  CLRF   x8F
08726:  MOVLW  0C
08728:  MOVWF  x8E
0872A:  MOVLB  0
0872C:  CALL   2E1E
....................                 delay_ms(tempo2); 
08730:  MOVFF  585,58E
08734:  MOVLB  5
08736:  INCF   x8E,F
08738:  DECF   x8E,F
0873A:  BTFSC  FD8.2
0873C:  BRA    874A
0873E:  SETF   x91
08740:  MOVLB  0
08742:  CALL   2954
08746:  MOVLB  5
08748:  BRA    8738
0874A:  MOVFF  584,591
0874E:  MOVLB  0
08750:  CALL   2954
....................                 desaciona_saida(ALIMENTADOR2); 
08754:  MOVLB  5
08756:  CLRF   x8F
08758:  MOVLW  0D
0875A:  MOVWF  x8E
0875C:  MOVLB  0
0875E:  CALL   2DDC
....................                 desaciona_saida(ALIMENTADOR3); 
08762:  MOVLB  5
08764:  CLRF   x8F
08766:  MOVLW  0C
08768:  MOVWF  x8E
0876A:  MOVLB  0
0876C:  CALL   2DDC
....................             } else { 
08770:  BRA    8896
08772:  MOVLB  5
....................                 if (tempo2 > tempo3){ 
08774:  MOVF   x87,W
08776:  SUBWF  x85,W
08778:  BNC   880E
0877A:  BNZ   8782
0877C:  MOVF   x84,W
0877E:  SUBWF  x86,W
08780:  BC    880E
....................                     aciona_saida(ALIMENTADOR2); 
08782:  CLRF   x8F
08784:  MOVLW  0D
08786:  MOVWF  x8E
08788:  MOVLB  0
0878A:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR3); 
0878E:  MOVLB  5
08790:  CLRF   x8F
08792:  MOVLW  0C
08794:  MOVWF  x8E
08796:  MOVLB  0
08798:  CALL   2E1E
....................                     delay_ms(tempo3); 
0879C:  MOVFF  587,58E
087A0:  MOVLB  5
087A2:  INCF   x8E,F
087A4:  DECF   x8E,F
087A6:  BTFSC  FD8.2
087A8:  BRA    87B6
087AA:  SETF   x91
087AC:  MOVLB  0
087AE:  CALL   2954
087B2:  MOVLB  5
087B4:  BRA    87A4
087B6:  MOVFF  586,591
087BA:  MOVLB  0
087BC:  CALL   2954
....................                     desaciona_saida(ALIMENTADOR3); 
087C0:  MOVLB  5
087C2:  CLRF   x8F
087C4:  MOVLW  0C
087C6:  MOVWF  x8E
087C8:  MOVLB  0
087CA:  CALL   2DDC
....................                     delay_ms(tempo2 - tempo3); 
087CE:  MOVLB  5
087D0:  MOVF   x86,W
087D2:  SUBWF  x84,W
087D4:  MOVWF  x8E
087D6:  MOVF   x87,W
087D8:  SUBWFB x85,W
087DA:  MOVWF  x8F
087DC:  MOVWF  x90
087DE:  INCF   x90,F
087E0:  DECF   x90,F
087E2:  BTFSC  FD8.2
087E4:  BRA    87F2
087E6:  SETF   x91
087E8:  MOVLB  0
087EA:  CALL   2954
087EE:  MOVLB  5
087F0:  BRA    87E0
087F2:  MOVFF  58E,591
087F6:  MOVLB  0
087F8:  CALL   2954
....................                     desaciona_saida(ALIMENTADOR2); 
087FC:  MOVLB  5
087FE:  CLRF   x8F
08800:  MOVLW  0D
08802:  MOVWF  x8E
08804:  MOVLB  0
08806:  CALL   2DDC
....................                 } else { 
0880A:  BRA    8896
0880C:  MOVLB  5
....................                     aciona_saida(ALIMENTADOR2); 
0880E:  CLRF   x8F
08810:  MOVLW  0D
08812:  MOVWF  x8E
08814:  MOVLB  0
08816:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR3); 
0881A:  MOVLB  5
0881C:  CLRF   x8F
0881E:  MOVLW  0C
08820:  MOVWF  x8E
08822:  MOVLB  0
08824:  CALL   2E1E
....................                     delay_ms(tempo2); 
08828:  MOVFF  585,58E
0882C:  MOVLB  5
0882E:  INCF   x8E,F
08830:  DECF   x8E,F
08832:  BTFSC  FD8.2
08834:  BRA    8842
08836:  SETF   x91
08838:  MOVLB  0
0883A:  CALL   2954
0883E:  MOVLB  5
08840:  BRA    8830
08842:  MOVFF  584,591
08846:  MOVLB  0
08848:  CALL   2954
....................                     desaciona_saida(ALIMENTADOR2); 
0884C:  MOVLB  5
0884E:  CLRF   x8F
08850:  MOVLW  0D
08852:  MOVWF  x8E
08854:  MOVLB  0
08856:  CALL   2DDC
....................                     delay_ms(tempo3 - tempo2); 
0885A:  MOVLB  5
0885C:  MOVF   x84,W
0885E:  SUBWF  x86,W
08860:  MOVWF  x8E
08862:  MOVF   x85,W
08864:  SUBWFB x87,W
08866:  MOVWF  x8F
08868:  MOVWF  x90
0886A:  INCF   x90,F
0886C:  DECF   x90,F
0886E:  BTFSC  FD8.2
08870:  BRA    887E
08872:  SETF   x91
08874:  MOVLB  0
08876:  CALL   2954
0887A:  MOVLB  5
0887C:  BRA    886C
0887E:  MOVFF  58E,591
08882:  MOVLB  0
08884:  CALL   2954
....................                     desaciona_saida(ALIMENTADOR3); 
08888:  MOVLB  5
0888A:  CLRF   x8F
0888C:  MOVLW  0C
0888E:  MOVWF  x8E
08890:  MOVLB  0
08892:  CALL   2DDC
....................                 } 
....................             } 
....................         break; 
08896:  MOVLB  5
08898:  BRA    8E86
....................         case 3: 
....................             if (tempo1>tempo2){ 
0889A:  MOVLB  5
0889C:  MOVF   x85,W
0889E:  SUBWF  x83,W
088A0:  BTFSS  FD8.0
088A2:  BRA    8B98
088A4:  BNZ   88AE
088A6:  MOVF   x82,W
088A8:  SUBWF  x84,W
088AA:  BTFSC  FD8.0
088AC:  BRA    8B98
....................                 if (tempo2>tempo3){ 
088AE:  MOVF   x87,W
088B0:  SUBWF  x85,W
088B2:  BTFSS  FD8.0
088B4:  BRA    89AC
088B6:  BNZ   88BE
088B8:  MOVF   x84,W
088BA:  SUBWF  x86,W
088BC:  BC    89AC
....................                     maior = tempo1; 
088BE:  MOVFF  583,589
088C2:  MOVFF  582,588
....................                     medio = tempo2; 
088C6:  MOVFF  585,58B
088CA:  MOVFF  584,58A
....................                     menor = tempo3; 
088CE:  MOVFF  587,58D
088D2:  MOVFF  586,58C
....................                     aciona_saida(ALIMENTADOR1); 
088D6:  CLRF   x8F
088D8:  MOVLW  0E
088DA:  MOVWF  x8E
088DC:  MOVLB  0
088DE:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR2); 
088E2:  MOVLB  5
088E4:  CLRF   x8F
088E6:  MOVLW  0D
088E8:  MOVWF  x8E
088EA:  MOVLB  0
088EC:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR3); 
088F0:  MOVLB  5
088F2:  CLRF   x8F
088F4:  MOVLW  0C
088F6:  MOVWF  x8E
088F8:  MOVLB  0
088FA:  CALL   2E1E
....................                     delay_ms(menor); 
088FE:  MOVFF  58D,58E
08902:  MOVLB  5
08904:  INCF   x8E,F
08906:  DECF   x8E,F
08908:  BTFSC  FD8.2
0890A:  BRA    8918
0890C:  SETF   x91
0890E:  MOVLB  0
08910:  CALL   2954
08914:  MOVLB  5
08916:  BRA    8906
08918:  MOVFF  58C,591
0891C:  MOVLB  0
0891E:  CALL   2954
....................                     desaciona_saida(ALIMENTADOR3); 
08922:  MOVLB  5
08924:  CLRF   x8F
08926:  MOVLW  0C
08928:  MOVWF  x8E
0892A:  MOVLB  0
0892C:  CALL   2DDC
....................                     delay_ms(medio-menor); 
08930:  MOVLB  5
08932:  MOVF   x8C,W
08934:  SUBWF  x8A,W
08936:  MOVWF  x8E
08938:  MOVF   x8D,W
0893A:  SUBWFB x8B,W
0893C:  MOVWF  x8F
0893E:  MOVWF  x90
08940:  INCF   x90,F
08942:  DECF   x90,F
08944:  BTFSC  FD8.2
08946:  BRA    8954
08948:  SETF   x91
0894A:  MOVLB  0
0894C:  CALL   2954
08950:  MOVLB  5
08952:  BRA    8942
08954:  MOVFF  58E,591
08958:  MOVLB  0
0895A:  CALL   2954
....................                     desaciona_saida(ALIMENTADOR2); 
0895E:  MOVLB  5
08960:  CLRF   x8F
08962:  MOVLW  0D
08964:  MOVWF  x8E
08966:  MOVLB  0
08968:  CALL   2DDC
....................                     delay_ms(maior-medio); 
0896C:  MOVLB  5
0896E:  MOVF   x8A,W
08970:  SUBWF  x88,W
08972:  MOVWF  x8E
08974:  MOVF   x8B,W
08976:  SUBWFB x89,W
08978:  MOVWF  x8F
0897A:  MOVWF  x90
0897C:  INCF   x90,F
0897E:  DECF   x90,F
08980:  BTFSC  FD8.2
08982:  BRA    8990
08984:  SETF   x91
08986:  MOVLB  0
08988:  CALL   2954
0898C:  MOVLB  5
0898E:  BRA    897E
08990:  MOVFF  58E,591
08994:  MOVLB  0
08996:  CALL   2954
....................                     desaciona_saida(ALIMENTADOR1); 
0899A:  MOVLB  5
0899C:  CLRF   x8F
0899E:  MOVLW  0E
089A0:  MOVWF  x8E
089A2:  MOVLB  0
089A4:  CALL   2DDC
....................                 } else { 
089A8:  BRA    8B94
089AA:  MOVLB  5
....................                     if (tempo1 > tempo3) { 
089AC:  MOVF   x87,W
089AE:  SUBWF  x83,W
089B0:  BTFSS  FD8.0
089B2:  BRA    8AAA
089B4:  BNZ   89BC
089B6:  MOVF   x82,W
089B8:  SUBWF  x86,W
089BA:  BC    8AAA
....................                         maior = tempo1; 
089BC:  MOVFF  583,589
089C0:  MOVFF  582,588
....................                         medio = tempo3; 
089C4:  MOVFF  587,58B
089C8:  MOVFF  586,58A
....................                         menor = tempo2; 
089CC:  MOVFF  585,58D
089D0:  MOVFF  584,58C
....................                         aciona_saida(ALIMENTADOR1); 
089D4:  CLRF   x8F
089D6:  MOVLW  0E
089D8:  MOVWF  x8E
089DA:  MOVLB  0
089DC:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR2); 
089E0:  MOVLB  5
089E2:  CLRF   x8F
089E4:  MOVLW  0D
089E6:  MOVWF  x8E
089E8:  MOVLB  0
089EA:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR3); 
089EE:  MOVLB  5
089F0:  CLRF   x8F
089F2:  MOVLW  0C
089F4:  MOVWF  x8E
089F6:  MOVLB  0
089F8:  CALL   2E1E
....................                         delay_ms(menor); 
089FC:  MOVFF  58D,58E
08A00:  MOVLB  5
08A02:  INCF   x8E,F
08A04:  DECF   x8E,F
08A06:  BTFSC  FD8.2
08A08:  BRA    8A16
08A0A:  SETF   x91
08A0C:  MOVLB  0
08A0E:  CALL   2954
08A12:  MOVLB  5
08A14:  BRA    8A04
08A16:  MOVFF  58C,591
08A1A:  MOVLB  0
08A1C:  CALL   2954
....................                         desaciona_saida(ALIMENTADOR2); 
08A20:  MOVLB  5
08A22:  CLRF   x8F
08A24:  MOVLW  0D
08A26:  MOVWF  x8E
08A28:  MOVLB  0
08A2A:  CALL   2DDC
....................                         delay_ms(medio-menor); 
08A2E:  MOVLB  5
08A30:  MOVF   x8C,W
08A32:  SUBWF  x8A,W
08A34:  MOVWF  x8E
08A36:  MOVF   x8D,W
08A38:  SUBWFB x8B,W
08A3A:  MOVWF  x8F
08A3C:  MOVWF  x90
08A3E:  INCF   x90,F
08A40:  DECF   x90,F
08A42:  BTFSC  FD8.2
08A44:  BRA    8A52
08A46:  SETF   x91
08A48:  MOVLB  0
08A4A:  CALL   2954
08A4E:  MOVLB  5
08A50:  BRA    8A40
08A52:  MOVFF  58E,591
08A56:  MOVLB  0
08A58:  CALL   2954
....................                         desaciona_saida(ALIMENTADOR3); 
08A5C:  MOVLB  5
08A5E:  CLRF   x8F
08A60:  MOVLW  0C
08A62:  MOVWF  x8E
08A64:  MOVLB  0
08A66:  CALL   2DDC
....................                         delay_ms(maior-medio); 
08A6A:  MOVLB  5
08A6C:  MOVF   x8A,W
08A6E:  SUBWF  x88,W
08A70:  MOVWF  x8E
08A72:  MOVF   x8B,W
08A74:  SUBWFB x89,W
08A76:  MOVWF  x8F
08A78:  MOVWF  x90
08A7A:  INCF   x90,F
08A7C:  DECF   x90,F
08A7E:  BTFSC  FD8.2
08A80:  BRA    8A8E
08A82:  SETF   x91
08A84:  MOVLB  0
08A86:  CALL   2954
08A8A:  MOVLB  5
08A8C:  BRA    8A7C
08A8E:  MOVFF  58E,591
08A92:  MOVLB  0
08A94:  CALL   2954
....................                         desaciona_saida(ALIMENTADOR1); 
08A98:  MOVLB  5
08A9A:  CLRF   x8F
08A9C:  MOVLW  0E
08A9E:  MOVWF  x8E
08AA0:  MOVLB  0
08AA2:  CALL   2DDC
....................                     } else { 
08AA6:  BRA    8B94
08AA8:  MOVLB  5
....................                         maior = tempo3; 
08AAA:  MOVFF  587,589
08AAE:  MOVFF  586,588
....................                         medio = tempo1; 
08AB2:  MOVFF  583,58B
08AB6:  MOVFF  582,58A
....................                         menor = tempo2; 
08ABA:  MOVFF  585,58D
08ABE:  MOVFF  584,58C
....................                         aciona_saida(ALIMENTADOR1); 
08AC2:  CLRF   x8F
08AC4:  MOVLW  0E
08AC6:  MOVWF  x8E
08AC8:  MOVLB  0
08ACA:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR2); 
08ACE:  MOVLB  5
08AD0:  CLRF   x8F
08AD2:  MOVLW  0D
08AD4:  MOVWF  x8E
08AD6:  MOVLB  0
08AD8:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR3); 
08ADC:  MOVLB  5
08ADE:  CLRF   x8F
08AE0:  MOVLW  0C
08AE2:  MOVWF  x8E
08AE4:  MOVLB  0
08AE6:  CALL   2E1E
....................                         delay_ms(menor); 
08AEA:  MOVFF  58D,58E
08AEE:  MOVLB  5
08AF0:  INCF   x8E,F
08AF2:  DECF   x8E,F
08AF4:  BTFSC  FD8.2
08AF6:  BRA    8B04
08AF8:  SETF   x91
08AFA:  MOVLB  0
08AFC:  CALL   2954
08B00:  MOVLB  5
08B02:  BRA    8AF2
08B04:  MOVFF  58C,591
08B08:  MOVLB  0
08B0A:  CALL   2954
....................                         desaciona_saida(ALIMENTADOR2); 
08B0E:  MOVLB  5
08B10:  CLRF   x8F
08B12:  MOVLW  0D
08B14:  MOVWF  x8E
08B16:  MOVLB  0
08B18:  CALL   2DDC
....................                         delay_ms(medio-menor); 
08B1C:  MOVLB  5
08B1E:  MOVF   x8C,W
08B20:  SUBWF  x8A,W
08B22:  MOVWF  x8E
08B24:  MOVF   x8D,W
08B26:  SUBWFB x8B,W
08B28:  MOVWF  x8F
08B2A:  MOVWF  x90
08B2C:  INCF   x90,F
08B2E:  DECF   x90,F
08B30:  BTFSC  FD8.2
08B32:  BRA    8B40
08B34:  SETF   x91
08B36:  MOVLB  0
08B38:  CALL   2954
08B3C:  MOVLB  5
08B3E:  BRA    8B2E
08B40:  MOVFF  58E,591
08B44:  MOVLB  0
08B46:  CALL   2954
....................                         desaciona_saida(ALIMENTADOR1); 
08B4A:  MOVLB  5
08B4C:  CLRF   x8F
08B4E:  MOVLW  0E
08B50:  MOVWF  x8E
08B52:  MOVLB  0
08B54:  CALL   2DDC
....................                         delay_ms(maior-medio); 
08B58:  MOVLB  5
08B5A:  MOVF   x8A,W
08B5C:  SUBWF  x88,W
08B5E:  MOVWF  x8E
08B60:  MOVF   x8B,W
08B62:  SUBWFB x89,W
08B64:  MOVWF  x8F
08B66:  MOVWF  x90
08B68:  INCF   x90,F
08B6A:  DECF   x90,F
08B6C:  BTFSC  FD8.2
08B6E:  BRA    8B7C
08B70:  SETF   x91
08B72:  MOVLB  0
08B74:  CALL   2954
08B78:  MOVLB  5
08B7A:  BRA    8B6A
08B7C:  MOVFF  58E,591
08B80:  MOVLB  0
08B82:  CALL   2954
....................                         desaciona_saida(ALIMENTADOR3); 
08B86:  MOVLB  5
08B88:  CLRF   x8F
08B8A:  MOVLW  0C
08B8C:  MOVWF  x8E
08B8E:  MOVLB  0
08B90:  CALL   2DDC
....................                     } 
....................                 } 
....................             } else { 
08B94:  BRA    8E80
08B96:  MOVLB  5
....................                 if (tempo2>tempo3){ 
08B98:  MOVF   x87,W
08B9A:  SUBWF  x85,W
08B9C:  BTFSS  FD8.0
08B9E:  BRA    8D96
08BA0:  BNZ   8BAA
08BA2:  MOVF   x84,W
08BA4:  SUBWF  x86,W
08BA6:  BTFSC  FD8.0
08BA8:  BRA    8D96
....................                     if (tempo1 > tempo3){ 
08BAA:  MOVF   x87,W
08BAC:  SUBWF  x83,W
08BAE:  BTFSS  FD8.0
08BB0:  BRA    8CA8
08BB2:  BNZ   8BBA
08BB4:  MOVF   x82,W
08BB6:  SUBWF  x86,W
08BB8:  BC    8CA8
....................                         maior = tempo2; 
08BBA:  MOVFF  585,589
08BBE:  MOVFF  584,588
....................                         medio = tempo1; 
08BC2:  MOVFF  583,58B
08BC6:  MOVFF  582,58A
....................                         menor = tempo3; 
08BCA:  MOVFF  587,58D
08BCE:  MOVFF  586,58C
....................                         aciona_saida(ALIMENTADOR1); 
08BD2:  CLRF   x8F
08BD4:  MOVLW  0E
08BD6:  MOVWF  x8E
08BD8:  MOVLB  0
08BDA:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR2); 
08BDE:  MOVLB  5
08BE0:  CLRF   x8F
08BE2:  MOVLW  0D
08BE4:  MOVWF  x8E
08BE6:  MOVLB  0
08BE8:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR3); 
08BEC:  MOVLB  5
08BEE:  CLRF   x8F
08BF0:  MOVLW  0C
08BF2:  MOVWF  x8E
08BF4:  MOVLB  0
08BF6:  CALL   2E1E
....................                         delay_ms(menor); 
08BFA:  MOVFF  58D,58E
08BFE:  MOVLB  5
08C00:  INCF   x8E,F
08C02:  DECF   x8E,F
08C04:  BTFSC  FD8.2
08C06:  BRA    8C14
08C08:  SETF   x91
08C0A:  MOVLB  0
08C0C:  CALL   2954
08C10:  MOVLB  5
08C12:  BRA    8C02
08C14:  MOVFF  58C,591
08C18:  MOVLB  0
08C1A:  CALL   2954
....................                         desaciona_saida(ALIMENTADOR3); 
08C1E:  MOVLB  5
08C20:  CLRF   x8F
08C22:  MOVLW  0C
08C24:  MOVWF  x8E
08C26:  MOVLB  0
08C28:  CALL   2DDC
....................                         delay_ms(medio-menor); 
08C2C:  MOVLB  5
08C2E:  MOVF   x8C,W
08C30:  SUBWF  x8A,W
08C32:  MOVWF  x8E
08C34:  MOVF   x8D,W
08C36:  SUBWFB x8B,W
08C38:  MOVWF  x8F
08C3A:  MOVWF  x90
08C3C:  INCF   x90,F
08C3E:  DECF   x90,F
08C40:  BTFSC  FD8.2
08C42:  BRA    8C50
08C44:  SETF   x91
08C46:  MOVLB  0
08C48:  CALL   2954
08C4C:  MOVLB  5
08C4E:  BRA    8C3E
08C50:  MOVFF  58E,591
08C54:  MOVLB  0
08C56:  CALL   2954
....................                         desaciona_saida(ALIMENTADOR1); 
08C5A:  MOVLB  5
08C5C:  CLRF   x8F
08C5E:  MOVLW  0E
08C60:  MOVWF  x8E
08C62:  MOVLB  0
08C64:  CALL   2DDC
....................                         delay_ms(maior-medio); 
08C68:  MOVLB  5
08C6A:  MOVF   x8A,W
08C6C:  SUBWF  x88,W
08C6E:  MOVWF  x8E
08C70:  MOVF   x8B,W
08C72:  SUBWFB x89,W
08C74:  MOVWF  x8F
08C76:  MOVWF  x90
08C78:  INCF   x90,F
08C7A:  DECF   x90,F
08C7C:  BTFSC  FD8.2
08C7E:  BRA    8C8C
08C80:  SETF   x91
08C82:  MOVLB  0
08C84:  CALL   2954
08C88:  MOVLB  5
08C8A:  BRA    8C7A
08C8C:  MOVFF  58E,591
08C90:  MOVLB  0
08C92:  CALL   2954
....................                         desaciona_saida(ALIMENTADOR2); 
08C96:  MOVLB  5
08C98:  CLRF   x8F
08C9A:  MOVLW  0D
08C9C:  MOVWF  x8E
08C9E:  MOVLB  0
08CA0:  CALL   2DDC
....................                     } else { 
08CA4:  BRA    8D92
08CA6:  MOVLB  5
....................                         maior = tempo2; 
08CA8:  MOVFF  585,589
08CAC:  MOVFF  584,588
....................                         medio = tempo3; 
08CB0:  MOVFF  587,58B
08CB4:  MOVFF  586,58A
....................                         menor = tempo1; 
08CB8:  MOVFF  583,58D
08CBC:  MOVFF  582,58C
....................                         aciona_saida(ALIMENTADOR1); 
08CC0:  CLRF   x8F
08CC2:  MOVLW  0E
08CC4:  MOVWF  x8E
08CC6:  MOVLB  0
08CC8:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR2); 
08CCC:  MOVLB  5
08CCE:  CLRF   x8F
08CD0:  MOVLW  0D
08CD2:  MOVWF  x8E
08CD4:  MOVLB  0
08CD6:  CALL   2E1E
....................                         aciona_saida(ALIMENTADOR3); 
08CDA:  MOVLB  5
08CDC:  CLRF   x8F
08CDE:  MOVLW  0C
08CE0:  MOVWF  x8E
08CE2:  MOVLB  0
08CE4:  CALL   2E1E
....................                         delay_ms(menor); 
08CE8:  MOVFF  58D,58E
08CEC:  MOVLB  5
08CEE:  INCF   x8E,F
08CF0:  DECF   x8E,F
08CF2:  BTFSC  FD8.2
08CF4:  BRA    8D02
08CF6:  SETF   x91
08CF8:  MOVLB  0
08CFA:  CALL   2954
08CFE:  MOVLB  5
08D00:  BRA    8CF0
08D02:  MOVFF  58C,591
08D06:  MOVLB  0
08D08:  CALL   2954
....................                         desaciona_saida(ALIMENTADOR1); 
08D0C:  MOVLB  5
08D0E:  CLRF   x8F
08D10:  MOVLW  0E
08D12:  MOVWF  x8E
08D14:  MOVLB  0
08D16:  CALL   2DDC
....................                         delay_ms(medio-menor); 
08D1A:  MOVLB  5
08D1C:  MOVF   x8C,W
08D1E:  SUBWF  x8A,W
08D20:  MOVWF  x8E
08D22:  MOVF   x8D,W
08D24:  SUBWFB x8B,W
08D26:  MOVWF  x8F
08D28:  MOVWF  x90
08D2A:  INCF   x90,F
08D2C:  DECF   x90,F
08D2E:  BTFSC  FD8.2
08D30:  BRA    8D3E
08D32:  SETF   x91
08D34:  MOVLB  0
08D36:  CALL   2954
08D3A:  MOVLB  5
08D3C:  BRA    8D2C
08D3E:  MOVFF  58E,591
08D42:  MOVLB  0
08D44:  CALL   2954
....................                         desaciona_saida(ALIMENTADOR3); 
08D48:  MOVLB  5
08D4A:  CLRF   x8F
08D4C:  MOVLW  0C
08D4E:  MOVWF  x8E
08D50:  MOVLB  0
08D52:  CALL   2DDC
....................                         delay_ms(maior-medio); 
08D56:  MOVLB  5
08D58:  MOVF   x8A,W
08D5A:  SUBWF  x88,W
08D5C:  MOVWF  x8E
08D5E:  MOVF   x8B,W
08D60:  SUBWFB x89,W
08D62:  MOVWF  x8F
08D64:  MOVWF  x90
08D66:  INCF   x90,F
08D68:  DECF   x90,F
08D6A:  BTFSC  FD8.2
08D6C:  BRA    8D7A
08D6E:  SETF   x91
08D70:  MOVLB  0
08D72:  CALL   2954
08D76:  MOVLB  5
08D78:  BRA    8D68
08D7A:  MOVFF  58E,591
08D7E:  MOVLB  0
08D80:  CALL   2954
....................                         desaciona_saida(ALIMENTADOR2); 
08D84:  MOVLB  5
08D86:  CLRF   x8F
08D88:  MOVLW  0D
08D8A:  MOVWF  x8E
08D8C:  MOVLB  0
08D8E:  CALL   2DDC
....................                     } 
....................                 } else { 
08D92:  BRA    8E80
08D94:  MOVLB  5
....................                     maior = tempo3; 
08D96:  MOVFF  587,589
08D9A:  MOVFF  586,588
....................                     medio = tempo2; 
08D9E:  MOVFF  585,58B
08DA2:  MOVFF  584,58A
....................                     menor = tempo1; 
08DA6:  MOVFF  583,58D
08DAA:  MOVFF  582,58C
....................                     aciona_saida(ALIMENTADOR1); 
08DAE:  CLRF   x8F
08DB0:  MOVLW  0E
08DB2:  MOVWF  x8E
08DB4:  MOVLB  0
08DB6:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR2); 
08DBA:  MOVLB  5
08DBC:  CLRF   x8F
08DBE:  MOVLW  0D
08DC0:  MOVWF  x8E
08DC2:  MOVLB  0
08DC4:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR3); 
08DC8:  MOVLB  5
08DCA:  CLRF   x8F
08DCC:  MOVLW  0C
08DCE:  MOVWF  x8E
08DD0:  MOVLB  0
08DD2:  CALL   2E1E
....................                     delay_ms(menor); 
08DD6:  MOVFF  58D,58E
08DDA:  MOVLB  5
08DDC:  INCF   x8E,F
08DDE:  DECF   x8E,F
08DE0:  BTFSC  FD8.2
08DE2:  BRA    8DF0
08DE4:  SETF   x91
08DE6:  MOVLB  0
08DE8:  CALL   2954
08DEC:  MOVLB  5
08DEE:  BRA    8DDE
08DF0:  MOVFF  58C,591
08DF4:  MOVLB  0
08DF6:  CALL   2954
....................                     desaciona_saida(ALIMENTADOR1); 
08DFA:  MOVLB  5
08DFC:  CLRF   x8F
08DFE:  MOVLW  0E
08E00:  MOVWF  x8E
08E02:  MOVLB  0
08E04:  CALL   2DDC
....................                     delay_ms(medio-menor); 
08E08:  MOVLB  5
08E0A:  MOVF   x8C,W
08E0C:  SUBWF  x8A,W
08E0E:  MOVWF  x8E
08E10:  MOVF   x8D,W
08E12:  SUBWFB x8B,W
08E14:  MOVWF  x8F
08E16:  MOVWF  x90
08E18:  INCF   x90,F
08E1A:  DECF   x90,F
08E1C:  BTFSC  FD8.2
08E1E:  BRA    8E2C
08E20:  SETF   x91
08E22:  MOVLB  0
08E24:  CALL   2954
08E28:  MOVLB  5
08E2A:  BRA    8E1A
08E2C:  MOVFF  58E,591
08E30:  MOVLB  0
08E32:  CALL   2954
....................                     desaciona_saida(ALIMENTADOR2); 
08E36:  MOVLB  5
08E38:  CLRF   x8F
08E3A:  MOVLW  0D
08E3C:  MOVWF  x8E
08E3E:  MOVLB  0
08E40:  CALL   2DDC
....................                     delay_ms(maior-medio); 
08E44:  MOVLB  5
08E46:  MOVF   x8A,W
08E48:  SUBWF  x88,W
08E4A:  MOVWF  x8E
08E4C:  MOVF   x8B,W
08E4E:  SUBWFB x89,W
08E50:  MOVWF  x8F
08E52:  MOVWF  x90
08E54:  INCF   x90,F
08E56:  DECF   x90,F
08E58:  BTFSC  FD8.2
08E5A:  BRA    8E68
08E5C:  SETF   x91
08E5E:  MOVLB  0
08E60:  CALL   2954
08E64:  MOVLB  5
08E66:  BRA    8E56
08E68:  MOVFF  58E,591
08E6C:  MOVLB  0
08E6E:  CALL   2954
....................                     desaciona_saida(ALIMENTADOR3); 
08E72:  MOVLB  5
08E74:  CLRF   x8F
08E76:  MOVLW  0C
08E78:  MOVWF  x8E
08E7A:  MOVLB  0
08E7C:  CALL   2DDC
....................                 } 
....................             } 
....................         break; 
08E80:  MOVLB  5
08E82:  BRA    8E86
08E84:  MOVLB  5
....................     } 
08E86:  MOVLB  0
08E88:  RETURN 0
....................              
.................... } 
....................  
.................... void soldar_teste(int componente, int local){ 
....................     liga_pressor(); 
*
08EB6:  CALL   7A76
....................     if ((local == 14)&&(modelo == 1)){ 
08EBA:  MOVLB  5
08EBC:  MOVF   x78,W
08EBE:  SUBLW  0E
08EC0:  BNZ   8EC8
08EC2:  DECFSZ 2E,W
08EC4:  BRA    8EC8
....................         local++; 
08EC6:  INCF   x78,F
....................     } 
....................     if ((y[local] > 700)&&(x[local] > 0)){ 
08EC8:  BCF    FD8.0
08ECA:  RLCF   x78,W
08ECC:  CLRF   03
08ECE:  ADDLW  59
08ED0:  MOVWF  FE9
08ED2:  MOVLW  00
08ED4:  ADDWFC 03,W
08ED6:  MOVWF  FEA
08ED8:  MOVFF  FEC,57A
08EDC:  MOVF   FED,F
08EDE:  MOVFF  FEF,579
08EE2:  MOVF   x7A,W
08EE4:  SUBLW  01
08EE6:  BTFSC  FD8.0
08EE8:  BRA    9582
08EEA:  XORLW  FF
08EEC:  BNZ   8EF6
08EEE:  MOVF   x79,W
08EF0:  SUBLW  BC
08EF2:  BTFSC  FD8.0
08EF4:  BRA    9582
08EF6:  BCF    FD8.0
08EF8:  RLCF   x78,W
08EFA:  CLRF   03
08EFC:  ADDLW  2F
08EFE:  MOVWF  FE9
08F00:  MOVLW  00
08F02:  ADDWFC 03,W
08F04:  MOVWF  FEA
08F06:  MOVFF  FEC,57A
08F0A:  MOVF   FED,F
08F0C:  MOVFF  FEF,579
08F10:  MOVF   x79,F
08F12:  BNZ   8F1A
08F14:  MOVF   x7A,F
08F16:  BTFSC  FD8.2
08F18:  BRA    9582
....................         desce_ferros(numeroFerros[local]); 
08F1A:  BCF    FD8.0
08F1C:  RLCF   x78,W
08F1E:  CLRF   03
08F20:  ADDLW  57
08F22:  MOVWF  FE9
08F24:  MOVLW  01
08F26:  ADDWFC 03,W
08F28:  MOVWF  FEA
08F2A:  MOVFF  FEC,57A
08F2E:  MOVF   FED,F
08F30:  MOVFF  FEF,579
08F34:  MOVFF  579,57C
08F38:  MOVLB  0
08F3A:  CALL   7A24
....................         switch (componente){ 
08F3E:  MOVLB  5
08F40:  MOVF   x77,W
08F42:  XORLW  00
08F44:  MOVLB  0
08F46:  BZ    8F50
08F48:  XORLW  01
08F4A:  BTFSC  FD8.2
08F4C:  BRA    9132
08F4E:  BRA    957E
....................             case 0: 
....................                 motor_run_y(y[local], 19); 
08F50:  BCF    FD8.0
08F52:  MOVLB  5
08F54:  RLCF   x78,W
08F56:  CLRF   03
08F58:  ADDLW  59
08F5A:  MOVWF  FE9
08F5C:  MOVLW  00
08F5E:  ADDWFC 03,W
08F60:  MOVWF  FEA
08F62:  MOVFF  FEC,57A
08F66:  MOVF   FED,F
08F68:  MOVFF  FEF,579
08F6C:  CLRF   x7F
08F6E:  CLRF   x7E
08F70:  MOVFF  57A,57D
08F74:  MOVFF  579,57C
08F78:  MOVLW  13
08F7A:  MOVWF  x80
08F7C:  MOVLB  0
08F7E:  CALL   6622
....................                 while ((run_flg_y)); 
08F82:  MOVLB  2
08F84:  BTFSC  x0B.7
08F86:  BRA    8F84
....................                 motor_run_x(x[local], 19); 
08F88:  BCF    FD8.0
08F8A:  MOVLB  5
08F8C:  RLCF   x78,W
08F8E:  CLRF   03
08F90:  ADDLW  2F
08F92:  MOVWF  FE9
08F94:  MOVLW  00
08F96:  ADDWFC 03,W
08F98:  MOVWF  FEA
08F9A:  MOVFF  FEC,57A
08F9E:  MOVF   FED,F
08FA0:  MOVFF  FEF,579
08FA4:  CLRF   x7F
08FA6:  CLRF   x7E
08FA8:  MOVFF  57A,57D
08FAC:  MOVFF  579,57C
08FB0:  MOVLW  13
08FB2:  MOVWF  x80
08FB4:  MOVLB  0
08FB6:  CALL   55F6
....................                 while ((run_flg_x)); 
08FBA:  MOVLB  2
08FBC:  BTFSC  x0B.5
08FBE:  BRA    8FBC
....................                 ligar_alimentador_solda(numeroFerros[local],t_solda[local],t_solda2[local],t_solda3[local]); 
08FC0:  BCF    FD8.0
08FC2:  MOVLB  5
08FC4:  RLCF   x78,W
08FC6:  CLRF   03
08FC8:  ADDLW  57
08FCA:  MOVWF  FE9
08FCC:  MOVLW  01
08FCE:  ADDWFC 03,W
08FD0:  MOVWF  FEA
08FD2:  MOVFF  FEC,57A
08FD6:  MOVF   FED,F
08FD8:  MOVFF  FEF,579
08FDC:  BCF    FD8.0
08FDE:  RLCF   x78,W
08FE0:  CLRF   03
08FE2:  ADDLW  AD
08FE4:  MOVWF  FE9
08FE6:  MOVLW  00
08FE8:  ADDWFC 03,W
08FEA:  MOVWF  FEA
08FEC:  MOVFF  FEC,57C
08FF0:  MOVF   FED,F
08FF2:  MOVFF  FEF,57B
08FF6:  BCF    FD8.0
08FF8:  RLCF   x78,W
08FFA:  CLRF   03
08FFC:  ADDLW  81
08FFE:  MOVWF  FE9
09000:  MOVLW  01
09002:  ADDWFC 03,W
09004:  MOVWF  FEA
09006:  MOVFF  FEC,57E
0900A:  MOVF   FED,F
0900C:  MOVFF  FEF,57D
09010:  BCF    FD8.0
09012:  RLCF   x78,W
09014:  CLRF   03
09016:  ADDLW  AB
09018:  MOVWF  FE9
0901A:  MOVLW  01
0901C:  ADDWFC 03,W
0901E:  MOVWF  FEA
09020:  MOVFF  FEC,580
09024:  MOVF   FED,F
09026:  MOVFF  FEF,57F
0902A:  MOVFF  579,581
0902E:  MOVFF  57C,583
09032:  MOVFF  57B,582
09036:  MOVFF  57E,585
0903A:  MOVFF  57D,584
0903E:  MOVFF  580,587
09042:  MOVFF  57F,586
09046:  MOVLB  0
09048:  CALL   851C
....................                 motor_run_z(z[local], 19); 
0904C:  BCF    FD8.0
0904E:  MOVLB  5
09050:  RLCF   x78,W
09052:  CLRF   03
09054:  ADDLW  83
09056:  MOVWF  FE9
09058:  MOVLW  00
0905A:  ADDWFC 03,W
0905C:  MOVWF  FEA
0905E:  MOVFF  FEC,57A
09062:  MOVF   FED,F
09064:  MOVFF  FEF,579
09068:  CLRF   x7F
0906A:  CLRF   x7E
0906C:  MOVFF  57A,57D
09070:  MOVFF  579,57C
09074:  MOVLW  13
09076:  MOVWF  x80
09078:  MOVLB  0
0907A:  CALL   63C2
....................                 while ((run_flg_z)); 
0907E:  MOVLB  3
09080:  BTFSC  xB7.2
09082:  BRA    9080
....................                 delay_ms(t_wait[local]);  
09084:  BCF    FD8.0
09086:  MOVLB  5
09088:  RLCF   x78,W
0908A:  CLRF   03
0908C:  ADDLW  D7
0908E:  MOVWF  FE9
09090:  MOVLW  00
09092:  ADDWFC 03,W
09094:  MOVWF  FEA
09096:  MOVFF  FEC,57A
0909A:  MOVF   FED,F
0909C:  MOVFF  FEF,579
090A0:  MOVFF  57A,57B
090A4:  INCF   x7B,F
090A6:  DECF   x7B,F
090A8:  BTFSC  FD8.2
090AA:  BRA    90B8
090AC:  SETF   x91
090AE:  MOVLB  0
090B0:  CALL   2954
090B4:  MOVLB  5
090B6:  BRA    90A6
090B8:  MOVFF  579,591
090BC:  MOVLB  0
090BE:  CALL   2954
....................                 motor_run_z(0, 19); 
090C2:  MOVLB  5
090C4:  CLRF   x7F
090C6:  CLRF   x7E
090C8:  CLRF   x7D
090CA:  CLRF   x7C
090CC:  MOVLW  13
090CE:  MOVWF  x80
090D0:  MOVLB  0
090D2:  CALL   63C2
....................                 while ((run_flg_z)); 
090D6:  MOVLB  3
090D8:  BTFSC  xB7.2
090DA:  BRA    90D8
....................                 desce_ferros(3); 
090DC:  MOVLW  03
090DE:  MOVLB  5
090E0:  MOVWF  x7C
090E2:  MOVLB  0
090E4:  CALL   7A24
....................                 aciona_saida(LIMPA_BICO1); 
090E8:  MOVLB  5
090EA:  CLRF   x8F
090EC:  MOVLW  08
090EE:  MOVWF  x8E
090F0:  MOVLB  0
090F2:  CALL   2E1E
....................                 aciona_saida(LIMPA_BICO2); 
090F6:  MOVLB  5
090F8:  CLRF   x8F
090FA:  MOVLW  09
090FC:  MOVWF  x8E
090FE:  MOVLB  0
09100:  CALL   2E1E
....................                 delay_ms(200); 
09104:  MOVLW  C8
09106:  MOVLB  5
09108:  MOVWF  x91
0910A:  MOVLB  0
0910C:  CALL   2954
....................                 desaciona_saida(LIMPA_BICO1); 
09110:  MOVLB  5
09112:  CLRF   x8F
09114:  MOVLW  08
09116:  MOVWF  x8E
09118:  MOVLB  0
0911A:  CALL   2DDC
....................                 desaciona_saida(LIMPA_BICO2); 
0911E:  MOVLB  5
09120:  CLRF   x8F
09122:  MOVLW  09
09124:  MOVWF  x8E
09126:  MOVLB  0
09128:  CALL   2DDC
....................                 sobe_ferros(); 
0912C:  CALL   7A06
....................             break; 
09130:  BRA    957E
....................             case 1: 
....................                 motor_run_y(y[local], 19); 
09132:  BCF    FD8.0
09134:  MOVLB  5
09136:  RLCF   x78,W
09138:  CLRF   03
0913A:  ADDLW  59
0913C:  MOVWF  FE9
0913E:  MOVLW  00
09140:  ADDWFC 03,W
09142:  MOVWF  FEA
09144:  MOVFF  FEC,57A
09148:  MOVF   FED,F
0914A:  MOVFF  FEF,579
0914E:  CLRF   x7F
09150:  CLRF   x7E
09152:  MOVFF  57A,57D
09156:  MOVFF  579,57C
0915A:  MOVLW  13
0915C:  MOVWF  x80
0915E:  MOVLB  0
09160:  CALL   6622
....................                 while ((run_flg_y)); 
09164:  MOVLB  2
09166:  BTFSC  x0B.7
09168:  BRA    9166
....................                 motor_run_x(x[local], 19); 
0916A:  BCF    FD8.0
0916C:  MOVLB  5
0916E:  RLCF   x78,W
09170:  CLRF   03
09172:  ADDLW  2F
09174:  MOVWF  FE9
09176:  MOVLW  00
09178:  ADDWFC 03,W
0917A:  MOVWF  FEA
0917C:  MOVFF  FEC,57A
09180:  MOVF   FED,F
09182:  MOVFF  FEF,579
09186:  CLRF   x7F
09188:  CLRF   x7E
0918A:  MOVFF  57A,57D
0918E:  MOVFF  579,57C
09192:  MOVLW  13
09194:  MOVWF  x80
09196:  MOVLB  0
09198:  CALL   55F6
....................                 while ((run_flg_x)); 
0919C:  MOVLB  2
0919E:  BTFSC  x0B.5
091A0:  BRA    919E
....................                 ligar_alimentador_solda(numeroFerros[local],t_solda[local],t_solda2[local],t_solda3[local]); 
091A2:  BCF    FD8.0
091A4:  MOVLB  5
091A6:  RLCF   x78,W
091A8:  CLRF   03
091AA:  ADDLW  57
091AC:  MOVWF  FE9
091AE:  MOVLW  01
091B0:  ADDWFC 03,W
091B2:  MOVWF  FEA
091B4:  MOVFF  FEC,57A
091B8:  MOVF   FED,F
091BA:  MOVFF  FEF,579
091BE:  BCF    FD8.0
091C0:  RLCF   x78,W
091C2:  CLRF   03
091C4:  ADDLW  AD
091C6:  MOVWF  FE9
091C8:  MOVLW  00
091CA:  ADDWFC 03,W
091CC:  MOVWF  FEA
091CE:  MOVFF  FEC,57C
091D2:  MOVF   FED,F
091D4:  MOVFF  FEF,57B
091D8:  BCF    FD8.0
091DA:  RLCF   x78,W
091DC:  CLRF   03
091DE:  ADDLW  81
091E0:  MOVWF  FE9
091E2:  MOVLW  01
091E4:  ADDWFC 03,W
091E6:  MOVWF  FEA
091E8:  MOVFF  FEC,57E
091EC:  MOVF   FED,F
091EE:  MOVFF  FEF,57D
091F2:  BCF    FD8.0
091F4:  RLCF   x78,W
091F6:  CLRF   03
091F8:  ADDLW  AB
091FA:  MOVWF  FE9
091FC:  MOVLW  01
091FE:  ADDWFC 03,W
09200:  MOVWF  FEA
09202:  MOVFF  FEC,580
09206:  MOVF   FED,F
09208:  MOVFF  FEF,57F
0920C:  MOVFF  579,581
09210:  MOVFF  57C,583
09214:  MOVFF  57B,582
09218:  MOVFF  57E,585
0921C:  MOVFF  57D,584
09220:  MOVFF  580,587
09224:  MOVFF  57F,586
09228:  MOVLB  0
0922A:  CALL   851C
....................                 motor_run_z(z[local], 19); 
0922E:  BCF    FD8.0
09230:  MOVLB  5
09232:  RLCF   x78,W
09234:  CLRF   03
09236:  ADDLW  83
09238:  MOVWF  FE9
0923A:  MOVLW  00
0923C:  ADDWFC 03,W
0923E:  MOVWF  FEA
09240:  MOVFF  FEC,57A
09244:  MOVF   FED,F
09246:  MOVFF  FEF,579
0924A:  CLRF   x7F
0924C:  CLRF   x7E
0924E:  MOVFF  57A,57D
09252:  MOVFF  579,57C
09256:  MOVLW  13
09258:  MOVWF  x80
0925A:  MOVLB  0
0925C:  CALL   63C2
....................                 while ((run_flg_z)); 
09260:  MOVLB  3
09262:  BTFSC  xB7.2
09264:  BRA    9262
....................                 delay_ms(t_wait[local]); 
09266:  BCF    FD8.0
09268:  MOVLB  5
0926A:  RLCF   x78,W
0926C:  CLRF   03
0926E:  ADDLW  D7
09270:  MOVWF  FE9
09272:  MOVLW  00
09274:  ADDWFC 03,W
09276:  MOVWF  FEA
09278:  MOVFF  FEC,57A
0927C:  MOVF   FED,F
0927E:  MOVFF  FEF,579
09282:  MOVFF  57A,57B
09286:  INCF   x7B,F
09288:  DECF   x7B,F
0928A:  BTFSC  FD8.2
0928C:  BRA    929A
0928E:  SETF   x91
09290:  MOVLB  0
09292:  CALL   2954
09296:  MOVLB  5
09298:  BRA    9288
0929A:  MOVFF  579,591
0929E:  MOVLB  0
092A0:  CALL   2954
....................                 motor_run_z(z[local]-5, 19); 
092A4:  BCF    FD8.0
092A6:  MOVLB  5
092A8:  RLCF   x78,W
092AA:  CLRF   03
092AC:  ADDLW  83
092AE:  MOVWF  FE9
092B0:  MOVLW  00
092B2:  ADDWFC 03,W
092B4:  MOVWF  FEA
092B6:  MOVFF  FEC,57A
092BA:  MOVF   FED,F
092BC:  MOVFF  FEF,579
092C0:  MOVLW  05
092C2:  SUBWF  x79,F
092C4:  MOVLW  00
092C6:  SUBWFB x7A,F
092C8:  CLRF   x7F
092CA:  CLRF   x7E
092CC:  MOVFF  57A,57D
092D0:  MOVFF  579,57C
092D4:  MOVLW  13
092D6:  MOVWF  x80
092D8:  MOVLB  0
092DA:  CALL   63C2
....................                 while ((run_flg_z)); 
092DE:  MOVLB  3
092E0:  BTFSC  xB7.2
092E2:  BRA    92E0
....................                 motor_run_x(x[local]-21, 19); 
092E4:  BCF    FD8.0
092E6:  MOVLB  5
092E8:  RLCF   x78,W
092EA:  CLRF   03
092EC:  ADDLW  2F
092EE:  MOVWF  FE9
092F0:  MOVLW  00
092F2:  ADDWFC 03,W
092F4:  MOVWF  FEA
092F6:  MOVFF  FEC,57A
092FA:  MOVF   FED,F
092FC:  MOVFF  FEF,579
09300:  MOVLW  15
09302:  SUBWF  x79,F
09304:  MOVLW  00
09306:  SUBWFB x7A,F
09308:  CLRF   x7F
0930A:  CLRF   x7E
0930C:  MOVFF  57A,57D
09310:  MOVFF  579,57C
09314:  MOVLW  13
09316:  MOVWF  x80
09318:  MOVLB  0
0931A:  CALL   55F6
....................                 while ((run_flg_x)); 
0931E:  MOVLB  2
09320:  BTFSC  x0B.5
09322:  BRA    9320
....................                 motor_run_z(z[local], 19); 
09324:  BCF    FD8.0
09326:  MOVLB  5
09328:  RLCF   x78,W
0932A:  CLRF   03
0932C:  ADDLW  83
0932E:  MOVWF  FE9
09330:  MOVLW  00
09332:  ADDWFC 03,W
09334:  MOVWF  FEA
09336:  MOVFF  FEC,57A
0933A:  MOVF   FED,F
0933C:  MOVFF  FEF,579
09340:  CLRF   x7F
09342:  CLRF   x7E
09344:  MOVFF  57A,57D
09348:  MOVFF  579,57C
0934C:  MOVLW  13
0934E:  MOVWF  x80
09350:  MOVLB  0
09352:  CALL   63C2
....................                 while ((run_flg_z)); 
09356:  MOVLB  3
09358:  BTFSC  xB7.2
0935A:  BRA    9358
....................                 delay_ms(t_wait[local]);   
0935C:  BCF    FD8.0
0935E:  MOVLB  5
09360:  RLCF   x78,W
09362:  CLRF   03
09364:  ADDLW  D7
09366:  MOVWF  FE9
09368:  MOVLW  00
0936A:  ADDWFC 03,W
0936C:  MOVWF  FEA
0936E:  MOVFF  FEC,57A
09372:  MOVF   FED,F
09374:  MOVFF  FEF,579
09378:  MOVFF  57A,57B
0937C:  INCF   x7B,F
0937E:  DECF   x7B,F
09380:  BTFSC  FD8.2
09382:  BRA    9390
09384:  SETF   x91
09386:  MOVLB  0
09388:  CALL   2954
0938C:  MOVLB  5
0938E:  BRA    937E
09390:  MOVFF  579,591
09394:  MOVLB  0
09396:  CALL   2954
....................                 motor_run_z(z[local]-5, 19); 
0939A:  BCF    FD8.0
0939C:  MOVLB  5
0939E:  RLCF   x78,W
093A0:  CLRF   03
093A2:  ADDLW  83
093A4:  MOVWF  FE9
093A6:  MOVLW  00
093A8:  ADDWFC 03,W
093AA:  MOVWF  FEA
093AC:  MOVFF  FEC,57A
093B0:  MOVF   FED,F
093B2:  MOVFF  FEF,579
093B6:  MOVLW  05
093B8:  SUBWF  x79,F
093BA:  MOVLW  00
093BC:  SUBWFB x7A,F
093BE:  CLRF   x7F
093C0:  CLRF   x7E
093C2:  MOVFF  57A,57D
093C6:  MOVFF  579,57C
093CA:  MOVLW  13
093CC:  MOVWF  x80
093CE:  MOVLB  0
093D0:  CALL   63C2
....................                 while ((run_flg_z)); 
093D4:  MOVLB  3
093D6:  BTFSC  xB7.2
093D8:  BRA    93D6
....................                 motor_run_x(x[local]-42, 19); 
093DA:  BCF    FD8.0
093DC:  MOVLB  5
093DE:  RLCF   x78,W
093E0:  CLRF   03
093E2:  ADDLW  2F
093E4:  MOVWF  FE9
093E6:  MOVLW  00
093E8:  ADDWFC 03,W
093EA:  MOVWF  FEA
093EC:  MOVFF  FEC,57A
093F0:  MOVF   FED,F
093F2:  MOVFF  FEF,579
093F6:  MOVLW  2A
093F8:  SUBWF  x79,F
093FA:  MOVLW  00
093FC:  SUBWFB x7A,F
093FE:  CLRF   x7F
09400:  CLRF   x7E
09402:  MOVFF  57A,57D
09406:  MOVFF  579,57C
0940A:  MOVLW  13
0940C:  MOVWF  x80
0940E:  MOVLB  0
09410:  CALL   55F6
....................                 while ((run_flg_x)); 
09414:  MOVLB  2
09416:  BTFSC  x0B.5
09418:  BRA    9416
....................                 motor_run_z(z[local], 19); 
0941A:  BCF    FD8.0
0941C:  MOVLB  5
0941E:  RLCF   x78,W
09420:  CLRF   03
09422:  ADDLW  83
09424:  MOVWF  FE9
09426:  MOVLW  00
09428:  ADDWFC 03,W
0942A:  MOVWF  FEA
0942C:  MOVFF  FEC,57A
09430:  MOVF   FED,F
09432:  MOVFF  FEF,579
09436:  CLRF   x7F
09438:  CLRF   x7E
0943A:  MOVFF  57A,57D
0943E:  MOVFF  579,57C
09442:  MOVLW  13
09444:  MOVWF  x80
09446:  MOVLB  0
09448:  CALL   63C2
....................                 while ((run_flg_z)); 
0944C:  MOVLB  3
0944E:  BTFSC  xB7.2
09450:  BRA    944E
....................                 delay_ms(t_wait[local]); 
09452:  BCF    FD8.0
09454:  MOVLB  5
09456:  RLCF   x78,W
09458:  CLRF   03
0945A:  ADDLW  D7
0945C:  MOVWF  FE9
0945E:  MOVLW  00
09460:  ADDWFC 03,W
09462:  MOVWF  FEA
09464:  MOVFF  FEC,57A
09468:  MOVF   FED,F
0946A:  MOVFF  FEF,579
0946E:  MOVFF  57A,57B
09472:  INCF   x7B,F
09474:  DECF   x7B,F
09476:  BTFSC  FD8.2
09478:  BRA    9486
0947A:  SETF   x91
0947C:  MOVLB  0
0947E:  CALL   2954
09482:  MOVLB  5
09484:  BRA    9474
09486:  MOVFF  579,591
0948A:  MOVLB  0
0948C:  CALL   2954
....................                 motor_run_z(z[local]-5, 19); 
09490:  BCF    FD8.0
09492:  MOVLB  5
09494:  RLCF   x78,W
09496:  CLRF   03
09498:  ADDLW  83
0949A:  MOVWF  FE9
0949C:  MOVLW  00
0949E:  ADDWFC 03,W
094A0:  MOVWF  FEA
094A2:  MOVFF  FEC,57A
094A6:  MOVF   FED,F
094A8:  MOVFF  FEF,579
094AC:  MOVLW  05
094AE:  SUBWF  x79,F
094B0:  MOVLW  00
094B2:  SUBWFB x7A,F
094B4:  CLRF   x7F
094B6:  CLRF   x7E
094B8:  MOVFF  57A,57D
094BC:  MOVFF  579,57C
094C0:  MOVLW  13
094C2:  MOVWF  x80
094C4:  MOVLB  0
094C6:  CALL   63C2
....................                 while ((run_flg_z)); 
094CA:  MOVLB  3
094CC:  BTFSC  xB7.2
094CE:  BRA    94CC
....................                 motor_run_x(x[local]+40, 19); 
094D0:  BCF    FD8.0
094D2:  MOVLB  5
094D4:  RLCF   x78,W
094D6:  CLRF   03
094D8:  ADDLW  2F
094DA:  MOVWF  FE9
094DC:  MOVLW  00
094DE:  ADDWFC 03,W
094E0:  MOVWF  FEA
094E2:  MOVFF  FEC,57A
094E6:  MOVF   FED,F
094E8:  MOVFF  FEF,579
094EC:  MOVLW  28
094EE:  ADDWF  x79,F
094F0:  MOVLW  00
094F2:  ADDWFC x7A,F
094F4:  CLRF   x7F
094F6:  CLRF   x7E
094F8:  MOVFF  57A,57D
094FC:  MOVFF  579,57C
09500:  MOVLW  13
09502:  MOVWF  x80
09504:  MOVLB  0
09506:  CALL   55F6
....................                 while ((run_flg_x)); 
0950A:  MOVLB  2
0950C:  BTFSC  x0B.5
0950E:  BRA    950C
....................                 motor_run_z(0, 19); 
09510:  MOVLB  5
09512:  CLRF   x7F
09514:  CLRF   x7E
09516:  CLRF   x7D
09518:  CLRF   x7C
0951A:  MOVLW  13
0951C:  MOVWF  x80
0951E:  MOVLB  0
09520:  CALL   63C2
....................                 while ((run_flg_z)); 
09524:  MOVLB  3
09526:  BTFSC  xB7.2
09528:  BRA    9526
....................                 desce_ferros(3); 
0952A:  MOVLW  03
0952C:  MOVLB  5
0952E:  MOVWF  x7C
09530:  MOVLB  0
09532:  CALL   7A24
....................                 aciona_saida(LIMPA_BICO1); 
09536:  MOVLB  5
09538:  CLRF   x8F
0953A:  MOVLW  08
0953C:  MOVWF  x8E
0953E:  MOVLB  0
09540:  CALL   2E1E
....................                 aciona_saida(LIMPA_BICO2); 
09544:  MOVLB  5
09546:  CLRF   x8F
09548:  MOVLW  09
0954A:  MOVWF  x8E
0954C:  MOVLB  0
0954E:  CALL   2E1E
....................                 delay_ms(200); 
09552:  MOVLW  C8
09554:  MOVLB  5
09556:  MOVWF  x91
09558:  MOVLB  0
0955A:  CALL   2954
....................                 desaciona_saida(LIMPA_BICO1); 
0955E:  MOVLB  5
09560:  CLRF   x8F
09562:  MOVLW  08
09564:  MOVWF  x8E
09566:  MOVLB  0
09568:  CALL   2DDC
....................                 desaciona_saida(LIMPA_BICO2); 
0956C:  MOVLB  5
0956E:  CLRF   x8F
09570:  MOVLW  09
09572:  MOVWF  x8E
09574:  MOVLB  0
09576:  CALL   2DDC
....................                 sobe_ferros(); 
0957A:  CALL   7A06
....................             break; 
....................         } 
....................     } 
0957E:  BRA    95C8
09580:  MOVLB  5
....................     else { 
....................         printf(lcd_putc, "\f"); //limpa display 
09582:  MOVLW  0C
09584:  MOVWF  x85
09586:  MOVLB  0
09588:  CALL   2D30
....................         printf(lcd_putc, "  POSICAO IRREGULAR \n\r"); 
0958C:  MOVLW  3A
0958E:  MOVWF  FF6
09590:  MOVLW  0E
09592:  MOVWF  FF7
09594:  CALL   2D86
....................         printf(lcd_putc, "   X DEVE SER > 0   \n\r"); 
09598:  MOVLW  52
0959A:  MOVWF  FF6
0959C:  MOVLW  0E
0959E:  MOVWF  FF7
095A0:  CALL   2D86
....................         printf(lcd_putc, "  Y DEVE SER > 700  \n\r"); 
095A4:  MOVLW  6A
095A6:  MOVWF  FF6
095A8:  MOVLW  0E
095AA:  MOVWF  FF7
095AC:  CALL   2D86
....................         delay_ms(5000); 
095B0:  MOVLW  14
095B2:  MOVLB  5
095B4:  MOVWF  x79
095B6:  MOVLW  FA
095B8:  MOVWF  x91
095BA:  MOVLB  0
095BC:  CALL   2954
095C0:  MOVLB  5
095C2:  DECFSZ x79,F
095C4:  BRA    95B6
095C6:  MOVLB  0
....................     } 
....................     sobe_ferros(); 
095C8:  CALL   7A06
095CC:  RETURN 0
.................... } //void soldar_teste(tipo[contador_lcd], contador_lcd) 
.................... void soldar(void){ 
....................     liga_pressor(); 
*
0C91E:  CALL   7A76
....................     for(int i=0; i < pontos_no_modelo+1; i++){ 
0C922:  MOVLB  5
0C924:  CLRF   x77
0C926:  MOVLW  01
0C928:  MOVLB  1
0C92A:  ADDWF  x2B,W
0C92C:  MOVWF  01
0C92E:  MOVLW  00
0C930:  ADDWFC x2C,W
0C932:  MOVWF  03
0C934:  MOVF   01,W
0C936:  MOVF   03,F
0C938:  BNZ   C946
0C93A:  MOVF   01,W
0C93C:  MOVLB  5
0C93E:  SUBWF  x77,W
0C940:  BTFSC  FD8.0
0C942:  BRA    D0E6
0C944:  MOVLB  1
....................         if ((i == 14)&&(modelo == 1)){ 
0C946:  MOVLB  5
0C948:  MOVF   x77,W
0C94A:  SUBLW  0E
0C94C:  BNZ   C954
0C94E:  DECFSZ 2E,W
0C950:  BRA    C954
....................             i++; 
0C952:  INCF   x77,F
....................         } 
....................         if (habilitado[i] == TRUE) { 
0C954:  BCF    FD8.0
0C956:  RLCF   x77,W
0C958:  CLRF   03
0C95A:  ADDLW  2D
0C95C:  MOVWF  FE9
0C95E:  MOVLW  01
0C960:  ADDWFC 03,W
0C962:  MOVWF  FEA
0C964:  MOVFF  FEC,579
0C968:  MOVF   FED,F
0C96A:  MOVFF  FEF,578
0C96E:  DECFSZ x78,W
0C970:  BRA    D0DA
0C972:  MOVF   x79,F
0C974:  BTFSS  FD8.2
0C976:  BRA    D0DA
....................             switch (tipo[i]){ 
0C978:  BCF    FD8.0
0C97A:  RLCF   x77,W
0C97C:  CLRF   03
0C97E:  ADDLW  01
0C980:  MOVWF  FE9
0C982:  MOVLW  01
0C984:  ADDWFC 03,W
0C986:  MOVWF  FEA
0C988:  MOVF   FEF,W
0C98A:  MOVWF  00
0C98C:  INCF   FE9,F
0C98E:  MOVF   FEF,W
0C990:  DECF   FE9,F
0C992:  MOVWF  03
0C994:  MOVF   03,W
0C996:  BNZ   C9A0
0C998:  MOVF   00,F
0C99A:  MOVLB  0
0C99C:  BZ    C9B2
0C99E:  MOVLB  5
0C9A0:  MOVF   03,W
0C9A2:  BNZ   C9B0
0C9A4:  MOVLW  01
0C9A6:  SUBWF  00,W
0C9A8:  MOVLB  0
0C9AA:  BTFSC  FD8.2
0C9AC:  BRA    CC0C
0C9AE:  MOVLB  5
0C9B0:  BRA    D0DA
....................                 case 0: 
....................                     motor_run_y(y[i], 19); 
0C9B2:  BCF    FD8.0
0C9B4:  MOVLB  5
0C9B6:  RLCF   x77,W
0C9B8:  CLRF   03
0C9BA:  ADDLW  59
0C9BC:  MOVWF  FE9
0C9BE:  MOVLW  00
0C9C0:  ADDWFC 03,W
0C9C2:  MOVWF  FEA
0C9C4:  MOVFF  FEC,579
0C9C8:  MOVF   FED,F
0C9CA:  MOVFF  FEF,578
0C9CE:  CLRF   x7F
0C9D0:  CLRF   x7E
0C9D2:  MOVFF  579,57D
0C9D6:  MOVFF  578,57C
0C9DA:  MOVLW  13
0C9DC:  MOVWF  x80
0C9DE:  MOVLB  0
0C9E0:  CALL   6622
....................                     while ((run_flg_y)); 
0C9E4:  MOVLB  2
0C9E6:  BTFSC  x0B.7
0C9E8:  BRA    C9E6
....................                     motor_run_x(x[i], 19); 
0C9EA:  BCF    FD8.0
0C9EC:  MOVLB  5
0C9EE:  RLCF   x77,W
0C9F0:  CLRF   03
0C9F2:  ADDLW  2F
0C9F4:  MOVWF  FE9
0C9F6:  MOVLW  00
0C9F8:  ADDWFC 03,W
0C9FA:  MOVWF  FEA
0C9FC:  MOVFF  FEC,579
0CA00:  MOVF   FED,F
0CA02:  MOVFF  FEF,578
0CA06:  CLRF   x7F
0CA08:  CLRF   x7E
0CA0A:  MOVFF  579,57D
0CA0E:  MOVFF  578,57C
0CA12:  MOVLW  13
0CA14:  MOVWF  x80
0CA16:  MOVLB  0
0CA18:  CALL   55F6
....................                     while ((run_flg_x)); 
0CA1C:  MOVLB  2
0CA1E:  BTFSC  x0B.5
0CA20:  BRA    CA1E
....................                     desce_ferros(numeroFerros[i]); 
0CA22:  BCF    FD8.0
0CA24:  MOVLB  5
0CA26:  RLCF   x77,W
0CA28:  CLRF   03
0CA2A:  ADDLW  57
0CA2C:  MOVWF  FE9
0CA2E:  MOVLW  01
0CA30:  ADDWFC 03,W
0CA32:  MOVWF  FEA
0CA34:  MOVFF  FEC,579
0CA38:  MOVF   FED,F
0CA3A:  MOVFF  FEF,578
0CA3E:  MOVFF  578,57C
0CA42:  MOVLB  0
0CA44:  CALL   7A24
....................                     ligar_alimentador_solda(numeroFerros[i],t_solda[i],t_solda2[i],t_solda3[i]); 
0CA48:  BCF    FD8.0
0CA4A:  MOVLB  5
0CA4C:  RLCF   x77,W
0CA4E:  CLRF   03
0CA50:  ADDLW  57
0CA52:  MOVWF  FE9
0CA54:  MOVLW  01
0CA56:  ADDWFC 03,W
0CA58:  MOVWF  FEA
0CA5A:  MOVFF  FEC,579
0CA5E:  MOVF   FED,F
0CA60:  MOVFF  FEF,578
0CA64:  BCF    FD8.0
0CA66:  RLCF   x77,W
0CA68:  CLRF   03
0CA6A:  ADDLW  AD
0CA6C:  MOVWF  FE9
0CA6E:  MOVLW  00
0CA70:  ADDWFC 03,W
0CA72:  MOVWF  FEA
0CA74:  MOVFF  FEC,57B
0CA78:  MOVF   FED,F
0CA7A:  MOVFF  FEF,57A
0CA7E:  BCF    FD8.0
0CA80:  RLCF   x77,W
0CA82:  CLRF   03
0CA84:  ADDLW  81
0CA86:  MOVWF  FE9
0CA88:  MOVLW  01
0CA8A:  ADDWFC 03,W
0CA8C:  MOVWF  FEA
0CA8E:  MOVFF  FEC,57D
0CA92:  MOVF   FED,F
0CA94:  MOVFF  FEF,57C
0CA98:  BCF    FD8.0
0CA9A:  RLCF   x77,W
0CA9C:  CLRF   03
0CA9E:  ADDLW  AB
0CAA0:  MOVWF  FE9
0CAA2:  MOVLW  01
0CAA4:  ADDWFC 03,W
0CAA6:  MOVWF  FEA
0CAA8:  MOVFF  FEC,57F
0CAAC:  MOVF   FED,F
0CAAE:  MOVFF  FEF,57E
0CAB2:  MOVFF  578,581
0CAB6:  MOVFF  57B,583
0CABA:  MOVFF  57A,582
0CABE:  MOVFF  57D,585
0CAC2:  MOVFF  57C,584
0CAC6:  MOVFF  57F,587
0CACA:  MOVFF  57E,586
0CACE:  MOVLB  0
0CAD0:  CALL   851C
....................                     motor_run_z(z[i], 19); 
0CAD4:  BCF    FD8.0
0CAD6:  MOVLB  5
0CAD8:  RLCF   x77,W
0CADA:  CLRF   03
0CADC:  ADDLW  83
0CADE:  MOVWF  FE9
0CAE0:  MOVLW  00
0CAE2:  ADDWFC 03,W
0CAE4:  MOVWF  FEA
0CAE6:  MOVFF  FEC,579
0CAEA:  MOVF   FED,F
0CAEC:  MOVFF  FEF,578
0CAF0:  CLRF   x7F
0CAF2:  CLRF   x7E
0CAF4:  MOVFF  579,57D
0CAF8:  MOVFF  578,57C
0CAFC:  MOVLW  13
0CAFE:  MOVWF  x80
0CB00:  MOVLB  0
0CB02:  CALL   63C2
....................                     while ((run_flg_z)); 
0CB06:  MOVLB  3
0CB08:  BTFSC  xB7.2
0CB0A:  BRA    CB08
....................                     delay_ms(t_wait[i]); 
0CB0C:  BCF    FD8.0
0CB0E:  MOVLB  5
0CB10:  RLCF   x77,W
0CB12:  CLRF   03
0CB14:  ADDLW  D7
0CB16:  MOVWF  FE9
0CB18:  MOVLW  00
0CB1A:  ADDWFC 03,W
0CB1C:  MOVWF  FEA
0CB1E:  MOVFF  FEC,579
0CB22:  MOVF   FED,F
0CB24:  MOVFF  FEF,578
0CB28:  MOVFF  579,57A
0CB2C:  INCF   x7A,F
0CB2E:  DECF   x7A,F
0CB30:  BTFSC  FD8.2
0CB32:  BRA    CB40
0CB34:  SETF   x91
0CB36:  MOVLB  0
0CB38:  CALL   2954
0CB3C:  MOVLB  5
0CB3E:  BRA    CB2E
0CB40:  MOVFF  578,591
0CB44:  MOVLB  0
0CB46:  CALL   2954
....................                     if (limpar[i] == 1){ 
0CB4A:  BCF    FD8.0
0CB4C:  MOVLB  5
0CB4E:  RLCF   x77,W
0CB50:  CLRF   03
0CB52:  ADDLW  D5
0CB54:  MOVWF  FE9
0CB56:  MOVLW  01
0CB58:  ADDWFC 03,W
0CB5A:  MOVWF  FEA
0CB5C:  MOVFF  FEC,579
0CB60:  MOVF   FED,F
0CB62:  MOVFF  FEF,578
0CB66:  DECFSZ x78,W
0CB68:  BRA    CBEA
0CB6A:  MOVF   x79,F
0CB6C:  BNZ   CBEA
....................                         motor_run_z(0, 19); 
0CB6E:  CLRF   x7F
0CB70:  CLRF   x7E
0CB72:  CLRF   x7D
0CB74:  CLRF   x7C
0CB76:  MOVLW  13
0CB78:  MOVWF  x80
0CB7A:  MOVLB  0
0CB7C:  CALL   63C2
....................                         while ((run_flg_z)); 
0CB80:  MOVLB  3
0CB82:  BTFSC  xB7.2
0CB84:  BRA    CB82
....................                         desce_ferros(3); 
0CB86:  MOVLW  03
0CB88:  MOVLB  5
0CB8A:  MOVWF  x7C
0CB8C:  MOVLB  0
0CB8E:  CALL   7A24
....................                         delay_ms(200); 
0CB92:  MOVLW  C8
0CB94:  MOVLB  5
0CB96:  MOVWF  x91
0CB98:  MOVLB  0
0CB9A:  CALL   2954
....................                         aciona_saida(LIMPA_BICO1); 
0CB9E:  MOVLB  5
0CBA0:  CLRF   x8F
0CBA2:  MOVLW  08
0CBA4:  MOVWF  x8E
0CBA6:  MOVLB  0
0CBA8:  CALL   2E1E
....................                         aciona_saida(LIMPA_BICO2); 
0CBAC:  MOVLB  5
0CBAE:  CLRF   x8F
0CBB0:  MOVLW  09
0CBB2:  MOVWF  x8E
0CBB4:  MOVLB  0
0CBB6:  CALL   2E1E
....................                         delay_ms(125); 
0CBBA:  MOVLW  7D
0CBBC:  MOVLB  5
0CBBE:  MOVWF  x91
0CBC0:  MOVLB  0
0CBC2:  CALL   2954
....................                         desaciona_saida(LIMPA_BICO1); 
0CBC6:  MOVLB  5
0CBC8:  CLRF   x8F
0CBCA:  MOVLW  08
0CBCC:  MOVWF  x8E
0CBCE:  MOVLB  0
0CBD0:  CALL   2DDC
....................                         desaciona_saida(LIMPA_BICO2); 
0CBD4:  MOVLB  5
0CBD6:  CLRF   x8F
0CBD8:  MOVLW  09
0CBDA:  MOVWF  x8E
0CBDC:  MOVLB  0
0CBDE:  CALL   2DDC
....................                         sobe_ferros(); 
0CBE2:  CALL   7A06
....................                     } else { 
0CBE6:  BRA    CC08
0CBE8:  MOVLB  5
....................                         motor_run_z(270, 19); 
0CBEA:  CLRF   x7F
0CBEC:  CLRF   x7E
0CBEE:  MOVLW  01
0CBF0:  MOVWF  x7D
0CBF2:  MOVLW  0E
0CBF4:  MOVWF  x7C
0CBF6:  MOVLW  13
0CBF8:  MOVWF  x80
0CBFA:  MOVLB  0
0CBFC:  CALL   63C2
....................                         while ((run_flg_z)); 
0CC00:  MOVLB  3
0CC02:  BTFSC  xB7.2
0CC04:  BRA    CC02
0CC06:  MOVLB  0
....................                     }                   
....................                 break; 
0CC08:  MOVLB  5
0CC0A:  BRA    D0DA
....................                 case 1:                     
....................                     motor_run_y(y[i], 19); 
0CC0C:  BCF    FD8.0
0CC0E:  MOVLB  5
0CC10:  RLCF   x77,W
0CC12:  CLRF   03
0CC14:  ADDLW  59
0CC16:  MOVWF  FE9
0CC18:  MOVLW  00
0CC1A:  ADDWFC 03,W
0CC1C:  MOVWF  FEA
0CC1E:  MOVFF  FEC,579
0CC22:  MOVF   FED,F
0CC24:  MOVFF  FEF,578
0CC28:  CLRF   x7F
0CC2A:  CLRF   x7E
0CC2C:  MOVFF  579,57D
0CC30:  MOVFF  578,57C
0CC34:  MOVLW  13
0CC36:  MOVWF  x80
0CC38:  MOVLB  0
0CC3A:  CALL   6622
....................                     while ((run_flg_y)); 
0CC3E:  MOVLB  2
0CC40:  BTFSC  x0B.7
0CC42:  BRA    CC40
....................                     motor_run_x(x[i], 19); 
0CC44:  BCF    FD8.0
0CC46:  MOVLB  5
0CC48:  RLCF   x77,W
0CC4A:  CLRF   03
0CC4C:  ADDLW  2F
0CC4E:  MOVWF  FE9
0CC50:  MOVLW  00
0CC52:  ADDWFC 03,W
0CC54:  MOVWF  FEA
0CC56:  MOVFF  FEC,579
0CC5A:  MOVF   FED,F
0CC5C:  MOVFF  FEF,578
0CC60:  CLRF   x7F
0CC62:  CLRF   x7E
0CC64:  MOVFF  579,57D
0CC68:  MOVFF  578,57C
0CC6C:  MOVLW  13
0CC6E:  MOVWF  x80
0CC70:  MOVLB  0
0CC72:  CALL   55F6
....................                     while ((run_flg_x)); 
0CC76:  MOVLB  2
0CC78:  BTFSC  x0B.5
0CC7A:  BRA    CC78
....................                     desce_ferros(numeroFerros[i]); 
0CC7C:  BCF    FD8.0
0CC7E:  MOVLB  5
0CC80:  RLCF   x77,W
0CC82:  CLRF   03
0CC84:  ADDLW  57
0CC86:  MOVWF  FE9
0CC88:  MOVLW  01
0CC8A:  ADDWFC 03,W
0CC8C:  MOVWF  FEA
0CC8E:  MOVFF  FEC,579
0CC92:  MOVF   FED,F
0CC94:  MOVFF  FEF,578
0CC98:  MOVFF  578,57C
0CC9C:  MOVLB  0
0CC9E:  CALL   7A24
....................                     ligar_alimentador_solda(numeroFerros[i],t_solda[i],t_solda2[i],t_solda3[i]); 
0CCA2:  BCF    FD8.0
0CCA4:  MOVLB  5
0CCA6:  RLCF   x77,W
0CCA8:  CLRF   03
0CCAA:  ADDLW  57
0CCAC:  MOVWF  FE9
0CCAE:  MOVLW  01
0CCB0:  ADDWFC 03,W
0CCB2:  MOVWF  FEA
0CCB4:  MOVFF  FEC,579
0CCB8:  MOVF   FED,F
0CCBA:  MOVFF  FEF,578
0CCBE:  BCF    FD8.0
0CCC0:  RLCF   x77,W
0CCC2:  CLRF   03
0CCC4:  ADDLW  AD
0CCC6:  MOVWF  FE9
0CCC8:  MOVLW  00
0CCCA:  ADDWFC 03,W
0CCCC:  MOVWF  FEA
0CCCE:  MOVFF  FEC,57B
0CCD2:  MOVF   FED,F
0CCD4:  MOVFF  FEF,57A
0CCD8:  BCF    FD8.0
0CCDA:  RLCF   x77,W
0CCDC:  CLRF   03
0CCDE:  ADDLW  81
0CCE0:  MOVWF  FE9
0CCE2:  MOVLW  01
0CCE4:  ADDWFC 03,W
0CCE6:  MOVWF  FEA
0CCE8:  MOVFF  FEC,57D
0CCEC:  MOVF   FED,F
0CCEE:  MOVFF  FEF,57C
0CCF2:  BCF    FD8.0
0CCF4:  RLCF   x77,W
0CCF6:  CLRF   03
0CCF8:  ADDLW  AB
0CCFA:  MOVWF  FE9
0CCFC:  MOVLW  01
0CCFE:  ADDWFC 03,W
0CD00:  MOVWF  FEA
0CD02:  MOVFF  FEC,57F
0CD06:  MOVF   FED,F
0CD08:  MOVFF  FEF,57E
0CD0C:  MOVFF  578,581
0CD10:  MOVFF  57B,583
0CD14:  MOVFF  57A,582
0CD18:  MOVFF  57D,585
0CD1C:  MOVFF  57C,584
0CD20:  MOVFF  57F,587
0CD24:  MOVFF  57E,586
0CD28:  MOVLB  0
0CD2A:  CALL   851C
....................                     motor_run_z(z[i], 19); 
0CD2E:  BCF    FD8.0
0CD30:  MOVLB  5
0CD32:  RLCF   x77,W
0CD34:  CLRF   03
0CD36:  ADDLW  83
0CD38:  MOVWF  FE9
0CD3A:  MOVLW  00
0CD3C:  ADDWFC 03,W
0CD3E:  MOVWF  FEA
0CD40:  MOVFF  FEC,579
0CD44:  MOVF   FED,F
0CD46:  MOVFF  FEF,578
0CD4A:  CLRF   x7F
0CD4C:  CLRF   x7E
0CD4E:  MOVFF  579,57D
0CD52:  MOVFF  578,57C
0CD56:  MOVLW  13
0CD58:  MOVWF  x80
0CD5A:  MOVLB  0
0CD5C:  CALL   63C2
....................                     while ((run_flg_z)); 
0CD60:  MOVLB  3
0CD62:  BTFSC  xB7.2
0CD64:  BRA    CD62
....................                     delay_ms(t_wait[i]); 
0CD66:  BCF    FD8.0
0CD68:  MOVLB  5
0CD6A:  RLCF   x77,W
0CD6C:  CLRF   03
0CD6E:  ADDLW  D7
0CD70:  MOVWF  FE9
0CD72:  MOVLW  00
0CD74:  ADDWFC 03,W
0CD76:  MOVWF  FEA
0CD78:  MOVFF  FEC,579
0CD7C:  MOVF   FED,F
0CD7E:  MOVFF  FEF,578
0CD82:  MOVFF  579,57A
0CD86:  INCF   x7A,F
0CD88:  DECF   x7A,F
0CD8A:  BTFSC  FD8.2
0CD8C:  BRA    CD9A
0CD8E:  SETF   x91
0CD90:  MOVLB  0
0CD92:  CALL   2954
0CD96:  MOVLB  5
0CD98:  BRA    CD88
0CD9A:  MOVFF  578,591
0CD9E:  MOVLB  0
0CDA0:  CALL   2954
....................                     motor_run_z(z[i]-8, 19); 
0CDA4:  BCF    FD8.0
0CDA6:  MOVLB  5
0CDA8:  RLCF   x77,W
0CDAA:  CLRF   03
0CDAC:  ADDLW  83
0CDAE:  MOVWF  FE9
0CDB0:  MOVLW  00
0CDB2:  ADDWFC 03,W
0CDB4:  MOVWF  FEA
0CDB6:  MOVFF  FEC,579
0CDBA:  MOVF   FED,F
0CDBC:  MOVFF  FEF,578
0CDC0:  MOVLW  08
0CDC2:  SUBWF  x78,F
0CDC4:  MOVLW  00
0CDC6:  SUBWFB x79,F
0CDC8:  CLRF   x7F
0CDCA:  CLRF   x7E
0CDCC:  MOVFF  579,57D
0CDD0:  MOVFF  578,57C
0CDD4:  MOVLW  13
0CDD6:  MOVWF  x80
0CDD8:  MOVLB  0
0CDDA:  CALL   63C2
....................                     while ((run_flg_z)); 
0CDDE:  MOVLB  3
0CDE0:  BTFSC  xB7.2
0CDE2:  BRA    CDE0
....................                     motor_run_x(x[i]-21, 19); 
0CDE4:  BCF    FD8.0
0CDE6:  MOVLB  5
0CDE8:  RLCF   x77,W
0CDEA:  CLRF   03
0CDEC:  ADDLW  2F
0CDEE:  MOVWF  FE9
0CDF0:  MOVLW  00
0CDF2:  ADDWFC 03,W
0CDF4:  MOVWF  FEA
0CDF6:  MOVFF  FEC,579
0CDFA:  MOVF   FED,F
0CDFC:  MOVFF  FEF,578
0CE00:  MOVLW  15
0CE02:  SUBWF  x78,F
0CE04:  MOVLW  00
0CE06:  SUBWFB x79,F
0CE08:  CLRF   x7F
0CE0A:  CLRF   x7E
0CE0C:  MOVFF  579,57D
0CE10:  MOVFF  578,57C
0CE14:  MOVLW  13
0CE16:  MOVWF  x80
0CE18:  MOVLB  0
0CE1A:  CALL   55F6
....................                     while ((run_flg_x)); 
0CE1E:  MOVLB  2
0CE20:  BTFSC  x0B.5
0CE22:  BRA    CE20
....................                     motor_run_z(z[i], 19); 
0CE24:  BCF    FD8.0
0CE26:  MOVLB  5
0CE28:  RLCF   x77,W
0CE2A:  CLRF   03
0CE2C:  ADDLW  83
0CE2E:  MOVWF  FE9
0CE30:  MOVLW  00
0CE32:  ADDWFC 03,W
0CE34:  MOVWF  FEA
0CE36:  MOVFF  FEC,579
0CE3A:  MOVF   FED,F
0CE3C:  MOVFF  FEF,578
0CE40:  CLRF   x7F
0CE42:  CLRF   x7E
0CE44:  MOVFF  579,57D
0CE48:  MOVFF  578,57C
0CE4C:  MOVLW  13
0CE4E:  MOVWF  x80
0CE50:  MOVLB  0
0CE52:  CALL   63C2
....................                     while ((run_flg_z)); 
0CE56:  MOVLB  3
0CE58:  BTFSC  xB7.2
0CE5A:  BRA    CE58
....................                     delay_ms(t_wait[i]);   
0CE5C:  BCF    FD8.0
0CE5E:  MOVLB  5
0CE60:  RLCF   x77,W
0CE62:  CLRF   03
0CE64:  ADDLW  D7
0CE66:  MOVWF  FE9
0CE68:  MOVLW  00
0CE6A:  ADDWFC 03,W
0CE6C:  MOVWF  FEA
0CE6E:  MOVFF  FEC,579
0CE72:  MOVF   FED,F
0CE74:  MOVFF  FEF,578
0CE78:  MOVFF  579,57A
0CE7C:  INCF   x7A,F
0CE7E:  DECF   x7A,F
0CE80:  BTFSC  FD8.2
0CE82:  BRA    CE90
0CE84:  SETF   x91
0CE86:  MOVLB  0
0CE88:  CALL   2954
0CE8C:  MOVLB  5
0CE8E:  BRA    CE7E
0CE90:  MOVFF  578,591
0CE94:  MOVLB  0
0CE96:  CALL   2954
....................                     motor_run_z(z[i]-8, 19); 
0CE9A:  BCF    FD8.0
0CE9C:  MOVLB  5
0CE9E:  RLCF   x77,W
0CEA0:  CLRF   03
0CEA2:  ADDLW  83
0CEA4:  MOVWF  FE9
0CEA6:  MOVLW  00
0CEA8:  ADDWFC 03,W
0CEAA:  MOVWF  FEA
0CEAC:  MOVFF  FEC,579
0CEB0:  MOVF   FED,F
0CEB2:  MOVFF  FEF,578
0CEB6:  MOVLW  08
0CEB8:  SUBWF  x78,F
0CEBA:  MOVLW  00
0CEBC:  SUBWFB x79,F
0CEBE:  CLRF   x7F
0CEC0:  CLRF   x7E
0CEC2:  MOVFF  579,57D
0CEC6:  MOVFF  578,57C
0CECA:  MOVLW  13
0CECC:  MOVWF  x80
0CECE:  MOVLB  0
0CED0:  CALL   63C2
....................                     while ((run_flg_z)); 
0CED4:  MOVLB  3
0CED6:  BTFSC  xB7.2
0CED8:  BRA    CED6
....................                     motor_run_x(x[i]-42, 19); 
0CEDA:  BCF    FD8.0
0CEDC:  MOVLB  5
0CEDE:  RLCF   x77,W
0CEE0:  CLRF   03
0CEE2:  ADDLW  2F
0CEE4:  MOVWF  FE9
0CEE6:  MOVLW  00
0CEE8:  ADDWFC 03,W
0CEEA:  MOVWF  FEA
0CEEC:  MOVFF  FEC,579
0CEF0:  MOVF   FED,F
0CEF2:  MOVFF  FEF,578
0CEF6:  MOVLW  2A
0CEF8:  SUBWF  x78,F
0CEFA:  MOVLW  00
0CEFC:  SUBWFB x79,F
0CEFE:  CLRF   x7F
0CF00:  CLRF   x7E
0CF02:  MOVFF  579,57D
0CF06:  MOVFF  578,57C
0CF0A:  MOVLW  13
0CF0C:  MOVWF  x80
0CF0E:  MOVLB  0
0CF10:  CALL   55F6
....................                     while ((run_flg_x)); 
0CF14:  MOVLB  2
0CF16:  BTFSC  x0B.5
0CF18:  BRA    CF16
....................                     motor_run_z(z[i], 19); 
0CF1A:  BCF    FD8.0
0CF1C:  MOVLB  5
0CF1E:  RLCF   x77,W
0CF20:  CLRF   03
0CF22:  ADDLW  83
0CF24:  MOVWF  FE9
0CF26:  MOVLW  00
0CF28:  ADDWFC 03,W
0CF2A:  MOVWF  FEA
0CF2C:  MOVFF  FEC,579
0CF30:  MOVF   FED,F
0CF32:  MOVFF  FEF,578
0CF36:  CLRF   x7F
0CF38:  CLRF   x7E
0CF3A:  MOVFF  579,57D
0CF3E:  MOVFF  578,57C
0CF42:  MOVLW  13
0CF44:  MOVWF  x80
0CF46:  MOVLB  0
0CF48:  CALL   63C2
....................                     while ((run_flg_z)); 
0CF4C:  MOVLB  3
0CF4E:  BTFSC  xB7.2
0CF50:  BRA    CF4E
....................                     delay_ms(t_wait[i]); 
0CF52:  BCF    FD8.0
0CF54:  MOVLB  5
0CF56:  RLCF   x77,W
0CF58:  CLRF   03
0CF5A:  ADDLW  D7
0CF5C:  MOVWF  FE9
0CF5E:  MOVLW  00
0CF60:  ADDWFC 03,W
0CF62:  MOVWF  FEA
0CF64:  MOVFF  FEC,579
0CF68:  MOVF   FED,F
0CF6A:  MOVFF  FEF,578
0CF6E:  MOVFF  579,57A
0CF72:  INCF   x7A,F
0CF74:  DECF   x7A,F
0CF76:  BTFSC  FD8.2
0CF78:  BRA    CF86
0CF7A:  SETF   x91
0CF7C:  MOVLB  0
0CF7E:  CALL   2954
0CF82:  MOVLB  5
0CF84:  BRA    CF74
0CF86:  MOVFF  578,591
0CF8A:  MOVLB  0
0CF8C:  CALL   2954
....................                     motor_run_z(z[i]-8, 19); 
0CF90:  BCF    FD8.0
0CF92:  MOVLB  5
0CF94:  RLCF   x77,W
0CF96:  CLRF   03
0CF98:  ADDLW  83
0CF9A:  MOVWF  FE9
0CF9C:  MOVLW  00
0CF9E:  ADDWFC 03,W
0CFA0:  MOVWF  FEA
0CFA2:  MOVFF  FEC,579
0CFA6:  MOVF   FED,F
0CFA8:  MOVFF  FEF,578
0CFAC:  MOVLW  08
0CFAE:  SUBWF  x78,F
0CFB0:  MOVLW  00
0CFB2:  SUBWFB x79,F
0CFB4:  CLRF   x7F
0CFB6:  CLRF   x7E
0CFB8:  MOVFF  579,57D
0CFBC:  MOVFF  578,57C
0CFC0:  MOVLW  13
0CFC2:  MOVWF  x80
0CFC4:  MOVLB  0
0CFC6:  CALL   63C2
....................                     while ((run_flg_y)); 
0CFCA:  MOVLB  2
0CFCC:  BTFSC  x0B.7
0CFCE:  BRA    CFCC
....................                     motor_run_x(x[i]+55, 19); 
0CFD0:  BCF    FD8.0
0CFD2:  MOVLB  5
0CFD4:  RLCF   x77,W
0CFD6:  CLRF   03
0CFD8:  ADDLW  2F
0CFDA:  MOVWF  FE9
0CFDC:  MOVLW  00
0CFDE:  ADDWFC 03,W
0CFE0:  MOVWF  FEA
0CFE2:  MOVFF  FEC,579
0CFE6:  MOVF   FED,F
0CFE8:  MOVFF  FEF,578
0CFEC:  MOVLW  37
0CFEE:  ADDWF  x78,F
0CFF0:  MOVLW  00
0CFF2:  ADDWFC x79,F
0CFF4:  CLRF   x7F
0CFF6:  CLRF   x7E
0CFF8:  MOVFF  579,57D
0CFFC:  MOVFF  578,57C
0D000:  MOVLW  13
0D002:  MOVWF  x80
0D004:  MOVLB  0
0D006:  CALL   55F6
....................                     while ((run_flg_x || run_flg_z)); 
0D00A:  MOVLB  2
0D00C:  BTFSC  x0B.5
0D00E:  BRA    D00C
0D010:  MOVLB  3
0D012:  BTFSS  xB7.2
0D014:  BRA    D01A
0D016:  MOVLB  0
0D018:  BRA    D00A
....................                     if (limpar[i] == 1){ 
0D01A:  BCF    FD8.0
0D01C:  MOVLB  5
0D01E:  RLCF   x77,W
0D020:  CLRF   03
0D022:  ADDLW  D5
0D024:  MOVWF  FE9
0D026:  MOVLW  01
0D028:  ADDWFC 03,W
0D02A:  MOVWF  FEA
0D02C:  MOVFF  FEC,579
0D030:  MOVF   FED,F
0D032:  MOVFF  FEF,578
0D036:  DECFSZ x78,W
0D038:  BRA    D0BA
0D03A:  MOVF   x79,F
0D03C:  BNZ   D0BA
....................                         motor_run_z(0, 19); 
0D03E:  CLRF   x7F
0D040:  CLRF   x7E
0D042:  CLRF   x7D
0D044:  CLRF   x7C
0D046:  MOVLW  13
0D048:  MOVWF  x80
0D04A:  MOVLB  0
0D04C:  CALL   63C2
....................                         while ((run_flg_z)); 
0D050:  MOVLB  3
0D052:  BTFSC  xB7.2
0D054:  BRA    D052
....................                         desce_ferros(3); 
0D056:  MOVLW  03
0D058:  MOVLB  5
0D05A:  MOVWF  x7C
0D05C:  MOVLB  0
0D05E:  CALL   7A24
....................                         delay_ms(200); 
0D062:  MOVLW  C8
0D064:  MOVLB  5
0D066:  MOVWF  x91
0D068:  MOVLB  0
0D06A:  CALL   2954
....................                         aciona_saida(LIMPA_BICO1); 
0D06E:  MOVLB  5
0D070:  CLRF   x8F
0D072:  MOVLW  08
0D074:  MOVWF  x8E
0D076:  MOVLB  0
0D078:  CALL   2E1E
....................                         aciona_saida(LIMPA_BICO2); 
0D07C:  MOVLB  5
0D07E:  CLRF   x8F
0D080:  MOVLW  09
0D082:  MOVWF  x8E
0D084:  MOVLB  0
0D086:  CALL   2E1E
....................                         delay_ms(125); 
0D08A:  MOVLW  7D
0D08C:  MOVLB  5
0D08E:  MOVWF  x91
0D090:  MOVLB  0
0D092:  CALL   2954
....................                         desaciona_saida(LIMPA_BICO1); 
0D096:  MOVLB  5
0D098:  CLRF   x8F
0D09A:  MOVLW  08
0D09C:  MOVWF  x8E
0D09E:  MOVLB  0
0D0A0:  CALL   2DDC
....................                         desaciona_saida(LIMPA_BICO2); 
0D0A4:  MOVLB  5
0D0A6:  CLRF   x8F
0D0A8:  MOVLW  09
0D0AA:  MOVWF  x8E
0D0AC:  MOVLB  0
0D0AE:  CALL   2DDC
....................                         sobe_ferros(); 
0D0B2:  CALL   7A06
....................                     } else { 
0D0B6:  BRA    D0D8
0D0B8:  MOVLB  5
....................                         motor_run_z(270, 19); 
0D0BA:  CLRF   x7F
0D0BC:  CLRF   x7E
0D0BE:  MOVLW  01
0D0C0:  MOVWF  x7D
0D0C2:  MOVLW  0E
0D0C4:  MOVWF  x7C
0D0C6:  MOVLW  13
0D0C8:  MOVWF  x80
0D0CA:  MOVLB  0
0D0CC:  CALL   63C2
....................                         while ((run_flg_z)); 
0D0D0:  MOVLB  3
0D0D2:  BTFSC  xB7.2
0D0D4:  BRA    D0D2
0D0D6:  MOVLB  0
....................                     }             
....................                 break; 
0D0D8:  MOVLB  5
....................             } 
....................         } 
....................         sobe_ferros(); 
0D0DA:  MOVLB  0
0D0DC:  CALL   7A06
0D0E0:  MOVLB  5
0D0E2:  INCF   x77,F
0D0E4:  BRA    C926
....................     } 
0D0E6:  MOVLB  0
0D0E8:  GOTO   D448 (RETURN)
.................... } 
....................  
.................... #include "Modelos_maq_1.c" 
.................... long int tamPrograma = 358; 
....................  
.................... void ler_modelo_memoria(long int modeloSelecionado){ 
*
05DCA:  MOVLB  5
05DCC:  CLRF   x77
05DCE:  CLRF   x76
05DD0:  CLRF   x79
05DD2:  CLRF   x78
05DD4:  MOVLW  01
05DD6:  SUBWF  x74,W
05DD8:  MOVWF  x7E
05DDA:  MOVLW  00
05DDC:  SUBWFB x75,W
05DDE:  MOVWF  x7F
05DE0:  MOVWF  x81
05DE2:  MOVFF  57E,580
05DE6:  MOVFF  573,583
05DEA:  MOVFF  572,582
05DEE:  MOVLB  0
05DF0:  RCALL  5DA8
05DF2:  MOVFF  02,57B
05DF6:  MOVFF  01,57A
....................     long int i = 0; 
....................     long int j = 0; 
....................     long int endInicial = (modeloSelecionado - 1)* tamPrograma; 
....................     pontos_no_modelo = read_ext_eeprom(endInicial); 
05DFA:  MOVFF  57B,585
05DFE:  MOVFF  57A,584
05E02:  CALL   2C1E
05E06:  MOVFF  02,12C
05E0A:  MOVFF  01,12B
....................     endInicial++; 
05E0E:  MOVLB  5
05E10:  INCF   x7A,F
05E12:  BTFSC  FD8.2
05E14:  INCF   x7B,F
....................     for(i = endInicial; i < (endInicial + tamPrograma) -1; i = i + 17) 
05E16:  MOVFF  57B,577
05E1A:  MOVFF  57A,576
05E1E:  MOVF   x72,W
05E20:  ADDWF  x7A,W
05E22:  MOVWF  x7E
05E24:  MOVF   x73,W
05E26:  ADDWFC x7B,W
05E28:  MOVWF  x7F
05E2A:  MOVLW  01
05E2C:  SUBWF  x7E,W
05E2E:  MOVWF  00
05E30:  MOVLW  00
05E32:  SUBWFB x7F,W
05E34:  MOVWF  03
05E36:  MOVFF  00,01
05E3A:  MOVF   x77,W
05E3C:  SUBWF  03,W
05E3E:  BTFSS  FD8.0
05E40:  BRA    6244
05E42:  BNZ   5E4C
05E44:  MOVF   01,W
05E46:  SUBWF  x76,W
05E48:  BTFSC  FD8.0
05E4A:  BRA    6244
....................     { 
....................         if (i != 248){ 
05E4C:  MOVF   x76,W
05E4E:  SUBLW  F8
05E50:  BNZ   5E58
05E52:  MOVF   x77,F
05E54:  BTFSC  FD8.2
05E56:  BRA    623A
....................             x[j] = make16(read_ext_eeprom(i),read_ext_eeprom(i+1)); 
05E58:  BCF    FD8.0
05E5A:  RLCF   x78,W
05E5C:  MOVWF  02
05E5E:  RLCF   x79,W
05E60:  MOVWF  03
05E62:  MOVF   02,W
05E64:  ADDLW  2F
05E66:  MOVWF  01
05E68:  MOVLW  00
05E6A:  ADDWFC 03,F
05E6C:  MOVFF  01,57E
05E70:  MOVFF  03,57F
05E74:  MOVFF  577,585
05E78:  MOVFF  576,584
05E7C:  MOVLB  0
05E7E:  CALL   2C1E
05E82:  MOVFF  02,581
05E86:  MOVFF  01,580
05E8A:  MOVLW  01
05E8C:  MOVLB  5
05E8E:  ADDWF  x76,W
05E90:  MOVWF  x82
05E92:  MOVLW  00
05E94:  ADDWFC x77,W
05E96:  MOVWF  x83
05E98:  MOVWF  x85
05E9A:  MOVFF  582,584
05E9E:  MOVLB  0
05EA0:  CALL   2C1E
05EA4:  MOVFF  57F,FEA
05EA8:  MOVFF  57E,FE9
05EAC:  MOVFF  580,FEC
05EB0:  MOVF   FED,F
05EB2:  MOVFF  01,FEF
....................             y[j] = make16(read_ext_eeprom(i+2),read_ext_eeprom(i+3)); 
05EB6:  BCF    FD8.0
05EB8:  MOVLB  5
05EBA:  RLCF   x78,W
05EBC:  MOVWF  02
05EBE:  RLCF   x79,W
05EC0:  MOVWF  03
05EC2:  MOVF   02,W
05EC4:  ADDLW  59
05EC6:  MOVWF  01
05EC8:  MOVLW  00
05ECA:  ADDWFC 03,F
05ECC:  MOVFF  01,57E
05ED0:  MOVFF  03,57F
05ED4:  MOVLW  02
05ED6:  ADDWF  x76,W
05ED8:  MOVWF  x80
05EDA:  MOVLW  00
05EDC:  ADDWFC x77,W
05EDE:  MOVWF  x81
05EE0:  MOVWF  x85
05EE2:  MOVFF  580,584
05EE6:  MOVLB  0
05EE8:  CALL   2C1E
05EEC:  MOVFF  02,581
05EF0:  MOVFF  01,580
05EF4:  MOVLW  03
05EF6:  MOVLB  5
05EF8:  ADDWF  x76,W
05EFA:  MOVWF  x82
05EFC:  MOVLW  00
05EFE:  ADDWFC x77,W
05F00:  MOVWF  x83
05F02:  MOVWF  x85
05F04:  MOVFF  582,584
05F08:  MOVLB  0
05F0A:  CALL   2C1E
05F0E:  MOVFF  57F,FEA
05F12:  MOVFF  57E,FE9
05F16:  MOVFF  580,FEC
05F1A:  MOVF   FED,F
05F1C:  MOVFF  01,FEF
....................             z[j] = make16(read_ext_eeprom(i+4),read_ext_eeprom(i+5)); 
05F20:  BCF    FD8.0
05F22:  MOVLB  5
05F24:  RLCF   x78,W
05F26:  MOVWF  02
05F28:  RLCF   x79,W
05F2A:  MOVWF  03
05F2C:  MOVF   02,W
05F2E:  ADDLW  83
05F30:  MOVWF  01
05F32:  MOVLW  00
05F34:  ADDWFC 03,F
05F36:  MOVFF  01,57E
05F3A:  MOVFF  03,57F
05F3E:  MOVLW  04
05F40:  ADDWF  x76,W
05F42:  MOVWF  x80
05F44:  MOVLW  00
05F46:  ADDWFC x77,W
05F48:  MOVWF  x81
05F4A:  MOVWF  x85
05F4C:  MOVFF  580,584
05F50:  MOVLB  0
05F52:  CALL   2C1E
05F56:  MOVFF  02,581
05F5A:  MOVFF  01,580
05F5E:  MOVLW  05
05F60:  MOVLB  5
05F62:  ADDWF  x76,W
05F64:  MOVWF  x82
05F66:  MOVLW  00
05F68:  ADDWFC x77,W
05F6A:  MOVWF  x83
05F6C:  MOVWF  x85
05F6E:  MOVFF  582,584
05F72:  MOVLB  0
05F74:  CALL   2C1E
05F78:  MOVFF  57F,FEA
05F7C:  MOVFF  57E,FE9
05F80:  MOVFF  580,FEC
05F84:  MOVF   FED,F
05F86:  MOVFF  01,FEF
....................             t_solda[j] = make16(read_ext_eeprom(i+6),read_ext_eeprom(i+7)); 
05F8A:  BCF    FD8.0
05F8C:  MOVLB  5
05F8E:  RLCF   x78,W
05F90:  MOVWF  02
05F92:  RLCF   x79,W
05F94:  MOVWF  03
05F96:  MOVF   02,W
05F98:  ADDLW  AD
05F9A:  MOVWF  01
05F9C:  MOVLW  00
05F9E:  ADDWFC 03,F
05FA0:  MOVFF  01,57E
05FA4:  MOVFF  03,57F
05FA8:  MOVLW  06
05FAA:  ADDWF  x76,W
05FAC:  MOVWF  x80
05FAE:  MOVLW  00
05FB0:  ADDWFC x77,W
05FB2:  MOVWF  x81
05FB4:  MOVWF  x85
05FB6:  MOVFF  580,584
05FBA:  MOVLB  0
05FBC:  CALL   2C1E
05FC0:  MOVFF  02,581
05FC4:  MOVFF  01,580
05FC8:  MOVLW  07
05FCA:  MOVLB  5
05FCC:  ADDWF  x76,W
05FCE:  MOVWF  x82
05FD0:  MOVLW  00
05FD2:  ADDWFC x77,W
05FD4:  MOVWF  x83
05FD6:  MOVWF  x85
05FD8:  MOVFF  582,584
05FDC:  MOVLB  0
05FDE:  CALL   2C1E
05FE2:  MOVFF  57F,FEA
05FE6:  MOVFF  57E,FE9
05FEA:  MOVFF  580,FEC
05FEE:  MOVF   FED,F
05FF0:  MOVFF  01,FEF
....................             t_wait[j] = make16(read_ext_eeprom(i+8),read_ext_eeprom(i+9)); 
05FF4:  BCF    FD8.0
05FF6:  MOVLB  5
05FF8:  RLCF   x78,W
05FFA:  MOVWF  02
05FFC:  RLCF   x79,W
05FFE:  MOVWF  03
06000:  MOVF   02,W
06002:  ADDLW  D7
06004:  MOVWF  01
06006:  MOVLW  00
06008:  ADDWFC 03,F
0600A:  MOVFF  01,57E
0600E:  MOVFF  03,57F
06012:  MOVLW  08
06014:  ADDWF  x76,W
06016:  MOVWF  x80
06018:  MOVLW  00
0601A:  ADDWFC x77,W
0601C:  MOVWF  x81
0601E:  MOVWF  x85
06020:  MOVFF  580,584
06024:  MOVLB  0
06026:  CALL   2C1E
0602A:  MOVFF  02,581
0602E:  MOVFF  01,580
06032:  MOVLW  09
06034:  MOVLB  5
06036:  ADDWF  x76,W
06038:  MOVWF  x82
0603A:  MOVLW  00
0603C:  ADDWFC x77,W
0603E:  MOVWF  x83
06040:  MOVWF  x85
06042:  MOVFF  582,584
06046:  MOVLB  0
06048:  CALL   2C1E
0604C:  MOVFF  57F,FEA
06050:  MOVFF  57E,FE9
06054:  MOVFF  580,FEC
06058:  MOVF   FED,F
0605A:  MOVFF  01,FEF
....................             long int tipoHabilitado = read_ext_eeprom(i+10); 
0605E:  MOVLW  0A
06060:  MOVLB  5
06062:  ADDWF  x76,W
06064:  MOVWF  x7E
06066:  MOVLW  00
06068:  ADDWFC x77,W
0606A:  MOVWF  x7F
0606C:  MOVWF  x85
0606E:  MOVFF  57E,584
06072:  MOVLB  0
06074:  CALL   2C1E
06078:  MOVFF  02,57D
0607C:  MOVFF  01,57C
....................             tipo[j] = (tipoHabilitado & 0x06)>>1; 
06080:  BCF    FD8.0
06082:  MOVLB  5
06084:  RLCF   x78,W
06086:  MOVWF  02
06088:  RLCF   x79,W
0608A:  MOVWF  03
0608C:  MOVF   02,W
0608E:  ADDLW  01
06090:  MOVWF  FE9
06092:  MOVLW  01
06094:  ADDWFC 03,W
06096:  MOVWF  FEA
06098:  MOVF   x7C,W
0609A:  ANDLW  06
0609C:  MOVWF  x80
0609E:  CLRF   x81
060A0:  BCF    FD8.0
060A2:  RRCF   x81,W
060A4:  MOVWF  03
060A6:  RRCF   x80,W
060A8:  MOVWF  FEF
060AA:  MOVFF  03,FEC
....................             habilitado[j] = tipoHabilitado & 0x01; 
060AE:  BCF    FD8.0
060B0:  RLCF   x78,W
060B2:  MOVWF  02
060B4:  RLCF   x79,W
060B6:  MOVWF  03
060B8:  MOVF   02,W
060BA:  ADDLW  2D
060BC:  MOVWF  FE9
060BE:  MOVLW  01
060C0:  ADDWFC 03,W
060C2:  MOVWF  FEA
060C4:  MOVF   x7C,W
060C6:  ANDLW  01
060C8:  CLRF   03
060CA:  MOVWF  FEF
060CC:  MOVFF  03,FEC
....................             numeroFerros[j] = read_ext_eeprom(i+11); 
060D0:  BCF    FD8.0
060D2:  RLCF   x78,W
060D4:  MOVWF  02
060D6:  RLCF   x79,W
060D8:  MOVWF  03
060DA:  MOVF   02,W
060DC:  ADDLW  57
060DE:  MOVWF  01
060E0:  MOVLW  01
060E2:  ADDWFC 03,F
060E4:  MOVFF  01,57E
060E8:  MOVFF  03,57F
060EC:  MOVLW  0B
060EE:  ADDWF  x76,W
060F0:  MOVWF  x80
060F2:  MOVLW  00
060F4:  ADDWFC x77,W
060F6:  MOVWF  x81
060F8:  MOVWF  x85
060FA:  MOVFF  580,584
060FE:  MOVLB  0
06100:  CALL   2C1E
06104:  MOVFF  57F,FEA
06108:  MOVFF  57E,FE9
0610C:  MOVFF  02,FEC
06110:  MOVF   FED,F
06112:  MOVFF  01,FEF
....................             t_solda2[j] = make16(read_ext_eeprom(i+12),read_ext_eeprom(i+13)); 
06116:  BCF    FD8.0
06118:  MOVLB  5
0611A:  RLCF   x78,W
0611C:  MOVWF  02
0611E:  RLCF   x79,W
06120:  MOVWF  03
06122:  MOVF   02,W
06124:  ADDLW  81
06126:  MOVWF  01
06128:  MOVLW  01
0612A:  ADDWFC 03,F
0612C:  MOVFF  01,57E
06130:  MOVFF  03,57F
06134:  MOVLW  0C
06136:  ADDWF  x76,W
06138:  MOVWF  x80
0613A:  MOVLW  00
0613C:  ADDWFC x77,W
0613E:  MOVWF  x81
06140:  MOVWF  x85
06142:  MOVFF  580,584
06146:  MOVLB  0
06148:  CALL   2C1E
0614C:  MOVFF  02,581
06150:  MOVFF  01,580
06154:  MOVLW  0D
06156:  MOVLB  5
06158:  ADDWF  x76,W
0615A:  MOVWF  x82
0615C:  MOVLW  00
0615E:  ADDWFC x77,W
06160:  MOVWF  x83
06162:  MOVWF  x85
06164:  MOVFF  582,584
06168:  MOVLB  0
0616A:  CALL   2C1E
0616E:  MOVFF  57F,FEA
06172:  MOVFF  57E,FE9
06176:  MOVFF  580,FEC
0617A:  MOVF   FED,F
0617C:  MOVFF  01,FEF
....................             t_solda3[j] = make16(read_ext_eeprom(i+14),read_ext_eeprom(i+15)); 
06180:  BCF    FD8.0
06182:  MOVLB  5
06184:  RLCF   x78,W
06186:  MOVWF  02
06188:  RLCF   x79,W
0618A:  MOVWF  03
0618C:  MOVF   02,W
0618E:  ADDLW  AB
06190:  MOVWF  01
06192:  MOVLW  01
06194:  ADDWFC 03,F
06196:  MOVFF  01,57E
0619A:  MOVFF  03,57F
0619E:  MOVLW  0E
061A0:  ADDWF  x76,W
061A2:  MOVWF  x80
061A4:  MOVLW  00
061A6:  ADDWFC x77,W
061A8:  MOVWF  x81
061AA:  MOVWF  x85
061AC:  MOVFF  580,584
061B0:  MOVLB  0
061B2:  CALL   2C1E
061B6:  MOVFF  02,581
061BA:  MOVFF  01,580
061BE:  MOVLW  0F
061C0:  MOVLB  5
061C2:  ADDWF  x76,W
061C4:  MOVWF  x82
061C6:  MOVLW  00
061C8:  ADDWFC x77,W
061CA:  MOVWF  x83
061CC:  MOVWF  x85
061CE:  MOVFF  582,584
061D2:  MOVLB  0
061D4:  CALL   2C1E
061D8:  MOVFF  57F,FEA
061DC:  MOVFF  57E,FE9
061E0:  MOVFF  580,FEC
061E4:  MOVF   FED,F
061E6:  MOVFF  01,FEF
....................             limpar[j] = read_ext_eeprom(i+16); 
061EA:  BCF    FD8.0
061EC:  MOVLB  5
061EE:  RLCF   x78,W
061F0:  MOVWF  02
061F2:  RLCF   x79,W
061F4:  MOVWF  03
061F6:  MOVF   02,W
061F8:  ADDLW  D5
061FA:  MOVWF  01
061FC:  MOVLW  01
061FE:  ADDWFC 03,F
06200:  MOVFF  01,57E
06204:  MOVFF  03,57F
06208:  MOVLW  10
0620A:  ADDWF  x76,W
0620C:  MOVWF  x80
0620E:  MOVLW  00
06210:  ADDWFC x77,W
06212:  MOVWF  x81
06214:  MOVWF  x85
06216:  MOVFF  580,584
0621A:  MOVLB  0
0621C:  CALL   2C1E
06220:  MOVFF  57F,FEA
06224:  MOVFF  57E,FE9
06228:  MOVFF  02,FEC
0622C:  MOVF   FED,F
0622E:  MOVFF  01,FEF
....................             j++; 
06232:  MOVLB  5
06234:  INCF   x78,F
06236:  BTFSC  FD8.2
06238:  INCF   x79,F
....................         } 
0623A:  MOVLW  11
0623C:  ADDWF  x76,F
0623E:  MOVLW  00
06240:  ADDWFC x77,F
06242:  BRA    5E1E
....................     } 
06244:  MOVLB  0
06246:  RETURN 0
.................... } //ler_modelo_memoria(modelo)) 
.................... void escrever_ponto_memoria(long int modeloSelecionado, long int pontoSelecionado){ 
*
07A86:  MOVLW  01
07A88:  MOVLB  5
07A8A:  SUBWF  x75,W
07A8C:  MOVWF  x7B
07A8E:  MOVLW  00
07A90:  SUBWFB x76,W
07A92:  MOVWF  x7C
07A94:  MOVWF  x81
07A96:  MOVFF  57B,580
07A9A:  MOVFF  573,583
07A9E:  MOVFF  572,582
07AA2:  MOVLB  0
07AA4:  CALL   5DA8
07AA8:  MOVFF  02,57C
07AAC:  MOVFF  01,57B
07AB0:  MOVFF  578,581
07AB4:  MOVFF  577,580
07AB8:  MOVLB  5
07ABA:  CLRF   x83
07ABC:  MOVLW  11
07ABE:  MOVWF  x82
07AC0:  MOVLB  0
07AC2:  CALL   5DA8
07AC6:  MOVF   01,W
07AC8:  MOVLB  5
07ACA:  ADDWF  x7B,W
07ACC:  MOVWF  x79
07ACE:  MOVF   02,W
07AD0:  ADDWFC x7C,W
07AD2:  MOVWF  x7A
....................     long int endInicial = ((modeloSelecionado - 1)*tamPrograma) + (pontoSelecionado*17); 
....................     write_ext_eeprom(endInicial+1,((x[pontoSelecionado]&0xff00)>>8));\ 
07AD4:  MOVLW  01
07AD6:  ADDWF  x79,W
07AD8:  MOVWF  x7B
07ADA:  MOVLW  00
07ADC:  ADDWFC x7A,W
07ADE:  MOVWF  x7C
07AE0:  BCF    FD8.0
07AE2:  RLCF   x77,W
07AE4:  MOVWF  02
07AE6:  RLCF   x78,W
07AE8:  MOVWF  03
07AEA:  MOVF   02,W
07AEC:  ADDLW  2F
07AEE:  MOVWF  FE9
07AF0:  MOVLW  00
07AF2:  ADDWFC 03,W
07AF4:  MOVWF  FEA
07AF6:  MOVFF  FEC,57E
07AFA:  MOVF   FED,F
07AFC:  MOVFF  FEF,57D
07B00:  CLRF   x7D
07B02:  MOVFF  57E,57D
07B06:  CLRF   x7E
07B08:  MOVFF  57C,580
07B0C:  MOVFF  57B,57F
07B10:  MOVFF  57E,582
07B14:  MOVFF  57D,581
07B18:  MOVLB  0
07B1A:  CALL   2B00
....................     write_ext_eeprom(endInicial+2,(x[pontoSelecionado]&0x00ff)); 
07B1E:  MOVLW  02
07B20:  MOVLB  5
07B22:  ADDWF  x79,W
07B24:  MOVWF  x7B
07B26:  MOVLW  00
07B28:  ADDWFC x7A,W
07B2A:  MOVWF  x7C
07B2C:  BCF    FD8.0
07B2E:  RLCF   x77,W
07B30:  MOVWF  02
07B32:  RLCF   x78,W
07B34:  MOVWF  03
07B36:  MOVF   02,W
07B38:  ADDLW  2F
07B3A:  MOVWF  FE9
07B3C:  MOVLW  00
07B3E:  ADDWFC 03,W
07B40:  MOVWF  FEA
07B42:  MOVFF  FEC,57E
07B46:  MOVF   FED,F
07B48:  MOVFF  FEF,57D
07B4C:  CLRF   x7E
07B4E:  MOVFF  57C,580
07B52:  MOVFF  57B,57F
07B56:  MOVFF  57E,582
07B5A:  MOVFF  57D,581
07B5E:  MOVLB  0
07B60:  CALL   2B00
....................     write_ext_eeprom(endInicial+3,((y[pontoSelecionado]&0xff00)>>8)); 
07B64:  MOVLW  03
07B66:  MOVLB  5
07B68:  ADDWF  x79,W
07B6A:  MOVWF  x7B
07B6C:  MOVLW  00
07B6E:  ADDWFC x7A,W
07B70:  MOVWF  x7C
07B72:  BCF    FD8.0
07B74:  RLCF   x77,W
07B76:  MOVWF  02
07B78:  RLCF   x78,W
07B7A:  MOVWF  03
07B7C:  MOVF   02,W
07B7E:  ADDLW  59
07B80:  MOVWF  FE9
07B82:  MOVLW  00
07B84:  ADDWFC 03,W
07B86:  MOVWF  FEA
07B88:  MOVFF  FEC,57E
07B8C:  MOVF   FED,F
07B8E:  MOVFF  FEF,57D
07B92:  CLRF   x7D
07B94:  MOVFF  57E,57D
07B98:  CLRF   x7E
07B9A:  MOVFF  57C,580
07B9E:  MOVFF  57B,57F
07BA2:  MOVFF  57E,582
07BA6:  MOVFF  57D,581
07BAA:  MOVLB  0
07BAC:  CALL   2B00
....................     write_ext_eeprom(endInicial+4,(y[pontoSelecionado]&0x00ff)); 
07BB0:  MOVLW  04
07BB2:  MOVLB  5
07BB4:  ADDWF  x79,W
07BB6:  MOVWF  x7B
07BB8:  MOVLW  00
07BBA:  ADDWFC x7A,W
07BBC:  MOVWF  x7C
07BBE:  BCF    FD8.0
07BC0:  RLCF   x77,W
07BC2:  MOVWF  02
07BC4:  RLCF   x78,W
07BC6:  MOVWF  03
07BC8:  MOVF   02,W
07BCA:  ADDLW  59
07BCC:  MOVWF  FE9
07BCE:  MOVLW  00
07BD0:  ADDWFC 03,W
07BD2:  MOVWF  FEA
07BD4:  MOVFF  FEC,57E
07BD8:  MOVF   FED,F
07BDA:  MOVFF  FEF,57D
07BDE:  CLRF   x7E
07BE0:  MOVFF  57C,580
07BE4:  MOVFF  57B,57F
07BE8:  MOVFF  57E,582
07BEC:  MOVFF  57D,581
07BF0:  MOVLB  0
07BF2:  CALL   2B00
....................     write_ext_eeprom(endInicial+5,((z[pontoSelecionado]&0xff00)>>8)); 
07BF6:  MOVLW  05
07BF8:  MOVLB  5
07BFA:  ADDWF  x79,W
07BFC:  MOVWF  x7B
07BFE:  MOVLW  00
07C00:  ADDWFC x7A,W
07C02:  MOVWF  x7C
07C04:  BCF    FD8.0
07C06:  RLCF   x77,W
07C08:  MOVWF  02
07C0A:  RLCF   x78,W
07C0C:  MOVWF  03
07C0E:  MOVF   02,W
07C10:  ADDLW  83
07C12:  MOVWF  FE9
07C14:  MOVLW  00
07C16:  ADDWFC 03,W
07C18:  MOVWF  FEA
07C1A:  MOVFF  FEC,57E
07C1E:  MOVF   FED,F
07C20:  MOVFF  FEF,57D
07C24:  CLRF   x7D
07C26:  MOVFF  57E,57D
07C2A:  CLRF   x7E
07C2C:  MOVFF  57C,580
07C30:  MOVFF  57B,57F
07C34:  MOVFF  57E,582
07C38:  MOVFF  57D,581
07C3C:  MOVLB  0
07C3E:  CALL   2B00
....................     write_ext_eeprom(endInicial+6,(z[pontoSelecionado]&0x00ff)); 
07C42:  MOVLW  06
07C44:  MOVLB  5
07C46:  ADDWF  x79,W
07C48:  MOVWF  x7B
07C4A:  MOVLW  00
07C4C:  ADDWFC x7A,W
07C4E:  MOVWF  x7C
07C50:  BCF    FD8.0
07C52:  RLCF   x77,W
07C54:  MOVWF  02
07C56:  RLCF   x78,W
07C58:  MOVWF  03
07C5A:  MOVF   02,W
07C5C:  ADDLW  83
07C5E:  MOVWF  FE9
07C60:  MOVLW  00
07C62:  ADDWFC 03,W
07C64:  MOVWF  FEA
07C66:  MOVFF  FEC,57E
07C6A:  MOVF   FED,F
07C6C:  MOVFF  FEF,57D
07C70:  CLRF   x7E
07C72:  MOVFF  57C,580
07C76:  MOVFF  57B,57F
07C7A:  MOVFF  57E,582
07C7E:  MOVFF  57D,581
07C82:  MOVLB  0
07C84:  CALL   2B00
....................     write_ext_eeprom(endInicial+7,((t_solda[pontoSelecionado]&0xff00)>>8)); 
07C88:  MOVLW  07
07C8A:  MOVLB  5
07C8C:  ADDWF  x79,W
07C8E:  MOVWF  x7B
07C90:  MOVLW  00
07C92:  ADDWFC x7A,W
07C94:  MOVWF  x7C
07C96:  BCF    FD8.0
07C98:  RLCF   x77,W
07C9A:  MOVWF  02
07C9C:  RLCF   x78,W
07C9E:  MOVWF  03
07CA0:  MOVF   02,W
07CA2:  ADDLW  AD
07CA4:  MOVWF  FE9
07CA6:  MOVLW  00
07CA8:  ADDWFC 03,W
07CAA:  MOVWF  FEA
07CAC:  MOVFF  FEC,57E
07CB0:  MOVF   FED,F
07CB2:  MOVFF  FEF,57D
07CB6:  CLRF   x7D
07CB8:  MOVFF  57E,57D
07CBC:  CLRF   x7E
07CBE:  MOVFF  57C,580
07CC2:  MOVFF  57B,57F
07CC6:  MOVFF  57E,582
07CCA:  MOVFF  57D,581
07CCE:  MOVLB  0
07CD0:  CALL   2B00
....................     write_ext_eeprom(endInicial+8,(t_solda[pontoSelecionado]&0x00ff)); 
07CD4:  MOVLW  08
07CD6:  MOVLB  5
07CD8:  ADDWF  x79,W
07CDA:  MOVWF  x7B
07CDC:  MOVLW  00
07CDE:  ADDWFC x7A,W
07CE0:  MOVWF  x7C
07CE2:  BCF    FD8.0
07CE4:  RLCF   x77,W
07CE6:  MOVWF  02
07CE8:  RLCF   x78,W
07CEA:  MOVWF  03
07CEC:  MOVF   02,W
07CEE:  ADDLW  AD
07CF0:  MOVWF  FE9
07CF2:  MOVLW  00
07CF4:  ADDWFC 03,W
07CF6:  MOVWF  FEA
07CF8:  MOVFF  FEC,57E
07CFC:  MOVF   FED,F
07CFE:  MOVFF  FEF,57D
07D02:  CLRF   x7E
07D04:  MOVFF  57C,580
07D08:  MOVFF  57B,57F
07D0C:  MOVFF  57E,582
07D10:  MOVFF  57D,581
07D14:  MOVLB  0
07D16:  CALL   2B00
....................     write_ext_eeprom(endInicial+9,((t_wait[pontoSelecionado]&0xff00)>>8)); 
07D1A:  MOVLW  09
07D1C:  MOVLB  5
07D1E:  ADDWF  x79,W
07D20:  MOVWF  x7B
07D22:  MOVLW  00
07D24:  ADDWFC x7A,W
07D26:  MOVWF  x7C
07D28:  BCF    FD8.0
07D2A:  RLCF   x77,W
07D2C:  MOVWF  02
07D2E:  RLCF   x78,W
07D30:  MOVWF  03
07D32:  MOVF   02,W
07D34:  ADDLW  D7
07D36:  MOVWF  FE9
07D38:  MOVLW  00
07D3A:  ADDWFC 03,W
07D3C:  MOVWF  FEA
07D3E:  MOVFF  FEC,57E
07D42:  MOVF   FED,F
07D44:  MOVFF  FEF,57D
07D48:  CLRF   x7D
07D4A:  MOVFF  57E,57D
07D4E:  CLRF   x7E
07D50:  MOVFF  57C,580
07D54:  MOVFF  57B,57F
07D58:  MOVFF  57E,582
07D5C:  MOVFF  57D,581
07D60:  MOVLB  0
07D62:  CALL   2B00
....................     write_ext_eeprom(endInicial+10,(t_wait[pontoSelecionado]&0x00ff)); 
07D66:  MOVLW  0A
07D68:  MOVLB  5
07D6A:  ADDWF  x79,W
07D6C:  MOVWF  x7B
07D6E:  MOVLW  00
07D70:  ADDWFC x7A,W
07D72:  MOVWF  x7C
07D74:  BCF    FD8.0
07D76:  RLCF   x77,W
07D78:  MOVWF  02
07D7A:  RLCF   x78,W
07D7C:  MOVWF  03
07D7E:  MOVF   02,W
07D80:  ADDLW  D7
07D82:  MOVWF  FE9
07D84:  MOVLW  00
07D86:  ADDWFC 03,W
07D88:  MOVWF  FEA
07D8A:  MOVFF  FEC,57E
07D8E:  MOVF   FED,F
07D90:  MOVFF  FEF,57D
07D94:  CLRF   x7E
07D96:  MOVFF  57C,580
07D9A:  MOVFF  57B,57F
07D9E:  MOVFF  57E,582
07DA2:  MOVFF  57D,581
07DA6:  MOVLB  0
07DA8:  CALL   2B00
....................     write_ext_eeprom(endInicial+11,(tipo[pontoSelecionado]<<1)+habilitado[pontoSelecionado]); 
07DAC:  MOVLW  0B
07DAE:  MOVLB  5
07DB0:  ADDWF  x79,W
07DB2:  MOVWF  x7B
07DB4:  MOVLW  00
07DB6:  ADDWFC x7A,W
07DB8:  MOVWF  x7C
07DBA:  BCF    FD8.0
07DBC:  RLCF   x77,W
07DBE:  MOVWF  02
07DC0:  RLCF   x78,W
07DC2:  MOVWF  03
07DC4:  MOVF   02,W
07DC6:  ADDLW  01
07DC8:  MOVWF  FE9
07DCA:  MOVLW  01
07DCC:  ADDWFC 03,W
07DCE:  MOVWF  FEA
07DD0:  MOVFF  FEC,57E
07DD4:  MOVF   FED,F
07DD6:  MOVFF  FEF,57D
07DDA:  BCF    FD8.0
07DDC:  RLCF   x7D,F
07DDE:  RLCF   x7E,F
07DE0:  BCF    FD8.0
07DE2:  RLCF   x77,W
07DE4:  MOVWF  02
07DE6:  RLCF   x78,W
07DE8:  MOVWF  03
07DEA:  MOVF   02,W
07DEC:  ADDLW  2D
07DEE:  MOVWF  FE9
07DF0:  MOVLW  01
07DF2:  ADDWFC 03,W
07DF4:  MOVWF  FEA
07DF6:  MOVFF  FEC,03
07DFA:  MOVF   FED,F
07DFC:  MOVF   FEF,W
07DFE:  ADDWF  x7D,F
07E00:  MOVF   03,W
07E02:  ADDWFC x7E,F
07E04:  MOVFF  57C,580
07E08:  MOVFF  57B,57F
07E0C:  MOVFF  57E,582
07E10:  MOVFF  57D,581
07E14:  MOVLB  0
07E16:  CALL   2B00
....................     write_ext_eeprom(endInicial+12,(numeroFerros[pontoSelecionado])); 
07E1A:  MOVLW  0C
07E1C:  MOVLB  5
07E1E:  ADDWF  x79,W
07E20:  MOVWF  x7B
07E22:  MOVLW  00
07E24:  ADDWFC x7A,W
07E26:  MOVWF  x7C
07E28:  BCF    FD8.0
07E2A:  RLCF   x77,W
07E2C:  MOVWF  02
07E2E:  RLCF   x78,W
07E30:  MOVWF  03
07E32:  MOVF   02,W
07E34:  ADDLW  57
07E36:  MOVWF  FE9
07E38:  MOVLW  01
07E3A:  ADDWFC 03,W
07E3C:  MOVWF  FEA
07E3E:  MOVFF  FEC,57E
07E42:  MOVF   FED,F
07E44:  MOVFF  FEF,57D
07E48:  MOVFF  57C,580
07E4C:  MOVFF  57B,57F
07E50:  MOVFF  57E,582
07E54:  MOVFF  57D,581
07E58:  MOVLB  0
07E5A:  CALL   2B00
....................     write_ext_eeprom(endInicial+13,((t_solda2[pontoSelecionado]&0xff00)>>8)); 
07E5E:  MOVLW  0D
07E60:  MOVLB  5
07E62:  ADDWF  x79,W
07E64:  MOVWF  x7B
07E66:  MOVLW  00
07E68:  ADDWFC x7A,W
07E6A:  MOVWF  x7C
07E6C:  BCF    FD8.0
07E6E:  RLCF   x77,W
07E70:  MOVWF  02
07E72:  RLCF   x78,W
07E74:  MOVWF  03
07E76:  MOVF   02,W
07E78:  ADDLW  81
07E7A:  MOVWF  FE9
07E7C:  MOVLW  01
07E7E:  ADDWFC 03,W
07E80:  MOVWF  FEA
07E82:  MOVFF  FEC,57E
07E86:  MOVF   FED,F
07E88:  MOVFF  FEF,57D
07E8C:  CLRF   x7D
07E8E:  MOVFF  57E,57D
07E92:  CLRF   x7E
07E94:  MOVFF  57C,580
07E98:  MOVFF  57B,57F
07E9C:  MOVFF  57E,582
07EA0:  MOVFF  57D,581
07EA4:  MOVLB  0
07EA6:  CALL   2B00
....................     write_ext_eeprom(endInicial+14,(t_solda2[pontoSelecionado]&0x00ff)); 
07EAA:  MOVLW  0E
07EAC:  MOVLB  5
07EAE:  ADDWF  x79,W
07EB0:  MOVWF  x7B
07EB2:  MOVLW  00
07EB4:  ADDWFC x7A,W
07EB6:  MOVWF  x7C
07EB8:  BCF    FD8.0
07EBA:  RLCF   x77,W
07EBC:  MOVWF  02
07EBE:  RLCF   x78,W
07EC0:  MOVWF  03
07EC2:  MOVF   02,W
07EC4:  ADDLW  81
07EC6:  MOVWF  FE9
07EC8:  MOVLW  01
07ECA:  ADDWFC 03,W
07ECC:  MOVWF  FEA
07ECE:  MOVFF  FEC,57E
07ED2:  MOVF   FED,F
07ED4:  MOVFF  FEF,57D
07ED8:  CLRF   x7E
07EDA:  MOVFF  57C,580
07EDE:  MOVFF  57B,57F
07EE2:  MOVFF  57E,582
07EE6:  MOVFF  57D,581
07EEA:  MOVLB  0
07EEC:  CALL   2B00
....................     write_ext_eeprom(endInicial+15,((t_solda3[pontoSelecionado]&0xff00)>>8)); 
07EF0:  MOVLW  0F
07EF2:  MOVLB  5
07EF4:  ADDWF  x79,W
07EF6:  MOVWF  x7B
07EF8:  MOVLW  00
07EFA:  ADDWFC x7A,W
07EFC:  MOVWF  x7C
07EFE:  BCF    FD8.0
07F00:  RLCF   x77,W
07F02:  MOVWF  02
07F04:  RLCF   x78,W
07F06:  MOVWF  03
07F08:  MOVF   02,W
07F0A:  ADDLW  AB
07F0C:  MOVWF  FE9
07F0E:  MOVLW  01
07F10:  ADDWFC 03,W
07F12:  MOVWF  FEA
07F14:  MOVFF  FEC,57E
07F18:  MOVF   FED,F
07F1A:  MOVFF  FEF,57D
07F1E:  CLRF   x7D
07F20:  MOVFF  57E,57D
07F24:  CLRF   x7E
07F26:  MOVFF  57C,580
07F2A:  MOVFF  57B,57F
07F2E:  MOVFF  57E,582
07F32:  MOVFF  57D,581
07F36:  MOVLB  0
07F38:  CALL   2B00
....................     write_ext_eeprom(endInicial+16,(t_solda3[pontoSelecionado]&0x00ff)); 
07F3C:  MOVLW  10
07F3E:  MOVLB  5
07F40:  ADDWF  x79,W
07F42:  MOVWF  x7B
07F44:  MOVLW  00
07F46:  ADDWFC x7A,W
07F48:  MOVWF  x7C
07F4A:  BCF    FD8.0
07F4C:  RLCF   x77,W
07F4E:  MOVWF  02
07F50:  RLCF   x78,W
07F52:  MOVWF  03
07F54:  MOVF   02,W
07F56:  ADDLW  AB
07F58:  MOVWF  FE9
07F5A:  MOVLW  01
07F5C:  ADDWFC 03,W
07F5E:  MOVWF  FEA
07F60:  MOVFF  FEC,57E
07F64:  MOVF   FED,F
07F66:  MOVFF  FEF,57D
07F6A:  CLRF   x7E
07F6C:  MOVFF  57C,580
07F70:  MOVFF  57B,57F
07F74:  MOVFF  57E,582
07F78:  MOVFF  57D,581
07F7C:  MOVLB  0
07F7E:  CALL   2B00
....................     write_ext_eeprom(endInicial+17,(limpar[pontoSelecionado])); 
07F82:  MOVLW  11
07F84:  MOVLB  5
07F86:  ADDWF  x79,W
07F88:  MOVWF  x7B
07F8A:  MOVLW  00
07F8C:  ADDWFC x7A,W
07F8E:  MOVWF  x7C
07F90:  BCF    FD8.0
07F92:  RLCF   x77,W
07F94:  MOVWF  02
07F96:  RLCF   x78,W
07F98:  MOVWF  03
07F9A:  MOVF   02,W
07F9C:  ADDLW  D5
07F9E:  MOVWF  FE9
07FA0:  MOVLW  01
07FA2:  ADDWFC 03,W
07FA4:  MOVWF  FEA
07FA6:  MOVFF  FEC,57E
07FAA:  MOVF   FED,F
07FAC:  MOVFF  FEF,57D
07FB0:  MOVFF  57C,580
07FB4:  MOVFF  57B,57F
07FB8:  MOVFF  57E,582
07FBC:  MOVFF  57D,581
07FC0:  MOVLB  0
07FC2:  CALL   2B00
07FC6:  RETURN 0
.................... } //escrever_ponto_memoria(modelo,contador_lcd) 
.................... void excluir_modelo_memoria(long int modeloSelecionado){ 
*
0B18A:  MOVLB  5
0B18C:  CLRF   x77
0B18E:  CLRF   x76
0B190:  MOVLW  01
0B192:  SUBWF  x74,W
0B194:  MOVWF  x7A
0B196:  MOVLW  00
0B198:  SUBWFB x75,W
0B19A:  MOVWF  x7B
0B19C:  MOVWF  x81
0B19E:  MOVFF  57A,580
0B1A2:  MOVFF  573,583
0B1A6:  MOVFF  572,582
0B1AA:  MOVLB  0
0B1AC:  CALL   5DA8
0B1B0:  MOVFF  02,579
0B1B4:  MOVFF  01,578
....................     long int i = 0; 
....................     long int endInicial = ((modeloSelecionado - 1)* tamPrograma); 
....................     for (i = endInicial; i< ((endInicial)  + tamPrograma); i++){ 
0B1B8:  MOVFF  579,577
0B1BC:  MOVFF  578,576
0B1C0:  MOVLB  5
0B1C2:  MOVF   x72,W
0B1C4:  ADDWF  x78,W
0B1C6:  MOVWF  01
0B1C8:  MOVF   x73,W
0B1CA:  ADDWFC x79,W
0B1CC:  MOVWF  03
0B1CE:  MOVF   x77,W
0B1D0:  SUBWF  03,W
0B1D2:  BNC   B1F8
0B1D4:  BNZ   B1DC
0B1D6:  MOVF   01,W
0B1D8:  SUBWF  x76,W
0B1DA:  BC    B1F8
....................         write_ext_eeprom(i,0);        
0B1DC:  MOVFF  577,580
0B1E0:  MOVFF  576,57F
0B1E4:  CLRF   x82
0B1E6:  CLRF   x81
0B1E8:  MOVLB  0
0B1EA:  CALL   2B00
0B1EE:  MOVLB  5
0B1F0:  INCF   x76,F
0B1F2:  BTFSC  FD8.2
0B1F4:  INCF   x77,F
0B1F6:  BRA    B1C2
....................     } 
0B1F8:  MOVLB  0
0B1FA:  GOTO   B246 (RETURN)
.................... } //excluir_modelo_memoria(modelo) 
.................... void escrever_pontos_no_modelo(long int modeloSelecionado,int quantidade_pontos){ 
*
0732C:  MOVLW  01
0732E:  MOVLB  5
07330:  SUBWF  x74,W
07332:  MOVWF  x79
07334:  MOVLW  00
07336:  SUBWFB x75,W
07338:  MOVWF  x7A
0733A:  MOVWF  x81
0733C:  MOVFF  579,580
07340:  MOVFF  573,583
07344:  MOVFF  572,582
07348:  MOVLB  0
0734A:  CALL   5DA8
0734E:  MOVFF  02,578
07352:  MOVFF  01,577
....................     long int endInicial = ((modeloSelecionado - 1)*tamPrograma); 
....................     write_ext_eeprom(endInicial,quantidade_pontos); 
07356:  MOVFF  578,580
0735A:  MOVFF  577,57F
0735E:  MOVLB  5
07360:  CLRF   x82
07362:  MOVFF  576,581
07366:  MOVLB  0
07368:  CALL   2B00
0736C:  GOTO   73EC (RETURN)
.................... } //escrever_pontos_no_modelo(modelo,pontos_no_modelo) 
....................  
.................... #include "att_telas_1.c" 
.................... #include "att_telas_1.h" 
.................... void atualiza_tela_principal(void); //atualizacao de tela principal: F1 para degub F2 para main 
....................  
.................... void atualiza_tela_seleciona_maquina(void); //atualiza tela de selecao de maquina f1 para maquina 1 e f2 para maquina 2 
.................... void atualiza_tela_manutencao_outra_maquina(void); //atualizacao de tela enquanto esta sendo feita manutencao na outra maquina 
.................... void atualiza_tela_edita_modelo(void); //atualizacao de tela para editar ou excluir modelo 
.................... void atualiza_tela_seleciona_debug(void); // atualizacao de tela que escolhe f1 para editar ponto e f2 para manutencao 
.................... void atualiza_tela_seleciona_debug_2 (void); 
.................... void atualiza_tela_edita_pontos_no_modelo(void);// atualizacao de tela da edicao de pontos do modelo 
.................... void atualiza_tela_excluir_modelo(void); //atualizacao de tela que exclui o modelo 
.................... void atualiza_tela_seleciona_pontos(void); //atualizacao de tela da escolha de ponto a ser editado 
.................... void atualiza_tela_dados_ponto (void); //atualizacao de tela que age em cima da tela de dados ponto, alterando x, y, z, tempo de solda, tempo de espera, tipo e habilitado 
.................... void atualiza_tela_dados_ponto_2 (void); //atualizacao de tela que age em cima da tela de dados ponto2, alterando tempo de solda e tempo de espera. 
....................  
.................... void atualiza_tela_seleciona_manutencao (void); //atualizacao de tela de manutencao, escolhe entre entradas e saidas 
.................... void atualiza_tela_debug_entrada_1 (void); //atualizacao de tela que ao passar pro lado mostra a tela 2 de sensores ou sai ao dar esc 
.................... void atualiza_tela_debug_entrada_2 (void); ///atualizacao de tela que ao passar pro lado mostra a tela 1 ou 3 de sensores ou sai ao dar esc 
.................... void atualiza_tela_debug_entrada_3 (void); //atualizacao de tela que ao passar pro lado mostra a tela 2 de sensores ou sai ao dar esc 
.................... void atualiza_tela_debug_saida_1(void); //atualizacao de tela que podemos acionar a esteira, pinos de entrada, e o alimentador de placa 
.................... void atualiza_tela_debug_saida_2(void); //atualizacao de tela que podemos acionar o pressor da placa, pinos de saida e dispensador de placa 
.................... void atualiza_tela_debug_saida_3(void); //atualizacao de tela que podemos acionar os alimentadores de solda, limpar os bicos e acionar os ferros 
.................... void atualiza_tela_debug_saida_4(void); //atualizacao de tela que podemos realizar a movimentacao do eixo x, y, z e o flip individualmenta 
....................  
.................... void programa_principal(void); // atualizacao de tela programa principal 
....................  
....................  
.................... void atualiza_tela_principal(){ 
....................     switch (Teclado()){ 
*
062F2:  RCALL  5B66
062F4:  MOVF   01,W
062F6:  XORLW  14
062F8:  BZ    6308
062FA:  XORLW  07
062FC:  BZ    6334
062FE:  XORLW  1D
06300:  BZ    6362
06302:  XORLW  01
06304:  BZ    6372
06306:  BRA    6380
....................         case MENU: 
....................             printf(lcd_putc, "\f"); // limpa display 
06308:  MOVLW  0C
0630A:  MOVLB  5
0630C:  MOVWF  x85
0630E:  MOVLB  0
06310:  CALL   2D30
....................             printf(lcd_putc, "  CARREGANDO MODELO \n\r"); 
06314:  MOVLW  82
06316:  MOVWF  FF6
06318:  MOVLW  0E
0631A:  MOVWF  FF7
0631C:  CALL   2D86
....................             ler_modelo_memoria(modelo); 
06320:  MOVLB  5
06322:  CLRF   x75
06324:  MOVFF  2E,574
06328:  MOVLB  0
0632A:  RCALL  5DCA
....................             menu_atual = menu_seleciona_maquina; 
0632C:  MOVLW  01
0632E:  MOVWF  1C
....................             tela_seleciona_maquina();             
06330:  RCALL  6248
....................         break; 
06332:  BRA    6380
....................         case ENTER: 
....................             printf(lcd_putc, "\f"); // limpa display 
06334:  MOVLW  0C
06336:  MOVLB  5
06338:  MOVWF  x85
0633A:  MOVLB  0
0633C:  CALL   2D30
....................             printf(lcd_putc, "  CARREGANDO MODELO \n\r"); 
06340:  MOVLW  9A
06342:  MOVWF  FF6
06344:  MOVLW  0E
06346:  MOVWF  FF7
06348:  CALL   2D86
....................             ler_modelo_memoria(modelo); 
0634C:  MOVLB  5
0634E:  CLRF   x75
06350:  MOVFF  2E,574
06354:  MOVLB  0
06356:  RCALL  5DCA
....................             exit = TRUE; 
06358:  BSF    2D.1
....................             menu_atual = menu_programa_principal; 
0635A:  MOVLW  0C
0635C:  MOVWF  1C
....................             tela_programa_principal(); 
0635E:  BRA    6286
....................         break; 
06360:  BRA    6380
....................         case SETA_SUPERIOR: 
....................             if (modelo < 4){ 
06362:  MOVF   2E,W
06364:  SUBLW  03
06366:  BNC   636A
....................                 modelo ++; 
06368:  INCF   2E,F
....................             } 
....................             menu_atual = menu_principal; 
0636A:  CLRF   1C
....................             tela_principal(); 
0636C:  CALL   59D6
....................         break; 
06370:  BRA    6380
....................         case SETA_INFERIOR: 
....................             if (modelo > 1){ 
06372:  MOVF   2E,W
06374:  SUBLW  01
06376:  BC    637A
....................                 modelo --; 
06378:  DECF   2E,F
....................             } 
....................             menu_atual = menu_principal; 
0637A:  CLRF   1C
....................             tela_principal(); 
0637C:  CALL   59D6
....................         break; 
....................     } 
06380:  GOTO   DA8A (RETURN)
.................... } 
....................  
.................... void atualiza_tela_seleciona_maquina(){ 
....................     switch (Teclado()){ 
*
06FDE:  CALL   5B66
06FE2:  MOVF   01,W
06FE4:  XORLW  0A
06FE6:  BZ    6FF2
06FE8:  XORLW  01
06FEA:  BZ    6FFC
06FEC:  XORLW  19
06FEE:  BZ    700E
06FF0:  BRA    7014
....................         case F1: 
....................             menu_atual = menu_edita_modelo; 
06FF2:  MOVLW  0D
06FF4:  MOVWF  1C
....................             tela_edita_modelo();  
06FF6:  CALL   6384
....................         break; 
06FFA:  BRA    7014
....................         case F2: 
....................             envia_maquina_para_posicao(HOME1); 
06FFC:  MOVLW  01
06FFE:  MOVLB  5
07000:  MOVWF  x77
07002:  MOVLB  0
07004:  RCALL  69E4
....................             tela_manutencao_outra_maquina(); 
07006:  RCALL  6FA0
....................             menu_atual = menu_manutencao_outra_maquina; 
07008:  MOVLW  07
0700A:  MOVWF  1C
....................         break; 
0700C:  BRA    7014
....................         case ESC: 
....................             menu_atual = menu_principal; 
0700E:  CLRF   1C
....................             tela_principal(); 
07010:  CALL   59D6
....................         break; 
....................     } 
07014:  GOTO   DA92 (RETURN)
.................... } 
.................... void atualiza_tela_manutencao_outra_maquina(){ 
....................     switch(Teclado()){ 
*
07058:  CALL   5B66
0705C:  MOVF   01,W
0705E:  XORLW  12
07060:  BZ    7064
07062:  BRA    706A
....................         case ESC: 
....................             menu_atual = menu_confirmaManutencao; 
07064:  MOVLW  15
07066:  MOVWF  1C
....................             tela_confirmaManutencao(); 
07068:  BRA    7018
....................         break; 
....................     } 
0706A:  GOTO   DA9A (RETURN)
.................... } 
.................... void atualiza_tela_edita_modelo(){ 
....................     switch (Teclado()){ 
*
07124:  CALL   5B66
07128:  MOVF   01,W
0712A:  XORLW  0A
0712C:  BZ    7138
0712E:  XORLW  01
07130:  BZ    7140
07132:  XORLW  19
07134:  BZ    7148
07136:  BRA    7156
....................         case F1: 
....................             menu_atual = menu_seleciona_debug; 
07138:  MOVLW  02
0713A:  MOVWF  1C
....................             tela_seleciona_debug(); 
0713C:  RCALL  709A
....................         break; 
0713E:  BRA    7156
....................         case F2: 
....................             menu_atual = menu_excluir_modelo; 
07140:  MOVLW  0E
07142:  MOVWF  1C
....................             tela_excluir_modelo(); 
07144:  BRA    70E4
....................         break; 
07146:  BRA    7156
....................         case ESC: 
....................             envia_maquina_para_posicao(ALIMENTADOR); 
07148:  MOVLB  5
0714A:  CLRF   x77
0714C:  MOVLB  0
0714E:  RCALL  69E4
....................             menu_atual = menu_principal; 
07150:  CLRF   1C
....................             tela_principal(); 
07152:  CALL   59D6
....................         break; 
....................     } 
07156:  GOTO   DAAA (RETURN)
.................... } 
.................... void atualiza_tela_seleciona_debug (){ 
....................     switch(Teclado()){ 
*
071E2:  CALL   5B66
071E6:  MOVF   01,W
071E8:  XORLW  0A
071EA:  BZ    71F6
071EC:  XORLW  01
071EE:  BZ    71FE
071F0:  XORLW  19
071F2:  BZ    7206
071F4:  BRA    720E
....................         case F1: 
....................             menu_atual = menu_seleciona_debug_2; 
071F6:  MOVLW  14
071F8:  MOVWF  1C
....................             tela_seleciona_debug_2(); 
071FA:  RCALL  715A
....................         break; 
071FC:  BRA    720E
....................         case F2: 
....................             menu_atual = menu_seleciona_manutencao; 
071FE:  MOVLW  03
07200:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
07202:  RCALL  71A4
....................         break; 
07204:  BRA    720E
....................         case ESC: 
....................             menu_atual = menu_edita_modelo; 
07206:  MOVLW  0D
07208:  MOVWF  1C
....................             tela_edita_modelo(); 
0720A:  CALL   6384
....................         break; 
....................     } 
0720E:  GOTO   DAB2 (RETURN)
.................... } 
.................... void atualiza_tela_seleciona_debug_2 (){ 
*
0B466:  MOVLB  5
0B468:  BSF    x74.1
....................     short int x; 
....................     short int k = TRUE; 
....................     short int b; 
....................     switch(Teclado()){ 
0B46A:  MOVLB  0
0B46C:  CALL   5B66
0B470:  MOVF   01,W
0B472:  XORLW  0B
0B474:  BZ    B484
0B476:  XORLW  01
0B478:  BTFSC  FD8.2
0B47A:  BRA    B5AA
0B47C:  XORLW  18
0B47E:  BTFSC  FD8.2
0B480:  BRA    B5B4
0B482:  BRA    B5BC
....................         case F2: 
....................             if (pontos_no_modelo > 0){ 
0B484:  MOVLB  1
0B486:  MOVF   x2B,F
0B488:  BNZ   B48E
0B48A:  MOVF   x2C,F
0B48C:  BZ    B564
....................                 b = le_Input(S_BANDEJA); 
0B48E:  MOVLW  15
0B490:  MOVLB  5
0B492:  MOVWF  x78
0B494:  MOVLB  0
0B496:  CALL   49FA
0B49A:  MOVLB  5
0B49C:  BCF    x74.2
0B49E:  BTFSC  01.0
0B4A0:  BSF    x74.2
....................                 if (b == 1){ 
0B4A2:  BTFSS  x74.2
0B4A4:  BRA    B546
....................                     liga_esteira(); 
0B4A6:  MOVLB  0
0B4A8:  RCALL  B39C
....................                     x = le_Input(S_ESTEIRA); 
0B4AA:  MOVLW  19
0B4AC:  MOVLB  5
0B4AE:  MOVWF  x78
0B4B0:  MOVLB  0
0B4B2:  CALL   49FA
0B4B6:  MOVLB  5
0B4B8:  BCF    x74.0
0B4BA:  BTFSC  01.0
0B4BC:  BSF    x74.0
....................                     while ((x == 0)&&(k == TRUE)){ 
0B4BE:  BTFSC  x74.0
0B4C0:  BRA    B510
0B4C2:  BTFSS  x74.1
0B4C4:  BRA    B510
....................                         printf(lcd_putc, "\f"); //limpa display 
0B4C6:  MOVLW  0C
0B4C8:  MOVWF  x85
0B4CA:  MOVLB  0
0B4CC:  CALL   2D30
....................                         printf(lcd_putc, "   ESPERANDO PLACA   \n\r"); 
0B4D0:  MOVLW  B2
0B4D2:  MOVWF  FF6
0B4D4:  MOVLW  0E
0B4D6:  MOVWF  FF7
0B4D8:  CALL   2D86
....................                         printf(lcd_putc, "     NA ESTEIRA     \n\r"); 
0B4DC:  MOVLW  CA
0B4DE:  MOVWF  FF6
0B4E0:  MOVLW  0E
0B4E2:  MOVWF  FF7
0B4E4:  CALL   2D86
....................                         x = le_Input(S_ESTEIRA); 
0B4E8:  MOVLW  19
0B4EA:  MOVLB  5
0B4EC:  MOVWF  x78
0B4EE:  MOVLB  0
0B4F0:  CALL   49FA
0B4F4:  MOVLB  5
0B4F6:  BCF    x74.0
0B4F8:  BTFSC  01.0
0B4FA:  BSF    x74.0
....................                         if (Teclado() == ESC){ 
0B4FC:  MOVLB  0
0B4FE:  CALL   5B66
0B502:  MOVF   01,W
0B504:  SUBLW  12
0B506:  BNZ   B50C
....................                             k = FALSE; 
0B508:  MOVLB  5
0B50A:  BCF    x74.1
....................                         }                    
0B50C:  MOVLB  5
0B50E:  BRA    B4BE
....................                     } 
....................                     if (k == TRUE){ 
0B510:  BTFSS  x74.1
0B512:  BRA    B536
....................                         desliga_esteira(); 
0B514:  MOVLB  0
0B516:  RCALL  B3AC
....................                         empurra_placa(); 
0B518:  RCALL  B3BC
....................                         liga_pressor(); 
0B51A:  CALL   7A76
....................                         envia_maquina_para_posicao(HOME1); 
0B51E:  MOVLW  01
0B520:  MOVLB  5
0B522:  MOVWF  x77
0B524:  MOVLB  0
0B526:  CALL   69E4
....................                         menu_atual = menu_seleciona_pontos; 
0B52A:  MOVLW  0F
0B52C:  MOVWF  1C
....................                         tela_seleciona_pontos(); 
0B52E:  CALL   7464
....................                     } else { 
0B532:  BRA    B542
0B534:  MOVLB  5
....................                         desliga_esteira(); 
0B536:  MOVLB  0
0B538:  RCALL  B3AC
....................                         menu_atual = menu_seleciona_debug_2; 
0B53A:  MOVLW  14
0B53C:  MOVWF  1C
....................                         tela_seleciona_debug_2(); 
0B53E:  CALL   715A
....................                     } 
....................                 } else { 
0B542:  BRA    B560
0B544:  MOVLB  5
....................                     liga_pressor(); 
0B546:  MOVLB  0
0B548:  CALL   7A76
....................                     envia_maquina_para_posicao(HOME1); 
0B54C:  MOVLW  01
0B54E:  MOVLB  5
0B550:  MOVWF  x77
0B552:  MOVLB  0
0B554:  CALL   69E4
....................                     menu_atual = menu_seleciona_pontos; 
0B558:  MOVLW  0F
0B55A:  MOVWF  1C
....................                     tela_seleciona_pontos(); 
0B55C:  CALL   7464
....................                 }                               
....................             } else { 
0B560:  BRA    B5A8
0B562:  MOVLB  1
....................                 printf(lcd_putc, "\f"); // limpa display 
0B564:  MOVLW  0C
0B566:  MOVLB  5
0B568:  MOVWF  x85
0B56A:  MOVLB  0
0B56C:  CALL   2D30
....................                 printf(lcd_putc, " VERIFIQUE O NUMERO \n\r"); 
0B570:  MOVLW  E2
0B572:  MOVWF  FF6
0B574:  MOVLW  0E
0B576:  MOVWF  FF7
0B578:  CALL   2D86
....................                 printf(lcd_putc, " DE PONTOS NO MODELO\n\r"); 
0B57C:  MOVLW  FA
0B57E:  MOVWF  FF6
0B580:  MOVLW  0E
0B582:  MOVWF  FF7
0B584:  CALL   2D86
....................                 delay_ms(3000); 
0B588:  MOVLW  0C
0B58A:  MOVLB  5
0B58C:  MOVWF  x75
0B58E:  MOVLW  FA
0B590:  MOVWF  x91
0B592:  MOVLB  0
0B594:  CALL   2954
0B598:  MOVLB  5
0B59A:  DECFSZ x75,F
0B59C:  BRA    B58E
....................                 menu_atual = menu_seleciona_debug_2; 
0B59E:  MOVLW  14
0B5A0:  MOVWF  1C
....................                 tela_seleciona_debug_2(); 
0B5A2:  MOVLB  0
0B5A4:  CALL   715A
....................             } 
....................         break; 
0B5A8:  BRA    B5BC
....................         case F1: 
....................             menu_atual = menu_edita_pontos_no_modelo; 
0B5AA:  MOVLW  11
0B5AC:  MOVWF  1C
....................             tela_edita_pontos_no_modelo(); 
0B5AE:  CALL   72D0
....................         break; 
0B5B2:  BRA    B5BC
....................         case ESC: 
....................             menu_atual = menu_seleciona_debug; 
0B5B4:  MOVLW  02
0B5B6:  MOVWF  1C
....................             tela_seleciona_debug(); 
0B5B8:  CALL   709A
....................         break; 
....................     } 
0B5BC:  GOTO   DAEA (RETURN)
.................... } 
.................... void atualiza_tela_edita_pontos_no_modelo(){ 
....................     switch(Teclado()){ 
*
07370:  CALL   5B66
07374:  MOVLW  0E
07376:  SUBWF  01,W
07378:  ADDLW  FA
0737A:  BC    7430
0737C:  ADDLW  06
0737E:  GOTO   7434
....................         case SETA_SUPERIOR: 
....................             if (pontos_no_modelo < 20){ 
07382:  MOVLB  1
07384:  MOVF   x2C,F
07386:  BNZ   7396
07388:  MOVF   x2B,W
0738A:  SUBLW  13
0738C:  BNC   7396
....................                 pontos_no_modelo = pontos_no_modelo + 1;                 
0738E:  MOVLW  01
07390:  ADDWF  x2B,F
07392:  MOVLW  00
07394:  ADDWFC x2C,F
....................             } 
....................             menu_atual = menu_edita_pontos_no_modelo; 
07396:  MOVLW  11
07398:  MOVWF  1C
....................             tela_edita_pontos_no_modelo(); 
0739A:  MOVLB  0
0739C:  RCALL  72D0
....................         break; 
0739E:  BRA    7430
....................         case SETA_INFERIOR: 
....................             if (pontos_no_modelo > 0){ 
073A0:  MOVLB  1
073A2:  MOVF   x2B,F
073A4:  BNZ   73AA
073A6:  MOVF   x2C,F
073A8:  BZ    73B2
....................                 pontos_no_modelo = pontos_no_modelo -1; 
073AA:  MOVLW  01
073AC:  SUBWF  x2B,F
073AE:  MOVLW  00
073B0:  SUBWFB x2C,F
....................             } 
....................             menu_atual = menu_edita_pontos_no_modelo; 
073B2:  MOVLW  11
073B4:  MOVWF  1C
....................             tela_edita_pontos_no_modelo(); 
073B6:  MOVLB  0
073B8:  RCALL  72D0
....................         break; 
073BA:  BRA    7430
....................         case ESC: 
....................             menu_atual = menu_seleciona_debug_2; 
073BC:  MOVLW  14
073BE:  MOVWF  1C
....................             tela_seleciona_debug_2(); 
073C0:  RCALL  715A
....................         break; 
073C2:  BRA    7430
....................         case ENTER: 
....................             printf(lcd_putc, "\f"); // limpa display 
073C4:  MOVLW  0C
073C6:  MOVLB  5
073C8:  MOVWF  x85
073CA:  MOVLB  0
073CC:  CALL   2D30
....................             printf(lcd_putc, "   GRAVANDO PONTOS  \n\r"); 
073D0:  MOVLW  12
073D2:  MOVWF  FF6
073D4:  MOVLW  0F
073D6:  MOVWF  FF7
073D8:  CALL   2D86
....................             escrever_pontos_no_modelo(modelo,pontos_no_modelo); 
073DC:  MOVLB  5
073DE:  CLRF   x75
073E0:  MOVFF  2E,574
073E4:  MOVFF  12B,576
073E8:  MOVLB  0
073EA:  BRA    732C
....................             ler_modelo_memoria(modelo); 
073EC:  MOVLB  5
073EE:  CLRF   x75
073F0:  MOVFF  2E,574
073F4:  MOVLB  0
073F6:  CALL   5DCA
....................             printf(lcd_putc, "\f"); // limpa display 
073FA:  MOVLW  0C
073FC:  MOVLB  5
073FE:  MOVWF  x85
07400:  MOVLB  0
07402:  CALL   2D30
....................             printf(lcd_putc, "PONTOS ATUALIZADOS\n\r"); 
07406:  MOVLW  2A
07408:  MOVWF  FF6
0740A:  MOVLW  0F
0740C:  MOVWF  FF7
0740E:  CALL   2D86
....................             delay_ms(3000); 
07412:  MOVLW  0C
07414:  MOVLB  5
07416:  MOVWF  x74
07418:  MOVLW  FA
0741A:  MOVWF  x91
0741C:  MOVLB  0
0741E:  CALL   2954
07422:  MOVLB  5
07424:  DECFSZ x74,F
07426:  BRA    7418
....................             menu_atual = menu_seleciona_debug_2; 
07428:  MOVLW  14
0742A:  MOVWF  1C
....................             tela_seleciona_debug_2(); 
0742C:  MOVLB  0
0742E:  RCALL  715A
....................         break; 
....................     } 
07430:  GOTO   DABA (RETURN)
.................... } 
.................... void atualiza_tela_excluir_modelo(){ 
....................     switch (Teclado()){ 
*
0B1FE:  CALL   5B66
0B202:  MOVF   01,W
0B204:  XORLW  13
0B206:  BZ    B20E
0B208:  XORLW  01
0B20A:  BZ    B28E
0B20C:  BRA    B296
....................         case ENTER: 
....................             printf(lcd_putc, "\f"); // limpa display 
0B20E:  MOVLW  0C
0B210:  MOVLB  5
0B212:  MOVWF  x85
0B214:  MOVLB  0
0B216:  CALL   2D30
....................             printf(lcd_putc, "  EXCLUINDO MODELO  \n\r"); 
0B21A:  MOVLW  40
0B21C:  MOVWF  FF6
0B21E:  MOVLW  0F
0B220:  MOVWF  FF7
0B222:  CALL   2D86
....................             delay_ms(1000); 
0B226:  MOVLW  04
0B228:  MOVLB  5
0B22A:  MOVWF  x74
0B22C:  MOVLW  FA
0B22E:  MOVWF  x91
0B230:  MOVLB  0
0B232:  CALL   2954
0B236:  MOVLB  5
0B238:  DECFSZ x74,F
0B23A:  BRA    B22C
....................             excluir_modelo_memoria(modelo); 
0B23C:  CLRF   x75
0B23E:  MOVFF  2E,574
0B242:  MOVLB  0
0B244:  BRA    B18A
....................             ler_modelo_memoria(modelo); 
0B246:  MOVLB  5
0B248:  CLRF   x75
0B24A:  MOVFF  2E,574
0B24E:  MOVLB  0
0B250:  CALL   5DCA
....................             printf(lcd_putc, "\f"); // limpa display 
0B254:  MOVLW  0C
0B256:  MOVLB  5
0B258:  MOVWF  x85
0B25A:  MOVLB  0
0B25C:  CALL   2D30
....................             printf(lcd_putc, "   MODELO EXCUIDO   \n\r"); 
0B260:  MOVLW  58
0B262:  MOVWF  FF6
0B264:  MOVLW  0F
0B266:  MOVWF  FF7
0B268:  CALL   2D86
....................             delay_ms(1000); 
0B26C:  MOVLW  04
0B26E:  MOVLB  5
0B270:  MOVWF  x74
0B272:  MOVLW  FA
0B274:  MOVWF  x91
0B276:  MOVLB  0
0B278:  CALL   2954
0B27C:  MOVLB  5
0B27E:  DECFSZ x74,F
0B280:  BRA    B272
....................             menu_atual = menu_edita_modelo; 
0B282:  MOVLW  0D
0B284:  MOVWF  1C
....................             tela_edita_modelo(); 
0B286:  MOVLB  0
0B288:  CALL   6384
....................         break; 
0B28C:  BRA    B296
....................         case ESC: 
....................             menu_atual = menu_edita_modelo; 
0B28E:  MOVLW  0D
0B290:  MOVWF  1C
....................             tela_edita_modelo(); 
0B292:  CALL   6384
....................         break; 
....................     } 
0B296:  GOTO   DADA (RETURN)
.................... } 
.................... void atualiza_tela_seleciona_pontos(){ 
....................     switch(Teclado()){ 
*
077A6:  CALL   5B66
077AA:  MOVLW  0E
077AC:  SUBWF  01,W
077AE:  ADDLW  FA
077B0:  BTFSC  FD8.0
077B2:  BRA    79D2
077B4:  ADDLW  06
077B6:  GOTO   79D6
....................         case SETA_SUPERIOR: 
....................             contador_lcd --; 
077BA:  DECF   24,F
....................             if  ((contador_lcd > 0)&&(contador_lcd < pontos_no_modelo)){ 
077BC:  MOVF   24,F
077BE:  BZ    77E6
077C0:  MOVLB  1
077C2:  MOVF   x2C,F
077C4:  BNZ   77D2
077C6:  MOVF   x2B,W
077C8:  SUBWF  24,W
077CA:  BTFSS  FD8.0
077CC:  BRA    77D2
077CE:  MOVLB  0
077D0:  BRA    77E6
....................                 if (ponteiro_lcd == 1){ 
077D2:  DECFSZ 21,W
077D4:  BRA    77E0
....................                     inicial_lcd --; 
077D6:  DECF   22,F
....................                     final_lcd --; 
077D8:  DECF   23,F
....................                     ponteiro_lcd = 1; 
077DA:  MOVLW  01
077DC:  MOVWF  21
....................                 } else { 
077DE:  BRA    77E2
....................                     ponteiro_lcd --; 
077E0:  DECF   21,F
....................                 }                 
....................             } else { 
077E2:  BRA    77F4
077E4:  MOVLB  0
....................                 contador_lcd = 0; 
077E6:  CLRF   24
....................                 inicial_lcd = 0; 
077E8:  CLRF   22
....................                 final_lcd = 3; 
077EA:  MOVLW  03
077EC:  MOVWF  23
....................                 ponteiro_lcd = 1; 
077EE:  MOVLW  01
077F0:  MOVWF  21
077F2:  MOVLB  1
....................             } 
....................             menu_atual = menu_seleciona_pontos; 
077F4:  MOVLW  0F
077F6:  MOVWF  1C
....................             tela_seleciona_pontos(); 
077F8:  MOVLB  0
077FA:  RCALL  7464
....................         break; 
077FC:  BRA    79D2
....................         case SETA_INFERIOR: 
....................             contador_lcd ++; 
077FE:  INCF   24,F
....................             if (contador_lcd < pontos_no_modelo){ 
07800:  MOVLB  1
07802:  MOVF   x2C,F
07804:  BNZ   780C
07806:  MOVF   x2B,W
07808:  SUBWF  24,W
0780A:  BC    7820
....................                 if (ponteiro_lcd == 4){ 
0780C:  MOVF   21,W
0780E:  SUBLW  04
07810:  BNZ   781C
....................                     inicial_lcd ++; 
07812:  INCF   22,F
....................                     final_lcd ++; 
07814:  INCF   23,F
....................                     ponteiro_lcd = 4; 
07816:  MOVLW  04
07818:  MOVWF  21
....................                 } else { 
0781A:  BRA    781E
....................                     ponteiro_lcd ++; 
0781C:  INCF   21,F
....................                 } 
....................             } else { 
0781E:  BRA    7826
....................                 contador_lcd = pontos_no_modelo-1; 
07820:  MOVLW  01
07822:  SUBWF  x2B,W
07824:  MOVWF  24
....................             } 
....................             menu_atual = menu_seleciona_pontos; 
07826:  MOVLW  0F
07828:  MOVWF  1C
....................             tela_seleciona_pontos(); 
0782A:  MOVLB  0
0782C:  RCALL  7464
....................         break; 
0782E:  BRA    79D2
....................         case ENTER: 
....................             ponteiro_lcd = 1; 
07830:  MOVLW  01
07832:  MOVWF  21
....................             inicial_lcd = 0; 
07834:  CLRF   22
....................             final_lcd = 3; 
07836:  MOVLW  03
07838:  MOVWF  23
....................             if ((contador_lcd >= 14)&&(modelo == 1)){ 
0783A:  MOVF   24,W
0783C:  SUBLW  0D
0783E:  BC    7846
07840:  DECFSZ 2E,W
07842:  BRA    7846
....................                 contador_lcd ++; 
07844:  INCF   24,F
....................             } 
....................             motor_run_z(0, 19); 
07846:  MOVLB  5
07848:  CLRF   x7F
0784A:  CLRF   x7E
0784C:  CLRF   x7D
0784E:  CLRF   x7C
07850:  MOVLW  13
07852:  MOVWF  x80
07854:  MOVLB  0
07856:  CALL   63C2
....................             while ((run_flg_z)); 
0785A:  MOVLB  3
0785C:  BTFSC  xB7.2
0785E:  BRA    785C
....................             if ((y[contador_lcd] > 0) && (x[contador_lcd]> 0)){ 
07860:  BCF    FD8.0
07862:  RLCF   24,W
07864:  CLRF   03
07866:  ADDLW  59
07868:  MOVWF  FE9
0786A:  MOVLW  00
0786C:  ADDWFC 03,W
0786E:  MOVWF  FEA
07870:  MOVFF  FEC,575
07874:  MOVF   FED,F
07876:  MOVFF  FEF,574
0787A:  MOVLB  5
0787C:  MOVF   x74,F
0787E:  BNZ   7884
07880:  MOVF   x75,F
07882:  BZ    7926
07884:  BCF    FD8.0
07886:  RLCF   24,W
07888:  CLRF   03
0788A:  ADDLW  2F
0788C:  MOVWF  FE9
0788E:  MOVLW  00
07890:  ADDWFC 03,W
07892:  MOVWF  FEA
07894:  MOVFF  FEC,575
07898:  MOVF   FED,F
0789A:  MOVFF  FEF,574
0789E:  MOVF   x74,F
078A0:  BNZ   78A6
078A2:  MOVF   x75,F
078A4:  BZ    7926
....................                 motor_run_x(x[contador_lcd],19); 
078A6:  BCF    FD8.0
078A8:  RLCF   24,W
078AA:  CLRF   03
078AC:  ADDLW  2F
078AE:  MOVWF  FE9
078B0:  MOVLW  00
078B2:  ADDWFC 03,W
078B4:  MOVWF  FEA
078B6:  MOVFF  FEC,575
078BA:  MOVF   FED,F
078BC:  MOVFF  FEF,574
078C0:  CLRF   x7F
078C2:  CLRF   x7E
078C4:  MOVFF  575,57D
078C8:  MOVFF  574,57C
078CC:  MOVLW  13
078CE:  MOVWF  x80
078D0:  MOVLB  0
078D2:  CALL   55F6
....................                 while ((run_flg_x)); 
078D6:  MOVLB  2
078D8:  BTFSC  x0B.5
078DA:  BRA    78D8
....................                 motor_run_y(y[contador_lcd],19); 
078DC:  BCF    FD8.0
078DE:  RLCF   24,W
078E0:  CLRF   03
078E2:  ADDLW  59
078E4:  MOVWF  FE9
078E6:  MOVLW  00
078E8:  ADDWFC 03,W
078EA:  MOVWF  FEA
078EC:  MOVFF  FEC,575
078F0:  MOVF   FED,F
078F2:  MOVFF  FEF,574
078F6:  MOVLB  5
078F8:  CLRF   x7F
078FA:  CLRF   x7E
078FC:  MOVFF  575,57D
07900:  MOVFF  574,57C
07904:  MOVLW  13
07906:  MOVWF  x80
07908:  MOVLB  0
0790A:  CALL   6622
....................                 while ((run_flg_y)); 
0790E:  MOVLB  2
07910:  BTFSC  x0B.7
07912:  BRA    7910
....................                 posicao_atual = SOLDAGEM; 
07914:  MOVLW  03
07916:  MOVWF  26
....................                 envia_posicao_para_outra_maquina(SOLDAGEM); 
07918:  MOVLB  5
0791A:  MOVWF  x78
0791C:  MOVLB  0
0791E:  CALL   4752
....................             } else { 
07922:  BRA    797E
07924:  MOVLB  5
....................                 envia_maquina_para_posicao(SOLDAGEM); 
07926:  MOVLW  03
07928:  MOVWF  x77
0792A:  MOVLB  0
0792C:  CALL   69E4
....................                 x[contador_lcd] = motor_pos_x; 
07930:  BCF    FD8.0
07932:  RLCF   24,W
07934:  CLRF   03
07936:  ADDLW  2F
07938:  MOVWF  FE9
0793A:  MOVLW  00
0793C:  ADDWFC 03,W
0793E:  MOVWF  FEA
07940:  MOVFF  204,FEC
07944:  MOVF   FED,F
07946:  MOVFF  203,FEF
....................                 y[contador_lcd] = motor_pos_y; 
0794A:  BCF    FD8.0
0794C:  RLCF   24,W
0794E:  CLRF   03
07950:  ADDLW  59
07952:  MOVWF  FE9
07954:  MOVLW  00
07956:  ADDWFC 03,W
07958:  MOVWF  FEA
0795A:  MOVFF  206,FEC
0795E:  MOVF   FED,F
07960:  MOVFF  205,FEF
....................                 z[contador_lcd] = motor_pos_z; 
07964:  BCF    FD8.0
07966:  RLCF   24,W
07968:  CLRF   03
0796A:  ADDLW  83
0796C:  MOVWF  FE9
0796E:  MOVLW  00
07970:  ADDWFC 03,W
07972:  MOVWF  FEA
07974:  MOVFF  20A,FEC
07978:  MOVF   FED,F
0797A:  MOVFF  209,FEF
....................             } 
....................             menu_atual = menu_dados_ponto; 
0797E:  MOVLW  10
07980:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
07982:  MOVFF  24,575
07986:  RCALL  7560
....................         break; 
07988:  BRA    79D2
....................         case ESC: 
....................             envia_maquina_para_posicao(HOME1); 
0798A:  MOVLW  01
0798C:  MOVLB  5
0798E:  MOVWF  x77
07990:  MOVLB  0
07992:  CALL   69E4
....................             envia_maquina_para_posicao(ALIMENTADOR); 
07996:  MOVLB  5
07998:  CLRF   x77
0799A:  MOVLB  0
0799C:  CALL   69E4
....................             desliga_pressor(); 
079A0:  RCALL  7796
....................             motor_run_z(0, 19); 
079A2:  MOVLB  5
079A4:  CLRF   x7F
079A6:  CLRF   x7E
079A8:  CLRF   x7D
079AA:  CLRF   x7C
079AC:  MOVLW  13
079AE:  MOVWF  x80
079B0:  MOVLB  0
079B2:  CALL   63C2
....................             while ((run_flg_z)); 
079B6:  MOVLB  3
079B8:  BTFSC  xB7.2
079BA:  BRA    79B8
....................             ponteiro_lcd = 1; 
079BC:  MOVLW  01
079BE:  MOVWF  21
....................             inicial_lcd = 0; 
079C0:  CLRF   22
....................             final_lcd = 3; 
079C2:  MOVLW  03
079C4:  MOVWF  23
....................             contador_lcd = 0; 
079C6:  CLRF   24
....................             menu_atual = menu_seleciona_debug; 
079C8:  MOVLW  02
079CA:  MOVWF  1C
....................             tela_seleciona_debug(); 
079CC:  MOVLB  0
079CE:  CALL   709A
....................         break; 
....................     } 
079D2:  GOTO   DAC2 (RETURN)
.................... } 
.................... void atualiza_tela_dados_ponto(){ 
....................     short f; 
....................     switch (Teclado()){ 
*
095CE:  CALL   5B66
095D2:  MOVF   01,W
095D4:  ADDLW  EC
095D6:  BTFSC  FD8.0
095D8:  GOTO   A0FA
095DC:  ADDLW  14
095DE:  GOTO   A0FE
....................         case SETA_SUPERIOR: 
....................             if (y[contador_lcd] > 0){ 
095E2:  BCF    FD8.0
095E4:  RLCF   24,W
095E6:  CLRF   03
095E8:  ADDLW  59
095EA:  MOVWF  FE9
095EC:  MOVLW  00
095EE:  ADDWFC 03,W
095F0:  MOVWF  FEA
095F2:  MOVFF  FEC,576
095F6:  MOVF   FED,F
095F8:  MOVFF  FEF,575
095FC:  MOVLB  5
095FE:  MOVF   x75,F
09600:  BNZ   9606
09602:  MOVF   x76,F
09604:  BZ    96CA
....................                 y[contador_lcd] = y[contador_lcd] - incremento; 
09606:  BCF    FD8.0
09608:  RLCF   24,W
0960A:  CLRF   03
0960C:  ADDLW  59
0960E:  MOVWF  01
09610:  MOVLW  00
09612:  ADDWFC 03,F
09614:  MOVFF  03,576
09618:  BCF    FD8.0
0961A:  RLCF   24,W
0961C:  CLRF   03
0961E:  ADDLW  59
09620:  MOVWF  FE9
09622:  MOVLW  00
09624:  ADDWFC 03,W
09626:  MOVWF  FEA
09628:  MOVFF  FEC,578
0962C:  MOVF   FED,F
0962E:  MOVFF  FEF,577
09632:  CLRF   03
09634:  MOVF   25,W
09636:  MOVWF  00
09638:  BTFSC  FE8.7
0963A:  DECF   03,F
0963C:  SUBWF  x77,W
0963E:  MOVWF  00
09640:  MOVF   03,W
09642:  SUBWFB x78,W
09644:  MOVFF  576,FEA
09648:  MOVFF  01,FE9
0964C:  MOVWF  FEC
0964E:  MOVF   FED,F
09650:  MOVFF  00,FEF
....................                 if (y[contador_lcd] <= 0) { 
09654:  BCF    FD8.0
09656:  RLCF   24,W
09658:  CLRF   03
0965A:  ADDLW  59
0965C:  MOVWF  FE9
0965E:  MOVLW  00
09660:  ADDWFC 03,W
09662:  MOVWF  FEA
09664:  MOVFF  FEC,576
09668:  MOVF   FED,F
0966A:  MOVFF  FEF,575
0966E:  MOVF   x75,F
09670:  BNZ   9692
09672:  MOVF   x76,F
09674:  BNZ   9692
....................                     motor_run_y(0,19); 
09676:  CLRF   x7F
09678:  CLRF   x7E
0967A:  CLRF   x7D
0967C:  CLRF   x7C
0967E:  MOVLW  13
09680:  MOVWF  x80
09682:  MOVLB  0
09684:  CALL   6622
....................                     while ((run_flg_y)); 
09688:  MOVLB  2
0968A:  BTFSC  x0B.7
0968C:  BRA    968A
....................                 } else { 
0968E:  BRA    96C8
09690:  MOVLB  5
....................                     motor_run_y(y[contador_lcd],19); 
09692:  BCF    FD8.0
09694:  RLCF   24,W
09696:  CLRF   03
09698:  ADDLW  59
0969A:  MOVWF  FE9
0969C:  MOVLW  00
0969E:  ADDWFC 03,W
096A0:  MOVWF  FEA
096A2:  MOVFF  FEC,576
096A6:  MOVF   FED,F
096A8:  MOVFF  FEF,575
096AC:  CLRF   x7F
096AE:  CLRF   x7E
096B0:  MOVFF  576,57D
096B4:  MOVFF  575,57C
096B8:  MOVLW  13
096BA:  MOVWF  x80
096BC:  MOVLB  0
096BE:  CALL   6622
....................                     while ((run_flg_y)); 
096C2:  MOVLB  2
096C4:  BTFSC  x0B.7
096C6:  BRA    96C4
096C8:  MOVLB  5
....................                 }             
....................             } 
....................             menu_atual = menu_dados_ponto; 
096CA:  MOVLW  10
096CC:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
096CE:  MOVFF  24,575
096D2:  MOVLB  0
096D4:  CALL   7560
....................         break; 
096D8:  GOTO   A0FA
....................         case SETA_INFERIOR: 
....................             y[contador_lcd] = y[contador_lcd] + incremento; 
096DC:  BCF    FD8.0
096DE:  RLCF   24,W
096E0:  CLRF   03
096E2:  ADDLW  59
096E4:  MOVWF  01
096E6:  MOVLW  00
096E8:  ADDWFC 03,F
096EA:  MOVFF  01,575
096EE:  MOVLB  5
096F0:  MOVFF  03,576
096F4:  BCF    FD8.0
096F6:  RLCF   24,W
096F8:  CLRF   03
096FA:  ADDLW  59
096FC:  MOVWF  FE9
096FE:  MOVLW  00
09700:  ADDWFC 03,W
09702:  MOVWF  FEA
09704:  MOVFF  FEC,578
09708:  MOVF   FED,F
0970A:  MOVFF  FEF,577
0970E:  CLRF   03
09710:  MOVF   25,W
09712:  BTFSC  FE8.7
09714:  DECF   03,F
09716:  ADDWF  x77,W
09718:  MOVWF  01
0971A:  MOVF   x78,W
0971C:  ADDWFC 03,F
0971E:  MOVFF  576,FEA
09722:  MOVFF  575,FE9
09726:  MOVFF  03,FEC
0972A:  MOVF   FED,F
0972C:  MOVFF  01,FEF
....................             motor_run_y(y[contador_lcd],19); 
09730:  BCF    FD8.0
09732:  RLCF   24,W
09734:  CLRF   03
09736:  ADDLW  59
09738:  MOVWF  FE9
0973A:  MOVLW  00
0973C:  ADDWFC 03,W
0973E:  MOVWF  FEA
09740:  MOVFF  FEC,576
09744:  MOVF   FED,F
09746:  MOVFF  FEF,575
0974A:  CLRF   x7F
0974C:  CLRF   x7E
0974E:  MOVFF  576,57D
09752:  MOVFF  575,57C
09756:  MOVLW  13
09758:  MOVWF  x80
0975A:  MOVLB  0
0975C:  CALL   6622
....................             while ((run_flg_y)); 
09760:  MOVLB  2
09762:  BTFSC  x0B.7
09764:  BRA    9762
....................             menu_atual = menu_dados_ponto; 
09766:  MOVLW  10
09768:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
0976A:  MOVFF  24,575
0976E:  MOVLB  0
09770:  CALL   7560
....................         break; 
09774:  GOTO   A0FA
....................         case SETA_DIREITA: 
....................             x[contador_lcd] = x[contador_lcd] + incremento; 
09778:  BCF    FD8.0
0977A:  RLCF   24,W
0977C:  CLRF   03
0977E:  ADDLW  2F
09780:  MOVWF  01
09782:  MOVLW  00
09784:  ADDWFC 03,F
09786:  MOVFF  01,575
0978A:  MOVLB  5
0978C:  MOVFF  03,576
09790:  BCF    FD8.0
09792:  RLCF   24,W
09794:  CLRF   03
09796:  ADDLW  2F
09798:  MOVWF  FE9
0979A:  MOVLW  00
0979C:  ADDWFC 03,W
0979E:  MOVWF  FEA
097A0:  MOVFF  FEC,578
097A4:  MOVF   FED,F
097A6:  MOVFF  FEF,577
097AA:  CLRF   03
097AC:  MOVF   25,W
097AE:  BTFSC  FE8.7
097B0:  DECF   03,F
097B2:  ADDWF  x77,W
097B4:  MOVWF  01
097B6:  MOVF   x78,W
097B8:  ADDWFC 03,F
097BA:  MOVFF  576,FEA
097BE:  MOVFF  575,FE9
097C2:  MOVFF  03,FEC
097C6:  MOVF   FED,F
097C8:  MOVFF  01,FEF
....................             motor_run_x(x[contador_lcd],19); 
097CC:  BCF    FD8.0
097CE:  RLCF   24,W
097D0:  CLRF   03
097D2:  ADDLW  2F
097D4:  MOVWF  FE9
097D6:  MOVLW  00
097D8:  ADDWFC 03,W
097DA:  MOVWF  FEA
097DC:  MOVFF  FEC,576
097E0:  MOVF   FED,F
097E2:  MOVFF  FEF,575
097E6:  CLRF   x7F
097E8:  CLRF   x7E
097EA:  MOVFF  576,57D
097EE:  MOVFF  575,57C
097F2:  MOVLW  13
097F4:  MOVWF  x80
097F6:  MOVLB  0
097F8:  CALL   55F6
....................             while ((run_flg_x)); 
097FC:  MOVLB  2
097FE:  BTFSC  x0B.5
09800:  BRA    97FE
....................             menu_atual = menu_dados_ponto; 
09802:  MOVLW  10
09804:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
09806:  MOVFF  24,575
0980A:  MOVLB  0
0980C:  CALL   7560
....................         break; 
09810:  GOTO   A0FA
....................         case SETA_ESQUERDA: 
....................             if (x[contador_lcd] > 0){ 
09814:  BCF    FD8.0
09816:  RLCF   24,W
09818:  CLRF   03
0981A:  ADDLW  2F
0981C:  MOVWF  FE9
0981E:  MOVLW  00
09820:  ADDWFC 03,W
09822:  MOVWF  FEA
09824:  MOVFF  FEC,576
09828:  MOVF   FED,F
0982A:  MOVFF  FEF,575
0982E:  MOVLB  5
09830:  MOVF   x75,F
09832:  BNZ   9838
09834:  MOVF   x76,F
09836:  BZ    98FC
....................                 x[contador_lcd] = x[contador_lcd] - incremento; 
09838:  BCF    FD8.0
0983A:  RLCF   24,W
0983C:  CLRF   03
0983E:  ADDLW  2F
09840:  MOVWF  01
09842:  MOVLW  00
09844:  ADDWFC 03,F
09846:  MOVFF  03,576
0984A:  BCF    FD8.0
0984C:  RLCF   24,W
0984E:  CLRF   03
09850:  ADDLW  2F
09852:  MOVWF  FE9
09854:  MOVLW  00
09856:  ADDWFC 03,W
09858:  MOVWF  FEA
0985A:  MOVFF  FEC,578
0985E:  MOVF   FED,F
09860:  MOVFF  FEF,577
09864:  CLRF   03
09866:  MOVF   25,W
09868:  MOVWF  00
0986A:  BTFSC  FE8.7
0986C:  DECF   03,F
0986E:  SUBWF  x77,W
09870:  MOVWF  00
09872:  MOVF   03,W
09874:  SUBWFB x78,W
09876:  MOVFF  576,FEA
0987A:  MOVFF  01,FE9
0987E:  MOVWF  FEC
09880:  MOVF   FED,F
09882:  MOVFF  00,FEF
....................                 if (x[contador_lcd] <= 0){ 
09886:  BCF    FD8.0
09888:  RLCF   24,W
0988A:  CLRF   03
0988C:  ADDLW  2F
0988E:  MOVWF  FE9
09890:  MOVLW  00
09892:  ADDWFC 03,W
09894:  MOVWF  FEA
09896:  MOVFF  FEC,576
0989A:  MOVF   FED,F
0989C:  MOVFF  FEF,575
098A0:  MOVF   x75,F
098A2:  BNZ   98C4
098A4:  MOVF   x76,F
098A6:  BNZ   98C4
....................                     motor_run_x(0,19); 
098A8:  CLRF   x7F
098AA:  CLRF   x7E
098AC:  CLRF   x7D
098AE:  CLRF   x7C
098B0:  MOVLW  13
098B2:  MOVWF  x80
098B4:  MOVLB  0
098B6:  CALL   55F6
....................                     while ((run_flg_x)); 
098BA:  MOVLB  2
098BC:  BTFSC  x0B.5
098BE:  BRA    98BC
....................                 } else{ 
098C0:  BRA    98FA
098C2:  MOVLB  5
....................                     motor_run_x(x[contador_lcd],19); 
098C4:  BCF    FD8.0
098C6:  RLCF   24,W
098C8:  CLRF   03
098CA:  ADDLW  2F
098CC:  MOVWF  FE9
098CE:  MOVLW  00
098D0:  ADDWFC 03,W
098D2:  MOVWF  FEA
098D4:  MOVFF  FEC,576
098D8:  MOVF   FED,F
098DA:  MOVFF  FEF,575
098DE:  CLRF   x7F
098E0:  CLRF   x7E
098E2:  MOVFF  576,57D
098E6:  MOVFF  575,57C
098EA:  MOVLW  13
098EC:  MOVWF  x80
098EE:  MOVLB  0
098F0:  CALL   55F6
....................                     while ((run_flg_x)); 
098F4:  MOVLB  2
098F6:  BTFSC  x0B.5
098F8:  BRA    98F6
098FA:  MOVLB  5
....................                 }                 
....................             } 
....................             menu_atual = menu_dados_ponto; 
098FC:  MOVLW  10
098FE:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
09900:  MOVFF  24,575
09904:  MOVLB  0
09906:  CALL   7560
....................         break; 
0990A:  GOTO   A0FA
....................         case F2: 
....................             if (z[contador_lcd] > 0){ 
0990E:  BCF    FD8.0
09910:  RLCF   24,W
09912:  CLRF   03
09914:  ADDLW  83
09916:  MOVWF  FE9
09918:  MOVLW  00
0991A:  ADDWFC 03,W
0991C:  MOVWF  FEA
0991E:  MOVFF  FEC,576
09922:  MOVF   FED,F
09924:  MOVFF  FEF,575
09928:  MOVLB  5
0992A:  MOVF   x75,F
0992C:  BNZ   9932
0992E:  MOVF   x76,F
09930:  BZ    99F6
....................                 z[contador_lcd] = z[contador_lcd] -incremento; 
09932:  BCF    FD8.0
09934:  RLCF   24,W
09936:  CLRF   03
09938:  ADDLW  83
0993A:  MOVWF  01
0993C:  MOVLW  00
0993E:  ADDWFC 03,F
09940:  MOVFF  03,576
09944:  BCF    FD8.0
09946:  RLCF   24,W
09948:  CLRF   03
0994A:  ADDLW  83
0994C:  MOVWF  FE9
0994E:  MOVLW  00
09950:  ADDWFC 03,W
09952:  MOVWF  FEA
09954:  MOVFF  FEC,578
09958:  MOVF   FED,F
0995A:  MOVFF  FEF,577
0995E:  CLRF   03
09960:  MOVF   25,W
09962:  MOVWF  00
09964:  BTFSC  FE8.7
09966:  DECF   03,F
09968:  SUBWF  x77,W
0996A:  MOVWF  00
0996C:  MOVF   03,W
0996E:  SUBWFB x78,W
09970:  MOVFF  576,FEA
09974:  MOVFF  01,FE9
09978:  MOVWF  FEC
0997A:  MOVF   FED,F
0997C:  MOVFF  00,FEF
....................                 if (z[contador_lcd] <= 0){ 
09980:  BCF    FD8.0
09982:  RLCF   24,W
09984:  CLRF   03
09986:  ADDLW  83
09988:  MOVWF  FE9
0998A:  MOVLW  00
0998C:  ADDWFC 03,W
0998E:  MOVWF  FEA
09990:  MOVFF  FEC,576
09994:  MOVF   FED,F
09996:  MOVFF  FEF,575
0999A:  MOVF   x75,F
0999C:  BNZ   99BE
0999E:  MOVF   x76,F
099A0:  BNZ   99BE
....................                     motor_run_z(0,19); 
099A2:  CLRF   x7F
099A4:  CLRF   x7E
099A6:  CLRF   x7D
099A8:  CLRF   x7C
099AA:  MOVLW  13
099AC:  MOVWF  x80
099AE:  MOVLB  0
099B0:  CALL   63C2
....................                     while ((run_flg_z)); 
099B4:  MOVLB  3
099B6:  BTFSC  xB7.2
099B8:  BRA    99B6
....................                 } else { 
099BA:  BRA    99F4
099BC:  MOVLB  5
....................                     motor_run_z(z[contador_lcd],19); 
099BE:  BCF    FD8.0
099C0:  RLCF   24,W
099C2:  CLRF   03
099C4:  ADDLW  83
099C6:  MOVWF  FE9
099C8:  MOVLW  00
099CA:  ADDWFC 03,W
099CC:  MOVWF  FEA
099CE:  MOVFF  FEC,576
099D2:  MOVF   FED,F
099D4:  MOVFF  FEF,575
099D8:  CLRF   x7F
099DA:  CLRF   x7E
099DC:  MOVFF  576,57D
099E0:  MOVFF  575,57C
099E4:  MOVLW  13
099E6:  MOVWF  x80
099E8:  MOVLB  0
099EA:  CALL   63C2
....................                     while ((run_flg_z)); 
099EE:  MOVLB  3
099F0:  BTFSC  xB7.2
099F2:  BRA    99F0
099F4:  MOVLB  5
....................                 } 
....................             } 
....................             menu_atual = menu_dados_ponto; 
099F6:  MOVLW  10
099F8:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
099FA:  MOVFF  24,575
099FE:  MOVLB  0
09A00:  CALL   7560
....................         break; 
09A04:  BRA    A0FA
....................         case F4:        
....................             z[contador_lcd] = z[contador_lcd] +incremento; 
09A06:  BCF    FD8.0
09A08:  RLCF   24,W
09A0A:  CLRF   03
09A0C:  ADDLW  83
09A0E:  MOVWF  01
09A10:  MOVLW  00
09A12:  ADDWFC 03,F
09A14:  MOVFF  01,575
09A18:  MOVLB  5
09A1A:  MOVFF  03,576
09A1E:  BCF    FD8.0
09A20:  RLCF   24,W
09A22:  CLRF   03
09A24:  ADDLW  83
09A26:  MOVWF  FE9
09A28:  MOVLW  00
09A2A:  ADDWFC 03,W
09A2C:  MOVWF  FEA
09A2E:  MOVFF  FEC,578
09A32:  MOVF   FED,F
09A34:  MOVFF  FEF,577
09A38:  CLRF   03
09A3A:  MOVF   25,W
09A3C:  BTFSC  FE8.7
09A3E:  DECF   03,F
09A40:  ADDWF  x77,W
09A42:  MOVWF  01
09A44:  MOVF   x78,W
09A46:  ADDWFC 03,F
09A48:  MOVFF  576,FEA
09A4C:  MOVFF  575,FE9
09A50:  MOVFF  03,FEC
09A54:  MOVF   FED,F
09A56:  MOVFF  01,FEF
....................             motor_run_z(z[contador_lcd],19); 
09A5A:  BCF    FD8.0
09A5C:  RLCF   24,W
09A5E:  CLRF   03
09A60:  ADDLW  83
09A62:  MOVWF  FE9
09A64:  MOVLW  00
09A66:  ADDWFC 03,W
09A68:  MOVWF  FEA
09A6A:  MOVFF  FEC,576
09A6E:  MOVF   FED,F
09A70:  MOVFF  FEF,575
09A74:  CLRF   x7F
09A76:  CLRF   x7E
09A78:  MOVFF  576,57D
09A7C:  MOVFF  575,57C
09A80:  MOVLW  13
09A82:  MOVWF  x80
09A84:  MOVLB  0
09A86:  CALL   63C2
....................             while ((run_flg_z)); 
09A8A:  MOVLB  3
09A8C:  BTFSC  xB7.2
09A8E:  BRA    9A8C
....................             menu_atual = menu_dados_ponto; 
09A90:  MOVLW  10
09A92:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
09A94:  MOVFF  24,575
09A98:  MOVLB  0
09A9A:  CALL   7560
....................         break; 
09A9E:  BRA    A0FA
....................         case 1: 
....................             switch (tipo[contador_lcd]){ 
09AA0:  BCF    FD8.0
09AA2:  RLCF   24,W
09AA4:  CLRF   03
09AA6:  ADDLW  01
09AA8:  MOVWF  FE9
09AAA:  MOVLW  01
09AAC:  ADDWFC 03,W
09AAE:  MOVWF  FEA
09AB0:  MOVFF  FEF,00
09AB4:  INCF   FE9,F
09AB6:  MOVF   FEF,W
09AB8:  DECF   FE9,F
09ABA:  MOVWF  03
09ABC:  MOVF   03,W
09ABE:  BNZ   9AC4
09AC0:  MOVF   00,F
09AC2:  BZ    9AD0
09AC4:  MOVF   03,W
09AC6:  BNZ   9ACE
09AC8:  MOVLW  01
09ACA:  SUBWF  00,W
09ACC:  BZ    9AEA
09ACE:  BRA    9B00
....................                 case 0: 
....................                     tipo[contador_lcd] = 1; 
09AD0:  BCF    FD8.0
09AD2:  RLCF   24,W
09AD4:  CLRF   03
09AD6:  ADDLW  01
09AD8:  MOVWF  FE9
09ADA:  MOVLW  01
09ADC:  ADDWFC 03,W
09ADE:  MOVWF  FEA
09AE0:  CLRF   FEC
09AE2:  MOVF   FED,F
09AE4:  MOVLW  01
09AE6:  MOVWF  FEF
....................                 break; 
09AE8:  BRA    9B00
....................                 case 1: 
....................                     tipo[contador_lcd] = 0; 
09AEA:  BCF    FD8.0
09AEC:  RLCF   24,W
09AEE:  CLRF   03
09AF0:  ADDLW  01
09AF2:  MOVWF  FE9
09AF4:  MOVLW  01
09AF6:  ADDWFC 03,W
09AF8:  MOVWF  FEA
09AFA:  CLRF   FEC
09AFC:  MOVF   FED,F
09AFE:  CLRF   FEF
....................                 break; 
....................             } 
....................             menu_atual = menu_dados_ponto; 
09B00:  MOVLW  10
09B02:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
09B04:  MOVFF  24,575
09B08:  CALL   7560
....................         break; 
09B0C:  BRA    A0FA
....................         case 2: 
....................             if (habilitado[contador_lcd] == TRUE){ 
09B0E:  BCF    FD8.0
09B10:  RLCF   24,W
09B12:  CLRF   03
09B14:  ADDLW  2D
09B16:  MOVWF  FE9
09B18:  MOVLW  01
09B1A:  ADDWFC 03,W
09B1C:  MOVWF  FEA
09B1E:  MOVFF  FEC,576
09B22:  MOVF   FED,F
09B24:  MOVFF  FEF,575
09B28:  MOVLB  5
09B2A:  DECFSZ x75,W
09B2C:  BRA    9B4A
09B2E:  MOVF   x76,F
09B30:  BNZ   9B4A
....................                 habilitado[contador_lcd] = FALSE; 
09B32:  BCF    FD8.0
09B34:  RLCF   24,W
09B36:  CLRF   03
09B38:  ADDLW  2D
09B3A:  MOVWF  FE9
09B3C:  MOVLW  01
09B3E:  ADDWFC 03,W
09B40:  MOVWF  FEA
09B42:  CLRF   FEC
09B44:  MOVF   FED,F
09B46:  CLRF   FEF
....................             } else { 
09B48:  BRA    9B62
....................                 habilitado[contador_lcd] = TRUE; 
09B4A:  BCF    FD8.0
09B4C:  RLCF   24,W
09B4E:  CLRF   03
09B50:  ADDLW  2D
09B52:  MOVWF  FE9
09B54:  MOVLW  01
09B56:  ADDWFC 03,W
09B58:  MOVWF  FEA
09B5A:  CLRF   FEC
09B5C:  MOVF   FED,F
09B5E:  MOVLW  01
09B60:  MOVWF  FEF
....................             }             
....................             menu_atual = menu_dados_ponto; 
09B62:  MOVLW  10
09B64:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
09B66:  MOVFF  24,575
09B6A:  MOVLB  0
09B6C:  CALL   7560
....................         break; 
09B70:  BRA    A0FA
....................         case 8:           
....................             sobe_ferros(); 
09B72:  CALL   7A06
....................             desliga_pressor(); 
09B76:  CALL   7796
....................         break; 
09B7A:  BRA    A0FA
....................         case 0: 
....................             sobe_ferros(); 
09B7C:  CALL   7A06
....................             if (numeroFerros[contador_lcd] == 0){ 
09B80:  BCF    FD8.0
09B82:  RLCF   24,W
09B84:  CLRF   03
09B86:  ADDLW  57
09B88:  MOVWF  FE9
09B8A:  MOVLW  01
09B8C:  ADDWFC 03,W
09B8E:  MOVWF  FEA
09B90:  MOVFF  FEC,576
09B94:  MOVF   FED,F
09B96:  MOVFF  FEF,575
09B9A:  MOVLB  5
09B9C:  MOVF   x75,F
09B9E:  BNZ   9BAE
09BA0:  MOVF   x76,F
09BA2:  BNZ   9BAE
....................                 desce_ferros(0); 
09BA4:  CLRF   x7C
09BA6:  MOVLB  0
09BA8:  CALL   7A24
09BAC:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){ 
09BAE:  BCF    FD8.0
09BB0:  RLCF   24,W
09BB2:  CLRF   03
09BB4:  ADDLW  57
09BB6:  MOVWF  FE9
09BB8:  MOVLW  01
09BBA:  ADDWFC 03,W
09BBC:  MOVWF  FEA
09BBE:  MOVFF  FEC,576
09BC2:  MOVF   FED,F
09BC4:  MOVFF  FEF,575
09BC8:  DECFSZ x75,W
09BCA:  BRA    9BDC
09BCC:  MOVF   x76,F
09BCE:  BNZ   9BDC
....................                 desce_ferros(1); 
09BD0:  MOVLW  01
09BD2:  MOVWF  x7C
09BD4:  MOVLB  0
09BD6:  CALL   7A24
09BDA:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){ 
09BDC:  BCF    FD8.0
09BDE:  RLCF   24,W
09BE0:  CLRF   03
09BE2:  ADDLW  57
09BE4:  MOVWF  FE9
09BE6:  MOVLW  01
09BE8:  ADDWFC 03,W
09BEA:  MOVWF  FEA
09BEC:  MOVFF  FEC,576
09BF0:  MOVF   FED,F
09BF2:  MOVFF  FEF,575
09BF6:  MOVF   x75,W
09BF8:  SUBLW  02
09BFA:  BNZ   9C0C
09BFC:  MOVF   x76,F
09BFE:  BNZ   9C0C
....................                 desce_ferros(2); 
09C00:  MOVLW  02
09C02:  MOVWF  x7C
09C04:  MOVLB  0
09C06:  CALL   7A24
09C0A:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
09C0C:  BCF    FD8.0
09C0E:  RLCF   24,W
09C10:  CLRF   03
09C12:  ADDLW  57
09C14:  MOVWF  FE9
09C16:  MOVLW  01
09C18:  ADDWFC 03,W
09C1A:  MOVWF  FEA
09C1C:  MOVFF  FEC,576
09C20:  MOVF   FED,F
09C22:  MOVFF  FEF,575
09C26:  MOVF   x75,W
09C28:  SUBLW  03
09C2A:  BNZ   9C3C
09C2C:  MOVF   x76,F
09C2E:  BNZ   9C3C
....................                 desce_ferros(3); 
09C30:  MOVLW  03
09C32:  MOVWF  x7C
09C34:  MOVLB  0
09C36:  CALL   7A24
09C3A:  MOVLB  5
....................             } 
....................             liga_pressor(); 
09C3C:  MOVLB  0
09C3E:  CALL   7A76
....................         break; 
09C42:  BRA    A0FA
....................         case 3: 
....................             switch (numeroFerros[contador_lcd]){ 
09C44:  BCF    FD8.0
09C46:  RLCF   24,W
09C48:  CLRF   03
09C4A:  ADDLW  57
09C4C:  MOVWF  FE9
09C4E:  MOVLW  01
09C50:  ADDWFC 03,W
09C52:  MOVWF  FEA
09C54:  MOVFF  FEF,00
09C58:  INCF   FE9,F
09C5A:  MOVF   FEF,W
09C5C:  DECF   FE9,F
09C5E:  MOVWF  03
09C60:  MOVF   03,W
09C62:  BNZ   9C68
09C64:  MOVF   00,F
09C66:  BZ    9C88
09C68:  MOVF   03,W
09C6A:  BNZ   9C72
09C6C:  MOVLW  01
09C6E:  SUBWF  00,W
09C70:  BZ    9CA2
09C72:  MOVF   03,W
09C74:  BNZ   9C7C
09C76:  MOVLW  02
09C78:  SUBWF  00,W
09C7A:  BZ    9CBC
09C7C:  MOVF   03,W
09C7E:  BNZ   9C86
09C80:  MOVLW  03
09C82:  SUBWF  00,W
09C84:  BZ    9CD6
09C86:  BRA    9CEC
....................                 case 0: 
....................                     numeroFerros[contador_lcd] = 1; 
09C88:  BCF    FD8.0
09C8A:  RLCF   24,W
09C8C:  CLRF   03
09C8E:  ADDLW  57
09C90:  MOVWF  FE9
09C92:  MOVLW  01
09C94:  ADDWFC 03,W
09C96:  MOVWF  FEA
09C98:  CLRF   FEC
09C9A:  MOVF   FED,F
09C9C:  MOVLW  01
09C9E:  MOVWF  FEF
....................                 break; 
09CA0:  BRA    9CEC
....................                 case 1: 
....................                     numeroFerros[contador_lcd] = 2; 
09CA2:  BCF    FD8.0
09CA4:  RLCF   24,W
09CA6:  CLRF   03
09CA8:  ADDLW  57
09CAA:  MOVWF  FE9
09CAC:  MOVLW  01
09CAE:  ADDWFC 03,W
09CB0:  MOVWF  FEA
09CB2:  CLRF   FEC
09CB4:  MOVF   FED,F
09CB6:  MOVLW  02
09CB8:  MOVWF  FEF
....................                 break; 
09CBA:  BRA    9CEC
....................                 case 2: 
....................                     numeroFerros[contador_lcd] = 3; 
09CBC:  BCF    FD8.0
09CBE:  RLCF   24,W
09CC0:  CLRF   03
09CC2:  ADDLW  57
09CC4:  MOVWF  FE9
09CC6:  MOVLW  01
09CC8:  ADDWFC 03,W
09CCA:  MOVWF  FEA
09CCC:  CLRF   FEC
09CCE:  MOVF   FED,F
09CD0:  MOVLW  03
09CD2:  MOVWF  FEF
....................                 break; 
09CD4:  BRA    9CEC
....................                 case 3: 
....................                     numeroFerros[contador_lcd] = 0; 
09CD6:  BCF    FD8.0
09CD8:  RLCF   24,W
09CDA:  CLRF   03
09CDC:  ADDLW  57
09CDE:  MOVWF  FE9
09CE0:  MOVLW  01
09CE2:  ADDWFC 03,W
09CE4:  MOVWF  FEA
09CE6:  CLRF   FEC
09CE8:  MOVF   FED,F
09CEA:  CLRF   FEF
....................                 break; 
....................             }             
....................             menu_atual = menu_dados_ponto; 
09CEC:  MOVLW  10
09CEE:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
09CF0:  MOVFF  24,575
09CF4:  CALL   7560
....................         break; 
09CF8:  BRA    A0FA
....................         case 4: 
....................             switch (incremento){ 
09CFA:  MOVF   25,W
09CFC:  XORLW  01
09CFE:  BZ    9D0A
09D00:  XORLW  0B
09D02:  BZ    9D10
09D04:  XORLW  38
09D06:  BZ    9D16
09D08:  BRA    9D1A
....................                 case 1: 
....................                     incremento = 10; 
09D0A:  MOVLW  0A
09D0C:  MOVWF  25
....................                 break; 
09D0E:  BRA    9D1A
....................                 case 10: 
....................                     incremento = 50; 
09D10:  MOVLW  32
09D12:  MOVWF  25
....................                 break; 
09D14:  BRA    9D1A
....................                 case 50: 
....................                     incremento = 1; 
09D16:  MOVLW  01
09D18:  MOVWF  25
....................                 break; 
....................             }             
....................             menu_atual = menu_dados_ponto; 
09D1A:  MOVLW  10
09D1C:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
09D1E:  MOVFF  24,575
09D22:  CALL   7560
....................         break; 
09D26:  BRA    A0FA
....................         case 5: 
....................             switch (limpar[contador_lcd]){ 
09D28:  BCF    FD8.0
09D2A:  RLCF   24,W
09D2C:  CLRF   03
09D2E:  ADDLW  D5
09D30:  MOVWF  FE9
09D32:  MOVLW  01
09D34:  ADDWFC 03,W
09D36:  MOVWF  FEA
09D38:  MOVFF  FEF,00
09D3C:  INCF   FE9,F
09D3E:  MOVF   FEF,W
09D40:  DECF   FE9,F
09D42:  MOVWF  03
09D44:  MOVF   03,W
09D46:  BNZ   9D4C
09D48:  MOVF   00,F
09D4A:  BZ    9D58
09D4C:  MOVF   03,W
09D4E:  BNZ   9D56
09D50:  MOVLW  01
09D52:  SUBWF  00,W
09D54:  BZ    9D72
09D56:  BRA    9D88
....................                 case 0: 
....................                     limpar[contador_lcd] = 1; 
09D58:  BCF    FD8.0
09D5A:  RLCF   24,W
09D5C:  CLRF   03
09D5E:  ADDLW  D5
09D60:  MOVWF  FE9
09D62:  MOVLW  01
09D64:  ADDWFC 03,W
09D66:  MOVWF  FEA
09D68:  CLRF   FEC
09D6A:  MOVF   FED,F
09D6C:  MOVLW  01
09D6E:  MOVWF  FEF
....................                 break; 
09D70:  BRA    9D88
....................                 case 1: 
....................                     limpar[contador_lcd] = 0; 
09D72:  BCF    FD8.0
09D74:  RLCF   24,W
09D76:  CLRF   03
09D78:  ADDLW  D5
09D7A:  MOVWF  FE9
09D7C:  MOVLW  01
09D7E:  ADDWFC 03,W
09D80:  MOVWF  FEA
09D82:  CLRF   FEC
09D84:  MOVF   FED,F
09D86:  CLRF   FEF
....................                 break; 
....................             }             
....................             menu_atual = menu_dados_ponto; 
09D88:  MOVLW  10
09D8A:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
09D8C:  MOVFF  24,575
09D90:  CALL   7560
....................         break;         
09D94:  BRA    A0FA
....................         case F1: 
....................             if ((numeroFerros[contador_lcd] == 0)||(numeroFerros[contador_lcd] == 2)){ 
09D96:  BCF    FD8.0
09D98:  RLCF   24,W
09D9A:  CLRF   03
09D9C:  ADDLW  57
09D9E:  MOVWF  FE9
09DA0:  MOVLW  01
09DA2:  ADDWFC 03,W
09DA4:  MOVWF  FEA
09DA6:  MOVFF  FEC,576
09DAA:  MOVF   FED,F
09DAC:  MOVFF  FEF,575
09DB0:  MOVLB  5
09DB2:  MOVF   x75,F
09DB4:  BNZ   9DBA
09DB6:  MOVF   x76,F
09DB8:  BZ    9DDE
09DBA:  BCF    FD8.0
09DBC:  RLCF   24,W
09DBE:  CLRF   03
09DC0:  ADDLW  57
09DC2:  MOVWF  FE9
09DC4:  MOVLW  01
09DC6:  ADDWFC 03,W
09DC8:  MOVWF  FEA
09DCA:  MOVFF  FEC,576
09DCE:  MOVF   FED,F
09DD0:  MOVFF  FEF,575
09DD4:  MOVF   x75,W
09DD6:  SUBLW  02
09DD8:  BNZ   9DF4
09DDA:  MOVF   x76,F
09DDC:  BNZ   9DF4
....................                 t_solda[contador_lcd] = 0; 
09DDE:  BCF    FD8.0
09DE0:  RLCF   24,W
09DE2:  CLRF   03
09DE4:  ADDLW  AD
09DE6:  MOVWF  FE9
09DE8:  MOVLW  00
09DEA:  ADDWFC 03,W
09DEC:  MOVWF  FEA
09DEE:  CLRF   FEC
09DF0:  MOVF   FED,F
09DF2:  CLRF   FEF
....................             } 
....................             if ((numeroFerros[contador_lcd] == 0)||(numeroFerros[contador_lcd] == 1)){ 
09DF4:  BCF    FD8.0
09DF6:  RLCF   24,W
09DF8:  CLRF   03
09DFA:  ADDLW  57
09DFC:  MOVWF  FE9
09DFE:  MOVLW  01
09E00:  ADDWFC 03,W
09E02:  MOVWF  FEA
09E04:  MOVFF  FEC,576
09E08:  MOVF   FED,F
09E0A:  MOVFF  FEF,575
09E0E:  MOVF   x75,F
09E10:  BNZ   9E16
09E12:  MOVF   x76,F
09E14:  BZ    9E38
09E16:  BCF    FD8.0
09E18:  RLCF   24,W
09E1A:  CLRF   03
09E1C:  ADDLW  57
09E1E:  MOVWF  FE9
09E20:  MOVLW  01
09E22:  ADDWFC 03,W
09E24:  MOVWF  FEA
09E26:  MOVFF  FEC,576
09E2A:  MOVF   FED,F
09E2C:  MOVFF  FEF,575
09E30:  DECFSZ x75,W
09E32:  BRA    9E4E
09E34:  MOVF   x76,F
09E36:  BNZ   9E4E
....................                 t_solda3[contador_lcd] = 0; 
09E38:  BCF    FD8.0
09E3A:  RLCF   24,W
09E3C:  CLRF   03
09E3E:  ADDLW  AB
09E40:  MOVWF  FE9
09E42:  MOVLW  01
09E44:  ADDWFC 03,W
09E46:  MOVWF  FEA
09E48:  CLRF   FEC
09E4A:  MOVF   FED,F
09E4C:  CLRF   FEF
....................             } 
....................             printf(lcd_putc, "\f"); // limpa display 
09E4E:  MOVLW  0C
09E50:  MOVWF  x85
09E52:  MOVLB  0
09E54:  CALL   2D30
....................             printf(lcd_putc, "   GRAVANDO PONTO   \n\r"); 
09E58:  MOVLW  70
09E5A:  MOVWF  FF6
09E5C:  MOVLW  0F
09E5E:  MOVWF  FF7
09E60:  CALL   2D86
....................             delay_ms(2000); 
09E64:  MOVLW  08
09E66:  MOVLB  5
09E68:  MOVWF  x75
09E6A:  MOVLW  FA
09E6C:  MOVWF  x91
09E6E:  MOVLB  0
09E70:  CALL   2954
09E74:  MOVLB  5
09E76:  DECFSZ x75,F
09E78:  BRA    9E6A
....................             escrever_ponto_memoria(modelo,contador_lcd); 
09E7A:  CLRF   x76
09E7C:  MOVFF  2E,575
09E80:  CLRF   x78
09E82:  MOVFF  24,577
09E86:  MOVLB  0
09E88:  CALL   7A86
....................             printf(lcd_putc, "\f"); // limpa display 
09E8C:  MOVLW  0C
09E8E:  MOVLB  5
09E90:  MOVWF  x85
09E92:  MOVLB  0
09E94:  CALL   2D30
....................             printf(lcd_putc, "    PONTO GRAVADO   \n\r"); 
09E98:  MOVLW  88
09E9A:  MOVWF  FF6
09E9C:  MOVLW  0F
09E9E:  MOVWF  FF7
09EA0:  CALL   2D86
....................             delay_ms(2000); 
09EA4:  MOVLW  08
09EA6:  MOVLB  5
09EA8:  MOVWF  x75
09EAA:  MOVLW  FA
09EAC:  MOVWF  x91
09EAE:  MOVLB  0
09EB0:  CALL   2954
09EB4:  MOVLB  5
09EB6:  DECFSZ x75,F
09EB8:  BRA    9EAA
....................             menu_atual = menu_seleciona_pontos; 
09EBA:  MOVLW  0F
09EBC:  MOVWF  1C
....................             tela_seleciona_pontos(); 
09EBE:  MOVLB  0
09EC0:  CALL   7464
....................             contador_lcd = 0; 
09EC4:  CLRF   24
....................             incremento = 1; 
09EC6:  MOVLW  01
09EC8:  MOVWF  25
....................             motor_run_z(0, 19); 
09ECA:  MOVLB  5
09ECC:  CLRF   x7F
09ECE:  CLRF   x7E
09ED0:  CLRF   x7D
09ED2:  CLRF   x7C
09ED4:  MOVLW  13
09ED6:  MOVWF  x80
09ED8:  MOVLB  0
09EDA:  CALL   63C2
....................             while ((run_flg_z)); 
09EDE:  MOVLB  3
09EE0:  BTFSC  xB7.2
09EE2:  BRA    9EE0
....................             sobe_ferros(); 
09EE4:  MOVLB  0
09EE6:  CALL   7A06
....................         break; 
09EEA:  BRA    A0FA
....................         case F3:             
....................             menu_atual = menu_dados_ponto_2; 
09EEC:  MOVLW  12
09EEE:  MOVWF  1C
....................             if (numeroFerros[contador_lcd] == 0){ 
09EF0:  BCF    FD8.0
09EF2:  RLCF   24,W
09EF4:  CLRF   03
09EF6:  ADDLW  57
09EF8:  MOVWF  FE9
09EFA:  MOVLW  01
09EFC:  ADDWFC 03,W
09EFE:  MOVWF  FEA
09F00:  MOVFF  FEC,576
09F04:  MOVF   FED,F
09F06:  MOVFF  FEF,575
09F0A:  MOVLB  5
09F0C:  MOVF   x75,F
09F0E:  BNZ   9F20
09F10:  MOVF   x76,F
09F12:  BNZ   9F20
....................                 tela_dados_ponto_5(contador_lcd); 
09F14:  MOVFF  24,575
09F18:  MOVLB  0
09F1A:  CALL   7FC8
09F1E:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){ 
09F20:  BCF    FD8.0
09F22:  RLCF   24,W
09F24:  CLRF   03
09F26:  ADDLW  57
09F28:  MOVWF  FE9
09F2A:  MOVLW  01
09F2C:  ADDWFC 03,W
09F2E:  MOVWF  FEA
09F30:  MOVFF  FEC,576
09F34:  MOVF   FED,F
09F36:  MOVFF  FEF,575
09F3A:  DECFSZ x75,W
09F3C:  BRA    9F4E
09F3E:  MOVF   x76,F
09F40:  BNZ   9F4E
....................                 tela_dados_ponto_4(contador_lcd); 
09F42:  MOVFF  24,575
09F46:  MOVLB  0
09F48:  CALL   80CA
09F4C:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){ 
09F4E:  BCF    FD8.0
09F50:  RLCF   24,W
09F52:  CLRF   03
09F54:  ADDLW  57
09F56:  MOVWF  FE9
09F58:  MOVLW  01
09F5A:  ADDWFC 03,W
09F5C:  MOVWF  FEA
09F5E:  MOVFF  FEC,576
09F62:  MOVF   FED,F
09F64:  MOVFF  FEF,575
09F68:  MOVF   x75,W
09F6A:  SUBLW  02
09F6C:  BNZ   9F7E
09F6E:  MOVF   x76,F
09F70:  BNZ   9F7E
....................                 tela_dados_ponto_3(contador_lcd); 
09F72:  MOVFF  24,575
09F76:  MOVLB  0
09F78:  CALL   820A
09F7C:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
09F7E:  BCF    FD8.0
09F80:  RLCF   24,W
09F82:  CLRF   03
09F84:  ADDLW  57
09F86:  MOVWF  FE9
09F88:  MOVLW  01
09F8A:  ADDWFC 03,W
09F8C:  MOVWF  FEA
09F8E:  MOVFF  FEC,576
09F92:  MOVF   FED,F
09F94:  MOVFF  FEF,575
09F98:  MOVF   x75,W
09F9A:  SUBLW  03
09F9C:  BNZ   9FAE
09F9E:  MOVF   x76,F
09FA0:  BNZ   9FAE
....................                 tela_dados_ponto_2(contador_lcd); 
09FA2:  MOVFF  24,575
09FA6:  MOVLB  0
09FA8:  CALL   834A
09FAC:  MOVLB  5
....................             } 
....................             incremento = 1; 
09FAE:  MOVLW  01
09FB0:  MOVWF  25
....................             motor_run_z(0, 19); 
09FB2:  CLRF   x7F
09FB4:  CLRF   x7E
09FB6:  CLRF   x7D
09FB8:  CLRF   x7C
09FBA:  MOVLW  13
09FBC:  MOVWF  x80
09FBE:  MOVLB  0
09FC0:  CALL   63C2
....................             while ((run_flg_z)); 
09FC4:  MOVLB  3
09FC6:  BTFSC  xB7.2
09FC8:  BRA    9FC6
....................             sobe_ferros(); 
09FCA:  MOVLB  0
09FCC:  CALL   7A06
....................         break; 
09FD0:  BRA    A0FA
....................         case ESC: 
....................             incremento = 1; 
09FD2:  MOVLW  01
09FD4:  MOVWF  25
....................             contador_lcd = 0; 
09FD6:  CLRF   24
....................             motor_run_z(0, 19); 
09FD8:  MOVLB  5
09FDA:  CLRF   x7F
09FDC:  CLRF   x7E
09FDE:  CLRF   x7D
09FE0:  CLRF   x7C
09FE2:  MOVLW  13
09FE4:  MOVWF  x80
09FE6:  MOVLB  0
09FE8:  CALL   63C2
....................             while ((run_flg_z)); 
09FEC:  MOVLB  3
09FEE:  BTFSC  xB7.2
09FF0:  BRA    9FEE
....................             sobe_ferros(); 
09FF2:  MOVLB  0
09FF4:  CALL   7A06
....................             menu_atual = menu_seleciona_pontos; 
09FF8:  MOVLW  0F
09FFA:  MOVWF  1C
....................             tela_seleciona_pontos(); 
09FFC:  CALL   7464
....................         break; 
0A000:  BRA    A0FA
....................         case ENTER: 
....................             incremento = 1; 
0A002:  MOVLW  01
0A004:  MOVWF  25
....................             f = statusSolda(); 
0A006:  CALL   84C8
0A00A:  MOVLB  5
0A00C:  BCF    x74.0
0A00E:  BTFSC  01.0
0A010:  BSF    x74.0
....................             if (f == 1){ 
0A012:  BTFSS  x74.0
0A014:  BRA    A042
....................                 soldar_teste(tipo[contador_lcd],contador_lcd); 
0A016:  BCF    FD8.0
0A018:  RLCF   24,W
0A01A:  CLRF   03
0A01C:  ADDLW  01
0A01E:  MOVWF  FE9
0A020:  MOVLW  01
0A022:  ADDWFC 03,W
0A024:  MOVWF  FEA
0A026:  MOVFF  FEC,576
0A02A:  MOVF   FED,F
0A02C:  MOVFF  FEF,575
0A030:  MOVFF  575,577
0A034:  MOVFF  24,578
0A038:  MOVLB  0
0A03A:  CALL   8EB6
....................             } else { 
0A03E:  BRA    A07C
0A040:  MOVLB  5
....................                 printf(lcd_putc, "\f"); // limpa display 
0A042:  MOVLW  0C
0A044:  MOVWF  x85
0A046:  MOVLB  0
0A048:  CALL   2D30
....................                 printf(lcd_putc, "    SEM SOLDA NOS   \n\r"); 
0A04C:  MOVLW  A0
0A04E:  MOVWF  FF6
0A050:  MOVLW  0F
0A052:  MOVWF  FF7
0A054:  CALL   2D86
....................                 printf(lcd_putc, "    ALIMENTADORES   \n\r"); 
0A058:  MOVLW  B8
0A05A:  MOVWF  FF6
0A05C:  MOVLW  0F
0A05E:  MOVWF  FF7
0A060:  CALL   2D86
....................                 delay_ms(1000); 
0A064:  MOVLW  04
0A066:  MOVLB  5
0A068:  MOVWF  x75
0A06A:  MOVLW  FA
0A06C:  MOVWF  x91
0A06E:  MOVLB  0
0A070:  CALL   2954
0A074:  MOVLB  5
0A076:  DECFSZ x75,F
0A078:  BRA    A06A
0A07A:  MOVLB  0
....................             } 
....................             motor_run_y(y[contador_lcd],19); 
0A07C:  BCF    FD8.0
0A07E:  RLCF   24,W
0A080:  CLRF   03
0A082:  ADDLW  59
0A084:  MOVWF  FE9
0A086:  MOVLW  00
0A088:  ADDWFC 03,W
0A08A:  MOVWF  FEA
0A08C:  MOVFF  FEC,576
0A090:  MOVF   FED,F
0A092:  MOVFF  FEF,575
0A096:  MOVLB  5
0A098:  CLRF   x7F
0A09A:  CLRF   x7E
0A09C:  MOVFF  576,57D
0A0A0:  MOVFF  575,57C
0A0A4:  MOVLW  13
0A0A6:  MOVWF  x80
0A0A8:  MOVLB  0
0A0AA:  CALL   6622
....................             while ((run_flg_y)); 
0A0AE:  MOVLB  2
0A0B0:  BTFSC  x0B.7
0A0B2:  BRA    A0B0
....................             motor_run_x(x[contador_lcd],19); 
0A0B4:  BCF    FD8.0
0A0B6:  RLCF   24,W
0A0B8:  CLRF   03
0A0BA:  ADDLW  2F
0A0BC:  MOVWF  FE9
0A0BE:  MOVLW  00
0A0C0:  ADDWFC 03,W
0A0C2:  MOVWF  FEA
0A0C4:  MOVFF  FEC,576
0A0C8:  MOVF   FED,F
0A0CA:  MOVFF  FEF,575
0A0CE:  MOVLB  5
0A0D0:  CLRF   x7F
0A0D2:  CLRF   x7E
0A0D4:  MOVFF  576,57D
0A0D8:  MOVFF  575,57C
0A0DC:  MOVLW  13
0A0DE:  MOVWF  x80
0A0E0:  MOVLB  0
0A0E2:  CALL   55F6
....................             while ((run_flg_x)); 
0A0E6:  MOVLB  2
0A0E8:  BTFSC  x0B.5
0A0EA:  BRA    A0E8
....................             menu_atual = menu_dados_ponto; 
0A0EC:  MOVLW  10
0A0EE:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
0A0F0:  MOVFF  24,575
0A0F4:  MOVLB  0
0A0F6:  CALL   7560
....................         break;  
....................     } 
0A0FA:  GOTO   DACA (RETURN)
.................... } 
.................... void atualiza_tela_dados_ponto_2(){ 
....................     short f; 
....................     switch (Teclado()){ 
*
0A14A:  CALL   5B66
0A14E:  MOVF   01,W
0A150:  ADDLW  EC
0A152:  BTFSC  FD8.0
0A154:  GOTO   B13A
0A158:  ADDLW  14
0A15A:  GOTO   B13E
....................         case 1: 
....................             if (numeroFerros[contador_lcd] == 1){ 
0A15E:  BCF    FD8.0
0A160:  RLCF   24,W
0A162:  CLRF   03
0A164:  ADDLW  57
0A166:  MOVWF  FE9
0A168:  MOVLW  01
0A16A:  ADDWFC 03,W
0A16C:  MOVWF  FEA
0A16E:  MOVFF  FEC,576
0A172:  MOVF   FED,F
0A174:  MOVFF  FEF,575
0A178:  MOVLB  5
0A17A:  DECFSZ x75,W
0A17C:  BRA    A1E0
0A17E:  MOVF   x76,F
0A180:  BNZ   A1E0
....................                 t_solda[contador_lcd] = t_solda[contador_lcd] + incremento; 
0A182:  BCF    FD8.0
0A184:  RLCF   24,W
0A186:  CLRF   03
0A188:  ADDLW  AD
0A18A:  MOVWF  01
0A18C:  MOVLW  00
0A18E:  ADDWFC 03,F
0A190:  MOVFF  01,575
0A194:  MOVFF  03,576
0A198:  BCF    FD8.0
0A19A:  RLCF   24,W
0A19C:  CLRF   03
0A19E:  ADDLW  AD
0A1A0:  MOVWF  FE9
0A1A2:  MOVLW  00
0A1A4:  ADDWFC 03,W
0A1A6:  MOVWF  FEA
0A1A8:  MOVFF  FEC,578
0A1AC:  MOVF   FED,F
0A1AE:  MOVFF  FEF,577
0A1B2:  CLRF   03
0A1B4:  MOVF   25,W
0A1B6:  BTFSC  FE8.7
0A1B8:  DECF   03,F
0A1BA:  ADDWF  x77,W
0A1BC:  MOVWF  01
0A1BE:  MOVF   x78,W
0A1C0:  ADDWFC 03,F
0A1C2:  MOVFF  576,FEA
0A1C6:  MOVFF  575,FE9
0A1CA:  MOVFF  03,FEC
0A1CE:  MOVF   FED,F
0A1D0:  MOVFF  01,FEF
....................                 tela_dados_ponto_4(contador_lcd); 
0A1D4:  MOVFF  24,575
0A1D8:  MOVLB  0
0A1DA:  CALL   80CA
0A1DE:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
0A1E0:  BCF    FD8.0
0A1E2:  RLCF   24,W
0A1E4:  CLRF   03
0A1E6:  ADDLW  57
0A1E8:  MOVWF  FE9
0A1EA:  MOVLW  01
0A1EC:  ADDWFC 03,W
0A1EE:  MOVWF  FEA
0A1F0:  MOVFF  FEC,576
0A1F4:  MOVF   FED,F
0A1F6:  MOVFF  FEF,575
0A1FA:  MOVF   x75,W
0A1FC:  SUBLW  03
0A1FE:  BNZ   A262
0A200:  MOVF   x76,F
0A202:  BNZ   A262
....................                 t_solda[contador_lcd] = t_solda[contador_lcd] + incremento; 
0A204:  BCF    FD8.0
0A206:  RLCF   24,W
0A208:  CLRF   03
0A20A:  ADDLW  AD
0A20C:  MOVWF  01
0A20E:  MOVLW  00
0A210:  ADDWFC 03,F
0A212:  MOVFF  01,575
0A216:  MOVFF  03,576
0A21A:  BCF    FD8.0
0A21C:  RLCF   24,W
0A21E:  CLRF   03
0A220:  ADDLW  AD
0A222:  MOVWF  FE9
0A224:  MOVLW  00
0A226:  ADDWFC 03,W
0A228:  MOVWF  FEA
0A22A:  MOVFF  FEC,578
0A22E:  MOVF   FED,F
0A230:  MOVFF  FEF,577
0A234:  CLRF   03
0A236:  MOVF   25,W
0A238:  BTFSC  FE8.7
0A23A:  DECF   03,F
0A23C:  ADDWF  x77,W
0A23E:  MOVWF  01
0A240:  MOVF   x78,W
0A242:  ADDWFC 03,F
0A244:  MOVFF  576,FEA
0A248:  MOVFF  575,FE9
0A24C:  MOVFF  03,FEC
0A250:  MOVF   FED,F
0A252:  MOVFF  01,FEF
....................                 tela_dados_ponto_2(contador_lcd); 
0A256:  MOVFF  24,575
0A25A:  MOVLB  0
0A25C:  CALL   834A
0A260:  MOVLB  5
....................             }             
....................             menu_atual = menu_dados_ponto_2; 
0A262:  MOVLW  12
0A264:  MOVWF  1C
....................         break; 
0A266:  MOVLB  0
0A268:  GOTO   B13A
....................         case 4: 
....................             if (numeroFerros[contador_lcd] == 1){ 
0A26C:  BCF    FD8.0
0A26E:  RLCF   24,W
0A270:  CLRF   03
0A272:  ADDLW  57
0A274:  MOVWF  FE9
0A276:  MOVLW  01
0A278:  ADDWFC 03,W
0A27A:  MOVWF  FEA
0A27C:  MOVFF  FEC,576
0A280:  MOVF   FED,F
0A282:  MOVFF  FEF,575
0A286:  MOVLB  5
0A288:  DECFSZ x75,W
0A28A:  BRA    A30C
0A28C:  MOVF   x76,F
0A28E:  BNZ   A30C
....................                 if (t_solda[contador_lcd] > 0){ 
0A290:  BCF    FD8.0
0A292:  RLCF   24,W
0A294:  CLRF   03
0A296:  ADDLW  AD
0A298:  MOVWF  FE9
0A29A:  MOVLW  00
0A29C:  ADDWFC 03,W
0A29E:  MOVWF  FEA
0A2A0:  MOVFF  FEC,576
0A2A4:  MOVF   FED,F
0A2A6:  MOVFF  FEF,575
0A2AA:  MOVF   x75,F
0A2AC:  BNZ   A2B2
0A2AE:  MOVF   x76,F
0A2B0:  BZ    A300
....................                     t_solda[contador_lcd] = t_solda[contador_lcd] - incremento; 
0A2B2:  BCF    FD8.0
0A2B4:  RLCF   24,W
0A2B6:  CLRF   03
0A2B8:  ADDLW  AD
0A2BA:  MOVWF  01
0A2BC:  MOVLW  00
0A2BE:  ADDWFC 03,F
0A2C0:  MOVFF  03,576
0A2C4:  BCF    FD8.0
0A2C6:  RLCF   24,W
0A2C8:  CLRF   03
0A2CA:  ADDLW  AD
0A2CC:  MOVWF  FE9
0A2CE:  MOVLW  00
0A2D0:  ADDWFC 03,W
0A2D2:  MOVWF  FEA
0A2D4:  MOVFF  FEC,578
0A2D8:  MOVF   FED,F
0A2DA:  MOVFF  FEF,577
0A2DE:  CLRF   03
0A2E0:  MOVF   25,W
0A2E2:  MOVWF  00
0A2E4:  BTFSC  FE8.7
0A2E6:  DECF   03,F
0A2E8:  SUBWF  x77,W
0A2EA:  MOVWF  00
0A2EC:  MOVF   03,W
0A2EE:  SUBWFB x78,W
0A2F0:  MOVFF  576,FEA
0A2F4:  MOVFF  01,FE9
0A2F8:  MOVWF  FEC
0A2FA:  MOVF   FED,F
0A2FC:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_4(contador_lcd); 
0A300:  MOVFF  24,575
0A304:  MOVLB  0
0A306:  CALL   80CA
0A30A:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
0A30C:  BCF    FD8.0
0A30E:  RLCF   24,W
0A310:  CLRF   03
0A312:  ADDLW  57
0A314:  MOVWF  FE9
0A316:  MOVLW  01
0A318:  ADDWFC 03,W
0A31A:  MOVWF  FEA
0A31C:  MOVFF  FEC,576
0A320:  MOVF   FED,F
0A322:  MOVFF  FEF,575
0A326:  MOVF   x75,W
0A328:  SUBLW  03
0A32A:  BNZ   A3AC
0A32C:  MOVF   x76,F
0A32E:  BNZ   A3AC
....................                 if (t_solda[contador_lcd] > 0){ 
0A330:  BCF    FD8.0
0A332:  RLCF   24,W
0A334:  CLRF   03
0A336:  ADDLW  AD
0A338:  MOVWF  FE9
0A33A:  MOVLW  00
0A33C:  ADDWFC 03,W
0A33E:  MOVWF  FEA
0A340:  MOVFF  FEC,576
0A344:  MOVF   FED,F
0A346:  MOVFF  FEF,575
0A34A:  MOVF   x75,F
0A34C:  BNZ   A352
0A34E:  MOVF   x76,F
0A350:  BZ    A3A0
....................                     t_solda[contador_lcd] = t_solda[contador_lcd] - incremento; 
0A352:  BCF    FD8.0
0A354:  RLCF   24,W
0A356:  CLRF   03
0A358:  ADDLW  AD
0A35A:  MOVWF  01
0A35C:  MOVLW  00
0A35E:  ADDWFC 03,F
0A360:  MOVFF  03,576
0A364:  BCF    FD8.0
0A366:  RLCF   24,W
0A368:  CLRF   03
0A36A:  ADDLW  AD
0A36C:  MOVWF  FE9
0A36E:  MOVLW  00
0A370:  ADDWFC 03,W
0A372:  MOVWF  FEA
0A374:  MOVFF  FEC,578
0A378:  MOVF   FED,F
0A37A:  MOVFF  FEF,577
0A37E:  CLRF   03
0A380:  MOVF   25,W
0A382:  MOVWF  00
0A384:  BTFSC  FE8.7
0A386:  DECF   03,F
0A388:  SUBWF  x77,W
0A38A:  MOVWF  00
0A38C:  MOVF   03,W
0A38E:  SUBWFB x78,W
0A390:  MOVFF  576,FEA
0A394:  MOVFF  01,FE9
0A398:  MOVWF  FEC
0A39A:  MOVF   FED,F
0A39C:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_2(contador_lcd); 
0A3A0:  MOVFF  24,575
0A3A4:  MOVLB  0
0A3A6:  CALL   834A
0A3AA:  MOVLB  5
....................             }             
....................             menu_atual = menu_dados_ponto_2; 
0A3AC:  MOVLW  12
0A3AE:  MOVWF  1C
....................         break; 
0A3B0:  MOVLB  0
0A3B2:  GOTO   B13A
....................         case 2: 
....................             if (numeroFerros[contador_lcd] == 0){ 
0A3B6:  BCF    FD8.0
0A3B8:  RLCF   24,W
0A3BA:  CLRF   03
0A3BC:  ADDLW  57
0A3BE:  MOVWF  FE9
0A3C0:  MOVLW  01
0A3C2:  ADDWFC 03,W
0A3C4:  MOVWF  FEA
0A3C6:  MOVFF  FEC,576
0A3CA:  MOVF   FED,F
0A3CC:  MOVFF  FEF,575
0A3D0:  MOVLB  5
0A3D2:  MOVF   x75,F
0A3D4:  BNZ   A438
0A3D6:  MOVF   x76,F
0A3D8:  BNZ   A438
....................                 t_solda2[contador_lcd] = t_solda2[contador_lcd] + incremento; 
0A3DA:  BCF    FD8.0
0A3DC:  RLCF   24,W
0A3DE:  CLRF   03
0A3E0:  ADDLW  81
0A3E2:  MOVWF  01
0A3E4:  MOVLW  01
0A3E6:  ADDWFC 03,F
0A3E8:  MOVFF  01,575
0A3EC:  MOVFF  03,576
0A3F0:  BCF    FD8.0
0A3F2:  RLCF   24,W
0A3F4:  CLRF   03
0A3F6:  ADDLW  81
0A3F8:  MOVWF  FE9
0A3FA:  MOVLW  01
0A3FC:  ADDWFC 03,W
0A3FE:  MOVWF  FEA
0A400:  MOVFF  FEC,578
0A404:  MOVF   FED,F
0A406:  MOVFF  FEF,577
0A40A:  CLRF   03
0A40C:  MOVF   25,W
0A40E:  BTFSC  FE8.7
0A410:  DECF   03,F
0A412:  ADDWF  x77,W
0A414:  MOVWF  01
0A416:  MOVF   x78,W
0A418:  ADDWFC 03,F
0A41A:  MOVFF  576,FEA
0A41E:  MOVFF  575,FE9
0A422:  MOVFF  03,FEC
0A426:  MOVF   FED,F
0A428:  MOVFF  01,FEF
....................                 tela_dados_ponto_5(contador_lcd); 
0A42C:  MOVFF  24,575
0A430:  MOVLB  0
0A432:  CALL   7FC8
0A436:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){ 
0A438:  BCF    FD8.0
0A43A:  RLCF   24,W
0A43C:  CLRF   03
0A43E:  ADDLW  57
0A440:  MOVWF  FE9
0A442:  MOVLW  01
0A444:  ADDWFC 03,W
0A446:  MOVWF  FEA
0A448:  MOVFF  FEC,576
0A44C:  MOVF   FED,F
0A44E:  MOVFF  FEF,575
0A452:  DECFSZ x75,W
0A454:  BRA    A4B8
0A456:  MOVF   x76,F
0A458:  BNZ   A4B8
....................                 t_solda2[contador_lcd] = t_solda2[contador_lcd] + incremento; 
0A45A:  BCF    FD8.0
0A45C:  RLCF   24,W
0A45E:  CLRF   03
0A460:  ADDLW  81
0A462:  MOVWF  01
0A464:  MOVLW  01
0A466:  ADDWFC 03,F
0A468:  MOVFF  01,575
0A46C:  MOVFF  03,576
0A470:  BCF    FD8.0
0A472:  RLCF   24,W
0A474:  CLRF   03
0A476:  ADDLW  81
0A478:  MOVWF  FE9
0A47A:  MOVLW  01
0A47C:  ADDWFC 03,W
0A47E:  MOVWF  FEA
0A480:  MOVFF  FEC,578
0A484:  MOVF   FED,F
0A486:  MOVFF  FEF,577
0A48A:  CLRF   03
0A48C:  MOVF   25,W
0A48E:  BTFSC  FE8.7
0A490:  DECF   03,F
0A492:  ADDWF  x77,W
0A494:  MOVWF  01
0A496:  MOVF   x78,W
0A498:  ADDWFC 03,F
0A49A:  MOVFF  576,FEA
0A49E:  MOVFF  575,FE9
0A4A2:  MOVFF  03,FEC
0A4A6:  MOVF   FED,F
0A4A8:  MOVFF  01,FEF
....................                 tela_dados_ponto_4(contador_lcd); 
0A4AC:  MOVFF  24,575
0A4B0:  MOVLB  0
0A4B2:  CALL   80CA
0A4B6:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){ 
0A4B8:  BCF    FD8.0
0A4BA:  RLCF   24,W
0A4BC:  CLRF   03
0A4BE:  ADDLW  57
0A4C0:  MOVWF  FE9
0A4C2:  MOVLW  01
0A4C4:  ADDWFC 03,W
0A4C6:  MOVWF  FEA
0A4C8:  MOVFF  FEC,576
0A4CC:  MOVF   FED,F
0A4CE:  MOVFF  FEF,575
0A4D2:  MOVF   x75,W
0A4D4:  SUBLW  02
0A4D6:  BNZ   A53A
0A4D8:  MOVF   x76,F
0A4DA:  BNZ   A53A
....................                 t_solda2[contador_lcd] = t_solda2[contador_lcd] + incremento; 
0A4DC:  BCF    FD8.0
0A4DE:  RLCF   24,W
0A4E0:  CLRF   03
0A4E2:  ADDLW  81
0A4E4:  MOVWF  01
0A4E6:  MOVLW  01
0A4E8:  ADDWFC 03,F
0A4EA:  MOVFF  01,575
0A4EE:  MOVFF  03,576
0A4F2:  BCF    FD8.0
0A4F4:  RLCF   24,W
0A4F6:  CLRF   03
0A4F8:  ADDLW  81
0A4FA:  MOVWF  FE9
0A4FC:  MOVLW  01
0A4FE:  ADDWFC 03,W
0A500:  MOVWF  FEA
0A502:  MOVFF  FEC,578
0A506:  MOVF   FED,F
0A508:  MOVFF  FEF,577
0A50C:  CLRF   03
0A50E:  MOVF   25,W
0A510:  BTFSC  FE8.7
0A512:  DECF   03,F
0A514:  ADDWF  x77,W
0A516:  MOVWF  01
0A518:  MOVF   x78,W
0A51A:  ADDWFC 03,F
0A51C:  MOVFF  576,FEA
0A520:  MOVFF  575,FE9
0A524:  MOVFF  03,FEC
0A528:  MOVF   FED,F
0A52A:  MOVFF  01,FEF
....................                 tela_dados_ponto_3(contador_lcd); 
0A52E:  MOVFF  24,575
0A532:  MOVLB  0
0A534:  CALL   820A
0A538:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
0A53A:  BCF    FD8.0
0A53C:  RLCF   24,W
0A53E:  CLRF   03
0A540:  ADDLW  57
0A542:  MOVWF  FE9
0A544:  MOVLW  01
0A546:  ADDWFC 03,W
0A548:  MOVWF  FEA
0A54A:  MOVFF  FEC,576
0A54E:  MOVF   FED,F
0A550:  MOVFF  FEF,575
0A554:  MOVF   x75,W
0A556:  SUBLW  03
0A558:  BNZ   A5BC
0A55A:  MOVF   x76,F
0A55C:  BNZ   A5BC
....................                 t_solda2[contador_lcd] = t_solda2[contador_lcd] + incremento; 
0A55E:  BCF    FD8.0
0A560:  RLCF   24,W
0A562:  CLRF   03
0A564:  ADDLW  81
0A566:  MOVWF  01
0A568:  MOVLW  01
0A56A:  ADDWFC 03,F
0A56C:  MOVFF  01,575
0A570:  MOVFF  03,576
0A574:  BCF    FD8.0
0A576:  RLCF   24,W
0A578:  CLRF   03
0A57A:  ADDLW  81
0A57C:  MOVWF  FE9
0A57E:  MOVLW  01
0A580:  ADDWFC 03,W
0A582:  MOVWF  FEA
0A584:  MOVFF  FEC,578
0A588:  MOVF   FED,F
0A58A:  MOVFF  FEF,577
0A58E:  CLRF   03
0A590:  MOVF   25,W
0A592:  BTFSC  FE8.7
0A594:  DECF   03,F
0A596:  ADDWF  x77,W
0A598:  MOVWF  01
0A59A:  MOVF   x78,W
0A59C:  ADDWFC 03,F
0A59E:  MOVFF  576,FEA
0A5A2:  MOVFF  575,FE9
0A5A6:  MOVFF  03,FEC
0A5AA:  MOVF   FED,F
0A5AC:  MOVFF  01,FEF
....................                 tela_dados_ponto_2(contador_lcd); 
0A5B0:  MOVFF  24,575
0A5B4:  MOVLB  0
0A5B6:  CALL   834A
0A5BA:  MOVLB  5
....................             } 
....................             menu_atual = menu_dados_ponto_2; 
0A5BC:  MOVLW  12
0A5BE:  MOVWF  1C
....................         break; 
0A5C0:  MOVLB  0
0A5C2:  GOTO   B13A
....................         case 5: 
....................             if (numeroFerros[contador_lcd] == 0){ 
0A5C6:  BCF    FD8.0
0A5C8:  RLCF   24,W
0A5CA:  CLRF   03
0A5CC:  ADDLW  57
0A5CE:  MOVWF  FE9
0A5D0:  MOVLW  01
0A5D2:  ADDWFC 03,W
0A5D4:  MOVWF  FEA
0A5D6:  MOVFF  FEC,576
0A5DA:  MOVF   FED,F
0A5DC:  MOVFF  FEF,575
0A5E0:  MOVLB  5
0A5E2:  MOVF   x75,F
0A5E4:  BNZ   A666
0A5E6:  MOVF   x76,F
0A5E8:  BNZ   A666
....................                 if (t_solda2[contador_lcd] > 0){ 
0A5EA:  BCF    FD8.0
0A5EC:  RLCF   24,W
0A5EE:  CLRF   03
0A5F0:  ADDLW  81
0A5F2:  MOVWF  FE9
0A5F4:  MOVLW  01
0A5F6:  ADDWFC 03,W
0A5F8:  MOVWF  FEA
0A5FA:  MOVFF  FEC,576
0A5FE:  MOVF   FED,F
0A600:  MOVFF  FEF,575
0A604:  MOVF   x75,F
0A606:  BNZ   A60C
0A608:  MOVF   x76,F
0A60A:  BZ    A65A
....................                     t_solda2[contador_lcd] = t_solda2[contador_lcd] - incremento; 
0A60C:  BCF    FD8.0
0A60E:  RLCF   24,W
0A610:  CLRF   03
0A612:  ADDLW  81
0A614:  MOVWF  01
0A616:  MOVLW  01
0A618:  ADDWFC 03,F
0A61A:  MOVFF  03,576
0A61E:  BCF    FD8.0
0A620:  RLCF   24,W
0A622:  CLRF   03
0A624:  ADDLW  81
0A626:  MOVWF  FE9
0A628:  MOVLW  01
0A62A:  ADDWFC 03,W
0A62C:  MOVWF  FEA
0A62E:  MOVFF  FEC,578
0A632:  MOVF   FED,F
0A634:  MOVFF  FEF,577
0A638:  CLRF   03
0A63A:  MOVF   25,W
0A63C:  MOVWF  00
0A63E:  BTFSC  FE8.7
0A640:  DECF   03,F
0A642:  SUBWF  x77,W
0A644:  MOVWF  00
0A646:  MOVF   03,W
0A648:  SUBWFB x78,W
0A64A:  MOVFF  576,FEA
0A64E:  MOVFF  01,FE9
0A652:  MOVWF  FEC
0A654:  MOVF   FED,F
0A656:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_5(contador_lcd); 
0A65A:  MOVFF  24,575
0A65E:  MOVLB  0
0A660:  CALL   7FC8
0A664:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){ 
0A666:  BCF    FD8.0
0A668:  RLCF   24,W
0A66A:  CLRF   03
0A66C:  ADDLW  57
0A66E:  MOVWF  FE9
0A670:  MOVLW  01
0A672:  ADDWFC 03,W
0A674:  MOVWF  FEA
0A676:  MOVFF  FEC,576
0A67A:  MOVF   FED,F
0A67C:  MOVFF  FEF,575
0A680:  DECFSZ x75,W
0A682:  BRA    A704
0A684:  MOVF   x76,F
0A686:  BNZ   A704
....................                 if (t_solda2[contador_lcd] > 0){ 
0A688:  BCF    FD8.0
0A68A:  RLCF   24,W
0A68C:  CLRF   03
0A68E:  ADDLW  81
0A690:  MOVWF  FE9
0A692:  MOVLW  01
0A694:  ADDWFC 03,W
0A696:  MOVWF  FEA
0A698:  MOVFF  FEC,576
0A69C:  MOVF   FED,F
0A69E:  MOVFF  FEF,575
0A6A2:  MOVF   x75,F
0A6A4:  BNZ   A6AA
0A6A6:  MOVF   x76,F
0A6A8:  BZ    A6F8
....................                     t_solda2[contador_lcd] = t_solda2[contador_lcd] - incremento; 
0A6AA:  BCF    FD8.0
0A6AC:  RLCF   24,W
0A6AE:  CLRF   03
0A6B0:  ADDLW  81
0A6B2:  MOVWF  01
0A6B4:  MOVLW  01
0A6B6:  ADDWFC 03,F
0A6B8:  MOVFF  03,576
0A6BC:  BCF    FD8.0
0A6BE:  RLCF   24,W
0A6C0:  CLRF   03
0A6C2:  ADDLW  81
0A6C4:  MOVWF  FE9
0A6C6:  MOVLW  01
0A6C8:  ADDWFC 03,W
0A6CA:  MOVWF  FEA
0A6CC:  MOVFF  FEC,578
0A6D0:  MOVF   FED,F
0A6D2:  MOVFF  FEF,577
0A6D6:  CLRF   03
0A6D8:  MOVF   25,W
0A6DA:  MOVWF  00
0A6DC:  BTFSC  FE8.7
0A6DE:  DECF   03,F
0A6E0:  SUBWF  x77,W
0A6E2:  MOVWF  00
0A6E4:  MOVF   03,W
0A6E6:  SUBWFB x78,W
0A6E8:  MOVFF  576,FEA
0A6EC:  MOVFF  01,FE9
0A6F0:  MOVWF  FEC
0A6F2:  MOVF   FED,F
0A6F4:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_4(contador_lcd); 
0A6F8:  MOVFF  24,575
0A6FC:  MOVLB  0
0A6FE:  CALL   80CA
0A702:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){ 
0A704:  BCF    FD8.0
0A706:  RLCF   24,W
0A708:  CLRF   03
0A70A:  ADDLW  57
0A70C:  MOVWF  FE9
0A70E:  MOVLW  01
0A710:  ADDWFC 03,W
0A712:  MOVWF  FEA
0A714:  MOVFF  FEC,576
0A718:  MOVF   FED,F
0A71A:  MOVFF  FEF,575
0A71E:  MOVF   x75,W
0A720:  SUBLW  02
0A722:  BNZ   A7A4
0A724:  MOVF   x76,F
0A726:  BNZ   A7A4
....................                 if (t_solda2[contador_lcd] > 0){ 
0A728:  BCF    FD8.0
0A72A:  RLCF   24,W
0A72C:  CLRF   03
0A72E:  ADDLW  81
0A730:  MOVWF  FE9
0A732:  MOVLW  01
0A734:  ADDWFC 03,W
0A736:  MOVWF  FEA
0A738:  MOVFF  FEC,576
0A73C:  MOVF   FED,F
0A73E:  MOVFF  FEF,575
0A742:  MOVF   x75,F
0A744:  BNZ   A74A
0A746:  MOVF   x76,F
0A748:  BZ    A798
....................                     t_solda2[contador_lcd] = t_solda2[contador_lcd] - incremento; 
0A74A:  BCF    FD8.0
0A74C:  RLCF   24,W
0A74E:  CLRF   03
0A750:  ADDLW  81
0A752:  MOVWF  01
0A754:  MOVLW  01
0A756:  ADDWFC 03,F
0A758:  MOVFF  03,576
0A75C:  BCF    FD8.0
0A75E:  RLCF   24,W
0A760:  CLRF   03
0A762:  ADDLW  81
0A764:  MOVWF  FE9
0A766:  MOVLW  01
0A768:  ADDWFC 03,W
0A76A:  MOVWF  FEA
0A76C:  MOVFF  FEC,578
0A770:  MOVF   FED,F
0A772:  MOVFF  FEF,577
0A776:  CLRF   03
0A778:  MOVF   25,W
0A77A:  MOVWF  00
0A77C:  BTFSC  FE8.7
0A77E:  DECF   03,F
0A780:  SUBWF  x77,W
0A782:  MOVWF  00
0A784:  MOVF   03,W
0A786:  SUBWFB x78,W
0A788:  MOVFF  576,FEA
0A78C:  MOVFF  01,FE9
0A790:  MOVWF  FEC
0A792:  MOVF   FED,F
0A794:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_3(contador_lcd); 
0A798:  MOVFF  24,575
0A79C:  MOVLB  0
0A79E:  CALL   820A
0A7A2:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
0A7A4:  BCF    FD8.0
0A7A6:  RLCF   24,W
0A7A8:  CLRF   03
0A7AA:  ADDLW  57
0A7AC:  MOVWF  FE9
0A7AE:  MOVLW  01
0A7B0:  ADDWFC 03,W
0A7B2:  MOVWF  FEA
0A7B4:  MOVFF  FEC,576
0A7B8:  MOVF   FED,F
0A7BA:  MOVFF  FEF,575
0A7BE:  MOVF   x75,W
0A7C0:  SUBLW  03
0A7C2:  BNZ   A844
0A7C4:  MOVF   x76,F
0A7C6:  BNZ   A844
....................                 if (t_solda2[contador_lcd] > 0){ 
0A7C8:  BCF    FD8.0
0A7CA:  RLCF   24,W
0A7CC:  CLRF   03
0A7CE:  ADDLW  81
0A7D0:  MOVWF  FE9
0A7D2:  MOVLW  01
0A7D4:  ADDWFC 03,W
0A7D6:  MOVWF  FEA
0A7D8:  MOVFF  FEC,576
0A7DC:  MOVF   FED,F
0A7DE:  MOVFF  FEF,575
0A7E2:  MOVF   x75,F
0A7E4:  BNZ   A7EA
0A7E6:  MOVF   x76,F
0A7E8:  BZ    A838
....................                     t_solda2[contador_lcd] = t_solda2[contador_lcd] - incremento; 
0A7EA:  BCF    FD8.0
0A7EC:  RLCF   24,W
0A7EE:  CLRF   03
0A7F0:  ADDLW  81
0A7F2:  MOVWF  01
0A7F4:  MOVLW  01
0A7F6:  ADDWFC 03,F
0A7F8:  MOVFF  03,576
0A7FC:  BCF    FD8.0
0A7FE:  RLCF   24,W
0A800:  CLRF   03
0A802:  ADDLW  81
0A804:  MOVWF  FE9
0A806:  MOVLW  01
0A808:  ADDWFC 03,W
0A80A:  MOVWF  FEA
0A80C:  MOVFF  FEC,578
0A810:  MOVF   FED,F
0A812:  MOVFF  FEF,577
0A816:  CLRF   03
0A818:  MOVF   25,W
0A81A:  MOVWF  00
0A81C:  BTFSC  FE8.7
0A81E:  DECF   03,F
0A820:  SUBWF  x77,W
0A822:  MOVWF  00
0A824:  MOVF   03,W
0A826:  SUBWFB x78,W
0A828:  MOVFF  576,FEA
0A82C:  MOVFF  01,FE9
0A830:  MOVWF  FEC
0A832:  MOVF   FED,F
0A834:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_2(contador_lcd); 
0A838:  MOVFF  24,575
0A83C:  MOVLB  0
0A83E:  CALL   834A
0A842:  MOVLB  5
....................             } 
....................             menu_atual = menu_dados_ponto_2; 
0A844:  MOVLW  12
0A846:  MOVWF  1C
....................         break; 
0A848:  MOVLB  0
0A84A:  GOTO   B13A
....................         case 3: 
....................             if (numeroFerros[contador_lcd] == 2){ 
0A84E:  BCF    FD8.0
0A850:  RLCF   24,W
0A852:  CLRF   03
0A854:  ADDLW  57
0A856:  MOVWF  FE9
0A858:  MOVLW  01
0A85A:  ADDWFC 03,W
0A85C:  MOVWF  FEA
0A85E:  MOVFF  FEC,576
0A862:  MOVF   FED,F
0A864:  MOVFF  FEF,575
0A868:  MOVLB  5
0A86A:  MOVF   x75,W
0A86C:  SUBLW  02
0A86E:  BNZ   A8D2
0A870:  MOVF   x76,F
0A872:  BNZ   A8D2
....................                 t_solda3[contador_lcd] = t_solda3[contador_lcd] + incremento; 
0A874:  BCF    FD8.0
0A876:  RLCF   24,W
0A878:  CLRF   03
0A87A:  ADDLW  AB
0A87C:  MOVWF  01
0A87E:  MOVLW  01
0A880:  ADDWFC 03,F
0A882:  MOVFF  01,575
0A886:  MOVFF  03,576
0A88A:  BCF    FD8.0
0A88C:  RLCF   24,W
0A88E:  CLRF   03
0A890:  ADDLW  AB
0A892:  MOVWF  FE9
0A894:  MOVLW  01
0A896:  ADDWFC 03,W
0A898:  MOVWF  FEA
0A89A:  MOVFF  FEC,578
0A89E:  MOVF   FED,F
0A8A0:  MOVFF  FEF,577
0A8A4:  CLRF   03
0A8A6:  MOVF   25,W
0A8A8:  BTFSC  FE8.7
0A8AA:  DECF   03,F
0A8AC:  ADDWF  x77,W
0A8AE:  MOVWF  01
0A8B0:  MOVF   x78,W
0A8B2:  ADDWFC 03,F
0A8B4:  MOVFF  576,FEA
0A8B8:  MOVFF  575,FE9
0A8BC:  MOVFF  03,FEC
0A8C0:  MOVF   FED,F
0A8C2:  MOVFF  01,FEF
....................                 tela_dados_ponto_3(contador_lcd); 
0A8C6:  MOVFF  24,575
0A8CA:  MOVLB  0
0A8CC:  CALL   820A
0A8D0:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
0A8D2:  BCF    FD8.0
0A8D4:  RLCF   24,W
0A8D6:  CLRF   03
0A8D8:  ADDLW  57
0A8DA:  MOVWF  FE9
0A8DC:  MOVLW  01
0A8DE:  ADDWFC 03,W
0A8E0:  MOVWF  FEA
0A8E2:  MOVFF  FEC,576
0A8E6:  MOVF   FED,F
0A8E8:  MOVFF  FEF,575
0A8EC:  MOVF   x75,W
0A8EE:  SUBLW  03
0A8F0:  BNZ   A954
0A8F2:  MOVF   x76,F
0A8F4:  BNZ   A954
....................                 t_solda3[contador_lcd] = t_solda3[contador_lcd] + incremento; 
0A8F6:  BCF    FD8.0
0A8F8:  RLCF   24,W
0A8FA:  CLRF   03
0A8FC:  ADDLW  AB
0A8FE:  MOVWF  01
0A900:  MOVLW  01
0A902:  ADDWFC 03,F
0A904:  MOVFF  01,575
0A908:  MOVFF  03,576
0A90C:  BCF    FD8.0
0A90E:  RLCF   24,W
0A910:  CLRF   03
0A912:  ADDLW  AB
0A914:  MOVWF  FE9
0A916:  MOVLW  01
0A918:  ADDWFC 03,W
0A91A:  MOVWF  FEA
0A91C:  MOVFF  FEC,578
0A920:  MOVF   FED,F
0A922:  MOVFF  FEF,577
0A926:  CLRF   03
0A928:  MOVF   25,W
0A92A:  BTFSC  FE8.7
0A92C:  DECF   03,F
0A92E:  ADDWF  x77,W
0A930:  MOVWF  01
0A932:  MOVF   x78,W
0A934:  ADDWFC 03,F
0A936:  MOVFF  576,FEA
0A93A:  MOVFF  575,FE9
0A93E:  MOVFF  03,FEC
0A942:  MOVF   FED,F
0A944:  MOVFF  01,FEF
....................                 tela_dados_ponto_2(contador_lcd); 
0A948:  MOVFF  24,575
0A94C:  MOVLB  0
0A94E:  CALL   834A
0A952:  MOVLB  5
....................             }             
....................             menu_atual = menu_dados_ponto_2; 
0A954:  MOVLW  12
0A956:  MOVWF  1C
....................         break; 
0A958:  MOVLB  0
0A95A:  GOTO   B13A
....................         case 6: 
....................             if (numeroFerros[contador_lcd] == 2){ 
0A95E:  BCF    FD8.0
0A960:  RLCF   24,W
0A962:  CLRF   03
0A964:  ADDLW  57
0A966:  MOVWF  FE9
0A968:  MOVLW  01
0A96A:  ADDWFC 03,W
0A96C:  MOVWF  FEA
0A96E:  MOVFF  FEC,576
0A972:  MOVF   FED,F
0A974:  MOVFF  FEF,575
0A978:  MOVLB  5
0A97A:  MOVF   x75,W
0A97C:  SUBLW  02
0A97E:  BNZ   AA00
0A980:  MOVF   x76,F
0A982:  BNZ   AA00
....................                 if (t_solda3[contador_lcd] > 0){ 
0A984:  BCF    FD8.0
0A986:  RLCF   24,W
0A988:  CLRF   03
0A98A:  ADDLW  AB
0A98C:  MOVWF  FE9
0A98E:  MOVLW  01
0A990:  ADDWFC 03,W
0A992:  MOVWF  FEA
0A994:  MOVFF  FEC,576
0A998:  MOVF   FED,F
0A99A:  MOVFF  FEF,575
0A99E:  MOVF   x75,F
0A9A0:  BNZ   A9A6
0A9A2:  MOVF   x76,F
0A9A4:  BZ    A9F4
....................                     t_solda3[contador_lcd] = t_solda3[contador_lcd] - incremento; 
0A9A6:  BCF    FD8.0
0A9A8:  RLCF   24,W
0A9AA:  CLRF   03
0A9AC:  ADDLW  AB
0A9AE:  MOVWF  01
0A9B0:  MOVLW  01
0A9B2:  ADDWFC 03,F
0A9B4:  MOVFF  03,576
0A9B8:  BCF    FD8.0
0A9BA:  RLCF   24,W
0A9BC:  CLRF   03
0A9BE:  ADDLW  AB
0A9C0:  MOVWF  FE9
0A9C2:  MOVLW  01
0A9C4:  ADDWFC 03,W
0A9C6:  MOVWF  FEA
0A9C8:  MOVFF  FEC,578
0A9CC:  MOVF   FED,F
0A9CE:  MOVFF  FEF,577
0A9D2:  CLRF   03
0A9D4:  MOVF   25,W
0A9D6:  MOVWF  00
0A9D8:  BTFSC  FE8.7
0A9DA:  DECF   03,F
0A9DC:  SUBWF  x77,W
0A9DE:  MOVWF  00
0A9E0:  MOVF   03,W
0A9E2:  SUBWFB x78,W
0A9E4:  MOVFF  576,FEA
0A9E8:  MOVFF  01,FE9
0A9EC:  MOVWF  FEC
0A9EE:  MOVF   FED,F
0A9F0:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_3(contador_lcd); 
0A9F4:  MOVFF  24,575
0A9F8:  MOVLB  0
0A9FA:  CALL   820A
0A9FE:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
0AA00:  BCF    FD8.0
0AA02:  RLCF   24,W
0AA04:  CLRF   03
0AA06:  ADDLW  57
0AA08:  MOVWF  FE9
0AA0A:  MOVLW  01
0AA0C:  ADDWFC 03,W
0AA0E:  MOVWF  FEA
0AA10:  MOVFF  FEC,576
0AA14:  MOVF   FED,F
0AA16:  MOVFF  FEF,575
0AA1A:  MOVF   x75,W
0AA1C:  SUBLW  03
0AA1E:  BNZ   AAA0
0AA20:  MOVF   x76,F
0AA22:  BNZ   AAA0
....................                 if (t_solda3[contador_lcd] > 0){ 
0AA24:  BCF    FD8.0
0AA26:  RLCF   24,W
0AA28:  CLRF   03
0AA2A:  ADDLW  AB
0AA2C:  MOVWF  FE9
0AA2E:  MOVLW  01
0AA30:  ADDWFC 03,W
0AA32:  MOVWF  FEA
0AA34:  MOVFF  FEC,576
0AA38:  MOVF   FED,F
0AA3A:  MOVFF  FEF,575
0AA3E:  MOVF   x75,F
0AA40:  BNZ   AA46
0AA42:  MOVF   x76,F
0AA44:  BZ    AA94
....................                     t_solda3[contador_lcd] = t_solda3[contador_lcd] - incremento; 
0AA46:  BCF    FD8.0
0AA48:  RLCF   24,W
0AA4A:  CLRF   03
0AA4C:  ADDLW  AB
0AA4E:  MOVWF  01
0AA50:  MOVLW  01
0AA52:  ADDWFC 03,F
0AA54:  MOVFF  03,576
0AA58:  BCF    FD8.0
0AA5A:  RLCF   24,W
0AA5C:  CLRF   03
0AA5E:  ADDLW  AB
0AA60:  MOVWF  FE9
0AA62:  MOVLW  01
0AA64:  ADDWFC 03,W
0AA66:  MOVWF  FEA
0AA68:  MOVFF  FEC,578
0AA6C:  MOVF   FED,F
0AA6E:  MOVFF  FEF,577
0AA72:  CLRF   03
0AA74:  MOVF   25,W
0AA76:  MOVWF  00
0AA78:  BTFSC  FE8.7
0AA7A:  DECF   03,F
0AA7C:  SUBWF  x77,W
0AA7E:  MOVWF  00
0AA80:  MOVF   03,W
0AA82:  SUBWFB x78,W
0AA84:  MOVFF  576,FEA
0AA88:  MOVFF  01,FE9
0AA8C:  MOVWF  FEC
0AA8E:  MOVF   FED,F
0AA90:  MOVFF  00,FEF
....................                 } 
....................                 tela_dados_ponto_2(contador_lcd); 
0AA94:  MOVFF  24,575
0AA98:  MOVLB  0
0AA9A:  CALL   834A
0AA9E:  MOVLB  5
....................             }             
....................             menu_atual = menu_dados_ponto_2; 
0AAA0:  MOVLW  12
0AAA2:  MOVWF  1C
....................         break; 
0AAA4:  MOVLB  0
0AAA6:  BRA    B13A
....................         case 8: 
....................             t_wait[contador_lcd] = t_wait[contador_lcd] + incremento; 
0AAA8:  BCF    FD8.0
0AAAA:  RLCF   24,W
0AAAC:  CLRF   03
0AAAE:  ADDLW  D7
0AAB0:  MOVWF  01
0AAB2:  MOVLW  00
0AAB4:  ADDWFC 03,F
0AAB6:  MOVFF  01,575
0AABA:  MOVLB  5
0AABC:  MOVFF  03,576
0AAC0:  BCF    FD8.0
0AAC2:  RLCF   24,W
0AAC4:  CLRF   03
0AAC6:  ADDLW  D7
0AAC8:  MOVWF  FE9
0AACA:  MOVLW  00
0AACC:  ADDWFC 03,W
0AACE:  MOVWF  FEA
0AAD0:  MOVFF  FEC,578
0AAD4:  MOVF   FED,F
0AAD6:  MOVFF  FEF,577
0AADA:  CLRF   03
0AADC:  MOVF   25,W
0AADE:  BTFSC  FE8.7
0AAE0:  DECF   03,F
0AAE2:  ADDWF  x77,W
0AAE4:  MOVWF  01
0AAE6:  MOVF   x78,W
0AAE8:  ADDWFC 03,F
0AAEA:  MOVFF  576,FEA
0AAEE:  MOVFF  575,FE9
0AAF2:  MOVFF  03,FEC
0AAF6:  MOVF   FED,F
0AAF8:  MOVFF  01,FEF
....................             if (numeroFerros[contador_lcd] == 0){                 
0AAFC:  BCF    FD8.0
0AAFE:  RLCF   24,W
0AB00:  CLRF   03
0AB02:  ADDLW  57
0AB04:  MOVWF  FE9
0AB06:  MOVLW  01
0AB08:  ADDWFC 03,W
0AB0A:  MOVWF  FEA
0AB0C:  MOVFF  FEC,576
0AB10:  MOVF   FED,F
0AB12:  MOVFF  FEF,575
0AB16:  MOVF   x75,F
0AB18:  BNZ   AB2A
0AB1A:  MOVF   x76,F
0AB1C:  BNZ   AB2A
....................                 tela_dados_ponto_5(contador_lcd); 
0AB1E:  MOVFF  24,575
0AB22:  MOVLB  0
0AB24:  CALL   7FC8
0AB28:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){                 
0AB2A:  BCF    FD8.0
0AB2C:  RLCF   24,W
0AB2E:  CLRF   03
0AB30:  ADDLW  57
0AB32:  MOVWF  FE9
0AB34:  MOVLW  01
0AB36:  ADDWFC 03,W
0AB38:  MOVWF  FEA
0AB3A:  MOVFF  FEC,576
0AB3E:  MOVF   FED,F
0AB40:  MOVFF  FEF,575
0AB44:  DECFSZ x75,W
0AB46:  BRA    AB58
0AB48:  MOVF   x76,F
0AB4A:  BNZ   AB58
....................                 tela_dados_ponto_4(contador_lcd); 
0AB4C:  MOVFF  24,575
0AB50:  MOVLB  0
0AB52:  CALL   80CA
0AB56:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){                 
0AB58:  BCF    FD8.0
0AB5A:  RLCF   24,W
0AB5C:  CLRF   03
0AB5E:  ADDLW  57
0AB60:  MOVWF  FE9
0AB62:  MOVLW  01
0AB64:  ADDWFC 03,W
0AB66:  MOVWF  FEA
0AB68:  MOVFF  FEC,576
0AB6C:  MOVF   FED,F
0AB6E:  MOVFF  FEF,575
0AB72:  MOVF   x75,W
0AB74:  SUBLW  02
0AB76:  BNZ   AB88
0AB78:  MOVF   x76,F
0AB7A:  BNZ   AB88
....................                 tela_dados_ponto_3(contador_lcd); 
0AB7C:  MOVFF  24,575
0AB80:  MOVLB  0
0AB82:  CALL   820A
0AB86:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){                 
0AB88:  BCF    FD8.0
0AB8A:  RLCF   24,W
0AB8C:  CLRF   03
0AB8E:  ADDLW  57
0AB90:  MOVWF  FE9
0AB92:  MOVLW  01
0AB94:  ADDWFC 03,W
0AB96:  MOVWF  FEA
0AB98:  MOVFF  FEC,576
0AB9C:  MOVF   FED,F
0AB9E:  MOVFF  FEF,575
0ABA2:  MOVF   x75,W
0ABA4:  SUBLW  03
0ABA6:  BNZ   ABB8
0ABA8:  MOVF   x76,F
0ABAA:  BNZ   ABB8
....................                 tela_dados_ponto_2(contador_lcd); 
0ABAC:  MOVFF  24,575
0ABB0:  MOVLB  0
0ABB2:  CALL   834A
0ABB6:  MOVLB  5
....................             }             
....................             menu_atual = menu_dados_ponto_2; 
0ABB8:  MOVLW  12
0ABBA:  MOVWF  1C
....................         break; 
0ABBC:  MOVLB  0
0ABBE:  BRA    B13A
....................         case 0: 
....................             if (t_wait[contador_lcd] > 0){ 
0ABC0:  BCF    FD8.0
0ABC2:  RLCF   24,W
0ABC4:  CLRF   03
0ABC6:  ADDLW  D7
0ABC8:  MOVWF  FE9
0ABCA:  MOVLW  00
0ABCC:  ADDWFC 03,W
0ABCE:  MOVWF  FEA
0ABD0:  MOVFF  FEC,576
0ABD4:  MOVF   FED,F
0ABD6:  MOVFF  FEF,575
0ABDA:  MOVLB  5
0ABDC:  MOVF   x75,F
0ABDE:  BNZ   ABE4
0ABE0:  MOVF   x76,F
0ABE2:  BZ    AC32
....................                 t_wait[contador_lcd] = t_wait[contador_lcd] - incremento; 
0ABE4:  BCF    FD8.0
0ABE6:  RLCF   24,W
0ABE8:  CLRF   03
0ABEA:  ADDLW  D7
0ABEC:  MOVWF  01
0ABEE:  MOVLW  00
0ABF0:  ADDWFC 03,F
0ABF2:  MOVFF  03,576
0ABF6:  BCF    FD8.0
0ABF8:  RLCF   24,W
0ABFA:  CLRF   03
0ABFC:  ADDLW  D7
0ABFE:  MOVWF  FE9
0AC00:  MOVLW  00
0AC02:  ADDWFC 03,W
0AC04:  MOVWF  FEA
0AC06:  MOVFF  FEC,578
0AC0A:  MOVF   FED,F
0AC0C:  MOVFF  FEF,577
0AC10:  CLRF   03
0AC12:  MOVF   25,W
0AC14:  MOVWF  00
0AC16:  BTFSC  FE8.7
0AC18:  DECF   03,F
0AC1A:  SUBWF  x77,W
0AC1C:  MOVWF  00
0AC1E:  MOVF   03,W
0AC20:  SUBWFB x78,W
0AC22:  MOVFF  576,FEA
0AC26:  MOVFF  01,FE9
0AC2A:  MOVWF  FEC
0AC2C:  MOVF   FED,F
0AC2E:  MOVFF  00,FEF
....................             } 
....................             if (numeroFerros[contador_lcd] == 0){                 
0AC32:  BCF    FD8.0
0AC34:  RLCF   24,W
0AC36:  CLRF   03
0AC38:  ADDLW  57
0AC3A:  MOVWF  FE9
0AC3C:  MOVLW  01
0AC3E:  ADDWFC 03,W
0AC40:  MOVWF  FEA
0AC42:  MOVFF  FEC,576
0AC46:  MOVF   FED,F
0AC48:  MOVFF  FEF,575
0AC4C:  MOVF   x75,F
0AC4E:  BNZ   AC60
0AC50:  MOVF   x76,F
0AC52:  BNZ   AC60
....................                 tela_dados_ponto_5(contador_lcd); 
0AC54:  MOVFF  24,575
0AC58:  MOVLB  0
0AC5A:  CALL   7FC8
0AC5E:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){                 
0AC60:  BCF    FD8.0
0AC62:  RLCF   24,W
0AC64:  CLRF   03
0AC66:  ADDLW  57
0AC68:  MOVWF  FE9
0AC6A:  MOVLW  01
0AC6C:  ADDWFC 03,W
0AC6E:  MOVWF  FEA
0AC70:  MOVFF  FEC,576
0AC74:  MOVF   FED,F
0AC76:  MOVFF  FEF,575
0AC7A:  DECFSZ x75,W
0AC7C:  BRA    AC8E
0AC7E:  MOVF   x76,F
0AC80:  BNZ   AC8E
....................                 tela_dados_ponto_4(contador_lcd); 
0AC82:  MOVFF  24,575
0AC86:  MOVLB  0
0AC88:  CALL   80CA
0AC8C:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){                 
0AC8E:  BCF    FD8.0
0AC90:  RLCF   24,W
0AC92:  CLRF   03
0AC94:  ADDLW  57
0AC96:  MOVWF  FE9
0AC98:  MOVLW  01
0AC9A:  ADDWFC 03,W
0AC9C:  MOVWF  FEA
0AC9E:  MOVFF  FEC,576
0ACA2:  MOVF   FED,F
0ACA4:  MOVFF  FEF,575
0ACA8:  MOVF   x75,W
0ACAA:  SUBLW  02
0ACAC:  BNZ   ACBE
0ACAE:  MOVF   x76,F
0ACB0:  BNZ   ACBE
....................                 tela_dados_ponto_3(contador_lcd); 
0ACB2:  MOVFF  24,575
0ACB6:  MOVLB  0
0ACB8:  CALL   820A
0ACBC:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){                 
0ACBE:  BCF    FD8.0
0ACC0:  RLCF   24,W
0ACC2:  CLRF   03
0ACC4:  ADDLW  57
0ACC6:  MOVWF  FE9
0ACC8:  MOVLW  01
0ACCA:  ADDWFC 03,W
0ACCC:  MOVWF  FEA
0ACCE:  MOVFF  FEC,576
0ACD2:  MOVF   FED,F
0ACD4:  MOVFF  FEF,575
0ACD8:  MOVF   x75,W
0ACDA:  SUBLW  03
0ACDC:  BNZ   ACEE
0ACDE:  MOVF   x76,F
0ACE0:  BNZ   ACEE
....................                 tela_dados_ponto_2(contador_lcd); 
0ACE2:  MOVFF  24,575
0ACE6:  MOVLB  0
0ACE8:  CALL   834A
0ACEC:  MOVLB  5
....................             }             
....................             menu_atual = menu_dados_ponto_2; 
0ACEE:  MOVLW  12
0ACF0:  MOVWF  1C
....................         break; 
0ACF2:  MOVLB  0
0ACF4:  BRA    B13A
....................         case 7: 
....................             switch (incremento){ 
0ACF6:  MOVF   25,W
0ACF8:  XORLW  01
0ACFA:  BZ    AD06
0ACFC:  XORLW  0B
0ACFE:  BZ    AD0C
0AD00:  XORLW  38
0AD02:  BZ    AD12
0AD04:  BRA    AD16
....................                 case 1: 
....................                     incremento = 10; 
0AD06:  MOVLW  0A
0AD08:  MOVWF  25
....................                 break; 
0AD0A:  BRA    AD16
....................                 case 10: 
....................                     incremento = 50; 
0AD0C:  MOVLW  32
0AD0E:  MOVWF  25
....................                 break; 
0AD10:  BRA    AD16
....................                 case 50: 
....................                     incremento = 1; 
0AD12:  MOVLW  01
0AD14:  MOVWF  25
....................                 break; 
....................             }             
....................             if (numeroFerros[contador_lcd] == 0){                 
0AD16:  BCF    FD8.0
0AD18:  RLCF   24,W
0AD1A:  CLRF   03
0AD1C:  ADDLW  57
0AD1E:  MOVWF  FE9
0AD20:  MOVLW  01
0AD22:  ADDWFC 03,W
0AD24:  MOVWF  FEA
0AD26:  MOVFF  FEC,576
0AD2A:  MOVF   FED,F
0AD2C:  MOVFF  FEF,575
0AD30:  MOVLB  5
0AD32:  MOVF   x75,F
0AD34:  BNZ   AD46
0AD36:  MOVF   x76,F
0AD38:  BNZ   AD46
....................                 tela_dados_ponto_5(contador_lcd); 
0AD3A:  MOVFF  24,575
0AD3E:  MOVLB  0
0AD40:  CALL   7FC8
0AD44:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){                 
0AD46:  BCF    FD8.0
0AD48:  RLCF   24,W
0AD4A:  CLRF   03
0AD4C:  ADDLW  57
0AD4E:  MOVWF  FE9
0AD50:  MOVLW  01
0AD52:  ADDWFC 03,W
0AD54:  MOVWF  FEA
0AD56:  MOVFF  FEC,576
0AD5A:  MOVF   FED,F
0AD5C:  MOVFF  FEF,575
0AD60:  DECFSZ x75,W
0AD62:  BRA    AD74
0AD64:  MOVF   x76,F
0AD66:  BNZ   AD74
....................                 tela_dados_ponto_4(contador_lcd); 
0AD68:  MOVFF  24,575
0AD6C:  MOVLB  0
0AD6E:  CALL   80CA
0AD72:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){                 
0AD74:  BCF    FD8.0
0AD76:  RLCF   24,W
0AD78:  CLRF   03
0AD7A:  ADDLW  57
0AD7C:  MOVWF  FE9
0AD7E:  MOVLW  01
0AD80:  ADDWFC 03,W
0AD82:  MOVWF  FEA
0AD84:  MOVFF  FEC,576
0AD88:  MOVF   FED,F
0AD8A:  MOVFF  FEF,575
0AD8E:  MOVF   x75,W
0AD90:  SUBLW  02
0AD92:  BNZ   ADA4
0AD94:  MOVF   x76,F
0AD96:  BNZ   ADA4
....................                 tela_dados_ponto_3(contador_lcd); 
0AD98:  MOVFF  24,575
0AD9C:  MOVLB  0
0AD9E:  CALL   820A
0ADA2:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){                 
0ADA4:  BCF    FD8.0
0ADA6:  RLCF   24,W
0ADA8:  CLRF   03
0ADAA:  ADDLW  57
0ADAC:  MOVWF  FE9
0ADAE:  MOVLW  01
0ADB0:  ADDWFC 03,W
0ADB2:  MOVWF  FEA
0ADB4:  MOVFF  FEC,576
0ADB8:  MOVF   FED,F
0ADBA:  MOVFF  FEF,575
0ADBE:  MOVF   x75,W
0ADC0:  SUBLW  03
0ADC2:  BNZ   ADD4
0ADC4:  MOVF   x76,F
0ADC6:  BNZ   ADD4
....................                 tela_dados_ponto_2(contador_lcd); 
0ADC8:  MOVFF  24,575
0ADCC:  MOVLB  0
0ADCE:  CALL   834A
0ADD2:  MOVLB  5
....................             }             
....................             menu_atual = menu_dados_ponto_2; 
0ADD4:  MOVLW  12
0ADD6:  MOVWF  1C
....................         break; 
0ADD8:  MOVLB  0
0ADDA:  BRA    B13A
....................         case F3: 
....................             menu_atual = menu_dados_ponto; 
0ADDC:  MOVLW  10
0ADDE:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
0ADE0:  MOVFF  24,575
0ADE4:  CALL   7560
....................             incremento = 1; 
0ADE8:  MOVLW  01
0ADEA:  MOVWF  25
....................             motor_run_z(0, 19); 
0ADEC:  MOVLB  5
0ADEE:  CLRF   x7F
0ADF0:  CLRF   x7E
0ADF2:  CLRF   x7D
0ADF4:  CLRF   x7C
0ADF6:  MOVLW  13
0ADF8:  MOVWF  x80
0ADFA:  MOVLB  0
0ADFC:  CALL   63C2
....................             while ((run_flg_z)); 
0AE00:  MOVLB  3
0AE02:  BTFSC  xB7.2
0AE04:  BRA    AE02
....................             sobe_ferros(); 
0AE06:  MOVLB  0
0AE08:  CALL   7A06
....................         break; 
0AE0C:  BRA    B13A
....................         case F1: 
....................             if ((numeroFerros[contador_lcd] == 0)||(numeroFerros[contador_lcd] == 2)){ 
0AE0E:  BCF    FD8.0
0AE10:  RLCF   24,W
0AE12:  CLRF   03
0AE14:  ADDLW  57
0AE16:  MOVWF  FE9
0AE18:  MOVLW  01
0AE1A:  ADDWFC 03,W
0AE1C:  MOVWF  FEA
0AE1E:  MOVFF  FEC,576
0AE22:  MOVF   FED,F
0AE24:  MOVFF  FEF,575
0AE28:  MOVLB  5
0AE2A:  MOVF   x75,F
0AE2C:  BNZ   AE32
0AE2E:  MOVF   x76,F
0AE30:  BZ    AE56
0AE32:  BCF    FD8.0
0AE34:  RLCF   24,W
0AE36:  CLRF   03
0AE38:  ADDLW  57
0AE3A:  MOVWF  FE9
0AE3C:  MOVLW  01
0AE3E:  ADDWFC 03,W
0AE40:  MOVWF  FEA
0AE42:  MOVFF  FEC,576
0AE46:  MOVF   FED,F
0AE48:  MOVFF  FEF,575
0AE4C:  MOVF   x75,W
0AE4E:  SUBLW  02
0AE50:  BNZ   AE6C
0AE52:  MOVF   x76,F
0AE54:  BNZ   AE6C
....................                 t_solda[contador_lcd] = 0; 
0AE56:  BCF    FD8.0
0AE58:  RLCF   24,W
0AE5A:  CLRF   03
0AE5C:  ADDLW  AD
0AE5E:  MOVWF  FE9
0AE60:  MOVLW  00
0AE62:  ADDWFC 03,W
0AE64:  MOVWF  FEA
0AE66:  CLRF   FEC
0AE68:  MOVF   FED,F
0AE6A:  CLRF   FEF
....................             } 
....................             if ((numeroFerros[contador_lcd] == 0)||(numeroFerros[contador_lcd] == 1)){ 
0AE6C:  BCF    FD8.0
0AE6E:  RLCF   24,W
0AE70:  CLRF   03
0AE72:  ADDLW  57
0AE74:  MOVWF  FE9
0AE76:  MOVLW  01
0AE78:  ADDWFC 03,W
0AE7A:  MOVWF  FEA
0AE7C:  MOVFF  FEC,576
0AE80:  MOVF   FED,F
0AE82:  MOVFF  FEF,575
0AE86:  MOVF   x75,F
0AE88:  BNZ   AE8E
0AE8A:  MOVF   x76,F
0AE8C:  BZ    AEB0
0AE8E:  BCF    FD8.0
0AE90:  RLCF   24,W
0AE92:  CLRF   03
0AE94:  ADDLW  57
0AE96:  MOVWF  FE9
0AE98:  MOVLW  01
0AE9A:  ADDWFC 03,W
0AE9C:  MOVWF  FEA
0AE9E:  MOVFF  FEC,576
0AEA2:  MOVF   FED,F
0AEA4:  MOVFF  FEF,575
0AEA8:  DECFSZ x75,W
0AEAA:  BRA    AEC6
0AEAC:  MOVF   x76,F
0AEAE:  BNZ   AEC6
....................                 t_solda3[contador_lcd] = 0; 
0AEB0:  BCF    FD8.0
0AEB2:  RLCF   24,W
0AEB4:  CLRF   03
0AEB6:  ADDLW  AB
0AEB8:  MOVWF  FE9
0AEBA:  MOVLW  01
0AEBC:  ADDWFC 03,W
0AEBE:  MOVWF  FEA
0AEC0:  CLRF   FEC
0AEC2:  MOVF   FED,F
0AEC4:  CLRF   FEF
....................             } 
....................             printf(lcd_putc, "\f"); // limpa display 
0AEC6:  MOVLW  0C
0AEC8:  MOVWF  x85
0AECA:  MOVLB  0
0AECC:  CALL   2D30
....................             printf(lcd_putc, "   GRAVANDO PONTO   \n\r"); 
0AED0:  MOVLW  D0
0AED2:  MOVWF  FF6
0AED4:  MOVLW  0F
0AED6:  MOVWF  FF7
0AED8:  CALL   2D86
....................             delay_ms(1000); 
0AEDC:  MOVLW  04
0AEDE:  MOVLB  5
0AEE0:  MOVWF  x75
0AEE2:  MOVLW  FA
0AEE4:  MOVWF  x91
0AEE6:  MOVLB  0
0AEE8:  CALL   2954
0AEEC:  MOVLB  5
0AEEE:  DECFSZ x75,F
0AEF0:  BRA    AEE2
....................             escrever_ponto_memoria(modelo,contador_lcd); 
0AEF2:  CLRF   x76
0AEF4:  MOVFF  2E,575
0AEF8:  CLRF   x78
0AEFA:  MOVFF  24,577
0AEFE:  MOVLB  0
0AF00:  CALL   7A86
....................             printf(lcd_putc, "\f"); // limpa display 
0AF04:  MOVLW  0C
0AF06:  MOVLB  5
0AF08:  MOVWF  x85
0AF0A:  MOVLB  0
0AF0C:  CALL   2D30
....................             printf(lcd_putc, "    PONTO GRAVADO   \n\r"); 
0AF10:  MOVLW  E8
0AF12:  MOVWF  FF6
0AF14:  MOVLW  0F
0AF16:  MOVWF  FF7
0AF18:  CALL   2D86
....................             delay_ms(1000); 
0AF1C:  MOVLW  04
0AF1E:  MOVLB  5
0AF20:  MOVWF  x75
0AF22:  MOVLW  FA
0AF24:  MOVWF  x91
0AF26:  MOVLB  0
0AF28:  CALL   2954
0AF2C:  MOVLB  5
0AF2E:  DECFSZ x75,F
0AF30:  BRA    AF22
....................             menu_atual = menu_seleciona_pontos; 
0AF32:  MOVLW  0F
0AF34:  MOVWF  1C
....................             tela_seleciona_pontos(); 
0AF36:  MOVLB  0
0AF38:  CALL   7464
....................             contador_lcd = 0; 
0AF3C:  CLRF   24
....................             motor_run_z(0, 19); 
0AF3E:  MOVLB  5
0AF40:  CLRF   x7F
0AF42:  CLRF   x7E
0AF44:  CLRF   x7D
0AF46:  CLRF   x7C
0AF48:  MOVLW  13
0AF4A:  MOVWF  x80
0AF4C:  MOVLB  0
0AF4E:  CALL   63C2
....................             while ((run_flg_z)); 
0AF52:  MOVLB  3
0AF54:  BTFSC  xB7.2
0AF56:  BRA    AF54
....................             sobe_ferros(); 
0AF58:  MOVLB  0
0AF5A:  CALL   7A06
....................         break; 
0AF5E:  BRA    B13A
....................         case ESC: 
....................             incremento = 1; 
0AF60:  MOVLW  01
0AF62:  MOVWF  25
....................             contador_lcd = 0; 
0AF64:  CLRF   24
....................             motor_run_z(0, 19); 
0AF66:  MOVLB  5
0AF68:  CLRF   x7F
0AF6A:  CLRF   x7E
0AF6C:  CLRF   x7D
0AF6E:  CLRF   x7C
0AF70:  MOVLW  13
0AF72:  MOVWF  x80
0AF74:  MOVLB  0
0AF76:  CALL   63C2
....................             while ((run_flg_z)); 
0AF7A:  MOVLB  3
0AF7C:  BTFSC  xB7.2
0AF7E:  BRA    AF7C
....................             sobe_ferros(); 
0AF80:  MOVLB  0
0AF82:  CALL   7A06
....................             menu_atual = menu_seleciona_pontos; 
0AF86:  MOVLW  0F
0AF88:  MOVWF  1C
....................             tela_seleciona_pontos(); 
0AF8A:  CALL   7464
....................         break; 
0AF8E:  BRA    B13A
....................         case ENTER: 
....................             f = statusSolda(); 
0AF90:  CALL   84C8
0AF94:  MOVLB  5
0AF96:  BCF    x74.0
0AF98:  BTFSC  01.0
0AF9A:  BSF    x74.0
....................             if (f == 1){ 
0AF9C:  BTFSS  x74.0
0AF9E:  BRA    AFCC
....................                 soldar_teste(tipo[contador_lcd],contador_lcd); 
0AFA0:  BCF    FD8.0
0AFA2:  RLCF   24,W
0AFA4:  CLRF   03
0AFA6:  ADDLW  01
0AFA8:  MOVWF  FE9
0AFAA:  MOVLW  01
0AFAC:  ADDWFC 03,W
0AFAE:  MOVWF  FEA
0AFB0:  MOVFF  FEC,576
0AFB4:  MOVF   FED,F
0AFB6:  MOVFF  FEF,575
0AFBA:  MOVFF  575,577
0AFBE:  MOVFF  24,578
0AFC2:  MOVLB  0
0AFC4:  CALL   8EB6
....................             } else { 
0AFC8:  BRA    B006
0AFCA:  MOVLB  5
....................                 printf(lcd_putc, "\f"); // limpa display 
0AFCC:  MOVLW  0C
0AFCE:  MOVWF  x85
0AFD0:  MOVLB  0
0AFD2:  CALL   2D30
....................                 printf(lcd_putc, "    SEM SOLDA NOS   \n\r"); 
0AFD6:  MOVLW  00
0AFD8:  MOVWF  FF6
0AFDA:  MOVLW  10
0AFDC:  MOVWF  FF7
0AFDE:  CALL   2D86
....................                 printf(lcd_putc, "    ALIMENTADORES   \n\r"); 
0AFE2:  MOVLW  18
0AFE4:  MOVWF  FF6
0AFE6:  MOVLW  10
0AFE8:  MOVWF  FF7
0AFEA:  CALL   2D86
....................                 delay_ms(1000); 
0AFEE:  MOVLW  04
0AFF0:  MOVLB  5
0AFF2:  MOVWF  x75
0AFF4:  MOVLW  FA
0AFF6:  MOVWF  x91
0AFF8:  MOVLB  0
0AFFA:  CALL   2954
0AFFE:  MOVLB  5
0B000:  DECFSZ x75,F
0B002:  BRA    AFF4
0B004:  MOVLB  0
....................             } 
....................             motor_run_y(y[contador_lcd],19); 
0B006:  BCF    FD8.0
0B008:  RLCF   24,W
0B00A:  CLRF   03
0B00C:  ADDLW  59
0B00E:  MOVWF  FE9
0B010:  MOVLW  00
0B012:  ADDWFC 03,W
0B014:  MOVWF  FEA
0B016:  MOVFF  FEC,576
0B01A:  MOVF   FED,F
0B01C:  MOVFF  FEF,575
0B020:  MOVLB  5
0B022:  CLRF   x7F
0B024:  CLRF   x7E
0B026:  MOVFF  576,57D
0B02A:  MOVFF  575,57C
0B02E:  MOVLW  13
0B030:  MOVWF  x80
0B032:  MOVLB  0
0B034:  CALL   6622
....................             while ((run_flg_y)); 
0B038:  MOVLB  2
0B03A:  BTFSC  x0B.7
0B03C:  BRA    B03A
....................             motor_run_x(x[contador_lcd],19); 
0B03E:  BCF    FD8.0
0B040:  RLCF   24,W
0B042:  CLRF   03
0B044:  ADDLW  2F
0B046:  MOVWF  FE9
0B048:  MOVLW  00
0B04A:  ADDWFC 03,W
0B04C:  MOVWF  FEA
0B04E:  MOVFF  FEC,576
0B052:  MOVF   FED,F
0B054:  MOVFF  FEF,575
0B058:  MOVLB  5
0B05A:  CLRF   x7F
0B05C:  CLRF   x7E
0B05E:  MOVFF  576,57D
0B062:  MOVFF  575,57C
0B066:  MOVLW  13
0B068:  MOVWF  x80
0B06A:  MOVLB  0
0B06C:  CALL   55F6
....................             while ((run_flg_x)); 
0B070:  MOVLB  2
0B072:  BTFSC  x0B.5
0B074:  BRA    B072
....................             if (numeroFerros[contador_lcd] == 0){ 
0B076:  BCF    FD8.0
0B078:  RLCF   24,W
0B07A:  CLRF   03
0B07C:  ADDLW  57
0B07E:  MOVWF  FE9
0B080:  MOVLW  01
0B082:  ADDWFC 03,W
0B084:  MOVWF  FEA
0B086:  MOVFF  FEC,576
0B08A:  MOVF   FED,F
0B08C:  MOVFF  FEF,575
0B090:  MOVLB  5
0B092:  MOVF   x75,F
0B094:  BNZ   B0A6
0B096:  MOVF   x76,F
0B098:  BNZ   B0A6
....................                 tela_dados_ponto_5(contador_lcd); 
0B09A:  MOVFF  24,575
0B09E:  MOVLB  0
0B0A0:  CALL   7FC8
0B0A4:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 1){ 
0B0A6:  BCF    FD8.0
0B0A8:  RLCF   24,W
0B0AA:  CLRF   03
0B0AC:  ADDLW  57
0B0AE:  MOVWF  FE9
0B0B0:  MOVLW  01
0B0B2:  ADDWFC 03,W
0B0B4:  MOVWF  FEA
0B0B6:  MOVFF  FEC,576
0B0BA:  MOVF   FED,F
0B0BC:  MOVFF  FEF,575
0B0C0:  DECFSZ x75,W
0B0C2:  BRA    B0D4
0B0C4:  MOVF   x76,F
0B0C6:  BNZ   B0D4
....................                 tela_dados_ponto_4(contador_lcd); 
0B0C8:  MOVFF  24,575
0B0CC:  MOVLB  0
0B0CE:  CALL   80CA
0B0D2:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 2){ 
0B0D4:  BCF    FD8.0
0B0D6:  RLCF   24,W
0B0D8:  CLRF   03
0B0DA:  ADDLW  57
0B0DC:  MOVWF  FE9
0B0DE:  MOVLW  01
0B0E0:  ADDWFC 03,W
0B0E2:  MOVWF  FEA
0B0E4:  MOVFF  FEC,576
0B0E8:  MOVF   FED,F
0B0EA:  MOVFF  FEF,575
0B0EE:  MOVF   x75,W
0B0F0:  SUBLW  02
0B0F2:  BNZ   B104
0B0F4:  MOVF   x76,F
0B0F6:  BNZ   B104
....................                 tela_dados_ponto_3(contador_lcd); 
0B0F8:  MOVFF  24,575
0B0FC:  MOVLB  0
0B0FE:  CALL   820A
0B102:  MOVLB  5
....................             } 
....................             if (numeroFerros[contador_lcd] == 3){ 
0B104:  BCF    FD8.0
0B106:  RLCF   24,W
0B108:  CLRF   03
0B10A:  ADDLW  57
0B10C:  MOVWF  FE9
0B10E:  MOVLW  01
0B110:  ADDWFC 03,W
0B112:  MOVWF  FEA
0B114:  MOVFF  FEC,576
0B118:  MOVF   FED,F
0B11A:  MOVFF  FEF,575
0B11E:  MOVF   x75,W
0B120:  SUBLW  03
0B122:  BNZ   B134
0B124:  MOVF   x76,F
0B126:  BNZ   B134
....................                 tela_dados_ponto_2(contador_lcd); 
0B128:  MOVFF  24,575
0B12C:  MOVLB  0
0B12E:  CALL   834A
0B132:  MOVLB  5
....................             } 
....................             menu_atual = menu_dados_ponto_2;             
0B134:  MOVLW  12
0B136:  MOVWF  1C
....................         break;  
0B138:  MOVLB  5
....................     } 
0B13A:  GOTO   DB38 (RETURN)
.................... } 
....................  
.................... void atualiza_tela_faltaSolda(){ 
....................     short int x; 
....................     switch (Teclado()){ 
*
0B2D8:  CALL   5B66
0B2DC:  MOVF   01,W
0B2DE:  XORLW  13
0B2E0:  BZ    B2E4
0B2E2:  BRA    B398
....................         case ENTER: 
....................             x = statusSolda(); 
0B2E4:  CALL   84C8
0B2E8:  MOVLB  5
0B2EA:  BCF    x74.0
0B2EC:  BTFSC  01.0
0B2EE:  BSF    x74.0
....................             printf(lcd_putc, "\f"); // limpa display 
0B2F0:  MOVLW  0C
0B2F2:  MOVWF  x85
0B2F4:  MOVLB  0
0B2F6:  CALL   2D30
....................             printf(lcd_putc, "  VERIFICANDO SOLDA \n\r"); 
0B2FA:  MOVLW  30
0B2FC:  MOVWF  FF6
0B2FE:  MOVLW  10
0B300:  MOVWF  FF7
0B302:  CALL   2D86
....................             delay_ms(1000); 
0B306:  MOVLW  04
0B308:  MOVLB  5
0B30A:  MOVWF  x75
0B30C:  MOVLW  FA
0B30E:  MOVWF  x91
0B310:  MOVLB  0
0B312:  CALL   2954
0B316:  MOVLB  5
0B318:  DECFSZ x75,F
0B31A:  BRA    B30C
....................             if (x == 0){ 
0B31C:  BTFSC  x74.0
0B31E:  BRA    B364
....................                 printf(lcd_putc, "\f"); // limpa display 
0B320:  MOVLW  0C
0B322:  MOVWF  x85
0B324:  MOVLB  0
0B326:  CALL   2D30
....................                 printf(lcd_putc, " VERIFIQUE NOVAMENTE\n\r"); 
0B32A:  MOVLW  48
0B32C:  MOVWF  FF6
0B32E:  MOVLW  10
0B330:  MOVWF  FF7
0B332:  CALL   2D86
....................                 printf(lcd_putc, "       A SOLDA      \n\r"); 
0B336:  MOVLW  60
0B338:  MOVWF  FF6
0B33A:  MOVLW  10
0B33C:  MOVWF  FF7
0B33E:  CALL   2D86
....................                 delay_ms(1000); 
0B342:  MOVLW  04
0B344:  MOVLB  5
0B346:  MOVWF  x75
0B348:  MOVLW  FA
0B34A:  MOVWF  x91
0B34C:  MOVLB  0
0B34E:  CALL   2954
0B352:  MOVLB  5
0B354:  DECFSZ x75,F
0B356:  BRA    B348
....................                 menu_atual = menu_faltaSolda; 
0B358:  MOVLW  13
0B35A:  MOVWF  1C
....................                 tela_faltaSolda(); 
0B35C:  MOVLB  0
0B35E:  RCALL  B29A
....................             } else { 
0B360:  BRA    B398
0B362:  MOVLB  5
....................                 printf(lcd_putc, "\f"); // limpa display 
0B364:  MOVLW  0C
0B366:  MOVWF  x85
0B368:  MOVLB  0
0B36A:  CALL   2D30
....................                 printf(lcd_putc, "      SOLDA OK      \n\r"); 
0B36E:  MOVLW  78
0B370:  MOVWF  FF6
0B372:  MOVLW  10
0B374:  MOVWF  FF7
0B376:  CALL   2D86
....................                 delay_ms(1000); 
0B37A:  MOVLW  04
0B37C:  MOVLB  5
0B37E:  MOVWF  x75
0B380:  MOVLW  FA
0B382:  MOVWF  x91
0B384:  MOVLB  0
0B386:  CALL   2954
0B38A:  MOVLB  5
0B38C:  DECFSZ x75,F
0B38E:  BRA    B380
....................                 menu_atual = menu_principal; 
0B390:  CLRF   1C
....................                 tela_principal(); 
0B392:  MOVLB  0
0B394:  CALL   59D6
....................             }           
....................         break; 
....................     } 
0B398:  GOTO   DAE2 (RETURN)
.................... } 
.................... void atualiza_tela_confirmaManutencao (){ 
....................     switch (Teclado()){ 
*
0706E:  CALL   5B66
07072:  MOVF   01,W
07074:  XORLW  13
07076:  BZ    707E
07078:  XORLW  01
0707A:  BZ    7090
0707C:  BRA    7096
....................         case ENTER: 
....................             envia_maquina_para_posicao(ALIMENTADOR); 
0707E:  MOVLB  5
07080:  CLRF   x77
07082:  MOVLB  0
07084:  RCALL  69E4
....................             menu_atual = menu_seleciona_maquina; 
07086:  MOVLW  01
07088:  MOVWF  1C
....................             tela_seleciona_maquina();          
0708A:  CALL   6248
....................         break; 
0708E:  BRA    7096
....................         case ESC: 
....................             tela_manutencao_outra_maquina(); 
07090:  RCALL  6FA0
....................             menu_atual = menu_manutencao_outra_maquina;       
07092:  MOVLW  07
07094:  MOVWF  1C
....................         break; 
....................     } 
07096:  GOTO   DAA2 (RETURN)
.................... } 
....................  
.................... void atualiza_tela_seleciona_manutencao(){ 
....................     switch(Teclado())    { 
*
0B808:  CALL   5B66
0B80C:  MOVF   01,W
0B80E:  XORLW  0A
0B810:  BZ    B81C
0B812:  XORLW  01
0B814:  BZ    B824
0B816:  XORLW  19
0B818:  BZ    B82C
0B81A:  BRA    B834
....................         case F1:  
....................             menu_atual = menu_debug_entrada_1; 
0B81C:  MOVLW  04
0B81E:  MOVWF  1C
....................             tela_debug_entrada_1(); 
0B820:  RCALL  B5C0
....................         break; 
0B822:  BRA    B834
....................         case F2: 
....................             menu_atual = menu_debug_saida_1; 
0B824:  MOVLW  08
0B826:  MOVWF  1C
....................             tela_debug_saida_1(); 
0B828:  RCALL  B7AE
....................         break; 
0B82A:  BRA    B834
....................         case ESC: 
....................             menu_atual = menu_seleciona_debug; 
0B82C:  MOVLW  02
0B82E:  MOVWF  1C
....................             tela_seleciona_debug(); 
0B830:  CALL   709A
....................         break; 
....................     } 
0B834:  GOTO   DAF2 (RETURN)
.................... } 
.................... void atualiza_tela_debug_entrada_1(){ 
....................     while (Teclado() == 0xff ){ 
*
0BA26:  CALL   5B66
0BA2A:  INCFSZ 01,W
0BA2C:  BRA    BA7E
....................         for (int i=0; i<9; i++){ 
0BA2E:  MOVLB  5
0BA30:  CLRF   x74
0BA32:  MOVF   x74,W
0BA34:  SUBLW  08
0BA36:  BNC   BA78
....................             if (le_Input(i) == true){ 
0BA38:  MOVFF  574,578
0BA3C:  MOVLB  0
0BA3E:  CALL   49FA
0BA42:  DECFSZ 01,W
0BA44:  BRA    BA5E
....................                 entradas [i] = 1; 
0BA46:  MOVFF  574,57D
0BA4A:  MOVLW  01
0BA4C:  MOVLB  5
0BA4E:  MOVWF  x7E
0BA50:  CLRF   x80
0BA52:  MOVLW  1D
0BA54:  MOVWF  x7F
0BA56:  MOVLB  0
0BA58:  CALL   516C
....................             } else { 
0BA5C:  BRA    BA72
....................                 entradas [i] = 0; 
0BA5E:  MOVFF  574,57D
0BA62:  MOVLB  5
0BA64:  CLRF   x7E
0BA66:  CLRF   x80
0BA68:  MOVLW  1D
0BA6A:  MOVWF  x7F
0BA6C:  MOVLB  0
0BA6E:  CALL   516C
....................             } 
0BA72:  MOVLB  5
0BA74:  INCF   x74,F
0BA76:  BRA    BA32
....................         } 
....................         tela_debug_entrada_1(); 
0BA78:  MOVLB  0
0BA7A:  RCALL  B5C0
0BA7C:  BRA    BA26
....................     } 
....................     switch(Teclado()){ 
0BA7E:  CALL   5B66
0BA82:  MOVF   01,W
0BA84:  XORLW  10
0BA86:  BZ    BA8E
0BA88:  XORLW  02
0BA8A:  BZ    BA96
0BA8C:  BRA    BA9E
....................         case SETA_DIREITA:  
....................             menu_atual = menu_debug_entrada_2; 
0BA8E:  MOVLW  05
0BA90:  MOVWF  1C
....................             tela_debug_entrada_2(); 
0BA92:  RCALL  B838
....................             break;         
0BA94:  BRA    BA9E
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
0BA96:  MOVLW  03
0BA98:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
0BA9A:  CALL   71A4
....................         break; 
....................     } 
0BA9E:  GOTO   DAFA (RETURN)
.................... } 
.................... void atualiza_tela_debug_entrada_2 () { 
....................     while (Teclado () == 0xff ){ 
*
0BCC4:  CALL   5B66
0BCC8:  INCFSZ 01,W
0BCCA:  BRA    BD1E
....................         for (int i=9; i<18; i++){ 
0BCCC:  MOVLW  09
0BCCE:  MOVLB  5
0BCD0:  MOVWF  x74
0BCD2:  MOVF   x74,W
0BCD4:  SUBLW  11
0BCD6:  BNC   BD1A
....................             if (le_Input(i) == true){ 
0BCD8:  MOVFF  574,578
0BCDC:  MOVLB  0
0BCDE:  CALL   49FA
0BCE2:  DECFSZ 01,W
0BCE4:  BRA    BCFE
....................                 entradas [i] = 1; 
0BCE6:  MOVFF  574,57D
0BCEA:  MOVLW  01
0BCEC:  MOVLB  5
0BCEE:  MOVWF  x7E
0BCF0:  CLRF   x80
0BCF2:  MOVLW  1D
0BCF4:  MOVWF  x7F
0BCF6:  MOVLB  0
0BCF8:  CALL   516C
....................             } else { 
0BCFC:  BRA    BD12
....................                 entradas [i] = 0; 
0BCFE:  MOVFF  574,57D
0BD02:  MOVLB  5
0BD04:  CLRF   x7E
0BD06:  CLRF   x80
0BD08:  MOVLW  1D
0BD0A:  MOVWF  x7F
0BD0C:  MOVLB  0
0BD0E:  CALL   516C
....................             } 
....................             tela_debug_entrada_2(); 
0BD12:  RCALL  B838
0BD14:  MOVLB  5
0BD16:  INCF   x74,F
0BD18:  BRA    BCD2
....................         } 
0BD1A:  MOVLB  0
0BD1C:  BRA    BCC4
....................     } 
....................     switch(Teclado()){ 
0BD1E:  CALL   5B66
0BD22:  MOVF   01,W
0BD24:  XORLW  11
0BD26:  BZ    BD32
0BD28:  XORLW  01
0BD2A:  BZ    BD3A
0BD2C:  XORLW  02
0BD2E:  BZ    BD42
0BD30:  BRA    BD4A
....................         case SETA_ESQUERDA:  
....................             menu_atual = menu_debug_entrada_1; 
0BD32:  MOVLW  04
0BD34:  MOVWF  1C
....................             tela_debug_entrada_1(); 
0BD36:  RCALL  B5C0
....................             break; 
0BD38:  BRA    BD4A
....................         case SETA_DIREITA:  
....................             menu_atual = menu_debug_entrada_3; 
0BD3A:  MOVLW  06
0BD3C:  MOVWF  1C
....................             tela_debug_entrada_3(); 
0BD3E:  RCALL  BAA2
....................             break; 
0BD40:  BRA    BD4A
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
0BD42:  MOVLW  03
0BD44:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
0BD46:  CALL   71A4
....................         break; 
....................     } 
0BD4A:  GOTO   DB02 (RETURN)
.................... } 
.................... void atualiza_tela_debug_entrada_3 (){ 
....................     while (Teclado() == 0xff){ 
0BD4E:  CALL   5B66
0BD52:  INCFSZ 01,W
0BD54:  BRA    BDA8
....................         for (int i=18; i<28; i++){ 
0BD56:  MOVLW  12
0BD58:  MOVLB  5
0BD5A:  MOVWF  x74
0BD5C:  MOVF   x74,W
0BD5E:  SUBLW  1B
0BD60:  BNC   BDA2
....................             if (le_Input(i) == true){ 
0BD62:  MOVFF  574,578
0BD66:  MOVLB  0
0BD68:  CALL   49FA
0BD6C:  DECFSZ 01,W
0BD6E:  BRA    BD88
....................                 entradas [i] = 1; 
0BD70:  MOVFF  574,57D
0BD74:  MOVLW  01
0BD76:  MOVLB  5
0BD78:  MOVWF  x7E
0BD7A:  CLRF   x80
0BD7C:  MOVLW  1D
0BD7E:  MOVWF  x7F
0BD80:  MOVLB  0
0BD82:  CALL   516C
....................             } else { 
0BD86:  BRA    BD9C
....................                 entradas [i] = 0; 
0BD88:  MOVFF  574,57D
0BD8C:  MOVLB  5
0BD8E:  CLRF   x7E
0BD90:  CLRF   x80
0BD92:  MOVLW  1D
0BD94:  MOVWF  x7F
0BD96:  MOVLB  0
0BD98:  CALL   516C
....................             } 
0BD9C:  MOVLB  5
0BD9E:  INCF   x74,F
0BDA0:  BRA    BD5C
....................         } 
....................         tela_debug_entrada_3(); 
0BDA2:  MOVLB  0
0BDA4:  RCALL  BAA2
0BDA6:  BRA    BD4E
....................     } 
....................     switch(Teclado()){ 
0BDA8:  CALL   5B66
0BDAC:  MOVF   01,W
0BDAE:  XORLW  11
0BDB0:  BZ    BDB8
0BDB2:  XORLW  03
0BDB4:  BZ    BDC0
0BDB6:  BRA    BDC8
....................         case SETA_ESQUERDA:  
....................             menu_atual = menu_debug_entrada_2; 
0BDB8:  MOVLW  05
0BDBA:  MOVWF  1C
....................             tela_debug_entrada_2(); 
0BDBC:  RCALL  B838
....................             break; 
0BDBE:  BRA    BDC8
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
0BDC0:  MOVLW  03
0BDC2:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
0BDC4:  CALL   71A4
....................         break; 
....................     } 
0BDC8:  GOTO   DB0A (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_1(){ 
....................     switch(Teclado()){ 
*
0BF14:  CALL   5B66
0BF18:  MOVLW  0A
0BF1A:  SUBWF  01,W
0BF1C:  ADDLW  F7
0BF1E:  BTFSC  FD8.0
0BF20:  BRA    C03C
0BF22:  ADDLW  09
0BF24:  GOTO   C040
....................         case F1: 
....................             switch(ponteiro_lcd){ 
0BF28:  MOVF   21,W
0BF2A:  XORLW  01
0BF2C:  BZ    BF38
0BF2E:  XORLW  03
0BF30:  BZ    BF48
0BF32:  XORLW  01
0BF34:  BZ    BF58
0BF36:  BRA    BF88
....................                 case 1: 
....................                     aciona_saida(RELE_ESTEIRA); 
0BF38:  MOVLB  5
0BF3A:  CLRF   x8F
0BF3C:  MOVLW  0A
0BF3E:  MOVWF  x8E
0BF40:  MOVLB  0
0BF42:  CALL   2E1E
....................                 break; 
0BF46:  BRA    BF88
....................                 case 2: 
....................                     aciona_saida(DEDO_ENTRADA); 
0BF48:  MOVLB  5
0BF4A:  CLRF   x8F
0BF4C:  MOVLW  07
0BF4E:  MOVWF  x8E
0BF50:  MOVLB  0
0BF52:  CALL   2E1E
....................                 break; 
0BF56:  BRA    BF88
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
0BF58:  MOVLB  5
0BF5A:  CLRF   x8F
0BF5C:  MOVLW  06
0BF5E:  MOVWF  x8E
0BF60:  MOVLB  0
0BF62:  CALL   2E1E
....................                     delay_ms(3000); 
0BF66:  MOVLW  0C
0BF68:  MOVLB  5
0BF6A:  MOVWF  x74
0BF6C:  MOVLW  FA
0BF6E:  MOVWF  x91
0BF70:  MOVLB  0
0BF72:  CALL   2954
0BF76:  MOVLB  5
0BF78:  DECFSZ x74,F
0BF7A:  BRA    BF6C
....................                     desaciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
0BF7C:  CLRF   x8F
0BF7E:  MOVLW  06
0BF80:  MOVWF  x8E
0BF82:  MOVLB  0
0BF84:  CALL   2DDC
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_1; 
0BF88:  MOVLW  08
0BF8A:  MOVWF  1C
....................             tela_debug_saida_1(); 
0BF8C:  RCALL  B7AE
....................         break; 
0BF8E:  BRA    C03C
....................         case F2:             
....................             switch(ponteiro_lcd){ 
0BF90:  MOVF   21,W
0BF92:  XORLW  01
0BF94:  BZ    BFA0
0BF96:  XORLW  03
0BF98:  BZ    BFB0
0BF9A:  XORLW  01
0BF9C:  BZ    BFC0
0BF9E:  BRA    BFF0
....................                 case 1: 
....................                     desaciona_saida(RELE_ESTEIRA); 
0BFA0:  MOVLB  5
0BFA2:  CLRF   x8F
0BFA4:  MOVLW  0A
0BFA6:  MOVWF  x8E
0BFA8:  MOVLB  0
0BFAA:  CALL   2DDC
....................                 break; 
0BFAE:  BRA    BFF0
....................                 case 2: 
....................                     desaciona_saida(DEDO_ENTRADA); 
0BFB0:  MOVLB  5
0BFB2:  CLRF   x8F
0BFB4:  MOVLW  07
0BFB6:  MOVWF  x8E
0BFB8:  MOVLB  0
0BFBA:  CALL   2DDC
....................                 break; 
0BFBE:  BRA    BFF0
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
0BFC0:  MOVLB  5
0BFC2:  CLRF   x8F
0BFC4:  MOVLW  05
0BFC6:  MOVWF  x8E
0BFC8:  MOVLB  0
0BFCA:  CALL   2E1E
....................                     delay_ms(3000); 
0BFCE:  MOVLW  0C
0BFD0:  MOVLB  5
0BFD2:  MOVWF  x74
0BFD4:  MOVLW  FA
0BFD6:  MOVWF  x91
0BFD8:  MOVLB  0
0BFDA:  CALL   2954
0BFDE:  MOVLB  5
0BFE0:  DECFSZ x74,F
0BFE2:  BRA    BFD4
....................                     desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
0BFE4:  CLRF   x8F
0BFE6:  MOVLW  05
0BFE8:  MOVWF  x8E
0BFEA:  MOVLB  0
0BFEC:  CALL   2DDC
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_1; 
0BFF0:  MOVLW  08
0BFF2:  MOVWF  1C
....................             tela_debug_saida_1(); 
0BFF4:  CALL   B7AE
....................         break; 
0BFF8:  BRA    C03C
....................         case SETA_DIREITA: 
....................             ponteiro_lcd = 1; 
0BFFA:  MOVLW  01
0BFFC:  MOVWF  21
....................             menu_atual = menu_debug_saida_2; 
0BFFE:  MOVLW  09
0C000:  MOVWF  1C
....................             tela_debug_saida_2(); 
0C002:  RCALL  BDCC
....................         break; 
0C004:  BRA    C03C
....................         case SETA_SUPERIOR: 
....................             if (ponteiro_lcd > 1){ 
0C006:  MOVF   21,W
0C008:  SUBLW  01
0C00A:  BC    C00E
....................                 ponteiro_lcd --; 
0C00C:  DECF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_1; 
0C00E:  MOVLW  08
0C010:  MOVWF  1C
....................             tela_debug_saida_1(); 
0C012:  CALL   B7AE
....................         break; 
0C016:  BRA    C03C
....................         case SETA_INFERIOR: 
....................             if (ponteiro_lcd < 3){ 
0C018:  MOVF   21,W
0C01A:  SUBLW  02
0C01C:  BNC   C020
....................                 ponteiro_lcd ++; 
0C01E:  INCF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_1; 
0C020:  MOVLW  08
0C022:  MOVWF  1C
....................             tela_debug_saida_1(); 
0C024:  CALL   B7AE
....................         break; 
0C028:  BRA    C03C
....................         case ESC: 
....................             home_solenoides(); 
0C02A:  CALL   2E6A
....................             posicao_volta_manutencao();  
0C02E:  RCALL  BE26
....................             ponteiro_lcd = 1; 
0C030:  MOVLW  01
0C032:  MOVWF  21
....................             menu_atual = menu_seleciona_manutencao; 
0C034:  MOVLW  03
0C036:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
0C038:  CALL   71A4
....................         break; 
....................     } 
0C03C:  GOTO   DB12 (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_2(){ 
....................     switch(Teclado()){ 
*
0C0D0:  CALL   5B66
0C0D4:  MOVLW  0A
0C0D6:  SUBWF  01,W
0C0D8:  ADDLW  F7
0C0DA:  BTFSC  FD8.0
0C0DC:  BRA    C1FC
0C0DE:  ADDLW  09
0C0E0:  GOTO   C200
....................         case F1: 
....................             switch(ponteiro_lcd){ 
0C0E4:  MOVF   21,W
0C0E6:  XORLW  01
0C0E8:  BZ    C0F4
0C0EA:  XORLW  03
0C0EC:  BZ    C104
0C0EE:  XORLW  01
0C0F0:  BZ    C114
0C0F2:  BRA    C140
....................                 case 1: 
....................                     aciona_saida(PRESSOR); 
0C0F4:  MOVLB  5
0C0F6:  CLRF   x8F
0C0F8:  MOVLW  04
0C0FA:  MOVWF  x8E
0C0FC:  MOVLB  0
0C0FE:  CALL   2E1E
....................                 break; 
0C102:  BRA    C140
....................                 case 2: 
....................                     aciona_saida(DEDO_SAIDA); 
0C104:  MOVLB  5
0C106:  CLRF   x8F
0C108:  MOVLW  01
0C10A:  MOVWF  x8E
0C10C:  MOVLB  0
0C10E:  CALL   2E1E
....................                 break; 
0C112:  BRA    C140
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
0C114:  MOVLB  5
0C116:  CLRF   x8F
0C118:  CLRF   x8E
0C11A:  MOVLB  0
0C11C:  CALL   2E1E
....................                     delay_ms(3000); 
0C120:  MOVLW  0C
0C122:  MOVLB  5
0C124:  MOVWF  x74
0C126:  MOVLW  FA
0C128:  MOVWF  x91
0C12A:  MOVLB  0
0C12C:  CALL   2954
0C130:  MOVLB  5
0C132:  DECFSZ x74,F
0C134:  BRA    C126
....................                     desaciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
0C136:  CLRF   x8F
0C138:  CLRF   x8E
0C13A:  MOVLB  0
0C13C:  CALL   2DDC
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_2; 
0C140:  MOVLW  09
0C142:  MOVWF  1C
....................             tela_debug_saida_2(); 
0C144:  RCALL  BDCC
....................         break; 
0C146:  BRA    C1FC
....................         case F2:             
....................             switch(ponteiro_lcd){ 
0C148:  MOVF   21,W
0C14A:  XORLW  01
0C14C:  BZ    C158
0C14E:  XORLW  03
0C150:  BZ    C168
0C152:  XORLW  01
0C154:  BZ    C178
0C156:  BRA    C1A8
....................                 case 1: 
....................                     desaciona_saida(PRESSOR); 
0C158:  MOVLB  5
0C15A:  CLRF   x8F
0C15C:  MOVLW  04
0C15E:  MOVWF  x8E
0C160:  MOVLB  0
0C162:  CALL   2DDC
....................                 break; 
0C166:  BRA    C1A8
....................                 case 2: 
....................                     desaciona_saida(DEDO_SAIDA); 
0C168:  MOVLB  5
0C16A:  CLRF   x8F
0C16C:  MOVLW  01
0C16E:  MOVWF  x8E
0C170:  MOVLB  0
0C172:  CALL   2DDC
....................                 break; 
0C176:  BRA    C1A8
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
0C178:  MOVLB  5
0C17A:  CLRF   x8F
0C17C:  MOVLW  0F
0C17E:  MOVWF  x8E
0C180:  MOVLB  0
0C182:  CALL   2E1E
....................                     delay_ms(3000); 
0C186:  MOVLW  0C
0C188:  MOVLB  5
0C18A:  MOVWF  x74
0C18C:  MOVLW  FA
0C18E:  MOVWF  x91
0C190:  MOVLB  0
0C192:  CALL   2954
0C196:  MOVLB  5
0C198:  DECFSZ x74,F
0C19A:  BRA    C18C
....................                     desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
0C19C:  CLRF   x8F
0C19E:  MOVLW  0F
0C1A0:  MOVWF  x8E
0C1A2:  MOVLB  0
0C1A4:  CALL   2DDC
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_2; 
0C1A8:  MOVLW  09
0C1AA:  MOVWF  1C
....................             tela_debug_saida_2(); 
0C1AC:  RCALL  BDCC
....................         break; 
0C1AE:  BRA    C1FC
....................         case SETA_DIREITA: 
....................             ponteiro_lcd = 1; 
0C1B0:  MOVLW  01
0C1B2:  MOVWF  21
....................             menu_atual = menu_debug_saida_3; 
0C1B4:  MOVLW  0A
0C1B6:  MOVWF  1C
....................             tela_debug_saida_3(); 
0C1B8:  RCALL  C076
....................         break; 
0C1BA:  BRA    C1FC
....................         case SETA_ESQUERDA: 
....................             ponteiro_lcd = 1; 
0C1BC:  MOVLW  01
0C1BE:  MOVWF  21
....................             menu_atual = menu_debug_saida_1; 
0C1C0:  MOVLW  08
0C1C2:  MOVWF  1C
....................             tela_debug_saida_1(); 
0C1C4:  CALL   B7AE
....................         break; 
0C1C8:  BRA    C1FC
....................         case SETA_SUPERIOR: 
....................             if (ponteiro_lcd > 1){ 
0C1CA:  MOVF   21,W
0C1CC:  SUBLW  01
0C1CE:  BC    C1D2
....................                 ponteiro_lcd --; 
0C1D0:  DECF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_2; 
0C1D2:  MOVLW  09
0C1D4:  MOVWF  1C
....................             tela_debug_saida_2(); 
0C1D6:  RCALL  BDCC
....................         break; 
0C1D8:  BRA    C1FC
....................         case SETA_INFERIOR: 
....................             if (ponteiro_lcd < 3){ 
0C1DA:  MOVF   21,W
0C1DC:  SUBLW  02
0C1DE:  BNC   C1E2
....................                 ponteiro_lcd ++; 
0C1E0:  INCF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_2; 
0C1E2:  MOVLW  09
0C1E4:  MOVWF  1C
....................             tela_debug_saida_2(); 
0C1E6:  RCALL  BDCC
....................         break; 
0C1E8:  BRA    C1FC
....................         case ESC: 
....................             home_solenoides(); 
0C1EA:  CALL   2E6A
....................             posicao_volta_manutencao();  
0C1EE:  RCALL  BE26
....................             ponteiro_lcd = 1; 
0C1F0:  MOVLW  01
0C1F2:  MOVWF  21
....................             menu_atual = menu_seleciona_manutencao; 
0C1F4:  MOVLW  03
0C1F6:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
0C1F8:  CALL   71A4
....................         break; 
....................     } 
0C1FC:  GOTO   DB1A (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_3(){ 
....................     switch(Teclado()){ 
*
0C340:  CALL   5B66
0C344:  MOVLW  0A
0C346:  SUBWF  01,W
0C348:  ADDLW  F7
0C34A:  BTFSC  FD8.0
0C34C:  BRA    C49A
0C34E:  ADDLW  09
0C350:  GOTO   C49E
....................         case F1: 
....................             switch(ponteiro_lcd){ 
0C354:  MOVF   21,W
0C356:  XORLW  01
0C358:  BZ    C364
0C35A:  XORLW  03
0C35C:  BZ    C390
0C35E:  XORLW  01
0C360:  BZ    C3AE
0C362:  BRA    C3CA
....................                 case 1: 
....................                     aciona_saida(ALIMENTADOR1); 
0C364:  MOVLB  5
0C366:  CLRF   x8F
0C368:  MOVLW  0E
0C36A:  MOVWF  x8E
0C36C:  MOVLB  0
0C36E:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR2); 
0C372:  MOVLB  5
0C374:  CLRF   x8F
0C376:  MOVLW  0D
0C378:  MOVWF  x8E
0C37A:  MOVLB  0
0C37C:  CALL   2E1E
....................                     aciona_saida(ALIMENTADOR3); 
0C380:  MOVLB  5
0C382:  CLRF   x8F
0C384:  MOVLW  0C
0C386:  MOVWF  x8E
0C388:  MOVLB  0
0C38A:  CALL   2E1E
....................                 break; 
0C38E:  BRA    C3CA
....................                 case 2: 
....................                     aciona_saida(LIMPA_BICO1); 
0C390:  MOVLB  5
0C392:  CLRF   x8F
0C394:  MOVLW  08
0C396:  MOVWF  x8E
0C398:  MOVLB  0
0C39A:  CALL   2E1E
....................                     aciona_saida(LIMPA_BICO2); 
0C39E:  MOVLB  5
0C3A0:  CLRF   x8F
0C3A2:  MOVLW  09
0C3A4:  MOVWF  x8E
0C3A6:  MOVLB  0
0C3A8:  CALL   2E1E
....................                 break; 
0C3AC:  BRA    C3CA
....................                 case 3: 
....................                     aciona_saida(FERRO_SOLDA1); 
0C3AE:  MOVLB  5
0C3B0:  CLRF   x8F
0C3B2:  MOVLW  03
0C3B4:  MOVWF  x8E
0C3B6:  MOVLB  0
0C3B8:  CALL   2E1E
....................                     aciona_saida(FERRO_SOLDA2); 
0C3BC:  MOVLB  5
0C3BE:  CLRF   x8F
0C3C0:  MOVLW  02
0C3C2:  MOVWF  x8E
0C3C4:  MOVLB  0
0C3C6:  CALL   2E1E
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_3; 
0C3CA:  MOVLW  0A
0C3CC:  MOVWF  1C
....................             tela_debug_saida_3(); 
0C3CE:  RCALL  C076
....................         break; 
0C3D0:  BRA    C49A
....................         case F2:             
....................             switch(ponteiro_lcd){ 
0C3D2:  MOVF   21,W
0C3D4:  XORLW  01
0C3D6:  BZ    C3E2
0C3D8:  XORLW  03
0C3DA:  BZ    C40E
0C3DC:  XORLW  01
0C3DE:  BZ    C42C
0C3E0:  BRA    C448
....................                 case 1: 
....................                     desaciona_saida(ALIMENTADOR1); 
0C3E2:  MOVLB  5
0C3E4:  CLRF   x8F
0C3E6:  MOVLW  0E
0C3E8:  MOVWF  x8E
0C3EA:  MOVLB  0
0C3EC:  CALL   2DDC
....................                     desaciona_saida(ALIMENTADOR2); 
0C3F0:  MOVLB  5
0C3F2:  CLRF   x8F
0C3F4:  MOVLW  0D
0C3F6:  MOVWF  x8E
0C3F8:  MOVLB  0
0C3FA:  CALL   2DDC
....................                     desaciona_saida(ALIMENTADOR3); 
0C3FE:  MOVLB  5
0C400:  CLRF   x8F
0C402:  MOVLW  0C
0C404:  MOVWF  x8E
0C406:  MOVLB  0
0C408:  CALL   2DDC
....................                 break; 
0C40C:  BRA    C448
....................                 case 2: 
....................                     desaciona_saida(LIMPA_BICO1); 
0C40E:  MOVLB  5
0C410:  CLRF   x8F
0C412:  MOVLW  08
0C414:  MOVWF  x8E
0C416:  MOVLB  0
0C418:  CALL   2DDC
....................                     desaciona_saida(LIMPA_BICO2); 
0C41C:  MOVLB  5
0C41E:  CLRF   x8F
0C420:  MOVLW  09
0C422:  MOVWF  x8E
0C424:  MOVLB  0
0C426:  CALL   2DDC
....................                 break; 
0C42A:  BRA    C448
....................                 case 3: 
....................                     desaciona_saida(FERRO_SOLDA1); 
0C42C:  MOVLB  5
0C42E:  CLRF   x8F
0C430:  MOVLW  03
0C432:  MOVWF  x8E
0C434:  MOVLB  0
0C436:  CALL   2DDC
....................                     desaciona_saida(FERRO_SOLDA2); 
0C43A:  MOVLB  5
0C43C:  CLRF   x8F
0C43E:  MOVLW  02
0C440:  MOVWF  x8E
0C442:  MOVLB  0
0C444:  CALL   2DDC
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_3; 
0C448:  MOVLW  0A
0C44A:  MOVWF  1C
....................             tela_debug_saida_3(); 
0C44C:  RCALL  C076
....................         break; 
0C44E:  BRA    C49A
....................         case SETA_DIREITA: 
....................             ponteiro_lcd = 1; 
0C450:  MOVLW  01
0C452:  MOVWF  21
....................             menu_atual = menu_debug_saida_4; 
0C454:  MOVLW  0B
0C456:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C458:  RCALL  C236
....................         break; 
0C45A:  BRA    C49A
....................         case SETA_ESQUERDA: 
....................             ponteiro_lcd = 1; 
0C45C:  MOVLW  01
0C45E:  MOVWF  21
....................             menu_atual = menu_debug_saida_2; 
0C460:  MOVLW  09
0C462:  MOVWF  1C
....................             tela_debug_saida_2(); 
0C464:  RCALL  BDCC
....................         break; 
0C466:  BRA    C49A
....................         case SETA_SUPERIOR: 
....................             if (ponteiro_lcd > 1){ 
0C468:  MOVF   21,W
0C46A:  SUBLW  01
0C46C:  BC    C470
....................                 ponteiro_lcd --; 
0C46E:  DECF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_3; 
0C470:  MOVLW  0A
0C472:  MOVWF  1C
....................             tela_debug_saida_3(); 
0C474:  RCALL  C076
....................         break; 
0C476:  BRA    C49A
....................         case SETA_INFERIOR: 
....................             if (ponteiro_lcd < 3){ 
0C478:  MOVF   21,W
0C47A:  SUBLW  02
0C47C:  BNC   C480
....................                 ponteiro_lcd ++; 
0C47E:  INCF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_3; 
0C480:  MOVLW  0A
0C482:  MOVWF  1C
....................             tela_debug_saida_3(); 
0C484:  RCALL  C076
....................         break; 
0C486:  BRA    C49A
....................         case ESC: 
....................             home_solenoides(); 
0C488:  CALL   2E6A
....................             posicao_volta_manutencao();  
0C48C:  RCALL  BE26
....................             ponteiro_lcd = 1; 
0C48E:  MOVLW  01
0C490:  MOVWF  21
....................             menu_atual = menu_seleciona_manutencao; 
0C492:  MOVLW  03
0C494:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
0C496:  CALL   71A4
....................         break; 
....................     } 
0C49A:  GOTO   DB22 (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_4(){ 
....................     signed long int posFlip; 
....................     signed long int posX; 
....................     signed long int posY; 
....................     signed long int posZ; 
....................     switch(Teclado()){ 
*
0C4D4:  CALL   5B66
0C4D8:  MOVF   01,W
0C4DA:  ADDLW  ED
0C4DC:  BTFSC  FD8.0
0C4DE:  BRA    C8D0
0C4E0:  ADDLW  13
0C4E2:  GOTO   C8D4
....................         case SETA_SUPERIOR: 
....................             posY = motor_pos_y + incremento; 
0C4E6:  CLRF   03
0C4E8:  MOVF   25,W
0C4EA:  BTFSC  FE8.7
0C4EC:  DECF   03,F
0C4EE:  MOVLB  2
0C4F0:  ADDWF  x05,W
0C4F2:  MOVLB  5
0C4F4:  MOVWF  x78
0C4F6:  MOVF   03,W
0C4F8:  MOVLB  2
0C4FA:  ADDWFC x06,W
0C4FC:  MOVLB  5
0C4FE:  MOVWF  x79
....................             if (posY >= 6110) { 
0C500:  BTFSC  x79.7
0C502:  BRA    C51E
0C504:  MOVF   x79,W
0C506:  SUBLW  16
0C508:  BC    C51E
0C50A:  XORLW  FF
0C50C:  BNZ   C514
0C50E:  MOVF   x78,W
0C510:  SUBLW  DD
0C512:  BC    C51E
....................                 posY = 6110; 
0C514:  MOVLW  17
0C516:  MOVWF  x79
0C518:  MOVLW  DE
0C51A:  MOVWF  x78
....................             } else { 
0C51C:  BRA    C538
....................                 posY = motor_pos_y + incremento; 
0C51E:  CLRF   03
0C520:  MOVF   25,W
0C522:  BTFSC  FE8.7
0C524:  DECF   03,F
0C526:  MOVLB  2
0C528:  ADDWF  x05,W
0C52A:  MOVLB  5
0C52C:  MOVWF  x78
0C52E:  MOVF   03,W
0C530:  MOVLB  2
0C532:  ADDWFC x06,W
0C534:  MOVLB  5
0C536:  MOVWF  x79
....................             } 
....................             atras(); 
0C538:  MOVLB  0
0C53A:  CALL   4DCA
....................             motor_run_y(posY, 19); 
0C53E:  MOVLB  5
0C540:  CLRF   x7F
0C542:  CLRF   x7E
0C544:  MOVFF  579,57D
0C548:  MOVFF  578,57C
0C54C:  MOVLW  13
0C54E:  MOVWF  x80
0C550:  MOVLB  0
0C552:  CALL   6622
....................             while ((run_flg_y)); 
0C556:  MOVLB  2
0C558:  BTFSC  x0B.7
0C55A:  BRA    C558
....................             menu_atual = menu_debug_saida_4; 
0C55C:  MOVLW  0B
0C55E:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C560:  MOVLB  0
0C562:  RCALL  C236
....................         break; 
0C564:  BRA    C8D0
....................         case SETA_INFERIOR: 
....................             posY = motor_pos_y - incremento; 
0C566:  CLRF   03
0C568:  MOVF   25,W
0C56A:  BTFSC  FE8.7
0C56C:  DECF   03,F
0C56E:  MOVLB  2
0C570:  SUBWF  x05,W
0C572:  MOVLB  5
0C574:  MOVWF  x78
0C576:  MOVF   03,W
0C578:  MOVLB  2
0C57A:  SUBWFB x06,W
0C57C:  MOVLB  5
0C57E:  MOVWF  x79
....................             if (posY >= 0) { 
0C580:  BTFSC  x79.7
0C582:  BRA    C5A0
....................                posY = motor_pos_y - incremento; 
0C584:  CLRF   03
0C586:  MOVF   25,W
0C588:  BTFSC  FE8.7
0C58A:  DECF   03,F
0C58C:  MOVLB  2
0C58E:  SUBWF  x05,W
0C590:  MOVLB  5
0C592:  MOVWF  x78
0C594:  MOVF   03,W
0C596:  MOVLB  2
0C598:  SUBWFB x06,W
0C59A:  MOVLB  5
0C59C:  MOVWF  x79
....................             } else { 
0C59E:  BRA    C5A4
....................                posY = 0; 
0C5A0:  CLRF   x79
0C5A2:  CLRF   x78
....................             } 
....................             frente(); 
0C5A4:  MOVLB  0
0C5A6:  CALL   4D88
....................             motor_run_y(posY, 19); 
0C5AA:  MOVLB  5
0C5AC:  CLRF   x7F
0C5AE:  CLRF   x7E
0C5B0:  MOVFF  579,57D
0C5B4:  MOVFF  578,57C
0C5B8:  MOVLW  13
0C5BA:  MOVWF  x80
0C5BC:  MOVLB  0
0C5BE:  CALL   6622
....................             while ((run_flg_y)); 
0C5C2:  MOVLB  2
0C5C4:  BTFSC  x0B.7
0C5C6:  BRA    C5C4
....................             menu_atual = menu_debug_saida_4; 
0C5C8:  MOVLW  0B
0C5CA:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C5CC:  MOVLB  0
0C5CE:  RCALL  C236
....................         break; 
0C5D0:  BRA    C8D0
....................         case SETA_DIREITA: 
....................             posX = motor_pos_x - incremento; 
0C5D2:  CLRF   03
0C5D4:  MOVF   25,W
0C5D6:  BTFSC  FE8.7
0C5D8:  DECF   03,F
0C5DA:  MOVLB  2
0C5DC:  SUBWF  x03,W
0C5DE:  MOVLB  5
0C5E0:  MOVWF  x76
0C5E2:  MOVF   03,W
0C5E4:  MOVLB  2
0C5E6:  SUBWFB x04,W
0C5E8:  MOVLB  5
0C5EA:  MOVWF  x77
....................             if (posX >= 0) { 
0C5EC:  BTFSC  x77.7
0C5EE:  BRA    C60C
....................                 posX = motor_pos_x - incremento;                 
0C5F0:  CLRF   03
0C5F2:  MOVF   25,W
0C5F4:  BTFSC  FE8.7
0C5F6:  DECF   03,F
0C5F8:  MOVLB  2
0C5FA:  SUBWF  x03,W
0C5FC:  MOVLB  5
0C5FE:  MOVWF  x76
0C600:  MOVF   03,W
0C602:  MOVLB  2
0C604:  SUBWFB x04,W
0C606:  MOVLB  5
0C608:  MOVWF  x77
....................             } else { 
0C60A:  BRA    C610
....................                posX = 0; 
0C60C:  CLRF   x77
0C60E:  CLRF   x76
....................             } 
....................             direita(); 
0C610:  MOVLB  0
0C612:  CALL   4EF6
....................             motor_run_x(posX, 19); 
0C616:  MOVLB  5
0C618:  CLRF   x7F
0C61A:  CLRF   x7E
0C61C:  MOVFF  577,57D
0C620:  MOVFF  576,57C
0C624:  MOVLW  13
0C626:  MOVWF  x80
0C628:  MOVLB  0
0C62A:  CALL   55F6
....................             while ((run_flg_x)); 
0C62E:  MOVLB  2
0C630:  BTFSC  x0B.5
0C632:  BRA    C630
....................             menu_atual = menu_debug_saida_4; 
0C634:  MOVLW  0B
0C636:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C638:  MOVLB  0
0C63A:  RCALL  C236
....................         break; 
0C63C:  BRA    C8D0
....................         case SETA_ESQUERDA: 
....................             posX = motor_pos_x + incremento; 
0C63E:  CLRF   03
0C640:  MOVF   25,W
0C642:  BTFSC  FE8.7
0C644:  DECF   03,F
0C646:  MOVLB  2
0C648:  ADDWF  x03,W
0C64A:  MOVLB  5
0C64C:  MOVWF  x76
0C64E:  MOVF   03,W
0C650:  MOVLB  2
0C652:  ADDWFC x04,W
0C654:  MOVLB  5
0C656:  MOVWF  x77
....................             if (posX >= 4250) { 
0C658:  BTFSC  x77.7
0C65A:  BRA    C676
0C65C:  MOVF   x77,W
0C65E:  SUBLW  0F
0C660:  BC    C676
0C662:  XORLW  FF
0C664:  BNZ   C66C
0C666:  MOVF   x76,W
0C668:  SUBLW  99
0C66A:  BC    C676
....................                 posX = 4250; 
0C66C:  MOVLW  10
0C66E:  MOVWF  x77
0C670:  MOVLW  9A
0C672:  MOVWF  x76
....................             } else { 
0C674:  BRA    C690
....................                 posX = motor_pos_x + incremento; 
0C676:  CLRF   03
0C678:  MOVF   25,W
0C67A:  BTFSC  FE8.7
0C67C:  DECF   03,F
0C67E:  MOVLB  2
0C680:  ADDWF  x03,W
0C682:  MOVLB  5
0C684:  MOVWF  x76
0C686:  MOVF   03,W
0C688:  MOVLB  2
0C68A:  ADDWFC x04,W
0C68C:  MOVLB  5
0C68E:  MOVWF  x77
....................             } 
....................             esquerda(); 
0C690:  MOVLB  0
0C692:  CALL   4F38
....................             motor_run_x(posX, 19); 
0C696:  MOVLB  5
0C698:  CLRF   x7F
0C69A:  CLRF   x7E
0C69C:  MOVFF  577,57D
0C6A0:  MOVFF  576,57C
0C6A4:  MOVLW  13
0C6A6:  MOVWF  x80
0C6A8:  MOVLB  0
0C6AA:  CALL   55F6
....................             while ((run_flg_x)); 
0C6AE:  MOVLB  2
0C6B0:  BTFSC  x0B.5
0C6B2:  BRA    C6B0
....................             menu_atual = menu_debug_saida_4; 
0C6B4:  MOVLW  0B
0C6B6:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C6B8:  MOVLB  0
0C6BA:  RCALL  C236
....................         break; 
0C6BC:  BRA    C8D0
....................         case F2: 
....................             posZ = motor_pos_z - incremento; 
0C6BE:  CLRF   03
0C6C0:  MOVF   25,W
0C6C2:  BTFSC  FE8.7
0C6C4:  DECF   03,F
0C6C6:  MOVLB  2
0C6C8:  SUBWF  x09,W
0C6CA:  MOVLB  5
0C6CC:  MOVWF  x7A
0C6CE:  MOVF   03,W
0C6D0:  MOVLB  2
0C6D2:  SUBWFB x0A,W
0C6D4:  MOVLB  5
0C6D6:  MOVWF  x7B
....................             if (posZ >= 0) { 
0C6D8:  BTFSC  x7B.7
0C6DA:  BRA    C6F8
....................                 posZ = motor_pos_z - incremento;                 
0C6DC:  CLRF   03
0C6DE:  MOVF   25,W
0C6E0:  BTFSC  FE8.7
0C6E2:  DECF   03,F
0C6E4:  MOVLB  2
0C6E6:  SUBWF  x09,W
0C6E8:  MOVLB  5
0C6EA:  MOVWF  x7A
0C6EC:  MOVF   03,W
0C6EE:  MOVLB  2
0C6F0:  SUBWFB x0A,W
0C6F2:  MOVLB  5
0C6F4:  MOVWF  x7B
....................             } else { 
0C6F6:  BRA    C6FC
....................                posZ = 0; 
0C6F8:  CLRF   x7B
0C6FA:  CLRF   x7A
....................             } 
....................             sobe(); 
0C6FC:  MOVLB  0
0C6FE:  CALL   4C78
....................             motor_run_z(posZ, 19); 
0C702:  MOVLB  5
0C704:  CLRF   x7F
0C706:  CLRF   x7E
0C708:  MOVFF  57B,57D
0C70C:  MOVFF  57A,57C
0C710:  MOVLW  13
0C712:  MOVWF  x80
0C714:  MOVLB  0
0C716:  CALL   63C2
....................             while ((run_flg_z)); 
0C71A:  MOVLB  3
0C71C:  BTFSC  xB7.2
0C71E:  BRA    C71C
....................             menu_atual = menu_debug_saida_4; 
0C720:  MOVLW  0B
0C722:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C724:  MOVLB  0
0C726:  RCALL  C236
....................         break; 
0C728:  BRA    C8D0
....................         case F4: 
....................             posZ = motor_pos_z + incremento; 
0C72A:  CLRF   03
0C72C:  MOVF   25,W
0C72E:  BTFSC  FE8.7
0C730:  DECF   03,F
0C732:  MOVLB  2
0C734:  ADDWF  x09,W
0C736:  MOVLB  5
0C738:  MOVWF  x7A
0C73A:  MOVF   03,W
0C73C:  MOVLB  2
0C73E:  ADDWFC x0A,W
0C740:  MOVLB  5
0C742:  MOVWF  x7B
....................             if (posZ >= 370) { 
0C744:  BTFSC  x7B.7
0C746:  BRA    C762
0C748:  MOVF   x7B,W
0C74A:  SUBLW  00
0C74C:  BC    C762
0C74E:  XORLW  FF
0C750:  BNZ   C758
0C752:  MOVF   x7A,W
0C754:  SUBLW  71
0C756:  BC    C762
....................                 posZ = 370;                 
0C758:  MOVLW  01
0C75A:  MOVWF  x7B
0C75C:  MOVLW  72
0C75E:  MOVWF  x7A
....................             } else { 
0C760:  BRA    C77C
....................                posZ = motor_pos_z + incremento; 
0C762:  CLRF   03
0C764:  MOVF   25,W
0C766:  BTFSC  FE8.7
0C768:  DECF   03,F
0C76A:  MOVLB  2
0C76C:  ADDWF  x09,W
0C76E:  MOVLB  5
0C770:  MOVWF  x7A
0C772:  MOVF   03,W
0C774:  MOVLB  2
0C776:  ADDWFC x0A,W
0C778:  MOVLB  5
0C77A:  MOVWF  x7B
....................             } 
....................             desce(); 
0C77C:  MOVLB  0
0C77E:  CALL   4C36
....................             motor_run_z(posZ, 19); 
0C782:  MOVLB  5
0C784:  CLRF   x7F
0C786:  CLRF   x7E
0C788:  MOVFF  57B,57D
0C78C:  MOVFF  57A,57C
0C790:  MOVLW  13
0C792:  MOVWF  x80
0C794:  MOVLB  0
0C796:  CALL   63C2
....................             while ((run_flg_z)); 
0C79A:  MOVLB  3
0C79C:  BTFSC  xB7.2
0C79E:  BRA    C79C
....................             menu_atual = menu_debug_saida_4; 
0C7A0:  MOVLW  0B
0C7A2:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C7A4:  MOVLB  0
0C7A6:  RCALL  C236
....................         break; 
0C7A8:  BRA    C8D0
....................         case 8: 
....................             posFlip = motor_pos_flip + incremento; 
0C7AA:  CLRF   03
0C7AC:  MOVF   25,W
0C7AE:  BTFSC  FE8.7
0C7B0:  DECF   03,F
0C7B2:  MOVLB  2
0C7B4:  ADDWF  x07,W
0C7B6:  MOVLB  5
0C7B8:  MOVWF  x74
0C7BA:  MOVF   03,W
0C7BC:  MOVLB  2
0C7BE:  ADDWFC x08,W
0C7C0:  MOVLB  5
0C7C2:  MOVWF  x75
....................             if (posFlip >= 2000) { 
0C7C4:  BTFSC  x75.7
0C7C6:  BRA    C7E2
0C7C8:  MOVF   x75,W
0C7CA:  SUBLW  06
0C7CC:  BC    C7E2
0C7CE:  XORLW  FF
0C7D0:  BNZ   C7D8
0C7D2:  MOVF   x74,W
0C7D4:  SUBLW  CF
0C7D6:  BC    C7E2
....................                 posFlip = 2000;                 
0C7D8:  MOVLW  07
0C7DA:  MOVWF  x75
0C7DC:  MOVLW  D0
0C7DE:  MOVWF  x74
....................             } else { 
0C7E0:  BRA    C7FC
....................                posFlip = motor_pos_flip + incremento; 
0C7E2:  CLRF   03
0C7E4:  MOVF   25,W
0C7E6:  BTFSC  FE8.7
0C7E8:  DECF   03,F
0C7EA:  MOVLB  2
0C7EC:  ADDWF  x07,W
0C7EE:  MOVLB  5
0C7F0:  MOVWF  x74
0C7F2:  MOVF   03,W
0C7F4:  MOVLB  2
0C7F6:  ADDWFC x08,W
0C7F8:  MOVLB  5
0C7FA:  MOVWF  x75
....................             } 
....................             motor_run_flip(posFlip, 19); 
0C7FC:  CLRF   x7F
0C7FE:  CLRF   x7E
0C800:  MOVFF  575,57D
0C804:  MOVFF  574,57C
0C808:  MOVLW  13
0C80A:  MOVWF  x80
0C80C:  MOVLB  0
0C80E:  CALL   680C
....................             while ((run_flg_flip)); 
0C812:  BTFSC  2D.3
0C814:  BRA    C812
....................             menu_atual = menu_debug_saida_4; 
0C816:  MOVLW  0B
0C818:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C81A:  RCALL  C236
....................         break; 
0C81C:  BRA    C8D0
....................         case 0: 
....................             posFlip = motor_pos_flip - incremento; 
0C81E:  CLRF   03
0C820:  MOVF   25,W
0C822:  BTFSC  FE8.7
0C824:  DECF   03,F
0C826:  MOVLB  2
0C828:  SUBWF  x07,W
0C82A:  MOVLB  5
0C82C:  MOVWF  x74
0C82E:  MOVF   03,W
0C830:  MOVLB  2
0C832:  SUBWFB x08,W
0C834:  MOVLB  5
0C836:  MOVWF  x75
....................             if (posFlip >= 0) { 
0C838:  BTFSC  x75.7
0C83A:  BRA    C858
....................                 posFlip = motor_pos_flip - incremento;                                
0C83C:  CLRF   03
0C83E:  MOVF   25,W
0C840:  BTFSC  FE8.7
0C842:  DECF   03,F
0C844:  MOVLB  2
0C846:  SUBWF  x07,W
0C848:  MOVLB  5
0C84A:  MOVWF  x74
0C84C:  MOVF   03,W
0C84E:  MOVLB  2
0C850:  SUBWFB x08,W
0C852:  MOVLB  5
0C854:  MOVWF  x75
....................             } else { 
0C856:  BRA    C85C
....................                posFlip = 0;  
0C858:  CLRF   x75
0C85A:  CLRF   x74
....................             } 
....................             motor_run_flip(posFlip, 19); 
0C85C:  CLRF   x7F
0C85E:  CLRF   x7E
0C860:  MOVFF  575,57D
0C864:  MOVFF  574,57C
0C868:  MOVLW  13
0C86A:  MOVWF  x80
0C86C:  MOVLB  0
0C86E:  CALL   680C
....................             while ((run_flg_flip)); 
0C872:  BTFSC  2D.3
0C874:  BRA    C872
....................             menu_atual = menu_debug_saida_4; 
0C876:  MOVLW  0B
0C878:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C87A:  RCALL  C236
....................         break; 
0C87C:  BRA    C8D0
....................         case 2:           
....................             sobe_ferros(); 
0C87E:  CALL   7A06
....................             desliga_pressor(); 
0C882:  CALL   7796
....................         break; 
0C886:  BRA    C8D0
....................         case 5: 
....................             desce_ferros(1); 
0C888:  MOVLW  01
0C88A:  MOVLB  5
0C88C:  MOVWF  x7C
0C88E:  MOVLB  0
0C890:  CALL   7A24
....................             liga_pressor(); 
0C894:  CALL   7A76
....................         break; 
0C898:  BRA    C8D0
....................         case 9: 
....................             switch (incremento){ 
0C89A:  MOVF   25,W
0C89C:  XORLW  01
0C89E:  BZ    C8AA
0C8A0:  XORLW  0B
0C8A2:  BZ    C8B0
0C8A4:  XORLW  6E
0C8A6:  BZ    C8B6
0C8A8:  BRA    C8BA
....................                 case 1: 
....................                     incremento = 10; 
0C8AA:  MOVLW  0A
0C8AC:  MOVWF  25
....................                 break; 
0C8AE:  BRA    C8BA
....................                 case 10: 
....................                     incremento = 100; 
0C8B0:  MOVLW  64
0C8B2:  MOVWF  25
....................                 break; 
0C8B4:  BRA    C8BA
....................                 case 100: 
....................                     incremento = 1; 
0C8B6:  MOVLW  01
0C8B8:  MOVWF  25
....................                 break; 
....................             }             
....................             menu_atual = menu_debug_saida_4; 
0C8BA:  MOVLW  0B
0C8BC:  MOVWF  1C
....................             tela_debug_saida_4(); 
0C8BE:  RCALL  C236
....................         break; 
0C8C0:  BRA    C8D0
....................         case ESC: 
....................             incremento = 1; 
0C8C2:  MOVLW  01
0C8C4:  MOVWF  25
....................             ponteiro_lcd = 1; 
0C8C6:  MOVWF  21
....................             menu_atual = menu_debug_saida_1; 
0C8C8:  MOVLW  08
0C8CA:  MOVWF  1C
....................             tela_debug_saida_1(); 
0C8CC:  CALL   B7AE
....................         break; 
....................     } 
0C8D0:  GOTO   DB2A (RETURN)
.................... } 
....................  
.................... void programa_principal_teste(){ 
*
0D194:  MOVLB  5
0D196:  CLRF   x74
....................     int i = 0; 
....................     short x; 
....................     short y; 
....................     short f; 
....................     short b; 
....................     int sair; 
....................     while (exit){ 
0D198:  BTFSS  2D.1
0D19A:  BRA    D634
....................         switch (i){ 
0D19C:  MOVF   x74,W
0D19E:  ADDLW  F1
0D1A0:  BTFSC  FD8.0
0D1A2:  BRA    D612
0D1A4:  ADDLW  0F
0D1A6:  MOVLB  0
0D1A8:  GOTO   D656
....................             case 0: 
....................                 f = statusSolda(); 
0D1AC:  CALL   84C8
0D1B0:  MOVLB  5
0D1B2:  BCF    x75.2
0D1B4:  BTFSC  01.0
0D1B6:  BSF    x75.2
....................                 if (f == 0){ 
0D1B8:  BTFSC  x75.2
0D1BA:  BRA    D1C2
....................                     sair = 1; 
0D1BC:  MOVLW  01
0D1BE:  MOVWF  x76
....................                 } else { 
0D1C0:  BRA    D1C4
....................                     sair = 0; 
0D1C2:  CLRF   x76
....................                 } 
....................                 i++; 
0D1C4:  INCF   x74,F
....................             break; 
0D1C6:  BRA    D612
....................             case 1: 
....................                 b = le_Input(S_BANDEJA); 
0D1C8:  MOVLW  15
0D1CA:  MOVLB  5
0D1CC:  MOVWF  x78
0D1CE:  MOVLB  0
0D1D0:  CALL   49FA
0D1D4:  MOVLB  5
0D1D6:  BCF    x75.3
0D1D8:  BTFSC  01.0
0D1DA:  BSF    x75.3
....................                 if (b == 1){ 
0D1DC:  BTFSS  x75.3
0D1DE:  BRA    D1EC
....................                     liga_esteira(); 
0D1E0:  MOVLB  0
0D1E2:  CALL   B39C
....................                     i++;  
0D1E6:  MOVLB  5
0D1E8:  INCF   x74,F
....................                 } else { 
0D1EA:  BRA    D1F8
....................                     liga_pressor(); 
0D1EC:  MOVLB  0
0D1EE:  CALL   7A76
....................                     i = 4; 
0D1F2:  MOVLW  04
0D1F4:  MOVLB  5
0D1F6:  MOVWF  x74
....................                 }                 
....................             break; 
0D1F8:  BRA    D612
....................             case 2: 
....................                 x = le_Input(S_ESTEIRA); 
0D1FA:  MOVLW  19
0D1FC:  MOVLB  5
0D1FE:  MOVWF  x78
0D200:  MOVLB  0
0D202:  CALL   49FA
0D206:  MOVLB  5
0D208:  BCF    x75.0
0D20A:  BTFSC  01.0
0D20C:  BSF    x75.0
....................                 while ((x == 0)&&(exit == 1)){ 
0D20E:  BTFSC  x75.0
0D210:  BRA    D298
0D212:  BTFSS  2D.1
0D214:  BRA    D298
....................                     printf(lcd_putc, "\f"); //limpa display 
0D216:  MOVLW  0C
0D218:  MOVWF  x85
0D21A:  MOVLB  0
0D21C:  CALL   2D30
....................                     printf(lcd_putc, "   ESPERANDO PLACA   \n\r"); 
0D220:  MOVLW  90
0D222:  MOVWF  FF6
0D224:  MOVLW  10
0D226:  MOVWF  FF7
0D228:  CALL   2D86
....................                     printf(lcd_putc, "     NA ESTEIRA     \n\r");                     
0D22C:  MOVLW  A8
0D22E:  MOVWF  FF6
0D230:  MOVLW  10
0D232:  MOVWF  FF7
0D234:  CALL   2D86
....................                     x = le_Input(S_ESTEIRA); 
0D238:  MOVLW  19
0D23A:  MOVLB  5
0D23C:  MOVWF  x78
0D23E:  MOVLB  0
0D240:  CALL   49FA
0D244:  MOVLB  5
0D246:  BCF    x75.0
0D248:  BTFSC  01.0
0D24A:  BSF    x75.0
....................                     if (Teclado() == ESC){ 
0D24C:  MOVLB  0
0D24E:  CALL   5B66
0D252:  MOVF   01,W
0D254:  SUBLW  12
0D256:  BNZ   D294
....................                         printf(lcd_putc, "\f"); //limpa display 
0D258:  MOVLW  0C
0D25A:  MOVLB  5
0D25C:  MOVWF  x85
0D25E:  MOVLB  0
0D260:  CALL   2D30
....................                         printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0D264:  MOVLW  C0
0D266:  MOVWF  FF6
0D268:  MOVLW  10
0D26A:  MOVWF  FF7
0D26C:  CALL   2D86
....................                         printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D270:  MOVLW  D8
0D272:  MOVWF  FF6
0D274:  MOVLW  10
0D276:  MOVWF  FF7
0D278:  CALL   2D86
....................                         delay_ms(2000); 
0D27C:  MOVLW  08
0D27E:  MOVLB  5
0D280:  MOVWF  x77
0D282:  MOVLW  FA
0D284:  MOVWF  x91
0D286:  MOVLB  0
0D288:  CALL   2954
0D28C:  MOVLB  5
0D28E:  DECFSZ x77,F
0D290:  BRA    D282
....................                         exit = FALSE; 
0D292:  BCF    2D.1
....................                     } 
0D294:  MOVLB  5
0D296:  BRA    D20E
....................                 } 
....................                 if (exit == 1){ 
0D298:  BTFSS  2D.1
0D29A:  BRA    D2AC
....................                     desliga_esteira(); 
0D29C:  MOVLB  0
0D29E:  CALL   B3AC
....................                     empurra_placa(); 
0D2A2:  CALL   B3BC
....................                     i++; 
0D2A6:  MOVLB  5
0D2A8:  INCF   x74,F
....................                 } else { 
0D2AA:  BRA    D2B4
....................                     desliga_esteira(); 
0D2AC:  MOVLB  0
0D2AE:  CALL   B3AC
0D2B2:  MOVLB  5
....................                 }                                 
....................             break; 
0D2B4:  BRA    D612
....................             case 3: 
....................                 y = le_Input(S_BANDEJA); 
0D2B6:  MOVLW  15
0D2B8:  MOVLB  5
0D2BA:  MOVWF  x78
0D2BC:  MOVLB  0
0D2BE:  CALL   49FA
0D2C2:  MOVLB  5
0D2C4:  BCF    x75.1
0D2C6:  BTFSC  01.0
0D2C8:  BSF    x75.1
....................                 while ((y == 1)&&(exit ==1)){ 
0D2CA:  BTFSS  x75.1
0D2CC:  BRA    D354
0D2CE:  BTFSS  2D.1
0D2D0:  BRA    D354
....................                     printf(lcd_putc, "\f"); //limpa display 
0D2D2:  MOVLW  0C
0D2D4:  MOVWF  x85
0D2D6:  MOVLB  0
0D2D8:  CALL   2D30
....................                     printf(lcd_putc, "      SEM PLACA     \n\r"); 
0D2DC:  MOVLW  F0
0D2DE:  MOVWF  FF6
0D2E0:  MOVLW  10
0D2E2:  MOVWF  FF7
0D2E4:  CALL   2D86
....................                     printf(lcd_putc, "     NA BANDEJA     \n\r");                  
0D2E8:  MOVLW  08
0D2EA:  MOVWF  FF6
0D2EC:  MOVLW  11
0D2EE:  MOVWF  FF7
0D2F0:  CALL   2D86
....................                     y = le_Input(S_BANDEJA); 
0D2F4:  MOVLW  15
0D2F6:  MOVLB  5
0D2F8:  MOVWF  x78
0D2FA:  MOVLB  0
0D2FC:  CALL   49FA
0D300:  MOVLB  5
0D302:  BCF    x75.1
0D304:  BTFSC  01.0
0D306:  BSF    x75.1
....................                     if (Teclado() == ESC){ 
0D308:  MOVLB  0
0D30A:  CALL   5B66
0D30E:  MOVF   01,W
0D310:  SUBLW  12
0D312:  BNZ   D350
....................                         printf(lcd_putc, "\f"); //limpa display 
0D314:  MOVLW  0C
0D316:  MOVLB  5
0D318:  MOVWF  x85
0D31A:  MOVLB  0
0D31C:  CALL   2D30
....................                         printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0D320:  MOVLW  20
0D322:  MOVWF  FF6
0D324:  MOVLW  11
0D326:  MOVWF  FF7
0D328:  CALL   2D86
....................                         printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D32C:  MOVLW  38
0D32E:  MOVWF  FF6
0D330:  MOVLW  11
0D332:  MOVWF  FF7
0D334:  CALL   2D86
....................                         delay_ms(2000); 
0D338:  MOVLW  08
0D33A:  MOVLB  5
0D33C:  MOVWF  x77
0D33E:  MOVLW  FA
0D340:  MOVWF  x91
0D342:  MOVLB  0
0D344:  CALL   2954
0D348:  MOVLB  5
0D34A:  DECFSZ x77,F
0D34C:  BRA    D33E
....................                         exit = FALSE; 
0D34E:  BCF    2D.1
....................                     } 
0D350:  MOVLB  5
0D352:  BRA    D2CA
....................                 } 
....................                 if (exit == 1){ 
0D354:  BTFSS  2D.1
0D356:  BRA    D364
....................                     liga_pressor(); 
0D358:  MOVLB  0
0D35A:  CALL   7A76
....................                     i++; 
0D35E:  MOVLB  5
0D360:  INCF   x74,F
....................                 } else { 
0D362:  BRA    D36C
....................                     desliga_pressor(); 
0D364:  MOVLB  0
0D366:  CALL   7796
0D36A:  MOVLB  5
....................                 }                 
....................             break; 
0D36C:  BRA    D612
....................             case 4: 
....................                 envia_maquina_para_posicao(HOME1); 
0D36E:  MOVLW  01
0D370:  MOVLB  5
0D372:  MOVWF  x77
0D374:  MOVLB  0
0D376:  CALL   69E4
....................                 if (Teclado() == ESC){ 
0D37A:  CALL   5B66
0D37E:  MOVF   01,W
0D380:  SUBLW  12
0D382:  BNZ   D3CE
....................                     printf(lcd_putc, "\f"); //limpa display 
0D384:  MOVLW  0C
0D386:  MOVLB  5
0D388:  MOVWF  x85
0D38A:  MOVLB  0
0D38C:  CALL   2D30
....................                     printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0D390:  MOVLW  50
0D392:  MOVWF  FF6
0D394:  MOVLW  11
0D396:  MOVWF  FF7
0D398:  CALL   2D86
....................                     printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D39C:  MOVLW  68
0D39E:  MOVWF  FF6
0D3A0:  MOVLW  11
0D3A2:  MOVWF  FF7
0D3A4:  CALL   2D86
....................                     delay_ms(2000); 
0D3A8:  MOVLW  08
0D3AA:  MOVLB  5
0D3AC:  MOVWF  x77
0D3AE:  MOVLW  FA
0D3B0:  MOVWF  x91
0D3B2:  MOVLB  0
0D3B4:  CALL   2954
0D3B8:  MOVLB  5
0D3BA:  DECFSZ x77,F
0D3BC:  BRA    D3AE
....................                     sair = 1; 
0D3BE:  MOVLW  01
0D3C0:  MOVWF  x76
....................                     envia_maquina_para_posicao(ALIMENTADOR); 
0D3C2:  CLRF   x77
0D3C4:  MOVLB  0
0D3C6:  CALL   69E4
....................                     desliga_pressor(); 
0D3CA:  CALL   7796
....................                 } 
....................                 i++; 
0D3CE:  MOVLB  5
0D3D0:  INCF   x74,F
....................             break;  
0D3D2:  BRA    D612
....................             case 5: 
....................                 envia_maquina_para_posicao(SOLDAGEM); 
0D3D4:  MOVLW  03
0D3D6:  MOVLB  5
0D3D8:  MOVWF  x77
0D3DA:  MOVLB  0
0D3DC:  CALL   69E4
....................                 if (Teclado() == ESC){ 
0D3E0:  CALL   5B66
0D3E4:  MOVF   01,W
0D3E6:  SUBLW  12
0D3E8:  BNZ   D43E
....................                     printf(lcd_putc, "\f"); //limpa display 
0D3EA:  MOVLW  0C
0D3EC:  MOVLB  5
0D3EE:  MOVWF  x85
0D3F0:  MOVLB  0
0D3F2:  CALL   2D30
....................                     printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0D3F6:  MOVLW  80
0D3F8:  MOVWF  FF6
0D3FA:  MOVLW  11
0D3FC:  MOVWF  FF7
0D3FE:  CALL   2D86
....................                     printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D402:  MOVLW  98
0D404:  MOVWF  FF6
0D406:  MOVLW  11
0D408:  MOVWF  FF7
0D40A:  CALL   2D86
....................                     delay_ms(2000); 
0D40E:  MOVLW  08
0D410:  MOVLB  5
0D412:  MOVWF  x77
0D414:  MOVLW  FA
0D416:  MOVWF  x91
0D418:  MOVLB  0
0D41A:  CALL   2954
0D41E:  MOVLB  5
0D420:  DECFSZ x77,F
0D422:  BRA    D414
....................                     sair = 1; 
0D424:  MOVLW  01
0D426:  MOVWF  x76
....................                     envia_maquina_para_posicao(HOME1); 
0D428:  MOVWF  x77
0D42A:  MOVLB  0
0D42C:  CALL   69E4
....................                     envia_maquina_para_posicao(ALIMENTADOR); 
0D430:  MOVLB  5
0D432:  CLRF   x77
0D434:  MOVLB  0
0D436:  CALL   69E4
....................                     desliga_pressor(); 
0D43A:  CALL   7796
....................                 } 
....................                 i++; 
0D43E:  MOVLB  5
0D440:  INCF   x74,F
....................             break; 
0D442:  BRA    D612
....................             case 6: 
....................                 soldar(); 
0D444:  GOTO   C91E
....................                 motor_run_x(3835, 19); 
0D448:  MOVLB  5
0D44A:  CLRF   x7F
0D44C:  CLRF   x7E
0D44E:  MOVLW  0E
0D450:  MOVWF  x7D
0D452:  MOVLW  FB
0D454:  MOVWF  x7C
0D456:  MOVLW  13
0D458:  MOVWF  x80
0D45A:  MOVLB  0
0D45C:  CALL   55F6
....................                 motor_run_y(2540, 19); 
0D460:  MOVLB  5
0D462:  CLRF   x7F
0D464:  CLRF   x7E
0D466:  MOVLW  09
0D468:  MOVWF  x7D
0D46A:  MOVLW  EC
0D46C:  MOVWF  x7C
0D46E:  MOVLW  13
0D470:  MOVWF  x80
0D472:  MOVLB  0
0D474:  CALL   6622
....................                 if (Teclado() == ESC){ 
0D478:  CALL   5B66
0D47C:  MOVF   01,W
0D47E:  SUBLW  12
0D480:  BNZ   D48A
....................                     sair = 1; 
0D482:  MOVLW  01
0D484:  MOVLB  5
0D486:  MOVWF  x76
0D488:  MOVLB  0
....................                 } 
....................                 i++; 
0D48A:  MOVLB  5
0D48C:  INCF   x74,F
....................             break; 
0D48E:  BRA    D612
....................             case 7: 
....................                 envia_maquina_para_posicao(HOME2); 
0D490:  MOVLW  04
0D492:  MOVLB  5
0D494:  MOVWF  x77
0D496:  MOVLB  0
0D498:  CALL   69E4
....................                 if (Teclado() == ESC){ 
0D49C:  CALL   5B66
0D4A0:  MOVF   01,W
0D4A2:  SUBLW  12
0D4A4:  BNZ   D4E6
....................                     printf(lcd_putc, "\f"); //limpa display 
0D4A6:  MOVLW  0C
0D4A8:  MOVLB  5
0D4AA:  MOVWF  x85
0D4AC:  MOVLB  0
0D4AE:  CALL   2D30
....................                    printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0D4B2:  MOVLW  B0
0D4B4:  MOVWF  FF6
0D4B6:  MOVLW  11
0D4B8:  MOVWF  FF7
0D4BA:  CALL   2D86
....................                     printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D4BE:  MOVLW  C8
0D4C0:  MOVWF  FF6
0D4C2:  MOVLW  11
0D4C4:  MOVWF  FF7
0D4C6:  CALL   2D86
....................                     delay_ms(2000); 
0D4CA:  MOVLW  08
0D4CC:  MOVLB  5
0D4CE:  MOVWF  x77
0D4D0:  MOVLW  FA
0D4D2:  MOVWF  x91
0D4D4:  MOVLB  0
0D4D6:  CALL   2954
0D4DA:  MOVLB  5
0D4DC:  DECFSZ x77,F
0D4DE:  BRA    D4D0
....................                     sair = 1; 
0D4E0:  MOVLW  01
0D4E2:  MOVWF  x76
0D4E4:  MOVLB  0
....................                 } 
....................                 i++; 
0D4E6:  MOVLB  5
0D4E8:  INCF   x74,F
....................             break; 
0D4EA:  BRA    D612
....................             case 8: 
....................                 envia_maquina_para_posicao(DISPENSADOR); 
0D4EC:  MOVLW  05
0D4EE:  MOVLB  5
0D4F0:  MOVWF  x77
0D4F2:  MOVLB  0
0D4F4:  CALL   69E4
....................                 if (Teclado() == ESC){ 
0D4F8:  CALL   5B66
0D4FC:  MOVF   01,W
0D4FE:  SUBLW  12
0D500:  BNZ   D542
....................                     printf(lcd_putc, "\f"); //limpa display 
0D502:  MOVLW  0C
0D504:  MOVLB  5
0D506:  MOVWF  x85
0D508:  MOVLB  0
0D50A:  CALL   2D30
....................                     printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0D50E:  MOVLW  E0
0D510:  MOVWF  FF6
0D512:  MOVLW  11
0D514:  MOVWF  FF7
0D516:  CALL   2D86
....................                     printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D51A:  MOVLW  F8
0D51C:  MOVWF  FF6
0D51E:  MOVLW  11
0D520:  MOVWF  FF7
0D522:  CALL   2D86
....................                     delay_ms(2000); 
0D526:  MOVLW  08
0D528:  MOVLB  5
0D52A:  MOVWF  x77
0D52C:  MOVLW  FA
0D52E:  MOVWF  x91
0D530:  MOVLB  0
0D532:  CALL   2954
0D536:  MOVLB  5
0D538:  DECFSZ x77,F
0D53A:  BRA    D52C
....................                     sair = 1; 
0D53C:  MOVLW  01
0D53E:  MOVWF  x76
0D540:  MOVLB  0
....................                 } 
....................                 i++; 
0D542:  MOVLB  5
0D544:  INCF   x74,F
....................             break; 
0D546:  BRA    D612
....................             case 9: 
....................                 desliga_pressor(); 
0D548:  CALL   7796
....................                 dispensa_placa(); 
0D54C:  BRA    D0EC
....................                 if (Teclado() == ESC){ 
0D54E:  CALL   5B66
0D552:  MOVF   01,W
0D554:  SUBLW  12
0D556:  BNZ   D598
....................                     printf(lcd_putc, "\f"); //limpa display 
0D558:  MOVLW  0C
0D55A:  MOVLB  5
0D55C:  MOVWF  x85
0D55E:  MOVLB  0
0D560:  CALL   2D30
....................                     printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0D564:  MOVLW  10
0D566:  MOVWF  FF6
0D568:  MOVLW  12
0D56A:  MOVWF  FF7
0D56C:  CALL   2D86
....................                     printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D570:  MOVLW  28
0D572:  MOVWF  FF6
0D574:  MOVLW  12
0D576:  MOVWF  FF7
0D578:  CALL   2D86
....................                     delay_ms(2000); 
0D57C:  MOVLW  08
0D57E:  MOVLB  5
0D580:  MOVWF  x77
0D582:  MOVLW  FA
0D584:  MOVWF  x91
0D586:  MOVLB  0
0D588:  CALL   2954
0D58C:  MOVLB  5
0D58E:  DECFSZ x77,F
0D590:  BRA    D582
....................                     sair = 1; 
0D592:  MOVLW  01
0D594:  MOVWF  x76
0D596:  MOVLB  0
....................                 } 
....................                 i++; 
0D598:  MOVLB  5
0D59A:  INCF   x74,F
....................             break; 
0D59C:  BRA    D612
....................             case 10: 
....................                 //envia_maquina_para_posicao(HOME2); 
....................                 //if (Teclado() == ESC){ 
....................                 //    printf(lcd_putc, "\f"); //limpa display 
....................                 //    printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
....................                 //    printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
....................                 //    delay_ms(2000); 
....................                 //    sair = 1; 
....................                 //} 
....................                 i++; 
0D59E:  MOVLB  5
0D5A0:  INCF   x74,F
....................             break; 
0D5A2:  BRA    D612
....................             case 11: 
....................                 i++;  
0D5A4:  MOVLB  5
0D5A6:  INCF   x74,F
....................             break; 
0D5A8:  BRA    D612
....................             case 12: 
....................                 i++; 
0D5AA:  MOVLB  5
0D5AC:  INCF   x74,F
....................             break; 
0D5AE:  BRA    D612
....................             case 13: 
....................                 //sobe_ferros(); 
....................                 //desaciona_saida(LIMPA_BICO1); 
....................                 //desaciona_saida(LIMPA_BICO2); 
....................                 //envia_maquina_para_posicao(HOME1); 
....................                 //if (Teclado() == ESC){ 
....................                 //    printf(lcd_putc, "\f"); //limpa display 
....................                 //    printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
....................                 //    printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
....................                 //    delay_ms(2000); 
....................                 //    sair = 1; 
....................                 //} 
....................                 i++; 
0D5B0:  MOVLB  5
0D5B2:  INCF   x74,F
....................             break; 
0D5B4:  BRA    D612
....................             case 14: 
....................                 envia_maquina_para_posicao(ALIMENTADOR); 
0D5B6:  MOVLB  5
0D5B8:  CLRF   x77
0D5BA:  MOVLB  0
0D5BC:  CALL   69E4
....................                 if (Teclado() == ESC){ 
0D5C0:  CALL   5B66
0D5C4:  MOVF   01,W
0D5C6:  SUBLW  12
0D5C8:  BNZ   D60A
....................                     printf(lcd_putc, "\f"); //limpa display 
0D5CA:  MOVLW  0C
0D5CC:  MOVLB  5
0D5CE:  MOVWF  x85
0D5D0:  MOVLB  0
0D5D2:  CALL   2D30
....................                     printf(lcd_putc, "REINICIO DO PROGRAMA\n\r"); 
0D5D6:  MOVLW  40
0D5D8:  MOVWF  FF6
0D5DA:  MOVLW  12
0D5DC:  MOVWF  FF7
0D5DE:  CALL   2D86
....................                     printf(lcd_putc, "   AO FIM DO CICLO  \n\r"); 
0D5E2:  MOVLW  58
0D5E4:  MOVWF  FF6
0D5E6:  MOVLW  12
0D5E8:  MOVWF  FF7
0D5EA:  CALL   2D86
....................                     delay_ms(2000); 
0D5EE:  MOVLW  08
0D5F0:  MOVLB  5
0D5F2:  MOVWF  x77
0D5F4:  MOVLW  FA
0D5F6:  MOVWF  x91
0D5F8:  MOVLB  0
0D5FA:  CALL   2954
0D5FE:  MOVLB  5
0D600:  DECFSZ x77,F
0D602:  BRA    D5F4
....................                     sair = 1; 
0D604:  MOVLW  01
0D606:  MOVWF  x76
0D608:  MOVLB  0
....................                 } 
....................                 i++; 
0D60A:  MOVLB  5
0D60C:  INCF   x74,F
....................             break; 
0D60E:  BRA    D612
0D610:  MOVLB  5
....................         } 
....................         if (((i==15)||(i<7))&&(sair == 1)){ 
0D612:  MOVF   x74,W
0D614:  SUBLW  0F
0D616:  BZ    D61E
0D618:  MOVF   x74,W
0D61A:  SUBLW  06
0D61C:  BNC   D626
0D61E:  DECFSZ x76,W
0D620:  BRA    D626
....................             exit = FALSE; 
0D622:  BCF    2D.1
....................         } else{ 
0D624:  BRA    D632
....................             if ((i==15)&&(sair ==0)){ 
0D626:  MOVF   x74,W
0D628:  SUBLW  0F
0D62A:  BNZ   D632
0D62C:  MOVF   x76,F
0D62E:  BNZ   D632
....................                 i =0; 
0D630:  CLRF   x74
....................             } 
....................         } 
0D632:  BRA    D198
....................     } 
....................     if ((i == 1)&&(exit == FALSE)){ 
0D634:  DECFSZ x74,W
0D636:  BRA    D64A
0D638:  BTFSC  2D.1
0D63A:  BRA    D64A
....................         menu_atual = menu_faltaSolda; 
0D63C:  MOVLW  13
0D63E:  MOVWF  1C
....................         tela_faltaSolda(); 
0D640:  MOVLB  0
0D642:  CALL   B29A
....................     } else { 
0D646:  BRA    D652
0D648:  MOVLB  5
....................        menu_atual = menu_principal; 
0D64A:  CLRF   1C
....................        tela_principal();  
0D64C:  MOVLB  0
0D64E:  CALL   59D6
....................     }     
0D652:  GOTO   DB32 (RETURN)
.................... } 
....................  
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Interrupoes de Tempo"> 
....................  
.................... #int_timer0 
....................  
.................... void trata_timer0(void) { 
....................     movimenta_eixo_x(); 
*
0180C:  BRA    1750
.................... } 
0180E:  BCF    FF2.2
01810:  GOTO   0078
.................... #int_timer1 
....................  
.................... void trata_timer1(void) { 
....................     movimenta_eixo_y(); 
*
01DB8:  BRA    1CF4
.................... } 
01DBA:  BCF    F9E.0
01DBC:  GOTO   0078
.................... #int_timer2 
....................  
.................... void trata_timer2(void) {//Timer responsavel por contar tempo de execuo 
....................     ciclo++; 
01DC0:  MOVLW  01
01DC2:  ADDWF  29,F
01DC4:  BTFSC  FD8.0
01DC6:  INCF   2A,F
01DC8:  BTFSC  FD8.2
01DCA:  INCF   2B,F
01DCC:  BTFSC  FD8.2
01DCE:  INCF   2C,F
.................... } 
01DD0:  BCF    F9E.1
01DD2:  GOTO   0078
.................... #int_timer3 
....................  
.................... void trata_timer3(void) {     
....................     if (flgMove){ 
*
028F2:  BTFSS  2D.2
028F4:  BRA    28FA
....................         movimenta_eixo_z(); 
028F6:  BRA    22B6
....................     } else { 
028F8:  BRA    28FC
....................         movimenta_eixo_flip(); 
028FA:  BRA    2826
....................     }   
028FC:  BCF    FA1.1
028FE:  GOTO   0078
.................... } 
.................... // </editor-fold> 
....................  
.................... void main() {     
*
0D698:  CLRF   FF8
0D69A:  BCF    FD0.7
0D69C:  BSF    07.7
0D69E:  BSF    F94.3
0D6A0:  BSF    F94.4
0D6A2:  MOVLW  31
0D6A4:  MOVWF  FC8
0D6A6:  MOVLW  28
0D6A8:  MOVWF  FC6
0D6AA:  BSF    FC7.7
0D6AC:  BCF    FC7.6
0D6AE:  CLRF   1C
0D6B0:  MOVLW  01
0D6B2:  MOVWF  21
0D6B4:  CLRF   22
0D6B6:  MOVLW  03
0D6B8:  MOVWF  23
0D6BA:  CLRF   24
0D6BC:  MOVLW  01
0D6BE:  MOVWF  25
0D6C0:  BSF    2D.0
0D6C2:  BSF    2D.1
0D6C4:  BSF    2D.2
0D6C6:  BCF    2D.3
0D6C8:  MOVWF  2E
0D6CA:  MOVLB  1
0D6CC:  CLRF   x2C
0D6CE:  CLRF   x2B
0D6D0:  MOVWF  xFF
0D6D2:  MOVLB  2
0D6D4:  MOVWF  x00
0D6D6:  CLRF   x12
0D6D8:  CLRF   x11
0D6DA:  MOVLW  48
0D6DC:  MOVWF  x10
0D6DE:  MOVLW  86
0D6E0:  MOVWF  x0F
0D6E2:  CLRF   x16
0D6E4:  CLRF   x15
0D6E6:  CLRF   x14
0D6E8:  MOVLW  7F
0D6EA:  MOVWF  x13
0D6EC:  CLRF   x1A
0D6EE:  CLRF   x19
0D6F0:  MOVLW  10
0D6F2:  MOVWF  x18
0D6F4:  MOVLW  82
0D6F6:  MOVWF  x17
0D6F8:  CLRF   x1E
0D6FA:  CLRF   x1D
0D6FC:  MOVLW  16
0D6FE:  MOVWF  x1C
0D700:  MOVLW  86
0D702:  MOVWF  x1B
0D704:  CLRF   x22
0D706:  CLRF   x21
0D708:  MOVLW  16
0D70A:  MOVWF  x20
0D70C:  MOVLW  88
0D70E:  MOVWF  x1F
0D710:  CLRF   x26
0D712:  CLRF   x25
0D714:  MOVLW  48
0D716:  MOVWF  x24
0D718:  MOVLW  86
0D71A:  MOVWF  x23
0D71C:  CLRF   x2A
0D71E:  CLRF   x29
0D720:  MOVLW  61
0D722:  MOVWF  x28
0D724:  MOVLW  87
0D726:  MOVWF  x27
0D728:  CLRF   x2E
0D72A:  CLRF   x2D
0D72C:  CLRF   x2C
0D72E:  CLRF   x2B
0D730:  MOVLW  14
0D732:  MOVWF  x2F
0D734:  CLRF   x33
0D736:  CLRF   x32
0D738:  CLRF   x31
0D73A:  CLRF   x30
0D73C:  CLRF   x37
0D73E:  CLRF   x36
0D740:  MOVLW  48
0D742:  MOVWF  x35
0D744:  MOVLW  85
0D746:  MOVWF  x34
0D748:  CLRF   xD9
0D74A:  CLRF   xD8
0D74C:  CLRF   xDA
0D74E:  CLRF   xDB
0D750:  BCF    x0B.5
0D752:  BCF    x0B.6
0D754:  CLRF   xDD
0D756:  CLRF   xDC
0D758:  CLRF   xDF
0D75A:  CLRF   xDE
0D75C:  CLRF   xE1
0D75E:  CLRF   xE0
0D760:  CLRF   xE3
0D762:  CLRF   xE2
0D764:  CLRF   xE7
0D766:  CLRF   xE6
0D768:  CLRF   xE5
0D76A:  CLRF   xE4
0D76C:  CLRF   xE8
0D76E:  MOVLW  13
0D770:  MOVWF  xE9
0D772:  CLRF   xED
0D774:  CLRF   xEC
0D776:  MOVLW  48
0D778:  MOVWF  xEB
0D77A:  MOVLW  86
0D77C:  MOVWF  xEA
0D77E:  CLRF   xF1
0D780:  CLRF   xF0
0D782:  CLRF   xEF
0D784:  MOVLW  7F
0D786:  MOVWF  xEE
0D788:  CLRF   xF5
0D78A:  CLRF   xF4
0D78C:  MOVLW  10
0D78E:  MOVWF  xF3
0D790:  MOVLW  82
0D792:  MOVWF  xF2
0D794:  CLRF   xF9
0D796:  CLRF   xF8
0D798:  MOVLW  16
0D79A:  MOVWF  xF7
0D79C:  MOVLW  86
0D79E:  MOVWF  xF6
0D7A0:  CLRF   xFD
0D7A2:  CLRF   xFC
0D7A4:  MOVLW  16
0D7A6:  MOVWF  xFB
0D7A8:  MOVLW  88
0D7AA:  MOVWF  xFA
0D7AC:  MOVLB  3
0D7AE:  CLRF   x01
0D7B0:  CLRF   x00
0D7B2:  MOVLW  48
0D7B4:  MOVLB  2
0D7B6:  MOVWF  xFF
0D7B8:  MOVLW  86
0D7BA:  MOVWF  xFE
0D7BC:  MOVLB  3
0D7BE:  CLRF   x05
0D7C0:  CLRF   x04
0D7C2:  MOVLW  61
0D7C4:  MOVWF  x03
0D7C6:  MOVLW  87
0D7C8:  MOVWF  x02
0D7CA:  CLRF   x09
0D7CC:  CLRF   x08
0D7CE:  CLRF   x07
0D7D0:  CLRF   x06
0D7D2:  MOVLW  14
0D7D4:  MOVWF  x0A
0D7D6:  CLRF   x0E
0D7D8:  CLRF   x0D
0D7DA:  CLRF   x0C
0D7DC:  CLRF   x0B
0D7DE:  CLRF   x12
0D7E0:  CLRF   x11
0D7E2:  MOVLW  48
0D7E4:  MOVWF  x10
0D7E6:  MOVLW  85
0D7E8:  MOVWF  x0F
0D7EA:  CLRF   xB4
0D7EC:  CLRF   xB3
0D7EE:  CLRF   xB5
0D7F0:  CLRF   xB6
0D7F2:  MOVLB  2
0D7F4:  BCF    x0B.7
0D7F6:  MOVLB  3
0D7F8:  BCF    xB7.0
0D7FA:  BCF    xB7.1
0D7FC:  CLRF   xB9
0D7FE:  CLRF   xB8
0D800:  CLRF   xBB
0D802:  CLRF   xBA
0D804:  CLRF   xBD
0D806:  CLRF   xBC
0D808:  CLRF   xBF
0D80A:  CLRF   xBE
0D80C:  CLRF   xC3
0D80E:  CLRF   xC2
0D810:  CLRF   xC1
0D812:  CLRF   xC0
0D814:  CLRF   xC4
0D816:  MOVLW  13
0D818:  MOVWF  xC5
0D81A:  CLRF   xC7
0D81C:  CLRF   xC6
0D81E:  CLRF   xCB
0D820:  CLRF   xCA
0D822:  MOVLW  48
0D824:  MOVWF  xC9
0D826:  MOVLW  86
0D828:  MOVWF  xC8
0D82A:  CLRF   xCF
0D82C:  CLRF   xCE
0D82E:  CLRF   xCD
0D830:  MOVLW  7F
0D832:  MOVWF  xCC
0D834:  CLRF   xD3
0D836:  CLRF   xD2
0D838:  MOVLW  10
0D83A:  MOVWF  xD1
0D83C:  MOVLW  82
0D83E:  MOVWF  xD0
0D840:  CLRF   xD7
0D842:  CLRF   xD6
0D844:  MOVLW  16
0D846:  MOVWF  xD5
0D848:  MOVLW  86
0D84A:  MOVWF  xD4
0D84C:  CLRF   xDB
0D84E:  CLRF   xDA
0D850:  MOVLW  16
0D852:  MOVWF  xD9
0D854:  MOVLW  88
0D856:  MOVWF  xD8
0D858:  CLRF   xDF
0D85A:  CLRF   xDE
0D85C:  MOVLW  16
0D85E:  MOVWF  xDD
0D860:  MOVLW  87
0D862:  MOVWF  xDC
0D864:  CLRF   xE3
0D866:  CLRF   xE2
0D868:  CLRF   xE1
0D86A:  CLRF   xE0
0D86C:  MOVLW  14
0D86E:  MOVWF  xE4
0D870:  CLRF   xE8
0D872:  CLRF   xE7
0D874:  CLRF   xE6
0D876:  CLRF   xE5
0D878:  MOVLB  4
0D87A:  CLRF   x8A
0D87C:  CLRF   x89
0D87E:  CLRF   x8B
0D880:  CLRF   x8C
0D882:  MOVLB  3
0D884:  BCF    xB7.2
0D886:  BCF    xB7.3
0D888:  MOVLB  4
0D88A:  CLRF   x8E
0D88C:  CLRF   x8D
0D88E:  CLRF   x90
0D890:  CLRF   x8F
0D892:  CLRF   x92
0D894:  CLRF   x91
0D896:  CLRF   x94
0D898:  CLRF   x93
0D89A:  CLRF   x98
0D89C:  CLRF   x97
0D89E:  CLRF   x96
0D8A0:  CLRF   x95
0D8A2:  CLRF   x99
0D8A4:  MOVLW  13
0D8A6:  MOVWF  x9A
0D8A8:  CLRF   x9C
0D8AA:  CLRF   x9B
0D8AC:  CLRF   xA0
0D8AE:  CLRF   x9F
0D8B0:  MOVLW  48
0D8B2:  MOVWF  x9E
0D8B4:  MOVLW  86
0D8B6:  MOVWF  x9D
0D8B8:  CLRF   xA4
0D8BA:  CLRF   xA3
0D8BC:  CLRF   xA2
0D8BE:  MOVLW  7F
0D8C0:  MOVWF  xA1
0D8C2:  CLRF   xA8
0D8C4:  CLRF   xA7
0D8C6:  MOVLW  10
0D8C8:  MOVWF  xA6
0D8CA:  MOVLW  82
0D8CC:  MOVWF  xA5
0D8CE:  CLRF   xAC
0D8D0:  CLRF   xAB
0D8D2:  MOVLW  16
0D8D4:  MOVWF  xAA
0D8D6:  MOVLW  86
0D8D8:  MOVWF  xA9
0D8DA:  CLRF   xB0
0D8DC:  CLRF   xAF
0D8DE:  MOVLW  16
0D8E0:  MOVWF  xAE
0D8E2:  MOVLW  88
0D8E4:  MOVWF  xAD
0D8E6:  CLRF   xB4
0D8E8:  CLRF   xB3
0D8EA:  MOVLW  16
0D8EC:  MOVWF  xB2
0D8EE:  MOVLW  87
0D8F0:  MOVWF  xB1
0D8F2:  CLRF   xB8
0D8F4:  CLRF   xB7
0D8F6:  CLRF   xB6
0D8F8:  CLRF   xB5
0D8FA:  MOVLW  14
0D8FC:  MOVWF  xB9
0D8FE:  CLRF   xBD
0D900:  CLRF   xBC
0D902:  CLRF   xBB
0D904:  CLRF   xBA
0D906:  MOVLB  5
0D908:  CLRF   x5F
0D90A:  CLRF   x5E
0D90C:  CLRF   x60
0D90E:  CLRF   x61
0D910:  MOVLB  3
0D912:  BCF    xB7.4
0D914:  MOVLB  5
0D916:  CLRF   x63
0D918:  CLRF   x62
0D91A:  CLRF   x65
0D91C:  CLRF   x64
0D91E:  CLRF   x67
0D920:  CLRF   x66
0D922:  CLRF   x69
0D924:  CLRF   x68
0D926:  CLRF   x6D
0D928:  CLRF   x6C
0D92A:  CLRF   x6B
0D92C:  CLRF   x6A
0D92E:  CLRF   x6E
0D930:  MOVLW  13
0D932:  MOVWF  x6F
0D934:  CLRF   x71
0D936:  CLRF   x70
0D938:  MOVLW  01
0D93A:  MOVWF  x73
0D93C:  MOVLW  66
0D93E:  MOVWF  x72
0D940:  MOVF   FC1,W
0D942:  ANDLW  C0
0D944:  IORLW  0F
0D946:  MOVWF  FC1
0D948:  MOVLW  07
0D94A:  MOVWF  FB4
0D94C:  BRA    D95C
0D94E:  DATA 02,00
0D950:  DATA 16,00
0D952:  DATA 00,FC
0D954:  DATA 40,2F
0D956:  DATA 00,D2
0D958:  DATA 41,2D
0D95A:  DATA 00,00
0D95C:  MOVLW  00
0D95E:  MOVWF  FF8
0D960:  MOVLW  D9
0D962:  MOVWF  FF7
0D964:  MOVLW  4E
0D966:  MOVWF  FF6
0D968:  TBLRD*+
0D96A:  MOVF   FF5,W
0D96C:  MOVWF  00
0D96E:  XORLW  00
0D970:  BZ    D998
0D972:  TBLRD*+
0D974:  MOVF   FF5,W
0D976:  MOVWF  01
0D978:  BTFSC  FE8.7
0D97A:  BRA    D986
0D97C:  ANDLW  0F
0D97E:  MOVWF  FEA
0D980:  TBLRD*+
0D982:  MOVFF  FF5,FE9
0D986:  BTFSC  01.6
0D988:  TBLRD*+
0D98A:  BTFSS  01.6
0D98C:  TBLRD*+
0D98E:  MOVFF  FF5,FEE
0D992:  DCFSNZ 00,F
0D994:  BRA    D968
0D996:  BRA    D98A
0D998:  CLRF   FF8
....................     // <editor-fold defaultstate="collapsed" desc="Inicializao saidas e entradas"> 
....................     setup_adc(ADC_OFF); 
0D99A:  BCF    FC2.0
....................     setup_ccp1(CCP_OFF); 
0D99C:  MOVLW  F0
0D99E:  ANDWF  FBD,F
....................     setup_ccp2(CCP_OFF); 
0D9A0:  ANDWF  FBA,F
....................     enable_interrupts(GLOBAL); 
0D9A2:  MOVLW  C0
0D9A4:  IORWF  FF2,F
....................     setup_psp(PSP_DISABLED); 
0D9A6:  BCF    F96.4
....................     output_low(step_y); 
0D9A8:  BCF    F94.2
0D9AA:  BCF    F8B.2
....................     output_low(dir_y); 
0D9AC:  BCF    F94.1
0D9AE:  BCF    F8B.1
....................     output_high(enable_y); 
0D9B0:  BCF    F94.0
0D9B2:  BSF    F8B.0
....................     output_low(step_x); 
0D9B4:  BCF    F95.2
0D9B6:  BCF    F8C.2
....................     output_low(dir_x); 
0D9B8:  BCF    F95.1
0D9BA:  BCF    F8C.1
....................     output_high(enable_x); 
0D9BC:  BCF    F95.0
0D9BE:  BSF    F8C.0
....................     output_low(step_z); 
0D9C0:  BCF    F92.5
0D9C2:  BCF    F89.5
....................     output_low(dir_z); 
0D9C4:  BCF    F92.4
0D9C6:  BCF    F89.4
....................     output_high(enable_z); 
0D9C8:  BCF    F92.3
0D9CA:  BSF    F89.3
....................     output_low(step_flip); 
0D9CC:  BCF    F96.2
0D9CE:  BCF    F8D.2
....................     output_low(dir_flip); 
0D9D0:  BCF    F96.1
0D9D2:  BCF    F8D.1
....................     output_high(enable_flip); 
0D9D4:  BCF    F96.0
0D9D6:  BSF    F8D.0
....................     setup_timer_2(T2_DIV_BY_16, 255, 16); 
0D9D8:  MOVLW  78
0D9DA:  IORLW  06
0D9DC:  MOVWF  FCA
0D9DE:  MOVLW  FF
0D9E0:  MOVWF  FCB
....................     enable_interrupts(INT_TIMER2); 
0D9E2:  BSF    F9D.1
....................     inicializa_display(); 
0D9E4:  MOVLB  0
0D9E6:  GOTO   29C6
....................     Init_Keyboard(); 
0D9EA:  GOTO   2A80
....................     Init_Sensores_porta1(); 
0D9EE:  GOTO   2AAC
....................     Init_saidas(); 
0D9F2:  GOTO   2AC2
....................     desaciona_todas_saidas(); 
0D9F6:  GOTO   2AD8
....................     init_ext_eeprom(); 
0D9FA:  GOTO   2C8A
....................     // </editor-fold> 
....................     tela_apresentacao(); 
0D9FE:  GOTO   2DA6
....................     home_solenoides(); 
0DA02:  CALL   2E6A
....................     tela_iniciando_maquina(); 
0DA06:  GOTO   2F02
....................     init_axis_x(); 
0DA0A:  GOTO   34FC
....................     init_axis_y(); 
0DA0E:  GOTO   39D6
....................     init_axis_z(); 
0DA12:  GOTO   3ED6
....................     init_axis_flip(); 
0DA16:  GOTO   4316
....................     posicao_maquina_1_default(); 
0DA1A:  GOTO   57DC
....................     tela_principal();     
0DA1E:  CALL   59D6
....................     while(run_ok){ 
0DA22:  BTFSS  2D.0
0DA24:  BRA    DB3C
....................         if (ciclo % 15 == 0){ 
0DA26:  BSF    FD8.1
0DA28:  MOVLW  05
0DA2A:  MOVWF  FEA
0DA2C:  MOVLW  74
0DA2E:  MOVWF  FE9
0DA30:  MOVFF  2C,57B
0DA34:  MOVFF  2B,57A
0DA38:  MOVFF  2A,579
0DA3C:  MOVFF  29,578
0DA40:  MOVLB  5
0DA42:  CLRF   x7F
0DA44:  CLRF   x7E
0DA46:  CLRF   x7D
0DA48:  MOVLW  0F
0DA4A:  MOVWF  x7C
0DA4C:  MOVLB  0
0DA4E:  GOTO   5A3A
0DA52:  MOVFF  577,57B
0DA56:  MOVFF  576,57A
0DA5A:  MOVFF  575,579
0DA5E:  MOVFF  574,578
0DA62:  MOVLB  5
0DA64:  MOVF   x78,F
0DA66:  BTFSS  FD8.2
0DA68:  BRA    DB38
0DA6A:  MOVF   x79,F
0DA6C:  BTFSS  FD8.2
0DA6E:  BRA    DB38
0DA70:  MOVF   x7A,F
0DA72:  BNZ   DB38
0DA74:  MOVF   x7B,F
0DA76:  BNZ   DB38
....................             switch(menu_atual){ 
0DA78:  MOVF   1C,W
0DA7A:  ADDLW  EA
0DA7C:  BC    DB38
0DA7E:  ADDLW  16
0DA80:  MOVLB  0
0DA82:  GOTO   DB3E
....................                 case menu_principal: 
....................                     atualiza_tela_principal(); 
0DA86:  GOTO   62F2
....................                 break;  
0DA8A:  MOVLB  5
0DA8C:  BRA    DB38
....................                 case menu_seleciona_maquina: 
....................                     atualiza_tela_seleciona_maquina(); 
0DA8E:  GOTO   6FDE
....................                 break; 
0DA92:  MOVLB  5
0DA94:  BRA    DB38
....................                 case menu_manutencao_outra_maquina: 
....................                     atualiza_tela_manutencao_outra_maquina(); 
0DA96:  GOTO   7058
....................                 break; 
0DA9A:  MOVLB  5
0DA9C:  BRA    DB38
....................                 case menu_confirmaManutencao: 
....................                     atualiza_tela_confirmaManutencao(); 
0DA9E:  GOTO   706E
....................                 break; 
0DAA2:  MOVLB  5
0DAA4:  BRA    DB38
....................                 case menu_edita_modelo: 
....................                     atualiza_tela_edita_modelo(); 
0DAA6:  GOTO   7124
....................                 break; 
0DAAA:  MOVLB  5
0DAAC:  BRA    DB38
....................                 case menu_seleciona_debug: 
....................                     atualiza_tela_seleciona_debug(); 
0DAAE:  GOTO   71E2
....................                 break;                 
0DAB2:  MOVLB  5
0DAB4:  BRA    DB38
....................                 case menu_edita_pontos_no_modelo: 
....................                     atualiza_tela_edita_pontos_no_modelo(); 
0DAB6:  GOTO   7370
....................                 break;                 
0DABA:  MOVLB  5
0DABC:  BRA    DB38
....................                 case menu_seleciona_pontos: 
....................                     atualiza_tela_seleciona_pontos(); 
0DABE:  GOTO   77A6
....................                 break; 
0DAC2:  MOVLB  5
0DAC4:  BRA    DB38
....................                 case menu_dados_ponto: 
....................                     atualiza_tela_dados_ponto(); 
0DAC6:  GOTO   95CE
....................                 break; 
0DACA:  MOVLB  5
0DACC:  BRA    DB38
....................                 case menu_dados_ponto_2: 
....................                     atualiza_tela_dados_ponto_2(); 
0DACE:  GOTO   A14A
....................                 break; 
0DAD2:  MOVLB  5
0DAD4:  BRA    DB38
....................                 case menu_excluir_modelo: 
....................                     atualiza_tela_excluir_modelo(); 
0DAD6:  GOTO   B1FE
....................                 break;                 
0DADA:  MOVLB  5
0DADC:  BRA    DB38
....................                 case menu_faltaSolda: 
....................                     atualiza_tela_faltaSolda(); 
0DADE:  GOTO   B2D8
....................                 break; 
0DAE2:  MOVLB  5
0DAE4:  BRA    DB38
....................                 case menu_seleciona_debug_2: 
....................                     atualiza_tela_seleciona_debug_2(); 
0DAE6:  GOTO   B466
....................                 break; 
0DAEA:  MOVLB  5
0DAEC:  BRA    DB38
....................                 case menu_seleciona_manutencao: 
....................                     atualiza_tela_seleciona_manutencao(); 
0DAEE:  GOTO   B808
....................                 break;                 
0DAF2:  MOVLB  5
0DAF4:  BRA    DB38
....................                 case menu_debug_entrada_1: 
....................                     atualiza_tela_debug_entrada_1(); 
0DAF6:  GOTO   BA26
....................                 break; 
0DAFA:  MOVLB  5
0DAFC:  BRA    DB38
....................                 case menu_debug_entrada_2: 
....................                     atualiza_tela_debug_entrada_2(); 
0DAFE:  GOTO   BCC4
....................                 break; 
0DB02:  MOVLB  5
0DB04:  BRA    DB38
....................                 case menu_debug_entrada_3: 
....................                     atualiza_tela_debug_entrada_3(); 
0DB06:  GOTO   BD4E
....................                 break; 
0DB0A:  MOVLB  5
0DB0C:  BRA    DB38
....................                 case menu_debug_saida_1: 
....................                     atualiza_tela_debug_saida_1(); 
0DB0E:  GOTO   BF14
....................                 break; 
0DB12:  MOVLB  5
0DB14:  BRA    DB38
....................                 case menu_debug_saida_2: 
....................                     atualiza_tela_debug_saida_2(); 
0DB16:  GOTO   C0D0
....................                 break; 
0DB1A:  MOVLB  5
0DB1C:  BRA    DB38
....................                 case menu_debug_saida_3: 
....................                     atualiza_tela_debug_saida_3(); 
0DB1E:  GOTO   C340
....................                 break; 
0DB22:  MOVLB  5
0DB24:  BRA    DB38
....................                 case menu_debug_saida_4: 
....................                     atualiza_tela_debug_saida_4(); 
0DB26:  GOTO   C4D4
....................                 break; 
0DB2A:  MOVLB  5
0DB2C:  BRA    DB38
....................                 case menu_programa_principal: 
....................                     programa_principal_teste(); 
0DB2E:  GOTO   D194
....................                 break; 
0DB32:  MOVLB  5
0DB34:  BRA    DB38
0DB36:  MOVLB  5
....................             } 
....................         } 
0DB38:  MOVLB  0
0DB3A:  BRA    DA22
....................     }    
.................... } 
0DB3C:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C000   PROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
