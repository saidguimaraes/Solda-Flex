CCS PCH C Compiler, Version 5.007, 61971               15-jan-19 16:43

               Filename:   C:\Users\ICTS-0101\Desktop\software solda\Maquina 1\SoldaFlex_Maquina 1.X\build\default\debug\_ext\1472\main.lst

               ROM used:   43574 bytes (67%)
                           Largest free fragment is 21126
               RAM used:   949 (24%) at main() level
                           995 (25%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 30

*
0000:  GOTO   A660
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   14B8
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   1A7C
0060:  BTFSS  F9D.1
0062:  GOTO   006C
0066:  BTFSC  F9E.1
0068:  GOTO   1A84
006C:  BTFSS  FA0.1
006E:  GOTO   0078
0072:  BTFSC  FA1.1
0074:  GOTO   200A
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include <18F4620.h> 
.................... //////// Standard Header file for the PIC18F4620 device //////////////// 
.................... #device PIC18F4620 
00BA:  DATA 65,72
00BC:  DATA 72,6F
00BE:  DATA 20,64
00C0:  DATA 65,20
00C2:  DATA 65,73
00C4:  DATA 63,72
00C6:  DATA 69,74
00C8:  DATA 61,20
00CA:  DATA 00,00
00CC:  DATA 20,20
00CE:  DATA 20,45
00D0:  DATA 45,50
00D2:  DATA 52,4F
00D4:  DATA 4D,20
00D6:  DATA 20,20
00D8:  DATA 20,20
00DA:  DATA 20,20
00DC:  DATA 00,00
00DE:  DATA 65,72
00E0:  DATA 72,6F
00E2:  DATA 20,64
00E4:  DATA 65,20
00E6:  DATA 6C,65
00E8:  DATA 69,74
00EA:  DATA 75,72
00EC:  DATA 61,20
00EE:  DATA 20,00
00F0:  DATA 20,20
00F2:  DATA 20,20
00F4:  DATA 20,45
00F6:  DATA 45,50
00F8:  DATA 52,4F
00FA:  DATA 4D,20
00FC:  DATA 20,20
00FE:  DATA 20,20
0100:  DATA 20,00
0102:  DATA 20,20
0104:  DATA 20,20
0106:  DATA 20,20
0108:  DATA 20,20
010A:  DATA 49,43
010C:  DATA 54,53
010E:  DATA 20,20
0110:  DATA 20,20
0112:  DATA 20,20
0114:  DATA 20,20
0116:  DATA 0A,0D
0118:  DATA 00,00
011A:  DATA 20,20
011C:  DATA 49,4E
011E:  DATA 53,54
0120:  DATA 49,54
0122:  DATA 55,54
0124:  DATA 4F,20
0126:  DATA 43,45
0128:  DATA 4E,54
012A:  DATA 52,4F
012C:  DATA 20,20
012E:  DATA 0A,0D
0130:  DATA 00,00
0132:  DATA 20,20
0134:  DATA 20,20
0136:  DATA 54,45
0138:  DATA 43,4E
013A:  DATA 4F,4C
013C:  DATA 4F,47
013E:  DATA 49,41
0140:  DATA 20,45
0142:  DATA 4D,20
0144:  DATA 20,20
0146:  DATA 0A,0D
0148:  DATA 00,00
014A:  DATA 20,20
014C:  DATA 20,20
014E:  DATA 20,20
0150:  DATA 53,4F
0152:  DATA 46,54
0154:  DATA 57,41
0156:  DATA 52,45
0158:  DATA 20,20
015A:  DATA 20,20
015C:  DATA 20,20
015E:  DATA 0A,0D
0160:  DATA 00,00
0162:  DATA 20,20
0164:  DATA 20,20
0166:  DATA 20,49
0168:  DATA 4E,49
016A:  DATA 43,49
016C:  DATA 41,4E
016E:  DATA 44,4F
0170:  DATA 20,20
0172:  DATA 20,20
0174:  DATA 20,0A
0176:  DATA 0D,00
0178:  DATA 20,20
017A:  DATA 20,20
017C:  DATA 20,20
017E:  DATA 4D,41
0180:  DATA 51,55
0182:  DATA 49,4E
0184:  DATA 41,20
0186:  DATA 20,20
0188:  DATA 20,20
018A:  DATA 0A,0D
018C:  DATA 00,00
018E:  DATA 4D,4F
0190:  DATA 56,49
0192:  DATA 4D,45
0194:  DATA 4E,54
0196:  DATA 41,4E
0198:  DATA 44,4F
019A:  DATA 20,4D
019C:  DATA 41,51
019E:  DATA 55,49
01A0:  DATA 4E,41
01A2:  DATA 0A,0D
01A4:  DATA 00,00
01A6:  DATA 20,20
01A8:  DATA 20,20
01AA:  DATA 50,41
01AC:  DATA 52,41
01AE:  DATA 20,50
01B0:  DATA 4F,53
01B2:  DATA 49,43
01B4:  DATA 41,4F
01B6:  DATA 20,20
01B8:  DATA 20,20
01BA:  DATA 0A,0D
01BC:  DATA 00,00
01BE:  DATA 20,20
01C0:  DATA 20,20
01C2:  DATA 20,41
01C4:  DATA 4C,49
01C6:  DATA 4D,45
01C8:  DATA 4E,54
01CA:  DATA 41,44
01CC:  DATA 4F,52
01CE:  DATA 20,20
01D0:  DATA 20,20
01D2:  DATA 0A,0D
01D4:  DATA 00,00
01D6:  DATA 4D,4F
01D8:  DATA 56,49
01DA:  DATA 4D,45
01DC:  DATA 4E,54
01DE:  DATA 41,4E
01E0:  DATA 44,4F
01E2:  DATA 20,4D
01E4:  DATA 41,51
01E6:  DATA 55,49
01E8:  DATA 4E,41
01EA:  DATA 0A,0D
01EC:  DATA 00,00
01EE:  DATA 20,20
01F0:  DATA 20,20
01F2:  DATA 50,41
01F4:  DATA 52,41
01F6:  DATA 20,50
01F8:  DATA 4F,53
01FA:  DATA 49,43
01FC:  DATA 41,4F
01FE:  DATA 20,20
0200:  DATA 20,20
0202:  DATA 0A,0D
0204:  DATA 00,00
0206:  DATA 20,20
0208:  DATA 20,20
020A:  DATA 20,20
020C:  DATA 20,48
020E:  DATA 4F,4D
0210:  DATA 45,20
0212:  DATA 31,20
0214:  DATA 20,20
0216:  DATA 20,20
0218:  DATA 20,20
021A:  DATA 0A,0D
021C:  DATA 00,00
021E:  DATA 4D,4F
0220:  DATA 56,49
0222:  DATA 4D,45
0224:  DATA 4E,54
0226:  DATA 41,4E
0228:  DATA 44,4F
022A:  DATA 20,4D
022C:  DATA 41,51
022E:  DATA 55,49
0230:  DATA 4E,41
0232:  DATA 0A,0D
0234:  DATA 00,00
0236:  DATA 20,20
0238:  DATA 20,20
023A:  DATA 50,41
023C:  DATA 52,41
023E:  DATA 20,50
0240:  DATA 4F,53
0242:  DATA 49,43
0244:  DATA 41,4F
0246:  DATA 20,20
0248:  DATA 20,20
024A:  DATA 0A,0D
024C:  DATA 00,00
024E:  DATA 20,20
0250:  DATA 20,20
0252:  DATA 20,20
0254:  DATA 53,4F
0256:  DATA 4C,44
0258:  DATA 41,47
025A:  DATA 45,4D
025C:  DATA 20,20
025E:  DATA 20,20
0260:  DATA 20,0A
0262:  DATA 0D,00
0264:  DATA 4D,4F
0266:  DATA 56,49
0268:  DATA 4D,45
026A:  DATA 4E,54
026C:  DATA 41,4E
026E:  DATA 44,4F
0270:  DATA 20,4D
0272:  DATA 41,51
0274:  DATA 55,49
0276:  DATA 4E,41
0278:  DATA 0A,0D
027A:  DATA 00,00
027C:  DATA 20,20
027E:  DATA 20,20
0280:  DATA 50,41
0282:  DATA 52,41
0284:  DATA 20,50
0286:  DATA 4F,53
0288:  DATA 49,43
028A:  DATA 41,4F
028C:  DATA 20,20
028E:  DATA 20,20
0290:  DATA 0A,0D
0292:  DATA 00,00
0294:  DATA 20,20
0296:  DATA 20,20
0298:  DATA 20,20
029A:  DATA 20,48
029C:  DATA 4F,4D
029E:  DATA 45,20
02A0:  DATA 32,20
02A2:  DATA 20,20
02A4:  DATA 20,20
02A6:  DATA 20,20
02A8:  DATA 0A,0D
02AA:  DATA 00,00
02AC:  DATA 4D,4F
02AE:  DATA 56,49
02B0:  DATA 4D,45
02B2:  DATA 4E,54
02B4:  DATA 41,4E
02B6:  DATA 44,4F
02B8:  DATA 20,4D
02BA:  DATA 41,51
02BC:  DATA 55,49
02BE:  DATA 4E,41
02C0:  DATA 0A,0D
02C2:  DATA 00,00
02C4:  DATA 20,20
02C6:  DATA 20,20
02C8:  DATA 50,41
02CA:  DATA 52,41
02CC:  DATA 20,50
02CE:  DATA 4F,53
02D0:  DATA 49,43
02D2:  DATA 41,4F
02D4:  DATA 20,20
02D6:  DATA 20,20
02D8:  DATA 0A,0D
02DA:  DATA 00,00
02DC:  DATA 20,20
02DE:  DATA 20,20
02E0:  DATA 44,49
02E2:  DATA 53,50
02E4:  DATA 45,4E
02E6:  DATA 53,41
02E8:  DATA 44,4F
02EA:  DATA 52,20
02EC:  DATA 20,20
02EE:  DATA 20,20
02F0:  DATA 0A,0D
02F2:  DATA 00,00
02F4:  DATA 4D,4F
02F6:  DATA 56,49
02F8:  DATA 4D,45
02FA:  DATA 4E,54
02FC:  DATA 41,4E
02FE:  DATA 44,4F
0300:  DATA 20,4D
0302:  DATA 41,51
0304:  DATA 55,49
0306:  DATA 4E,41
0308:  DATA 0A,0D
030A:  DATA 00,00
030C:  DATA 20,20
030E:  DATA 20,20
0310:  DATA 50,41
0312:  DATA 52,41
0314:  DATA 20,50
0316:  DATA 4F,53
0318:  DATA 49,43
031A:  DATA 41,4F
031C:  DATA 20,20
031E:  DATA 20,20
0320:  DATA 0A,0D
0322:  DATA 00,00
0324:  DATA 20,20
0326:  DATA 20,20
0328:  DATA 20,20
032A:  DATA 20,4C
032C:  DATA 49,4D
032E:  DATA 50,45
0330:  DATA 5A,41
0332:  DATA 20,20
0334:  DATA 20,20
0336:  DATA 20,20
0338:  DATA 0A,0D
033A:  DATA 00,00
033C:  DATA 4D,4F
033E:  DATA 56,49
0340:  DATA 4D,45
0342:  DATA 4E,54
0344:  DATA 41,4E
0346:  DATA 44,4F
0348:  DATA 20,4D
034A:  DATA 41,51
034C:  DATA 55,49
034E:  DATA 4E,41
0350:  DATA 0A,0D
0352:  DATA 00,00
0354:  DATA 20,20
0356:  DATA 20,20
0358:  DATA 50,41
035A:  DATA 52,41
035C:  DATA 20,50
035E:  DATA 4F,53
0360:  DATA 49,43
0362:  DATA 41,4F
0364:  DATA 20,20
0366:  DATA 20,20
0368:  DATA 0A,0D
036A:  DATA 00,00
036C:  DATA 20,20
036E:  DATA 20,20
0370:  DATA 20,4C
0372:  DATA 49,4D
0374:  DATA 50,45
0376:  DATA 5A,41
0378:  DATA 5F,32
037A:  DATA 20,20
037C:  DATA 20,20
037E:  DATA 20,20
0380:  DATA 0A,0D
0382:  DATA 00,00
0384:  DATA 20,20
0386:  DATA 45,53
0388:  DATA 50,45
038A:  DATA 52,41
038C:  DATA 4E,44
038E:  DATA 4F,20
0390:  DATA 4D,41
0392:  DATA 51,55
0394:  DATA 49,4E
0396:  DATA 41,20
0398:  DATA 0A,0D
039A:  DATA 00,00
039C:  DATA 20,20
039E:  DATA 20,49
03A0:  DATA 52,20
03A2:  DATA 50,41
03A4:  DATA 52,41
03A6:  DATA 20,50
03A8:  DATA 4F,53
03AA:  DATA 49,43
03AC:  DATA 41,4F
03AE:  DATA 20,20
03B0:  DATA 0A,0D
03B2:  DATA 00,00
03B4:  DATA 20,20
03B6:  DATA 20,20
03B8:  DATA 50,52
03BA:  DATA 45,2D
03BC:  DATA 52,45
03BE:  DATA 51,55
03C0:  DATA 49,53
03C2:  DATA 49,54
03C4:  DATA 4F,20
03C6:  DATA 20,20
03C8:  DATA 0A,0D
03CA:  DATA 00,00
03CC:  DATA 20,20
03CE:  DATA 20,45
03D0:  DATA 53,50
03D2:  DATA 45,52
03D4:  DATA 41,4E
03D6:  DATA 44,4F
03D8:  DATA 20,4F
03DA:  DATA 55,54
03DC:  DATA 52,41
03DE:  DATA 20,20
03E0:  DATA 0A,0D
03E2:  DATA 00,00
03E4:  DATA 20,20
03E6:  DATA 20,20
03E8:  DATA 20,20
03EA:  DATA 20,4D
03EC:  DATA 41,51
03EE:  DATA 55,49
03F0:  DATA 4E,41
03F2:  DATA 20,20
03F4:  DATA 20,20
03F6:  DATA 20,20
03F8:  DATA 0A,0D
03FA:  DATA 00,00
03FC:  DATA 20,20
03FE:  DATA 20,49
0400:  DATA 52,20
0402:  DATA 50,41
0404:  DATA 52,41
0406:  DATA 20,50
0408:  DATA 4F,53
040A:  DATA 49,43
040C:  DATA 41,4F
040E:  DATA 20,20
0410:  DATA 0A,0D
0412:  DATA 00,00
0414:  DATA 20,20
0416:  DATA 20,20
0418:  DATA 20,41
041A:  DATA 4C,49
041C:  DATA 4D,45
041E:  DATA 4E,54
0420:  DATA 41,44
0422:  DATA 4F,52
0424:  DATA 20,20
0426:  DATA 20,20
0428:  DATA 0A,0D
042A:  DATA 00,00
042C:  DATA 20,20
042E:  DATA 20,45
0430:  DATA 53,50
0432:  DATA 45,52
0434:  DATA 41,4E
0436:  DATA 44,4F
0438:  DATA 20,4F
043A:  DATA 55,54
043C:  DATA 52,41
043E:  DATA 20,20
0440:  DATA 0A,0D
0442:  DATA 00,00
0444:  DATA 20,20
0446:  DATA 20,20
0448:  DATA 20,20
044A:  DATA 20,4D
044C:  DATA 41,51
044E:  DATA 55,49
0450:  DATA 4E,41
0452:  DATA 20,20
0454:  DATA 20,20
0456:  DATA 20,20
0458:  DATA 0A,0D
045A:  DATA 00,00
045C:  DATA 20,20
045E:  DATA 20,49
0460:  DATA 52,20
0462:  DATA 50,41
0464:  DATA 52,41
0466:  DATA 20,50
0468:  DATA 4F,53
046A:  DATA 49,43
046C:  DATA 41,4F
046E:  DATA 20,20
0470:  DATA 0A,0D
0472:  DATA 00,00
0474:  DATA 20,20
0476:  DATA 20,20
0478:  DATA 20,20
047A:  DATA 20,48
047C:  DATA 4F,4D
047E:  DATA 45,20
0480:  DATA 31,20
0482:  DATA 20,20
0484:  DATA 20,20
0486:  DATA 20,20
0488:  DATA 0A,0D
048A:  DATA 00,00
048C:  DATA 20,20
048E:  DATA 20,45
0490:  DATA 53,50
0492:  DATA 45,52
0494:  DATA 41,4E
0496:  DATA 44,4F
0498:  DATA 20,4F
049A:  DATA 55,54
049C:  DATA 52,41
049E:  DATA 20,20
04A0:  DATA 0A,0D
04A2:  DATA 00,00
04A4:  DATA 20,20
04A6:  DATA 20,20
04A8:  DATA 20,20
04AA:  DATA 20,4D
04AC:  DATA 41,51
04AE:  DATA 55,49
04B0:  DATA 4E,41
04B2:  DATA 20,20
04B4:  DATA 20,20
04B6:  DATA 20,20
04B8:  DATA 0A,0D
04BA:  DATA 00,00
04BC:  DATA 20,20
04BE:  DATA 20,49
04C0:  DATA 52,20
04C2:  DATA 50,41
04C4:  DATA 52,41
04C6:  DATA 20,50
04C8:  DATA 4F,53
04CA:  DATA 49,43
04CC:  DATA 41,4F
04CE:  DATA 20,20
04D0:  DATA 0A,0D
04D2:  DATA 00,00
04D4:  DATA 20,20
04D6:  DATA 20,20
04D8:  DATA 20,53
04DA:  DATA 4F,4C
04DC:  DATA 44,41
04DE:  DATA 47,45
04E0:  DATA 4D,20
04E2:  DATA 31,20
04E4:  DATA 20,20
04E6:  DATA 20,20
04E8:  DATA 0A,0D
04EA:  DATA 00,00
04EC:  DATA 20,20
04EE:  DATA 20,45
04F0:  DATA 53,50
04F2:  DATA 45,52
04F4:  DATA 41,4E
04F6:  DATA 44,4F
04F8:  DATA 20,4F
04FA:  DATA 55,54
04FC:  DATA 52,41
04FE:  DATA 20,20
0500:  DATA 0A,0D
0502:  DATA 00,00
0504:  DATA 20,20
0506:  DATA 20,20
0508:  DATA 20,20
050A:  DATA 20,4D
050C:  DATA 41,51
050E:  DATA 55,49
0510:  DATA 4E,41
0512:  DATA 20,20
0514:  DATA 20,20
0516:  DATA 20,20
0518:  DATA 0A,0D
051A:  DATA 00,00
051C:  DATA 20,20
051E:  DATA 20,49
0520:  DATA 52,20
0522:  DATA 50,41
0524:  DATA 52,41
0526:  DATA 20,50
0528:  DATA 4F,53
052A:  DATA 49,43
052C:  DATA 41,4F
052E:  DATA 20,20
0530:  DATA 0A,0D
0532:  DATA 00,00
0534:  DATA 20,20
0536:  DATA 20,20
0538:  DATA 20,20
053A:  DATA 20,48
053C:  DATA 4F,4D
053E:  DATA 45,20
0540:  DATA 32,20
0542:  DATA 20,20
0544:  DATA 20,20
0546:  DATA 20,20
0548:  DATA 0A,0D
054A:  DATA 00,00
054C:  DATA 20,20
054E:  DATA 20,45
0550:  DATA 53,50
0552:  DATA 45,52
0554:  DATA 41,4E
0556:  DATA 44,4F
0558:  DATA 20,4F
055A:  DATA 55,54
055C:  DATA 52,41
055E:  DATA 20,20
0560:  DATA 0A,0D
0562:  DATA 00,00
0564:  DATA 20,20
0566:  DATA 20,20
0568:  DATA 20,20
056A:  DATA 20,4D
056C:  DATA 41,51
056E:  DATA 55,49
0570:  DATA 4E,41
0572:  DATA 20,20
0574:  DATA 20,20
0576:  DATA 20,20
0578:  DATA 0A,0D
057A:  DATA 00,00
057C:  DATA 20,20
057E:  DATA 20,49
0580:  DATA 52,20
0582:  DATA 50,41
0584:  DATA 52,41
0586:  DATA 20,50
0588:  DATA 4F,53
058A:  DATA 49,43
058C:  DATA 41,4F
058E:  DATA 20,20
0590:  DATA 0A,0D
0592:  DATA 00,00
0594:  DATA 20,20
0596:  DATA 20,20
0598:  DATA 20,44
059A:  DATA 49,53
059C:  DATA 50,45
059E:  DATA 4E,53
05A0:  DATA 41,44
05A2:  DATA 4F,52
05A4:  DATA 20,20
05A6:  DATA 20,20
05A8:  DATA 0A,0D
05AA:  DATA 00,00
05AC:  DATA 20,20
05AE:  DATA 20,45
05B0:  DATA 53,50
05B2:  DATA 45,52
05B4:  DATA 41,4E
05B6:  DATA 44,4F
05B8:  DATA 20,4F
05BA:  DATA 55,54
05BC:  DATA 52,41
05BE:  DATA 20,20
05C0:  DATA 0A,0D
05C2:  DATA 00,00
05C4:  DATA 20,20
05C6:  DATA 20,20
05C8:  DATA 20,20
05CA:  DATA 20,4D
05CC:  DATA 41,51
05CE:  DATA 55,49
05D0:  DATA 4E,41
05D2:  DATA 20,20
05D4:  DATA 20,20
05D6:  DATA 20,20
05D8:  DATA 0A,0D
05DA:  DATA 00,00
05DC:  DATA 20,20
05DE:  DATA 20,49
05E0:  DATA 52,20
05E2:  DATA 50,41
05E4:  DATA 52,41
05E6:  DATA 20,50
05E8:  DATA 4F,53
05EA:  DATA 49,43
05EC:  DATA 41,4F
05EE:  DATA 20,20
05F0:  DATA 0A,0D
05F2:  DATA 00,00
05F4:  DATA 20,20
05F6:  DATA 20,20
05F8:  DATA 20,20
05FA:  DATA 20,4C
05FC:  DATA 49,4D
05FE:  DATA 50,45
0600:  DATA 5A,41
0602:  DATA 20,20
0604:  DATA 20,20
0606:  DATA 20,20
0608:  DATA 0A,0D
060A:  DATA 00,00
060C:  DATA 20,20
060E:  DATA 20,45
0610:  DATA 53,50
0612:  DATA 45,52
0614:  DATA 41,4E
0616:  DATA 44,4F
0618:  DATA 20,4F
061A:  DATA 55,54
061C:  DATA 52,41
061E:  DATA 20,20
0620:  DATA 0A,0D
0622:  DATA 00,00
0624:  DATA 20,20
0626:  DATA 20,20
0628:  DATA 20,20
062A:  DATA 20,4D
062C:  DATA 41,51
062E:  DATA 55,49
0630:  DATA 4E,41
0632:  DATA 20,20
0634:  DATA 20,20
0636:  DATA 20,20
0638:  DATA 0A,0D
063A:  DATA 00,00
063C:  DATA 20,20
063E:  DATA 20,49
0640:  DATA 52,20
0642:  DATA 50,41
0644:  DATA 52,41
0646:  DATA 20,50
0648:  DATA 4F,53
064A:  DATA 49,43
064C:  DATA 41,4F
064E:  DATA 20,20
0650:  DATA 0A,0D
0652:  DATA 00,00
0654:  DATA 20,20
0656:  DATA 20,20
0658:  DATA 20,20
065A:  DATA 4C,49
065C:  DATA 4D,50
065E:  DATA 45,5A
0660:  DATA 41,5F
0662:  DATA 32,20
0664:  DATA 20,20
0666:  DATA 20,20
0668:  DATA 0A,0D
066A:  DATA 00,00
066C:  DATA 20,20
066E:  DATA 20,45
0670:  DATA 53,50
0672:  DATA 45,52
0674:  DATA 41,4E
0676:  DATA 44,4F
0678:  DATA 20,4F
067A:  DATA 55,54
067C:  DATA 52,41
067E:  DATA 20,20
0680:  DATA 0A,0D
0682:  DATA 00,00
0684:  DATA 20,20
0686:  DATA 20,20
0688:  DATA 20,20
068A:  DATA 20,4D
068C:  DATA 41,51
068E:  DATA 55,49
0690:  DATA 4E,41
0692:  DATA 20,20
0694:  DATA 20,20
0696:  DATA 20,20
0698:  DATA 0A,0D
069A:  DATA 00,00
069C:  DATA 20,20
069E:  DATA 20,53
06A0:  DATA 41,49
06A2:  DATA 52,20
06A4:  DATA 44,41
06A6:  DATA 20,50
06A8:  DATA 4F,53
06AA:  DATA 49,43
06AC:  DATA 41,4F
06AE:  DATA 20,20
06B0:  DATA 0A,0D
06B2:  DATA 00,00
06B4:  DATA 20,20
06B6:  DATA 20,20
06B8:  DATA 20,20
06BA:  DATA 20,20
06BC:  DATA 41,54
06BE:  DATA 55,41
06C0:  DATA 4C,20
06C2:  DATA 20,20
06C4:  DATA 20,20
06C6:  DATA 20,20
06C8:  DATA 0A,0D
06CA:  DATA 00,00
06CC:  DATA 20,53
06CE:  DATA 4F,4C
06D0:  DATA 44,41
06D2:  DATA 44,4F
06D4:  DATA 52,20
06D6:  DATA 41,55
06D8:  DATA 54,4F
06DA:  DATA 4D,41
06DC:  DATA 54,49
06DE:  DATA 43,4F
06E0:  DATA 0A,0D
06E2:  DATA 00,00
06E4:  DATA 20,20
06E6:  DATA 20,20
06E8:  DATA 20,20
06EA:  DATA 4D,4F
06EC:  DATA 44,45
06EE:  DATA 4C,4F
06F0:  DATA 3A,25
06F2:  DATA 30,32
06F4:  DATA 75,20
06F6:  DATA 20,20
06F8:  DATA 0A,0D
06FA:  DATA 00,00
06FC:  DATA 5E,2F
06FE:  DATA 3F,3A
0700:  DATA 4D,4F
0702:  DATA 44,45
0704:  DATA 4C,4F
0706:  DATA 7C,4D
0708:  DATA 45,4E
070A:  DATA 55,3A
070C:  DATA 44,42
070E:  DATA 55,47
0710:  DATA 0A,0D
0712:  DATA 00,00
0714:  DATA 20,20
0716:  DATA 20,20
0718:  DATA 20,45
071A:  DATA 4E,54
071C:  DATA 45,52
071E:  DATA 3A,4D
0720:  DATA 41,49
0722:  DATA 4E,20
0724:  DATA 20,20
0726:  DATA 20,20
0728:  DATA 0A,0D
072A:  DATA 00,00
072C:  DATA 20,53
072E:  DATA 45,4C
0730:  DATA 45,43
0732:  DATA 49,4F
0734:  DATA 4E,45
0736:  DATA 20,41
0738:  DATA 20,4D
073A:  DATA 41,51
073C:  DATA 55,49
073E:  DATA 4E,41
0740:  DATA 0A,0D
0742:  DATA 00,00
0744:  DATA 20,20
0746:  DATA 20,20
0748:  DATA 46,31
074A:  DATA 3A,20
074C:  DATA 4D,41
074E:  DATA 51,55
0750:  DATA 49,4E
0752:  DATA 41,20
0754:  DATA 31,20
0756:  DATA 20,20
0758:  DATA 0A,0D
075A:  DATA 00,00
075C:  DATA 20,20
075E:  DATA 20,20
0760:  DATA 46,32
0762:  DATA 3A,20
0764:  DATA 4D,41
0766:  DATA 51,55
0768:  DATA 49,4E
076A:  DATA 41,20
076C:  DATA 32,20
076E:  DATA 20,20
0770:  DATA 0A,0D
0772:  DATA 00,00
0774:  DATA 20,20
0776:  DATA 20,20
0778:  DATA 45,53
077A:  DATA 43,3A
077C:  DATA 42,41
077E:  DATA 43,4B
0780:  DATA 20,20
0782:  DATA 20,20
0784:  DATA 20,20
0786:  DATA 20,20
0788:  DATA 0A,0D
078A:  DATA 00,00
078C:  DATA 20,20
078E:  DATA 20,20
0790:  DATA 20,4D
0792:  DATA 41,4E
0794:  DATA 55,54
0796:  DATA 45,4E
0798:  DATA 43,41
079A:  DATA 4F,20
079C:  DATA 20,20
079E:  DATA 20,20
07A0:  DATA 0A,0D
07A2:  DATA 00,00
07A4:  DATA 20,20
07A6:  DATA 20,20
07A8:  DATA 20,20
07AA:  DATA 4D,41
07AC:  DATA 51,55
07AE:  DATA 49,4E
07B0:  DATA 41,20
07B2:  DATA 32,20
07B4:  DATA 20,20
07B6:  DATA 20,20
07B8:  DATA 0A,0D
07BA:  DATA 00,00
07BC:  DATA 20,20
07BE:  DATA 20,20
07C0:  DATA 20,20
07C2:  DATA 20,20
07C4:  DATA 20,20
07C6:  DATA 20,20
07C8:  DATA 20,20
07CA:  DATA 20,20
07CC:  DATA 20,20
07CE:  DATA 20,20
07D0:  DATA 0A,0D
07D2:  DATA 00,00
07D4:  DATA 20,20
07D6:  DATA 20,20
07D8:  DATA 20,20
07DA:  DATA 45,53
07DC:  DATA 43,3A
07DE:  DATA 42,41
07E0:  DATA 43,4B
07E2:  DATA 20,20
07E4:  DATA 20,20
07E6:  DATA 20,20
07E8:  DATA 0A,0D
07EA:  DATA 00,00
07EC:  DATA 20,20
07EE:  DATA 20,20
07F0:  DATA 45,53
07F2:  DATA 43,4F
07F4:  DATA 4C,48
07F6:  DATA 45,52
07F8:  DATA 20,41
07FA:  DATA 43,41
07FC:  DATA 4F,20
07FE:  DATA 20,20
0800:  DATA 0A,0D
0802:  DATA 00,00
0804:  DATA 20,20
0806:  DATA 46,31
0808:  DATA 3A,20
080A:  DATA 45,44
080C:  DATA 49,54
080E:  DATA 41,52
0810:  DATA 20,4D
0812:  DATA 4F,44
0814:  DATA 45,4C
0816:  DATA 4F,20
0818:  DATA 0A,0D
081A:  DATA 00,00
081C:  DATA 20,20
081E:  DATA 46,32
0820:  DATA 3A,20
0822:  DATA 45,58
0824:  DATA 43,4C
0826:  DATA 55,49
0828:  DATA 20,4D
082A:  DATA 4F,44
082C:  DATA 45,4C
082E:  DATA 4F,20
0830:  DATA 0A,0D
0832:  DATA 00,00
0834:  DATA 20,20
0836:  DATA 45,53
0838:  DATA 43,3A
083A:  DATA 42,41
083C:  DATA 43,4B
083E:  DATA 20,20
0840:  DATA 20,20
0842:  DATA 20,20
0844:  DATA 20,20
0846:  DATA 20,20
0848:  DATA 0A,0D
084A:  DATA 00,00
084C:  DATA 20,20
084E:  DATA 46,31
0850:  DATA 3A,20
0852:  DATA 45,44
0854:  DATA 49,54
0856:  DATA 41,52
0858:  DATA 20,50
085A:  DATA 4F,4E
085C:  DATA 54,4F
085E:  DATA 53,20
0860:  DATA 0A,0D
0862:  DATA 00,00
0864:  DATA 20,20
0866:  DATA 46,32
0868:  DATA 3A,20
086A:  DATA 4D,41
086C:  DATA 4E,55
086E:  DATA 54,45
0870:  DATA 4E,43
0872:  DATA 41,4F
0874:  DATA 20,20
0876:  DATA 20,20
0878:  DATA 0A,0D
087A:  DATA 00,00
087C:  DATA 20,20
087E:  DATA 46,33
0880:  DATA 3A,20
0882:  DATA 51,4E
0884:  DATA 54,5F
0886:  DATA 50,4F
0888:  DATA 4E,54
088A:  DATA 4F,53
088C:  DATA 20,20
088E:  DATA 20,20
0890:  DATA 0A,0D
0892:  DATA 00,00
0894:  DATA 20,20
0896:  DATA 45,53
0898:  DATA 43,3A
089A:  DATA 42,41
089C:  DATA 43,4B
089E:  DATA 20,20
08A0:  DATA 20,20
08A2:  DATA 20,20
08A4:  DATA 20,20
08A6:  DATA 20,20
08A8:  DATA 0A,0D
08AA:  DATA 00,00
08AC:  DATA 20,20
08AE:  DATA 50,4F
08B0:  DATA 4E,54
08B2:  DATA 4F,53
08B4:  DATA 20,4E
08B6:  DATA 4F,20
08B8:  DATA 4D,4F
08BA:  DATA 44,45
08BC:  DATA 4C,4F
08BE:  DATA 20,20
08C0:  DATA 0A,0D
08C2:  DATA 00,00
08C4:  DATA 20,20
08C6:  DATA 20,20
08C8:  DATA 20,20
08CA:  DATA 20,20
08CC:  DATA 20,25
08CE:  DATA 30,32
08D0:  DATA 75,20
08D2:  DATA 20,20
08D4:  DATA 20,20
08D6:  DATA 20,20
08D8:  DATA 0A,0D
08DA:  DATA 00,00
08DC:  DATA 20,20
08DE:  DATA 20,20
08E0:  DATA 3F,2F
08E2:  DATA 3F,3A
08E4:  DATA 4E,5F
08E6:  DATA 50,4F
08E8:  DATA 4E,54
08EA:  DATA 4F,53
08EC:  DATA 20,20
08EE:  DATA 20,0A
08F0:  DATA 0D,00
08F2:  DATA 20,45
08F4:  DATA 4E,54
08F6:  DATA 45,52
08F8:  DATA 3A,53
08FA:  DATA 41,56
08FC:  DATA 45,7C
08FE:  DATA 45,53
0900:  DATA 43,3A
0902:  DATA 42,41
0904:  DATA 43,4B
0906:  DATA 0A,0D
0908:  DATA 00,00
090A:  DATA 20,20
090C:  DATA 20,44
090E:  DATA 45,53
0910:  DATA 45,4A
0912:  DATA 41,20
0914:  DATA 45,58
0916:  DATA 43,4C
0918:  DATA 55,49
091A:  DATA 52,20
091C:  DATA 20,20
091E:  DATA 0A,0D
0920:  DATA 00,00
0922:  DATA 20,20
0924:  DATA 20,20
0926:  DATA 20,4F
0928:  DATA 20,4D
092A:  DATA 4F,44
092C:  DATA 45,4C
092E:  DATA 4F,20
0930:  DATA 3F,20
0932:  DATA 20,20
0934:  DATA 20,20
0936:  DATA 0A,0D
0938:  DATA 00,00
093A:  DATA 20,20
093C:  DATA 20,20
093E:  DATA 20,20
0940:  DATA 45,4E
0942:  DATA 54,45
0944:  DATA 52,3D
0946:  DATA 4F,4B
0948:  DATA 20,20
094A:  DATA 20,20
094C:  DATA 20,20
094E:  DATA 0A,0D
0950:  DATA 00,00
0952:  DATA 20,20
0954:  DATA 20,20
0956:  DATA 45,53
0958:  DATA 43,3A
095A:  DATA 4E,4F
095C:  DATA 2F,42
095E:  DATA 41,43
0960:  DATA 4B,20
0962:  DATA 20,20
0964:  DATA 20,20
0966:  DATA 0A,0D
0968:  DATA 00,00
096A:  DATA 50,25
096C:  DATA 30,32
096E:  DATA 75,20
0970:  DATA 20,20
0972:  DATA 20,20
0974:  DATA 20,20
0976:  DATA 20,20
0978:  DATA 45,4E
097A:  DATA 54,3D
097C:  DATA 45,44
097E:  DATA 49,54
0980:  DATA 0A,0D
0982:  DATA 00,00
0984:  DATA 50,25
0986:  DATA 30,32
0988:  DATA 75,20
098A:  DATA 20,20
098C:  DATA 20,20
098E:  DATA 20,20
0990:  DATA 20,20
0992:  DATA 45,53
0994:  DATA 43,3D
0996:  DATA 42,41
0998:  DATA 43,4B
099A:  DATA 0A,0D
099C:  DATA 00,00
099E:  DATA 50,25
09A0:  DATA 30,32
09A2:  DATA 75,20
09A4:  DATA 20,20
09A6:  DATA 20,20
09A8:  DATA 20,20
09AA:  DATA 20,20
09AC:  DATA 20,20
09AE:  DATA 20,20
09B0:  DATA 20,20
09B2:  DATA 20,20
09B4:  DATA 0A,0D
09B6:  DATA 00,00
09B8:  DATA 50,25
09BA:  DATA 30,32
09BC:  DATA 75,20
09BE:  DATA 20,20
09C0:  DATA 20,20
09C2:  DATA 20,20
09C4:  DATA 20,20
09C6:  DATA 20,20
09C8:  DATA 20,20
09CA:  DATA 20,20
09CC:  DATA 20,20
09CE:  DATA 0A,0D
09D0:  DATA 00,00
09D2:  DATA 58,3A
09D4:  DATA 25,30
09D6:  DATA 34,4C
09D8:  DATA 75,20
09DA:  DATA 59,3A
09DC:  DATA 25,30
09DE:  DATA 34,4C
09E0:  DATA 75,20
09E2:  DATA 5A,3A
09E4:  DATA 25,30
09E6:  DATA 34,4C
09E8:  DATA 75,0A
09EA:  DATA 0D,00
09EC:  DATA 20,20
09EE:  DATA 54,5F
09F0:  DATA 53,3A
09F2:  DATA 25,30
09F4:  DATA 34,4C
09F6:  DATA 75,20
09F8:  DATA 54,5F
09FA:  DATA 45,3A
09FC:  DATA 25,30
09FE:  DATA 34,4C
0A00:  DATA 75,20
0A02:  DATA 0A,0D
0A04:  DATA 00,00
0A06:  DATA 20,20
0A08:  DATA 20,54
0A0A:  DATA 49,50
0A0C:  DATA 4F,3A
0A0E:  DATA 25,30
0A10:  DATA 32,75
0A12:  DATA 20,48
0A14:  DATA 41,42
0A16:  DATA 3A,25
0A18:  DATA 30,32
0A1A:  DATA 75,20
0A1C:  DATA 20,20
0A1E:  DATA 0A,0D
0A20:  DATA 00,00
0A22:  DATA 46,31
0A24:  DATA 3A,47
0A26:  DATA 52,41
0A28:  DATA 56,41
0A2A:  DATA 7C,45
0A2C:  DATA 4E,54
0A2E:  DATA 45,52
0A30:  DATA 3A,54
0A32:  DATA 45,53
0A34:  DATA 54,45
0A36:  DATA 0A,0D
0A38:  DATA 00,00
0A3A:  DATA 20,46
0A3C:  DATA 31,3A
0A3E:  DATA 20,44
0A40:  DATA 45,42
0A42:  DATA 55,47
0A44:  DATA 20,45
0A46:  DATA 4E,54
0A48:  DATA 52,41
0A4A:  DATA 44,41
0A4C:  DATA 53,20
0A4E:  DATA 0A,0D
0A50:  DATA 00,00
0A52:  DATA 20,46
0A54:  DATA 32,3A
0A56:  DATA 20,20
0A58:  DATA 44,45
0A5A:  DATA 42,55
0A5C:  DATA 47,20
0A5E:  DATA 53,41
0A60:  DATA 49,44
0A62:  DATA 41,53
0A64:  DATA 20,20
0A66:  DATA 0A,0D
0A68:  DATA 00,00
0A6A:  DATA 20,20
0A6C:  DATA 20,20
0A6E:  DATA 20,20
0A70:  DATA 20,20
0A72:  DATA 20,20
0A74:  DATA 20,20
0A76:  DATA 20,20
0A78:  DATA 20,20
0A7A:  DATA 20,20
0A7C:  DATA 20,20
0A7E:  DATA 0A,0D
0A80:  DATA 00,00
0A82:  DATA 20,20
0A84:  DATA 20,20
0A86:  DATA 20,20
0A88:  DATA 45,53
0A8A:  DATA 43,3A
0A8C:  DATA 42,41
0A8E:  DATA 43,4B
0A90:  DATA 20,20
0A92:  DATA 20,20
0A94:  DATA 20,20
0A96:  DATA 0A,0D
0A98:  DATA 00,00
0A9A:  DATA 45,30
0A9C:  DATA 30,3A
0A9E:  DATA 25,30
0AA0:  DATA 32,75
0AA2:  DATA 20,45
0AA4:  DATA 30,31
0AA6:  DATA 3A,25
0AA8:  DATA 30,32
0AAA:  DATA 75,20
0AAC:  DATA 45,30
0AAE:  DATA 32,3A
0AB0:  DATA 25,30
0AB2:  DATA 32,75
0AB4:  DATA 0A,0D
0AB6:  DATA 00,00
0AB8:  DATA 45,30
0ABA:  DATA 33,3A
0ABC:  DATA 25,30
0ABE:  DATA 32,75
0AC0:  DATA 20,45
0AC2:  DATA 30,34
0AC4:  DATA 3A,25
0AC6:  DATA 30,32
0AC8:  DATA 75,20
0ACA:  DATA 45,30
0ACC:  DATA 35,3A
0ACE:  DATA 25,30
0AD0:  DATA 32,75
0AD2:  DATA 0A,0D
0AD4:  DATA 00,00
0AD6:  DATA 45,30
0AD8:  DATA 36,3A
0ADA:  DATA 25,30
0ADC:  DATA 32,75
0ADE:  DATA 20,45
0AE0:  DATA 30,37
0AE2:  DATA 3A,25
0AE4:  DATA 30,32
0AE6:  DATA 75,20
0AE8:  DATA 45,30
0AEA:  DATA 38,3A
0AEC:  DATA 25,30
0AEE:  DATA 32,75
0AF0:  DATA 0A,0D
0AF2:  DATA 00,00
0AF4:  DATA 20,20
0AF6:  DATA 20,3E
0AF8:  DATA 3A,50
0AFA:  DATA 52,4F
0AFC:  DATA 58,7C
0AFE:  DATA 45,53
0B00:  DATA 43,3A
0B02:  DATA 42,41
0B04:  DATA 43,4B
0B06:  DATA 20,20
0B08:  DATA 0A,0D
0B0A:  DATA 00,00
0B0C:  DATA 45,30
0B0E:  DATA 39,3A
0B10:  DATA 25,30
0B12:  DATA 32,75
0B14:  DATA 20,45
0B16:  DATA 31,30
0B18:  DATA 3A,25
0B1A:  DATA 30,32
0B1C:  DATA 75,20
0B1E:  DATA 45,31
0B20:  DATA 31,3A
0B22:  DATA 25,30
0B24:  DATA 32,75
0B26:  DATA 0A,0D
0B28:  DATA 00,00
0B2A:  DATA 45,31
0B2C:  DATA 32,3A
0B2E:  DATA 25,30
0B30:  DATA 32,75
0B32:  DATA 20,45
0B34:  DATA 31,33
0B36:  DATA 3A,25
0B38:  DATA 30,32
0B3A:  DATA 75,20
0B3C:  DATA 45,31
0B3E:  DATA 34,3A
0B40:  DATA 25,30
0B42:  DATA 32,75
0B44:  DATA 0A,0D
0B46:  DATA 00,00
0B48:  DATA 45,31
0B4A:  DATA 35,3A
0B4C:  DATA 25,30
0B4E:  DATA 32,75
0B50:  DATA 20,45
0B52:  DATA 31,36
0B54:  DATA 3A,25
0B56:  DATA 30,32
0B58:  DATA 75,20
0B5A:  DATA 45,31
0B5C:  DATA 37,3A
0B5E:  DATA 25,30
0B60:  DATA 32,75
0B62:  DATA 0A,0D
0B64:  DATA 00,00
0B66:  DATA 20,20
0B68:  DATA 3C,7C
0B6A:  DATA 3E,3A
0B6C:  DATA 50,52
0B6E:  DATA 4F,58
0B70:  DATA 7C,45
0B72:  DATA 53,43
0B74:  DATA 3A,42
0B76:  DATA 41,43
0B78:  DATA 4B,20
0B7A:  DATA 0A,0D
0B7C:  DATA 00,00
0B7E:  DATA 45,31
0B80:  DATA 38,3A
0B82:  DATA 25,30
0B84:  DATA 32,75
0B86:  DATA 20,45
0B88:  DATA 31,39
0B8A:  DATA 3A,25
0B8C:  DATA 30,32
0B8E:  DATA 75,20
0B90:  DATA 45,32
0B92:  DATA 30,3A
0B94:  DATA 25,30
0B96:  DATA 32,75
0B98:  DATA 0A,0D
0B9A:  DATA 00,00
0B9C:  DATA 45,32
0B9E:  DATA 31,3A
0BA0:  DATA 25,30
0BA2:  DATA 32,75
0BA4:  DATA 20,45
0BA6:  DATA 32,32
0BA8:  DATA 3A,25
0BAA:  DATA 30,32
0BAC:  DATA 75,20
0BAE:  DATA 45,32
0BB0:  DATA 33,3A
0BB2:  DATA 25,30
0BB4:  DATA 32,75
0BB6:  DATA 0A,0D
0BB8:  DATA 00,00
0BBA:  DATA 45,32
0BBC:  DATA 34,3A
0BBE:  DATA 25,30
0BC0:  DATA 32,75
0BC2:  DATA 20,45
0BC4:  DATA 32,35
0BC6:  DATA 3A,25
0BC8:  DATA 30,32
0BCA:  DATA 75,20
0BCC:  DATA 45,32
0BCE:  DATA 36,3A
0BD0:  DATA 25,30
0BD2:  DATA 32,75
0BD4:  DATA 0A,0D
0BD6:  DATA 00,00
0BD8:  DATA 45,32
0BDA:  DATA 37,3A
0BDC:  DATA 25,30
0BDE:  DATA 32,75
0BE0:  DATA 20,3C
0BE2:  DATA 3A,41
0BE4:  DATA 4E,54
0BE6:  DATA 7C,45
0BE8:  DATA 53,43
0BEA:  DATA 3A,42
0BEC:  DATA 41,43
0BEE:  DATA 4B,0A
0BF0:  DATA 0D,00
0BF2:  DATA 45,53
0BF4:  DATA 54,45
0BF6:  DATA 49,52
0BF8:  DATA 41,20
0BFA:  DATA 20,20
0BFC:  DATA 20,20
0BFE:  DATA 20,20
0C00:  DATA 20,20
0C02:  DATA 20,20
0C04:  DATA 20,20
0C06:  DATA 0A,0D
0C08:  DATA 00,00
0C0A:  DATA 44,45
0C0C:  DATA 44,4F
0C0E:  DATA 53,20
0C10:  DATA 45,4E
0C12:  DATA 54,52
0C14:  DATA 41,44
0C16:  DATA 41,20
0C18:  DATA 20,20
0C1A:  DATA 20,20
0C1C:  DATA 20,20
0C1E:  DATA 0A,0D
0C20:  DATA 00,00
0C22:  DATA 41,4C
0C24:  DATA 49,4D
0C26:  DATA 45,4E
0C28:  DATA 54,41
0C2A:  DATA 44,4F
0C2C:  DATA 52,5F
0C2E:  DATA 50,4C
0C30:  DATA 41,43
0C32:  DATA 41,20
0C34:  DATA 20,20
0C36:  DATA 0A,0D
0C38:  DATA 00,00
0C3A:  DATA 46,31
0C3C:  DATA 3A,4F
0C3E:  DATA 4E,7C
0C40:  DATA 46,32
0C42:  DATA 3A,4F
0C44:  DATA 46,7C
0C46:  DATA 45,53
0C48:  DATA 43,3A
0C4A:  DATA 42,41
0C4C:  DATA 43,4B
0C4E:  DATA 0A,0D
0C50:  DATA 00,00
0C52:  DATA 50,52
0C54:  DATA 45,53
0C56:  DATA 53,4F
0C58:  DATA 52,20
0C5A:  DATA 20,20
0C5C:  DATA 20,20
0C5E:  DATA 20,20
0C60:  DATA 20,20
0C62:  DATA 20,20
0C64:  DATA 20,20
0C66:  DATA 0A,0D
0C68:  DATA 00,00
0C6A:  DATA 44,45
0C6C:  DATA 44,4F
0C6E:  DATA 53,5F
0C70:  DATA 53,41
0C72:  DATA 49,44
0C74:  DATA 41,20
0C76:  DATA 20,20
0C78:  DATA 20,20
0C7A:  DATA 20,20
0C7C:  DATA 20,20
0C7E:  DATA 0A,0D
0C80:  DATA 00,00
0C82:  DATA 44,49
0C84:  DATA 53,50
0C86:  DATA 45,4E
0C88:  DATA 53,41
0C8A:  DATA 44,4F
0C8C:  DATA 52,5F
0C8E:  DATA 50,4C
0C90:  DATA 41,43
0C92:  DATA 41,20
0C94:  DATA 20,20
0C96:  DATA 0A,0D
0C98:  DATA 00,00
0C9A:  DATA 46,31
0C9C:  DATA 3A,4F
0C9E:  DATA 4E,7C
0CA0:  DATA 46,32
0CA2:  DATA 3A,4F
0CA4:  DATA 46,7C
0CA6:  DATA 45,53
0CA8:  DATA 43,3A
0CAA:  DATA 42,41
0CAC:  DATA 43,4B
0CAE:  DATA 0A,0D
0CB0:  DATA 00,00
0CB2:  DATA 41,4C
0CB4:  DATA 49,4D
0CB6:  DATA 45,4E
0CB8:  DATA 54,41
0CBA:  DATA 44,4F
0CBC:  DATA 52,5F
0CBE:  DATA 53,4F
0CC0:  DATA 4C,44
0CC2:  DATA 41,20
0CC4:  DATA 20,20
0CC6:  DATA 0A,0D
0CC8:  DATA 00,00
0CCA:  DATA 4C,49
0CCC:  DATA 4D,50
0CCE:  DATA 41,44
0CD0:  DATA 4F,52
0CD2:  DATA 5F,42
0CD4:  DATA 49,43
0CD6:  DATA 4F,20
0CD8:  DATA 20,20
0CDA:  DATA 20,20
0CDC:  DATA 20,20
0CDE:  DATA 0A,0D
0CE0:  DATA 00,00
0CE2:  DATA 46,45
0CE4:  DATA 52,52
0CE6:  DATA 4F,53
0CE8:  DATA 5F,44
0CEA:  DATA 45,5F
0CEC:  DATA 53,4F
0CEE:  DATA 4C,44
0CF0:  DATA 41,20
0CF2:  DATA 20,20
0CF4:  DATA 20,20
0CF6:  DATA 0A,0D
0CF8:  DATA 00,00
0CFA:  DATA 46,31
0CFC:  DATA 3A,4F
0CFE:  DATA 4E,7C
0D00:  DATA 46,32
0D02:  DATA 3A,4F
0D04:  DATA 46,7C
0D06:  DATA 45,53
0D08:  DATA 43,3A
0D0A:  DATA 42,41
0D0C:  DATA 43,4B
0D0E:  DATA 0A,0D
0D10:  DATA 00,00
0D12:  DATA 20,20
0D14:  DATA 20,58
0D16:  DATA 3A,25
0D18:  DATA 30,34
0D1A:  DATA 4C,75
0D1C:  DATA 20,20
0D1E:  DATA 59,3A
0D20:  DATA 25,30
0D22:  DATA 34,4C
0D24:  DATA 75,20
0D26:  DATA 20,0A
0D28:  DATA 0D,00
0D2A:  DATA 20,20
0D2C:  DATA 20,5A
0D2E:  DATA 3A,25
0D30:  DATA 30,34
0D32:  DATA 4C,75
0D34:  DATA 20,20
0D36:  DATA 46,3A
0D38:  DATA 25,30
0D3A:  DATA 34,4C
0D3C:  DATA 75,20
0D3E:  DATA 20,0A
0D40:  DATA 0D,00
0D42:  DATA 20,20
0D44:  DATA 5E,7C
0D46:  DATA 3F,7C
0D48:  DATA 7C,3E
0D4A:  DATA 7C,3C
0D4C:  DATA 7C,46
0D4E:  DATA 31,7C
0D50:  DATA 46,32
0D52:  DATA 7C,38
0D54:  DATA 7C,30
0D56:  DATA 20,0A
0D58:  DATA 0D,00
0D5A:  DATA 20,20
0D5C:  DATA 20,20
0D5E:  DATA 20,20
0D60:  DATA 20,45
0D62:  DATA 53,43
0D64:  DATA 3A,42
0D66:  DATA 41,43
0D68:  DATA 4B,20
0D6A:  DATA 20,20
0D6C:  DATA 20,20
0D6E:  DATA 20,0A
0D70:  DATA 0D,00
0D72:  DATA 20,45
0D74:  DATA 58,45
0D76:  DATA 43,55
0D78:  DATA 54,41
0D7A:  DATA 4E,44
0D7C:  DATA 4F,20
0D7E:  DATA 50,52
0D80:  DATA 4F,47
0D82:  DATA 52,41
0D84:  DATA 4D,41
0D86:  DATA 0A,0D
0D88:  DATA 00,00
0D8A:  DATA 20,20
0D8C:  DATA 20,20
0D8E:  DATA 20,4D
0D90:  DATA 4F,44
0D92:  DATA 45,4C
0D94:  DATA 4F,3A
0D96:  DATA 25,30
0D98:  DATA 32,75
0D9A:  DATA 20,20
0D9C:  DATA 20,20
0D9E:  DATA 0A,0D
0DA0:  DATA 00,00
0DA2:  DATA 20,20
0DA4:  DATA 20,20
0DA6:  DATA 20,20
0DA8:  DATA 20,20
0DAA:  DATA 20,20
0DAC:  DATA 20,20
0DAE:  DATA 20,20
0DB0:  DATA 20,20
0DB2:  DATA 20,20
0DB4:  DATA 20,20
0DB6:  DATA 0A,0D
0DB8:  DATA 00,00
0DBA:  DATA 20,20
0DBC:  DATA 20,20
0DBE:  DATA 20,20
0DC0:  DATA 45,53
0DC2:  DATA 43,3A
0DC4:  DATA 53,54
0DC6:  DATA 4F,50
0DC8:  DATA 20,20
0DCA:  DATA 20,20
0DCC:  DATA 20,20
0DCE:  DATA 0A,0D
0DD0:  DATA 00,00
0DD2:  DATA 20,20
0DD4:  DATA 50,4F
0DD6:  DATA 53,49
0DD8:  DATA 43,41
0DDA:  DATA 4F,20
0DDC:  DATA 49,52
0DDE:  DATA 52,45
0DE0:  DATA 47,55
0DE2:  DATA 4C,41
0DE4:  DATA 52,20
0DE6:  DATA 0A,0D
0DE8:  DATA 00,00
0DEA:  DATA 20,20
0DEC:  DATA 20,58
0DEE:  DATA 20,44
0DF0:  DATA 45,56
0DF2:  DATA 45,20
0DF4:  DATA 53,45
0DF6:  DATA 52,20
0DF8:  DATA 3E,20
0DFA:  DATA 30,20
0DFC:  DATA 20,20
0DFE:  DATA 0A,0D
0E00:  DATA 00,00
0E02:  DATA 20,20
0E04:  DATA 59,20
0E06:  DATA 44,45
0E08:  DATA 56,45
0E0A:  DATA 20,53
0E0C:  DATA 45,52
0E0E:  DATA 20,3E
0E10:  DATA 20,37
0E12:  DATA 30,30
0E14:  DATA 20,20
0E16:  DATA 0A,0D
0E18:  DATA 00,00
0E1A:  DATA 20,20
0E1C:  DATA 43,41
0E1E:  DATA 52,52
0E20:  DATA 45,47
0E22:  DATA 41,4E
0E24:  DATA 44,4F
0E26:  DATA 20,4D
0E28:  DATA 4F,44
0E2A:  DATA 45,4C
0E2C:  DATA 4F,20
0E2E:  DATA 0A,0D
0E30:  DATA 00,00
0E32:  DATA 20,20
0E34:  DATA 43,41
0E36:  DATA 52,52
0E38:  DATA 45,47
0E3A:  DATA 41,4E
0E3C:  DATA 44,4F
0E3E:  DATA 20,4D
0E40:  DATA 4F,44
0E42:  DATA 45,4C
0E44:  DATA 4F,20
0E46:  DATA 0A,0D
0E48:  DATA 00,00
0E4A:  DATA 50,4F
0E4C:  DATA 4E,54
0E4E:  DATA 4F,53
0E50:  DATA 20,41
0E52:  DATA 54,55
0E54:  DATA 41,4C
0E56:  DATA 49,5A
0E58:  DATA 41,44
0E5A:  DATA 4F,53
0E5C:  DATA 0A,0D
0E5E:  DATA 00,00
0E60:  DATA 20,20
0E62:  DATA 45,58
0E64:  DATA 43,4C
0E66:  DATA 55,49
0E68:  DATA 4E,44
0E6A:  DATA 4F,20
0E6C:  DATA 4D,4F
0E6E:  DATA 44,45
0E70:  DATA 4C,4F
0E72:  DATA 20,20
0E74:  DATA 0A,0D
0E76:  DATA 00,00
0E78:  DATA 20,20
0E7A:  DATA 20,4D
0E7C:  DATA 4F,44
0E7E:  DATA 45,4C
0E80:  DATA 4F,20
0E82:  DATA 45,58
0E84:  DATA 43,55
0E86:  DATA 49,44
0E88:  DATA 4F,20
0E8A:  DATA 20,20
0E8C:  DATA 0A,0D
0E8E:  DATA 00,00
0E90:  DATA 47,52
0E92:  DATA 41,56
0E94:  DATA 41,4E
0E96:  DATA 44,4F
0E98:  DATA 20,50
0E9A:  DATA 4F,4E
0E9C:  DATA 54,4F
0E9E:  DATA 0A,0D
0EA0:  DATA 00,00
0EA2:  DATA 50,4F
0EA4:  DATA 4E,54
0EA6:  DATA 4F,20
0EA8:  DATA 47,52
0EAA:  DATA 41,56
0EAC:  DATA 41,44
0EAE:  DATA 4F,0A
0EB0:  DATA 0D,00
0EB2:  DATA 20,20
0EB4:  DATA 20,45
0EB6:  DATA 53,50
0EB8:  DATA 45,52
0EBA:  DATA 41,4E
0EBC:  DATA 44,4F
0EBE:  DATA 20,50
0EC0:  DATA 4C,41
0EC2:  DATA 43,41
0EC4:  DATA 20,20
0EC6:  DATA 20,0A
0EC8:  DATA 0D,00
0ECA:  DATA 20,20
0ECC:  DATA 20,20
0ECE:  DATA 20,4E
0ED0:  DATA 41,20
0ED2:  DATA 45,53
0ED4:  DATA 54,45
0ED6:  DATA 49,52
0ED8:  DATA 41,20
0EDA:  DATA 20,20
0EDC:  DATA 20,20
0EDE:  DATA 0A,0D
0EE0:  DATA 00,00
0EE2:  DATA 20,20
0EE4:  DATA 20,20
0EE6:  DATA 20,20
0EE8:  DATA 53,45
0EEA:  DATA 4D,20
0EEC:  DATA 50,4C
0EEE:  DATA 41,43
0EF0:  DATA 41,20
0EF2:  DATA 20,20
0EF4:  DATA 20,20
0EF6:  DATA 0A,0D
0EF8:  DATA 00,00
0EFA:  DATA 20,20
0EFC:  DATA 20,20
0EFE:  DATA 20,4E
0F00:  DATA 41,20
0F02:  DATA 42,41
0F04:  DATA 4E,44
0F06:  DATA 45,4A
0F08:  DATA 41,20
0F0A:  DATA 20,20
0F0C:  DATA 20,20
0F0E:  DATA 0A,0D
0F10:  DATA 00,00
*
22F0:  TBLRD*+
22F2:  MOVF   FF5,F
22F4:  BZ    230E
22F6:  MOVFF  FF6,3AE
22FA:  MOVFF  FF7,3AF
22FE:  MOVFF  FF5,3BE
2302:  RCALL  22E4
2304:  MOVFF  3AE,FF6
2308:  MOVFF  3AF,FF7
230C:  BRA    22F0
230E:  RETURN 0
*
248A:  TBLRD*+
248C:  MOVF   FF5,F
248E:  BZ    24A8
2490:  MOVFF  FF6,3B2
2494:  MOVFF  FF7,3B3
2498:  MOVFF  FF5,3BD
249C:  RCALL  2436
249E:  MOVFF  3B2,FF6
24A2:  MOVFF  3B3,FF7
24A6:  BRA    248A
24A8:  RETURN 0
*
2628:  MOVLB  3
262A:  MOVF   xC8,W
262C:  BTFSC  FD8.2
262E:  BRA    2712
2630:  MOVWF  00
2632:  MOVF   xCC,W
2634:  BTFSC  FD8.2
2636:  BRA    2712
2638:  ADDWF  00,F
263A:  BNC   2644
263C:  MOVLW  81
263E:  ADDWF  00,F
2640:  BC    2712
2642:  BRA    264C
2644:  MOVLW  7F
2646:  SUBWF  00,F
2648:  BNC   2712
264A:  BZ    2712
264C:  MOVFF  3C9,3D0
2650:  MOVF   xCD,W
2652:  XORWF  xD0,F
2654:  BSF    xC9.7
2656:  BSF    xCD.7
2658:  MOVF   xCB,W
265A:  MULWF  xCF
265C:  MOVFF  FF4,3D2
2660:  MOVF   xCA,W
2662:  MULWF  xCE
2664:  MOVFF  FF4,03
2668:  MOVFF  FF3,3D1
266C:  MULWF  xCF
266E:  MOVF   FF3,W
2670:  ADDWF  xD2,F
2672:  MOVF   FF4,W
2674:  ADDWFC xD1,F
2676:  MOVLW  00
2678:  ADDWFC 03,F
267A:  MOVF   xCB,W
267C:  MULWF  xCE
267E:  MOVF   FF3,W
2680:  ADDWF  xD2,F
2682:  MOVF   FF4,W
2684:  ADDWFC xD1,F
2686:  MOVLW  00
2688:  CLRF   02
268A:  ADDWFC 03,F
268C:  ADDWFC 02,F
268E:  MOVF   xC9,W
2690:  MULWF  xCF
2692:  MOVF   FF3,W
2694:  ADDWF  xD1,F
2696:  MOVF   FF4,W
2698:  ADDWFC 03,F
269A:  MOVLW  00
269C:  ADDWFC 02,F
269E:  MOVF   xC9,W
26A0:  MULWF  xCE
26A2:  MOVF   FF3,W
26A4:  ADDWF  03,F
26A6:  MOVF   FF4,W
26A8:  ADDWFC 02,F
26AA:  MOVLW  00
26AC:  CLRF   01
26AE:  ADDWFC 01,F
26B0:  MOVF   xCB,W
26B2:  MULWF  xCD
26B4:  MOVF   FF3,W
26B6:  ADDWF  xD1,F
26B8:  MOVF   FF4,W
26BA:  ADDWFC 03,F
26BC:  MOVLW  00
26BE:  ADDWFC 02,F
26C0:  ADDWFC 01,F
26C2:  MOVF   xCA,W
26C4:  MULWF  xCD
26C6:  MOVF   FF3,W
26C8:  ADDWF  03,F
26CA:  MOVF   FF4,W
26CC:  ADDWFC 02,F
26CE:  MOVLW  00
26D0:  ADDWFC 01,F
26D2:  MOVF   xC9,W
26D4:  MULWF  xCD
26D6:  MOVF   FF3,W
26D8:  ADDWF  02,F
26DA:  MOVF   FF4,W
26DC:  ADDWFC 01,F
26DE:  INCF   00,F
26E0:  BTFSC  01.7
26E2:  BRA    26EE
26E4:  RLCF   xD1,F
26E6:  RLCF   03,F
26E8:  RLCF   02,F
26EA:  RLCF   01,F
26EC:  DECF   00,F
26EE:  MOVLW  00
26F0:  BTFSS  xD1.7
26F2:  BRA    2708
26F4:  INCF   03,F
26F6:  ADDWFC 02,F
26F8:  ADDWFC 01,F
26FA:  MOVF   01,W
26FC:  BNZ   2708
26FE:  MOVF   02,W
2700:  BNZ   2708
2702:  MOVF   03,W
2704:  BNZ   2708
2706:  INCF   00,F
2708:  BTFSC  xD0.7
270A:  BSF    01.7
270C:  BTFSS  xD0.7
270E:  BCF    01.7
2710:  BRA    271A
2712:  CLRF   00
2714:  CLRF   01
2716:  CLRF   02
2718:  CLRF   03
271A:  MOVLB  0
271C:  RETURN 0
271E:  MOVLB  3
2720:  MOVF   xCE,W
2722:  BTFSC  FD8.2
2724:  BRA    2870
2726:  MOVWF  xDA
2728:  MOVF   xD2,W
272A:  BTFSC  FD8.2
272C:  BRA    2870
272E:  SUBWF  xDA,F
2730:  BNC   273C
2732:  MOVLW  7F
2734:  ADDWF  xDA,F
2736:  BTFSC  FD8.0
2738:  BRA    2870
273A:  BRA    2748
273C:  MOVLW  81
273E:  SUBWF  xDA,F
2740:  BTFSS  FD8.0
2742:  BRA    2870
2744:  BTFSC  FD8.2
2746:  BRA    2870
2748:  MOVFF  3DA,00
274C:  CLRF   01
274E:  CLRF   02
2750:  CLRF   03
2752:  CLRF   xD9
2754:  MOVFF  3CF,3D8
2758:  BSF    xD8.7
275A:  MOVFF  3D0,3D7
275E:  MOVFF  3D1,3D6
2762:  MOVLW  19
2764:  MOVWF  xDA
2766:  MOVF   xD5,W
2768:  SUBWF  xD6,F
276A:  BC    2786
276C:  MOVLW  01
276E:  SUBWF  xD7,F
2770:  BC    2786
2772:  SUBWF  xD8,F
2774:  BC    2786
2776:  SUBWF  xD9,F
2778:  BC    2786
277A:  INCF   xD9,F
277C:  INCF   xD8,F
277E:  INCF   xD7,F
2780:  MOVF   xD5,W
2782:  ADDWF  xD6,F
2784:  BRA    27D6
2786:  MOVF   xD4,W
2788:  SUBWF  xD7,F
278A:  BC    27B0
278C:  MOVLW  01
278E:  SUBWF  xD8,F
2790:  BC    27B0
2792:  SUBWF  xD9,F
2794:  BC    27B0
2796:  INCF   xD9,F
2798:  INCF   xD8,F
279A:  MOVF   xD4,W
279C:  ADDWF  xD7,F
279E:  MOVF   xD5,W
27A0:  ADDWF  xD6,F
27A2:  BNC   27D6
27A4:  INCF   xD7,F
27A6:  BNZ   27D6
27A8:  INCF   xD8,F
27AA:  BNZ   27D6
27AC:  INCF   xD9,F
27AE:  BRA    27D6
27B0:  MOVF   xD3,W
27B2:  IORLW  80
27B4:  SUBWF  xD8,F
27B6:  BC    27D4
27B8:  MOVLW  01
27BA:  SUBWF  xD9,F
27BC:  BC    27D4
27BE:  INCF   xD9,F
27C0:  MOVF   xD3,W
27C2:  IORLW  80
27C4:  ADDWF  xD8,F
27C6:  MOVF   xD4,W
27C8:  ADDWF  xD7,F
27CA:  BNC   279E
27CC:  INCF   xD8,F
27CE:  BNZ   279E
27D0:  INCF   xD9,F
27D2:  BRA    279E
27D4:  BSF    03.0
27D6:  DECFSZ xDA,F
27D8:  BRA    27DC
27DA:  BRA    27F2
27DC:  BCF    FD8.0
27DE:  RLCF   xD6,F
27E0:  RLCF   xD7,F
27E2:  RLCF   xD8,F
27E4:  RLCF   xD9,F
27E6:  BCF    FD8.0
27E8:  RLCF   03,F
27EA:  RLCF   02,F
27EC:  RLCF   01,F
27EE:  RLCF   xDB,F
27F0:  BRA    2766
27F2:  BTFSS  xDB.0
27F4:  BRA    2802
27F6:  BCF    FD8.0
27F8:  RRCF   01,F
27FA:  RRCF   02,F
27FC:  RRCF   03,F
27FE:  RRCF   xDB,F
2800:  BRA    2806
2802:  DECF   00,F
2804:  BZ    2870
2806:  BTFSC  xDB.7
2808:  BRA    2846
280A:  BCF    FD8.0
280C:  RLCF   xD6,F
280E:  RLCF   xD7,F
2810:  RLCF   xD8,F
2812:  RLCF   xD9,F
2814:  MOVF   xD5,W
2816:  SUBWF  xD6,F
2818:  BC    2828
281A:  MOVLW  01
281C:  SUBWF  xD7,F
281E:  BC    2828
2820:  SUBWF  xD8,F
2822:  BC    2828
2824:  SUBWF  xD9,F
2826:  BNC   285C
2828:  MOVF   xD4,W
282A:  SUBWF  xD7,F
282C:  BC    2838
282E:  MOVLW  01
2830:  SUBWF  xD8,F
2832:  BC    2838
2834:  SUBWF  xD9,F
2836:  BNC   285C
2838:  MOVF   xD3,W
283A:  IORLW  80
283C:  SUBWF  xD8,F
283E:  BC    2846
2840:  MOVLW  01
2842:  SUBWF  xD9,F
2844:  BNC   285C
2846:  INCF   03,F
2848:  BNZ   285C
284A:  INCF   02,F
284C:  BNZ   285C
284E:  INCF   01,F
2850:  BNZ   285C
2852:  INCF   00,F
2854:  BZ    2870
2856:  RRCF   01,F
2858:  RRCF   02,F
285A:  RRCF   03,F
285C:  MOVFF  3CF,3DA
2860:  MOVF   xD3,W
2862:  XORWF  xDA,F
2864:  BTFSS  xDA.7
2866:  BRA    286C
2868:  BSF    01.7
286A:  BRA    2878
286C:  BCF    01.7
286E:  BRA    2878
2870:  CLRF   00
2872:  CLRF   01
2874:  CLRF   02
2876:  CLRF   03
2878:  MOVLB  0
287A:  RETURN 0
287C:  MOVLW  8E
287E:  MOVWF  00
2880:  MOVFF  3C9,01
2884:  MOVFF  3C8,02
2888:  CLRF   03
288A:  MOVF   01,F
288C:  BNZ   28A0
288E:  MOVFF  02,01
2892:  CLRF   02
2894:  MOVLW  08
2896:  SUBWF  00,F
2898:  MOVF   01,F
289A:  BNZ   28A0
289C:  CLRF   00
289E:  BRA    28B0
28A0:  BCF    FD8.0
28A2:  BTFSC  01.7
28A4:  BRA    28AE
28A6:  RLCF   02,F
28A8:  RLCF   01,F
28AA:  DECF   00,F
28AC:  BRA    28A0
28AE:  BCF    01.7
28B0:  RETURN 0
28B2:  MOVLW  80
28B4:  BTFSS  FD8.1
28B6:  BRA    28BC
28B8:  MOVLB  3
28BA:  XORWF  xD3,F
28BC:  MOVLB  3
28BE:  CLRF   xD8
28C0:  CLRF   xD9
28C2:  MOVFF  3CF,3D7
28C6:  MOVF   xD3,W
28C8:  XORWF  xD7,F
28CA:  MOVF   xCE,W
28CC:  BTFSC  FD8.2
28CE:  BRA    2A8E
28D0:  MOVWF  xD6
28D2:  MOVWF  00
28D4:  MOVF   xD2,W
28D6:  BTFSC  FD8.2
28D8:  BRA    2AA0
28DA:  SUBWF  xD6,F
28DC:  BTFSC  FD8.2
28DE:  BRA    29E6
28E0:  BNC   295E
28E2:  MOVFF  3D3,3DC
28E6:  BSF    xDC.7
28E8:  MOVFF  3D4,3DB
28EC:  MOVFF  3D5,3DA
28F0:  CLRF   xD9
28F2:  BCF    FD8.0
28F4:  RRCF   xDC,F
28F6:  RRCF   xDB,F
28F8:  RRCF   xDA,F
28FA:  RRCF   xD9,F
28FC:  DECFSZ xD6,F
28FE:  BRA    28F0
2900:  BTFSS  xD7.7
2902:  BRA    290A
2904:  BSF    xD8.0
2906:  BRA    2AC8
2908:  BCF    xD8.0
290A:  BCF    xD6.0
290C:  BSF    xD8.4
290E:  MOVLW  03
2910:  MOVWF  FEA
2912:  MOVLW  D1
2914:  MOVWF  FE9
2916:  BRA    2AEE
2918:  BCF    xD8.4
291A:  BTFSC  xD7.7
291C:  BRA    2932
291E:  BTFSS  xD6.0
2920:  BRA    2948
2922:  RRCF   xDC,F
2924:  RRCF   xDB,F
2926:  RRCF   xDA,F
2928:  RRCF   xD9,F
292A:  INCF   00,F
292C:  BTFSC  FD8.2
292E:  BRA    2ABE
2930:  BRA    2948
2932:  BTFSC  xDC.7
2934:  BRA    294E
2936:  BCF    FD8.0
2938:  RLCF   xD9,F
293A:  RLCF   xDA,F
293C:  RLCF   xDB,F
293E:  RLCF   xDC,F
2940:  DECF   00,F
2942:  BTFSC  FD8.2
2944:  BRA    2ABE
2946:  BRA    2932
2948:  BSF    xD8.6
294A:  BRA    2A26
294C:  BCF    xD8.6
294E:  MOVFF  3CF,3D7
2952:  BTFSS  xCF.7
2954:  BRA    295A
2956:  BSF    xDC.7
2958:  BRA    2AB0
295A:  BCF    xDC.7
295C:  BRA    2AB0
295E:  MOVFF  3D2,3D6
2962:  MOVFF  3D2,00
2966:  MOVF   xCE,W
2968:  SUBWF  xD6,F
296A:  MOVFF  3CF,3DC
296E:  BSF    xDC.7
2970:  MOVFF  3D0,3DB
2974:  MOVFF  3D1,3DA
2978:  CLRF   xD9
297A:  BCF    FD8.0
297C:  RRCF   xDC,F
297E:  RRCF   xDB,F
2980:  RRCF   xDA,F
2982:  RRCF   xD9,F
2984:  DECFSZ xD6,F
2986:  BRA    2978
2988:  BTFSS  xD7.7
298A:  BRA    2992
298C:  BSF    xD8.1
298E:  BRA    2AC8
2990:  BCF    xD8.1
2992:  BCF    xD6.0
2994:  BSF    xD8.5
2996:  MOVLW  03
2998:  MOVWF  FEA
299A:  MOVLW  D5
299C:  MOVWF  FE9
299E:  BRA    2AEE
29A0:  BCF    xD8.5
29A2:  BTFSC  xD7.7
29A4:  BRA    29BA
29A6:  BTFSS  xD6.0
29A8:  BRA    29D0
29AA:  RRCF   xDC,F
29AC:  RRCF   xDB,F
29AE:  RRCF   xDA,F
29B0:  RRCF   xD9,F
29B2:  INCF   00,F
29B4:  BTFSC  FD8.2
29B6:  BRA    2ABE
29B8:  BRA    29D0
29BA:  BTFSC  xDC.7
29BC:  BRA    29D6
29BE:  BCF    FD8.0
29C0:  RLCF   xD9,F
29C2:  RLCF   xDA,F
29C4:  RLCF   xDB,F
29C6:  RLCF   xDC,F
29C8:  DECF   00,F
29CA:  BTFSC  FD8.2
29CC:  BRA    2ABE
29CE:  BRA    29BA
29D0:  BSF    xD8.7
29D2:  BRA    2A26
29D4:  BCF    xD8.7
29D6:  MOVFF  3D3,3D7
29DA:  BTFSS  xD3.7
29DC:  BRA    29E2
29DE:  BSF    xDC.7
29E0:  BRA    2AB0
29E2:  BCF    xDC.7
29E4:  BRA    2AB0
29E6:  MOVFF  3D3,3DC
29EA:  BSF    xDC.7
29EC:  MOVFF  3D4,3DB
29F0:  MOVFF  3D5,3DA
29F4:  BTFSS  xD7.7
29F6:  BRA    2A00
29F8:  BCF    xDC.7
29FA:  BSF    xD8.2
29FC:  BRA    2AC8
29FE:  BCF    xD8.2
2A00:  CLRF   xD9
2A02:  BCF    xD6.0
2A04:  MOVLW  03
2A06:  MOVWF  FEA
2A08:  MOVLW  D1
2A0A:  MOVWF  FE9
2A0C:  BRA    2AEE
2A0E:  BTFSC  xD7.7
2A10:  BRA    2A4A
2A12:  MOVFF  3CF,3D7
2A16:  BTFSS  xD6.0
2A18:  BRA    2A26
2A1A:  RRCF   xDC,F
2A1C:  RRCF   xDB,F
2A1E:  RRCF   xDA,F
2A20:  RRCF   xD9,F
2A22:  INCF   00,F
2A24:  BZ    2ABE
2A26:  BTFSS  xD9.7
2A28:  BRA    2A40
2A2A:  INCF   xDA,F
2A2C:  BNZ   2A40
2A2E:  INCF   xDB,F
2A30:  BNZ   2A40
2A32:  INCF   xDC,F
2A34:  BNZ   2A40
2A36:  RRCF   xDC,F
2A38:  RRCF   xDB,F
2A3A:  RRCF   xDA,F
2A3C:  INCF   00,F
2A3E:  BZ    2ABE
2A40:  BTFSC  xD8.6
2A42:  BRA    294C
2A44:  BTFSC  xD8.7
2A46:  BRA    29D4
2A48:  BRA    2A82
2A4A:  MOVLW  80
2A4C:  XORWF  xDC,F
2A4E:  BTFSS  xDC.7
2A50:  BRA    2A5A
2A52:  BRA    2AC8
2A54:  MOVFF  3D3,3D7
2A58:  BRA    2A6E
2A5A:  MOVFF  3CF,3D7
2A5E:  MOVF   xDC,F
2A60:  BNZ   2A6E
2A62:  MOVF   xDB,F
2A64:  BNZ   2A6E
2A66:  MOVF   xDA,F
2A68:  BNZ   2A6E
2A6A:  CLRF   00
2A6C:  BRA    2AB0
2A6E:  BTFSC  xDC.7
2A70:  BRA    2A82
2A72:  BCF    FD8.0
2A74:  RLCF   xD9,F
2A76:  RLCF   xDA,F
2A78:  RLCF   xDB,F
2A7A:  RLCF   xDC,F
2A7C:  DECFSZ 00,F
2A7E:  BRA    2A6E
2A80:  BRA    2ABE
2A82:  BTFSS  xD7.7
2A84:  BRA    2A8A
2A86:  BSF    xDC.7
2A88:  BRA    2AB0
2A8A:  BCF    xDC.7
2A8C:  BRA    2AB0
2A8E:  MOVFF  3D2,00
2A92:  MOVFF  3D3,3DC
2A96:  MOVFF  3D4,3DB
2A9A:  MOVFF  3D5,3DA
2A9E:  BRA    2AB0
2AA0:  MOVFF  3CE,00
2AA4:  MOVFF  3CF,3DC
2AA8:  MOVFF  3D0,3DB
2AAC:  MOVFF  3D1,3DA
2AB0:  MOVFF  3DC,01
2AB4:  MOVFF  3DB,02
2AB8:  MOVFF  3DA,03
2ABC:  BRA    2B26
2ABE:  CLRF   00
2AC0:  CLRF   01
2AC2:  CLRF   02
2AC4:  CLRF   03
2AC6:  BRA    2B26
2AC8:  CLRF   xD9
2ACA:  COMF   xDA,F
2ACC:  COMF   xDB,F
2ACE:  COMF   xDC,F
2AD0:  COMF   xD9,F
2AD2:  INCF   xD9,F
2AD4:  BNZ   2AE0
2AD6:  INCF   xDA,F
2AD8:  BNZ   2AE0
2ADA:  INCF   xDB,F
2ADC:  BNZ   2AE0
2ADE:  INCF   xDC,F
2AE0:  BTFSC  xD8.0
2AE2:  BRA    2908
2AE4:  BTFSC  xD8.1
2AE6:  BRA    2990
2AE8:  BTFSC  xD8.2
2AEA:  BRA    29FE
2AEC:  BRA    2A54
2AEE:  MOVF   FEF,W
2AF0:  ADDWF  xDA,F
2AF2:  BNC   2AFE
2AF4:  INCF   xDB,F
2AF6:  BNZ   2AFE
2AF8:  INCF   xDC,F
2AFA:  BTFSC  FD8.2
2AFC:  BSF    xD6.0
2AFE:  MOVF   FED,F
2B00:  MOVF   FEF,W
2B02:  ADDWF  xDB,F
2B04:  BNC   2B0C
2B06:  INCF   xDC,F
2B08:  BTFSC  FD8.2
2B0A:  BSF    xD6.0
2B0C:  MOVF   FED,F
2B0E:  MOVF   FEF,W
2B10:  BTFSC  FEF.7
2B12:  BRA    2B16
2B14:  XORLW  80
2B16:  ADDWF  xDC,F
2B18:  BTFSC  FD8.0
2B1A:  BSF    xD6.0
2B1C:  BTFSC  xD8.4
2B1E:  BRA    2918
2B20:  BTFSC  xD8.5
2B22:  BRA    29A0
2B24:  BRA    2A0E
2B26:  MOVLB  0
2B28:  RETURN 0
2B2A:  MOVLB  3
2B2C:  CLRF   xC6
2B2E:  CLRF   xC7
2B30:  MOVLW  01
2B32:  MOVWF  xC8
2B34:  CLRF   FDA
2B36:  CLRF   FD9
2B38:  MOVLW  03
2B3A:  MOVWF  xCB
2B3C:  MOVLW  BE
2B3E:  MOVWF  xCA
2B40:  MOVLW  03
2B42:  MOVWF  FEA
2B44:  MOVLW  C2
2B46:  MOVWF  FE9
2B48:  MOVFF  3CB,FE2
2B4C:  MOVFF  3CA,FE1
2B50:  MOVFF  3C8,3C9
2B54:  BCF    FD8.0
2B56:  MOVF   FE5,W
2B58:  MULWF  FEE
2B5A:  MOVF   FF3,W
2B5C:  ADDWFC xC6,F
2B5E:  MOVF   FF4,W
2B60:  ADDWFC xC7,F
2B62:  DECFSZ xC9,F
2B64:  BRA    2B54
2B66:  MOVFF  3C6,FDE
2B6A:  MOVFF  3C7,3C6
2B6E:  CLRF   xC7
2B70:  BTFSC  FD8.0
2B72:  INCF   xC7,F
2B74:  INCF   xCA,F
2B76:  BTFSC  FD8.2
2B78:  INCF   xCB,F
2B7A:  INCF   xC8,F
2B7C:  MOVF   xC8,W
2B7E:  SUBLW  05
2B80:  BNZ   2B40
2B82:  MOVLB  0
2B84:  RETURN 0
2B86:  MOVLW  B6
2B88:  MOVWF  00
2B8A:  CLRF   03
2B8C:  CLRF   02
2B8E:  CLRF   01
2B90:  MOVLB  3
2B92:  MOVF   xCE,W
2B94:  IORWF  xCF,W
2B96:  IORWF  xD0,W
2B98:  IORWF  xD1,W
2B9A:  BNZ   2BA0
2B9C:  CLRF   00
2B9E:  BRA    2BBA
2BA0:  BCF    FD8.0
2BA2:  BTFSC  01.7
2BA4:  BRA    2BB8
2BA6:  RLCF   xCE,F
2BA8:  RLCF   xCF,F
2BAA:  RLCF   xD0,F
2BAC:  RLCF   xD1,F
2BAE:  RLCF   03,F
2BB0:  RLCF   02,F
2BB2:  RLCF   01,F
2BB4:  DECFSZ 00,F
2BB6:  BRA    2BA0
2BB8:  BCF    01.7
2BBA:  MOVLB  0
2BBC:  RETURN 0
2BBE:  MOVLB  3
2BC0:  MOVF   xCE,W
2BC2:  SUBLW  B6
2BC4:  MOVWF  xCE
2BC6:  CLRF   03
2BC8:  MOVFF  3CF,3D2
2BCC:  BSF    xCF.7
2BCE:  BCF    FD8.0
2BD0:  RRCF   xCF,F
2BD2:  RRCF   xD0,F
2BD4:  RRCF   xD1,F
2BD6:  RRCF   03,F
2BD8:  RRCF   02,F
2BDA:  RRCF   01,F
2BDC:  RRCF   00,F
2BDE:  DECFSZ xCE,F
2BE0:  BRA    2BCE
2BE2:  BTFSS  xD2.7
2BE4:  BRA    2BFC
2BE6:  COMF   00,F
2BE8:  COMF   01,F
2BEA:  COMF   02,F
2BEC:  COMF   03,F
2BEE:  INCF   00,F
2BF0:  BTFSC  FD8.2
2BF2:  INCF   01,F
2BF4:  BTFSC  FD8.2
2BF6:  INCF   02,F
2BF8:  BTFSC  FD8.2
2BFA:  INCF   03,F
2BFC:  MOVLB  0
2BFE:  RETURN 0
*
3A1A:  MOVLB  3
3A1C:  MOVF   xB5,W
3A1E:  ANDLW  07
3A20:  MOVWF  00
3A22:  RRCF   xB5,W
3A24:  MOVWF  01
3A26:  RRCF   01,F
3A28:  RRCF   01,F
3A2A:  MOVLW  1F
3A2C:  ANDWF  01,F
3A2E:  MOVF   01,W
3A30:  ADDWF  xB7,W
3A32:  MOVWF  FE9
3A34:  MOVLW  00
3A36:  ADDWFC xB8,W
3A38:  MOVWF  FEA
3A3A:  CLRF   01
3A3C:  INCF   01,F
3A3E:  INCF   00,F
3A40:  BRA    3A44
3A42:  RLCF   01,F
3A44:  DECFSZ 00,F
3A46:  BRA    3A42
3A48:  MOVF   xB6,F
3A4A:  BZ    3A52
3A4C:  MOVF   01,W
3A4E:  IORWF  FEF,F
3A50:  BRA    3A58
3A52:  COMF   01,F
3A54:  MOVF   01,W
3A56:  ANDWF  FEF,F
3A58:  MOVLB  0
3A5A:  RETURN 0
3A5C:  MOVLB  3
3A5E:  MOVF   xB5,W
3A60:  ANDLW  07
3A62:  MOVWF  00
3A64:  RRCF   xB5,W
3A66:  MOVWF  01
3A68:  RRCF   01,F
3A6A:  RRCF   01,F
3A6C:  MOVLW  1F
3A6E:  ANDWF  01,F
3A70:  MOVF   01,W
3A72:  ADDWF  xB6,W
3A74:  MOVWF  FE9
3A76:  MOVLW  00
3A78:  ADDWFC xB7,W
3A7A:  MOVWF  FEA
3A7C:  MOVFF  FEF,01
3A80:  INCF   00,F
3A82:  BRA    3A86
3A84:  RRCF   01,F
3A86:  DECFSZ 00,F
3A88:  BRA    3A84
3A8A:  MOVLB  0
3A8C:  RETURN 0
*
3DDE:  MOVFF  FF2,0D
3DE2:  BCF    FF2.7
3DE4:  ADDWF  FE8,W
3DE6:  CLRF   FF7
3DE8:  RLCF   FF7,F
3DEA:  ADDLW  03
3DEC:  MOVWF  FF6
3DEE:  MOVLW  3E
3DF0:  ADDWFC FF7,F
3DF2:  TBLRD*-
3DF4:  MOVF   FF5,W
3DF6:  MOVWF  FFA
3DF8:  TBLRD*
3DFA:  MOVF   FF5,W
3DFC:  BTFSC  0D.7
3DFE:  BSF    FF2.7
3E00:  MOVWF  FF9
3E02:  DATA 1A,3C
3E04:  DATA 56,3C
3E06:  DATA D6,3D
3E08:  DATA 96,3C
3E0A:  DATA D6,3C
3E0C:  DATA 16,3D
3E0E:  DATA 56,3D
3E10:  DATA 96,3D
*
3F96:  MOVFF  FF2,0D
3F9A:  BCF    FF2.7
3F9C:  ADDWF  FE8,W
3F9E:  CLRF   FF7
3FA0:  RLCF   FF7,F
3FA2:  ADDLW  BB
3FA4:  MOVWF  FF6
3FA6:  MOVLW  3F
3FA8:  ADDWFC FF7,F
3FAA:  TBLRD*-
3FAC:  MOVF   FF5,W
3FAE:  MOVWF  FFA
3FB0:  TBLRD*
3FB2:  MOVF   FF5,W
3FB4:  BTFSC  0D.7
3FB6:  BSF    FF2.7
3FB8:  MOVWF  FF9
3FBA:  DATA 24,3E
3FBC:  DATA 58,3E
3FBE:  DATA 90,3F
3FC0:  DATA 8C,3E
3FC2:  DATA C0,3E
3FC4:  DATA F4,3E
3FC6:  DATA 28,3F
3FC8:  DATA 5C,3F
*
42A0:  MOVFF  FF2,0D
42A4:  BCF    FF2.7
42A6:  ADDWF  FE8,W
42A8:  CLRF   FF7
42AA:  RLCF   FF7,F
42AC:  ADDLW  C5
42AE:  MOVWF  FF6
42B0:  MOVLW  42
42B2:  ADDWFC FF7,F
42B4:  TBLRD*-
42B6:  MOVF   FF5,W
42B8:  MOVWF  FFA
42BA:  TBLRD*
42BC:  MOVF   FF5,W
42BE:  BTFSC  0D.7
42C0:  BSF    FF2.7
42C2:  MOVWF  FF9
42C4:  DATA AA,41
42C6:  DATA E6,41
42C8:  DATA 22,42
42CA:  DATA 5E,42
*
4CBA:  MOVFF  FF2,0D
4CBE:  BCF    FF2.7
4CC0:  ADDWF  FE8,W
4CC2:  CLRF   FF7
4CC4:  RLCF   FF7,F
4CC6:  ADDLW  DF
4CC8:  MOVWF  FF6
4CCA:  MOVLW  4C
4CCC:  ADDWFC FF7,F
4CCE:  TBLRD*-
4CD0:  MOVF   FF5,W
4CD2:  MOVWF  FFA
4CD4:  TBLRD*
4CD6:  MOVF   FF5,W
4CD8:  BTFSC  0D.7
4CDA:  BSF    FF2.7
4CDC:  MOVWF  FF9
4CDE:  DATA 34,4C
4CE0:  DATA 44,4C
4CE2:  DATA B4,4C
4CE4:  DATA 54,4C
4CE6:  DATA 64,4C
4CE8:  DATA 74,4C
4CEA:  DATA 84,4C
4CEC:  DATA 94,4C
4CEE:  DATA A4,4C
*
4DEC:  TBLRD*+
4DEE:  MOVFF  FF6,3B5
4DF2:  MOVFF  FF7,3B6
4DF6:  MOVFF  FF5,3BD
4DFA:  CALL   2436
4DFE:  MOVFF  3B5,FF6
4E02:  MOVFF  3B6,FF7
4E06:  MOVLB  3
4E08:  DECFSZ xB4,F
4E0A:  BRA    4E0E
4E0C:  BRA    4E12
4E0E:  MOVLB  0
4E10:  BRA    4DEC
4E12:  MOVLB  0
4E14:  RETURN 0
4E16:  MOVLB  3
4E18:  MOVF   xB4,W
4E1A:  CLRF   01
4E1C:  SUBWF  xB3,W
4E1E:  BC    4E26
4E20:  MOVFF  3B3,00
4E24:  BRA    4E3E
4E26:  CLRF   00
4E28:  MOVLW  08
4E2A:  MOVWF  xB5
4E2C:  RLCF   xB3,F
4E2E:  RLCF   00,F
4E30:  MOVF   xB4,W
4E32:  SUBWF  00,W
4E34:  BTFSC  FD8.0
4E36:  MOVWF  00
4E38:  RLCF   01,F
4E3A:  DECFSZ xB5,F
4E3C:  BRA    4E2C
4E3E:  MOVLB  0
4E40:  RETURN 0
4E42:  MOVF   01,W
4E44:  MOVFF  3B1,3B3
4E48:  MOVLW  64
4E4A:  MOVLB  3
4E4C:  MOVWF  xB4
4E4E:  MOVLB  0
4E50:  RCALL  4E16
4E52:  MOVFF  00,3B1
4E56:  MOVF   01,W
4E58:  MOVLW  30
4E5A:  BNZ   4E6C
4E5C:  MOVLB  3
4E5E:  BTFSS  xB2.1
4E60:  BRA    4E82
4E62:  BTFSC  xB2.3
4E64:  BRA    4E82
4E66:  BTFSC  xB2.4
4E68:  MOVLW  20
4E6A:  BRA    4E74
4E6C:  MOVLB  3
4E6E:  BCF    xB2.3
4E70:  BCF    xB2.4
4E72:  BSF    xB2.0
4E74:  ADDWF  01,F
4E76:  MOVFF  01,3BD
4E7A:  MOVLB  0
4E7C:  CALL   2436
4E80:  MOVLB  3
4E82:  MOVFF  3B1,3B3
4E86:  MOVLW  0A
4E88:  MOVWF  xB4
4E8A:  MOVLB  0
4E8C:  RCALL  4E16
4E8E:  MOVFF  00,3B1
4E92:  MOVF   01,W
4E94:  MOVLW  30
4E96:  BNZ   4EA8
4E98:  MOVLB  3
4E9A:  BTFSC  xB2.3
4E9C:  BRA    4EB4
4E9E:  BTFSS  xB2.0
4EA0:  BRA    4EB4
4EA2:  BTFSC  xB2.4
4EA4:  MOVLW  20
4EA6:  MOVLB  0
4EA8:  ADDWF  01,F
4EAA:  MOVFF  01,3BD
4EAE:  CALL   2436
4EB2:  MOVLB  3
4EB4:  MOVLW  30
4EB6:  ADDWF  xB1,F
4EB8:  MOVFF  3B1,3BD
4EBC:  MOVLB  0
4EBE:  CALL   2436
4EC2:  RETURN 0
*
4F28:  BTFSC  FD8.1
4F2A:  BRA    4F34
4F2C:  MOVLW  03
4F2E:  MOVWF  FEA
4F30:  MOVLW  B9
4F32:  MOVWF  FE9
4F34:  CLRF   00
4F36:  CLRF   01
4F38:  CLRF   02
4F3A:  CLRF   03
4F3C:  MOVLB  3
4F3E:  CLRF   xB9
4F40:  CLRF   xBA
4F42:  CLRF   xBB
4F44:  CLRF   xBC
4F46:  MOVF   xB8,W
4F48:  IORWF  xB7,W
4F4A:  IORWF  xB6,W
4F4C:  IORWF  xB5,W
4F4E:  BZ    4FA8
4F50:  MOVLW  20
4F52:  MOVWF  xBD
4F54:  BCF    FD8.0
4F56:  RLCF   xB1,F
4F58:  RLCF   xB2,F
4F5A:  RLCF   xB3,F
4F5C:  RLCF   xB4,F
4F5E:  RLCF   xB9,F
4F60:  RLCF   xBA,F
4F62:  RLCF   xBB,F
4F64:  RLCF   xBC,F
4F66:  MOVF   xB8,W
4F68:  SUBWF  xBC,W
4F6A:  BNZ   4F7C
4F6C:  MOVF   xB7,W
4F6E:  SUBWF  xBB,W
4F70:  BNZ   4F7C
4F72:  MOVF   xB6,W
4F74:  SUBWF  xBA,W
4F76:  BNZ   4F7C
4F78:  MOVF   xB5,W
4F7A:  SUBWF  xB9,W
4F7C:  BNC   4F9C
4F7E:  MOVF   xB5,W
4F80:  SUBWF  xB9,F
4F82:  MOVF   xB6,W
4F84:  BTFSS  FD8.0
4F86:  INCFSZ xB6,W
4F88:  SUBWF  xBA,F
4F8A:  MOVF   xB7,W
4F8C:  BTFSS  FD8.0
4F8E:  INCFSZ xB7,W
4F90:  SUBWF  xBB,F
4F92:  MOVF   xB8,W
4F94:  BTFSS  FD8.0
4F96:  INCFSZ xB8,W
4F98:  SUBWF  xBC,F
4F9A:  BSF    FD8.0
4F9C:  RLCF   00,F
4F9E:  RLCF   01,F
4FA0:  RLCF   02,F
4FA2:  RLCF   03,F
4FA4:  DECFSZ xBD,F
4FA6:  BRA    4F54
4FA8:  MOVFF  3B9,FEF
4FAC:  MOVFF  3BA,FEC
4FB0:  MOVFF  3BB,FEC
4FB4:  MOVFF  3BC,FEC
4FB8:  MOVLB  0
4FBA:  GOTO   A92C (RETURN)
*
6396:  MOVFF  FF2,0D
639A:  BCF    FF2.7
639C:  ADDWF  FE8,W
639E:  CLRF   FF7
63A0:  RLCF   FF7,F
63A2:  ADDLW  BB
63A4:  MOVWF  FF6
63A6:  MOVLW  63
63A8:  ADDWFC FF7,F
63AA:  TBLRD*-
63AC:  MOVF   FF5,W
63AE:  MOVWF  FFA
63B0:  TBLRD*
63B2:  MOVF   FF5,W
63B4:  BTFSC  0D.7
63B6:  BSF    FF2.7
63B8:  MOVWF  FF9
63BA:  DATA 3E,5A
63BC:  DATA F8,5A
63BE:  DATA 90,63
63C0:  DATA D6,5D
63C2:  DATA 22,5F
63C4:  DATA CE,60
63C6:  DATA 7E,61
63C8:  DATA EE,62
*
67BA:  MOVFF  FF2,0D
67BE:  BCF    FF2.7
67C0:  ADDWF  FE8,W
67C2:  CLRF   FF7
67C4:  RLCF   FF7,F
67C6:  ADDLW  DF
67C8:  MOVWF  FF6
67CA:  MOVLW  67
67CC:  ADDWFC FF7,F
67CE:  TBLRD*-
67D0:  MOVF   FF5,W
67D2:  MOVWF  FFA
67D4:  TBLRD*
67D6:  MOVF   FF5,W
67D8:  BTFSC  0D.7
67DA:  BSF    FF2.7
67DC:  MOVWF  FF9
67DE:  DATA 4A,67
67E0:  DATA 5A,67
67E2:  DATA B6,67
67E4:  DATA B6,67
67E6:  DATA 6E,67
67E8:  DATA 76,67
67EA:  MOVFF  FEA,3BC
67EE:  MOVFF  FE9,3BB
67F2:  MOVLB  3
67F4:  SWAPF  xB5,W
67F6:  IORLW  F0
67F8:  MOVWF  xB7
67FA:  ADDWF  xB7,F
67FC:  ADDLW  E2
67FE:  MOVWF  xB8
6800:  ADDLW  32
6802:  MOVWF  xBA
6804:  MOVF   xB5,W
6806:  ANDLW  0F
6808:  ADDWF  xB8,F
680A:  ADDWF  xB8,F
680C:  ADDWF  xBA,F
680E:  ADDLW  E9
6810:  MOVWF  xB9
6812:  ADDWF  xB9,F
6814:  ADDWF  xB9,F
6816:  SWAPF  xB4,W
6818:  ANDLW  0F
681A:  ADDWF  xB9,F
681C:  ADDWF  xBA,F
681E:  RLCF   xB9,F
6820:  RLCF   xBA,F
6822:  COMF   xBA,F
6824:  RLCF   xBA,F
6826:  MOVF   xB4,W
6828:  ANDLW  0F
682A:  ADDWF  xBA,F
682C:  RLCF   xB7,F
682E:  MOVLW  07
6830:  MOVWF  xB6
6832:  MOVLW  0A
6834:  DECF   xB9,F
6836:  ADDWF  xBA,F
6838:  BNC   6834
683A:  DECF   xB8,F
683C:  ADDWF  xB9,F
683E:  BNC   683A
6840:  DECF   xB7,F
6842:  ADDWF  xB8,F
6844:  BNC   6840
6846:  DECF   xB6,F
6848:  ADDWF  xB7,F
684A:  BNC   6846
684C:  MOVLW  03
684E:  MOVWF  FEA
6850:  MOVLW  B6
6852:  MOVWF  FE9
6854:  MOVLW  07
6856:  ANDWF  xBB,W
6858:  BCF    xBB.6
685A:  ADDWF  FE9,F
685C:  MOVLW  BA
685E:  SUBWF  FE9,W
6860:  BTFSC  FD8.2
6862:  BSF    xBB.6
6864:  MOVF   FEF,W
6866:  MOVWF  00
6868:  BNZ   687A
686A:  BTFSC  xBB.6
686C:  BRA    687A
686E:  BTFSC  xBB.4
6870:  BRA    689E
6872:  BTFSC  xBB.3
6874:  BRA    687A
6876:  MOVLW  20
6878:  BRA    6880
687A:  BSF    xBB.3
687C:  BCF    xBB.4
687E:  MOVLW  30
6880:  ADDWF  00,F
6882:  MOVFF  FEA,3B5
6886:  MOVFF  FE9,3B4
688A:  MOVFF  00,3BD
688E:  MOVLB  0
6890:  CALL   2436
6894:  MOVFF  3B5,FEA
6898:  MOVFF  3B4,FE9
689C:  MOVLB  3
689E:  MOVF   FEE,W
68A0:  BTFSS  xBB.6
68A2:  BRA    685C
68A4:  MOVLB  0
68A6:  RETURN 0
*
6CF6:  MOVFF  FF2,0D
6CFA:  BCF    FF2.7
6CFC:  ADDWF  FE8,W
6CFE:  CLRF   FF7
6D00:  RLCF   FF7,F
6D02:  ADDLW  1B
6D04:  MOVWF  FF6
6D06:  MOVLW  6D
6D08:  ADDWFC FF7,F
6D0A:  TBLRD*-
6D0C:  MOVF   FF5,W
6D0E:  MOVWF  FFA
6D10:  TBLRD*
6D12:  MOVF   FF5,W
6D14:  BTFSC  0D.7
6D16:  BSF    FF2.7
6D18:  MOVWF  FF9
6D1A:  DATA CC,6A
6D1C:  DATA 0C,6B
6D1E:  DATA F2,6C
6D20:  DATA F2,6C
6D22:  DATA AA,6C
6D24:  DATA 38,6B
*
7C78:  MOVFF  FF2,0D
7C7C:  BCF    FF2.7
7C7E:  ADDWF  FE8,W
7C80:  CLRF   FF7
7C82:  RLCF   FF7,F
7C84:  ADDLW  9D
7C86:  MOVWF  FF6
7C88:  MOVLW  7C
7C8A:  ADDWFC FF7,F
7C8C:  TBLRD*-
7C8E:  MOVF   FF5,W
7C90:  MOVWF  FFA
7C92:  TBLRD*
7C94:  MOVF   FF5,W
7C96:  BTFSC  0D.7
7C98:  BSF    FF2.7
7C9A:  MOVWF  FF9
7C9C:  DATA 0C,72
7C9E:  DATA 38,73
7CA0:  DATA 82,75
7CA2:  DATA 94,78
*
844E:  MOVFF  FF2,0D
8452:  BCF    FF2.7
8454:  ADDWF  FE8,W
8456:  CLRF   FF7
8458:  RLCF   FF7,F
845A:  ADDLW  73
845C:  MOVWF  FF6
845E:  MOVLW  84
8460:  ADDWFC FF7,F
8462:  TBLRD*-
8464:  MOVF   FF5,W
8466:  MOVWF  FFA
8468:  TBLRD*
846A:  MOVF   FF5,W
846C:  BTFSC  0D.7
846E:  BSF    FF2.7
8470:  MOVWF  FF9
8472:  DATA 28,83
8474:  DATA 82,80
8476:  DATA 2E,82
8478:  DATA 58,81
847A:  DATA DE,80
847C:  DATA A4,82
847E:  DATA B4,81
8480:  DATA 4A,84
8482:  DATA FC,82
8484:  DATA 4A,84
8486:  DATA 54,83
8488:  DATA 40,7F
848A:  DATA 4A,84
848C:  DATA F0,7F
848E:  DATA B8,7C
8490:  DATA 6A,7D
8492:  DATA FC,7D
8494:  DATA 8E,7E
8496:  DATA F0,83
8498:  DATA 20,84
*
8F00:  MOVFF  FF2,0D
8F04:  BCF    FF2.7
8F06:  ADDWF  FE8,W
8F08:  CLRF   FF7
8F0A:  RLCF   FF7,F
8F0C:  ADDLW  25
8F0E:  MOVWF  FF6
8F10:  MOVLW  8F
8F12:  ADDWFC FF7,F
8F14:  TBLRD*-
8F16:  MOVF   FF5,W
8F18:  MOVWF  FFA
8F1A:  TBLRD*
8F1C:  MOVF   FF5,W
8F1E:  BTFSC  0D.7
8F20:  BSF    FF2.7
8F22:  MOVWF  FF9
8F24:  DATA F4,8D
8F26:  DATA 5C,8E
8F28:  DATA FC,8E
8F2A:  DATA FC,8E
8F2C:  DATA D0,8E
8F2E:  DATA E0,8E
8F30:  DATA C4,8E
8F32:  DATA FC,8E
8F34:  DATA F0,8E
*
90BA:  MOVFF  FF2,0D
90BE:  BCF    FF2.7
90C0:  ADDWF  FE8,W
90C2:  CLRF   FF7
90C4:  RLCF   FF7,F
90C6:  ADDLW  DF
90C8:  MOVWF  FF6
90CA:  MOVLW  90
90CC:  ADDWFC FF7,F
90CE:  TBLRD*-
90D0:  MOVF   FF5,W
90D2:  MOVWF  FFA
90D4:  TBLRD*
90D6:  MOVF   FF5,W
90D8:  BTFSC  0D.7
90DA:  BSF    FF2.7
90DC:  MOVWF  FF9
90DE:  DATA A4,8F
90E0:  DATA 08,90
90E2:  DATA B6,90
90E4:  DATA B6,90
90E6:  DATA 8A,90
90E8:  DATA 9A,90
90EA:  DATA 70,90
90EC:  DATA 7C,90
90EE:  DATA AA,90
*
9326:  MOVFF  FF2,0D
932A:  BCF    FF2.7
932C:  ADDWF  FE8,W
932E:  CLRF   FF7
9330:  RLCF   FF7,F
9332:  ADDLW  4B
9334:  MOVWF  FF6
9336:  MOVLW  93
9338:  ADDWFC FF7,F
933A:  TBLRD*-
933C:  MOVF   FF5,W
933E:  MOVWF  FFA
9340:  TBLRD*
9342:  MOVF   FF5,W
9344:  BTFSC  0D.7
9346:  BSF    FF2.7
9348:  MOVWF  FF9
934A:  DATA E2,91
934C:  DATA 60,92
934E:  DATA 22,93
9350:  DATA 22,93
9352:  DATA F6,92
9354:  DATA 06,93
9356:  DATA DE,92
9358:  DATA EA,92
935A:  DATA 16,93
*
9548:  MOVFF  FF2,0D
954C:  BCF    FF2.7
954E:  ADDWF  FE8,W
9550:  CLRF   FF7
9552:  RLCF   FF7,F
9554:  ADDLW  6D
9556:  MOVWF  FF6
9558:  MOVLW  95
955A:  ADDWFC FF7,F
955C:  TBLRD*-
955E:  MOVF   FF5,W
9560:  MOVWF  FFA
9562:  TBLRD*
9564:  MOVF   FF5,W
9566:  BTFSC  0D.7
9568:  BSF    FF2.7
956A:  MOVWF  FF9
956C:  DATA 1C,95
956E:  DATA 44,95
9570:  DATA 44,95
9572:  DATA 44,95
9574:  DATA 44,95
9576:  DATA 44,95
9578:  DATA 44,95
957A:  DATA 44,95
957C:  DATA 00,95
957E:  DATA 44,95
9580:  DATA 44,95
9582:  DATA 7A,94
9584:  DATA 44,95
9586:  DATA BA,94
9588:  DATA 6E,93
958A:  DATA B4,93
958C:  DATA F4,93
958E:  DATA 34,94
9590:  DATA 34,95
*
A22E:  MOVFF  FF2,0D
A232:  BCF    FF2.7
A234:  ADDWF  FE8,W
A236:  CLRF   FF7
A238:  RLCF   FF7,F
A23A:  ADDLW  53
A23C:  MOVWF  FF6
A23E:  MOVLW  A2
A240:  ADDWFC FF7,F
A242:  TBLRD*-
A244:  MOVF   FF5,W
A246:  MOVWF  FFA
A248:  TBLRD*
A24A:  MOVF   FF5,W
A24C:  BTFSC  0D.7
A24E:  BSF    FF2.7
A250:  MOVWF  FF9
A252:  DATA F0,96
A254:  DATA 5A,98
A256:  DATA FA,9A
A258:  DATA 4A,9E
*
A620:  MOVFF  FF2,0D
A624:  BCF    FF2.7
A626:  ADDWF  FE8,W
A628:  CLRF   FF7
A62A:  RLCF   FF7,F
A62C:  ADDLW  45
A62E:  MOVWF  FF6
A630:  MOVLW  A6
A632:  ADDWFC FF7,F
A634:  TBLRD*-
A636:  MOVF   FF5,W
A638:  MOVWF  FFA
A63A:  TBLRD*
A63C:  MOVF   FF5,W
A63E:  BTFSC  0D.7
A640:  BSF    FF2.7
A642:  MOVWF  FF9
A644:  DATA 80,A3
A646:  DATA 98,A3
A648:  DATA 06,A4
A64A:  DATA 70,A4
A64C:  DATA 90,A4
A64E:  DATA B0,A4
A650:  DATA F8,A4
A652:  DATA 18,A5
A654:  DATA 38,A5
A656:  DATA 52,A5
A658:  DATA 72,A5
A65A:  DATA A0,A5
A65C:  DATA CE,A5
A65E:  DATA EE,A5
*
A9F2:  MOVFF  FF2,0D
A9F6:  BCF    FF2.7
A9F8:  ADDWF  FE8,W
A9FA:  CLRF   FF7
A9FC:  RLCF   FF7,F
A9FE:  ADDLW  17
AA00:  MOVWF  FF6
AA02:  MOVLW  AA
AA04:  ADDWFC FF7,F
AA06:  TBLRD*-
AA08:  MOVF   FF5,W
AA0A:  MOVWF  FFA
AA0C:  TBLRD*
AA0E:  MOVF   FF5,W
AA10:  BTFSC  0D.7
AA12:  BSF    FF2.7
AA14:  MOVWF  FF9
AA16:  DATA 5C,A9
AA18:  DATA 64,A9
AA1A:  DATA 7C,A9
AA1C:  DATA A4,A9
AA1E:  DATA AC,A9
AA20:  DATA B4,A9
AA22:  DATA BC,A9
AA24:  DATA 6C,A9
AA26:  DATA C4,A9
AA28:  DATA CC,A9
AA2A:  DATA D4,A9
AA2C:  DATA DC,A9
AA2E:  DATA E4,A9
AA30:  DATA 74,A9
AA32:  DATA 9C,A9
AA34:  DATA 8C,A9
AA36:  DATA 94,A9
AA38:  DATA 84,A9
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "main.h" 
.................... #fuses HS,NOWDT,PROTECT,NOLVP,NODEBUG,MCLR 
.................... #use delay(clock=20000000) 
*
2064:  MOVLW  03
2066:  MOVWF  FEA
2068:  MOVLW  BE
206A:  MOVWF  FE9
206C:  MOVF   FEF,W
206E:  BZ    208A
2070:  MOVLW  06
2072:  MOVWF  01
2074:  CLRF   00
2076:  DECFSZ 00,F
2078:  BRA    2076
207A:  DECFSZ 01,F
207C:  BRA    2074
207E:  MOVLW  7B
2080:  MOVWF  00
2082:  DECFSZ 00,F
2084:  BRA    2082
2086:  DECFSZ FEF,F
2088:  BRA    2070
208A:  RETURN 0
*
597E:  MOVLW  03
5980:  MOVLB  3
5982:  SUBWF  xB3,F
5984:  BNC   599A
5986:  MOVLW  03
5988:  MOVWF  FEA
598A:  MOVLW  B3
598C:  MOVWF  FE9
598E:  MOVF   FEF,W
5990:  BZ    599A
5992:  BRA    5996
5994:  BRA    5996
5996:  DECFSZ FEF,F
5998:  BRA    5994
599A:  MOVLB  0
599C:  GOTO   5A04 (RETURN)
.................... #use i2c(master,sda = pin_C4,scl = pin_C3,force_hw) 
*
2012:  BCF    FC6.7
2014:  BCF    F9E.3
2016:  MOVFF  3C6,FC9
201A:  MOVLW  02
201C:  BTFSC  FC6.7
201E:  BRA    202A
2020:  BTFSS  F9E.3
2022:  BRA    2020
2024:  MOVLW  00
2026:  BTFSC  FC5.6
2028:  MOVLW  01
202A:  MOVWF  01
202C:  RETURN 0
*
2310:  BCF    FC6.6
2312:  BSF    FC5.3
2314:  BTFSC  FC5.3
2316:  BRA    2314
2318:  BTFSC  00.0
231A:  BCF    FC5.5
231C:  BTFSS  00.0
231E:  BSF    FC5.5
2320:  BSF    FC5.4
2322:  BTFSC  FC5.4
2324:  BRA    2322
2326:  MOVFF  FC9,01
232A:  RETURN 0
....................  
.................... #use 		standard_io(a) 
.................... #use 		standard_io(b) 
.................... #use 		standard_io(c) 
.................... #use 		standard_io(d) 
.................... #use 		standard_io(e) 
....................  
....................  
.................... #DEFINE   	RS    pin_B5			 
.................... #DEFINE	  	E	  pin_A0 
....................  
....................  
.................... #DEFINE		EEPROM_SCL	    	pin_C3 
.................... #DEFINE 	EEPROM_SDA		    pin_C4 
....................  
....................  
.................... #DEFINE     in24_bit			pin_B0 
.................... #DEFINE     in25_bit			pin_B1 
.................... #DEFINE     in26_bit			pin_B3 
.................... #DEFINE     in27_bit			pin_B4 
....................  
.................... #DEFINE     H0					pin_D7 
.................... #DEFINE     H1					pin_D6 
.................... #DEFINE     H2					pin_D5 
.................... #DEFINE     H3					pin_D4 
.................... #DEFINE     H4					pin_C7	 
.................... #DEFINE     H5					pin_C6 
....................  
.................... #DEFINE ALIMENTADOR        0 // 000          
.................... #DEFINE HOME1              1 // 001 
.................... #DEFINE SOLDAGEM           3 // 010 
.................... #DEFINE HOME2              4 // 011 
.................... #DEFINE DISPENSADOR        5 // 100 
.................... #DEFINE LIMPEZA            6 // 101 
.................... #DEFINE LIMPEZA_2          7 // 110 
.................... #DEFINE POSICAO_8          8 // 111 
....................  
.................... #define ramp_idle 0 
.................... #define ramp_up   1 
.................... #define ramp_max  2 
.................... #define ramp_down 3 
.................... #define ramp_last 4 
....................  
.................... #DEFINE velocidade_motor        2500 
.................... #DEFINE     LED                 0 
.................... #DEFINE     PONTO               1 
.................... #DEFINE     MOLA                2 
....................  
.................... int menu_atual = 0; 
.................... short int entradas[27]; 
....................  
.................... int ponteiro_lcd = 1; 
.................... int inicial_lcd = 0; 
.................... int final_lcd = 3; 
.................... int contador_lcd = 0; 
....................  
.................... int posicao_atual; 
.................... int posicao_futura; 
.................... int posicao_outra_maquina; 
.................... int32 ciclo; 
.................... short run_ok = 1; 
.................... short exit = 1; 
....................  
.................... void grava_coordenada_na_eeprom(int passo,long int coordenada_x,long int coordenada_y,long int coordenada_z); 
.................... void pega_data_eeprom(int passo); 
....................  
.................... int modelo = 1; 
.................... long int x[20]; 
.................... long int y[20]; 
.................... long int z[20]; 
.................... long int t_solda[20]; 
.................... long int t_wait[20]; 
.................... int tipo[20]; 
.................... int pontos_no_modelo; 
.................... short int habilitado[20]; 
....................  
.................... #include "pcf8574.c" 
.................... short int ack; 
.................... int	lcdcoluna = 1; 
.................... int	lcdlinha  = 1; 
....................  
.................... void escreve_pcf8574(int dispositivo,int data) { 
....................    i2c_start(); 
*
202E:  BSF    FC5.0
2030:  BTFSC  FC5.0
2032:  BRA    2030
....................    ack=i2c_write(0x40 |(dispositivo << 1)); 
2034:  BCF    FD8.0
2036:  MOVLB  3
2038:  RLCF   xC3,W
203A:  IORLW  40
203C:  MOVWF  xC5
203E:  MOVWF  xC6
2040:  MOVLB  0
2042:  RCALL  2012
2044:  MOVF   01,W
2046:  BCF    2C.2
2048:  BTFSC  01.0
204A:  BSF    2C.2
....................    ack=i2c_write(data); 
204C:  MOVFF  3C4,3C6
2050:  RCALL  2012
2052:  MOVF   01,W
2054:  BCF    2C.2
2056:  BTFSC  01.0
2058:  BSF    2C.2
....................    i2c_stop(); 
205A:  BSF    FC5.2
205C:  BTFSC  FC5.2
205E:  BRA    205C
....................    ack=!ack; 
2060:  BTG    2C.2
2062:  RETURN 0
.................... } 
....................  
.................... int le_pcf8574(int dispositivo) { 
....................     int data; 
....................     i2c_start(); 
....................     i2c_write(0x41 |(dispositivo << 1)); 
....................     data=i2c_read(0); 
....................     i2c_stop(); 
....................     ack=!ack; 
....................     return(data); 
.................... } 
....................  
.................... int le_pcf8574A(int dispositivo) { 
....................     int data; 
....................     i2c_start(); 
*
405A:  BSF    FC5.0
405C:  BTFSC  FC5.0
405E:  BRA    405C
....................     i2c_write(0x71 |(dispositivo << 1)); 
4060:  BCF    FD8.0
4062:  MOVLB  3
4064:  RLCF   xB7,W
4066:  IORLW  71
4068:  MOVWF  xB9
406A:  MOVWF  xC6
406C:  MOVLB  0
406E:  CALL   2012
....................     data=i2c_read(0); 
4072:  CLRF   00
4074:  CALL   2310
4078:  MOVFF  01,3B8
....................     i2c_stop(); 
407C:  BSF    FC5.2
407E:  BTFSC  FC5.2
4080:  BRA    407E
....................     ack=!ack; 
4082:  BTG    2C.2
.................... 	return(data); 
4084:  MOVLB  3
4086:  MOVFF  3B8,01
408A:  MOVLB  0
408C:  GOTO   4126 (RETURN)
.................... } 
....................  
....................  
.................... #include "pca9555.c" 
.................... void escreve_PCA9555(int dispositivo,int comando,int data1,int data2) { 
....................    i2c_start(); 
*
213C:  BSF    FC5.0
213E:  BTFSC  FC5.0
2140:  BRA    213E
....................    ack=i2c_write(0x40 |(dispositivo << 1)); 
2142:  BCF    FD8.0
2144:  MOVLB  3
2146:  RLCF   xBB,W
2148:  IORLW  40
214A:  MOVWF  xBF
214C:  MOVWF  xC6
214E:  MOVLB  0
2150:  RCALL  2012
2152:  MOVF   01,W
2154:  BCF    2C.2
2156:  BTFSC  01.0
2158:  BSF    2C.2
....................    ack=i2c_write(comando); 
215A:  MOVFF  3BC,3C6
215E:  RCALL  2012
2160:  MOVF   01,W
2162:  BCF    2C.2
2164:  BTFSC  01.0
2166:  BSF    2C.2
....................    ack=i2c_write(data2); 
2168:  MOVFF  3BE,3C6
216C:  RCALL  2012
216E:  MOVF   01,W
2170:  BCF    2C.2
2172:  BTFSC  01.0
2174:  BSF    2C.2
....................    ack=i2c_write(data1); 
2176:  MOVFF  3BD,3C6
217A:  RCALL  2012
217C:  MOVF   01,W
217E:  BCF    2C.2
2180:  BTFSC  01.0
2182:  BSF    2C.2
....................    i2c_stop(); 
2184:  BSF    FC5.2
2186:  BTFSC  FC5.2
2188:  BRA    2186
....................    ack=!ack; 
218A:  BTG    2C.2
218C:  RETURN 0
.................... }   
....................  
.................... unsigned long  int le_PCA9555(int dispositivo,int comando) {     
*
3FD2:  MOVLB  3
3FD4:  CLRF   xBB
3FD6:  CLRF   xBA
3FD8:  CLRF   xBC
....................    unsigned long int data1 = 0x0000;  
....................    int data2= 0x00; 
....................    i2c_start(); 	 
3FDA:  BSF    FC5.0
3FDC:  BTFSC  FC5.0
3FDE:  BRA    3FDC
....................    ack=i2c_write(0x40 |(dispositivo << 1));  
3FE0:  BCF    FD8.0
3FE2:  RLCF   xB8,W
3FE4:  IORLW  40
3FE6:  MOVWF  xBD
3FE8:  MOVWF  xC6
3FEA:  MOVLB  0
3FEC:  CALL   2012
3FF0:  MOVF   01,W
3FF2:  BCF    2C.2
3FF4:  BTFSC  01.0
3FF6:  BSF    2C.2
....................    ack=i2c_write(comando); 
3FF8:  MOVFF  3B9,3C6
3FFC:  CALL   2012
4000:  MOVF   01,W
4002:  BCF    2C.2
4004:  BTFSC  01.0
4006:  BSF    2C.2
....................    i2c_start(); 
4008:  BSF    FC5.1
400A:  BTFSC  FC5.1
400C:  BRA    400A
....................    ack=i2c_write(0x41 |(dispositivo << 1)); 
400E:  BCF    FD8.0
4010:  MOVLB  3
4012:  RLCF   xB8,W
4014:  IORLW  41
4016:  MOVWF  xBD
4018:  MOVWF  xC6
401A:  MOVLB  0
401C:  CALL   2012
4020:  MOVF   01,W
4022:  BCF    2C.2
4024:  BTFSC  01.0
4026:  BSF    2C.2
....................    data2=i2c_read(1);            // acknoledgment 
4028:  MOVLW  01
402A:  MOVWF  00
402C:  CALL   2310
4030:  MOVFF  01,3BC
....................    data1=i2c_read(0) << 8;      // no  acknoledgment 
4034:  CLRF   00
4036:  CALL   2310
403A:  MOVFF  01,3BB
403E:  MOVLB  3
4040:  CLRF   xBA
....................    i2c_stop(); 
4042:  BSF    FC5.2
4044:  BTFSC  FC5.2
4046:  BRA    4044
....................    ack=!ack; 
4048:  BTG    2C.2
....................    data1|=data2; 
404A:  MOVF   xBC,W
404C:  IORWF  xBA,F
....................    return(data1); 
404E:  MOVFF  3BA,01
4052:  MOVFF  3BB,02
4056:  MOVLB  0
4058:  RETURN 0
.................... }     
....................  
.................... #include "display_maq.c"  
.................... void write (char dado){ 
.................... 	delay_us(30); 
*
208C:  MOVLW  31
208E:  MOVWF  00
2090:  DECFSZ 00,F
2092:  BRA    2090
2094:  BRA    2096
.................... 	escreve_pcf8574(0x00,dado); 
2096:  MOVLB  3
2098:  CLRF   xC3
209A:  MOVFF  3C2,3C4
209E:  MOVLB  0
20A0:  RCALL  202E
.................... 	delay_us(30); 
20A2:  MOVLW  31
20A4:  MOVWF  00
20A6:  DECFSZ 00,F
20A8:  BRA    20A6
20AA:  BRA    20AC
.................... 	output_high (E); 
20AC:  BCF    F92.0
20AE:  BSF    F89.0
.................... 	delay_us(30); 
20B0:  MOVLW  31
20B2:  MOVWF  00
20B4:  DECFSZ 00,F
20B6:  BRA    20B4
20B8:  BRA    20BA
.................... 	output_low  (E) ; 
20BA:  BCF    F92.0
20BC:  BCF    F89.0
.................... 	delay_us(30); 
20BE:  MOVLW  31
20C0:  MOVWF  00
20C2:  DECFSZ 00,F
20C4:  BRA    20C2
20C6:  BRA    20C8
20C8:  RETURN 0
.................... } 
.................... void displayprog (int valor) { 
.................... 	output_low (RS); 
20CA:  BCF    F93.5
20CC:  BCF    F8A.5
.................... 	write (valor); 
20CE:  MOVFF  3C1,3C2
20D2:  RCALL  208C
20D4:  RETURN 0
.................... } 
.................... void limpa_display (void){ 
....................  	displayprog (0x1); 
*
227A:  MOVLW  01
227C:  MOVLB  3
227E:  MOVWF  xC1
2280:  MOVLB  0
2282:  RCALL  20CA
.................... 	delay_ms(5); 
2284:  MOVLW  05
2286:  MOVLB  3
2288:  MOVWF  xBE
228A:  MOVLB  0
228C:  RCALL  2064
228E:  RETURN 0
.................... } 
.................... void inicializa_display(void){ 
....................     escreve_pcf8574(0x00,0Xff); //;output_b(0xff);				//	porta_display (0XFF); 
*
20D6:  MOVLB  3
20D8:  CLRF   xC3
20DA:  SETF   xC4
20DC:  MOVLB  0
20DE:  RCALL  202E
.................... 	output_low(E); 
20E0:  BCF    F92.0
20E2:  BCF    F89.0
.................... 	output_high(RS); 
20E4:  BCF    F93.5
20E6:  BSF    F8A.5
.................... 	delay_ms(15); 
20E8:  MOVLW  0F
20EA:  MOVLB  3
20EC:  MOVWF  xBE
20EE:  MOVLB  0
20F0:  RCALL  2064
.................... 	displayprog(0x38);      // 2 linha / 5x7 /8 bit 
20F2:  MOVLW  38
20F4:  MOVLB  3
20F6:  MOVWF  xC1
20F8:  MOVLB  0
20FA:  RCALL  20CA
.................... 	delay_ms(15); 
20FC:  MOVLW  0F
20FE:  MOVLB  3
2100:  MOVWF  xBE
2102:  MOVLB  0
2104:  RCALL  2064
.................... 	displayprog(0x0c);		// display aceso s/ cursor 
2106:  MOVLW  0C
2108:  MOVLB  3
210A:  MOVWF  xC1
210C:  MOVLB  0
210E:  RCALL  20CA
.................... 	delay_ms(15); 
2110:  MOVLW  0F
2112:  MOVLB  3
2114:  MOVWF  xBE
2116:  MOVLB  0
2118:  RCALL  2064
.................... 	displayprog(0x06);      // escreve deslocando o cursor para direita 
211A:  MOVLW  06
211C:  MOVLB  3
211E:  MOVWF  xC1
2120:  MOVLB  0
2122:  RCALL  20CA
.................... 	delay_ms(15); 
2124:  MOVLW  0F
2126:  MOVLB  3
2128:  MOVWF  xBE
212A:  MOVLB  0
212C:  RCALL  2064
.................... 	lcdcoluna = 1; 
212E:  MOVLW  01
2130:  MOVLB  1
2132:  MOVWF  x0E
.................... 	lcdlinha = 1; 
2134:  MOVWF  x0F
2136:  MOVLB  0
2138:  GOTO   A8C8 (RETURN)
.................... } 
.................... void posiciona_cursor (int linha,int coluna){ 
.................... 	lcdcoluna = coluna; 
*
2290:  MOVFF  3BF,10E
.................... 	lcdlinha  = linha; 
2294:  MOVFF  3BE,10F
.................... 	int	x; 
.................... 	if (linha == 1)	x=(0x00 + coluna) - 1; 
2298:  MOVLB  3
229A:  DECFSZ xBE,W
229C:  BRA    22A4
229E:  MOVLW  01
22A0:  SUBWF  xBF,W
22A2:  MOVWF  xC0
.................... 	if (linha == 2) x=(0x40 + coluna) - 1;  
22A4:  MOVF   xBE,W
22A6:  SUBLW  02
22A8:  BNZ   22B2
22AA:  MOVLW  40
22AC:  ADDWF  xBF,W
22AE:  ADDLW  FF
22B0:  MOVWF  xC0
....................     if (linha == 3) x=(0x14 + coluna) - 1; 
22B2:  MOVF   xBE,W
22B4:  SUBLW  03
22B6:  BNZ   22C0
22B8:  MOVLW  14
22BA:  ADDWF  xBF,W
22BC:  ADDLW  FF
22BE:  MOVWF  xC0
.................... 	if (linha == 4) x=(0x54 + coluna) - 1; 
22C0:  MOVF   xBE,W
22C2:  SUBLW  04
22C4:  BNZ   22CE
22C6:  MOVLW  54
22C8:  ADDWF  xBF,W
22CA:  ADDLW  FF
22CC:  MOVWF  xC0
.................... 	x =x | 0x80; 
22CE:  BSF    xC0.7
.................... 	displayprog (x); 
22D0:  MOVFF  3C0,3C1
22D4:  MOVLB  0
22D6:  RCALL  20CA
.................... 	delay_us(100); 
22D8:  MOVLW  A6
22DA:  MOVWF  00
22DC:  DECFSZ 00,F
22DE:  BRA    22DC
22E0:  NOP   
22E2:  RETURN 0
.................... } 
.................... void display (char  c){ 
.................... 	output_high (RS); 
22E4:  BCF    F93.5
22E6:  BSF    F8A.5
.................... 	write (c); 
22E8:  MOVFF  3BE,3C2
22EC:  RCALL  208C
22EE:  RETURN 0
.................... } 
.................... void lcd_putc(char c) { 
.................... 	// \n nova linha muda o cursor para uma linha abaixo 
....................     // \r retorno 
....................     // \f limpa display 
....................  
....................  
....................    switch (c) { 
*
2436:  MOVLB  3
2438:  MOVF   xBD,W
243A:  XORLW  0C
243C:  MOVLB  0
243E:  BZ    244A
2440:  XORLW  06
2442:  BZ    2456
2444:  XORLW  07
2446:  BZ    246A
2448:  BRA    247E
....................      case '\f'   : limpa_display(); 
244A:  RCALL  227A
....................                    lcdlinha = 1; 
244C:  MOVLW  01
244E:  MOVLB  1
2450:  MOVWF  x0F
.................... 				   lcdcoluna= 1; 
2452:  MOVWF  x0E
....................                    break; 
2454:  BRA    2486
....................  
....................      case '\n'   : posiciona_cursor(++lcdlinha,lcdcoluna);  
2456:  MOVLB  1
2458:  INCF   x0F,F
245A:  MOVFF  10F,3BE
245E:  MOVFF  10E,3BF
2462:  MOVLB  0
2464:  RCALL  2290
.................... 			       break; 
2466:  MOVLB  1
2468:  BRA    2486
....................  
....................      case '\r'   : posiciona_cursor(lcdlinha,1);  
246A:  MOVFF  10F,3BE
246E:  MOVLW  01
2470:  MOVLB  3
2472:  MOVWF  xBF
2474:  MOVLB  0
2476:  RCALL  2290
....................                    break; 
2478:  MOVLB  1
247A:  BRA    2486
247C:  MOVLB  0
....................  
....................      default     : display(c);   
247E:  MOVFF  3BD,3BE
2482:  RCALL  22E4
....................                    break; 
2484:  MOVLB  1
....................    } 
2486:  MOVLB  0
2488:  RETURN 0
.................... } 
.................... void Show_String(char matriz[]) { 
.................... 	int result; 
.................... 	int	a; 
.................... 	char x1[21]; 
.................... 	strcpy (x1,matriz); 
.................... 	result = strlen(x1); 
.................... 	for (a=0;a < result;a++){ 
....................         display(x1[a]); 
....................     } 
.................... } 
....................  
.................... #include "24c64.c" 
.................... void write_ext_eeprom(long int address,int data) { 
....................  
....................    disable_interrupts(GLOBAL); 
*
220E:  BCF    FF2.6
2210:  BCF    FF2.7
2212:  BTFSC  FF2.7
2214:  BRA    2210
....................    i2c_start(); 
2216:  BSF    FC5.0
2218:  BTFSC  FC5.0
221A:  BRA    2218
....................    ack=i2c_write(0xa0); 
221C:  MOVLW  A0
221E:  MOVLB  3
2220:  MOVWF  xC6
2222:  MOVLB  0
2224:  RCALL  2012
2226:  MOVF   01,W
2228:  BCF    2C.2
222A:  BTFSC  01.0
222C:  BSF    2C.2
....................    ack=i2c_write(address >> 8); 
222E:  MOVFF  3B6,3B8
2232:  MOVLB  3
2234:  CLRF   xB9
2236:  MOVFF  3B6,3C6
223A:  MOVLB  0
223C:  RCALL  2012
223E:  MOVF   01,W
2240:  BCF    2C.2
2242:  BTFSC  01.0
2244:  BSF    2C.2
....................    ack=i2c_write(address); 
2246:  MOVFF  3B5,3C6
224A:  RCALL  2012
224C:  MOVF   01,W
224E:  BCF    2C.2
2250:  BTFSC  01.0
2252:  BSF    2C.2
....................    ack=i2c_write(data); 
2254:  MOVFF  3B7,3C6
2258:  RCALL  2012
225A:  MOVF   01,W
225C:  BCF    2C.2
225E:  BTFSC  01.0
2260:  BSF    2C.2
....................    i2c_stop(); 
2262:  BSF    FC5.2
2264:  BTFSC  FC5.2
2266:  BRA    2264
....................    ack=!ack; 
2268:  BTG    2C.2
....................    delay_ms(5); 
226A:  MOVLW  05
226C:  MOVLB  3
226E:  MOVWF  xBE
2270:  MOVLB  0
2272:  RCALL  2064
....................    enable_interrupts(GLOBAL); 
2274:  MOVLW  C0
2276:  IORWF  FF2,F
2278:  RETURN 0
....................  
.................... } 
.................... int read_ext_eeprom(long int address) { 
....................    int data; 
....................  
....................    disable_interrupts(GLOBAL); 
*
232C:  BCF    FF2.6
232E:  BCF    FF2.7
2330:  BTFSC  FF2.7
2332:  BRA    232E
....................    i2c_start(); 
2334:  BSF    FC5.0
2336:  BTFSC  FC5.0
2338:  BRA    2336
....................    i2c_write(0xa0); 
233A:  MOVLW  A0
233C:  MOVLB  3
233E:  MOVWF  xC6
2340:  MOVLB  0
2342:  RCALL  2012
....................    i2c_write(address >> 8); 
2344:  MOVFF  3B8,3BA
2348:  MOVLB  3
234A:  CLRF   xBB
234C:  MOVFF  3B8,3C6
2350:  MOVLB  0
2352:  RCALL  2012
....................    i2c_write(address); 
2354:  MOVFF  3B7,3C6
2358:  RCALL  2012
....................    i2c_start(); 
235A:  BSF    FC5.1
235C:  BTFSC  FC5.1
235E:  BRA    235C
....................    i2c_write(0xa1); 
2360:  MOVLW  A1
2362:  MOVLB  3
2364:  MOVWF  xC6
2366:  MOVLB  0
2368:  RCALL  2012
....................    data=i2c_read(0); 
236A:  CLRF   00
236C:  RCALL  2310
236E:  MOVFF  01,3B9
....................    i2c_stop(); 
2372:  BSF    FC5.2
2374:  BTFSC  FC5.2
2376:  BRA    2374
....................    ack=!ack; 
2378:  BTG    2C.2
....................    delay_ms(5); 
237A:  MOVLW  05
237C:  MOVLB  3
237E:  MOVWF  xBE
2380:  MOVLB  0
2382:  RCALL  2064
....................    enable_interrupts(GLOBAL); 
2384:  MOVLW  C0
2386:  IORWF  FF2,F
....................  
....................    return(data); 
2388:  MOVLB  3
238A:  MOVFF  3B9,01
238E:  MOVLB  0
2390:  RETURN 0
....................  
.................... } 
.................... void init_ext_eeprom() { 
.................... 	int a; 
....................  
....................     output_float(EEPROM_SCL); 
2392:  BSF    F94.3
....................     output_float(EEPROM_SDA); 
2394:  BSF    F94.4
....................  
.................... 	write_ext_eeprom(0x00ff,0xAA); 
2396:  MOVLB  3
2398:  CLRF   xB6
239A:  SETF   xB5
239C:  MOVLW  AA
239E:  MOVWF  xB7
23A0:  MOVLB  0
23A2:  RCALL  220E
.................... 	if (ack == false) 
23A4:  BTFSC  2C.2
23A6:  BRA    23DA
.................... 	{ 
.................... 	limpa_display(); 
23A8:  RCALL  227A
.................... 	posiciona_cursor(1,1); 
23AA:  MOVLW  01
23AC:  MOVLB  3
23AE:  MOVWF  xBE
23B0:  MOVWF  xBF
23B2:  MOVLB  0
23B4:  RCALL  2290
.................... 	display("erro de escrita "); 
23B6:  MOVLW  BA
23B8:  MOVWF  FF6
23BA:  MOVLW  00
23BC:  MOVWF  FF7
23BE:  RCALL  22F0
.................... 	posiciona_cursor(2,1); 
23C0:  MOVLW  02
23C2:  MOVLB  3
23C4:  MOVWF  xBE
23C6:  MOVLW  01
23C8:  MOVWF  xBF
23CA:  MOVLB  0
23CC:  RCALL  2290
.................... 	display("   EEPROM       "); 
23CE:  MOVLW  CC
23D0:  MOVWF  FF6
23D2:  MOVLW  00
23D4:  MOVWF  FF7
23D6:  RCALL  22F0
.................... 	while(true){} 
23D8:  BRA    23D8
.................... 	} 
.................... 	 
.................... 	delay_ms(5);	 
23DA:  MOVLW  05
23DC:  MOVLB  3
23DE:  MOVWF  xBE
23E0:  MOVLB  0
23E2:  RCALL  2064
....................  
.................... 	a = read_ext_eeprom(0x00ff); 
23E4:  MOVLB  3
23E6:  CLRF   xB8
23E8:  SETF   xB7
23EA:  MOVLB  0
23EC:  RCALL  232C
23EE:  MOVFF  01,3AD
.................... 	if (a != 0xAA) 
23F2:  MOVLB  3
23F4:  MOVF   xAD,W
23F6:  SUBLW  AA
23F8:  BZ    2430
.................... 	{ 
.................... 	limpa_display(); 
23FA:  MOVLB  0
23FC:  RCALL  227A
.................... 	posiciona_cursor(1,1); 
23FE:  MOVLW  01
2400:  MOVLB  3
2402:  MOVWF  xBE
2404:  MOVWF  xBF
2406:  MOVLB  0
2408:  RCALL  2290
.................... 	display("erro de leitura  "); 
240A:  MOVLW  DE
240C:  MOVWF  FF6
240E:  MOVLW  00
2410:  MOVWF  FF7
2412:  RCALL  22F0
.................... 	posiciona_cursor(2,1); 
2414:  MOVLW  02
2416:  MOVLB  3
2418:  MOVWF  xBE
241A:  MOVLW  01
241C:  MOVWF  xBF
241E:  MOVLB  0
2420:  RCALL  2290
.................... 	display("     EEPROM      "); 
2422:  MOVLW  F0
2424:  MOVWF  FF6
2426:  MOVLW  00
2428:  MOVWF  FF7
242A:  RCALL  22F0
.................... 	while(true){} 
242C:  BRA    242C
242E:  MOVLB  3
.................... 	} 
2430:  MOVLB  0
2432:  GOTO   A8DC (RETURN)
....................  
....................  
....................      
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
.................... #include "teclado_21_teclas.c" 
.................... #define		F1					10 
.................... #define		F2					11 
.................... #define     F3					12 
.................... #define		F4					13 
.................... #define     SETA_SUPERIOR   	14 
.................... #define     SETA_INFERIOR   	15  
.................... #define		SETA_DIREITA    	16  
.................... #define     SETA_ESQUERDA  	    17 
.................... #define     ESC					18 
.................... #define     ENTER				19	 
.................... #define     MENU				20 
....................  
.................... void Init_Keyboard(void){ 
.................... 	escreve_PCA9555(0X01,0X06,0Xff,0xf8);// programa bit 0,bit 1,bit 2  como saida e os demais como entrada 
*
218E:  MOVLW  01
2190:  MOVLB  3
2192:  MOVWF  xBB
2194:  MOVLW  06
2196:  MOVWF  xBC
2198:  SETF   xBD
219A:  MOVLW  F8
219C:  MOVWF  xBE
219E:  MOVLB  0
21A0:  RCALL  213C
....................  	escreve_PCA9555(0X01,0X02,0X00,0X07);//coloca colunas em  high level 
21A2:  MOVLW  01
21A4:  MOVLB  3
21A6:  MOVWF  xBB
21A8:  MOVLW  02
21AA:  MOVWF  xBC
21AC:  CLRF   xBD
21AE:  MOVLW  07
21B0:  MOVWF  xBE
21B2:  MOVLB  0
21B4:  RCALL  213C
21B6:  GOTO   A8CC (RETURN)
.................... } 
.................... unsigned long int  Get_Key(void){	 
*
4FBE:  MOVLB  3
4FC0:  CLRF   xB3
4FC2:  CLRF   xB2
4FC4:  MOVLW  06
4FC6:  MOVWF  xB4
4FC8:  MOVLW  7F
4FCA:  MOVWF  xB5
.................... 	long int dado = 0x0000; 
.................... 	int    coluna = 0x06; 
....................     int    mascara = 0x7f; 
.................... 	long int i; 
.................... 	for (i = 0 ; i < 3 ; i++) { 
4FCC:  CLRF   xB7
4FCE:  CLRF   xB6
4FD0:  MOVF   xB7,F
4FD2:  BNZ   5046
4FD4:  MOVF   xB6,W
4FD6:  SUBLW  02
4FD8:  BNC   5046
....................     	coluna -= i; 
4FDA:  MOVF   xB6,W
4FDC:  SUBWF  xB4,F
.................... 		escreve_PCA9555(0X01,0X02,0X00,coluna);     // coloca coluna  em  low level 
4FDE:  MOVLW  01
4FE0:  MOVWF  xBB
4FE2:  MOVLW  02
4FE4:  MOVWF  xBC
4FE6:  CLRF   xBD
4FE8:  MOVFF  3B4,3BE
4FEC:  MOVLB  0
4FEE:  CALL   213C
.................... 		dado =  le_PCA9555(0X01,0X00) >> 3;         // desloca bits 
4FF2:  MOVLW  01
4FF4:  MOVLB  3
4FF6:  MOVWF  xB8
4FF8:  CLRF   xB9
4FFA:  MOVLB  0
4FFC:  CALL   3FD2
5000:  MOVLB  3
5002:  RRCF   02,W
5004:  MOVWF  xB3
5006:  RRCF   01,W
5008:  MOVWF  xB2
500A:  RRCF   xB3,F
500C:  RRCF   xB2,F
500E:  RRCF   xB3,F
5010:  RRCF   xB2,F
5012:  MOVLW  1F
5014:  ANDWF  xB3,F
.................... 		dado &= mascara;  							// mascara bits 
5016:  MOVF   xB5,W
5018:  ANDWF  xB2,F
501A:  CLRF   xB3
....................         dado = 127 - dado;                            
501C:  MOVLW  7F
501E:  BSF    FD8.0
5020:  SUBFWB xB2,F
5022:  MOVLW  00
5024:  SUBFWB xB3,F
.................... 		if(dado != 0) { 
5026:  MOVF   xB2,F
5028:  BNZ   502E
502A:  MOVF   xB3,F
502C:  BZ    503E
....................             i = i << 8; 
502E:  MOVFF  3B6,3B7
5032:  CLRF   xB6
....................             dado |= i ; 
5034:  MOVF   xB6,W
5036:  IORWF  xB2,F
5038:  MOVF   xB7,W
503A:  IORWF  xB3,F
....................             break; 
503C:  BRA    5046
.................... 		}		 
503E:  INCF   xB6,F
5040:  BTFSC  FD8.2
5042:  INCF   xB7,F
5044:  BRA    4FD0
.................... 	}		 
....................     return(dado); 
5046:  MOVFF  3B2,01
504A:  MOVFF  3B3,02
504E:  MOVLB  0
5050:  GOTO   5060 (RETURN)
.................... } 
.................... int Teclado(void) { 
5054:  MOVLB  3
5056:  CLRF   xB0
5058:  CLRF   xAF
505A:  CLRF   xB1
....................  // l o teclado 
....................  // se nenhuma tecla acionada retorna 0xff 
....................  // se acionada retorna o codigo da tecla 
....................    unsigned long int codigo_teclado = 0x0000; 
....................    int key_code = 0x00; 
....................    codigo_teclado = Get_Key(); 
505C:  MOVLB  0
505E:  BRA    4FBE
5060:  MOVFF  02,3B0
5064:  MOVFF  01,3AF
....................    if(codigo_teclado == 0x00) return( key_code =0xff);	 
5068:  MOVLB  3
506A:  MOVF   xAF,F
506C:  BNZ   507A
506E:  MOVF   xB0,F
5070:  BNZ   507A
5072:  SETF   xB1
5074:  MOVFF  3B1,01
5078:  BRA    5292
.................... 	switch(codigo_teclado){ 
507A:  MOVF   xAF,W
507C:  MOVWF  00
507E:  MOVF   xB0,W
5080:  MOVWF  03
5082:  MOVLW  01
5084:  SUBWF  03,W
5086:  BNZ   5094
5088:  MOVLW  40
508A:  SUBWF  00,W
508C:  MOVLB  0
508E:  BTFSC  FD8.2
5090:  BRA    51E8
5092:  MOVLB  3
5094:  MOVF   03,W
5096:  BNZ   50A4
5098:  MOVLW  08
509A:  SUBWF  00,W
509C:  MOVLB  0
509E:  BTFSC  FD8.2
50A0:  BRA    51EE
50A2:  MOVLB  3
50A4:  MOVLW  01
50A6:  SUBWF  03,W
50A8:  BNZ   50B6
50AA:  MOVLW  08
50AC:  SUBWF  00,W
50AE:  MOVLB  0
50B0:  BTFSC  FD8.2
50B2:  BRA    51F6
50B4:  MOVLB  3
50B6:  MOVLW  02
50B8:  SUBWF  03,W
50BA:  BNZ   50C8
50BC:  MOVLW  08
50BE:  SUBWF  00,W
50C0:  MOVLB  0
50C2:  BTFSC  FD8.2
50C4:  BRA    51FE
50C6:  MOVLB  3
50C8:  MOVF   03,W
50CA:  BNZ   50D8
50CC:  MOVLW  10
50CE:  SUBWF  00,W
50D0:  MOVLB  0
50D2:  BTFSC  FD8.2
50D4:  BRA    5206
50D6:  MOVLB  3
50D8:  MOVLW  01
50DA:  SUBWF  03,W
50DC:  BNZ   50EA
50DE:  MOVLW  10
50E0:  SUBWF  00,W
50E2:  MOVLB  0
50E4:  BTFSC  FD8.2
50E6:  BRA    520E
50E8:  MOVLB  3
50EA:  MOVLW  02
50EC:  SUBWF  03,W
50EE:  BNZ   50FC
50F0:  MOVLW  10
50F2:  SUBWF  00,W
50F4:  MOVLB  0
50F6:  BTFSC  FD8.2
50F8:  BRA    5216
50FA:  MOVLB  3
50FC:  MOVF   03,W
50FE:  BNZ   510C
5100:  MOVLW  20
5102:  SUBWF  00,W
5104:  MOVLB  0
5106:  BTFSC  FD8.2
5108:  BRA    521E
510A:  MOVLB  3
510C:  MOVLW  01
510E:  SUBWF  03,W
5110:  BNZ   511E
5112:  MOVLW  20
5114:  SUBWF  00,W
5116:  MOVLB  0
5118:  BTFSC  FD8.2
511A:  BRA    5226
511C:  MOVLB  3
511E:  MOVLW  02
5120:  SUBWF  03,W
5122:  BNZ   5130
5124:  MOVLW  20
5126:  SUBWF  00,W
5128:  MOVLB  0
512A:  BTFSC  FD8.2
512C:  BRA    522E
512E:  MOVLB  3
5130:  MOVF   03,W
5132:  BNZ   5140
5134:  MOVLW  01
5136:  SUBWF  00,W
5138:  MOVLB  0
513A:  BTFSC  FD8.2
513C:  BRA    5236
513E:  MOVLB  3
5140:  MOVLW  02
5142:  SUBWF  03,W
5144:  BNZ   5152
5146:  MOVLW  01
5148:  SUBWF  00,W
514A:  MOVLB  0
514C:  BTFSC  FD8.2
514E:  BRA    523E
5150:  MOVLB  3
5152:  MOVF   03,W
5154:  BNZ   5162
5156:  MOVLW  04
5158:  SUBWF  00,W
515A:  MOVLB  0
515C:  BTFSC  FD8.2
515E:  BRA    5246
5160:  MOVLB  3
5162:  MOVLW  02
5164:  SUBWF  03,W
5166:  BNZ   5174
5168:  MOVLW  04
516A:  SUBWF  00,W
516C:  MOVLB  0
516E:  BTFSC  FD8.2
5170:  BRA    524E
5172:  MOVLB  3
5174:  MOVF   03,W
5176:  BNZ   5184
5178:  MOVLW  40
517A:  SUBWF  00,W
517C:  MOVLB  0
517E:  BTFSC  FD8.2
5180:  BRA    5256
5182:  MOVLB  3
5184:  MOVLW  02
5186:  SUBWF  03,W
5188:  BNZ   5196
518A:  MOVLW  40
518C:  SUBWF  00,W
518E:  MOVLB  0
5190:  BTFSC  FD8.2
5192:  BRA    525E
5194:  MOVLB  3
5196:  MOVLW  01
5198:  SUBWF  03,W
519A:  BNZ   51A8
519C:  MOVLW  01
519E:  SUBWF  00,W
51A0:  MOVLB  0
51A2:  BTFSC  FD8.2
51A4:  BRA    5266
51A6:  MOVLB  3
51A8:  MOVF   03,W
51AA:  BNZ   51B6
51AC:  MOVLW  02
51AE:  SUBWF  00,W
51B0:  MOVLB  0
51B2:  BZ    526E
51B4:  MOVLB  3
51B6:  MOVLW  02
51B8:  SUBWF  03,W
51BA:  BNZ   51C6
51BC:  MOVLW  02
51BE:  SUBWF  00,W
51C0:  MOVLB  0
51C2:  BZ    5276
51C4:  MOVLB  3
51C6:  MOVLW  01
51C8:  SUBWF  03,W
51CA:  BNZ   51D6
51CC:  MOVLW  04
51CE:  SUBWF  00,W
51D0:  MOVLB  0
51D2:  BZ    527E
51D4:  MOVLB  3
51D6:  MOVLW  01
51D8:  SUBWF  03,W
51DA:  BNZ   51E6
51DC:  MOVLW  02
51DE:  SUBWF  00,W
51E0:  MOVLB  0
51E2:  BZ    5286
51E4:  MOVLB  3
51E6:  BRA    528E
.................... 		case 320:key_code=0; 
51E8:  MOVLB  3
51EA:  CLRF   xB1
.................... 				break; 
51EC:  BRA    528E
.................... 		case 8:	key_code=1; 
51EE:  MOVLW  01
51F0:  MOVLB  3
51F2:  MOVWF  xB1
.................... 				break; 
51F4:  BRA    528E
.................... 		case 264:key_code=2; 
51F6:  MOVLW  02
51F8:  MOVLB  3
51FA:  MOVWF  xB1
.................... 				break; 
51FC:  BRA    528E
.................... 		case 520:key_code=3; 
51FE:  MOVLW  03
5200:  MOVLB  3
5202:  MOVWF  xB1
.................... 				break;	 
5204:  BRA    528E
.................... 		case 16: key_code=4; 
5206:  MOVLW  04
5208:  MOVLB  3
520A:  MOVWF  xB1
.................... 				break; 
520C:  BRA    528E
.................... 		case 272:key_code=5; 
520E:  MOVLW  05
5210:  MOVLB  3
5212:  MOVWF  xB1
.................... 				break; 
5214:  BRA    528E
.................... 		case 528:key_code=6; 
5216:  MOVLW  06
5218:  MOVLB  3
521A:  MOVWF  xB1
.................... 				break; 
521C:  BRA    528E
.................... 		case 32:key_code=7; 
521E:  MOVLW  07
5220:  MOVLB  3
5222:  MOVWF  xB1
.................... 				break; 
5224:  BRA    528E
.................... 		case 288:key_code=8; 
5226:  MOVLW  08
5228:  MOVLB  3
522A:  MOVWF  xB1
.................... 				break; 
522C:  BRA    528E
.................... 		case 544:key_code=9; 
522E:  MOVLW  09
5230:  MOVLB  3
5232:  MOVWF  xB1
....................                 break; 
5234:  BRA    528E
.................... 		case 1:	key_code=F1; 
5236:  MOVLW  0A
5238:  MOVLB  3
523A:  MOVWF  xB1
....................                 break; 
523C:  BRA    528E
.................... 		case 513:key_code=F2; 
523E:  MOVLW  0B
5240:  MOVLB  3
5242:  MOVWF  xB1
....................                 break; 
5244:  BRA    528E
.................... 		case 4:	key_code=F3; 
5246:  MOVLW  0C
5248:  MOVLB  3
524A:  MOVWF  xB1
....................                 break; 
524C:  BRA    528E
.................... 		case 516:key_code=F4; 
524E:  MOVLW  0D
5250:  MOVLB  3
5252:  MOVWF  xB1
....................                 break; 
5254:  BRA    528E
.................... 		case 64:key_code=ESC; 
5256:  MOVLW  12
5258:  MOVLB  3
525A:  MOVWF  xB1
....................                 break; 
525C:  BRA    528E
.................... 		case 576:key_code=ENTER; 
525E:  MOVLW  13
5260:  MOVLB  3
5262:  MOVWF  xB1
....................                 break; 
5264:  BRA    528E
.................... 		case 257:key_code=SETA_SUPERIOR ; 
5266:  MOVLW  0E
5268:  MOVLB  3
526A:  MOVWF  xB1
....................                 break; 
526C:  BRA    528E
.................... 		case 2:	key_code=SETA_ESQUERDA ; 
526E:  MOVLW  11
5270:  MOVLB  3
5272:  MOVWF  xB1
....................                 break; 
5274:  BRA    528E
.................... 		case 514:key_code=SETA_DIREITA ; 
5276:  MOVLW  10
5278:  MOVLB  3
527A:  MOVWF  xB1
....................                 break; 
527C:  BRA    528E
.................... 		case 260:key_code=SETA_INFERIOR; 
527E:  MOVLW  0F
5280:  MOVLB  3
5282:  MOVWF  xB1
....................                 break; 
5284:  BRA    528E
.................... 		case 258:key_code=MENU; 
5286:  MOVLW  14
5288:  MOVLB  3
528A:  MOVWF  xB1
....................                 break; 
528C:  BRA    528E
.................... 	    default: 
.................... 				break; 
.................... 	} 
.................... 	return( key_code ); 
528E:  MOVFF  3B1,01
5292:  MOVLB  0
5294:  RETURN 0
.................... } 
.................... void espera_desacionar_teclas(void) { 
....................   int key_code = 0x00; 
....................   key_code = Teclado(); 
....................   while(key_code != 0xff){ 
....................     key_code = Teclado(); 
....................   } 
.................... } 
....................  
.................... #include "stepper_motor.c" 
.................... #DEFINE     step_y			    pin_C2 
.................... #DEFINE     dir_y				pin_C1 
.................... #DEFINE     enable_y			pin_C0 
....................  
.................... #DEFINE     step_x 		        pin_D2 
.................... #DEFINE     dir_x				pin_D1 
.................... #DEFINE     enable_x			pin_D0 
.................... #DEFINE     step_z              pin_A5              
.................... #DEFINE     dir_z               pin_A4 
.................... #DEFINE     enable_z            pin_A3 
.................... #DEFINE     step_flip           pin_E2 
.................... #DEFINE     dir_flip            pin_E1  
.................... #DEFINE     enable_flip         pin_E0 
....................  
.................... long int buffer_saida; 
.................... int16 motor_pos_x; 
.................... int16 motor_pos_y; 
.................... long int contador_step_flip; 
.................... int16 motor_pos_z; 
.................... short int direita_flag; 
.................... short int esquerda_flag; 
.................... short int frente_flag; 
.................... short int atras_flag; 
.................... short int sobe_flag; 
.................... short int desce_flag; 
.................... short int sentido_horario_flag; 
.................... short int sentido_antihorario_flag; 
....................  
.................... void direita(void) { 
....................     direita_flag = true; 
*
458C:  BSF    2C.3
....................     esquerda_flag = false; 
458E:  BCF    2C.4
....................     output_low(dir_x); 
4590:  BCF    F95.1
4592:  BCF    F8C.1
4594:  RETURN 0
.................... } 
.................... void esquerda(void) { 
....................     direita_flag = false; 
*
45CE:  BCF    2C.3
....................     esquerda_flag = true; 
45D0:  BSF    2C.4
....................     output_high(dir_x); 
45D2:  BCF    F95.1
45D4:  BSF    F8C.1
45D6:  RETURN 0
.................... } 
.................... void frente(void) { 
....................     frente_flag = true; 
*
4420:  BSF    2C.5
....................     atras_flag = false; 
4422:  BCF    2C.6
....................     output_low(dir_y); 
4424:  BCF    F94.1
4426:  BCF    F8B.1
4428:  RETURN 0
.................... } 
.................... void atras(void) { 
....................     frente_flag = false; 
*
4462:  BCF    2C.5
....................     atras_flag = true; 
4464:  BSF    2C.6
....................     output_high(dir_y); 
4466:  BCF    F94.1
4468:  BSF    F8B.1
446A:  RETURN 0
.................... } 
.................... void sentido_horario(void) { 
....................     sentido_horario_flag = true; 
*
4920:  MOVLB  1
4922:  BSF    x1A.1
....................     sentido_antihorario_flag = false; 
4924:  BCF    x1A.2
....................     output_low(dir_flip); 
4926:  BCF    F96.1
4928:  BCF    F8D.1
492A:  MOVLB  0
492C:  RETURN 0
.................... } 
.................... void sentido_antihorario(void) { 
....................     sentido_horario_flag = false; 
*
4962:  MOVLB  1
4964:  BCF    x1A.1
....................     sentido_antihorario_flag = true; 
4966:  BSF    x1A.2
....................     output_high(dir_flip); 
4968:  BCF    F96.1
496A:  BSF    F8D.1
496C:  MOVLB  0
496E:  RETURN 0
.................... } 
.................... void sobe(void) { 
....................     sobe_flag = true; 
*
430E:  BSF    2C.7
....................     desce_flag = false; 
4310:  MOVLB  1
4312:  BCF    x1A.0
....................     output_low(dir_z); 
4314:  BCF    F92.4
4316:  BCF    F89.4
4318:  MOVLB  0
431A:  RETURN 0
.................... } 
.................... void desce(void) { 
....................     sobe_flag = false; 
*
42CC:  BCF    2C.7
....................     desce_flag = true; 
42CE:  MOVLB  1
42D0:  BSF    x1A.0
....................     output_high(dir_z); 
42D2:  BCF    F92.4
42D4:  BSF    F89.4
42D6:  MOVLB  0
42D8:  RETURN 0
.................... } 
....................  
.................... void one_step_x(void) { 
....................     output_high(step_x); 
*
4596:  BCF    F95.2
4598:  BSF    F8C.2
....................     delay_us(10); 
459A:  MOVLW  10
459C:  MOVWF  00
459E:  DECFSZ 00,F
45A0:  BRA    459E
45A2:  NOP   
....................     output_low(step_x); 
45A4:  BCF    F95.2
45A6:  BCF    F8C.2
....................     if (esquerda_flag == true) { 
45A8:  BTFSS  2C.4
45AA:  BRA    45B8
....................         motor_pos_x++; 
45AC:  MOVLB  1
45AE:  INCF   x12,F
45B0:  BTFSC  FD8.2
45B2:  INCF   x13,F
....................     } else { 
45B4:  BRA    45CA
45B6:  MOVLB  0
....................         if (motor_pos_x != 0000){ 
45B8:  MOVLB  1
45BA:  MOVF   x12,F
45BC:  BNZ   45C2
45BE:  MOVF   x13,F
45C0:  BZ    45CA
....................             motor_pos_x--; 
45C2:  MOVF   x12,W
45C4:  BTFSC  FD8.2
45C6:  DECF   x13,F
45C8:  DECF   x12,F
....................         } 
....................     } 
45CA:  MOVLB  0
45CC:  RETURN 0
.................... } 
.................... void one_step_y(void) { 
....................     output_high(step_y); 
*
442A:  BCF    F94.2
442C:  BSF    F8B.2
....................     delay_us(10); 
442E:  MOVLW  10
4430:  MOVWF  00
4432:  DECFSZ 00,F
4434:  BRA    4432
4436:  NOP   
....................     output_low(step_y); 
4438:  BCF    F94.2
443A:  BCF    F8B.2
....................     if (atras_flag == true) { 
443C:  BTFSS  2C.6
443E:  BRA    444C
....................         motor_pos_y++; 
4440:  MOVLB  1
4442:  INCF   x14,F
4444:  BTFSC  FD8.2
4446:  INCF   x15,F
....................     } else { 
4448:  BRA    445E
444A:  MOVLB  0
....................         if (motor_pos_y != 0000) { 
444C:  MOVLB  1
444E:  MOVF   x14,F
4450:  BNZ   4456
4452:  MOVF   x15,F
4454:  BZ    445E
....................             motor_pos_y--; 
4456:  MOVF   x14,W
4458:  BTFSC  FD8.2
445A:  DECF   x15,F
445C:  DECF   x14,F
....................         } 
....................     } 
445E:  MOVLB  0
4460:  RETURN 0
.................... } 
.................... void one_step_flip(void) { 
....................     output_high(step_flip); 
*
492E:  BCF    F96.2
4930:  BSF    F8D.2
....................     delay_us(10); 
4932:  MOVLW  10
4934:  MOVWF  00
4936:  DECFSZ 00,F
4938:  BRA    4936
493A:  NOP   
....................     output_low(step_flip); 
493C:  BCF    F96.2
493E:  BCF    F8D.2
....................     if (sentido_horario_flag == true) { 
4940:  MOVLB  1
4942:  BTFSS  x1A.1
4944:  BRA    494E
....................         contador_step_flip++; 
4946:  INCF   x16,F
4948:  BTFSC  FD8.2
494A:  INCF   x17,F
....................     } else { 
494C:  BRA    495E
....................         if (contador_step_flip != 0000) { 
494E:  MOVF   x16,F
4950:  BNZ   4956
4952:  MOVF   x17,F
4954:  BZ    495E
....................             contador_step_flip--; 
4956:  MOVF   x16,W
4958:  BTFSC  FD8.2
495A:  DECF   x17,F
495C:  DECF   x16,F
....................         } 
....................     } 
495E:  MOVLB  0
4960:  RETURN 0
.................... } 
.................... void one_step_z(void) { 
....................     output_high(step_z); 
*
42DA:  BCF    F92.5
42DC:  BSF    F89.5
....................     delay_us(10); 
42DE:  MOVLW  10
42E0:  MOVWF  00
42E2:  DECFSZ 00,F
42E4:  BRA    42E2
42E6:  NOP   
....................     output_low(step_z); 
42E8:  BCF    F92.5
42EA:  BCF    F89.5
....................     if (desce_flag == true) { 
42EC:  MOVLB  1
42EE:  BTFSS  x1A.0
42F0:  BRA    42FA
....................         motor_pos_z++; 
42F2:  INCF   x18,F
42F4:  BTFSC  FD8.2
42F6:  INCF   x19,F
....................     } else { 
42F8:  BRA    430A
....................         if (motor_pos_z != 0000) { 
42FA:  MOVF   x18,F
42FC:  BNZ   4302
42FE:  MOVF   x19,F
4300:  BZ    430A
....................             motor_pos_z--; 
4302:  MOVF   x18,W
4304:  BTFSC  FD8.2
4306:  DECF   x19,F
4308:  DECF   x18,F
....................         } 
....................     } 
430A:  MOVLB  0
430C:  RETURN 0
.................... } 
....................  
.................... void chopper_x(void) { 
....................     output_low(enable_x); 
*
4586:  BCF    F95.0
4588:  BCF    F8C.0
458A:  RETURN 0
.................... } 
.................... void chopper_y(void) { 
....................     output_low(enable_y); 
*
441A:  BCF    F94.0
441C:  BCF    F8B.0
441E:  RETURN 0
.................... } 
.................... void chopper_flip(void) { 
....................     output_low(enable_flip); 
*
4918:  BCF    F96.0
491A:  BCF    F8D.0
491C:  GOTO   4978 (RETURN)
.................... } 
.................... void chopper_z(void) { 
....................     output_low(enable_z); 
*
3FCA:  BCF    F92.3
3FCC:  BCF    F89.3
3FCE:  GOTO   4326 (RETURN)
.................... } 
.................... void stop_x(void) { 
....................     output_low(enable_x); 
*
45D8:  BCF    F95.0
45DA:  BCF    F8C.0
45DC:  RETURN 0
.................... } 
.................... void stop_y(void) { 
....................    output_low(enable_y); 
*
446C:  BCF    F94.0
446E:  BCF    F8B.0
4470:  RETURN 0
.................... } 
.................... void stop_flip(void) { 
....................     output_low(enable_flip); 
.................... } 
.................... void stop_z(void) { 
....................     output_low(enable_z); 
*
431C:  BCF    F92.3
431E:  BCF    F89.3
4320:  GOTO   4416 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "I_O.c" 
.................... #define     IN0				0 
.................... #define     IN1				1 
.................... #define     IN2				2 
.................... #define     IN3				3 
.................... #define     IN4				4 
.................... #define     IN5				5 
.................... #define     IN6				6 
.................... #define     IN7				7 
.................... #define     IN8				8 
.................... #define     IN9				9 
.................... #define     IN10			10 
.................... #define     IN11			11 
.................... #define     IN12			12 
.................... #define     IN13			13 
.................... #define     IN14			14 
.................... #define     IN15			15 
.................... #define     IN16			16 
.................... #define     IN17			17 
.................... #define     IN18			18 
.................... #define     IN19			19 
.................... #define     IN20			20 
.................... #define     IN21			21	 
.................... #define     IN22			22 
.................... #define     IN23			23 
.................... #define     IN24			24 
.................... #define     IN25			25 
.................... #define     IN26    		26 
.................... #define     IN27	    	27 
.................... 	 
.................... #define     S_DEDO_IN_LS1      	    IN0  	//SENSOR AVANO CILINRO  1		 
.................... #define     S_DEDO_IN_LS2      	    IN1	 	//SENSOR AVANO CILINDRO 2			 
.................... #define     S_EMPURRADOR_IN_LS1	    IN2	 	//NT 
.................... #define     S_EMPURRADOR_IN_LS2     IN3	 	//SENSOR RECUO  CLP1			 
.................... #define     S_PRESSOR_LS2           IN4	 	//SENSOR AVANCO 
.................... #define     S_X_DIREITA			    IN5	 	//LIMITE DIREITA			 
.................... #define     S_X_ESQUERDA		    IN6	 	//LIMITE ESQUERDA			 
.................... #define     S_Y_FRENTE   		    IN7  	//LIMITE FRENTE			 
.................... #define     S_Y_ATRAS               IN8  	//LIMITE ATRAS	 
.................... #define     S_Y_DIREITA_PROT  	    IN9  	//LIMITE DIREITA DA OUTRA PLACA			 
.................... #define     S_Y_ESQUERDA_PROT       IN10 	//LIMITE ESQUERDA DA OUTRA PLACA	 
.................... #define     S_ROTACAO_LS1           IN11 	//SENSOR LIMITE GIRO HORARIO			 
.................... #define     S_FERRO_SOLDA1          IN12 	//SENSOR FERRO DE SOLDA 1 			 
.................... #define     S_Z_TOP	    		    IN13 	//SENSOR LIMITE  SUPEIOR			 
.................... #define     S_Z_BOTTOM			    IN14 	//SENSOR LIMITE  INFERIOR			 
.................... #define     S_FERRO_SOLDA2          IN15 	//SENSOR FERRO DE SOLDA 2			 
.................... #define     S_DEDO_OUT_LS1		    IN16 	//SENSOR AVANO 
.................... #define     S_DEDO_OUT_LS2	        IN17 	//SENSOR AVANO 
.................... #define     S_EMPURRADOR_OUT_LS1    IN18 	//SENSOR AVANO 			 
.................... #define     S_EMPURRADOR_OUT_LS2    IN19 	//SENSOR recuo	 
.................... #define     SENSOR_BOARD   			IN20 	 
.................... #define     S_BANDEJA               IN21 	//SENSOR BANDEJA CLP1 & CLP2 
.................... #define     S_FIO_SOLDA1	        IN22 	//SENSOR FIO DE SOLDA 1 
.................... #define     S_FIO_SOLDA2	        IN23 	//SENSOR FIO DE SOLDA 2 
.................... #define     S_FIO_SOLDA3	        IN24 	//SENSOR FIO DE SOLDA 3 
.................... #define     S_ESTEIRA               IN25 	//SENSOR DESLIGA ESTEIRA 
.................... #define     RESERVADO2 				IN26 	 
.................... #define     RESERVADO3              IN27    //RESET 
....................    	  
.................... // definio das saidas de comandos 
....................  
.................... #define     DEDO_ENTRADA				     7  //OUT 0 
.................... #define     EMPURRADOR_ENTRADA_SOL_EMPURRA   6  //OUT 1 
.................... #define     EMPURRADOR_ENTRADA_SOL_RETORNA 	 5  //OUT 2 
.................... #define     PRESSOR						     4  //OUT 3 
.................... #define     FERRO_SOLDA1				     3  //OUT 4 
.................... #define     FERRO_SOLDA2				     2  //OUT 5 
.................... #define     DEDO_SAIDA					     1  //OUT 6 
.................... #define     EMPURRADOR_SAIDA_SOL_EMPURRA     0  //OUT 7 
.................... #define     EMPURRADOR_SAIDA_SOL_RETORNA     15 //OUT 8 
.................... #define     ALIMENTADOR1					 14 //OUT 9  RL2 
.................... #define     ALIMENTADOR2					 13 //OUT 10 RL3 
.................... #define     ALIMENTADOR3					 12	//OUT 11 RL4  
.................... #define     LIMPADOR					     11	//OUT 12 RL5 
.................... #define     RELE_ESTEIRA                     10 //OUT 13  
.................... #define     LIMPA_BICO1                       8 //OUT 15    
.................... #define     LIMPA_BICO2                       9 //OUT 14  
....................  
.................... short int le_Input(int input_number){ 
*
4090:  MOVLB  3
4092:  CLRF   xB5
4094:  CLRF   xB4
4096:  CLRF   xB6
.................... 	short int retorno; 
....................     long int  data_sensores  = 0x0000; 
.................... 	int		  data_sensores2 = 0x00;	 
.................... 	if(input_number < 16) { 
4098:  MOVF   xB2,W
409A:  SUBLW  0F
409C:  BNC   4112
.................... 	 	data_sensores = le_PCA9555(0X03,0X00); 
409E:  MOVLW  03
40A0:  MOVWF  xB8
40A2:  CLRF   xB9
40A4:  MOVLB  0
40A6:  RCALL  3FD2
40A8:  MOVFF  02,3B5
40AC:  MOVFF  01,3B4
.................... 		if(bit_test (data_sensores,input_number) == 0){ 
40B0:  MOVFF  3B5,03
40B4:  MOVLB  3
40B6:  MOVFF  3B4,02
40BA:  MOVF   xB2,W
40BC:  MOVWF  00
40BE:  BZ    40CA
40C0:  BCF    FD8.0
40C2:  RRCF   03,F
40C4:  RRCF   02,F
40C6:  DECFSZ 00,F
40C8:  BRA    40C0
40CA:  MOVF   02,W
40CC:  BTFSC  02.0
40CE:  BRA    410A
.................... 			delay_us(30); 
40D0:  MOVLW  31
40D2:  MOVWF  00
40D4:  DECFSZ 00,F
40D6:  BRA    40D4
40D8:  BRA    40DA
.................... 			if(bit_test (data_sensores,input_number) == 0) return retorno = true; 
40DA:  MOVFF  3B5,03
40DE:  MOVFF  3B4,02
40E2:  MOVF   xB2,W
40E4:  MOVWF  00
40E6:  BZ    40F2
40E8:  BCF    FD8.0
40EA:  RRCF   03,F
40EC:  RRCF   02,F
40EE:  DECFSZ 00,F
40F0:  BRA    40E8
40F2:  MOVF   02,W
40F4:  BTFSC  02.0
40F6:  BRA    4100
40F8:  BSF    xB3.0
40FA:  MOVLW  01
40FC:  MOVWF  01
40FE:  BRA    429C
.................... 			return  retorno = false; 
4100:  BCF    xB3.0
4102:  MOVLW  00
4104:  MOVWF  01
4106:  BRA    429C
.................... 		} 
4108:  BRA    4112
....................         else  
....................             return  retorno = false; 
410A:  BCF    xB3.0
410C:  MOVLW  00
410E:  MOVWF  01
4110:  BRA    429C
.................... 	}		 
.................... 	if((input_number >= 16) && (input_number < 24)){ 
4112:  MOVF   xB2,W
4114:  SUBLW  0F
4116:  BC    4188
4118:  MOVF   xB2,W
411A:  SUBLW  17
411C:  BNC   4188
.................... 		data_sensores2 = le_pcf8574A(0x04); 
411E:  MOVLW  04
4120:  MOVWF  xB7
4122:  MOVLB  0
4124:  BRA    405A
4126:  MOVFF  01,3B6
.................... 		if(bit_test (data_sensores2,input_number - 16) == 0) { 
412A:  MOVLW  10
412C:  MOVLB  3
412E:  SUBWF  xB2,W
4130:  MOVWF  xB7
4132:  MOVFF  3B6,00
4136:  MOVF   xB7,W
4138:  MOVWF  01
413A:  BZ    4144
413C:  BCF    FD8.0
413E:  RRCF   00,F
4140:  DECFSZ 01,F
4142:  BRA    413C
4144:  BTFSC  00.0
4146:  BRA    4180
.................... 			delay_us(30); 
4148:  MOVLW  31
414A:  MOVWF  00
414C:  DECFSZ 00,F
414E:  BRA    414C
4150:  BRA    4152
.................... 			if(bit_test (data_sensores2,input_number - 16) == 0) return retorno = true; 
4152:  MOVLW  10
4154:  SUBWF  xB2,W
4156:  MOVWF  xB7
4158:  MOVFF  3B6,00
415C:  MOVF   xB7,W
415E:  MOVWF  01
4160:  BZ    416A
4162:  BCF    FD8.0
4164:  RRCF   00,F
4166:  DECFSZ 01,F
4168:  BRA    4162
416A:  BTFSC  00.0
416C:  BRA    4176
416E:  BSF    xB3.0
4170:  MOVLW  01
4172:  MOVWF  01
4174:  BRA    429C
.................... 			return    retorno = false; 
4176:  BCF    xB3.0
4178:  MOVLW  00
417A:  MOVWF  01
417C:  BRA    429C
.................... 		} 
417E:  BRA    4188
....................         else { 
....................             return  retorno = false; 
4180:  BCF    xB3.0
4182:  MOVLW  00
4184:  MOVWF  01
4186:  BRA    429C
....................         } 
.................... 	} 
.................... 	if((input_number >= 24) && (input_number <= 27)) {	 
4188:  MOVF   xB2,W
418A:  SUBLW  17
418C:  BTFSC  FD8.0
418E:  BRA    429C
4190:  MOVF   xB2,W
4192:  SUBLW  1B
4194:  BTFSS  FD8.0
4196:  BRA    429C
.................... 		switch(input_number) { 
4198:  MOVLW  18
419A:  SUBWF  xB2,W
419C:  ADDLW  FC
419E:  BTFSC  FD8.0
41A0:  BRA    429C
41A2:  ADDLW  04
41A4:  MOVLB  0
41A6:  GOTO   42A0
.................... 			case 24: 
....................                 if(input(in24_bit) == 0) { 
41AA:  BSF    F93.0
41AC:  BTFSC  F81.0
41AE:  BRA    41D6
....................                     delay_us(30); 
41B0:  MOVLW  31
41B2:  MOVWF  00
41B4:  DECFSZ 00,F
41B6:  BRA    41B4
41B8:  BRA    41BA
....................                     if(input(in24_bit) == 0) { 
41BA:  BSF    F93.0
41BC:  BTFSC  F81.0
41BE:  BRA    41D4
....................                         return retorno	= true;		 
41C0:  MOVLB  3
41C2:  BSF    xB3.0
41C4:  MOVLW  01
41C6:  MOVWF  01
41C8:  BRA    429C
....................                         return retorno	= false;	 
41CA:  BCF    xB3.0
41CC:  MOVLW  00
41CE:  MOVWF  01
41D0:  BRA    429C
41D2:  MOVLB  0
....................                     } 
....................                 } 
41D4:  BRA    41E2
....................                 else {	 
....................                     return retorno	= false; 
41D6:  MOVLB  3
41D8:  BCF    xB3.0
41DA:  MOVLW  00
41DC:  MOVWF  01
41DE:  BRA    429C
41E0:  MOVLB  0
....................                 } 
....................             break; 
41E2:  MOVLB  3
41E4:  BRA    429C
.................... 			case 25: 
....................                 if(input(in25_bit) == 0){ 
41E6:  BSF    F93.1
41E8:  BTFSC  F81.1
41EA:  BRA    4212
....................                     delay_us(30); 
41EC:  MOVLW  31
41EE:  MOVWF  00
41F0:  DECFSZ 00,F
41F2:  BRA    41F0
41F4:  BRA    41F6
....................                     if(input(in25_bit) == 0) { 
41F6:  BSF    F93.1
41F8:  BTFSC  F81.1
41FA:  BRA    4210
....................                         return retorno	= true;		 
41FC:  MOVLB  3
41FE:  BSF    xB3.0
4200:  MOVLW  01
4202:  MOVWF  01
4204:  BRA    429C
....................                         return retorno	= false;	 
4206:  BCF    xB3.0
4208:  MOVLW  00
420A:  MOVWF  01
420C:  BRA    429C
420E:  MOVLB  0
....................                     } 
....................                 }else {	 
4210:  BRA    421E
....................                     return retorno	= false; 
4212:  MOVLB  3
4214:  BCF    xB3.0
4216:  MOVLW  00
4218:  MOVWF  01
421A:  BRA    429C
421C:  MOVLB  0
....................                 } 
....................             break; 
421E:  MOVLB  3
4220:  BRA    429C
.................... 			case 26: 
....................                 if(input(in26_bit) == 0){ 
4222:  BSF    F93.3
4224:  BTFSC  F81.3
4226:  BRA    424E
....................                     delay_us(30); 
4228:  MOVLW  31
422A:  MOVWF  00
422C:  DECFSZ 00,F
422E:  BRA    422C
4230:  BRA    4232
....................                     if(input(in26_bit) == 0) { 
4232:  BSF    F93.3
4234:  BTFSC  F81.3
4236:  BRA    424C
....................                         return retorno	= true;		 
4238:  MOVLB  3
423A:  BSF    xB3.0
423C:  MOVLW  01
423E:  MOVWF  01
4240:  BRA    429C
....................                         return retorno	= false;	 
4242:  BCF    xB3.0
4244:  MOVLW  00
4246:  MOVWF  01
4248:  BRA    429C
424A:  MOVLB  0
....................                     } 
....................                 }else{ 	 
424C:  BRA    425A
....................                     return retorno	= false; 
424E:  MOVLB  3
4250:  BCF    xB3.0
4252:  MOVLW  00
4254:  MOVWF  01
4256:  BRA    429C
4258:  MOVLB  0
....................                 } 
....................             break; 
425A:  MOVLB  3
425C:  BRA    429C
.................... 			case 27: 
....................                 if(input(in27_bit) == 0) { 
425E:  BSF    F93.4
4260:  BTFSC  F81.4
4262:  BRA    428A
....................                     delay_us(30); 
4264:  MOVLW  31
4266:  MOVWF  00
4268:  DECFSZ 00,F
426A:  BRA    4268
426C:  BRA    426E
....................                     if(input(in27_bit) == 0) { 
426E:  BSF    F93.4
4270:  BTFSC  F81.4
4272:  BRA    4288
....................                         return retorno	= true;		 
4274:  MOVLB  3
4276:  BSF    xB3.0
4278:  MOVLW  01
427A:  MOVWF  01
427C:  BRA    429C
....................                         return retorno	= false;	 
427E:  BCF    xB3.0
4280:  MOVLW  00
4282:  MOVWF  01
4284:  BRA    429C
4286:  MOVLB  0
....................                     } 
....................                 }else{ 	 
4288:  BRA    4296
....................                     return retorno	= false; 
428A:  MOVLB  3
428C:  BCF    xB3.0
428E:  MOVLW  00
4290:  MOVWF  01
4292:  BRA    429C
4294:  MOVLB  0
....................                 } 
....................             break; 
4296:  MOVLB  3
4298:  BRA    429C
429A:  MOVLB  3
.................... 	 	} 
.................... 	} 
429C:  MOVLB  0
429E:  RETURN 0
.................... } 
.................... void aciona_saida(long int output_word){ 
.................... 	int valor_lsb; 
.................... 	int valor_msb; 
.................... 	bit_clear(buffer_saida,output_word); 
*
2522:  CLRF   03
2524:  MOVLW  01
2526:  MOVWF  02
2528:  MOVLB  3
252A:  MOVF   xB7,W
252C:  MOVWF  00
252E:  BZ    253A
2530:  BCF    FD8.0
2532:  RLCF   02,F
2534:  RLCF   03,F
2536:  DECFSZ 00,F
2538:  BRA    2530
253A:  MOVF   02,W
253C:  XORLW  FF
253E:  MOVWF  00
2540:  MOVLW  FF
2542:  XORWF  03,F
2544:  MOVF   00,W
2546:  MOVLB  1
2548:  ANDWF  x10,F
254A:  MOVF   03,W
254C:  ANDWF  x11,F
.................... 	valor_lsb = make8(buffer_saida,0);   
254E:  MOVFF  110,3B9
2552:  MOVLB  3
.................... 	valor_msb = make8(buffer_saida,1); 
2554:  MOVFF  111,3BA
2558:  MOVLB  3
.................... 	escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
255A:  MOVLW  02
255C:  MOVWF  xBB
255E:  MOVWF  xBC
2560:  MOVFF  3BA,3BD
2564:  MOVFF  3B9,3BE
2568:  MOVLB  0
256A:  RCALL  213C
256C:  RETURN 0
.................... } 
.................... void desaciona_saida(long int output_word){ 
.................... 	int valor_lsb; 
.................... 	int valor_msb; 
.................... 	bit_set(buffer_saida,output_word); 
*
24E0:  CLRF   03
24E2:  MOVLW  01
24E4:  MOVWF  02
24E6:  MOVLB  3
24E8:  MOVF   xB7,W
24EA:  MOVWF  00
24EC:  BZ    24F8
24EE:  BCF    FD8.0
24F0:  RLCF   02,F
24F2:  RLCF   03,F
24F4:  DECFSZ 00,F
24F6:  BRA    24EE
24F8:  MOVF   02,W
24FA:  MOVLB  1
24FC:  IORWF  x10,F
24FE:  MOVF   03,W
2500:  IORWF  x11,F
.................... 	valor_lsb = make8(buffer_saida,0);   
2502:  MOVFF  110,3B9
2506:  MOVLB  3
.................... 	valor_msb = make8(buffer_saida,1); 
2508:  MOVFF  111,3BA
250C:  MOVLB  3
.................... 	escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
250E:  MOVLW  02
2510:  MOVWF  xBB
2512:  MOVWF  xBC
2514:  MOVFF  3BA,3BD
2518:  MOVFF  3B9,3BE
251C:  MOVLB  0
251E:  RCALL  213C
2520:  RETURN 0
.................... } 
.................... void desaciona_todas_saidas(void){ 
.................... 	int valor_lsb; 
.................... 	int valor_msb; 
.................... 	buffer_saida = 0x0ffff; 
*
21E6:  MOVLB  1
21E8:  SETF   x11
21EA:  SETF   x10
.................... 	valor_lsb = make8(buffer_saida,0);   
21EC:  MOVFF  110,3AD
21F0:  MOVLB  3
.................... 	valor_msb = make8(buffer_saida,1); 
21F2:  MOVFF  111,3AE
21F6:  MOVLB  3
.................... 	escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
21F8:  MOVLW  02
21FA:  MOVWF  xBB
21FC:  MOVWF  xBC
21FE:  MOVFF  3AE,3BD
2202:  MOVFF  3AD,3BE
2206:  MOVLB  0
2208:  RCALL  213C
220A:  GOTO   A8D8 (RETURN)
.................... } 
.................... void Init_Sensores_porta1(void){ 
.................... 	escreve_PCA9555(0X03,0X06,0Xff,0xff);	// programa bits entradas  
*
21BA:  MOVLW  03
21BC:  MOVLB  3
21BE:  MOVWF  xBB
21C0:  MOVLW  06
21C2:  MOVWF  xBC
21C4:  SETF   xBD
21C6:  SETF   xBE
21C8:  MOVLB  0
21CA:  RCALL  213C
21CC:  GOTO   A8D0 (RETURN)
.................... } 
.................... void Init_saidas(void){ 
.................... 	escreve_PCA9555(0X02,0X06,0X00,0x00);	// programa bits saidas //como saida e os demais como entrada     
21D0:  MOVLW  02
21D2:  MOVLB  3
21D4:  MOVWF  xBB
21D6:  MOVLW  06
21D8:  MOVWF  xBC
21DA:  CLRF   xBD
21DC:  CLRF   xBE
21DE:  MOVLB  0
21E0:  RCALL  213C
21E2:  GOTO   A8D4 (RETURN)
.................... } 
....................  
.................... #include "comunicacao_entre_maquinas.c" 
.................... #include "comunicacao_entre_maquinas.h" 
.................... /*  
....................  * File:   comunicacao_entre_maquinas.h 
....................  * Author: ictsam0100 
....................  * 
....................  * Created on 6 de Dezembro de 2018, 11:13 
....................  */ 
....................  
.................... int posicao_maq; 
.................... int n_posicao; 
.................... int n_bit; 
....................  
.................... short int le_bit(int n_bit); //l bit especifico e verifica o valor "0 ou 1" 
.................... int ler_posicao_maquina_1 (void); //le os bits H3, H4 e H5 para verificar a posicao da maquina 1 
.................... void enviar_posicao_para_maquina_1 (int n_posicao); //aciona os outputs H0, H1 e H2 para enviar posicao para maquina 1    
....................  
....................  
.................... short int le_bit(int n_bit) { 
....................     short int retorno; 
....................  
....................     if (input(n_bit) == 1) { 
*
3A8E:  MOVFF  3B3,3B5
3A92:  MOVLW  01
3A94:  MOVLB  3
3A96:  MOVWF  xB6
3A98:  MOVLW  0F
3A9A:  MOVWF  xB8
3A9C:  MOVLW  92
3A9E:  MOVWF  xB7
3AA0:  MOVLB  0
3AA2:  RCALL  3A1A
3AA4:  MOVFF  3B3,3B5
3AA8:  MOVLW  0F
3AAA:  MOVLB  3
3AAC:  MOVWF  xB7
3AAE:  MOVLW  80
3AB0:  MOVWF  xB6
3AB2:  MOVLB  0
3AB4:  RCALL  3A5C
3AB6:  BTFSS  01.0
3AB8:  BRA    3AD0
....................         return retorno = 1; 
3ABA:  MOVLB  3
3ABC:  BSF    xB4.0
3ABE:  MOVLW  01
3AC0:  MOVWF  01
3AC2:  BRA    3B10
....................         delay_us(30); 
3AC4:  MOVLW  31
3AC6:  MOVWF  00
3AC8:  DECFSZ 00,F
3ACA:  BRA    3AC8
3ACC:  BRA    3ACE
3ACE:  MOVLB  0
....................     } 
....................     if (input(n_bit) == 0) { 
3AD0:  MOVFF  3B3,3B5
3AD4:  MOVLW  01
3AD6:  MOVLB  3
3AD8:  MOVWF  xB6
3ADA:  MOVLW  0F
3ADC:  MOVWF  xB8
3ADE:  MOVLW  92
3AE0:  MOVWF  xB7
3AE2:  MOVLB  0
3AE4:  RCALL  3A1A
3AE6:  MOVFF  3B3,3B5
3AEA:  MOVLW  0F
3AEC:  MOVLB  3
3AEE:  MOVWF  xB7
3AF0:  MOVLW  80
3AF2:  MOVWF  xB6
3AF4:  MOVLB  0
3AF6:  RCALL  3A5C
3AF8:  BTFSC  01.0
3AFA:  BRA    3B12
....................         return retorno = 0; 
3AFC:  MOVLB  3
3AFE:  BCF    xB4.0
3B00:  MOVLW  00
3B02:  MOVWF  01
3B04:  BRA    3B10
....................         delay_us(30); 
3B06:  MOVLW  31
3B08:  MOVWF  00
3B0A:  DECFSZ 00,F
3B0C:  BRA    3B0A
3B0E:  BRA    3B10
3B10:  MOVLB  0
....................     } 
3B12:  RETURN 0
.................... } 
.................... int le_posicao_outra_maquina (void){ 
3B14:  MOVLW  1F
3B16:  MOVLB  3
3B18:  MOVWF  xB3
3B1A:  MOVLB  0
3B1C:  RCALL  3A8E
3B1E:  MOVFF  01,3B0
3B22:  MOVLW  1E
3B24:  MOVLB  3
3B26:  MOVWF  xB3
3B28:  MOVLB  0
3B2A:  RCALL  3A8E
3B2C:  MOVFF  01,3B1
3B30:  MOVLW  1D
3B32:  MOVLB  3
3B34:  MOVWF  xB3
3B36:  MOVLB  0
3B38:  RCALL  3A8E
3B3A:  MOVFF  01,3B2
....................     int x = le_bit(H0); 
....................     int y = le_bit(H1); 
....................     int z = le_bit(H2); 
....................      
....................     switch (z) { 
3B3E:  MOVLB  3
3B40:  MOVF   xB2,W
3B42:  XORLW  00
3B44:  MOVLB  0
3B46:  BZ    3B4E
3B48:  XORLW  01
3B4A:  BZ    3BA6
3B4C:  BRA    3BFE
....................         case 0: 
....................             switch (y) { 
3B4E:  MOVLB  3
3B50:  MOVF   xB1,W
3B52:  XORLW  00
3B54:  MOVLB  0
3B56:  BZ    3B5E
3B58:  XORLW  01
3B5A:  BZ    3B80
3B5C:  BRA    3BA4
....................                 case 0: 
....................                     switch (x) { 
3B5E:  MOVLB  3
3B60:  MOVF   xB0,W
3B62:  XORLW  00
3B64:  MOVLB  0
3B66:  BZ    3B6E
3B68:  XORLW  01
3B6A:  BZ    3B76
3B6C:  BRA    3B7E
....................                         case 0: 
....................                             posicao_maq = ALIMENTADOR; 
3B6E:  MOVLB  1
3B70:  CLRF   x1B
....................                         break; 
3B72:  MOVLB  0
3B74:  BRA    3B7E
....................                         case 1: 
....................                             posicao_maq = HOME1; 
3B76:  MOVLW  01
3B78:  MOVLB  1
3B7A:  MOVWF  x1B
....................                         break; 
3B7C:  MOVLB  0
....................                     } 
....................                 break; 
3B7E:  BRA    3BA4
....................                 case 1: 
....................                     switch (x) { 
3B80:  MOVLB  3
3B82:  MOVF   xB0,W
3B84:  XORLW  00
3B86:  MOVLB  0
3B88:  BZ    3B90
3B8A:  XORLW  01
3B8C:  BZ    3B9A
3B8E:  BRA    3BA2
....................                         case 0: 
....................                             posicao_maq = SOLDAGEM; 
3B90:  MOVLW  03
3B92:  MOVLB  1
3B94:  MOVWF  x1B
....................                         break; 
3B96:  MOVLB  0
3B98:  BRA    3BA2
....................                         case 1: 
....................                             posicao_maq = HOME2; 
3B9A:  MOVLW  04
3B9C:  MOVLB  1
3B9E:  MOVWF  x1B
....................                         break; 
3BA0:  MOVLB  0
....................                     } 
....................                 break;                     
3BA2:  BRA    3BA4
....................             } 
....................         break; 
3BA4:  BRA    3BFE
....................         case 1: 
....................             switch (y) { 
3BA6:  MOVLB  3
3BA8:  MOVF   xB1,W
3BAA:  XORLW  00
3BAC:  MOVLB  0
3BAE:  BZ    3BB6
3BB0:  XORLW  01
3BB2:  BZ    3BDA
3BB4:  BRA    3BFE
....................                 case 0: 
....................                     switch (x) { 
3BB6:  MOVLB  3
3BB8:  MOVF   xB0,W
3BBA:  XORLW  00
3BBC:  MOVLB  0
3BBE:  BZ    3BC6
3BC0:  XORLW  01
3BC2:  BZ    3BD0
3BC4:  BRA    3BD8
....................                         case 0: 
....................                             posicao_maq = DISPENSADOR; 
3BC6:  MOVLW  05
3BC8:  MOVLB  1
3BCA:  MOVWF  x1B
....................                         break; 
3BCC:  MOVLB  0
3BCE:  BRA    3BD8
....................                         case 1: 
....................                             posicao_maq = LIMPEZA; 
3BD0:  MOVLW  06
3BD2:  MOVLB  1
3BD4:  MOVWF  x1B
....................                         break; 
3BD6:  MOVLB  0
....................                     } 
....................                 break; 
3BD8:  BRA    3BFE
....................                 case 1: 
....................                     switch (x) { 
3BDA:  MOVLB  3
3BDC:  MOVF   xB0,W
3BDE:  XORLW  00
3BE0:  MOVLB  0
3BE2:  BZ    3BEA
3BE4:  XORLW  01
3BE6:  BZ    3BF4
3BE8:  BRA    3BFC
....................                         case 0: 
....................                             posicao_maq = LIMPEZA_2; 
3BEA:  MOVLW  07
3BEC:  MOVLB  1
3BEE:  MOVWF  x1B
....................                         break; 
3BF0:  MOVLB  0
3BF2:  BRA    3BFC
....................                         case 1: 
....................                             posicao_maq = POSICAO_8; 
3BF4:  MOVLW  08
3BF6:  MOVLB  1
3BF8:  MOVWF  x1B
....................                         break; 
3BFA:  MOVLB  0
....................                     } 
....................                 break;  
3BFC:  BRA    3BFE
....................             }                 
....................         break; 
....................     } 
....................     return posicao_maq; 
3BFE:  MOVLB  1
3C00:  MOVFF  11B,01
3C04:  MOVLB  0
3C06:  RETURN 0
.................... } 
.................... void envia_posicao_para_outra_maquina (int n_posicao) { 
....................     switch (n_posicao){ 
*
4C24:  MOVLB  3
4C26:  MOVF   xB0,W
4C28:  ADDLW  F7
4C2A:  BC    4CB6
4C2C:  ADDLW  09
4C2E:  MOVLB  0
4C30:  GOTO   4CBA
....................         case ALIMENTADOR: 
....................             output_low(H3); 
4C34:  BCF    F95.4
4C36:  BCF    F8C.4
....................             output_low(H4); 
4C38:  BCF    F94.7
4C3A:  BCF    F8B.7
....................             output_low(H5); 
4C3C:  BCF    F94.6
4C3E:  BCF    F8B.6
....................         break; 
4C40:  MOVLB  3
4C42:  BRA    4CB6
....................         case HOME1: 
....................             output_high(H3); 
4C44:  BCF    F95.4
4C46:  BSF    F8C.4
....................             output_low (H4); 
4C48:  BCF    F94.7
4C4A:  BCF    F8B.7
....................             output_low (H5); 
4C4C:  BCF    F94.6
4C4E:  BCF    F8B.6
....................         break; 
4C50:  MOVLB  3
4C52:  BRA    4CB6
....................         case SOLDAGEM: 
....................             output_low (H3); 
4C54:  BCF    F95.4
4C56:  BCF    F8C.4
....................             output_high(H4); 
4C58:  BCF    F94.7
4C5A:  BSF    F8B.7
....................             output_low (H5); 
4C5C:  BCF    F94.6
4C5E:  BCF    F8B.6
....................         break; 
4C60:  MOVLB  3
4C62:  BRA    4CB6
....................         case HOME2: 
....................             output_high (H3); 
4C64:  BCF    F95.4
4C66:  BSF    F8C.4
....................             output_high(H4); 
4C68:  BCF    F94.7
4C6A:  BSF    F8B.7
....................             output_low (H5); 
4C6C:  BCF    F94.6
4C6E:  BCF    F8B.6
....................         break; 
4C70:  MOVLB  3
4C72:  BRA    4CB6
....................         case DISPENSADOR: 
....................             output_low (H3); 
4C74:  BCF    F95.4
4C76:  BCF    F8C.4
....................             output_low (H4); 
4C78:  BCF    F94.7
4C7A:  BCF    F8B.7
....................             output_high(H5); 
4C7C:  BCF    F94.6
4C7E:  BSF    F8B.6
....................         break; 
4C80:  MOVLB  3
4C82:  BRA    4CB6
....................         case LIMPEZA: 
....................             output_high(H3); 
4C84:  BCF    F95.4
4C86:  BSF    F8C.4
....................             output_low (H4); 
4C88:  BCF    F94.7
4C8A:  BCF    F8B.7
....................             output_high(H5); 
4C8C:  BCF    F94.6
4C8E:  BSF    F8B.6
....................         break; 
4C90:  MOVLB  3
4C92:  BRA    4CB6
....................         case LIMPEZA_2: 
....................             output_low(H3); 
4C94:  BCF    F95.4
4C96:  BCF    F8C.4
....................             output_high(H4); 
4C98:  BCF    F94.7
4C9A:  BSF    F8B.7
....................             output_high (H5); 
4C9C:  BCF    F94.6
4C9E:  BSF    F8B.6
....................         break; 
4CA0:  MOVLB  3
4CA2:  BRA    4CB6
....................         case POSICAO_8: 
....................             output_high(H3); 
4CA4:  BCF    F95.4
4CA6:  BSF    F8C.4
....................             output_high(H4); 
4CA8:  BCF    F94.7
4CAA:  BSF    F8B.7
....................             output_high(H5); 
4CAC:  BCF    F94.6
4CAE:  BSF    F8B.6
....................         break; 
4CB0:  MOVLB  3
4CB2:  BRA    4CB6
4CB4:  MOVLB  3
....................     } 
4CB6:  MOVLB  0
4CB8:  RETURN 0
.................... } 
....................  
.................... #include "telas_maquina_1.c" 
.................... #include "telas_maquina_1.h" 
.................... #define menu_principal                          0 
.................... #define menu_seleciona_maquina                  1 
.................... #define menu_seleciona_debug                    2 
.................... #define menu_seleciona_manutencao               3 
.................... #define menu_debug_entrada_1                    4 
.................... #define menu_debug_entrada_2                    5 
.................... #define menu_debug_entrada_3                    6 
.................... #define menu_manutencao_outra_maquina           7 
.................... #define menu_debug_saida_1                      8 
.................... #define menu_debug_saida_2                      9 
.................... #define menu_debug_saida_3                      10 
.................... #define menu_debug_saida_4                      11 
....................  
.................... #define menu_programa_principal                 12 
....................  
.................... #define menu_edita_modelo                       13 
.................... #define menu_excluir_modelo                     14 
.................... #define menu_seleciona_pontos                   15 
.................... #define menu_dados_ponto                        16 
.................... #define menu_edita_pontos_no_modelo             17 
....................  
.................... void tela_apresentacao(void); //Tela que aparece quando liga a maquina 
.................... void tela_iniciando_maquina (void); //tela que aparece quando a maquina esta iniciando 
.................... void tela_movimentando_maquina (int posicao); //tela de movimentacao que aparece na maquina 2 
.................... void tela_esperando_mov_maquina(void); //tela esperando movimentacao da maquina 
.................... void tela_esperando_mov_outra_maquina (int posicao); //tela de espera de movimentacao da maquina 1 
.................... void tela_esperando_sair_posicao_outra_maquina(void); //tela de espera a outra maquina sair da posicao atual 
....................  
.................... void tela_principal(void); //tela principal 
.................... void tela_seleciona_maquina(void); // tela de selecao maquina 1 ou maquina 2 
.................... void tela_manutencao_outra_maquina(void); //tela de manutencao na outra maquina 
.................... void tela_edita_modelo (void); //tela que escolhe entre edicao e exclusao do modelo escolhido 
.................... void tela_seleciona_debug(void); //tela de selecao de debug: manutencao ou pontos 
.................... void tela_edita_pontos_no_modelo(void); //tela de edicao dos pontos no modelo 
.................... void tela_excluir_modelo(void); //tela que pergunta se voce quer realmente exlcuir o modelo 
.................... void tela_seleciona_pontos(void); //tela de escolha do ponto a ser editado 
.................... void tela_dados_ponto (void); //tela que mostra todos os dados do respectivo ponto da placa 
....................  
.................... void tela_seleciona_manutencao (void); //tela que mostra as opcoes sensores de entrada e atuadores de saida 
.................... void tela_debug_entrada_1 (void); //tela 1 de sensores da maquina 
.................... void tela_debug_entrada_2 (void); //tela 2 de sensores da maquina 
.................... void tela_debug_entrada_3 (void); //tela 3 de sensores da maquina 
.................... void tela_debug_saida_1(void); //tela que podemos acionar a esteira, pinos de entrada, e o alimentador de placa 
.................... void tela_debug_saida_2(void); //tela que podemos acionar o pressor da placa, pinos de saida e dispensador de placa 
.................... void tela_debug_saida_3(void); //tela que podemos acionar os alimentadores de solda, limpar os bicos e acionar os ferros 
.................... void tela_debug_saida_4(void); //tela que podemos realizar a movimentacao do eixo x, y, z e o flip individualmenta 
....................  
....................  
.................... void tela_programa_principal(void);//tela que aparece quando estamos no programa principal 
....................  
....................  
.................... void tela_apresentacao(){ 
....................     printf(lcd_putc, "\f"); //limpa display 
*
24AA:  MOVLW  0C
24AC:  MOVLB  3
24AE:  MOVWF  xBD
24B0:  MOVLB  0
24B2:  RCALL  2436
....................     printf(lcd_putc, "        ICTS        \n\r"); 
24B4:  MOVLW  02
24B6:  MOVWF  FF6
24B8:  MOVLW  01
24BA:  MOVWF  FF7
24BC:  RCALL  248A
....................     printf(lcd_putc, "  INSTITUTO CENTRO  \n\r"); 
24BE:  MOVLW  1A
24C0:  MOVWF  FF6
24C2:  MOVLW  01
24C4:  MOVWF  FF7
24C6:  RCALL  248A
....................     printf(lcd_putc, "    TECNOLOGIA EM   \n\r"); 
24C8:  MOVLW  32
24CA:  MOVWF  FF6
24CC:  MOVLW  01
24CE:  MOVWF  FF7
24D0:  RCALL  248A
....................     printf(lcd_putc, "      SOFTWARE      \n\r"); 
24D2:  MOVLW  4A
24D4:  MOVWF  FF6
24D6:  MOVLW  01
24D8:  MOVWF  FF7
24DA:  RCALL  248A
24DC:  GOTO   A8E0 (RETURN)
.................... } 
.................... void tela_iniciando_maquina(){ 
....................     printf(lcd_putc, "\f"); //limpa display 
*
2606:  MOVLW  0C
2608:  MOVLB  3
260A:  MOVWF  xBD
260C:  MOVLB  0
260E:  RCALL  2436
....................     printf(lcd_putc, "     INICIANDO     \n\r"); 
2610:  MOVLW  62
2612:  MOVWF  FF6
2614:  MOVLW  01
2616:  MOVWF  FF7
2618:  RCALL  248A
....................     printf(lcd_putc, "      MAQUINA     \n\r"); 
261A:  MOVLW  78
261C:  MOVWF  FF6
261E:  MOVLW  01
2620:  MOVWF  FF7
2622:  RCALL  248A
2624:  GOTO   A8E8 (RETURN)
.................... } 
.................... void tela_movimentando_maquina (int posicao) { 
....................     switch (posicao){ 
*
3E12:  MOVLB  3
3E14:  MOVF   xB0,W
3E16:  ADDLW  F8
3E18:  BTFSC  FD8.0
3E1A:  BRA    3F92
3E1C:  ADDLW  08
3E1E:  MOVLB  0
3E20:  GOTO   3F96
....................         case ALIMENTADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
3E24:  MOVLW  0C
3E26:  MOVLB  3
3E28:  MOVWF  xBD
3E2A:  MOVLB  0
3E2C:  CALL   2436
....................             printf(lcd_putc, "MOVIMENTANDO MAQUINA\n\r"); 
3E30:  MOVLW  8E
3E32:  MOVWF  FF6
3E34:  MOVLW  01
3E36:  MOVWF  FF7
3E38:  CALL   248A
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
3E3C:  MOVLW  A6
3E3E:  MOVWF  FF6
3E40:  MOVLW  01
3E42:  MOVWF  FF7
3E44:  CALL   248A
....................             printf(lcd_putc, "     ALIMENTADOR    \n\r"); 
3E48:  MOVLW  BE
3E4A:  MOVWF  FF6
3E4C:  MOVLW  01
3E4E:  MOVWF  FF7
3E50:  CALL   248A
....................         break; 
3E54:  MOVLB  3
3E56:  BRA    3F92
....................         case HOME1: 
....................             printf(lcd_putc, "\f"); //limpa display 
3E58:  MOVLW  0C
3E5A:  MOVLB  3
3E5C:  MOVWF  xBD
3E5E:  MOVLB  0
3E60:  CALL   2436
....................             printf(lcd_putc, "MOVIMENTANDO MAQUINA\n\r"); 
3E64:  MOVLW  D6
3E66:  MOVWF  FF6
3E68:  MOVLW  01
3E6A:  MOVWF  FF7
3E6C:  CALL   248A
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
3E70:  MOVLW  EE
3E72:  MOVWF  FF6
3E74:  MOVLW  01
3E76:  MOVWF  FF7
3E78:  CALL   248A
....................             printf(lcd_putc, "       HOME 1       \n\r"); 
3E7C:  MOVLW  06
3E7E:  MOVWF  FF6
3E80:  MOVLW  02
3E82:  MOVWF  FF7
3E84:  CALL   248A
....................         break; 
3E88:  MOVLB  3
3E8A:  BRA    3F92
....................         case SOLDAGEM: 
....................             printf(lcd_putc, "\f"); //limpa display 
3E8C:  MOVLW  0C
3E8E:  MOVLB  3
3E90:  MOVWF  xBD
3E92:  MOVLB  0
3E94:  CALL   2436
....................             printf(lcd_putc, "MOVIMENTANDO MAQUINA\n\r"); 
3E98:  MOVLW  1E
3E9A:  MOVWF  FF6
3E9C:  MOVLW  02
3E9E:  MOVWF  FF7
3EA0:  CALL   248A
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
3EA4:  MOVLW  36
3EA6:  MOVWF  FF6
3EA8:  MOVLW  02
3EAA:  MOVWF  FF7
3EAC:  CALL   248A
....................             printf(lcd_putc, "      SOLDAGEM     \n\r"); 
3EB0:  MOVLW  4E
3EB2:  MOVWF  FF6
3EB4:  MOVLW  02
3EB6:  MOVWF  FF7
3EB8:  CALL   248A
....................         break; 
3EBC:  MOVLB  3
3EBE:  BRA    3F92
....................         case HOME2: 
....................             printf(lcd_putc, "\f"); //limpa display 
3EC0:  MOVLW  0C
3EC2:  MOVLB  3
3EC4:  MOVWF  xBD
3EC6:  MOVLB  0
3EC8:  CALL   2436
....................             printf(lcd_putc, "MOVIMENTANDO MAQUINA\n\r"); 
3ECC:  MOVLW  64
3ECE:  MOVWF  FF6
3ED0:  MOVLW  02
3ED2:  MOVWF  FF7
3ED4:  CALL   248A
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
3ED8:  MOVLW  7C
3EDA:  MOVWF  FF6
3EDC:  MOVLW  02
3EDE:  MOVWF  FF7
3EE0:  CALL   248A
....................             printf(lcd_putc, "       HOME 2       \n\r"); 
3EE4:  MOVLW  94
3EE6:  MOVWF  FF6
3EE8:  MOVLW  02
3EEA:  MOVWF  FF7
3EEC:  CALL   248A
....................         break; 
3EF0:  MOVLB  3
3EF2:  BRA    3F92
....................         case DISPENSADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
3EF4:  MOVLW  0C
3EF6:  MOVLB  3
3EF8:  MOVWF  xBD
3EFA:  MOVLB  0
3EFC:  CALL   2436
....................             printf(lcd_putc, "MOVIMENTANDO MAQUINA\n\r"); 
3F00:  MOVLW  AC
3F02:  MOVWF  FF6
3F04:  MOVLW  02
3F06:  MOVWF  FF7
3F08:  CALL   248A
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
3F0C:  MOVLW  C4
3F0E:  MOVWF  FF6
3F10:  MOVLW  02
3F12:  MOVWF  FF7
3F14:  CALL   248A
....................             printf(lcd_putc, "    DISPENSADOR     \n\r"); 
3F18:  MOVLW  DC
3F1A:  MOVWF  FF6
3F1C:  MOVLW  02
3F1E:  MOVWF  FF7
3F20:  CALL   248A
....................         break; 
3F24:  MOVLB  3
3F26:  BRA    3F92
....................         case LIMPEZA: 
....................             printf(lcd_putc, "\f"); //limpa display 
3F28:  MOVLW  0C
3F2A:  MOVLB  3
3F2C:  MOVWF  xBD
3F2E:  MOVLB  0
3F30:  CALL   2436
....................             printf(lcd_putc, "MOVIMENTANDO MAQUINA\n\r"); 
3F34:  MOVLW  F4
3F36:  MOVWF  FF6
3F38:  MOVLW  02
3F3A:  MOVWF  FF7
3F3C:  CALL   248A
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
3F40:  MOVLW  0C
3F42:  MOVWF  FF6
3F44:  MOVLW  03
3F46:  MOVWF  FF7
3F48:  CALL   248A
....................             printf(lcd_putc, "       LIMPEZA      \n\r"); 
3F4C:  MOVLW  24
3F4E:  MOVWF  FF6
3F50:  MOVLW  03
3F52:  MOVWF  FF7
3F54:  CALL   248A
....................         break; 
3F58:  MOVLB  3
3F5A:  BRA    3F92
....................         case LIMPEZA_2: 
....................             printf(lcd_putc, "\f"); //limpa display 
3F5C:  MOVLW  0C
3F5E:  MOVLB  3
3F60:  MOVWF  xBD
3F62:  MOVLB  0
3F64:  CALL   2436
....................             printf(lcd_putc, "MOVIMENTANDO MAQUINA\n\r"); 
3F68:  MOVLW  3C
3F6A:  MOVWF  FF6
3F6C:  MOVLW  03
3F6E:  MOVWF  FF7
3F70:  CALL   248A
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
3F74:  MOVLW  54
3F76:  MOVWF  FF6
3F78:  MOVLW  03
3F7A:  MOVWF  FF7
3F7C:  CALL   248A
....................             printf(lcd_putc, "     LIMPEZA_2      \n\r"); 
3F80:  MOVLW  6C
3F82:  MOVWF  FF6
3F84:  MOVLW  03
3F86:  MOVWF  FF7
3F88:  CALL   248A
....................         break; 
3F8C:  MOVLB  3
3F8E:  BRA    3F92
3F90:  MOVLB  3
....................     } 
3F92:  MOVLB  0
3F94:  RETURN 0
.................... } 
.................... void tela_esperando_mov_maquina(void) { 
....................     printf(lcd_putc, "\f"); //limpa display 
*
5792:  MOVLW  0C
5794:  MOVLB  3
5796:  MOVWF  xBD
5798:  MOVLB  0
579A:  CALL   2436
....................     printf(lcd_putc, "  ESPERANDO MAQUINA \n\r"); 
579E:  MOVLW  84
57A0:  MOVWF  FF6
57A2:  MOVLW  03
57A4:  MOVWF  FF7
57A6:  CALL   248A
....................     printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
57AA:  MOVLW  9C
57AC:  MOVWF  FF6
57AE:  MOVLW  03
57B0:  MOVWF  FF7
57B2:  CALL   248A
....................     printf(lcd_putc, "    PRE-REQUISITO   \n\r"); 
57B6:  MOVLW  B4
57B8:  MOVWF  FF6
57BA:  MOVLW  03
57BC:  MOVWF  FF7
57BE:  CALL   248A
57C2:  RETURN 0
.................... } 
.................... void tela_esperando_mov_outra_maquina(int posicao) { 
....................     switch (posicao){ 
*
3C08:  MOVLB  3
3C0A:  MOVF   xB0,W
3C0C:  ADDLW  F8
3C0E:  BTFSC  FD8.0
3C10:  BRA    3DD8
3C12:  ADDLW  08
3C14:  MOVLB  0
3C16:  GOTO   3DDE
....................         case ALIMENTADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
3C1A:  MOVLW  0C
3C1C:  MOVLB  3
3C1E:  MOVWF  xBD
3C20:  MOVLB  0
3C22:  CALL   2436
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
3C26:  MOVLW  CC
3C28:  MOVWF  FF6
3C2A:  MOVLW  03
3C2C:  MOVWF  FF7
3C2E:  CALL   248A
....................             printf(lcd_putc, "       MAQUINA      \n\r"); 
3C32:  MOVLW  E4
3C34:  MOVWF  FF6
3C36:  MOVLW  03
3C38:  MOVWF  FF7
3C3A:  CALL   248A
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
3C3E:  MOVLW  FC
3C40:  MOVWF  FF6
3C42:  MOVLW  03
3C44:  MOVWF  FF7
3C46:  CALL   248A
....................             printf(lcd_putc, "     ALIMENTADOR    \n\r"); 
3C4A:  MOVLW  14
3C4C:  MOVWF  FF6
3C4E:  MOVLW  04
3C50:  MOVWF  FF7
3C52:  CALL   248A
....................         case HOME1: 
....................             printf(lcd_putc, "\f"); //limpa display 
3C56:  MOVLW  0C
3C58:  MOVLB  3
3C5A:  MOVWF  xBD
3C5C:  MOVLB  0
3C5E:  CALL   2436
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
3C62:  MOVLW  2C
3C64:  MOVWF  FF6
3C66:  MOVLW  04
3C68:  MOVWF  FF7
3C6A:  CALL   248A
....................             printf(lcd_putc, "       MAQUINA      \n\r"); 
3C6E:  MOVLW  44
3C70:  MOVWF  FF6
3C72:  MOVLW  04
3C74:  MOVWF  FF7
3C76:  CALL   248A
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
3C7A:  MOVLW  5C
3C7C:  MOVWF  FF6
3C7E:  MOVLW  04
3C80:  MOVWF  FF7
3C82:  CALL   248A
....................             printf(lcd_putc, "       HOME 1       \n\r"); 
3C86:  MOVLW  74
3C88:  MOVWF  FF6
3C8A:  MOVLW  04
3C8C:  MOVWF  FF7
3C8E:  CALL   248A
....................         break; 
3C92:  MOVLB  3
3C94:  BRA    3DD8
....................         case SOLDAGEM: 
....................             printf(lcd_putc, "\f"); //limpa display 
3C96:  MOVLW  0C
3C98:  MOVLB  3
3C9A:  MOVWF  xBD
3C9C:  MOVLB  0
3C9E:  CALL   2436
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
3CA2:  MOVLW  8C
3CA4:  MOVWF  FF6
3CA6:  MOVLW  04
3CA8:  MOVWF  FF7
3CAA:  CALL   248A
....................             printf(lcd_putc, "       MAQUINA      \n\r"); 
3CAE:  MOVLW  A4
3CB0:  MOVWF  FF6
3CB2:  MOVLW  04
3CB4:  MOVWF  FF7
3CB6:  CALL   248A
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
3CBA:  MOVLW  BC
3CBC:  MOVWF  FF6
3CBE:  MOVLW  04
3CC0:  MOVWF  FF7
3CC2:  CALL   248A
....................             printf(lcd_putc, "     SOLDAGEM 1     \n\r"); 
3CC6:  MOVLW  D4
3CC8:  MOVWF  FF6
3CCA:  MOVLW  04
3CCC:  MOVWF  FF7
3CCE:  CALL   248A
....................         break; 
3CD2:  MOVLB  3
3CD4:  BRA    3DD8
....................         case HOME2: 
....................             printf(lcd_putc, "\f"); //limpa display 
3CD6:  MOVLW  0C
3CD8:  MOVLB  3
3CDA:  MOVWF  xBD
3CDC:  MOVLB  0
3CDE:  CALL   2436
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
3CE2:  MOVLW  EC
3CE4:  MOVWF  FF6
3CE6:  MOVLW  04
3CE8:  MOVWF  FF7
3CEA:  CALL   248A
....................             printf(lcd_putc, "       MAQUINA      \n\r"); 
3CEE:  MOVLW  04
3CF0:  MOVWF  FF6
3CF2:  MOVLW  05
3CF4:  MOVWF  FF7
3CF6:  CALL   248A
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
3CFA:  MOVLW  1C
3CFC:  MOVWF  FF6
3CFE:  MOVLW  05
3D00:  MOVWF  FF7
3D02:  CALL   248A
....................             printf(lcd_putc, "       HOME 2       \n\r"); 
3D06:  MOVLW  34
3D08:  MOVWF  FF6
3D0A:  MOVLW  05
3D0C:  MOVWF  FF7
3D0E:  CALL   248A
....................         break; 
3D12:  MOVLB  3
3D14:  BRA    3DD8
....................         case DISPENSADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
3D16:  MOVLW  0C
3D18:  MOVLB  3
3D1A:  MOVWF  xBD
3D1C:  MOVLB  0
3D1E:  CALL   2436
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
3D22:  MOVLW  4C
3D24:  MOVWF  FF6
3D26:  MOVLW  05
3D28:  MOVWF  FF7
3D2A:  CALL   248A
....................             printf(lcd_putc, "       MAQUINA      \n\r"); 
3D2E:  MOVLW  64
3D30:  MOVWF  FF6
3D32:  MOVLW  05
3D34:  MOVWF  FF7
3D36:  CALL   248A
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
3D3A:  MOVLW  7C
3D3C:  MOVWF  FF6
3D3E:  MOVLW  05
3D40:  MOVWF  FF7
3D42:  CALL   248A
....................             printf(lcd_putc, "     DISPENSADOR    \n\r"); 
3D46:  MOVLW  94
3D48:  MOVWF  FF6
3D4A:  MOVLW  05
3D4C:  MOVWF  FF7
3D4E:  CALL   248A
....................         break; 
3D52:  MOVLB  3
3D54:  BRA    3DD8
....................         case LIMPEZA: 
....................             printf(lcd_putc, "\f"); //limpa display 
3D56:  MOVLW  0C
3D58:  MOVLB  3
3D5A:  MOVWF  xBD
3D5C:  MOVLB  0
3D5E:  CALL   2436
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
3D62:  MOVLW  AC
3D64:  MOVWF  FF6
3D66:  MOVLW  05
3D68:  MOVWF  FF7
3D6A:  CALL   248A
....................             printf(lcd_putc, "       MAQUINA      \n\r"); 
3D6E:  MOVLW  C4
3D70:  MOVWF  FF6
3D72:  MOVLW  05
3D74:  MOVWF  FF7
3D76:  CALL   248A
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
3D7A:  MOVLW  DC
3D7C:  MOVWF  FF6
3D7E:  MOVLW  05
3D80:  MOVWF  FF7
3D82:  CALL   248A
....................             printf(lcd_putc, "       LIMPEZA      \n\r"); 
3D86:  MOVLW  F4
3D88:  MOVWF  FF6
3D8A:  MOVLW  05
3D8C:  MOVWF  FF7
3D8E:  CALL   248A
....................         break; 
3D92:  MOVLB  3
3D94:  BRA    3DD8
....................         case LIMPEZA_2: 
....................             printf(lcd_putc, "\f"); //limpa display 
3D96:  MOVLW  0C
3D98:  MOVLB  3
3D9A:  MOVWF  xBD
3D9C:  MOVLB  0
3D9E:  CALL   2436
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
3DA2:  MOVLW  0C
3DA4:  MOVWF  FF6
3DA6:  MOVLW  06
3DA8:  MOVWF  FF7
3DAA:  CALL   248A
....................             printf(lcd_putc, "       MAQUINA      \n\r"); 
3DAE:  MOVLW  24
3DB0:  MOVWF  FF6
3DB2:  MOVLW  06
3DB4:  MOVWF  FF7
3DB6:  CALL   248A
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
3DBA:  MOVLW  3C
3DBC:  MOVWF  FF6
3DBE:  MOVLW  06
3DC0:  MOVWF  FF7
3DC2:  CALL   248A
....................             printf(lcd_putc, "      LIMPEZA_2     \n\r"); 
3DC6:  MOVLW  54
3DC8:  MOVWF  FF6
3DCA:  MOVLW  06
3DCC:  MOVWF  FF7
3DCE:  CALL   248A
....................         break; 
3DD2:  MOVLB  3
3DD4:  BRA    3DD8
3DD6:  MOVLB  3
....................     } 
3DD8:  MOVLB  0
3DDA:  GOTO   4D0A (RETURN)
.................... } 
.................... void tela_esperando_sair_posicao_outra_maquina(void){ 
....................     printf(lcd_putc, "\f"); //limpa display 
*
57C4:  MOVLW  0C
57C6:  MOVLB  3
57C8:  MOVWF  xBD
57CA:  MOVLB  0
57CC:  CALL   2436
....................     printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
57D0:  MOVLW  6C
57D2:  MOVWF  FF6
57D4:  MOVLW  06
57D6:  MOVWF  FF7
57D8:  CALL   248A
....................     printf(lcd_putc, "       MAQUINA      \n\r"); 
57DC:  MOVLW  84
57DE:  MOVWF  FF6
57E0:  MOVLW  06
57E2:  MOVWF  FF7
57E4:  CALL   248A
....................     printf(lcd_putc, "   SAIR DA POSICAO  \n\r"); 
57E8:  MOVLW  9C
57EA:  MOVWF  FF6
57EC:  MOVLW  06
57EE:  MOVWF  FF7
57F0:  CALL   248A
....................     printf(lcd_putc, "        ATUAL       \n\r"); 
57F4:  MOVLW  B4
57F6:  MOVWF  FF6
57F8:  MOVLW  06
57FA:  MOVWF  FF7
57FC:  CALL   248A
5800:  RETURN 0
.................... } 
....................  
.................... void tela_principal() { 
....................     printf(lcd_putc, "\f"); // limpa display 
*
4EC4:  MOVLW  0C
4EC6:  MOVLB  3
4EC8:  MOVWF  xBD
4ECA:  MOVLB  0
4ECC:  CALL   2436
....................     printf(lcd_putc, " SOLDADOR AUTOMATICO\n\r"); 
4ED0:  MOVLW  CC
4ED2:  MOVWF  FF6
4ED4:  MOVLW  06
4ED6:  MOVWF  FF7
4ED8:  CALL   248A
....................     printf(lcd_putc, "      MODELO:%02u   \n\r",modelo); 
4EDC:  MOVLW  E4
4EDE:  MOVWF  FF6
4EE0:  MOVLW  06
4EE2:  MOVWF  FF7
4EE4:  MOVLW  0D
4EE6:  MOVLB  3
4EE8:  MOVWF  xB4
4EEA:  MOVLB  0
4EEC:  RCALL  4DEC
4EEE:  MOVFF  2D,3B1
4EF2:  MOVLW  01
4EF4:  MOVLB  3
4EF6:  MOVWF  xB2
4EF8:  MOVLB  0
4EFA:  RCALL  4E42
4EFC:  MOVLW  F5
4EFE:  MOVWF  FF6
4F00:  MOVLW  06
4F02:  MOVWF  FF7
4F04:  MOVLW  05
4F06:  MOVLB  3
4F08:  MOVWF  xB4
4F0A:  MOVLB  0
4F0C:  RCALL  4DEC
....................     printf(lcd_putc, "^/?:MODELO|MENU:DBUG\n\r"); 
4F0E:  MOVLW  FC
4F10:  MOVWF  FF6
4F12:  MOVLW  06
4F14:  MOVWF  FF7
4F16:  CALL   248A
....................     printf(lcd_putc, "     ENTER:MAIN     \n\r"); 
4F1A:  MOVLW  14
4F1C:  MOVWF  FF6
4F1E:  MOVLW  07
4F20:  MOVWF  FF7
4F22:  CALL   248A
4F26:  RETURN 0
.................... } 
.................... void tela_seleciona_maquina(){ 
....................     printf(lcd_putc, "\f"); 
*
54D4:  MOVLW  0C
54D6:  MOVLB  3
54D8:  MOVWF  xBD
54DA:  MOVLB  0
54DC:  CALL   2436
....................     printf(lcd_putc, " SELECIONE A MAQUINA\n\r"); 
54E0:  MOVLW  2C
54E2:  MOVWF  FF6
54E4:  MOVLW  07
54E6:  MOVWF  FF7
54E8:  CALL   248A
....................     printf(lcd_putc, "    F1: MAQUINA 1   \n\r"); 
54EC:  MOVLW  44
54EE:  MOVWF  FF6
54F0:  MOVLW  07
54F2:  MOVWF  FF7
54F4:  CALL   248A
....................     printf(lcd_putc, "    F2: MAQUINA 2   \n\r"); 
54F8:  MOVLW  5C
54FA:  MOVWF  FF6
54FC:  MOVLW  07
54FE:  MOVWF  FF7
5500:  CALL   248A
....................     printf(lcd_putc, "    ESC:BACK        \n\r"); 
5504:  MOVLW  74
5506:  MOVWF  FF6
5508:  MOVLW  07
550A:  MOVWF  FF7
550C:  CALL   248A
5510:  RETURN 0
.................... } 
.................... void tela_manutencao_outra_maquina() { 
....................     printf(lcd_putc, "\f"); // limpa display 
*
63CA:  MOVLW  0C
63CC:  MOVLB  3
63CE:  MOVWF  xBD
63D0:  MOVLB  0
63D2:  CALL   2436
....................     printf(lcd_putc, "     MANUTENCAO     \n\r"); 
63D6:  MOVLW  8C
63D8:  MOVWF  FF6
63DA:  MOVLW  07
63DC:  MOVWF  FF7
63DE:  CALL   248A
....................     printf(lcd_putc, "      MAQUINA 2     \n\r"); 
63E2:  MOVLW  A4
63E4:  MOVWF  FF6
63E6:  MOVLW  07
63E8:  MOVWF  FF7
63EA:  CALL   248A
....................     printf(lcd_putc, "                    \n\r"); 
63EE:  MOVLW  BC
63F0:  MOVWF  FF6
63F2:  MOVLW  07
63F4:  MOVWF  FF7
63F6:  CALL   248A
....................     printf(lcd_putc, "      ESC:BACK      \n\r"); 
63FA:  MOVLW  D4
63FC:  MOVWF  FF6
63FE:  MOVLW  07
6400:  MOVWF  FF7
6402:  CALL   248A
6406:  GOTO   6436 (RETURN)
.................... } 
.................... void tela_edita_modelo(){ 
....................     printf(lcd_putc, "\f"); 
*
55FA:  MOVLW  0C
55FC:  MOVLB  3
55FE:  MOVWF  xBD
5600:  MOVLB  0
5602:  CALL   2436
....................     printf(lcd_putc, "    ESCOLHER ACAO   \n\r"); 
5606:  MOVLW  EC
5608:  MOVWF  FF6
560A:  MOVLW  07
560C:  MOVWF  FF7
560E:  CALL   248A
....................     printf(lcd_putc, "  F1: EDITAR MODELO \n\r"); 
5612:  MOVLW  04
5614:  MOVWF  FF6
5616:  MOVLW  08
5618:  MOVWF  FF7
561A:  CALL   248A
....................     printf(lcd_putc, "  F2: EXCLUI MODELO \n\r"); 
561E:  MOVLW  1C
5620:  MOVWF  FF6
5622:  MOVLW  08
5624:  MOVWF  FF7
5626:  CALL   248A
....................     printf(lcd_putc, "  ESC:BACK          \n\r"); 
562A:  MOVLW  34
562C:  MOVWF  FF6
562E:  MOVLW  08
5630:  MOVWF  FF7
5632:  CALL   248A
5636:  RETURN 0
.................... } 
.................... void tela_seleciona_debug(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
6468:  MOVLW  0C
646A:  MOVLB  3
646C:  MOVWF  xBD
646E:  MOVLB  0
6470:  CALL   2436
....................     printf(lcd_putc, "  F1: EDITAR PONTOS \n\r"); 
6474:  MOVLW  4C
6476:  MOVWF  FF6
6478:  MOVLW  08
647A:  MOVWF  FF7
647C:  CALL   248A
....................     printf(lcd_putc, "  F2: MANUTENCAO    \n\r"); 
6480:  MOVLW  64
6482:  MOVWF  FF6
6484:  MOVLW  08
6486:  MOVWF  FF7
6488:  CALL   248A
....................     printf(lcd_putc, "  F3: QNT_PONTOS    \n\r"); 
648C:  MOVLW  7C
648E:  MOVWF  FF6
6490:  MOVLW  08
6492:  MOVWF  FF7
6494:  CALL   248A
....................     printf(lcd_putc, "  ESC:BACK          \n\r"); 
6498:  MOVLW  94
649A:  MOVWF  FF6
649C:  MOVLW  08
649E:  MOVWF  FF7
64A0:  CALL   248A
64A4:  RETURN 0
.................... } 
.................... void tela_edita_pontos_no_modelo(){ 
....................     printf(lcd_putc, "\f"); 
*
6660:  MOVLW  0C
6662:  MOVLB  3
6664:  MOVWF  xBD
6666:  MOVLB  0
6668:  CALL   2436
....................     printf(lcd_putc, "  PONTOS NO MODELO  \n\r"); 
666C:  MOVLW  AC
666E:  MOVWF  FF6
6670:  MOVLW  08
6672:  MOVWF  FF7
6674:  CALL   248A
....................     printf(lcd_putc, "         %02u       \n\r",pontos_no_modelo); 
6678:  MOVLW  C4
667A:  MOVWF  FF6
667C:  MOVLW  08
667E:  MOVWF  FF7
6680:  MOVLW  09
6682:  MOVLB  3
6684:  MOVWF  xB4
6686:  MOVLB  0
6688:  CALL   4DEC
668C:  MOVFF  10A,3B1
6690:  MOVLW  01
6692:  MOVLB  3
6694:  MOVWF  xB2
6696:  MOVLB  0
6698:  CALL   4E42
669C:  MOVLW  D1
669E:  MOVWF  FF6
66A0:  MOVLW  08
66A2:  MOVWF  FF7
66A4:  MOVLW  09
66A6:  MOVLB  3
66A8:  MOVWF  xB4
66AA:  MOVLB  0
66AC:  CALL   4DEC
....................     printf(lcd_putc, "    ?/?:N_PONTOS   \n\r"); 
66B0:  MOVLW  DC
66B2:  MOVWF  FF6
66B4:  MOVLW  08
66B6:  MOVWF  FF7
66B8:  CALL   248A
....................     printf(lcd_putc, " ENTER:SAVE|ESC:BACK\n\r"); 
66BC:  MOVLW  F2
66BE:  MOVWF  FF6
66C0:  MOVLW  08
66C2:  MOVWF  FF7
66C4:  CALL   248A
66C8:  RETURN 0
.................... } 
.................... void tela_excluir_modelo(){ 
....................     printf(lcd_putc, "\f"); 
*
64A6:  MOVLW  0C
64A8:  MOVLB  3
64AA:  MOVWF  xBD
64AC:  MOVLB  0
64AE:  CALL   2436
....................     printf(lcd_putc, "   DESEJA EXCLUIR   \n\r"); 
64B2:  MOVLW  0A
64B4:  MOVWF  FF6
64B6:  MOVLW  09
64B8:  MOVWF  FF7
64BA:  CALL   248A
....................     printf(lcd_putc, "     O MODELO ?     \n\r"); 
64BE:  MOVLW  22
64C0:  MOVWF  FF6
64C2:  MOVLW  09
64C4:  MOVWF  FF7
64C6:  CALL   248A
....................     printf(lcd_putc, "      ENTER=OK      \n\r"); 
64CA:  MOVLW  3A
64CC:  MOVWF  FF6
64CE:  MOVLW  09
64D0:  MOVWF  FF7
64D2:  CALL   248A
....................     printf(lcd_putc, "    ESC:NO/BACK     \n\r"); 
64D6:  MOVLW  52
64D8:  MOVWF  FF6
64DA:  MOVLW  09
64DC:  MOVWF  FF7
64DE:  CALL   248A
64E2:  GOTO   6512 (RETURN)
.................... } 
.................... void tela_seleciona_pontos(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
6526:  MOVLW  0C
6528:  MOVLB  3
652A:  MOVWF  xBD
652C:  MOVLB  0
652E:  CALL   2436
....................     printf(lcd_putc, "P%02u         ENT=EDIT\n\r",inicial_lcd); 
6532:  MOVLW  50
6534:  MOVLB  3
6536:  MOVWF  xBD
6538:  MOVLB  0
653A:  CALL   2436
653E:  MOVFF  22,3B1
6542:  MOVLW  01
6544:  MOVLB  3
6546:  MOVWF  xB2
6548:  MOVLB  0
654A:  CALL   4E42
654E:  MOVLW  6F
6550:  MOVWF  FF6
6552:  MOVLW  09
6554:  MOVWF  FF7
6556:  MOVLW  13
6558:  MOVLB  3
655A:  MOVWF  xB4
655C:  MOVLB  0
655E:  CALL   4DEC
....................     printf(lcd_putc, "P%02u         ESC=BACK\n\r",inicial_lcd+1); 
6562:  MOVLW  01
6564:  ADDWF  22,W
6566:  MOVLB  3
6568:  MOVWF  xAD
656A:  MOVLW  50
656C:  MOVWF  xBD
656E:  MOVLB  0
6570:  CALL   2436
6574:  MOVFF  3AD,3B1
6578:  MOVLW  01
657A:  MOVLB  3
657C:  MOVWF  xB2
657E:  MOVLB  0
6580:  CALL   4E42
6584:  MOVLW  89
6586:  MOVWF  FF6
6588:  MOVLW  09
658A:  MOVWF  FF7
658C:  MOVLW  13
658E:  MOVLB  3
6590:  MOVWF  xB4
6592:  MOVLB  0
6594:  CALL   4DEC
....................     printf(lcd_putc, "P%02u                 \n\r",inicial_lcd+2); 
6598:  MOVLW  02
659A:  ADDWF  22,W
659C:  MOVLB  3
659E:  MOVWF  xAD
65A0:  MOVLW  50
65A2:  MOVWF  xBD
65A4:  MOVLB  0
65A6:  CALL   2436
65AA:  MOVFF  3AD,3B1
65AE:  MOVLW  01
65B0:  MOVLB  3
65B2:  MOVWF  xB2
65B4:  MOVLB  0
65B6:  CALL   4E42
65BA:  MOVLW  A3
65BC:  MOVWF  FF6
65BE:  MOVLW  09
65C0:  MOVWF  FF7
65C2:  MOVLW  13
65C4:  MOVLB  3
65C6:  MOVWF  xB4
65C8:  MOVLB  0
65CA:  CALL   4DEC
....................     printf(lcd_putc, "P%02u                 \n\r",inicial_lcd+3); 
65CE:  MOVLW  03
65D0:  ADDWF  22,W
65D2:  MOVLB  3
65D4:  MOVWF  xAD
65D6:  MOVLW  50
65D8:  MOVWF  xBD
65DA:  MOVLB  0
65DC:  CALL   2436
65E0:  MOVFF  3AD,3B1
65E4:  MOVLW  01
65E6:  MOVLB  3
65E8:  MOVWF  xB2
65EA:  MOVLB  0
65EC:  CALL   4E42
65F0:  MOVLW  BD
65F2:  MOVWF  FF6
65F4:  MOVLW  09
65F6:  MOVWF  FF7
65F8:  MOVLW  13
65FA:  MOVLB  3
65FC:  MOVWF  xB4
65FE:  MOVLB  0
6600:  CALL   4DEC
....................     posiciona_cursor(ponteiro_lcd,5); 
6604:  MOVFF  21,3BE
6608:  MOVLW  05
660A:  MOVLB  3
660C:  MOVWF  xBF
660E:  MOVLB  0
6610:  CALL   2290
....................     printf(lcd_putc,"<"); 
6614:  MOVLW  3C
6616:  MOVLB  3
6618:  MOVWF  xBD
661A:  MOVLB  0
661C:  CALL   2436
6620:  RETURN 0
.................... } 
.................... void tela_dados_ponto (contador_lcd){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
68A8:  MOVLW  0C
68AA:  MOVLB  3
68AC:  MOVWF  xBD
68AE:  MOVLB  0
68B0:  CALL   2436
....................     printf(lcd_putc, "X:%04Lu Y:%04Lu Z:%04Lu\n\r",x[contador_lcd],y[contador_lcd],z[contador_lcd]); 
68B4:  BCF    FD8.0
68B6:  MOVLB  3
68B8:  RLCF   xAD,W
68BA:  CLRF   03
68BC:  ADDLW  2E
68BE:  MOVWF  FE9
68C0:  MOVLW  00
68C2:  ADDWFC 03,W
68C4:  MOVWF  FEA
68C6:  MOVFF  FEC,3AF
68CA:  MOVF   FED,F
68CC:  MOVFF  FEF,3AE
68D0:  BCF    FD8.0
68D2:  RLCF   xAD,W
68D4:  CLRF   03
68D6:  ADDLW  56
68D8:  MOVWF  FE9
68DA:  MOVLW  00
68DC:  ADDWFC 03,W
68DE:  MOVWF  FEA
68E0:  MOVFF  FEC,3B1
68E4:  MOVF   FED,F
68E6:  MOVFF  FEF,3B0
68EA:  BCF    FD8.0
68EC:  RLCF   xAD,W
68EE:  CLRF   03
68F0:  ADDLW  7E
68F2:  MOVWF  FE9
68F4:  MOVLW  00
68F6:  ADDWFC 03,W
68F8:  MOVWF  FEA
68FA:  MOVFF  FEC,3B3
68FE:  MOVF   FED,F
6900:  MOVFF  FEF,3B2
6904:  MOVLW  58
6906:  MOVWF  xBD
6908:  MOVLB  0
690A:  CALL   2436
690E:  MOVLW  3A
6910:  MOVLB  3
6912:  MOVWF  xBD
6914:  MOVLB  0
6916:  CALL   2436
691A:  MOVLW  09
691C:  MOVWF  FE9
691E:  MOVFF  3AF,3B5
6922:  MOVFF  3AE,3B4
6926:  RCALL  67EA
6928:  MOVLW  D9
692A:  MOVWF  FF6
692C:  MOVLW  09
692E:  MOVWF  FF7
6930:  MOVLW  03
6932:  MOVLB  3
6934:  MOVWF  xB4
6936:  MOVLB  0
6938:  CALL   4DEC
693C:  MOVLW  09
693E:  MOVWF  FE9
6940:  MOVFF  3B1,3B5
6944:  MOVFF  3B0,3B4
6948:  RCALL  67EA
694A:  MOVLW  E1
694C:  MOVWF  FF6
694E:  MOVLW  09
6950:  MOVWF  FF7
6952:  MOVLW  03
6954:  MOVLB  3
6956:  MOVWF  xB4
6958:  MOVLB  0
695A:  CALL   4DEC
695E:  MOVLW  09
6960:  MOVWF  FE9
6962:  MOVFF  3B3,3B5
6966:  MOVFF  3B2,3B4
696A:  RCALL  67EA
696C:  MOVLW  0A
696E:  MOVLB  3
6970:  MOVWF  xBD
6972:  MOVLB  0
6974:  CALL   2436
6978:  MOVLW  0D
697A:  MOVLB  3
697C:  MOVWF  xBD
697E:  MOVLB  0
6980:  CALL   2436
....................     printf(lcd_putc, "  T_S:%04Lu T_E:%04Lu \n\r",t_solda[contador_lcd],t_wait[contador_lcd]); 
6984:  BCF    FD8.0
6986:  MOVLB  3
6988:  RLCF   xAD,W
698A:  CLRF   03
698C:  ADDLW  A6
698E:  MOVWF  FE9
6990:  MOVLW  00
6992:  ADDWFC 03,W
6994:  MOVWF  FEA
6996:  MOVFF  FEC,3AF
699A:  MOVF   FED,F
699C:  MOVFF  FEF,3AE
69A0:  BCF    FD8.0
69A2:  RLCF   xAD,W
69A4:  CLRF   03
69A6:  ADDLW  CE
69A8:  MOVWF  FE9
69AA:  MOVLW  00
69AC:  ADDWFC 03,W
69AE:  MOVWF  FEA
69B0:  MOVFF  FEC,3B1
69B4:  MOVF   FED,F
69B6:  MOVFF  FEF,3B0
69BA:  MOVLW  EC
69BC:  MOVWF  FF6
69BE:  MOVLW  09
69C0:  MOVWF  FF7
69C2:  MOVLW  06
69C4:  MOVWF  xB4
69C6:  MOVLB  0
69C8:  CALL   4DEC
69CC:  MOVLW  09
69CE:  MOVWF  FE9
69D0:  MOVFF  3AF,3B5
69D4:  MOVFF  3AE,3B4
69D8:  RCALL  67EA
69DA:  MOVLW  F7
69DC:  MOVWF  FF6
69DE:  MOVLW  09
69E0:  MOVWF  FF7
69E2:  MOVLW  05
69E4:  MOVLB  3
69E6:  MOVWF  xB4
69E8:  MOVLB  0
69EA:  CALL   4DEC
69EE:  MOVLW  09
69F0:  MOVWF  FE9
69F2:  MOVFF  3B1,3B5
69F6:  MOVFF  3B0,3B4
69FA:  RCALL  67EA
69FC:  MOVLW  01
69FE:  MOVWF  FF6
6A00:  MOVLW  0A
6A02:  MOVWF  FF7
6A04:  MOVLW  03
6A06:  MOVLB  3
6A08:  MOVWF  xB4
6A0A:  MOVLB  0
6A0C:  CALL   4DEC
....................     printf(lcd_putc, "   TIPO:%02u HAB:%02u   \n\r",tipo[contador_lcd],habilitado[contador_lcd]); 
6A10:  CLRF   03
6A12:  MOVLB  3
6A14:  MOVF   xAD,W
6A16:  ADDLW  F6
6A18:  MOVWF  FE9
6A1A:  MOVLW  00
6A1C:  ADDWFC 03,W
6A1E:  MOVWF  FEA
6A20:  MOVFF  FEF,3AE
6A24:  MOVFF  3AD,3B5
6A28:  MOVLW  01
6A2A:  MOVWF  xB7
6A2C:  MOVLW  0B
6A2E:  MOVWF  xB6
6A30:  MOVLB  0
6A32:  CALL   3A5C
6A36:  MOVLW  00
6A38:  BTFSC  01.0
6A3A:  MOVLW  01
6A3C:  MOVLB  3
6A3E:  MOVWF  xAF
6A40:  MOVLW  06
6A42:  MOVWF  FF6
6A44:  MOVLW  0A
6A46:  MOVWF  FF7
6A48:  MOVLW  08
6A4A:  MOVWF  xB4
6A4C:  MOVLB  0
6A4E:  CALL   4DEC
6A52:  MOVFF  3AE,3B1
6A56:  MOVLW  01
6A58:  MOVLB  3
6A5A:  MOVWF  xB2
6A5C:  MOVLB  0
6A5E:  CALL   4E42
6A62:  MOVLW  12
6A64:  MOVWF  FF6
6A66:  MOVLW  0A
6A68:  MOVWF  FF7
6A6A:  MOVLW  05
6A6C:  MOVLB  3
6A6E:  MOVWF  xB4
6A70:  MOVLB  0
6A72:  CALL   4DEC
6A76:  MOVFF  3AF,3B1
6A7A:  MOVLW  01
6A7C:  MOVLB  3
6A7E:  MOVWF  xB2
6A80:  MOVLB  0
6A82:  CALL   4E42
6A86:  MOVLW  1B
6A88:  MOVWF  FF6
6A8A:  MOVLW  0A
6A8C:  MOVWF  FF7
6A8E:  MOVLW  05
6A90:  MOVLB  3
6A92:  MOVWF  xB4
6A94:  MOVLB  0
6A96:  CALL   4DEC
....................     printf(lcd_putc, "F1:GRAVA|ENTER:TESTE\n\r"); 
6A9A:  MOVLW  22
6A9C:  MOVWF  FF6
6A9E:  MOVLW  0A
6AA0:  MOVWF  FF7
6AA2:  CALL   248A
6AA6:  RETURN 0
.................... } 
....................  
.................... void tela_seleciona_manutencao(){ 
....................     printf(lcd_putc, "\f"); 
*
6622:  MOVLW  0C
6624:  MOVLB  3
6626:  MOVWF  xBD
6628:  MOVLB  0
662A:  CALL   2436
....................     printf(lcd_putc, " F1: DEBUG ENTRADAS \n\r"); 
662E:  MOVLW  3A
6630:  MOVWF  FF6
6632:  MOVLW  0A
6634:  MOVWF  FF7
6636:  CALL   248A
....................     printf(lcd_putc, " F2:  DEBUG SAIDAS  \n\r"); 
663A:  MOVLW  52
663C:  MOVWF  FF6
663E:  MOVLW  0A
6640:  MOVWF  FF7
6642:  CALL   248A
....................     printf(lcd_putc, "                    \n\r"); 
6646:  MOVLW  6A
6648:  MOVWF  FF6
664A:  MOVLW  0A
664C:  MOVWF  FF7
664E:  CALL   248A
....................     printf(lcd_putc, "      ESC:BACK      \n\r"); 
6652:  MOVLW  82
6654:  MOVWF  FF6
6656:  MOVLW  0A
6658:  MOVWF  FF7
665A:  CALL   248A
665E:  RETURN 0
.................... } 
.................... void tela_debug_entrada_1 (){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
857A:  MOVLW  0C
857C:  MOVLB  3
857E:  MOVWF  xBD
8580:  MOVLB  0
8582:  CALL   2436
....................     printf(lcd_putc, "E00:%02u E01:%02u E02:%02u\n\r", entradas[0], entradas[1], entradas[2]); 
8586:  MOVLW  00
8588:  BTFSC  1D.0
858A:  MOVLW  01
858C:  MOVLB  3
858E:  MOVWF  xAE
8590:  MOVLW  00
8592:  BTFSC  1D.1
8594:  MOVLW  01
8596:  MOVWF  xAF
8598:  MOVLW  00
859A:  BTFSC  1D.2
859C:  MOVLW  01
859E:  MOVWF  xB0
85A0:  MOVLW  9A
85A2:  MOVWF  FF6
85A4:  MOVLW  0A
85A6:  MOVWF  FF7
85A8:  MOVLW  04
85AA:  MOVWF  xB4
85AC:  MOVLB  0
85AE:  CALL   4DEC
85B2:  MOVFF  3AE,3B1
85B6:  MOVLW  01
85B8:  MOVLB  3
85BA:  MOVWF  xB2
85BC:  MOVLB  0
85BE:  CALL   4E42
85C2:  MOVLW  A2
85C4:  MOVWF  FF6
85C6:  MOVLW  0A
85C8:  MOVWF  FF7
85CA:  MOVLW  05
85CC:  MOVLB  3
85CE:  MOVWF  xB4
85D0:  MOVLB  0
85D2:  CALL   4DEC
85D6:  MOVFF  3AF,3B1
85DA:  MOVLW  01
85DC:  MOVLB  3
85DE:  MOVWF  xB2
85E0:  MOVLB  0
85E2:  CALL   4E42
85E6:  MOVLW  AB
85E8:  MOVWF  FF6
85EA:  MOVLW  0A
85EC:  MOVWF  FF7
85EE:  MOVLW  05
85F0:  MOVLB  3
85F2:  MOVWF  xB4
85F4:  MOVLB  0
85F6:  CALL   4DEC
85FA:  MOVFF  3B0,3B1
85FE:  MOVLW  01
8600:  MOVLB  3
8602:  MOVWF  xB2
8604:  MOVLB  0
8606:  CALL   4E42
860A:  MOVLW  0A
860C:  MOVLB  3
860E:  MOVWF  xBD
8610:  MOVLB  0
8612:  CALL   2436
8616:  MOVLW  0D
8618:  MOVLB  3
861A:  MOVWF  xBD
861C:  MOVLB  0
861E:  CALL   2436
....................     printf(lcd_putc, "E03:%02u E04:%02u E05:%02u\n\r", entradas[3], entradas[4], entradas[5]); 
8622:  MOVLW  00
8624:  BTFSC  1D.3
8626:  MOVLW  01
8628:  MOVLB  3
862A:  MOVWF  xAE
862C:  MOVLW  00
862E:  BTFSC  1D.4
8630:  MOVLW  01
8632:  MOVWF  xAF
8634:  MOVLW  00
8636:  BTFSC  1D.5
8638:  MOVLW  01
863A:  MOVWF  xB0
863C:  MOVLW  B8
863E:  MOVWF  FF6
8640:  MOVLW  0A
8642:  MOVWF  FF7
8644:  MOVLW  04
8646:  MOVWF  xB4
8648:  MOVLB  0
864A:  CALL   4DEC
864E:  MOVFF  3AE,3B1
8652:  MOVLW  01
8654:  MOVLB  3
8656:  MOVWF  xB2
8658:  MOVLB  0
865A:  CALL   4E42
865E:  MOVLW  C0
8660:  MOVWF  FF6
8662:  MOVLW  0A
8664:  MOVWF  FF7
8666:  MOVLW  05
8668:  MOVLB  3
866A:  MOVWF  xB4
866C:  MOVLB  0
866E:  CALL   4DEC
8672:  MOVFF  3AF,3B1
8676:  MOVLW  01
8678:  MOVLB  3
867A:  MOVWF  xB2
867C:  MOVLB  0
867E:  CALL   4E42
8682:  MOVLW  C9
8684:  MOVWF  FF6
8686:  MOVLW  0A
8688:  MOVWF  FF7
868A:  MOVLW  05
868C:  MOVLB  3
868E:  MOVWF  xB4
8690:  MOVLB  0
8692:  CALL   4DEC
8696:  MOVFF  3B0,3B1
869A:  MOVLW  01
869C:  MOVLB  3
869E:  MOVWF  xB2
86A0:  MOVLB  0
86A2:  CALL   4E42
86A6:  MOVLW  0A
86A8:  MOVLB  3
86AA:  MOVWF  xBD
86AC:  MOVLB  0
86AE:  CALL   2436
86B2:  MOVLW  0D
86B4:  MOVLB  3
86B6:  MOVWF  xBD
86B8:  MOVLB  0
86BA:  CALL   2436
....................     printf(lcd_putc, "E06:%02u E07:%02u E08:%02u\n\r", entradas[6], entradas[7], entradas[8]);     
86BE:  MOVLW  00
86C0:  BTFSC  1D.6
86C2:  MOVLW  01
86C4:  MOVLB  3
86C6:  MOVWF  xAE
86C8:  MOVLW  00
86CA:  BTFSC  1D.7
86CC:  MOVLW  01
86CE:  MOVWF  xAF
86D0:  MOVLW  00
86D2:  BTFSC  1E.0
86D4:  MOVLW  01
86D6:  MOVWF  xB0
86D8:  MOVLW  D6
86DA:  MOVWF  FF6
86DC:  MOVLW  0A
86DE:  MOVWF  FF7
86E0:  MOVLW  04
86E2:  MOVWF  xB4
86E4:  MOVLB  0
86E6:  CALL   4DEC
86EA:  MOVFF  3AE,3B1
86EE:  MOVLW  01
86F0:  MOVLB  3
86F2:  MOVWF  xB2
86F4:  MOVLB  0
86F6:  CALL   4E42
86FA:  MOVLW  DE
86FC:  MOVWF  FF6
86FE:  MOVLW  0A
8700:  MOVWF  FF7
8702:  MOVLW  05
8704:  MOVLB  3
8706:  MOVWF  xB4
8708:  MOVLB  0
870A:  CALL   4DEC
870E:  MOVFF  3AF,3B1
8712:  MOVLW  01
8714:  MOVLB  3
8716:  MOVWF  xB2
8718:  MOVLB  0
871A:  CALL   4E42
871E:  MOVLW  E7
8720:  MOVWF  FF6
8722:  MOVLW  0A
8724:  MOVWF  FF7
8726:  MOVLW  05
8728:  MOVLB  3
872A:  MOVWF  xB4
872C:  MOVLB  0
872E:  CALL   4DEC
8732:  MOVFF  3B0,3B1
8736:  MOVLW  01
8738:  MOVLB  3
873A:  MOVWF  xB2
873C:  MOVLB  0
873E:  CALL   4E42
8742:  MOVLW  0A
8744:  MOVLB  3
8746:  MOVWF  xBD
8748:  MOVLB  0
874A:  CALL   2436
874E:  MOVLW  0D
8750:  MOVLB  3
8752:  MOVWF  xBD
8754:  MOVLB  0
8756:  CALL   2436
....................     printf(lcd_putc, "   >:PROX|ESC:BACK  \n\r"); 
875A:  MOVLW  F4
875C:  MOVWF  FF6
875E:  MOVLW  0A
8760:  MOVWF  FF7
8762:  CALL   248A
8766:  RETURN 0
.................... } 
.................... void tela_debug_entrada_2 (){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
87F2:  MOVLW  0C
87F4:  MOVLB  3
87F6:  MOVWF  xBD
87F8:  MOVLB  0
87FA:  CALL   2436
....................     printf(lcd_putc, "E09:%02u E10:%02u E11:%02u\n\r", entradas[9], entradas[10], entradas[11]); 
87FE:  MOVLW  00
8800:  BTFSC  1E.1
8802:  MOVLW  01
8804:  MOVLB  3
8806:  MOVWF  xAE
8808:  MOVLW  00
880A:  BTFSC  1E.2
880C:  MOVLW  01
880E:  MOVWF  xAF
8810:  MOVLW  00
8812:  BTFSC  1E.3
8814:  MOVLW  01
8816:  MOVWF  xB0
8818:  MOVLW  0C
881A:  MOVWF  FF6
881C:  MOVLW  0B
881E:  MOVWF  FF7
8820:  MOVLW  04
8822:  MOVWF  xB4
8824:  MOVLB  0
8826:  CALL   4DEC
882A:  MOVFF  3AE,3B1
882E:  MOVLW  01
8830:  MOVLB  3
8832:  MOVWF  xB2
8834:  MOVLB  0
8836:  CALL   4E42
883A:  MOVLW  14
883C:  MOVWF  FF6
883E:  MOVLW  0B
8840:  MOVWF  FF7
8842:  MOVLW  05
8844:  MOVLB  3
8846:  MOVWF  xB4
8848:  MOVLB  0
884A:  CALL   4DEC
884E:  MOVFF  3AF,3B1
8852:  MOVLW  01
8854:  MOVLB  3
8856:  MOVWF  xB2
8858:  MOVLB  0
885A:  CALL   4E42
885E:  MOVLW  1D
8860:  MOVWF  FF6
8862:  MOVLW  0B
8864:  MOVWF  FF7
8866:  MOVLW  05
8868:  MOVLB  3
886A:  MOVWF  xB4
886C:  MOVLB  0
886E:  CALL   4DEC
8872:  MOVFF  3B0,3B1
8876:  MOVLW  01
8878:  MOVLB  3
887A:  MOVWF  xB2
887C:  MOVLB  0
887E:  CALL   4E42
8882:  MOVLW  0A
8884:  MOVLB  3
8886:  MOVWF  xBD
8888:  MOVLB  0
888A:  CALL   2436
888E:  MOVLW  0D
8890:  MOVLB  3
8892:  MOVWF  xBD
8894:  MOVLB  0
8896:  CALL   2436
....................     printf(lcd_putc, "E12:%02u E13:%02u E14:%02u\n\r", entradas[12], entradas[13], entradas[14]); 
889A:  MOVLW  00
889C:  BTFSC  1E.4
889E:  MOVLW  01
88A0:  MOVLB  3
88A2:  MOVWF  xAE
88A4:  MOVLW  00
88A6:  BTFSC  1E.5
88A8:  MOVLW  01
88AA:  MOVWF  xAF
88AC:  MOVLW  00
88AE:  BTFSC  1E.6
88B0:  MOVLW  01
88B2:  MOVWF  xB0
88B4:  MOVLW  2A
88B6:  MOVWF  FF6
88B8:  MOVLW  0B
88BA:  MOVWF  FF7
88BC:  MOVLW  04
88BE:  MOVWF  xB4
88C0:  MOVLB  0
88C2:  CALL   4DEC
88C6:  MOVFF  3AE,3B1
88CA:  MOVLW  01
88CC:  MOVLB  3
88CE:  MOVWF  xB2
88D0:  MOVLB  0
88D2:  CALL   4E42
88D6:  MOVLW  32
88D8:  MOVWF  FF6
88DA:  MOVLW  0B
88DC:  MOVWF  FF7
88DE:  MOVLW  05
88E0:  MOVLB  3
88E2:  MOVWF  xB4
88E4:  MOVLB  0
88E6:  CALL   4DEC
88EA:  MOVFF  3AF,3B1
88EE:  MOVLW  01
88F0:  MOVLB  3
88F2:  MOVWF  xB2
88F4:  MOVLB  0
88F6:  CALL   4E42
88FA:  MOVLW  3B
88FC:  MOVWF  FF6
88FE:  MOVLW  0B
8900:  MOVWF  FF7
8902:  MOVLW  05
8904:  MOVLB  3
8906:  MOVWF  xB4
8908:  MOVLB  0
890A:  CALL   4DEC
890E:  MOVFF  3B0,3B1
8912:  MOVLW  01
8914:  MOVLB  3
8916:  MOVWF  xB2
8918:  MOVLB  0
891A:  CALL   4E42
891E:  MOVLW  0A
8920:  MOVLB  3
8922:  MOVWF  xBD
8924:  MOVLB  0
8926:  CALL   2436
892A:  MOVLW  0D
892C:  MOVLB  3
892E:  MOVWF  xBD
8930:  MOVLB  0
8932:  CALL   2436
....................     printf(lcd_putc, "E15:%02u E16:%02u E17:%02u\n\r", entradas[15], entradas[16], entradas[17]);     
8936:  MOVLW  00
8938:  BTFSC  1E.7
893A:  MOVLW  01
893C:  MOVLB  3
893E:  MOVWF  xAE
8940:  MOVLW  00
8942:  BTFSC  1F.0
8944:  MOVLW  01
8946:  MOVWF  xAF
8948:  MOVLW  00
894A:  BTFSC  1F.1
894C:  MOVLW  01
894E:  MOVWF  xB0
8950:  MOVLW  48
8952:  MOVWF  FF6
8954:  MOVLW  0B
8956:  MOVWF  FF7
8958:  MOVLW  04
895A:  MOVWF  xB4
895C:  MOVLB  0
895E:  CALL   4DEC
8962:  MOVFF  3AE,3B1
8966:  MOVLW  01
8968:  MOVLB  3
896A:  MOVWF  xB2
896C:  MOVLB  0
896E:  CALL   4E42
8972:  MOVLW  50
8974:  MOVWF  FF6
8976:  MOVLW  0B
8978:  MOVWF  FF7
897A:  MOVLW  05
897C:  MOVLB  3
897E:  MOVWF  xB4
8980:  MOVLB  0
8982:  CALL   4DEC
8986:  MOVFF  3AF,3B1
898A:  MOVLW  01
898C:  MOVLB  3
898E:  MOVWF  xB2
8990:  MOVLB  0
8992:  CALL   4E42
8996:  MOVLW  59
8998:  MOVWF  FF6
899A:  MOVLW  0B
899C:  MOVWF  FF7
899E:  MOVLW  05
89A0:  MOVLB  3
89A2:  MOVWF  xB4
89A4:  MOVLB  0
89A6:  CALL   4DEC
89AA:  MOVFF  3B0,3B1
89AE:  MOVLW  01
89B0:  MOVLB  3
89B2:  MOVWF  xB2
89B4:  MOVLB  0
89B6:  CALL   4E42
89BA:  MOVLW  0A
89BC:  MOVLB  3
89BE:  MOVWF  xBD
89C0:  MOVLB  0
89C2:  CALL   2436
89C6:  MOVLW  0D
89C8:  MOVLB  3
89CA:  MOVWF  xBD
89CC:  MOVLB  0
89CE:  CALL   2436
....................     printf(lcd_putc, "  <|>:PROX|ESC:BACK \n\r"); 
89D2:  MOVLW  66
89D4:  MOVWF  FF6
89D6:  MOVLW  0B
89D8:  MOVWF  FF7
89DA:  CALL   248A
89DE:  RETURN 0
.................... } 
.................... void tela_debug_entrada_3 (){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
8A5C:  MOVLW  0C
8A5E:  MOVLB  3
8A60:  MOVWF  xBD
8A62:  MOVLB  0
8A64:  CALL   2436
....................     printf(lcd_putc, "E18:%02u E19:%02u E20:%02u\n\r", entradas[18], entradas[19], entradas[20]); 
8A68:  MOVLW  00
8A6A:  BTFSC  1F.2
8A6C:  MOVLW  01
8A6E:  MOVLB  3
8A70:  MOVWF  xAE
8A72:  MOVLW  00
8A74:  BTFSC  1F.3
8A76:  MOVLW  01
8A78:  MOVWF  xAF
8A7A:  MOVLW  00
8A7C:  BTFSC  1F.4
8A7E:  MOVLW  01
8A80:  MOVWF  xB0
8A82:  MOVLW  7E
8A84:  MOVWF  FF6
8A86:  MOVLW  0B
8A88:  MOVWF  FF7
8A8A:  MOVLW  04
8A8C:  MOVWF  xB4
8A8E:  MOVLB  0
8A90:  CALL   4DEC
8A94:  MOVFF  3AE,3B1
8A98:  MOVLW  01
8A9A:  MOVLB  3
8A9C:  MOVWF  xB2
8A9E:  MOVLB  0
8AA0:  CALL   4E42
8AA4:  MOVLW  86
8AA6:  MOVWF  FF6
8AA8:  MOVLW  0B
8AAA:  MOVWF  FF7
8AAC:  MOVLW  05
8AAE:  MOVLB  3
8AB0:  MOVWF  xB4
8AB2:  MOVLB  0
8AB4:  CALL   4DEC
8AB8:  MOVFF  3AF,3B1
8ABC:  MOVLW  01
8ABE:  MOVLB  3
8AC0:  MOVWF  xB2
8AC2:  MOVLB  0
8AC4:  CALL   4E42
8AC8:  MOVLW  8F
8ACA:  MOVWF  FF6
8ACC:  MOVLW  0B
8ACE:  MOVWF  FF7
8AD0:  MOVLW  05
8AD2:  MOVLB  3
8AD4:  MOVWF  xB4
8AD6:  MOVLB  0
8AD8:  CALL   4DEC
8ADC:  MOVFF  3B0,3B1
8AE0:  MOVLW  01
8AE2:  MOVLB  3
8AE4:  MOVWF  xB2
8AE6:  MOVLB  0
8AE8:  CALL   4E42
8AEC:  MOVLW  0A
8AEE:  MOVLB  3
8AF0:  MOVWF  xBD
8AF2:  MOVLB  0
8AF4:  CALL   2436
8AF8:  MOVLW  0D
8AFA:  MOVLB  3
8AFC:  MOVWF  xBD
8AFE:  MOVLB  0
8B00:  CALL   2436
....................     printf(lcd_putc, "E21:%02u E22:%02u E23:%02u\n\r", entradas[21], entradas[22], entradas[23]); 
8B04:  MOVLW  00
8B06:  BTFSC  1F.5
8B08:  MOVLW  01
8B0A:  MOVLB  3
8B0C:  MOVWF  xAE
8B0E:  MOVLW  00
8B10:  BTFSC  1F.6
8B12:  MOVLW  01
8B14:  MOVWF  xAF
8B16:  MOVLW  00
8B18:  BTFSC  1F.7
8B1A:  MOVLW  01
8B1C:  MOVWF  xB0
8B1E:  MOVLW  9C
8B20:  MOVWF  FF6
8B22:  MOVLW  0B
8B24:  MOVWF  FF7
8B26:  MOVLW  04
8B28:  MOVWF  xB4
8B2A:  MOVLB  0
8B2C:  CALL   4DEC
8B30:  MOVFF  3AE,3B1
8B34:  MOVLW  01
8B36:  MOVLB  3
8B38:  MOVWF  xB2
8B3A:  MOVLB  0
8B3C:  CALL   4E42
8B40:  MOVLW  A4
8B42:  MOVWF  FF6
8B44:  MOVLW  0B
8B46:  MOVWF  FF7
8B48:  MOVLW  05
8B4A:  MOVLB  3
8B4C:  MOVWF  xB4
8B4E:  MOVLB  0
8B50:  CALL   4DEC
8B54:  MOVFF  3AF,3B1
8B58:  MOVLW  01
8B5A:  MOVLB  3
8B5C:  MOVWF  xB2
8B5E:  MOVLB  0
8B60:  CALL   4E42
8B64:  MOVLW  AD
8B66:  MOVWF  FF6
8B68:  MOVLW  0B
8B6A:  MOVWF  FF7
8B6C:  MOVLW  05
8B6E:  MOVLB  3
8B70:  MOVWF  xB4
8B72:  MOVLB  0
8B74:  CALL   4DEC
8B78:  MOVFF  3B0,3B1
8B7C:  MOVLW  01
8B7E:  MOVLB  3
8B80:  MOVWF  xB2
8B82:  MOVLB  0
8B84:  CALL   4E42
8B88:  MOVLW  0A
8B8A:  MOVLB  3
8B8C:  MOVWF  xBD
8B8E:  MOVLB  0
8B90:  CALL   2436
8B94:  MOVLW  0D
8B96:  MOVLB  3
8B98:  MOVWF  xBD
8B9A:  MOVLB  0
8B9C:  CALL   2436
....................     printf(lcd_putc, "E24:%02u E25:%02u E26:%02u\n\r", entradas[24], entradas[25], entradas[26]); 
8BA0:  MOVLW  00
8BA2:  BTFSC  20.0
8BA4:  MOVLW  01
8BA6:  MOVLB  3
8BA8:  MOVWF  xAE
8BAA:  MOVLW  00
8BAC:  BTFSC  20.1
8BAE:  MOVLW  01
8BB0:  MOVWF  xAF
8BB2:  MOVLW  00
8BB4:  BTFSC  20.2
8BB6:  MOVLW  01
8BB8:  MOVWF  xB0
8BBA:  MOVLW  BA
8BBC:  MOVWF  FF6
8BBE:  MOVLW  0B
8BC0:  MOVWF  FF7
8BC2:  MOVLW  04
8BC4:  MOVWF  xB4
8BC6:  MOVLB  0
8BC8:  CALL   4DEC
8BCC:  MOVFF  3AE,3B1
8BD0:  MOVLW  01
8BD2:  MOVLB  3
8BD4:  MOVWF  xB2
8BD6:  MOVLB  0
8BD8:  CALL   4E42
8BDC:  MOVLW  C2
8BDE:  MOVWF  FF6
8BE0:  MOVLW  0B
8BE2:  MOVWF  FF7
8BE4:  MOVLW  05
8BE6:  MOVLB  3
8BE8:  MOVWF  xB4
8BEA:  MOVLB  0
8BEC:  CALL   4DEC
8BF0:  MOVFF  3AF,3B1
8BF4:  MOVLW  01
8BF6:  MOVLB  3
8BF8:  MOVWF  xB2
8BFA:  MOVLB  0
8BFC:  CALL   4E42
8C00:  MOVLW  CB
8C02:  MOVWF  FF6
8C04:  MOVLW  0B
8C06:  MOVWF  FF7
8C08:  MOVLW  05
8C0A:  MOVLB  3
8C0C:  MOVWF  xB4
8C0E:  MOVLB  0
8C10:  CALL   4DEC
8C14:  MOVFF  3B0,3B1
8C18:  MOVLW  01
8C1A:  MOVLB  3
8C1C:  MOVWF  xB2
8C1E:  MOVLB  0
8C20:  CALL   4E42
8C24:  MOVLW  0A
8C26:  MOVLB  3
8C28:  MOVWF  xBD
8C2A:  MOVLB  0
8C2C:  CALL   2436
8C30:  MOVLW  0D
8C32:  MOVLB  3
8C34:  MOVWF  xBD
8C36:  MOVLB  0
8C38:  CALL   2436
....................     printf(lcd_putc, "E27:%02u <:ANT|ESC:BACK\n\r", entradas[27]); 
8C3C:  MOVLW  00
8C3E:  BTFSC  20.3
8C40:  MOVLW  01
8C42:  MOVLB  3
8C44:  MOVWF  xAE
8C46:  MOVLW  D8
8C48:  MOVWF  FF6
8C4A:  MOVLW  0B
8C4C:  MOVWF  FF7
8C4E:  MOVLW  04
8C50:  MOVWF  xB4
8C52:  MOVLB  0
8C54:  CALL   4DEC
8C58:  MOVFF  3AE,3B1
8C5C:  MOVLW  01
8C5E:  MOVLB  3
8C60:  MOVWF  xB2
8C62:  MOVLB  0
8C64:  CALL   4E42
8C68:  MOVLW  E0
8C6A:  MOVWF  FF6
8C6C:  MOVLW  0B
8C6E:  MOVWF  FF7
8C70:  MOVLW  11
8C72:  MOVLB  3
8C74:  MOVWF  xB4
8C76:  MOVLB  0
8C78:  CALL   4DEC
8C7C:  RETURN 0
.................... } 
.................... void tela_debug_saida_1 (){ 
....................     printf(lcd_putc, "\f"); 
*
8768:  MOVLW  0C
876A:  MOVLB  3
876C:  MOVWF  xBD
876E:  MOVLB  0
8770:  CALL   2436
....................     printf(lcd_putc, "ESTEIRA             \n\r"); 
8774:  MOVLW  F2
8776:  MOVWF  FF6
8778:  MOVLW  0B
877A:  MOVWF  FF7
877C:  CALL   248A
....................     printf(lcd_putc, "DEDOS ENTRADA       \n\r"); 
8780:  MOVLW  0A
8782:  MOVWF  FF6
8784:  MOVLW  0C
8786:  MOVWF  FF7
8788:  CALL   248A
....................     printf(lcd_putc, "ALIMENTADOR_PLACA   \n\r"); 
878C:  MOVLW  22
878E:  MOVWF  FF6
8790:  MOVLW  0C
8792:  MOVWF  FF7
8794:  CALL   248A
....................     printf(lcd_putc, "F1:ON|F2:OF|ESC:BACK\n\r"); 
8798:  MOVLW  3A
879A:  MOVWF  FF6
879C:  MOVLW  0C
879E:  MOVWF  FF7
87A0:  CALL   248A
....................     posiciona_cursor(ponteiro_lcd,19); 
87A4:  MOVFF  21,3BE
87A8:  MOVLW  13
87AA:  MOVLB  3
87AC:  MOVWF  xBF
87AE:  MOVLB  0
87B0:  CALL   2290
....................     printf(lcd_putc,"<"); 
87B4:  MOVLW  3C
87B6:  MOVLB  3
87B8:  MOVWF  xBD
87BA:  MOVLB  0
87BC:  CALL   2436
87C0:  RETURN 0
.................... } 
.................... void tela_debug_saida_2 (){ 
....................     printf(lcd_putc, "\f"); 
*
8D86:  MOVLW  0C
8D88:  MOVLB  3
8D8A:  MOVWF  xBD
8D8C:  MOVLB  0
8D8E:  CALL   2436
....................     printf(lcd_putc, "PRESSOR             \n\r"); 
8D92:  MOVLW  52
8D94:  MOVWF  FF6
8D96:  MOVLW  0C
8D98:  MOVWF  FF7
8D9A:  CALL   248A
....................     printf(lcd_putc, "DEDOS_SAIDA         \n\r"); 
8D9E:  MOVLW  6A
8DA0:  MOVWF  FF6
8DA2:  MOVLW  0C
8DA4:  MOVWF  FF7
8DA6:  CALL   248A
....................     printf(lcd_putc, "DISPENSADOR_PLACA   \n\r"); 
8DAA:  MOVLW  82
8DAC:  MOVWF  FF6
8DAE:  MOVLW  0C
8DB0:  MOVWF  FF7
8DB2:  CALL   248A
....................     printf(lcd_putc, "F1:ON|F2:OF|ESC:BACK\n\r"); 
8DB6:  MOVLW  9A
8DB8:  MOVWF  FF6
8DBA:  MOVLW  0C
8DBC:  MOVWF  FF7
8DBE:  CALL   248A
....................     posiciona_cursor(ponteiro_lcd,19); 
8DC2:  MOVFF  21,3BE
8DC6:  MOVLW  13
8DC8:  MOVLB  3
8DCA:  MOVWF  xBF
8DCC:  MOVLB  0
8DCE:  CALL   2290
....................     printf(lcd_putc,"<"); 
8DD2:  MOVLW  3C
8DD4:  MOVLB  3
8DD6:  MOVWF  xBD
8DD8:  MOVLB  0
8DDA:  CALL   2436
8DDE:  RETURN 0
.................... } 
.................... void tela_debug_saida_3 (){ 
....................     printf(lcd_putc, "\f"); 
*
8F36:  MOVLW  0C
8F38:  MOVLB  3
8F3A:  MOVWF  xBD
8F3C:  MOVLB  0
8F3E:  CALL   2436
....................     printf(lcd_putc, "ALIMENTADOR_SOLDA   \n\r"); 
8F42:  MOVLW  B2
8F44:  MOVWF  FF6
8F46:  MOVLW  0C
8F48:  MOVWF  FF7
8F4A:  CALL   248A
....................     printf(lcd_putc, "LIMPADOR_BICO       \n\r"); 
8F4E:  MOVLW  CA
8F50:  MOVWF  FF6
8F52:  MOVLW  0C
8F54:  MOVWF  FF7
8F56:  CALL   248A
....................     printf(lcd_putc, "FERROS_DE_SOLDA     \n\r"); 
8F5A:  MOVLW  E2
8F5C:  MOVWF  FF6
8F5E:  MOVLW  0C
8F60:  MOVWF  FF7
8F62:  CALL   248A
....................     printf(lcd_putc, "F1:ON|F2:OF|ESC:BACK\n\r"); 
8F66:  MOVLW  FA
8F68:  MOVWF  FF6
8F6A:  MOVLW  0C
8F6C:  MOVWF  FF7
8F6E:  CALL   248A
....................     posiciona_cursor(ponteiro_lcd,19); 
8F72:  MOVFF  21,3BE
8F76:  MOVLW  13
8F78:  MOVLB  3
8F7A:  MOVWF  xBF
8F7C:  MOVLB  0
8F7E:  CALL   2290
....................     printf(lcd_putc,"<"); 
8F82:  MOVLW  3C
8F84:  MOVLB  3
8F86:  MOVWF  xBD
8F88:  MOVLB  0
8F8A:  CALL   2436
8F8E:  RETURN 0
.................... } 
.................... void tela_debug_saida_4(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
90F0:  MOVLW  0C
90F2:  MOVLB  3
90F4:  MOVWF  xBD
90F6:  MOVLB  0
90F8:  CALL   2436
....................     printf(lcd_putc, "   X:%04Lu  Y:%04Lu  \n\r",motor_pos_x,motor_pos_y); 
90FC:  MOVLW  12
90FE:  MOVWF  FF6
9100:  MOVLW  0D
9102:  MOVWF  FF7
9104:  MOVLW  05
9106:  MOVLB  3
9108:  MOVWF  xB4
910A:  MOVLB  0
910C:  CALL   4DEC
9110:  MOVLW  09
9112:  MOVWF  FE9
9114:  MOVFF  113,3B5
9118:  MOVFF  112,3B4
911C:  CALL   67EA
9120:  MOVLW  1C
9122:  MOVWF  FF6
9124:  MOVLW  0D
9126:  MOVWF  FF7
9128:  MOVLW  04
912A:  MOVLB  3
912C:  MOVWF  xB4
912E:  MOVLB  0
9130:  CALL   4DEC
9134:  MOVLW  09
9136:  MOVWF  FE9
9138:  MOVFF  115,3B5
913C:  MOVFF  114,3B4
9140:  CALL   67EA
9144:  MOVLW  25
9146:  MOVWF  FF6
9148:  MOVLW  0D
914A:  MOVWF  FF7
914C:  MOVLW  04
914E:  MOVLB  3
9150:  MOVWF  xB4
9152:  MOVLB  0
9154:  CALL   4DEC
....................     printf(lcd_putc, "   Z:%04Lu  F:%04Lu  \n\r",motor_pos_z,contador_step_flip); 
9158:  MOVLW  2A
915A:  MOVWF  FF6
915C:  MOVLW  0D
915E:  MOVWF  FF7
9160:  MOVLW  05
9162:  MOVLB  3
9164:  MOVWF  xB4
9166:  MOVLB  0
9168:  CALL   4DEC
916C:  MOVLW  09
916E:  MOVWF  FE9
9170:  MOVFF  119,3B5
9174:  MOVFF  118,3B4
9178:  CALL   67EA
917C:  MOVLW  34
917E:  MOVWF  FF6
9180:  MOVLW  0D
9182:  MOVWF  FF7
9184:  MOVLW  04
9186:  MOVLB  3
9188:  MOVWF  xB4
918A:  MOVLB  0
918C:  CALL   4DEC
9190:  MOVLW  09
9192:  MOVWF  FE9
9194:  MOVFF  117,3B5
9198:  MOVFF  116,3B4
919C:  CALL   67EA
91A0:  MOVLW  3D
91A2:  MOVWF  FF6
91A4:  MOVLW  0D
91A6:  MOVWF  FF7
91A8:  MOVLW  04
91AA:  MOVLB  3
91AC:  MOVWF  xB4
91AE:  MOVLB  0
91B0:  CALL   4DEC
....................     printf(lcd_putc, "  ^|?||>|<|F1|F2|8|0 \n\r"); 
91B4:  MOVLW  42
91B6:  MOVWF  FF6
91B8:  MOVLW  0D
91BA:  MOVWF  FF7
91BC:  CALL   248A
....................     printf(lcd_putc, "       ESC:BACK      \n\r"); 
91C0:  MOVLW  5A
91C2:  MOVWF  FF6
91C4:  MOVLW  0D
91C6:  MOVWF  FF7
91C8:  CALL   248A
91CC:  RETURN 0
.................... } 
....................  
.................... void tela_programa_principal(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
5512:  MOVLW  0C
5514:  MOVLB  3
5516:  MOVWF  xBD
5518:  MOVLB  0
551A:  CALL   2436
....................     printf(lcd_putc, " EXECUTANDO PROGRAMA\n\r"); 
551E:  MOVLW  72
5520:  MOVWF  FF6
5522:  MOVLW  0D
5524:  MOVWF  FF7
5526:  CALL   248A
....................     printf(lcd_putc, "     MODELO:%02u    \n\r",modelo); 
552A:  MOVLW  8A
552C:  MOVWF  FF6
552E:  MOVLW  0D
5530:  MOVWF  FF7
5532:  MOVLW  0C
5534:  MOVLB  3
5536:  MOVWF  xB4
5538:  MOVLB  0
553A:  RCALL  4DEC
553C:  MOVFF  2D,3B1
5540:  MOVLW  01
5542:  MOVLB  3
5544:  MOVWF  xB2
5546:  MOVLB  0
5548:  RCALL  4E42
554A:  MOVLW  9A
554C:  MOVWF  FF6
554E:  MOVLW  0D
5550:  MOVWF  FF7
5552:  MOVLW  06
5554:  MOVLB  3
5556:  MOVWF  xB4
5558:  MOVLB  0
555A:  RCALL  4DEC
....................     printf(lcd_putc, "                    \n\r"); 
555C:  MOVLW  A2
555E:  MOVWF  FF6
5560:  MOVLW  0D
5562:  MOVWF  FF7
5564:  CALL   248A
....................     printf(lcd_putc, "      ESC:STOP      \n\r"); 
5568:  MOVLW  BA
556A:  MOVWF  FF6
556C:  MOVLW  0D
556E:  MOVWF  FF7
5570:  CALL   248A
5574:  GOTO   55F6 (RETURN)
.................... } 
....................  
.................... #include "Axis_x.c" 
.................... // <editor-fold defaultstate="collapsed" desc="Valores que devem ser inseridos"> 
.................... float stepbyrev_x = 200; //pulso por volta (datasheet) 
.................... float driver_u_step_x = 1; //divisao entre chave/pulso por volta 
.................... float Leadscrew_x = 9; //tipo de redutor 
.................... float Leadscrew_Pich_x = 150; //comprimento da polia (datasheet) 
.................... float Vmax_x = 30;//esse valor deve ser em mm por segundo 
.................... float Vmin_x = 10; 
.................... float Amax_x = 200; //esse valor deve ser em mm por segundo 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Valores calculo rampa"> 
.................... float MMbyStep_x = 0; 
.................... int8 StepinAcc_x = 20; 
.................... float Fmax_x = 0; 
.................... float Fmin_x = 100; 
.................... int32 Ts_x[20]; 
.................... int32 StepbyF_x[20]; 
.................... int16 total_acc_step_x = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Flags e Controles de Movimento"> 
.................... signed int8 pos_inc_x = 0; 
.................... int8 ramp_sts_x = ramp_idle; 
.................... short run_flg_x = FALSE; 
.................... short rest_x = FALSE; 
.................... int16 step_no_x = 0; 
.................... int16 step_down_x = 0; 
.................... int16 move_x = 0; 
.................... int16 midpt_x = 0; 
.................... int32 step_acumulado_x = 0; 
.................... int atual_frequencia_x = 0; 
.................... int vel_x = 19; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Pinos Motor"> 
.................... #DEFINE     i_limite_x            5 
.................... #DEFINE     s_limite_x            6 
.................... // </editor-fold>    
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Inicializa Motor"> 
.................... void init_axis_x(){ 
....................     set_tris_d(0xf8); 
*
2C00:  MOVLW  F8
2C02:  MOVWF  F95
....................     output_high(step_x); 
2C04:  BCF    F95.2
2C06:  BSF    F8C.2
....................     output_high(enable_x); 
2C08:  BCF    F95.0
2C0A:  BSF    F8C.0
....................     output_high(dir_x); 
2C0C:  BCF    F95.1
2C0E:  BSF    F8C.1
....................      
....................     MMbyStep_x = Leadscrew_Pich_x/(stepbyrev_x*driver_u_step_x*Leadscrew_x); 
2C10:  MOVFF  121,3CB
2C14:  MOVFF  120,3CA
2C18:  MOVFF  11F,3C9
2C1C:  MOVFF  11E,3C8
2C20:  MOVFF  125,3CF
2C24:  MOVFF  124,3CE
2C28:  MOVFF  123,3CD
2C2C:  MOVFF  122,3CC
2C30:  RCALL  2628
2C32:  MOVFF  03,3BD
2C36:  MOVFF  02,3BC
2C3A:  MOVFF  01,3BB
2C3E:  MOVFF  00,3BA
2C42:  MOVFF  03,3CB
2C46:  MOVFF  02,3CA
2C4A:  MOVFF  01,3C9
2C4E:  MOVFF  00,3C8
2C52:  MOVFF  129,3CF
2C56:  MOVFF  128,3CE
2C5A:  MOVFF  127,3CD
2C5E:  MOVFF  126,3CC
2C62:  RCALL  2628
2C64:  MOVFF  12D,3D1
2C68:  MOVFF  12C,3D0
2C6C:  MOVFF  12B,3CF
2C70:  MOVFF  12A,3CE
2C74:  MOVFF  03,3D5
2C78:  MOVFF  02,3D4
2C7C:  MOVFF  01,3D3
2C80:  MOVFF  00,3D2
2C84:  RCALL  271E
2C86:  MOVFF  03,13D
2C8A:  MOVFF  02,13C
2C8E:  MOVFF  01,13B
2C92:  MOVFF  00,13A
....................     Fmax_x = Vmax_x/MMbyStep_x; //Valor de ferequencia adiquirido em hz 
2C96:  MOVFF  131,3D1
2C9A:  MOVFF  130,3D0
2C9E:  MOVFF  12F,3CF
2CA2:  MOVFF  12E,3CE
2CA6:  MOVFF  13D,3D5
2CAA:  MOVFF  13C,3D4
2CAE:  MOVFF  13B,3D3
2CB2:  MOVFF  13A,3D2
2CB6:  RCALL  271E
2CB8:  MOVFF  03,142
2CBC:  MOVFF  02,141
2CC0:  MOVFF  01,140
2CC4:  MOVFF  00,13F
....................     //Fmin_x = Vmin_x/MMbyStep_x; 
....................      
....................     float den = Amax_x*StepinAcc_x; 
....................     float num = (Vmax_x - Vmin_x)*1000000; 
....................     float TbyF = num/den;//tempo em us 
....................      
....................     int i = 0; 
2CC8:  MOVLB  3
2CCA:  CLRF   xC9
2CCC:  MOVFF  13E,3C8
2CD0:  MOVLB  0
2CD2:  RCALL  287C
2CD4:  MOVFF  139,3CB
2CD8:  MOVFF  138,3CA
2CDC:  MOVFF  137,3C9
2CE0:  MOVFF  136,3C8
2CE4:  MOVFF  03,3CF
2CE8:  MOVFF  02,3CE
2CEC:  MOVFF  01,3CD
2CF0:  MOVFF  00,3CC
2CF4:  RCALL  2628
2CF6:  MOVFF  03,3B0
2CFA:  MOVFF  02,3AF
2CFE:  MOVFF  01,3AE
2D02:  MOVFF  00,3AD
2D06:  BSF    FD8.1
2D08:  MOVFF  131,3D1
2D0C:  MOVFF  130,3D0
2D10:  MOVFF  12F,3CF
2D14:  MOVFF  12E,3CE
2D18:  MOVFF  135,3D5
2D1C:  MOVFF  134,3D4
2D20:  MOVFF  133,3D3
2D24:  MOVFF  132,3D2
2D28:  RCALL  28B2
2D2A:  MOVFF  03,3BD
2D2E:  MOVFF  02,3BC
2D32:  MOVFF  01,3BB
2D36:  MOVFF  00,3BA
2D3A:  MOVFF  03,3CB
2D3E:  MOVFF  02,3CA
2D42:  MOVFF  01,3C9
2D46:  MOVFF  00,3C8
2D4A:  MOVLB  3
2D4C:  CLRF   xCF
2D4E:  MOVLW  24
2D50:  MOVWF  xCE
2D52:  MOVLW  74
2D54:  MOVWF  xCD
2D56:  MOVLW  92
2D58:  MOVWF  xCC
2D5A:  MOVLB  0
2D5C:  RCALL  2628
2D5E:  MOVFF  03,3B4
2D62:  MOVFF  02,3B3
2D66:  MOVFF  01,3B2
2D6A:  MOVFF  00,3B1
2D6E:  MOVFF  3B4,3D1
2D72:  MOVFF  3B3,3D0
2D76:  MOVFF  3B2,3CF
2D7A:  MOVFF  3B1,3CE
2D7E:  MOVFF  3B0,3D5
2D82:  MOVFF  3AF,3D4
2D86:  MOVFF  3AE,3D3
2D8A:  MOVFF  3AD,3D2
2D8E:  RCALL  271E
2D90:  MOVFF  03,3B8
2D94:  MOVFF  02,3B7
2D98:  MOVFF  01,3B6
2D9C:  MOVFF  00,3B5
2DA0:  MOVLB  3
2DA2:  CLRF   xB9
....................     for(i = 1; i <=StepinAcc_x;i++) 
2DA4:  MOVLW  01
2DA6:  MOVWF  xB9
2DA8:  MOVF   xB9,W
2DAA:  MOVLB  1
2DAC:  SUBWF  x3E,W
2DAE:  BTFSS  FD8.0
2DB0:  BRA    30D4
....................     { 
....................         Ts_x[i-1]=(1000000*StepinAcc_x)/(i*(Fmax_x-Fmin_x)+Fmin_x); 
2DB2:  MOVLW  01
2DB4:  MOVLB  3
2DB6:  SUBWF  xB9,W
2DB8:  MULLW  04
2DBA:  MOVF   FF3,W
2DBC:  CLRF   03
2DBE:  ADDLW  47
2DC0:  MOVWF  FE9
2DC2:  MOVLW  01
2DC4:  ADDWFC 03,W
2DC6:  MOVWF  FEA
2DC8:  MOVFF  FEA,3BD
2DCC:  MOVFF  FE9,3BC
2DD0:  CLRF   xC1
2DD2:  MOVLW  0F
2DD4:  MOVWF  xC0
2DD6:  MOVLW  42
2DD8:  MOVWF  xBF
2DDA:  MOVLW  40
2DDC:  MOVWF  xBE
2DDE:  CLRF   xC5
2DE0:  CLRF   xC4
2DE2:  CLRF   xC3
2DE4:  MOVFF  13E,3C2
2DE8:  MOVLB  0
2DEA:  RCALL  2B2A
2DEC:  MOVFF  3BD,FEA
2DF0:  MOVFF  3BC,FE9
2DF4:  MOVFF  03,3C1
2DF8:  MOVFF  02,3C0
2DFC:  MOVFF  01,3BF
2E00:  MOVFF  00,3BE
2E04:  MOVFF  FEA,3C3
2E08:  MOVFF  FE9,3C2
2E0C:  BSF    FD8.1
2E0E:  MOVFF  142,3D1
2E12:  MOVFF  141,3D0
2E16:  MOVFF  140,3CF
2E1A:  MOVFF  13F,3CE
2E1E:  MOVFF  146,3D5
2E22:  MOVFF  145,3D4
2E26:  MOVFF  144,3D3
2E2A:  MOVFF  143,3D2
2E2E:  RCALL  28B2
2E30:  MOVFF  3C3,FEA
2E34:  MOVFF  3C2,FE9
2E38:  MOVFF  03,3C7
2E3C:  MOVFF  02,3C6
2E40:  MOVFF  01,3C5
2E44:  MOVFF  00,3C4
2E48:  MOVLB  3
2E4A:  CLRF   xC9
2E4C:  MOVFF  3B9,3C8
2E50:  MOVLB  0
2E52:  RCALL  287C
2E54:  MOVFF  03,3CB
2E58:  MOVFF  02,3CA
2E5C:  MOVFF  01,3C9
2E60:  MOVFF  00,3C8
2E64:  MOVFF  3C7,3CF
2E68:  MOVFF  3C6,3CE
2E6C:  MOVFF  3C5,3CD
2E70:  MOVFF  3C4,3CC
2E74:  CALL   2628
2E78:  MOVFF  03,3CB
2E7C:  MOVFF  02,3CA
2E80:  MOVFF  01,3C9
2E84:  MOVFF  00,3C8
2E88:  MOVFF  FEA,3CD
2E8C:  MOVFF  FE9,3CC
2E90:  BCF    FD8.1
2E92:  MOVFF  03,3D1
2E96:  MOVFF  02,3D0
2E9A:  MOVFF  01,3CF
2E9E:  MOVFF  00,3CE
2EA2:  MOVFF  146,3D5
2EA6:  MOVFF  145,3D4
2EAA:  MOVFF  144,3D3
2EAE:  MOVFF  143,3D2
2EB2:  RCALL  28B2
2EB4:  MOVFF  3CD,FEA
2EB8:  MOVFF  3CC,FE9
2EBC:  MOVFF  03,3CB
2EC0:  MOVFF  02,3CA
2EC4:  MOVFF  01,3C9
2EC8:  MOVFF  00,3C8
2ECC:  MOVFF  3C1,3D1
2ED0:  MOVFF  3C0,3D0
2ED4:  MOVFF  3BF,3CF
2ED8:  MOVFF  3BE,3CE
2EDC:  RCALL  2B86
2EDE:  MOVFF  03,3D1
2EE2:  MOVFF  02,3D0
2EE6:  MOVFF  01,3CF
2EEA:  MOVFF  00,3CE
2EEE:  MOVFF  3CB,3D5
2EF2:  MOVFF  3CA,3D4
2EF6:  MOVFF  3C9,3D3
2EFA:  MOVFF  3C8,3D2
2EFE:  RCALL  271E
2F00:  MOVFF  03,3D1
2F04:  MOVFF  02,3D0
2F08:  MOVFF  01,3CF
2F0C:  MOVFF  00,3CE
2F10:  RCALL  2BBE
2F12:  MOVFF  00,FEF
2F16:  MOVFF  01,FEC
2F1A:  MOVFF  02,FEC
2F1E:  MOVFF  03,FEC
....................         StepbyF_x[i-1] = 2*TbyF/Ts_x[i-1]; 
2F22:  MOVLW  01
2F24:  MOVLB  3
2F26:  SUBWF  xB9,W
2F28:  MULLW  04
2F2A:  MOVF   FF3,W
2F2C:  CLRF   03
2F2E:  ADDLW  97
2F30:  MOVWF  01
2F32:  MOVLW  01
2F34:  ADDWFC 03,F
2F36:  MOVFF  01,3BA
2F3A:  MOVFF  03,3BB
2F3E:  CLRF   xCB
2F40:  CLRF   xCA
2F42:  CLRF   xC9
2F44:  MOVLW  80
2F46:  MOVWF  xC8
2F48:  MOVFF  3B8,3CF
2F4C:  MOVFF  3B7,3CE
2F50:  MOVFF  3B6,3CD
2F54:  MOVFF  3B5,3CC
2F58:  MOVLB  0
2F5A:  CALL   2628
2F5E:  MOVFF  03,3BF
2F62:  MOVFF  02,3BE
2F66:  MOVFF  01,3BD
2F6A:  MOVFF  00,3BC
2F6E:  MOVLW  01
2F70:  MOVLB  3
2F72:  SUBWF  xB9,W
2F74:  MULLW  04
2F76:  MOVF   FF3,W
2F78:  CLRF   03
2F7A:  ADDLW  47
2F7C:  MOVWF  FE9
2F7E:  MOVLW  01
2F80:  ADDWFC 03,W
2F82:  MOVWF  FEA
2F84:  MOVFF  FEF,00
2F88:  MOVFF  FEC,01
2F8C:  MOVFF  FEC,02
2F90:  MOVFF  FEC,03
2F94:  MOVFF  03,3D1
2F98:  MOVFF  02,3D0
2F9C:  MOVFF  01,3CF
2FA0:  MOVFF  00,3CE
2FA4:  MOVLB  0
2FA6:  RCALL  2B86
2FA8:  MOVFF  3BF,3D1
2FAC:  MOVFF  3BE,3D0
2FB0:  MOVFF  3BD,3CF
2FB4:  MOVFF  3BC,3CE
2FB8:  MOVFF  03,3D5
2FBC:  MOVFF  02,3D4
2FC0:  MOVFF  01,3D3
2FC4:  MOVFF  00,3D2
2FC8:  CALL   271E
2FCC:  MOVFF  03,3D1
2FD0:  MOVFF  02,3D0
2FD4:  MOVFF  01,3CF
2FD8:  MOVFF  00,3CE
2FDC:  RCALL  2BBE
2FDE:  MOVFF  3BB,FEA
2FE2:  MOVFF  3BA,FE9
2FE6:  MOVFF  00,FEF
2FEA:  MOVFF  01,FEC
2FEE:  MOVFF  02,FEC
2FF2:  MOVFF  03,FEC
....................         total_acc_step_x += StepbyF_x[i-1]; 
2FF6:  MOVLW  01
2FF8:  MOVLB  3
2FFA:  SUBWF  xB9,W
2FFC:  MULLW  04
2FFE:  MOVF   FF3,W
3000:  CLRF   03
3002:  ADDLW  97
3004:  MOVWF  FE9
3006:  MOVLW  01
3008:  ADDWFC 03,W
300A:  MOVWF  FEA
300C:  MOVFF  FEF,00
3010:  MOVFF  FEC,01
3014:  MOVFF  FEC,02
3018:  MOVFF  FEC,03
301C:  MOVF   00,W
301E:  MOVLB  1
3020:  ADDWF  xE7,F
3022:  MOVF   01,W
3024:  ADDWFC xE8,F
....................         Ts_x[i-1] = Ts_x[i-1]/(8*0.2*2);//Tempo/(prescale*ciclodemaquina*metadedociclo) 
3026:  MOVLW  01
3028:  MOVLB  3
302A:  SUBWF  xB9,W
302C:  MULLW  04
302E:  MOVF   FF3,W
3030:  CLRF   03
3032:  ADDLW  47
3034:  MOVWF  01
3036:  MOVLW  01
3038:  ADDWFC 03,F
303A:  MOVFF  01,3BA
303E:  MOVFF  03,3BB
3042:  MOVLW  01
3044:  SUBWF  xB9,W
3046:  MULLW  04
3048:  MOVF   FF3,W
304A:  CLRF   03
304C:  ADDLW  47
304E:  MOVWF  FE9
3050:  MOVLW  01
3052:  ADDWFC 03,W
3054:  MOVWF  FEA
3056:  MOVFF  FEF,3BC
305A:  MOVFF  FEC,3BD
305E:  MOVFF  FEC,3BE
3062:  MOVFF  FEC,3BF
3066:  MOVFF  3BF,3D1
306A:  MOVFF  3BE,3D0
306E:  MOVFF  3BD,3CF
3072:  MOVFF  3BC,3CE
3076:  MOVLB  0
3078:  RCALL  2B86
307A:  MOVFF  03,3D1
307E:  MOVFF  02,3D0
3082:  MOVFF  01,3CF
3086:  MOVFF  00,3CE
308A:  MOVLW  CD
308C:  MOVLB  3
308E:  MOVWF  xD5
3090:  MOVLW  CC
3092:  MOVWF  xD4
3094:  MOVLW  4C
3096:  MOVWF  xD3
3098:  MOVLW  80
309A:  MOVWF  xD2
309C:  MOVLB  0
309E:  CALL   271E
30A2:  MOVFF  03,3D1
30A6:  MOVFF  02,3D0
30AA:  MOVFF  01,3CF
30AE:  MOVFF  00,3CE
30B2:  RCALL  2BBE
30B4:  MOVFF  3BB,FEA
30B8:  MOVFF  3BA,FE9
30BC:  MOVFF  00,FEF
30C0:  MOVFF  01,FEC
30C4:  MOVFF  02,FEC
30C8:  MOVFF  03,FEC
30CC:  MOVLB  3
30CE:  INCF   xB9,F
30D0:  BRA    2DA8
30D2:  MOVLB  1
....................     } 
....................     i++; 
30D4:  MOVLB  3
30D6:  INCF   xB9,F
30D8:  MOVLB  0
30DA:  GOTO   A8EC (RETURN)
.................... } 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Movimento Motor"> 
.................... void motor_stop_x(){ 
....................     step_no_x = step_down_x; 
....................     ramp_sts_x = ramp_down; 
.................... } 
....................  
.................... void motor_disable_x(){ 
....................     output_high(enable_x); 
....................     disable_interrupts(INT_TIMER0); 
.................... } 
....................  
.................... void motor_run_x(int32 pos_new, int velocidade) { // set up to drive motor to pos_new (absolute step#) 
....................      
....................     vel_x = velocidade; 
*
4AB2:  MOVFF  3B8,1F8
....................     total_acc_step_x = 0; 
4AB6:  MOVLB  1
4AB8:  CLRF   xE8
4ABA:  CLRF   xE7
....................      
....................     /*Obtem a Direo do motor*/ 
....................     if (pos_new < motor_pos_x)  
4ABC:  MOVLB  3
4ABE:  MOVF   xB7,F
4AC0:  BNZ   4AFC
4AC2:  MOVF   xB6,F
4AC4:  BNZ   4AFC
4AC6:  MOVF   xB5,W
4AC8:  MOVLB  1
4ACA:  SUBWF  x13,W
4ACC:  BTFSC  FD8.0
4ACE:  BRA    4AD4
4AD0:  MOVLB  3
4AD2:  BRA    4AFC
4AD4:  BNZ   4AE0
4AD6:  MOVF   x12,W
4AD8:  MOVLB  3
4ADA:  SUBWF  xB4,W
4ADC:  BC    4AFC
4ADE:  MOVLB  1
....................     { 
....................         output_low(dir_x); 
4AE0:  BCF    F95.1
4AE2:  BCF    F8C.1
....................         move_x = motor_pos_x - pos_new; 
4AE4:  MOVLB  3
4AE6:  MOVF   xB4,W
4AE8:  MOVLB  1
4AEA:  SUBWF  x12,W
4AEC:  MOVWF  xEF
4AEE:  MOVLB  3
4AF0:  MOVF   xB5,W
4AF2:  MOVLB  1
4AF4:  SUBWFB x13,W
4AF6:  MOVWF  xF0
....................         pos_inc_x = -1; 
4AF8:  SETF   xE9
....................     } else if (pos_new != motor_pos_x) { 
4AFA:  BRA    4B3E
4AFC:  MOVLB  1
4AFE:  MOVF   x12,W
4B00:  MOVLB  3
4B02:  SUBWF  xB4,W
4B04:  BNZ   4B18
4B06:  MOVLB  1
4B08:  MOVF   x13,W
4B0A:  MOVLB  3
4B0C:  SUBWF  xB5,W
4B0E:  BNZ   4B18
4B10:  MOVF   xB6,F
4B12:  BNZ   4B18
4B14:  MOVF   xB7,F
4B16:  BZ    4B3A
....................         output_high(dir_x); 
4B18:  BCF    F95.1
4B1A:  BSF    F8C.1
....................         move_x = pos_new - motor_pos_x; 
4B1C:  MOVLB  1
4B1E:  MOVF   x12,W
4B20:  MOVLB  3
4B22:  SUBWF  xB4,W
4B24:  MOVLB  1
4B26:  MOVWF  xEF
4B28:  MOVF   x13,W
4B2A:  MOVLB  3
4B2C:  SUBWFB xB5,W
4B2E:  MOVLB  1
4B30:  MOVWF  xF0
....................         pos_inc_x = 1; 
4B32:  MOVLW  01
4B34:  MOVWF  xE9
....................     } else return; 
4B36:  BRA    4B3E
4B38:  MOVLB  3
4B3A:  BRA    4C20
4B3C:  MOVLB  1
....................      
....................     /*Calcula a quantidade de passos para chegar na velocidade desejada*/ 
....................     for(int j = 0; j <= velocidade;j++) 
4B3E:  MOVLB  3
4B40:  CLRF   xB9
4B42:  MOVF   xB9,W
4B44:  SUBWF  xB8,W
4B46:  BNC   4B7A
....................     { 
....................         total_acc_step_x += StepbyF_x[j]; 
4B48:  MOVF   xB9,W
4B4A:  MULLW  04
4B4C:  MOVF   FF3,W
4B4E:  CLRF   03
4B50:  ADDLW  97
4B52:  MOVWF  FE9
4B54:  MOVLW  01
4B56:  ADDWFC 03,W
4B58:  MOVWF  FEA
4B5A:  MOVFF  FEF,00
4B5E:  MOVFF  FEC,01
4B62:  MOVFF  FEC,02
4B66:  MOVFF  FEC,03
4B6A:  MOVF   00,W
4B6C:  MOVLB  1
4B6E:  ADDWF  xE7,F
4B70:  MOVF   01,W
4B72:  ADDWFC xE8,F
4B74:  MOVLB  3
4B76:  INCF   xB9,F
4B78:  BRA    4B42
....................     } 
....................     /*Define Formato da Rampa(Trapezio,triangulo ou constante)*/ 
....................     if (move_x > 2 * total_acc_step_x) { 
4B7A:  BCF    FD8.0
4B7C:  MOVLB  1
4B7E:  RLCF   xE7,W
4B80:  MOVWF  02
4B82:  RLCF   xE8,W
4B84:  MOVWF  03
4B86:  MOVFF  02,01
4B8A:  MOVF   03,W
4B8C:  SUBWF  xF0,W
4B8E:  BNC   4BAE
4B90:  BNZ   4B98
4B92:  MOVF   xEF,W
4B94:  SUBWF  01,W
4B96:  BC    4BAE
....................         midpt_x = total_acc_step_x; 
4B98:  MOVFF  1E8,1F2
4B9C:  MOVFF  1E7,1F1
....................         step_down_x = move_x - total_acc_step_x; 
4BA0:  MOVF   xE7,W
4BA2:  SUBWF  xEF,W
4BA4:  MOVWF  xED
4BA6:  MOVF   xE8,W
4BA8:  SUBWFB xF0,W
4BAA:  MOVWF  xEE
....................     }  
4BAC:  BRA    4BD8
....................     else 
....................     { 
....................         midpt_x = (move_x - 1) >> 1; 
4BAE:  MOVLW  01
4BB0:  SUBWF  xEF,W
4BB2:  MOVLB  3
4BB4:  MOVWF  xBA
4BB6:  MOVLW  00
4BB8:  MOVLB  1
4BBA:  SUBWFB xF0,W
4BBC:  MOVLB  3
4BBE:  MOVWF  xBB
4BC0:  BCF    FD8.0
4BC2:  RRCF   xBB,W
4BC4:  MOVLB  1
4BC6:  MOVWF  xF2
4BC8:  MOVLB  3
4BCA:  RRCF   xBA,W
4BCC:  MOVLB  1
4BCE:  MOVWF  xF1
....................         step_down_x = midpt_x; 
4BD0:  MOVFF  1F2,1EE
4BD4:  MOVFF  1F1,1ED
....................     } 
....................     step_no_x = 0; 
4BD8:  CLRF   xEC
4BDA:  CLRF   xEB
....................     step_acumulado_x = 0; 
4BDC:  CLRF   xF6
4BDE:  CLRF   xF5
4BE0:  CLRF   xF4
4BE2:  CLRF   xF3
....................     atual_frequencia_x = 0; 
4BE4:  CLRF   xF7
....................     ramp_sts_x = ramp_up; // start ramp state-machine 
4BE6:  MOVLW  01
4BE8:  MOVWF  xEA
....................     run_flg_x = TRUE; 
4BEA:  BSF    x1A.3
....................     output_low(enable_x); 
4BEC:  BCF    F95.0
4BEE:  BCF    F8C.0
....................     setup_timer_0(T0_INTERNAL | T0_DIV_8); 
4BF0:  MOVLW  82
4BF2:  MOVWF  FD5
....................     set_timer0(65535 - Ts_x[0]); 
4BF4:  MOVLW  FF
4BF6:  BSF    FD8.0
4BF8:  SUBFWB x47,W
4BFA:  MOVLB  3
4BFC:  MOVWF  xBA
4BFE:  MOVLW  FF
4C00:  MOVLB  1
4C02:  SUBFWB x48,W
4C04:  MOVLB  3
4C06:  MOVWF  xBB
4C08:  MOVLW  00
4C0A:  MOVLB  1
4C0C:  SUBFWB x49,W
4C0E:  MOVLW  00
4C10:  MOVLB  1
4C12:  SUBFWB x4A,W
4C14:  MOVLB  3
4C16:  MOVFF  3BB,FD7
4C1A:  MOVFF  3BA,FD6
....................     enable_interrupts(INT_TIMER0); 
4C1E:  BSF    FF2.5
4C20:  MOVLB  0
4C22:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_subida_x() { 
....................     if (atual_frequencia_x == 0) { 
*
0F12:  MOVLB  1
0F14:  MOVF   xF7,F
0F16:  BTFSS  FD8.2
0F18:  BRA    1048
....................         if (step_no_x == StepbyF_x[atual_frequencia_x]) { 
0F1A:  MOVF   xF7,W
0F1C:  MULLW  04
0F1E:  MOVF   FF3,W
0F20:  CLRF   03
0F22:  ADDLW  97
0F24:  MOVWF  FE9
0F26:  MOVLW  01
0F28:  ADDWFC 03,W
0F2A:  MOVWF  FEA
0F2C:  MOVFF  FEF,00
0F30:  MOVFF  FEC,01
0F34:  MOVFF  FEC,02
0F38:  MOVFF  FEC,03
0F3C:  MOVF   00,W
0F3E:  SUBWF  xEB,W
0F40:  BNZ   1002
0F42:  MOVF   01,W
0F44:  SUBWF  xEC,W
0F46:  BNZ   1002
0F48:  MOVF   02,F
0F4A:  BNZ   1002
0F4C:  MOVF   03,F
0F4E:  BNZ   1002
....................             step_acumulado_x += StepbyF_x[atual_frequencia_x] + StepbyF_x[atual_frequencia_x + 1]; 
0F50:  MOVF   xF7,W
0F52:  MULLW  04
0F54:  MOVF   FF3,W
0F56:  CLRF   03
0F58:  ADDLW  97
0F5A:  MOVWF  FE9
0F5C:  MOVLW  01
0F5E:  ADDWFC 03,W
0F60:  MOVWF  FEA
0F62:  MOVFF  FEF,3DE
0F66:  MOVFF  FEC,3DF
0F6A:  MOVFF  FEC,3E0
0F6E:  MOVFF  FEC,3E1
0F72:  MOVLW  01
0F74:  ADDWF  xF7,W
0F76:  MULLW  04
0F78:  MOVF   FF3,W
0F7A:  CLRF   03
0F7C:  ADDLW  97
0F7E:  MOVWF  FE9
0F80:  MOVLW  01
0F82:  ADDWFC 03,W
0F84:  MOVWF  FEA
0F86:  MOVFF  FEF,00
0F8A:  MOVFF  FEC,01
0F8E:  MOVFF  FEC,02
0F92:  MOVFF  FEC,03
0F96:  MOVLB  3
0F98:  MOVF   xDE,W
0F9A:  ADDWF  00,F
0F9C:  MOVF   xDF,W
0F9E:  ADDWFC 01,F
0FA0:  MOVF   xE0,W
0FA2:  ADDWFC 02,F
0FA4:  MOVF   xE1,W
0FA6:  ADDWFC 03,F
0FA8:  MOVF   00,W
0FAA:  MOVLB  1
0FAC:  ADDWF  xF3,F
0FAE:  MOVF   01,W
0FB0:  ADDWFC xF4,F
0FB2:  MOVF   02,W
0FB4:  ADDWFC xF5,F
0FB6:  MOVF   03,W
0FB8:  ADDWFC xF6,F
....................             atual_frequencia_x++; 
0FBA:  INCF   xF7,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
0FBC:  MOVF   xF7,W
0FBE:  MULLW  04
0FC0:  MOVF   FF3,W
0FC2:  CLRF   03
0FC4:  ADDLW  47
0FC6:  MOVWF  FE9
0FC8:  MOVLW  01
0FCA:  ADDWFC 03,W
0FCC:  MOVWF  FEA
0FCE:  MOVFF  FEF,00
0FD2:  MOVFF  FEC,01
0FD6:  MOVFF  FEC,02
0FDA:  MOVFF  FEC,03
0FDE:  MOVLW  FF
0FE0:  BSF    FD8.0
0FE2:  SUBFWB 00,W
0FE4:  MOVLB  3
0FE6:  MOVWF  xDE
0FE8:  MOVLW  FF
0FEA:  SUBFWB 01,W
0FEC:  MOVWF  xDF
0FEE:  MOVLW  00
0FF0:  SUBFWB 02,W
0FF2:  MOVLW  00
0FF4:  SUBFWB 03,W
0FF6:  MOVFF  3DF,FD7
0FFA:  MOVFF  3DE,FD6
....................         } else { 
0FFE:  BRA    1044
1000:  MOVLB  1
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
1002:  MOVF   xF7,W
1004:  MULLW  04
1006:  MOVF   FF3,W
1008:  CLRF   03
100A:  ADDLW  47
100C:  MOVWF  FE9
100E:  MOVLW  01
1010:  ADDWFC 03,W
1012:  MOVWF  FEA
1014:  MOVFF  FEF,00
1018:  MOVFF  FEC,01
101C:  MOVFF  FEC,02
1020:  MOVFF  FEC,03
1024:  MOVLW  FF
1026:  BSF    FD8.0
1028:  SUBFWB 00,W
102A:  MOVLB  3
102C:  MOVWF  xDE
102E:  MOVLW  FF
1030:  SUBFWB 01,W
1032:  MOVWF  xDF
1034:  MOVLW  00
1036:  SUBFWB 02,W
1038:  MOVLW  00
103A:  SUBFWB 03,W
103C:  MOVFF  3DF,FD7
1040:  MOVFF  3DE,FD6
....................         } 
....................     } else if (atual_frequencia_x == vel_x) { 
1044:  BRA    1164
1046:  MOVLB  1
1048:  MOVF   xF8,W
104A:  SUBWF  xF7,W
104C:  BNZ   1094
....................         set_timer0(65535 - Ts_x[atual_frequencia_x]); 
104E:  MOVF   xF7,W
1050:  MULLW  04
1052:  MOVF   FF3,W
1054:  CLRF   03
1056:  ADDLW  47
1058:  MOVWF  FE9
105A:  MOVLW  01
105C:  ADDWFC 03,W
105E:  MOVWF  FEA
1060:  MOVFF  FEF,00
1064:  MOVFF  FEC,01
1068:  MOVFF  FEC,02
106C:  MOVFF  FEC,03
1070:  MOVLW  FF
1072:  BSF    FD8.0
1074:  SUBFWB 00,W
1076:  MOVLB  3
1078:  MOVWF  xDE
107A:  MOVLW  FF
107C:  SUBFWB 01,W
107E:  MOVWF  xDF
1080:  MOVLW  00
1082:  SUBFWB 02,W
1084:  MOVLW  00
1086:  SUBFWB 03,W
1088:  MOVFF  3DF,FD7
108C:  MOVFF  3DE,FD6
....................     } else { 
1090:  BRA    1164
1092:  MOVLB  1
....................         if (step_no_x == step_acumulado_x) { 
1094:  MOVF   xF3,W
1096:  SUBWF  xEB,W
1098:  BNZ   1122
109A:  MOVF   xF4,W
109C:  SUBWF  xEC,W
109E:  BNZ   1122
10A0:  MOVF   xF5,F
10A2:  BNZ   1122
10A4:  MOVF   xF6,F
10A6:  BNZ   1122
....................             atual_frequencia_x++; 
10A8:  INCF   xF7,F
....................             step_acumulado_x += StepbyF_x[atual_frequencia_x]; 
10AA:  MOVF   xF7,W
10AC:  MULLW  04
10AE:  MOVF   FF3,W
10B0:  CLRF   03
10B2:  ADDLW  97
10B4:  MOVWF  FE9
10B6:  MOVLW  01
10B8:  ADDWFC 03,W
10BA:  MOVWF  FEA
10BC:  MOVFF  FEF,00
10C0:  MOVFF  FEC,01
10C4:  MOVFF  FEC,02
10C8:  MOVFF  FEC,03
10CC:  MOVF   00,W
10CE:  ADDWF  xF3,F
10D0:  MOVF   01,W
10D2:  ADDWFC xF4,F
10D4:  MOVF   02,W
10D6:  ADDWFC xF5,F
10D8:  MOVF   03,W
10DA:  ADDWFC xF6,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
10DC:  MOVF   xF7,W
10DE:  MULLW  04
10E0:  MOVF   FF3,W
10E2:  CLRF   03
10E4:  ADDLW  47
10E6:  MOVWF  FE9
10E8:  MOVLW  01
10EA:  ADDWFC 03,W
10EC:  MOVWF  FEA
10EE:  MOVFF  FEF,00
10F2:  MOVFF  FEC,01
10F6:  MOVFF  FEC,02
10FA:  MOVFF  FEC,03
10FE:  MOVLW  FF
1100:  BSF    FD8.0
1102:  SUBFWB 00,W
1104:  MOVLB  3
1106:  MOVWF  xDE
1108:  MOVLW  FF
110A:  SUBFWB 01,W
110C:  MOVWF  xDF
110E:  MOVLW  00
1110:  SUBFWB 02,W
1112:  MOVLW  00
1114:  SUBFWB 03,W
1116:  MOVFF  3DF,FD7
111A:  MOVFF  3DE,FD6
....................         } else { 
111E:  BRA    1164
1120:  MOVLB  1
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
1122:  MOVF   xF7,W
1124:  MULLW  04
1126:  MOVF   FF3,W
1128:  CLRF   03
112A:  ADDLW  47
112C:  MOVWF  FE9
112E:  MOVLW  01
1130:  ADDWFC 03,W
1132:  MOVWF  FEA
1134:  MOVFF  FEF,00
1138:  MOVFF  FEC,01
113C:  MOVFF  FEC,02
1140:  MOVFF  FEC,03
1144:  MOVLW  FF
1146:  BSF    FD8.0
1148:  SUBFWB 00,W
114A:  MOVLB  3
114C:  MOVWF  xDE
114E:  MOVLW  FF
1150:  SUBFWB 01,W
1152:  MOVWF  xDF
1154:  MOVLW  00
1156:  SUBFWB 02,W
1158:  MOVLW  00
115A:  SUBFWB 03,W
115C:  MOVFF  3DF,FD7
1160:  MOVFF  3DE,FD6
....................         } 
....................         break; 
....................     } 
1164:  MOVLB  0
1166:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_descida_x() { 
....................     if (atual_frequencia_x == 0) { 
1168:  MOVLB  1
116A:  MOVF   xF7,F
116C:  BNZ   11B4
....................         set_timer0(65535 - Ts_x[atual_frequencia_x]); 
116E:  MOVF   xF7,W
1170:  MULLW  04
1172:  MOVF   FF3,W
1174:  CLRF   03
1176:  ADDLW  47
1178:  MOVWF  FE9
117A:  MOVLW  01
117C:  ADDWFC 03,W
117E:  MOVWF  FEA
1180:  MOVFF  FEF,00
1184:  MOVFF  FEC,01
1188:  MOVFF  FEC,02
118C:  MOVFF  FEC,03
1190:  MOVLW  FF
1192:  BSF    FD8.0
1194:  SUBFWB 00,W
1196:  MOVLB  3
1198:  MOVWF  xDE
119A:  MOVLW  FF
119C:  SUBFWB 01,W
119E:  MOVWF  xDF
11A0:  MOVLW  00
11A2:  SUBFWB 02,W
11A4:  MOVLW  00
11A6:  SUBFWB 03,W
11A8:  MOVFF  3DF,FD7
11AC:  MOVFF  3DE,FD6
....................     }  
11B0:  BRA    13EC
11B2:  MOVLB  1
....................     else if (atual_frequencia_x == vel_x) { 
11B4:  MOVF   xF8,W
11B6:  SUBWF  xF7,W
11B8:  BTFSS  FD8.2
11BA:  BRA    131C
....................         if (step_no_x == (step_down_x + StepbyF_x[atual_frequencia_x])) { 
11BC:  MOVF   xF7,W
11BE:  MULLW  04
11C0:  MOVF   FF3,W
11C2:  CLRF   03
11C4:  ADDLW  97
11C6:  MOVWF  FE9
11C8:  MOVLW  01
11CA:  ADDWFC 03,W
11CC:  MOVWF  FEA
11CE:  MOVFF  FEF,00
11D2:  MOVFF  FEC,01
11D6:  MOVFF  FEC,02
11DA:  MOVFF  FEC,03
11DE:  MOVF   xED,W
11E0:  ADDWF  00,F
11E2:  MOVF   xEE,W
11E4:  ADDWFC 01,F
11E6:  MOVLW  00
11E8:  ADDWFC 02,F
11EA:  ADDWFC 03,F
11EC:  MOVF   00,W
11EE:  SUBWF  xEB,W
11F0:  BNZ   12D6
11F2:  MOVF   01,W
11F4:  SUBWF  xEC,W
11F6:  BNZ   12D6
11F8:  MOVF   02,F
11FA:  BNZ   12D6
11FC:  MOVF   03,F
11FE:  BNZ   12D6
....................             step_acumulado_x = step_down_x + StepbyF_x[atual_frequencia_x] + StepbyF_x[atual_frequencia_x - 1]; 
1200:  MOVF   xF7,W
1202:  MULLW  04
1204:  MOVF   FF3,W
1206:  CLRF   03
1208:  ADDLW  97
120A:  MOVWF  FE9
120C:  MOVLW  01
120E:  ADDWFC 03,W
1210:  MOVWF  FEA
1212:  MOVFF  FEF,00
1216:  MOVFF  FEC,01
121A:  MOVFF  FEC,02
121E:  MOVFF  FEC,03
1222:  MOVF   00,W
1224:  ADDWF  xED,W
1226:  MOVLB  3
1228:  MOVWF  xDE
122A:  MOVF   01,W
122C:  MOVLB  1
122E:  ADDWFC xEE,W
1230:  MOVLB  3
1232:  MOVWF  xDF
1234:  MOVLW  00
1236:  ADDWFC 02,W
1238:  MOVWF  xE0
123A:  MOVLW  00
123C:  ADDWFC 03,W
123E:  MOVWF  xE1
1240:  MOVLW  01
1242:  MOVLB  1
1244:  SUBWF  xF7,W
1246:  MULLW  04
1248:  MOVF   FF3,W
124A:  CLRF   03
124C:  ADDLW  97
124E:  MOVWF  FE9
1250:  MOVLW  01
1252:  ADDWFC 03,W
1254:  MOVWF  FEA
1256:  MOVFF  FEF,00
125A:  MOVFF  FEC,01
125E:  MOVFF  FEC,02
1262:  MOVFF  FEC,03
1266:  MOVF   00,W
1268:  MOVLB  3
126A:  ADDWF  xDE,W
126C:  MOVLB  1
126E:  MOVWF  xF3
1270:  MOVF   01,W
1272:  MOVLB  3
1274:  ADDWFC xDF,W
1276:  MOVLB  1
1278:  MOVWF  xF4
127A:  MOVF   02,W
127C:  MOVLB  3
127E:  ADDWFC xE0,W
1280:  MOVLB  1
1282:  MOVWF  xF5
1284:  MOVF   03,W
1286:  MOVLB  3
1288:  ADDWFC xE1,W
128A:  MOVLB  1
128C:  MOVWF  xF6
....................             atual_frequencia_x--; 
128E:  DECF   xF7,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
1290:  MOVF   xF7,W
1292:  MULLW  04
1294:  MOVF   FF3,W
1296:  CLRF   03
1298:  ADDLW  47
129A:  MOVWF  FE9
129C:  MOVLW  01
129E:  ADDWFC 03,W
12A0:  MOVWF  FEA
12A2:  MOVFF  FEF,00
12A6:  MOVFF  FEC,01
12AA:  MOVFF  FEC,02
12AE:  MOVFF  FEC,03
12B2:  MOVLW  FF
12B4:  BSF    FD8.0
12B6:  SUBFWB 00,W
12B8:  MOVLB  3
12BA:  MOVWF  xDE
12BC:  MOVLW  FF
12BE:  SUBFWB 01,W
12C0:  MOVWF  xDF
12C2:  MOVLW  00
12C4:  SUBFWB 02,W
12C6:  MOVLW  00
12C8:  SUBFWB 03,W
12CA:  MOVFF  3DF,FD7
12CE:  MOVFF  3DE,FD6
....................         } else { 
12D2:  BRA    1318
12D4:  MOVLB  1
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
12D6:  MOVF   xF7,W
12D8:  MULLW  04
12DA:  MOVF   FF3,W
12DC:  CLRF   03
12DE:  ADDLW  47
12E0:  MOVWF  FE9
12E2:  MOVLW  01
12E4:  ADDWFC 03,W
12E6:  MOVWF  FEA
12E8:  MOVFF  FEF,00
12EC:  MOVFF  FEC,01
12F0:  MOVFF  FEC,02
12F4:  MOVFF  FEC,03
12F8:  MOVLW  FF
12FA:  BSF    FD8.0
12FC:  SUBFWB 00,W
12FE:  MOVLB  3
1300:  MOVWF  xDE
1302:  MOVLW  FF
1304:  SUBFWB 01,W
1306:  MOVWF  xDF
1308:  MOVLW  00
130A:  SUBFWB 02,W
130C:  MOVLW  00
130E:  SUBFWB 03,W
1310:  MOVFF  3DF,FD7
1314:  MOVFF  3DE,FD6
....................         } 
....................     } else { 
1318:  BRA    13EC
131A:  MOVLB  1
....................         if (step_no_x == step_acumulado_x) { 
131C:  MOVF   xF3,W
131E:  SUBWF  xEB,W
1320:  BNZ   13AA
1322:  MOVF   xF4,W
1324:  SUBWF  xEC,W
1326:  BNZ   13AA
1328:  MOVF   xF5,F
132A:  BNZ   13AA
132C:  MOVF   xF6,F
132E:  BNZ   13AA
....................             atual_frequencia_x--; 
1330:  DECF   xF7,F
....................             step_acumulado_x += StepbyF_x[atual_frequencia_x]; 
1332:  MOVF   xF7,W
1334:  MULLW  04
1336:  MOVF   FF3,W
1338:  CLRF   03
133A:  ADDLW  97
133C:  MOVWF  FE9
133E:  MOVLW  01
1340:  ADDWFC 03,W
1342:  MOVWF  FEA
1344:  MOVFF  FEF,00
1348:  MOVFF  FEC,01
134C:  MOVFF  FEC,02
1350:  MOVFF  FEC,03
1354:  MOVF   00,W
1356:  ADDWF  xF3,F
1358:  MOVF   01,W
135A:  ADDWFC xF4,F
135C:  MOVF   02,W
135E:  ADDWFC xF5,F
1360:  MOVF   03,W
1362:  ADDWFC xF6,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
1364:  MOVF   xF7,W
1366:  MULLW  04
1368:  MOVF   FF3,W
136A:  CLRF   03
136C:  ADDLW  47
136E:  MOVWF  FE9
1370:  MOVLW  01
1372:  ADDWFC 03,W
1374:  MOVWF  FEA
1376:  MOVFF  FEF,00
137A:  MOVFF  FEC,01
137E:  MOVFF  FEC,02
1382:  MOVFF  FEC,03
1386:  MOVLW  FF
1388:  BSF    FD8.0
138A:  SUBFWB 00,W
138C:  MOVLB  3
138E:  MOVWF  xDE
1390:  MOVLW  FF
1392:  SUBFWB 01,W
1394:  MOVWF  xDF
1396:  MOVLW  00
1398:  SUBFWB 02,W
139A:  MOVLW  00
139C:  SUBFWB 03,W
139E:  MOVFF  3DF,FD7
13A2:  MOVFF  3DE,FD6
....................         } else { 
13A6:  BRA    13EC
13A8:  MOVLB  1
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
13AA:  MOVF   xF7,W
13AC:  MULLW  04
13AE:  MOVF   FF3,W
13B0:  CLRF   03
13B2:  ADDLW  47
13B4:  MOVWF  FE9
13B6:  MOVLW  01
13B8:  ADDWFC 03,W
13BA:  MOVWF  FEA
13BC:  MOVFF  FEF,00
13C0:  MOVFF  FEC,01
13C4:  MOVFF  FEC,02
13C8:  MOVFF  FEC,03
13CC:  MOVLW  FF
13CE:  BSF    FD8.0
13D0:  SUBFWB 00,W
13D2:  MOVLB  3
13D4:  MOVWF  xDE
13D6:  MOVLW  FF
13D8:  SUBFWB 01,W
13DA:  MOVWF  xDF
13DC:  MOVLW  00
13DE:  SUBFWB 02,W
13E0:  MOVLW  00
13E2:  SUBFWB 03,W
13E4:  MOVFF  3DF,FD7
13E8:  MOVFF  3DE,FD6
....................         } 
....................     } 
13EC:  MOVLB  0
13EE:  GOTO   1446 (RETURN)
.................... } 
....................  
.................... void movimenta_eixo_x() { 
....................   
....................     switch (ramp_sts_x) { 
13F2:  MOVLB  1
13F4:  MOVF   xEA,W
13F6:  XORLW  01
13F8:  MOVLB  0
13FA:  BZ    1406
13FC:  XORLW  02
13FE:  BZ    1444
1400:  XORLW  01
1402:  BZ    1460
1404:  BRA    147E
....................         case ramp_up: // accel 
....................             proximo_valor_subida_x(); 
1406:  RCALL  0F12
....................             if (step_no_x == midpt_x) { // midpoint: decel 
1408:  MOVLB  1
140A:  MOVF   xF1,W
140C:  SUBWF  xEB,W
140E:  BNZ   143C
1410:  MOVF   xF2,W
1412:  SUBWF  xEC,W
1414:  BNZ   143C
....................                 if (move_x > 2 * total_acc_step_x) 
1416:  BCF    FD8.0
1418:  RLCF   xE7,W
141A:  MOVWF  02
141C:  RLCF   xE8,W
141E:  MOVWF  03
1420:  MOVFF  02,01
1424:  MOVF   03,W
1426:  SUBWF  xF0,W
1428:  BNC   1438
142A:  BNZ   1432
142C:  MOVF   xEF,W
142E:  SUBWF  01,W
1430:  BC    1438
....................                     ramp_sts_x = ramp_max; 
1432:  MOVLW  02
1434:  MOVWF  xEA
1436:  BRA    143C
....................                 else 
....................                     ramp_sts_x = ramp_down; 
1438:  MOVLW  03
143A:  MOVWF  xEA
....................             } 
....................             output_toggle(step_x); 
143C:  BCF    F95.2
143E:  BTG    F8C.2
....................             rest_x = ~rest_x; 
1440:  BTG    x1A.4
....................             break; 
1442:  BRA    1486
....................  
....................         case ramp_down: // decel 
....................             proximo_valor_descida_x(); 
1444:  BRA    1168
....................             if (step_no_x == move_x) 
1446:  MOVLB  1
1448:  MOVF   xEF,W
144A:  SUBWF  xEB,W
144C:  BNZ   1458
144E:  MOVF   xF0,W
1450:  SUBWF  xEC,W
1452:  BNZ   1458
....................                 ramp_sts_x = ramp_last; 
1454:  MOVLW  04
1456:  MOVWF  xEA
....................             output_toggle(step_x); 
1458:  BCF    F95.2
145A:  BTG    F8C.2
....................             rest_x = ~rest_x; 
145C:  BTG    x1A.4
....................             break; 
145E:  BRA    1486
....................  
....................         case ramp_max: // constant speed 
....................             proximo_valor_subida_x(); 
1460:  RCALL  0F12
....................             if (step_no_x == step_down_x) // start decel 
1462:  MOVLB  1
1464:  MOVF   xED,W
1466:  SUBWF  xEB,W
1468:  BNZ   1474
146A:  MOVF   xEE,W
146C:  SUBWF  xEC,W
146E:  BNZ   1474
....................                 ramp_sts_x = ramp_down; 
1470:  MOVLW  03
1472:  MOVWF  xEA
....................             output_toggle(step_x); 
1474:  BCF    F95.2
1476:  BTG    F8C.2
....................             rest_x = ~rest_x; 
1478:  BTG    x1A.4
....................             break; 
147A:  BRA    1486
147C:  MOVLB  0
....................  
....................         default: // last step: cleanup 
....................             ramp_sts_x = ramp_idle; 
147E:  MOVLB  1
1480:  CLRF   xEA
....................             disable_interrupts(INT_TIMER0); 
1482:  BCF    FF2.5
....................             run_flg_x = FALSE; // move_x complete 
1484:  BCF    x1A.3
....................             break; 
....................     } // switch (ramp_sts_x) 
....................     if ((ramp_sts_x != ramp_idle)&&(ramp_sts_x != ramp_last)) { 
1486:  MOVF   xEA,F
1488:  BZ    14B2
148A:  MOVF   xEA,W
148C:  SUBLW  04
148E:  BZ    14B2
....................         if (rest_x) { 
1490:  BTFSS  x1A.4
1492:  BRA    14B2
....................             motor_pos_x += pos_inc_x; 
1494:  CLRF   03
1496:  MOVF   xE9,W
1498:  BTFSC  FE8.7
149A:  DECF   03,F
149C:  ADDWF  x12,W
149E:  MOVWF  01
14A0:  MOVF   x13,W
14A2:  ADDWFC 03,F
14A4:  MOVFF  01,112
14A8:  MOVFF  03,113
....................             ++step_no_x;    
14AC:  INCF   xEB,F
14AE:  BTFSC  FD8.2
14B0:  INCF   xEC,F
....................         } 
....................     } 
14B2:  MOVLB  0
14B4:  GOTO   14BA (RETURN)
.................... } 
....................  
.................... void umpasso_x(int16 descanco, short dir) { 
....................     output_low(enable_x); 
....................     if (dir) { 
....................         output_high(dir_x); 
....................         motor_pos_x++; 
....................     } else { 
....................         output_low(dir_x); 
....................         motor_pos_x--; 
....................     } 
....................     output_high(step_x); 
....................     delay_us(descanco); 
....................     output_low(step_x); 
....................     delay_us(descanco); 
....................      
.................... } 
....................  
.................... void zerar_x() { 
....................     while(le_Input(i_limite_x)==1){ 
....................         delay_us(200); 
....................         umpasso_x(600, TRUE); 
....................     } 
....................     while (le_Input(i_limite_x)==0){ 
....................         umpasso_x(900, FALSE); 
....................         delay_us(200); 
....................     } 
....................     while(le_Input(i_limite_x)==1){ 
....................         delay_us(200); 
....................         umpasso_x(1000, TRUE); 
....................     } 
....................     motor_pos_x = 0; 
....................     output_high(enable_x); 
.................... } 
.................... // </editor-fold> 
....................  
.................... #include "Axis_y.c" 
.................... // <editor-fold defaultstate="collapsed" desc="Valores que devem ser inseridos"> 
.................... float stepbyrev_y = 200; 
.................... float driver_u_step_y = 1; // caso o driver esteja em 400 
.................... float Leadscrew_y = 9; //redutor de voltas do motor 
.................... float Leadscrew_Pich_y = 150; //esse valor deve ser em mm/revoluo 
.................... float Vmax_y = 30; //esse valor deve ser em mm por segundo 
.................... float Vmin_y = 10; 
.................... float Amax_y = 200; //esse valor deve ser em mm por segundo 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Valores calculo rampa"> 
.................... float MMbyStep_y = 0; 
.................... int8 StepinAcc_y = 20; 
.................... float Fmax_y = 0; 
.................... float Fmin_y = 100; 
.................... int32 Ts_y[20]; 
.................... int32 StepbyF_y[20]; 
.................... int16 total_acc_step_y = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Flags e Controles de Movimento"> 
.................... signed int8 pos_inc_y = 0; 
.................... int8 ramp_sts_y = ramp_idle; 
.................... short run_flg_y = FALSE; 
.................... short rest_y = FALSE; 
.................... short stop_yf = FALSE; 
.................... int16 step_no_y = 0; 
.................... int16 step_down_y = 0; 
.................... int16 move_y = 0; 
.................... int16 midpt_y = 0; 
.................... int32 step_acumulado_y = 0; 
.................... int atual_frequencia_y = 0; 
.................... int vel_y = 19; 
.................... int16 max_posicao_y=0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Pinos Motor"> 
....................  
.................... #DEFINE     i_limite_y            7 
.................... #DEFINE     s_limite_y            8 
....................  
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Inicializa Motor"> 
.................... void init_axis_y() { 
....................     set_tris_c(0xf8); 
*
30DE:  MOVLW  F8
30E0:  MOVWF  F94
....................     output_high(step_y); 
30E2:  BCF    F94.2
30E4:  BSF    F8B.2
....................     output_high(enable_y); 
30E6:  BCF    F94.0
30E8:  BSF    F8B.0
....................     output_high(dir_y); 
30EA:  BCF    F94.1
30EC:  BSF    F8B.1
....................  
....................     MMbyStep_y = Leadscrew_Pich_y / (stepbyrev_y * driver_u_step_y * Leadscrew_y); 
30EE:  MOVFF  1FC,3CB
30F2:  MOVFF  1FB,3CA
30F6:  MOVFF  1FA,3C9
30FA:  MOVFF  1F9,3C8
30FE:  MOVFF  200,3CF
3102:  MOVFF  1FF,3CE
3106:  MOVFF  1FE,3CD
310A:  MOVFF  1FD,3CC
310E:  CALL   2628
3112:  MOVFF  03,3BD
3116:  MOVFF  02,3BC
311A:  MOVFF  01,3BB
311E:  MOVFF  00,3BA
3122:  MOVFF  03,3CB
3126:  MOVFF  02,3CA
312A:  MOVFF  01,3C9
312E:  MOVFF  00,3C8
3132:  MOVFF  204,3CF
3136:  MOVFF  203,3CE
313A:  MOVFF  202,3CD
313E:  MOVFF  201,3CC
3142:  CALL   2628
3146:  MOVFF  208,3D1
314A:  MOVFF  207,3D0
314E:  MOVFF  206,3CF
3152:  MOVFF  205,3CE
3156:  MOVFF  03,3D5
315A:  MOVFF  02,3D4
315E:  MOVFF  01,3D3
3162:  MOVFF  00,3D2
3166:  CALL   271E
316A:  MOVFF  03,218
316E:  MOVFF  02,217
3172:  MOVFF  01,216
3176:  MOVFF  00,215
....................     Fmax_y = Vmax_y/MMbyStep_y; //Valor de ferequencia adiquirido em hz 
317A:  MOVFF  20C,3D1
317E:  MOVFF  20B,3D0
3182:  MOVFF  20A,3CF
3186:  MOVFF  209,3CE
318A:  MOVFF  218,3D5
318E:  MOVFF  217,3D4
3192:  MOVFF  216,3D3
3196:  MOVFF  215,3D2
319A:  CALL   271E
319E:  MOVFF  03,21D
31A2:  MOVFF  02,21C
31A6:  MOVFF  01,21B
31AA:  MOVFF  00,21A
....................      
....................     float den = Amax_y*StepinAcc_y; 
....................     float num = (Vmax_y-Vmin_y)*1000000; 
....................     float TbyF = num/den;//tempo em us 
....................      
....................     int i = 0; 
31AE:  MOVLB  3
31B0:  CLRF   xC9
31B2:  MOVFF  219,3C8
31B6:  MOVLB  0
31B8:  CALL   287C
31BC:  MOVFF  214,3CB
31C0:  MOVFF  213,3CA
31C4:  MOVFF  212,3C9
31C8:  MOVFF  211,3C8
31CC:  MOVFF  03,3CF
31D0:  MOVFF  02,3CE
31D4:  MOVFF  01,3CD
31D8:  MOVFF  00,3CC
31DC:  CALL   2628
31E0:  MOVFF  03,3B0
31E4:  MOVFF  02,3AF
31E8:  MOVFF  01,3AE
31EC:  MOVFF  00,3AD
31F0:  BSF    FD8.1
31F2:  MOVFF  20C,3D1
31F6:  MOVFF  20B,3D0
31FA:  MOVFF  20A,3CF
31FE:  MOVFF  209,3CE
3202:  MOVFF  210,3D5
3206:  MOVFF  20F,3D4
320A:  MOVFF  20E,3D3
320E:  MOVFF  20D,3D2
3212:  CALL   28B2
3216:  MOVFF  03,3BD
321A:  MOVFF  02,3BC
321E:  MOVFF  01,3BB
3222:  MOVFF  00,3BA
3226:  MOVFF  03,3CB
322A:  MOVFF  02,3CA
322E:  MOVFF  01,3C9
3232:  MOVFF  00,3C8
3236:  MOVLB  3
3238:  CLRF   xCF
323A:  MOVLW  24
323C:  MOVWF  xCE
323E:  MOVLW  74
3240:  MOVWF  xCD
3242:  MOVLW  92
3244:  MOVWF  xCC
3246:  MOVLB  0
3248:  CALL   2628
324C:  MOVFF  03,3B4
3250:  MOVFF  02,3B3
3254:  MOVFF  01,3B2
3258:  MOVFF  00,3B1
325C:  MOVFF  3B4,3D1
3260:  MOVFF  3B3,3D0
3264:  MOVFF  3B2,3CF
3268:  MOVFF  3B1,3CE
326C:  MOVFF  3B0,3D5
3270:  MOVFF  3AF,3D4
3274:  MOVFF  3AE,3D3
3278:  MOVFF  3AD,3D2
327C:  CALL   271E
3280:  MOVFF  03,3B8
3284:  MOVFF  02,3B7
3288:  MOVFF  01,3B6
328C:  MOVFF  00,3B5
3290:  MOVLB  3
3292:  CLRF   xB9
....................     for(i = 1; i <=StepinAcc_y;i++) 
3294:  MOVLW  01
3296:  MOVWF  xB9
3298:  MOVF   xB9,W
329A:  MOVLB  2
329C:  SUBWF  x19,W
329E:  BTFSS  FD8.0
32A0:  BRA    35D8
....................     { 
....................         Ts_y[i-1]=(1000000*StepinAcc_y)/((i*(Fmax_y-Fmin_y)+Fmin_y)); 
32A2:  MOVLW  01
32A4:  MOVLB  3
32A6:  SUBWF  xB9,W
32A8:  MULLW  04
32AA:  MOVF   FF3,W
32AC:  CLRF   03
32AE:  ADDLW  22
32B0:  MOVWF  FE9
32B2:  MOVLW  02
32B4:  ADDWFC 03,W
32B6:  MOVWF  FEA
32B8:  MOVFF  FEA,3BD
32BC:  MOVFF  FE9,3BC
32C0:  CLRF   xC1
32C2:  MOVLW  0F
32C4:  MOVWF  xC0
32C6:  MOVLW  42
32C8:  MOVWF  xBF
32CA:  MOVLW  40
32CC:  MOVWF  xBE
32CE:  CLRF   xC5
32D0:  CLRF   xC4
32D2:  CLRF   xC3
32D4:  MOVFF  219,3C2
32D8:  MOVLB  0
32DA:  RCALL  2B2A
32DC:  MOVFF  3BD,FEA
32E0:  MOVFF  3BC,FE9
32E4:  MOVFF  03,3C1
32E8:  MOVFF  02,3C0
32EC:  MOVFF  01,3BF
32F0:  MOVFF  00,3BE
32F4:  MOVFF  FEA,3C3
32F8:  MOVFF  FE9,3C2
32FC:  BSF    FD8.1
32FE:  MOVFF  21D,3D1
3302:  MOVFF  21C,3D0
3306:  MOVFF  21B,3CF
330A:  MOVFF  21A,3CE
330E:  MOVFF  221,3D5
3312:  MOVFF  220,3D4
3316:  MOVFF  21F,3D3
331A:  MOVFF  21E,3D2
331E:  CALL   28B2
3322:  MOVFF  3C3,FEA
3326:  MOVFF  3C2,FE9
332A:  MOVFF  03,3C7
332E:  MOVFF  02,3C6
3332:  MOVFF  01,3C5
3336:  MOVFF  00,3C4
333A:  MOVLB  3
333C:  CLRF   xC9
333E:  MOVFF  3B9,3C8
3342:  MOVLB  0
3344:  CALL   287C
3348:  MOVFF  03,3CB
334C:  MOVFF  02,3CA
3350:  MOVFF  01,3C9
3354:  MOVFF  00,3C8
3358:  MOVFF  3C7,3CF
335C:  MOVFF  3C6,3CE
3360:  MOVFF  3C5,3CD
3364:  MOVFF  3C4,3CC
3368:  CALL   2628
336C:  MOVFF  03,3CB
3370:  MOVFF  02,3CA
3374:  MOVFF  01,3C9
3378:  MOVFF  00,3C8
337C:  MOVFF  FEA,3CD
3380:  MOVFF  FE9,3CC
3384:  BCF    FD8.1
3386:  MOVFF  03,3D1
338A:  MOVFF  02,3D0
338E:  MOVFF  01,3CF
3392:  MOVFF  00,3CE
3396:  MOVFF  221,3D5
339A:  MOVFF  220,3D4
339E:  MOVFF  21F,3D3
33A2:  MOVFF  21E,3D2
33A6:  CALL   28B2
33AA:  MOVFF  3CD,FEA
33AE:  MOVFF  3CC,FE9
33B2:  MOVFF  03,3CB
33B6:  MOVFF  02,3CA
33BA:  MOVFF  01,3C9
33BE:  MOVFF  00,3C8
33C2:  MOVFF  3C1,3D1
33C6:  MOVFF  3C0,3D0
33CA:  MOVFF  3BF,3CF
33CE:  MOVFF  3BE,3CE
33D2:  CALL   2B86
33D6:  MOVFF  03,3D1
33DA:  MOVFF  02,3D0
33DE:  MOVFF  01,3CF
33E2:  MOVFF  00,3CE
33E6:  MOVFF  3CB,3D5
33EA:  MOVFF  3CA,3D4
33EE:  MOVFF  3C9,3D3
33F2:  MOVFF  3C8,3D2
33F6:  CALL   271E
33FA:  MOVFF  03,3D1
33FE:  MOVFF  02,3D0
3402:  MOVFF  01,3CF
3406:  MOVFF  00,3CE
340A:  CALL   2BBE
340E:  MOVFF  00,FEF
3412:  MOVFF  01,FEC
3416:  MOVFF  02,FEC
341A:  MOVFF  03,FEC
....................         StepbyF_y[i-1] = 2*TbyF/Ts_y[i-1]; 
341E:  MOVLW  01
3420:  MOVLB  3
3422:  SUBWF  xB9,W
3424:  MULLW  04
3426:  MOVF   FF3,W
3428:  CLRF   03
342A:  ADDLW  72
342C:  MOVWF  01
342E:  MOVLW  02
3430:  ADDWFC 03,F
3432:  MOVFF  01,3BA
3436:  MOVFF  03,3BB
343A:  CLRF   xCB
343C:  CLRF   xCA
343E:  CLRF   xC9
3440:  MOVLW  80
3442:  MOVWF  xC8
3444:  MOVFF  3B8,3CF
3448:  MOVFF  3B7,3CE
344C:  MOVFF  3B6,3CD
3450:  MOVFF  3B5,3CC
3454:  MOVLB  0
3456:  CALL   2628
345A:  MOVFF  03,3BF
345E:  MOVFF  02,3BE
3462:  MOVFF  01,3BD
3466:  MOVFF  00,3BC
346A:  MOVLW  01
346C:  MOVLB  3
346E:  SUBWF  xB9,W
3470:  MULLW  04
3472:  MOVF   FF3,W
3474:  CLRF   03
3476:  ADDLW  22
3478:  MOVWF  FE9
347A:  MOVLW  02
347C:  ADDWFC 03,W
347E:  MOVWF  FEA
3480:  MOVFF  FEF,00
3484:  MOVFF  FEC,01
3488:  MOVFF  FEC,02
348C:  MOVFF  FEC,03
3490:  MOVFF  03,3D1
3494:  MOVFF  02,3D0
3498:  MOVFF  01,3CF
349C:  MOVFF  00,3CE
34A0:  MOVLB  0
34A2:  CALL   2B86
34A6:  MOVFF  3BF,3D1
34AA:  MOVFF  3BE,3D0
34AE:  MOVFF  3BD,3CF
34B2:  MOVFF  3BC,3CE
34B6:  MOVFF  03,3D5
34BA:  MOVFF  02,3D4
34BE:  MOVFF  01,3D3
34C2:  MOVFF  00,3D2
34C6:  CALL   271E
34CA:  MOVFF  03,3D1
34CE:  MOVFF  02,3D0
34D2:  MOVFF  01,3CF
34D6:  MOVFF  00,3CE
34DA:  CALL   2BBE
34DE:  MOVFF  3BB,FEA
34E2:  MOVFF  3BA,FE9
34E6:  MOVFF  00,FEF
34EA:  MOVFF  01,FEC
34EE:  MOVFF  02,FEC
34F2:  MOVFF  03,FEC
....................         total_acc_step_y += StepbyF_y[i-1]; 
34F6:  MOVLW  01
34F8:  MOVLB  3
34FA:  SUBWF  xB9,W
34FC:  MULLW  04
34FE:  MOVF   FF3,W
3500:  CLRF   03
3502:  ADDLW  72
3504:  MOVWF  FE9
3506:  MOVLW  02
3508:  ADDWFC 03,W
350A:  MOVWF  FEA
350C:  MOVFF  FEF,00
3510:  MOVFF  FEC,01
3514:  MOVFF  FEC,02
3518:  MOVFF  FEC,03
351C:  MOVF   00,W
351E:  MOVLB  2
3520:  ADDWF  xC2,F
3522:  MOVF   01,W
3524:  ADDWFC xC3,F
....................         Ts_y[i-1] = Ts_y[i-1]/(8*0.2*2);//Tempo/(prescale*ciclodemaquina*metadedociclo) 
3526:  MOVLW  01
3528:  MOVLB  3
352A:  SUBWF  xB9,W
352C:  MULLW  04
352E:  MOVF   FF3,W
3530:  CLRF   03
3532:  ADDLW  22
3534:  MOVWF  01
3536:  MOVLW  02
3538:  ADDWFC 03,F
353A:  MOVFF  01,3BA
353E:  MOVFF  03,3BB
3542:  MOVLW  01
3544:  SUBWF  xB9,W
3546:  MULLW  04
3548:  MOVF   FF3,W
354A:  CLRF   03
354C:  ADDLW  22
354E:  MOVWF  FE9
3550:  MOVLW  02
3552:  ADDWFC 03,W
3554:  MOVWF  FEA
3556:  MOVFF  FEF,3BC
355A:  MOVFF  FEC,3BD
355E:  MOVFF  FEC,3BE
3562:  MOVFF  FEC,3BF
3566:  MOVFF  3BF,3D1
356A:  MOVFF  3BE,3D0
356E:  MOVFF  3BD,3CF
3572:  MOVFF  3BC,3CE
3576:  MOVLB  0
3578:  CALL   2B86
357C:  MOVFF  03,3D1
3580:  MOVFF  02,3D0
3584:  MOVFF  01,3CF
3588:  MOVFF  00,3CE
358C:  MOVLW  CD
358E:  MOVLB  3
3590:  MOVWF  xD5
3592:  MOVLW  CC
3594:  MOVWF  xD4
3596:  MOVLW  4C
3598:  MOVWF  xD3
359A:  MOVLW  80
359C:  MOVWF  xD2
359E:  MOVLB  0
35A0:  CALL   271E
35A4:  MOVFF  03,3D1
35A8:  MOVFF  02,3D0
35AC:  MOVFF  01,3CF
35B0:  MOVFF  00,3CE
35B4:  CALL   2BBE
35B8:  MOVFF  3BB,FEA
35BC:  MOVFF  3BA,FE9
35C0:  MOVFF  00,FEF
35C4:  MOVFF  01,FEC
35C8:  MOVFF  02,FEC
35CC:  MOVFF  03,FEC
35D0:  MOVLB  3
35D2:  INCF   xB9,F
35D4:  BRA    3298
35D6:  MOVLB  2
....................     } 
35D8:  MOVLB  0
35DA:  GOTO   A8F0 (RETURN)
.................... } 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Movimento Motor"> 
.................... void motor_stop_y(){ 
....................     step_no_y = step_down_y; 
....................     ramp_sts_y = ramp_down; 
.................... } 
....................  
.................... void motor_disable_y(){ 
....................     output_high(enable_y); 
....................     disable_interrupts(INT_TIMER1); 
.................... } 
....................  
.................... void motor_run_y(int32 pos_new, int velocidade) { // set up to drive motor to pos_new (absolute step#) 
....................     vel_y = velocidade; 
*
5802:  MOVFF  3B8,2D3
....................     total_acc_step_y = 0; 
5806:  MOVLB  2
5808:  CLRF   xC3
580A:  CLRF   xC2
....................      
....................     if (pos_new < motor_pos_y) // get dir_yection & #steps 
580C:  MOVLB  3
580E:  MOVF   xB7,F
5810:  BNZ   5850
5812:  MOVF   xB6,F
5814:  BNZ   5850
5816:  MOVF   xB5,W
5818:  MOVLB  1
581A:  SUBWF  x15,W
581C:  BTFSC  FD8.0
581E:  BRA    5824
5820:  MOVLB  3
5822:  BRA    5850
5824:  BNZ   5830
5826:  MOVF   x14,W
5828:  MOVLB  3
582A:  SUBWF  xB4,W
582C:  BC    5850
582E:  MOVLB  1
....................     { 
....................         output_low(dir_y); 
5830:  BCF    F94.1
5832:  BCF    F8B.1
....................         move_y = motor_pos_y - pos_new; 
5834:  MOVLB  3
5836:  MOVF   xB4,W
5838:  MOVLB  1
583A:  SUBWF  x14,W
583C:  MOVLB  2
583E:  MOVWF  xCA
5840:  MOVLB  3
5842:  MOVF   xB5,W
5844:  MOVLB  1
5846:  SUBWFB x15,W
5848:  MOVLB  2
584A:  MOVWF  xCB
....................         pos_inc_y = -1; 
584C:  SETF   xC4
....................     } else if (pos_new != motor_pos_y) { 
584E:  BRA    5894
5850:  MOVLB  1
5852:  MOVF   x14,W
5854:  MOVLB  3
5856:  SUBWF  xB4,W
5858:  BNZ   586C
585A:  MOVLB  1
585C:  MOVF   x15,W
585E:  MOVLB  3
5860:  SUBWF  xB5,W
5862:  BNZ   586C
5864:  MOVF   xB6,F
5866:  BNZ   586C
5868:  MOVF   xB7,F
586A:  BZ    5890
....................         output_high(dir_y); 
586C:  BCF    F94.1
586E:  BSF    F8B.1
....................         move_y = pos_new - motor_pos_y; 
5870:  MOVLB  1
5872:  MOVF   x14,W
5874:  MOVLB  3
5876:  SUBWF  xB4,W
5878:  MOVLB  2
587A:  MOVWF  xCA
587C:  MOVLB  1
587E:  MOVF   x15,W
5880:  MOVLB  3
5882:  SUBWFB xB5,W
5884:  MOVLB  2
5886:  MOVWF  xCB
....................         pos_inc_y = 1; 
5888:  MOVLW  01
588A:  MOVWF  xC4
....................     } else return; 
588C:  BRA    5894
588E:  MOVLB  3
5890:  BRA    597A
5892:  MOVLB  2
....................  
....................     for(int j = 0; j <= velocidade;j++) 
5894:  MOVLB  3
5896:  CLRF   xB9
5898:  MOVF   xB9,W
589A:  SUBWF  xB8,W
589C:  BNC   58D0
....................     { 
....................         total_acc_step_y += StepbyF_y[j]; 
589E:  MOVF   xB9,W
58A0:  MULLW  04
58A2:  MOVF   FF3,W
58A4:  CLRF   03
58A6:  ADDLW  72
58A8:  MOVWF  FE9
58AA:  MOVLW  02
58AC:  ADDWFC 03,W
58AE:  MOVWF  FEA
58B0:  MOVFF  FEF,00
58B4:  MOVFF  FEC,01
58B8:  MOVFF  FEC,02
58BC:  MOVFF  FEC,03
58C0:  MOVF   00,W
58C2:  MOVLB  2
58C4:  ADDWF  xC2,F
58C6:  MOVF   01,W
58C8:  ADDWFC xC3,F
58CA:  MOVLB  3
58CC:  INCF   xB9,F
58CE:  BRA    5898
....................     } 
....................     if (move_y > 2 * total_acc_step_y) { 
58D0:  BCF    FD8.0
58D2:  MOVLB  2
58D4:  RLCF   xC2,W
58D6:  MOVWF  02
58D8:  RLCF   xC3,W
58DA:  MOVWF  03
58DC:  MOVFF  02,01
58E0:  MOVF   03,W
58E2:  SUBWF  xCB,W
58E4:  BNC   5904
58E6:  BNZ   58EE
58E8:  MOVF   xCA,W
58EA:  SUBWF  01,W
58EC:  BC    5904
....................         midpt_y = total_acc_step_y; 
58EE:  MOVFF  2C3,2CD
58F2:  MOVFF  2C2,2CC
....................         step_down_y = move_y - total_acc_step_y; 
58F6:  MOVF   xC2,W
58F8:  SUBWF  xCA,W
58FA:  MOVWF  xC8
58FC:  MOVF   xC3,W
58FE:  SUBWFB xCB,W
5900:  MOVWF  xC9
....................     }  
5902:  BRA    592E
....................     else 
....................     { 
....................         midpt_y = (move_y - 1) >> 1; 
5904:  MOVLW  01
5906:  SUBWF  xCA,W
5908:  MOVLB  3
590A:  MOVWF  xBA
590C:  MOVLW  00
590E:  MOVLB  2
5910:  SUBWFB xCB,W
5912:  MOVLB  3
5914:  MOVWF  xBB
5916:  BCF    FD8.0
5918:  RRCF   xBB,W
591A:  MOVLB  2
591C:  MOVWF  xCD
591E:  MOVLB  3
5920:  RRCF   xBA,W
5922:  MOVLB  2
5924:  MOVWF  xCC
....................         step_down_y = midpt_y; 
5926:  MOVFF  2CD,2C9
592A:  MOVFF  2CC,2C8
....................     } 
....................     step_no_y = 0; 
592E:  CLRF   xC7
5930:  CLRF   xC6
....................     step_acumulado_y = 0; 
5932:  CLRF   xD1
5934:  CLRF   xD0
5936:  CLRF   xCF
5938:  CLRF   xCE
....................     atual_frequencia_y = 0; 
593A:  CLRF   xD2
....................     ramp_sts_y = ramp_up; // start ramp state-machine 
593C:  MOVLW  01
593E:  MOVWF  xC5
....................     run_flg_y = TRUE; 
5940:  MOVLB  1
5942:  BSF    x1A.5
....................     output_low(enable_y); 
5944:  BCF    F94.0
5946:  BCF    F8B.0
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
5948:  MOVLW  B5
594A:  MOVWF  FCD
....................     set_timer1(65535 - Ts_y[0]); 
594C:  MOVLW  FF
594E:  BSF    FD8.0
5950:  MOVLB  2
5952:  SUBFWB x22,W
5954:  MOVLB  3
5956:  MOVWF  xBA
5958:  MOVLW  FF
595A:  MOVLB  2
595C:  SUBFWB x23,W
595E:  MOVLB  3
5960:  MOVWF  xBB
5962:  MOVLW  00
5964:  MOVLB  2
5966:  SUBFWB x24,W
5968:  MOVLW  00
596A:  MOVLB  2
596C:  SUBFWB x25,W
596E:  MOVLB  3
5970:  MOVFF  3BB,FCF
5974:  MOVFF  3BA,FCE
....................     enable_interrupts(INT_TIMER1); 
5978:  BSF    F9D.0
597A:  MOVLB  0
597C:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_subida_y() { 
....................     if (atual_frequencia_y == 0) { 
*
14C0:  MOVLB  2
14C2:  MOVF   xD2,F
14C4:  BTFSS  FD8.2
14C6:  BRA    15F6
....................         if (step_no_y == StepbyF_y[atual_frequencia_y]) { 
14C8:  MOVF   xD2,W
14CA:  MULLW  04
14CC:  MOVF   FF3,W
14CE:  CLRF   03
14D0:  ADDLW  72
14D2:  MOVWF  FE9
14D4:  MOVLW  02
14D6:  ADDWFC 03,W
14D8:  MOVWF  FEA
14DA:  MOVFF  FEF,00
14DE:  MOVFF  FEC,01
14E2:  MOVFF  FEC,02
14E6:  MOVFF  FEC,03
14EA:  MOVF   00,W
14EC:  SUBWF  xC6,W
14EE:  BNZ   15B0
14F0:  MOVF   01,W
14F2:  SUBWF  xC7,W
14F4:  BNZ   15B0
14F6:  MOVF   02,F
14F8:  BNZ   15B0
14FA:  MOVF   03,F
14FC:  BNZ   15B0
....................             step_acumulado_y += StepbyF_y[atual_frequencia_y] + StepbyF_y[atual_frequencia_y + 1]; 
14FE:  MOVF   xD2,W
1500:  MULLW  04
1502:  MOVF   FF3,W
1504:  CLRF   03
1506:  ADDLW  72
1508:  MOVWF  FE9
150A:  MOVLW  02
150C:  ADDWFC 03,W
150E:  MOVWF  FEA
1510:  MOVFF  FEF,3DE
1514:  MOVFF  FEC,3DF
1518:  MOVFF  FEC,3E0
151C:  MOVFF  FEC,3E1
1520:  MOVLW  01
1522:  ADDWF  xD2,W
1524:  MULLW  04
1526:  MOVF   FF3,W
1528:  CLRF   03
152A:  ADDLW  72
152C:  MOVWF  FE9
152E:  MOVLW  02
1530:  ADDWFC 03,W
1532:  MOVWF  FEA
1534:  MOVFF  FEF,00
1538:  MOVFF  FEC,01
153C:  MOVFF  FEC,02
1540:  MOVFF  FEC,03
1544:  MOVLB  3
1546:  MOVF   xDE,W
1548:  ADDWF  00,F
154A:  MOVF   xDF,W
154C:  ADDWFC 01,F
154E:  MOVF   xE0,W
1550:  ADDWFC 02,F
1552:  MOVF   xE1,W
1554:  ADDWFC 03,F
1556:  MOVF   00,W
1558:  MOVLB  2
155A:  ADDWF  xCE,F
155C:  MOVF   01,W
155E:  ADDWFC xCF,F
1560:  MOVF   02,W
1562:  ADDWFC xD0,F
1564:  MOVF   03,W
1566:  ADDWFC xD1,F
....................             atual_frequencia_y++; 
1568:  INCF   xD2,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
156A:  MOVF   xD2,W
156C:  MULLW  04
156E:  MOVF   FF3,W
1570:  CLRF   03
1572:  ADDLW  22
1574:  MOVWF  FE9
1576:  MOVLW  02
1578:  ADDWFC 03,W
157A:  MOVWF  FEA
157C:  MOVFF  FEF,00
1580:  MOVFF  FEC,01
1584:  MOVFF  FEC,02
1588:  MOVFF  FEC,03
158C:  MOVLW  FF
158E:  BSF    FD8.0
1590:  SUBFWB 00,W
1592:  MOVLB  3
1594:  MOVWF  xDE
1596:  MOVLW  FF
1598:  SUBFWB 01,W
159A:  MOVWF  xDF
159C:  MOVLW  00
159E:  SUBFWB 02,W
15A0:  MOVLW  00
15A2:  SUBFWB 03,W
15A4:  MOVFF  3DF,FCF
15A8:  MOVFF  3DE,FCE
....................         } else { 
15AC:  BRA    15F2
15AE:  MOVLB  2
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
15B0:  MOVF   xD2,W
15B2:  MULLW  04
15B4:  MOVF   FF3,W
15B6:  CLRF   03
15B8:  ADDLW  22
15BA:  MOVWF  FE9
15BC:  MOVLW  02
15BE:  ADDWFC 03,W
15C0:  MOVWF  FEA
15C2:  MOVFF  FEF,00
15C6:  MOVFF  FEC,01
15CA:  MOVFF  FEC,02
15CE:  MOVFF  FEC,03
15D2:  MOVLW  FF
15D4:  BSF    FD8.0
15D6:  SUBFWB 00,W
15D8:  MOVLB  3
15DA:  MOVWF  xDE
15DC:  MOVLW  FF
15DE:  SUBFWB 01,W
15E0:  MOVWF  xDF
15E2:  MOVLW  00
15E4:  SUBFWB 02,W
15E6:  MOVLW  00
15E8:  SUBFWB 03,W
15EA:  MOVFF  3DF,FCF
15EE:  MOVFF  3DE,FCE
....................         } 
....................     } else if (atual_frequencia_y == vel_y) { 
15F2:  BRA    1712
15F4:  MOVLB  2
15F6:  MOVF   xD3,W
15F8:  SUBWF  xD2,W
15FA:  BNZ   1642
....................         set_timer1(65535 - Ts_y[atual_frequencia_y]); 
15FC:  MOVF   xD2,W
15FE:  MULLW  04
1600:  MOVF   FF3,W
1602:  CLRF   03
1604:  ADDLW  22
1606:  MOVWF  FE9
1608:  MOVLW  02
160A:  ADDWFC 03,W
160C:  MOVWF  FEA
160E:  MOVFF  FEF,00
1612:  MOVFF  FEC,01
1616:  MOVFF  FEC,02
161A:  MOVFF  FEC,03
161E:  MOVLW  FF
1620:  BSF    FD8.0
1622:  SUBFWB 00,W
1624:  MOVLB  3
1626:  MOVWF  xDE
1628:  MOVLW  FF
162A:  SUBFWB 01,W
162C:  MOVWF  xDF
162E:  MOVLW  00
1630:  SUBFWB 02,W
1632:  MOVLW  00
1634:  SUBFWB 03,W
1636:  MOVFF  3DF,FCF
163A:  MOVFF  3DE,FCE
....................     } else { 
163E:  BRA    1712
1640:  MOVLB  2
....................         if (step_no_y == step_acumulado_y) { 
1642:  MOVF   xCE,W
1644:  SUBWF  xC6,W
1646:  BNZ   16D0
1648:  MOVF   xCF,W
164A:  SUBWF  xC7,W
164C:  BNZ   16D0
164E:  MOVF   xD0,F
1650:  BNZ   16D0
1652:  MOVF   xD1,F
1654:  BNZ   16D0
....................             atual_frequencia_y++; 
1656:  INCF   xD2,F
....................             step_acumulado_y += StepbyF_y[atual_frequencia_y]; 
1658:  MOVF   xD2,W
165A:  MULLW  04
165C:  MOVF   FF3,W
165E:  CLRF   03
1660:  ADDLW  72
1662:  MOVWF  FE9
1664:  MOVLW  02
1666:  ADDWFC 03,W
1668:  MOVWF  FEA
166A:  MOVFF  FEF,00
166E:  MOVFF  FEC,01
1672:  MOVFF  FEC,02
1676:  MOVFF  FEC,03
167A:  MOVF   00,W
167C:  ADDWF  xCE,F
167E:  MOVF   01,W
1680:  ADDWFC xCF,F
1682:  MOVF   02,W
1684:  ADDWFC xD0,F
1686:  MOVF   03,W
1688:  ADDWFC xD1,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
168A:  MOVF   xD2,W
168C:  MULLW  04
168E:  MOVF   FF3,W
1690:  CLRF   03
1692:  ADDLW  22
1694:  MOVWF  FE9
1696:  MOVLW  02
1698:  ADDWFC 03,W
169A:  MOVWF  FEA
169C:  MOVFF  FEF,00
16A0:  MOVFF  FEC,01
16A4:  MOVFF  FEC,02
16A8:  MOVFF  FEC,03
16AC:  MOVLW  FF
16AE:  BSF    FD8.0
16B0:  SUBFWB 00,W
16B2:  MOVLB  3
16B4:  MOVWF  xDE
16B6:  MOVLW  FF
16B8:  SUBFWB 01,W
16BA:  MOVWF  xDF
16BC:  MOVLW  00
16BE:  SUBFWB 02,W
16C0:  MOVLW  00
16C2:  SUBFWB 03,W
16C4:  MOVFF  3DF,FCF
16C8:  MOVFF  3DE,FCE
....................         } else { 
16CC:  BRA    1712
16CE:  MOVLB  2
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
16D0:  MOVF   xD2,W
16D2:  MULLW  04
16D4:  MOVF   FF3,W
16D6:  CLRF   03
16D8:  ADDLW  22
16DA:  MOVWF  FE9
16DC:  MOVLW  02
16DE:  ADDWFC 03,W
16E0:  MOVWF  FEA
16E2:  MOVFF  FEF,00
16E6:  MOVFF  FEC,01
16EA:  MOVFF  FEC,02
16EE:  MOVFF  FEC,03
16F2:  MOVLW  FF
16F4:  BSF    FD8.0
16F6:  SUBFWB 00,W
16F8:  MOVLB  3
16FA:  MOVWF  xDE
16FC:  MOVLW  FF
16FE:  SUBFWB 01,W
1700:  MOVWF  xDF
1702:  MOVLW  00
1704:  SUBFWB 02,W
1706:  MOVLW  00
1708:  SUBFWB 03,W
170A:  MOVFF  3DF,FCF
170E:  MOVFF  3DE,FCE
....................         } 
....................         break; 
....................     } 
1712:  MOVLB  0
1714:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_descida_y() { 
....................     if (atual_frequencia_y == 0) { 
1716:  MOVLB  2
1718:  MOVF   xD2,F
171A:  BNZ   1762
....................         set_timer1(65535 - Ts_y[atual_frequencia_y]); 
171C:  MOVF   xD2,W
171E:  MULLW  04
1720:  MOVF   FF3,W
1722:  CLRF   03
1724:  ADDLW  22
1726:  MOVWF  FE9
1728:  MOVLW  02
172A:  ADDWFC 03,W
172C:  MOVWF  FEA
172E:  MOVFF  FEF,00
1732:  MOVFF  FEC,01
1736:  MOVFF  FEC,02
173A:  MOVFF  FEC,03
173E:  MOVLW  FF
1740:  BSF    FD8.0
1742:  SUBFWB 00,W
1744:  MOVLB  3
1746:  MOVWF  xDE
1748:  MOVLW  FF
174A:  SUBFWB 01,W
174C:  MOVWF  xDF
174E:  MOVLW  00
1750:  SUBFWB 02,W
1752:  MOVLW  00
1754:  SUBFWB 03,W
1756:  MOVFF  3DF,FCF
175A:  MOVFF  3DE,FCE
....................     }  
175E:  BRA    199A
1760:  MOVLB  2
....................     else if (atual_frequencia_y == vel_y) { 
1762:  MOVF   xD3,W
1764:  SUBWF  xD2,W
1766:  BTFSS  FD8.2
1768:  BRA    18CA
....................         if (step_no_y == (step_down_y + StepbyF_y[atual_frequencia_y])) { 
176A:  MOVF   xD2,W
176C:  MULLW  04
176E:  MOVF   FF3,W
1770:  CLRF   03
1772:  ADDLW  72
1774:  MOVWF  FE9
1776:  MOVLW  02
1778:  ADDWFC 03,W
177A:  MOVWF  FEA
177C:  MOVFF  FEF,00
1780:  MOVFF  FEC,01
1784:  MOVFF  FEC,02
1788:  MOVFF  FEC,03
178C:  MOVF   xC8,W
178E:  ADDWF  00,F
1790:  MOVF   xC9,W
1792:  ADDWFC 01,F
1794:  MOVLW  00
1796:  ADDWFC 02,F
1798:  ADDWFC 03,F
179A:  MOVF   00,W
179C:  SUBWF  xC6,W
179E:  BNZ   1884
17A0:  MOVF   01,W
17A2:  SUBWF  xC7,W
17A4:  BNZ   1884
17A6:  MOVF   02,F
17A8:  BNZ   1884
17AA:  MOVF   03,F
17AC:  BNZ   1884
....................             step_acumulado_y = step_down_y + StepbyF_y[atual_frequencia_y] + StepbyF_y[atual_frequencia_y - 1]; 
17AE:  MOVF   xD2,W
17B0:  MULLW  04
17B2:  MOVF   FF3,W
17B4:  CLRF   03
17B6:  ADDLW  72
17B8:  MOVWF  FE9
17BA:  MOVLW  02
17BC:  ADDWFC 03,W
17BE:  MOVWF  FEA
17C0:  MOVFF  FEF,00
17C4:  MOVFF  FEC,01
17C8:  MOVFF  FEC,02
17CC:  MOVFF  FEC,03
17D0:  MOVF   00,W
17D2:  ADDWF  xC8,W
17D4:  MOVLB  3
17D6:  MOVWF  xDE
17D8:  MOVF   01,W
17DA:  MOVLB  2
17DC:  ADDWFC xC9,W
17DE:  MOVLB  3
17E0:  MOVWF  xDF
17E2:  MOVLW  00
17E4:  ADDWFC 02,W
17E6:  MOVWF  xE0
17E8:  MOVLW  00
17EA:  ADDWFC 03,W
17EC:  MOVWF  xE1
17EE:  MOVLW  01
17F0:  MOVLB  2
17F2:  SUBWF  xD2,W
17F4:  MULLW  04
17F6:  MOVF   FF3,W
17F8:  CLRF   03
17FA:  ADDLW  72
17FC:  MOVWF  FE9
17FE:  MOVLW  02
1800:  ADDWFC 03,W
1802:  MOVWF  FEA
1804:  MOVFF  FEF,00
1808:  MOVFF  FEC,01
180C:  MOVFF  FEC,02
1810:  MOVFF  FEC,03
1814:  MOVF   00,W
1816:  MOVLB  3
1818:  ADDWF  xDE,W
181A:  MOVLB  2
181C:  MOVWF  xCE
181E:  MOVF   01,W
1820:  MOVLB  3
1822:  ADDWFC xDF,W
1824:  MOVLB  2
1826:  MOVWF  xCF
1828:  MOVF   02,W
182A:  MOVLB  3
182C:  ADDWFC xE0,W
182E:  MOVLB  2
1830:  MOVWF  xD0
1832:  MOVF   03,W
1834:  MOVLB  3
1836:  ADDWFC xE1,W
1838:  MOVLB  2
183A:  MOVWF  xD1
....................             atual_frequencia_y--; 
183C:  DECF   xD2,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
183E:  MOVF   xD2,W
1840:  MULLW  04
1842:  MOVF   FF3,W
1844:  CLRF   03
1846:  ADDLW  22
1848:  MOVWF  FE9
184A:  MOVLW  02
184C:  ADDWFC 03,W
184E:  MOVWF  FEA
1850:  MOVFF  FEF,00
1854:  MOVFF  FEC,01
1858:  MOVFF  FEC,02
185C:  MOVFF  FEC,03
1860:  MOVLW  FF
1862:  BSF    FD8.0
1864:  SUBFWB 00,W
1866:  MOVLB  3
1868:  MOVWF  xDE
186A:  MOVLW  FF
186C:  SUBFWB 01,W
186E:  MOVWF  xDF
1870:  MOVLW  00
1872:  SUBFWB 02,W
1874:  MOVLW  00
1876:  SUBFWB 03,W
1878:  MOVFF  3DF,FCF
187C:  MOVFF  3DE,FCE
....................         } else { 
1880:  BRA    18C6
1882:  MOVLB  2
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
1884:  MOVF   xD2,W
1886:  MULLW  04
1888:  MOVF   FF3,W
188A:  CLRF   03
188C:  ADDLW  22
188E:  MOVWF  FE9
1890:  MOVLW  02
1892:  ADDWFC 03,W
1894:  MOVWF  FEA
1896:  MOVFF  FEF,00
189A:  MOVFF  FEC,01
189E:  MOVFF  FEC,02
18A2:  MOVFF  FEC,03
18A6:  MOVLW  FF
18A8:  BSF    FD8.0
18AA:  SUBFWB 00,W
18AC:  MOVLB  3
18AE:  MOVWF  xDE
18B0:  MOVLW  FF
18B2:  SUBFWB 01,W
18B4:  MOVWF  xDF
18B6:  MOVLW  00
18B8:  SUBFWB 02,W
18BA:  MOVLW  00
18BC:  SUBFWB 03,W
18BE:  MOVFF  3DF,FCF
18C2:  MOVFF  3DE,FCE
....................         } 
....................     } else { 
18C6:  BRA    199A
18C8:  MOVLB  2
....................         if (step_no_y == step_acumulado_y) { 
18CA:  MOVF   xCE,W
18CC:  SUBWF  xC6,W
18CE:  BNZ   1958
18D0:  MOVF   xCF,W
18D2:  SUBWF  xC7,W
18D4:  BNZ   1958
18D6:  MOVF   xD0,F
18D8:  BNZ   1958
18DA:  MOVF   xD1,F
18DC:  BNZ   1958
....................             atual_frequencia_y--; 
18DE:  DECF   xD2,F
....................             step_acumulado_y += StepbyF_y[atual_frequencia_y]; 
18E0:  MOVF   xD2,W
18E2:  MULLW  04
18E4:  MOVF   FF3,W
18E6:  CLRF   03
18E8:  ADDLW  72
18EA:  MOVWF  FE9
18EC:  MOVLW  02
18EE:  ADDWFC 03,W
18F0:  MOVWF  FEA
18F2:  MOVFF  FEF,00
18F6:  MOVFF  FEC,01
18FA:  MOVFF  FEC,02
18FE:  MOVFF  FEC,03
1902:  MOVF   00,W
1904:  ADDWF  xCE,F
1906:  MOVF   01,W
1908:  ADDWFC xCF,F
190A:  MOVF   02,W
190C:  ADDWFC xD0,F
190E:  MOVF   03,W
1910:  ADDWFC xD1,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
1912:  MOVF   xD2,W
1914:  MULLW  04
1916:  MOVF   FF3,W
1918:  CLRF   03
191A:  ADDLW  22
191C:  MOVWF  FE9
191E:  MOVLW  02
1920:  ADDWFC 03,W
1922:  MOVWF  FEA
1924:  MOVFF  FEF,00
1928:  MOVFF  FEC,01
192C:  MOVFF  FEC,02
1930:  MOVFF  FEC,03
1934:  MOVLW  FF
1936:  BSF    FD8.0
1938:  SUBFWB 00,W
193A:  MOVLB  3
193C:  MOVWF  xDE
193E:  MOVLW  FF
1940:  SUBFWB 01,W
1942:  MOVWF  xDF
1944:  MOVLW  00
1946:  SUBFWB 02,W
1948:  MOVLW  00
194A:  SUBFWB 03,W
194C:  MOVFF  3DF,FCF
1950:  MOVFF  3DE,FCE
....................         } else { 
1954:  BRA    199A
1956:  MOVLB  2
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
1958:  MOVF   xD2,W
195A:  MULLW  04
195C:  MOVF   FF3,W
195E:  CLRF   03
1960:  ADDLW  22
1962:  MOVWF  FE9
1964:  MOVLW  02
1966:  ADDWFC 03,W
1968:  MOVWF  FEA
196A:  MOVFF  FEF,00
196E:  MOVFF  FEC,01
1972:  MOVFF  FEC,02
1976:  MOVFF  FEC,03
197A:  MOVLW  FF
197C:  BSF    FD8.0
197E:  SUBFWB 00,W
1980:  MOVLB  3
1982:  MOVWF  xDE
1984:  MOVLW  FF
1986:  SUBFWB 01,W
1988:  MOVWF  xDF
198A:  MOVLW  00
198C:  SUBFWB 02,W
198E:  MOVLW  00
1990:  SUBFWB 03,W
1992:  MOVFF  3DF,FCF
1996:  MOVFF  3DE,FCE
....................         } 
....................     } 
199A:  MOVLB  0
199C:  GOTO   19F8 (RETURN)
.................... } 
....................  
.................... void movimenta_eixo_y() { 
....................      
....................     switch (ramp_sts_y) { 
19A0:  MOVLB  2
19A2:  MOVF   xC5,W
19A4:  XORLW  01
19A6:  MOVLB  0
19A8:  BZ    19B4
19AA:  XORLW  02
19AC:  BZ    19F6
19AE:  XORLW  01
19B0:  BZ    1A16
19B2:  BRA    1A38
....................  
....................         case ramp_up: // accel 
....................             output_toggle(step_y); 
19B4:  BCF    F94.2
19B6:  BTG    F8B.2
....................             rest_y = ~rest_y; 
19B8:  MOVLB  1
19BA:  BTG    x1A.6
....................             proximo_valor_subida_y(); 
19BC:  MOVLB  0
19BE:  RCALL  14C0
....................             if (step_no_y == midpt_y) { // midpoint: decel 
19C0:  MOVLB  2
19C2:  MOVF   xCC,W
19C4:  SUBWF  xC6,W
19C6:  BNZ   19F4
19C8:  MOVF   xCD,W
19CA:  SUBWF  xC7,W
19CC:  BNZ   19F4
....................                 if (move_y > 2 * total_acc_step_y) 
19CE:  BCF    FD8.0
19D0:  RLCF   xC2,W
19D2:  MOVWF  02
19D4:  RLCF   xC3,W
19D6:  MOVWF  03
19D8:  MOVFF  02,01
19DC:  MOVF   03,W
19DE:  SUBWF  xCB,W
19E0:  BNC   19F0
19E2:  BNZ   19EA
19E4:  MOVF   xCA,W
19E6:  SUBWF  01,W
19E8:  BC    19F0
....................                     ramp_sts_y = ramp_max; 
19EA:  MOVLW  02
19EC:  MOVWF  xC5
19EE:  BRA    19F4
....................                 else 
....................                     ramp_sts_y = ramp_down; 
19F0:  MOVLW  03
19F2:  MOVWF  xC5
....................             } 
....................             break; 
19F4:  BRA    1A46
....................  
....................         case ramp_down: // decel 
....................             proximo_valor_descida_y(); 
19F6:  BRA    1716
....................             if (step_no_y == move_y) 
19F8:  MOVLB  2
19FA:  MOVF   xCA,W
19FC:  SUBWF  xC6,W
19FE:  BNZ   1A0A
1A00:  MOVF   xCB,W
1A02:  SUBWF  xC7,W
1A04:  BNZ   1A0A
....................                 ramp_sts_y = ramp_last; 
1A06:  MOVLW  04
1A08:  MOVWF  xC5
....................             output_toggle(step_y); 
1A0A:  BCF    F94.2
1A0C:  BTG    F8B.2
....................             rest_y = ~rest_y; 
1A0E:  MOVLB  1
1A10:  BTG    x1A.6
....................             break; 
1A12:  MOVLB  2
1A14:  BRA    1A46
....................  
....................         case ramp_max: // constant speed 
....................             proximo_valor_subida_y(); 
1A16:  RCALL  14C0
....................             if (step_no_y == step_down_y) // start decel 
1A18:  MOVLB  2
1A1A:  MOVF   xC8,W
1A1C:  SUBWF  xC6,W
1A1E:  BNZ   1A2A
1A20:  MOVF   xC9,W
1A22:  SUBWF  xC7,W
1A24:  BNZ   1A2A
....................                 ramp_sts_y = ramp_down; 
1A26:  MOVLW  03
1A28:  MOVWF  xC5
....................             output_toggle(step_y); 
1A2A:  BCF    F94.2
1A2C:  BTG    F8B.2
....................             rest_y = ~rest_y; 
1A2E:  MOVLB  1
1A30:  BTG    x1A.6
....................             break; 
1A32:  MOVLB  2
1A34:  BRA    1A46
1A36:  MOVLB  0
....................  
....................         default: // last step: cleanup 
....................             ramp_sts_y = ramp_idle; 
1A38:  MOVLB  2
1A3A:  CLRF   xC5
....................             stop_yf = FALSE; 
1A3C:  MOVLB  1
1A3E:  BCF    x1A.7
....................             disable_interrupts(INT_TIMER1); 
1A40:  BCF    F9D.0
....................             run_flg_y = FALSE; // move_y complete 
1A42:  BCF    x1A.5
....................             break; 
1A44:  MOVLB  2
....................     } // switch (ramp_sts_y) 
....................     if (ramp_sts_y != ramp_idle) { 
1A46:  MOVF   xC5,F
1A48:  BZ    1A74
....................         if (rest_y) { 
1A4A:  MOVLB  1
1A4C:  BTFSS  x1A.6
1A4E:  BRA    1A76
....................             motor_pos_y += pos_inc_y; 
1A50:  CLRF   03
1A52:  MOVLB  2
1A54:  MOVF   xC4,W
1A56:  BTFSC  FE8.7
1A58:  DECF   03,F
1A5A:  MOVLB  1
1A5C:  ADDWF  x14,W
1A5E:  MOVWF  01
1A60:  MOVF   x15,W
1A62:  ADDWFC 03,F
1A64:  MOVFF  01,114
1A68:  MOVFF  03,115
....................             ++step_no_y; 
1A6C:  MOVLB  2
1A6E:  INCF   xC6,F
1A70:  BTFSC  FD8.2
1A72:  INCF   xC7,F
1A74:  MOVLB  1
....................         } 
....................     } 
1A76:  MOVLB  0
1A78:  GOTO   1A7E (RETURN)
.................... } 
....................  
.................... void umpasso_y(int16 descanco, short dir) { 
....................     output_low(enable_y); 
....................     if (dir) { 
....................         output_high(dir_y); 
....................         motor_pos_y--; 
....................     } else { 
....................         output_low(dir_y); 
....................         motor_pos_y++; 
....................     } 
....................     output_high(step_y); 
....................     delay_us(descanco); 
....................     output_low(step_y); 
....................     delay_us(descanco); 
....................     //output_high(enable_y); 
.................... } 
....................  
.................... void zerar_y() { 
....................     while(le_Input(i_limite_y)==1){ 
....................         umpasso_y(600, FALSE); 
....................         delay_us(200); 
....................     } 
....................     while (le_Input(i_limite_y)==0){ 
....................         umpasso_y(900,TRUE); 
....................         delay_us(200); 
....................     } 
....................     while(le_Input(i_limite_y)==1){ 
....................         umpasso_y(1000, FALSE); 
....................         delay_us(200); 
....................     } 
....................     motor_pos_y = 0; 
....................     output_high(enable_y); 
.................... } 
.................... void medir_y(){ 
....................     while (le_Input(s_limite_y)==0){ 
....................         umpasso_y(900,FALSE); 
....................         delay_us(200); 
....................     } 
....................     while (le_Input(s_limite_y)==1){ 
....................         umpasso_y(900,TRUE); 
....................         delay_us(200); 
....................     } 
....................     max_posicao_y = motor_pos_y; 
....................     output_high(enable_y); 
.................... } 
.................... // </editor-fold> 
....................  
.................... #include "Axis_z.c" 
.................... // <editor-fold defaultstate="collapsed" desc="Valores que devem ser inseridos"> 
.................... float stepbyrev_z = 200; 
.................... float driver_u_step_z = 1; // caso o driver esteja em 400 
.................... float Leadscrew_z = 9; //redutor de voltas do motor 
.................... float Leadscrew_Pich_z = 150; //esse valor deve ser em mm/revoluo 
.................... float Vmax_z = 40; //esse valor deve ser em mm por segundo 
.................... float Amax_z = 200; //esse valor deve ser em mm por segundo 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Valores calculo rampa"> 
.................... float MMbyStep_z = 0; 
.................... int8 StepinAcc_z = 20; 
.................... float Fmax_z = 0; 
.................... int32 Ts_z[20]; 
.................... int32 StepbyF_z[20]; 
.................... int16 total_acc_step_z = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Flags e Controles de Movimento"> 
.................... signed int8 pos_inc_z = 0; 
.................... int8 ramp_sts_z = ramp_idle; 
.................... short run_flg_z = FALSE; 
.................... short rest_z = false; 
.................... int16 step_no_z = 0; 
.................... int16 step_down_z = 0; 
.................... int16 move_z = 0; 
.................... int16 midpt_z = 0; 
.................... int32 step_acumulado_z = 0; 
.................... int atual_frequencia_z = 0; 
.................... int vel_z = 19; 
.................... int16 max_posicao_z = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Pinos Motor"> 
.................... #DEFINE     i_limite_z            13 
.................... #DEFINE     s_limite_z            14 
....................  
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Inicializa Motor"> 
.................... void init_axis_z() { 
....................     set_tris_a(0x00); 
*
35DE:  MOVLW  00
35E0:  MOVWF  F92
....................     output_high(step_z); 
35E2:  BCF    F92.5
35E4:  BSF    F89.5
....................     output_high(enable_z); 
35E6:  BCF    F92.3
35E8:  BSF    F89.3
....................     output_high(dir_z); 
35EA:  BCF    F92.4
35EC:  BSF    F89.4
....................  
....................     MMbyStep_z = Leadscrew_Pich_z / (stepbyrev_z * driver_u_step_z * Leadscrew_z); 
35EE:  MOVFF  2D9,3CB
35F2:  MOVFF  2D8,3CA
35F6:  MOVFF  2D7,3C9
35FA:  MOVFF  2D6,3C8
35FE:  MOVFF  2DD,3CF
3602:  MOVFF  2DC,3CE
3606:  MOVFF  2DB,3CD
360A:  MOVFF  2DA,3CC
360E:  CALL   2628
3612:  MOVFF  03,3BD
3616:  MOVFF  02,3BC
361A:  MOVFF  01,3BB
361E:  MOVFF  00,3BA
3622:  MOVFF  03,3CB
3626:  MOVFF  02,3CA
362A:  MOVFF  01,3C9
362E:  MOVFF  00,3C8
3632:  MOVFF  2E1,3CF
3636:  MOVFF  2E0,3CE
363A:  MOVFF  2DF,3CD
363E:  MOVFF  2DE,3CC
3642:  CALL   2628
3646:  MOVFF  2E5,3D1
364A:  MOVFF  2E4,3D0
364E:  MOVFF  2E3,3CF
3652:  MOVFF  2E2,3CE
3656:  MOVFF  03,3D5
365A:  MOVFF  02,3D4
365E:  MOVFF  01,3D3
3662:  MOVFF  00,3D2
3666:  CALL   271E
366A:  MOVFF  03,2F1
366E:  MOVFF  02,2F0
3672:  MOVFF  01,2EF
3676:  MOVFF  00,2EE
....................     Fmax_z = Vmax_z / MMbyStep_z; //Valor de ferequencia adiquirido em hz 
367A:  MOVFF  2E9,3D1
367E:  MOVFF  2E8,3D0
3682:  MOVFF  2E7,3CF
3686:  MOVFF  2E6,3CE
368A:  MOVFF  2F1,3D5
368E:  MOVFF  2F0,3D4
3692:  MOVFF  2EF,3D3
3696:  MOVFF  2EE,3D2
369A:  CALL   271E
369E:  MOVFF  03,2F6
36A2:  MOVFF  02,2F5
36A6:  MOVFF  01,2F4
36AA:  MOVFF  00,2F3
....................  
....................     float den = Amax_z*StepinAcc_z; 
....................     float num = Vmax_z * 1000000; 
....................     float TbyF = num / den; //tempo em us 
....................  
....................     int i = 0; 
36AE:  MOVLB  3
36B0:  CLRF   xC9
36B2:  MOVFF  2F2,3C8
36B6:  MOVLB  0
36B8:  CALL   287C
36BC:  MOVFF  2ED,3CB
36C0:  MOVFF  2EC,3CA
36C4:  MOVFF  2EB,3C9
36C8:  MOVFF  2EA,3C8
36CC:  MOVFF  03,3CF
36D0:  MOVFF  02,3CE
36D4:  MOVFF  01,3CD
36D8:  MOVFF  00,3CC
36DC:  CALL   2628
36E0:  MOVFF  03,3B0
36E4:  MOVFF  02,3AF
36E8:  MOVFF  01,3AE
36EC:  MOVFF  00,3AD
36F0:  MOVFF  2E9,3CB
36F4:  MOVFF  2E8,3CA
36F8:  MOVFF  2E7,3C9
36FC:  MOVFF  2E6,3C8
3700:  MOVLB  3
3702:  CLRF   xCF
3704:  MOVLW  24
3706:  MOVWF  xCE
3708:  MOVLW  74
370A:  MOVWF  xCD
370C:  MOVLW  92
370E:  MOVWF  xCC
3710:  MOVLB  0
3712:  CALL   2628
3716:  MOVFF  03,3B4
371A:  MOVFF  02,3B3
371E:  MOVFF  01,3B2
3722:  MOVFF  00,3B1
3726:  MOVFF  3B4,3D1
372A:  MOVFF  3B3,3D0
372E:  MOVFF  3B2,3CF
3732:  MOVFF  3B1,3CE
3736:  MOVFF  3B0,3D5
373A:  MOVFF  3AF,3D4
373E:  MOVFF  3AE,3D3
3742:  MOVFF  3AD,3D2
3746:  CALL   271E
374A:  MOVFF  03,3B8
374E:  MOVFF  02,3B7
3752:  MOVFF  01,3B6
3756:  MOVFF  00,3B5
375A:  MOVLB  3
375C:  CLRF   xB9
....................     for (i = 1; i <= StepinAcc_z; i++) { 
375E:  MOVLW  01
3760:  MOVWF  xB9
3762:  MOVF   xB9,W
3764:  MOVLB  2
3766:  SUBWF  xF2,W
3768:  BTFSS  FD8.0
376A:  BRA    3A14
....................         Ts_z[i - 1] = (1000000 * StepinAcc_z) / (i * Fmax_z); 
376C:  MOVLW  01
376E:  MOVLB  3
3770:  SUBWF  xB9,W
3772:  MULLW  04
3774:  MOVF   FF3,W
3776:  CLRF   03
3778:  ADDLW  F7
377A:  MOVWF  FE9
377C:  MOVLW  02
377E:  ADDWFC 03,W
3780:  MOVWF  FEA
3782:  MOVFF  FEA,3BD
3786:  MOVFF  FE9,3BC
378A:  CLRF   xC1
378C:  MOVLW  0F
378E:  MOVWF  xC0
3790:  MOVLW  42
3792:  MOVWF  xBF
3794:  MOVLW  40
3796:  MOVWF  xBE
3798:  CLRF   xC5
379A:  CLRF   xC4
379C:  CLRF   xC3
379E:  MOVFF  2F2,3C2
37A2:  MOVLB  0
37A4:  CALL   2B2A
37A8:  MOVFF  3BD,FEA
37AC:  MOVFF  3BC,FE9
37B0:  MOVFF  03,3C1
37B4:  MOVFF  02,3C0
37B8:  MOVFF  01,3BF
37BC:  MOVFF  00,3BE
37C0:  MOVLB  3
37C2:  CLRF   xC9
37C4:  MOVFF  3B9,3C8
37C8:  MOVLB  0
37CA:  CALL   287C
37CE:  MOVFF  03,3CB
37D2:  MOVFF  02,3CA
37D6:  MOVFF  01,3C9
37DA:  MOVFF  00,3C8
37DE:  MOVFF  2F6,3CF
37E2:  MOVFF  2F5,3CE
37E6:  MOVFF  2F4,3CD
37EA:  MOVFF  2F3,3CC
37EE:  CALL   2628
37F2:  MOVFF  03,3C5
37F6:  MOVFF  02,3C4
37FA:  MOVFF  01,3C3
37FE:  MOVFF  00,3C2
3802:  MOVFF  3C1,3D1
3806:  MOVFF  3C0,3D0
380A:  MOVFF  3BF,3CF
380E:  MOVFF  3BE,3CE
3812:  CALL   2B86
3816:  MOVFF  03,3D1
381A:  MOVFF  02,3D0
381E:  MOVFF  01,3CF
3822:  MOVFF  00,3CE
3826:  MOVFF  3C5,3D5
382A:  MOVFF  3C4,3D4
382E:  MOVFF  3C3,3D3
3832:  MOVFF  3C2,3D2
3836:  CALL   271E
383A:  MOVFF  03,3D1
383E:  MOVFF  02,3D0
3842:  MOVFF  01,3CF
3846:  MOVFF  00,3CE
384A:  CALL   2BBE
384E:  MOVFF  00,FEF
3852:  MOVFF  01,FEC
3856:  MOVFF  02,FEC
385A:  MOVFF  03,FEC
....................         StepbyF_z[i - 1] = 2 * TbyF / Ts_z[i - 1]; 
385E:  MOVLW  01
3860:  MOVLB  3
3862:  SUBWF  xB9,W
3864:  MULLW  04
3866:  MOVF   FF3,W
3868:  CLRF   03
386A:  ADDLW  47
386C:  MOVWF  01
386E:  MOVLW  03
3870:  ADDWFC 03,F
3872:  MOVFF  01,3BA
3876:  MOVFF  03,3BB
387A:  CLRF   xCB
387C:  CLRF   xCA
387E:  CLRF   xC9
3880:  MOVLW  80
3882:  MOVWF  xC8
3884:  MOVFF  3B8,3CF
3888:  MOVFF  3B7,3CE
388C:  MOVFF  3B6,3CD
3890:  MOVFF  3B5,3CC
3894:  MOVLB  0
3896:  CALL   2628
389A:  MOVFF  03,3BF
389E:  MOVFF  02,3BE
38A2:  MOVFF  01,3BD
38A6:  MOVFF  00,3BC
38AA:  MOVLW  01
38AC:  MOVLB  3
38AE:  SUBWF  xB9,W
38B0:  MULLW  04
38B2:  MOVF   FF3,W
38B4:  CLRF   03
38B6:  ADDLW  F7
38B8:  MOVWF  FE9
38BA:  MOVLW  02
38BC:  ADDWFC 03,W
38BE:  MOVWF  FEA
38C0:  MOVFF  FEF,00
38C4:  MOVFF  FEC,01
38C8:  MOVFF  FEC,02
38CC:  MOVFF  FEC,03
38D0:  MOVFF  03,3D1
38D4:  MOVFF  02,3D0
38D8:  MOVFF  01,3CF
38DC:  MOVFF  00,3CE
38E0:  MOVLB  0
38E2:  CALL   2B86
38E6:  MOVFF  3BF,3D1
38EA:  MOVFF  3BE,3D0
38EE:  MOVFF  3BD,3CF
38F2:  MOVFF  3BC,3CE
38F6:  MOVFF  03,3D5
38FA:  MOVFF  02,3D4
38FE:  MOVFF  01,3D3
3902:  MOVFF  00,3D2
3906:  CALL   271E
390A:  MOVFF  03,3D1
390E:  MOVFF  02,3D0
3912:  MOVFF  01,3CF
3916:  MOVFF  00,3CE
391A:  CALL   2BBE
391E:  MOVFF  3BB,FEA
3922:  MOVFF  3BA,FE9
3926:  MOVFF  00,FEF
392A:  MOVFF  01,FEC
392E:  MOVFF  02,FEC
3932:  MOVFF  03,FEC
....................         total_acc_step_z += StepbyF_z[i - 1]; 
3936:  MOVLW  01
3938:  MOVLB  3
393A:  SUBWF  xB9,W
393C:  MULLW  04
393E:  MOVF   FF3,W
3940:  CLRF   03
3942:  ADDLW  47
3944:  MOVWF  FE9
3946:  MOVLW  03
3948:  ADDWFC 03,W
394A:  MOVWF  FEA
394C:  MOVFF  FEF,00
3950:  MOVFF  FEC,01
3954:  MOVFF  FEC,02
3958:  MOVFF  FEC,03
395C:  MOVF   00,W
395E:  ADDWF  x97,F
3960:  MOVF   01,W
3962:  ADDWFC x98,F
....................         Ts_z[i - 1] = Ts_z[i - 1] / (8 * 0.2 * 2); //Tempo/(prescale*ciclodemaquina*metadedociclo) 
3964:  MOVLW  01
3966:  SUBWF  xB9,W
3968:  MULLW  04
396A:  MOVF   FF3,W
396C:  CLRF   03
396E:  ADDLW  F7
3970:  MOVWF  01
3972:  MOVLW  02
3974:  ADDWFC 03,F
3976:  MOVFF  01,3BA
397A:  MOVFF  03,3BB
397E:  MOVLW  01
3980:  SUBWF  xB9,W
3982:  MULLW  04
3984:  MOVF   FF3,W
3986:  CLRF   03
3988:  ADDLW  F7
398A:  MOVWF  FE9
398C:  MOVLW  02
398E:  ADDWFC 03,W
3990:  MOVWF  FEA
3992:  MOVFF  FEF,3BC
3996:  MOVFF  FEC,3BD
399A:  MOVFF  FEC,3BE
399E:  MOVFF  FEC,3BF
39A2:  MOVFF  3BF,3D1
39A6:  MOVFF  3BE,3D0
39AA:  MOVFF  3BD,3CF
39AE:  MOVFF  3BC,3CE
39B2:  MOVLB  0
39B4:  CALL   2B86
39B8:  MOVFF  03,3D1
39BC:  MOVFF  02,3D0
39C0:  MOVFF  01,3CF
39C4:  MOVFF  00,3CE
39C8:  MOVLW  CD
39CA:  MOVLB  3
39CC:  MOVWF  xD5
39CE:  MOVLW  CC
39D0:  MOVWF  xD4
39D2:  MOVLW  4C
39D4:  MOVWF  xD3
39D6:  MOVLW  80
39D8:  MOVWF  xD2
39DA:  MOVLB  0
39DC:  CALL   271E
39E0:  MOVFF  03,3D1
39E4:  MOVFF  02,3D0
39E8:  MOVFF  01,3CF
39EC:  MOVFF  00,3CE
39F0:  CALL   2BBE
39F4:  MOVFF  3BB,FEA
39F8:  MOVFF  3BA,FE9
39FC:  MOVFF  00,FEF
3A00:  MOVFF  01,FEC
3A04:  MOVFF  02,FEC
3A08:  MOVFF  03,FEC
3A0C:  MOVLB  3
3A0E:  INCF   xB9,F
3A10:  BRA    3762
3A12:  MOVLB  2
....................     } 
3A14:  MOVLB  0
3A16:  GOTO   A8F4 (RETURN)
.................... } 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Movimento Motor"> 
.................... void motor_stop_z() { 
....................     step_no_z = step_down_z; 
....................     ramp_sts_z = ramp_down; 
.................... } 
....................  
.................... void motor_disable_z() { 
....................     output_high(enable_z); 
....................     disable_interrupts(INT_TIMER3); 
.................... } 
....................  
.................... void motor_run_z(int32 pos_new, int velocidade) { // set up to drive motor to pos_new (absolute step#) 
....................     vel_z = velocidade; 
*
5638:  MOVFF  3B8,3A9
....................     total_acc_step_z = 0; 
563C:  MOVLB  3
563E:  CLRF   x98
5640:  CLRF   x97
....................  
....................     if (pos_new < motor_pos_z) // get dir_yection & #steps 
5642:  MOVF   xB7,F
5644:  BNZ   5682
5646:  MOVF   xB6,F
5648:  BNZ   5682
564A:  MOVF   xB5,W
564C:  MOVLB  1
564E:  SUBWF  x19,W
5650:  BTFSC  FD8.0
5652:  BRA    5658
5654:  MOVLB  3
5656:  BRA    5682
5658:  BNZ   5664
565A:  MOVF   x18,W
565C:  MOVLB  3
565E:  SUBWF  xB4,W
5660:  BC    5682
5662:  MOVLB  1
....................     { 
....................         output_high(dir_z); 
5664:  BCF    F92.4
5666:  BSF    F89.4
....................         move_z = motor_pos_z - pos_new; 
5668:  MOVLB  3
566A:  MOVF   xB4,W
566C:  MOVLB  1
566E:  SUBWF  x18,W
5670:  MOVLB  3
5672:  MOVWF  xA0
5674:  MOVF   xB5,W
5676:  MOVLB  1
5678:  SUBWFB x19,W
567A:  MOVLB  3
567C:  MOVWF  xA1
....................         pos_inc_z = -1; 
567E:  SETF   x99
....................     } else if (pos_new != motor_pos_z) { 
5680:  BRA    56BE
5682:  MOVLB  1
5684:  MOVF   x18,W
5686:  MOVLB  3
5688:  SUBWF  xB4,W
568A:  BNZ   569E
568C:  MOVLB  1
568E:  MOVF   x19,W
5690:  MOVLB  3
5692:  SUBWF  xB5,W
5694:  BNZ   569E
5696:  MOVF   xB6,F
5698:  BNZ   569E
569A:  MOVF   xB7,F
569C:  BZ    56BC
....................         output_low(dir_z); 
569E:  BCF    F92.4
56A0:  BCF    F89.4
....................         move_z = pos_new - motor_pos_z; 
56A2:  MOVLB  1
56A4:  MOVF   x18,W
56A6:  MOVLB  3
56A8:  SUBWF  xB4,W
56AA:  MOVWF  xA0
56AC:  MOVLB  1
56AE:  MOVF   x19,W
56B0:  MOVLB  3
56B2:  SUBWFB xB5,W
56B4:  MOVWF  xA1
....................         pos_inc_z = 1; 
56B6:  MOVLW  01
56B8:  MOVWF  x99
....................     } else return; 
56BA:  BRA    56BE
56BC:  BRA    578E
....................  
....................     for (int j = 0; j <= velocidade; j++) { 
56BE:  CLRF   xB9
56C0:  MOVF   xB9,W
56C2:  SUBWF  xB8,W
56C4:  BNC   56F4
....................         total_acc_step_z += StepbyF_z[j]; 
56C6:  MOVF   xB9,W
56C8:  MULLW  04
56CA:  MOVF   FF3,W
56CC:  CLRF   03
56CE:  ADDLW  47
56D0:  MOVWF  FE9
56D2:  MOVLW  03
56D4:  ADDWFC 03,W
56D6:  MOVWF  FEA
56D8:  MOVFF  FEF,00
56DC:  MOVFF  FEC,01
56E0:  MOVFF  FEC,02
56E4:  MOVFF  FEC,03
56E8:  MOVF   00,W
56EA:  ADDWF  x97,F
56EC:  MOVF   01,W
56EE:  ADDWFC x98,F
56F0:  INCF   xB9,F
56F2:  BRA    56C0
....................     } 
....................  
....................     if (move_z > 2 * total_acc_step_z) { 
56F4:  BCF    FD8.0
56F6:  RLCF   x97,W
56F8:  MOVWF  02
56FA:  RLCF   x98,W
56FC:  MOVWF  03
56FE:  MOVFF  02,01
5702:  MOVF   03,W
5704:  SUBWF  xA1,W
5706:  BNC   5726
5708:  BNZ   5710
570A:  MOVF   xA0,W
570C:  SUBWF  01,W
570E:  BC    5726
....................         midpt_z = total_acc_step_z; 
5710:  MOVFF  398,3A3
5714:  MOVFF  397,3A2
....................         step_down_z = move_z - total_acc_step_z; 
5718:  MOVF   x97,W
571A:  SUBWF  xA0,W
571C:  MOVWF  x9E
571E:  MOVF   x98,W
5720:  SUBWFB xA1,W
5722:  MOVWF  x9F
....................     } else { 
5724:  BRA    5744
....................         midpt_z = (move_z - 1) >> 1; 
5726:  MOVLW  01
5728:  SUBWF  xA0,W
572A:  MOVWF  xBA
572C:  MOVLW  00
572E:  SUBWFB xA1,W
5730:  MOVWF  xBB
5732:  BCF    FD8.0
5734:  RRCF   xBB,W
5736:  MOVWF  xA3
5738:  RRCF   xBA,W
573A:  MOVWF  xA2
....................         step_down_z = midpt_z; 
573C:  MOVFF  3A3,39F
5740:  MOVFF  3A2,39E
....................     } 
....................     step_no_z = 0; 
5744:  CLRF   x9D
5746:  CLRF   x9C
....................     step_acumulado_z = 0; 
5748:  CLRF   xA7
574A:  CLRF   xA6
574C:  CLRF   xA5
574E:  CLRF   xA4
....................     atual_frequencia_z = 0; 
5750:  CLRF   xA8
....................     ramp_sts_z = ramp_up; // start ramp state-machine 
5752:  MOVLW  01
5754:  MOVWF  x9A
....................     run_flg_z = TRUE; 
5756:  BSF    x9B.0
....................     output_low(enable_z); 
5758:  BCF    F92.3
575A:  BCF    F89.3
....................     setup_timer_3(T3_INTERNAL | T3_DIV_BY_8); 
575C:  MOVLW  B5
575E:  MOVWF  FB1
....................     set_timer3(65535 - Ts_z[0]); 
5760:  MOVLW  FF
5762:  BSF    FD8.0
5764:  MOVLB  2
5766:  SUBFWB xF7,W
5768:  MOVLB  3
576A:  MOVWF  xBA
576C:  MOVLW  FF
576E:  MOVLB  2
5770:  SUBFWB xF8,W
5772:  MOVLB  3
5774:  MOVWF  xBB
5776:  MOVLW  00
5778:  MOVLB  2
577A:  SUBFWB xF9,W
577C:  MOVLW  00
577E:  MOVLB  2
5780:  SUBFWB xFA,W
5782:  MOVLB  3
5784:  MOVFF  3BB,FB3
5788:  MOVFF  3BA,FB2
....................     enable_interrupts(INT_TIMER3); 
578C:  BSF    FA0.1
578E:  MOVLB  0
5790:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_subida_z() { 
....................     if (atual_frequencia_z == 0) { 
*
1A9A:  MOVLB  3
1A9C:  MOVF   xA8,F
1A9E:  BTFSS  FD8.2
1AA0:  BRA    1BC4
....................         if (step_no_z == StepbyF_z[atual_frequencia_z]) { 
1AA2:  MOVF   xA8,W
1AA4:  MULLW  04
1AA6:  MOVF   FF3,W
1AA8:  CLRF   03
1AAA:  ADDLW  47
1AAC:  MOVWF  FE9
1AAE:  MOVLW  03
1AB0:  ADDWFC 03,W
1AB2:  MOVWF  FEA
1AB4:  MOVFF  FEF,00
1AB8:  MOVFF  FEC,01
1ABC:  MOVFF  FEC,02
1AC0:  MOVFF  FEC,03
1AC4:  MOVF   00,W
1AC6:  SUBWF  x9C,W
1AC8:  BNZ   1B82
1ACA:  MOVF   01,W
1ACC:  SUBWF  x9D,W
1ACE:  BNZ   1B82
1AD0:  MOVF   02,F
1AD2:  BNZ   1B82
1AD4:  MOVF   03,F
1AD6:  BNZ   1B82
....................             step_acumulado_z += StepbyF_z[atual_frequencia_z] + StepbyF_z[atual_frequencia_z + 1]; 
1AD8:  MOVF   xA8,W
1ADA:  MULLW  04
1ADC:  MOVF   FF3,W
1ADE:  CLRF   03
1AE0:  ADDLW  47
1AE2:  MOVWF  FE9
1AE4:  MOVLW  03
1AE6:  ADDWFC 03,W
1AE8:  MOVWF  FEA
1AEA:  MOVFF  FEF,3DE
1AEE:  MOVFF  FEC,3DF
1AF2:  MOVFF  FEC,3E0
1AF6:  MOVFF  FEC,3E1
1AFA:  MOVLW  01
1AFC:  ADDWF  xA8,W
1AFE:  MULLW  04
1B00:  MOVF   FF3,W
1B02:  CLRF   03
1B04:  ADDLW  47
1B06:  MOVWF  FE9
1B08:  MOVLW  03
1B0A:  ADDWFC 03,W
1B0C:  MOVWF  FEA
1B0E:  MOVFF  FEF,00
1B12:  MOVFF  FEC,01
1B16:  MOVFF  FEC,02
1B1A:  MOVFF  FEC,03
1B1E:  MOVF   xDE,W
1B20:  ADDWF  00,F
1B22:  MOVF   xDF,W
1B24:  ADDWFC 01,F
1B26:  MOVF   xE0,W
1B28:  ADDWFC 02,F
1B2A:  MOVF   xE1,W
1B2C:  ADDWFC 03,F
1B2E:  MOVF   00,W
1B30:  ADDWF  xA4,F
1B32:  MOVF   01,W
1B34:  ADDWFC xA5,F
1B36:  MOVF   02,W
1B38:  ADDWFC xA6,F
1B3A:  MOVF   03,W
1B3C:  ADDWFC xA7,F
....................             atual_frequencia_z++; 
1B3E:  INCF   xA8,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
1B40:  MOVF   xA8,W
1B42:  MULLW  04
1B44:  MOVF   FF3,W
1B46:  CLRF   03
1B48:  ADDLW  F7
1B4A:  MOVWF  FE9
1B4C:  MOVLW  02
1B4E:  ADDWFC 03,W
1B50:  MOVWF  FEA
1B52:  MOVFF  FEF,00
1B56:  MOVFF  FEC,01
1B5A:  MOVFF  FEC,02
1B5E:  MOVFF  FEC,03
1B62:  MOVLW  FF
1B64:  BSF    FD8.0
1B66:  SUBFWB 00,W
1B68:  MOVWF  xDE
1B6A:  MOVLW  FF
1B6C:  SUBFWB 01,W
1B6E:  MOVWF  xDF
1B70:  MOVLW  00
1B72:  SUBFWB 02,W
1B74:  MOVLW  00
1B76:  SUBFWB 03,W
1B78:  MOVFF  3DF,FB3
1B7C:  MOVFF  3DE,FB2
....................         } else { 
1B80:  BRA    1BC2
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
1B82:  MOVF   xA8,W
1B84:  MULLW  04
1B86:  MOVF   FF3,W
1B88:  CLRF   03
1B8A:  ADDLW  F7
1B8C:  MOVWF  FE9
1B8E:  MOVLW  02
1B90:  ADDWFC 03,W
1B92:  MOVWF  FEA
1B94:  MOVFF  FEF,00
1B98:  MOVFF  FEC,01
1B9C:  MOVFF  FEC,02
1BA0:  MOVFF  FEC,03
1BA4:  MOVLW  FF
1BA6:  BSF    FD8.0
1BA8:  SUBFWB 00,W
1BAA:  MOVWF  xDE
1BAC:  MOVLW  FF
1BAE:  SUBFWB 01,W
1BB0:  MOVWF  xDF
1BB2:  MOVLW  00
1BB4:  SUBFWB 02,W
1BB6:  MOVLW  00
1BB8:  SUBFWB 03,W
1BBA:  MOVFF  3DF,FB3
1BBE:  MOVFF  3DE,FB2
....................         } 
....................     } else if (atual_frequencia_z == vel_z) { 
1BC2:  BRA    1CD6
1BC4:  MOVF   xA9,W
1BC6:  SUBWF  xA8,W
1BC8:  BNZ   1C0C
....................         set_timer3(65535 - Ts_z[atual_frequencia_z]); 
1BCA:  MOVF   xA8,W
1BCC:  MULLW  04
1BCE:  MOVF   FF3,W
1BD0:  CLRF   03
1BD2:  ADDLW  F7
1BD4:  MOVWF  FE9
1BD6:  MOVLW  02
1BD8:  ADDWFC 03,W
1BDA:  MOVWF  FEA
1BDC:  MOVFF  FEF,00
1BE0:  MOVFF  FEC,01
1BE4:  MOVFF  FEC,02
1BE8:  MOVFF  FEC,03
1BEC:  MOVLW  FF
1BEE:  BSF    FD8.0
1BF0:  SUBFWB 00,W
1BF2:  MOVWF  xDE
1BF4:  MOVLW  FF
1BF6:  SUBFWB 01,W
1BF8:  MOVWF  xDF
1BFA:  MOVLW  00
1BFC:  SUBFWB 02,W
1BFE:  MOVLW  00
1C00:  SUBFWB 03,W
1C02:  MOVFF  3DF,FB3
1C06:  MOVFF  3DE,FB2
....................     } else { 
1C0A:  BRA    1CD6
....................         if (step_no_z == step_acumulado_z) { 
1C0C:  MOVF   xA4,W
1C0E:  SUBWF  x9C,W
1C10:  BNZ   1C96
1C12:  MOVF   xA5,W
1C14:  SUBWF  x9D,W
1C16:  BNZ   1C96
1C18:  MOVF   xA6,F
1C1A:  BNZ   1C96
1C1C:  MOVF   xA7,F
1C1E:  BNZ   1C96
....................             atual_frequencia_z++; 
1C20:  INCF   xA8,F
....................             step_acumulado_z += StepbyF_z[atual_frequencia_z]; 
1C22:  MOVF   xA8,W
1C24:  MULLW  04
1C26:  MOVF   FF3,W
1C28:  CLRF   03
1C2A:  ADDLW  47
1C2C:  MOVWF  FE9
1C2E:  MOVLW  03
1C30:  ADDWFC 03,W
1C32:  MOVWF  FEA
1C34:  MOVFF  FEF,00
1C38:  MOVFF  FEC,01
1C3C:  MOVFF  FEC,02
1C40:  MOVFF  FEC,03
1C44:  MOVF   00,W
1C46:  ADDWF  xA4,F
1C48:  MOVF   01,W
1C4A:  ADDWFC xA5,F
1C4C:  MOVF   02,W
1C4E:  ADDWFC xA6,F
1C50:  MOVF   03,W
1C52:  ADDWFC xA7,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
1C54:  MOVF   xA8,W
1C56:  MULLW  04
1C58:  MOVF   FF3,W
1C5A:  CLRF   03
1C5C:  ADDLW  F7
1C5E:  MOVWF  FE9
1C60:  MOVLW  02
1C62:  ADDWFC 03,W
1C64:  MOVWF  FEA
1C66:  MOVFF  FEF,00
1C6A:  MOVFF  FEC,01
1C6E:  MOVFF  FEC,02
1C72:  MOVFF  FEC,03
1C76:  MOVLW  FF
1C78:  BSF    FD8.0
1C7A:  SUBFWB 00,W
1C7C:  MOVWF  xDE
1C7E:  MOVLW  FF
1C80:  SUBFWB 01,W
1C82:  MOVWF  xDF
1C84:  MOVLW  00
1C86:  SUBFWB 02,W
1C88:  MOVLW  00
1C8A:  SUBFWB 03,W
1C8C:  MOVFF  3DF,FB3
1C90:  MOVFF  3DE,FB2
....................         } else { 
1C94:  BRA    1CD6
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
1C96:  MOVF   xA8,W
1C98:  MULLW  04
1C9A:  MOVF   FF3,W
1C9C:  CLRF   03
1C9E:  ADDLW  F7
1CA0:  MOVWF  FE9
1CA2:  MOVLW  02
1CA4:  ADDWFC 03,W
1CA6:  MOVWF  FEA
1CA8:  MOVFF  FEF,00
1CAC:  MOVFF  FEC,01
1CB0:  MOVFF  FEC,02
1CB4:  MOVFF  FEC,03
1CB8:  MOVLW  FF
1CBA:  BSF    FD8.0
1CBC:  SUBFWB 00,W
1CBE:  MOVWF  xDE
1CC0:  MOVLW  FF
1CC2:  SUBFWB 01,W
1CC4:  MOVWF  xDF
1CC6:  MOVLW  00
1CC8:  SUBFWB 02,W
1CCA:  MOVLW  00
1CCC:  SUBFWB 03,W
1CCE:  MOVFF  3DF,FB3
1CD2:  MOVFF  3DE,FB2
....................         } 
....................         break; 
....................     } 
1CD6:  MOVLB  0
1CD8:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_descida_z() { 
....................     if (atual_frequencia_z == 0) { 
1CDA:  MOVLB  3
1CDC:  MOVF   xA8,F
1CDE:  BNZ   1D22
....................         set_timer3(65535 - Ts_z[atual_frequencia_z]); 
1CE0:  MOVF   xA8,W
1CE2:  MULLW  04
1CE4:  MOVF   FF3,W
1CE6:  CLRF   03
1CE8:  ADDLW  F7
1CEA:  MOVWF  FE9
1CEC:  MOVLW  02
1CEE:  ADDWFC 03,W
1CF0:  MOVWF  FEA
1CF2:  MOVFF  FEF,00
1CF6:  MOVFF  FEC,01
1CFA:  MOVFF  FEC,02
1CFE:  MOVFF  FEC,03
1D02:  MOVLW  FF
1D04:  BSF    FD8.0
1D06:  SUBFWB 00,W
1D08:  MOVWF  xDE
1D0A:  MOVLW  FF
1D0C:  SUBFWB 01,W
1D0E:  MOVWF  xDF
1D10:  MOVLW  00
1D12:  SUBFWB 02,W
1D14:  MOVLW  00
1D16:  SUBFWB 03,W
1D18:  MOVFF  3DF,FB3
1D1C:  MOVFF  3DE,FB2
....................     } 
1D20:  BRA    1F34
....................     else if (atual_frequencia_z == vel_z) { 
1D22:  MOVF   xA9,W
1D24:  SUBWF  xA8,W
1D26:  BTFSS  FD8.2
1D28:  BRA    1E6A
....................         if (step_no_z == (step_down_z + StepbyF_z[atual_frequencia_z])) { 
1D2A:  MOVF   xA8,W
1D2C:  MULLW  04
1D2E:  MOVF   FF3,W
1D30:  CLRF   03
1D32:  ADDLW  47
1D34:  MOVWF  FE9
1D36:  MOVLW  03
1D38:  ADDWFC 03,W
1D3A:  MOVWF  FEA
1D3C:  MOVFF  FEF,00
1D40:  MOVFF  FEC,01
1D44:  MOVFF  FEC,02
1D48:  MOVFF  FEC,03
1D4C:  MOVF   x9E,W
1D4E:  ADDWF  00,F
1D50:  MOVF   x9F,W
1D52:  ADDWFC 01,F
1D54:  MOVLW  00
1D56:  ADDWFC 02,F
1D58:  ADDWFC 03,F
1D5A:  MOVF   00,W
1D5C:  SUBWF  x9C,W
1D5E:  BNZ   1E28
1D60:  MOVF   01,W
1D62:  SUBWF  x9D,W
1D64:  BNZ   1E28
1D66:  MOVF   02,F
1D68:  BNZ   1E28
1D6A:  MOVF   03,F
1D6C:  BNZ   1E28
....................             step_acumulado_z = step_down_z + StepbyF_z[atual_frequencia_z] + StepbyF_z[atual_frequencia_z - 1]; 
1D6E:  MOVF   xA8,W
1D70:  MULLW  04
1D72:  MOVF   FF3,W
1D74:  CLRF   03
1D76:  ADDLW  47
1D78:  MOVWF  FE9
1D7A:  MOVLW  03
1D7C:  ADDWFC 03,W
1D7E:  MOVWF  FEA
1D80:  MOVFF  FEF,00
1D84:  MOVFF  FEC,01
1D88:  MOVFF  FEC,02
1D8C:  MOVFF  FEC,03
1D90:  MOVF   00,W
1D92:  ADDWF  x9E,W
1D94:  MOVWF  xDE
1D96:  MOVF   01,W
1D98:  ADDWFC x9F,W
1D9A:  MOVWF  xDF
1D9C:  MOVLW  00
1D9E:  ADDWFC 02,W
1DA0:  MOVWF  xE0
1DA2:  MOVLW  00
1DA4:  ADDWFC 03,W
1DA6:  MOVWF  xE1
1DA8:  MOVLW  01
1DAA:  SUBWF  xA8,W
1DAC:  MULLW  04
1DAE:  MOVF   FF3,W
1DB0:  CLRF   03
1DB2:  ADDLW  47
1DB4:  MOVWF  FE9
1DB6:  MOVLW  03
1DB8:  ADDWFC 03,W
1DBA:  MOVWF  FEA
1DBC:  MOVFF  FEF,00
1DC0:  MOVFF  FEC,01
1DC4:  MOVFF  FEC,02
1DC8:  MOVFF  FEC,03
1DCC:  MOVF   00,W
1DCE:  ADDWF  xDE,W
1DD0:  MOVWF  xA4
1DD2:  MOVF   01,W
1DD4:  ADDWFC xDF,W
1DD6:  MOVWF  xA5
1DD8:  MOVF   02,W
1DDA:  ADDWFC xE0,W
1DDC:  MOVWF  xA6
1DDE:  MOVF   03,W
1DE0:  ADDWFC xE1,W
1DE2:  MOVWF  xA7
....................             atual_frequencia_z--; 
1DE4:  DECF   xA8,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
1DE6:  MOVF   xA8,W
1DE8:  MULLW  04
1DEA:  MOVF   FF3,W
1DEC:  CLRF   03
1DEE:  ADDLW  F7
1DF0:  MOVWF  FE9
1DF2:  MOVLW  02
1DF4:  ADDWFC 03,W
1DF6:  MOVWF  FEA
1DF8:  MOVFF  FEF,00
1DFC:  MOVFF  FEC,01
1E00:  MOVFF  FEC,02
1E04:  MOVFF  FEC,03
1E08:  MOVLW  FF
1E0A:  BSF    FD8.0
1E0C:  SUBFWB 00,W
1E0E:  MOVWF  xDE
1E10:  MOVLW  FF
1E12:  SUBFWB 01,W
1E14:  MOVWF  xDF
1E16:  MOVLW  00
1E18:  SUBFWB 02,W
1E1A:  MOVLW  00
1E1C:  SUBFWB 03,W
1E1E:  MOVFF  3DF,FB3
1E22:  MOVFF  3DE,FB2
....................         } else { 
1E26:  BRA    1E68
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
1E28:  MOVF   xA8,W
1E2A:  MULLW  04
1E2C:  MOVF   FF3,W
1E2E:  CLRF   03
1E30:  ADDLW  F7
1E32:  MOVWF  FE9
1E34:  MOVLW  02
1E36:  ADDWFC 03,W
1E38:  MOVWF  FEA
1E3A:  MOVFF  FEF,00
1E3E:  MOVFF  FEC,01
1E42:  MOVFF  FEC,02
1E46:  MOVFF  FEC,03
1E4A:  MOVLW  FF
1E4C:  BSF    FD8.0
1E4E:  SUBFWB 00,W
1E50:  MOVWF  xDE
1E52:  MOVLW  FF
1E54:  SUBFWB 01,W
1E56:  MOVWF  xDF
1E58:  MOVLW  00
1E5A:  SUBFWB 02,W
1E5C:  MOVLW  00
1E5E:  SUBFWB 03,W
1E60:  MOVFF  3DF,FB3
1E64:  MOVFF  3DE,FB2
....................         } 
....................     } else { 
1E68:  BRA    1F34
....................         if (step_no_z == step_acumulado_z) { 
1E6A:  MOVF   xA4,W
1E6C:  SUBWF  x9C,W
1E6E:  BNZ   1EF4
1E70:  MOVF   xA5,W
1E72:  SUBWF  x9D,W
1E74:  BNZ   1EF4
1E76:  MOVF   xA6,F
1E78:  BNZ   1EF4
1E7A:  MOVF   xA7,F
1E7C:  BNZ   1EF4
....................             atual_frequencia_z--; 
1E7E:  DECF   xA8,F
....................             step_acumulado_z += StepbyF_z[atual_frequencia_z]; 
1E80:  MOVF   xA8,W
1E82:  MULLW  04
1E84:  MOVF   FF3,W
1E86:  CLRF   03
1E88:  ADDLW  47
1E8A:  MOVWF  FE9
1E8C:  MOVLW  03
1E8E:  ADDWFC 03,W
1E90:  MOVWF  FEA
1E92:  MOVFF  FEF,00
1E96:  MOVFF  FEC,01
1E9A:  MOVFF  FEC,02
1E9E:  MOVFF  FEC,03
1EA2:  MOVF   00,W
1EA4:  ADDWF  xA4,F
1EA6:  MOVF   01,W
1EA8:  ADDWFC xA5,F
1EAA:  MOVF   02,W
1EAC:  ADDWFC xA6,F
1EAE:  MOVF   03,W
1EB0:  ADDWFC xA7,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
1EB2:  MOVF   xA8,W
1EB4:  MULLW  04
1EB6:  MOVF   FF3,W
1EB8:  CLRF   03
1EBA:  ADDLW  F7
1EBC:  MOVWF  FE9
1EBE:  MOVLW  02
1EC0:  ADDWFC 03,W
1EC2:  MOVWF  FEA
1EC4:  MOVFF  FEF,00
1EC8:  MOVFF  FEC,01
1ECC:  MOVFF  FEC,02
1ED0:  MOVFF  FEC,03
1ED4:  MOVLW  FF
1ED6:  BSF    FD8.0
1ED8:  SUBFWB 00,W
1EDA:  MOVWF  xDE
1EDC:  MOVLW  FF
1EDE:  SUBFWB 01,W
1EE0:  MOVWF  xDF
1EE2:  MOVLW  00
1EE4:  SUBFWB 02,W
1EE6:  MOVLW  00
1EE8:  SUBFWB 03,W
1EEA:  MOVFF  3DF,FB3
1EEE:  MOVFF  3DE,FB2
....................         } else { 
1EF2:  BRA    1F34
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
1EF4:  MOVF   xA8,W
1EF6:  MULLW  04
1EF8:  MOVF   FF3,W
1EFA:  CLRF   03
1EFC:  ADDLW  F7
1EFE:  MOVWF  FE9
1F00:  MOVLW  02
1F02:  ADDWFC 03,W
1F04:  MOVWF  FEA
1F06:  MOVFF  FEF,00
1F0A:  MOVFF  FEC,01
1F0E:  MOVFF  FEC,02
1F12:  MOVFF  FEC,03
1F16:  MOVLW  FF
1F18:  BSF    FD8.0
1F1A:  SUBFWB 00,W
1F1C:  MOVWF  xDE
1F1E:  MOVLW  FF
1F20:  SUBFWB 01,W
1F22:  MOVWF  xDF
1F24:  MOVLW  00
1F26:  SUBFWB 02,W
1F28:  MOVLW  00
1F2A:  SUBFWB 03,W
1F2C:  MOVFF  3DF,FB3
1F30:  MOVFF  3DE,FB2
....................         } 
....................     } 
1F34:  MOVLB  0
1F36:  GOTO   1F9C (RETURN)
.................... } 
....................  
.................... void movimenta_eixo_z() { 
....................  
....................     switch (ramp_sts_z) { 
1F3A:  MOVLB  3
1F3C:  MOVF   x9A,W
1F3E:  XORLW  01
1F40:  MOVLB  0
1F42:  BZ    1F4E
1F44:  XORLW  02
1F46:  BZ    1F90
1F48:  XORLW  01
1F4A:  BZ    1FB0
1F4C:  BRA    1FD2
....................         case ramp_up: // accel 
....................             output_toggle(step_z); 
1F4E:  BCF    F92.5
1F50:  BTG    F89.5
....................             rest_z = ~rest_z; 
1F52:  MOVLB  3
1F54:  BTG    x9B.1
....................             proximo_valor_subida_z(); 
1F56:  MOVLB  0
1F58:  RCALL  1A9A
....................             if (step_no_z == midpt_z) { // midpoint: decel 
1F5A:  MOVLB  3
1F5C:  MOVF   xA2,W
1F5E:  SUBWF  x9C,W
1F60:  BNZ   1F8E
1F62:  MOVF   xA3,W
1F64:  SUBWF  x9D,W
1F66:  BNZ   1F8E
....................                 if (move_z > 2 * total_acc_step_z) 
1F68:  BCF    FD8.0
1F6A:  RLCF   x97,W
1F6C:  MOVWF  02
1F6E:  RLCF   x98,W
1F70:  MOVWF  03
1F72:  MOVFF  02,01
1F76:  MOVF   03,W
1F78:  SUBWF  xA1,W
1F7A:  BNC   1F8A
1F7C:  BNZ   1F84
1F7E:  MOVF   xA0,W
1F80:  SUBWF  01,W
1F82:  BC    1F8A
....................                     ramp_sts_z = ramp_max; 
1F84:  MOVLW  02
1F86:  MOVWF  x9A
1F88:  BRA    1F8E
....................                 else 
....................                     ramp_sts_z = ramp_down; 
1F8A:  MOVLW  03
1F8C:  MOVWF  x9A
....................             } 
....................             break; 
1F8E:  BRA    1FDA
....................  
....................         case ramp_down: // decel 
....................             output_toggle(step_z); 
1F90:  BCF    F92.5
1F92:  BTG    F89.5
....................             rest_z = ~rest_z; 
1F94:  MOVLB  3
1F96:  BTG    x9B.1
....................             proximo_valor_descida_z(); 
1F98:  MOVLB  0
1F9A:  BRA    1CDA
....................             if (step_no_z == move_z) 
1F9C:  MOVLB  3
1F9E:  MOVF   xA0,W
1FA0:  SUBWF  x9C,W
1FA2:  BNZ   1FAE
1FA4:  MOVF   xA1,W
1FA6:  SUBWF  x9D,W
1FA8:  BNZ   1FAE
....................                 ramp_sts_z = ramp_last; 
1FAA:  MOVLW  04
1FAC:  MOVWF  x9A
....................             break; 
1FAE:  BRA    1FDA
....................  
....................         case ramp_max: // constant speed 
....................             output_toggle(step_z); 
1FB0:  BCF    F92.5
1FB2:  BTG    F89.5
....................             rest_z = ~rest_z; 
1FB4:  MOVLB  3
1FB6:  BTG    x9B.1
....................             proximo_valor_subida_z(); 
1FB8:  MOVLB  0
1FBA:  RCALL  1A9A
....................             if (step_no_z == step_down_z) // start decel 
1FBC:  MOVLB  3
1FBE:  MOVF   x9E,W
1FC0:  SUBWF  x9C,W
1FC2:  BNZ   1FCE
1FC4:  MOVF   x9F,W
1FC6:  SUBWF  x9D,W
1FC8:  BNZ   1FCE
....................                 ramp_sts_z = ramp_down; 
1FCA:  MOVLW  03
1FCC:  MOVWF  x9A
....................             break; 
1FCE:  BRA    1FDA
1FD0:  MOVLB  0
....................  
....................         default: // last step: cleanup 
....................             ramp_sts_z = ramp_idle; 
1FD2:  MOVLB  3
1FD4:  CLRF   x9A
....................             disable_interrupts(INT_TIMER3); 
1FD6:  BCF    FA0.1
....................             run_flg_z = FALSE; // move_z complete 
1FD8:  BCF    x9B.0
....................             break; 
....................     } // switch (ramp_sts_z) 
....................     if (ramp_sts_z != ramp_idle) { 
1FDA:  MOVF   x9A,F
1FDC:  BZ    2004
....................         if (rest_z) { 
1FDE:  BTFSS  x9B.1
1FE0:  BRA    2004
....................             motor_pos_z += pos_inc_z; 
1FE2:  CLRF   03
1FE4:  MOVF   x99,W
1FE6:  BTFSC  FE8.7
1FE8:  DECF   03,F
1FEA:  MOVLB  1
1FEC:  ADDWF  x18,W
1FEE:  MOVWF  01
1FF0:  MOVF   x19,W
1FF2:  ADDWFC 03,F
1FF4:  MOVFF  01,118
1FF8:  MOVFF  03,119
....................             ++step_no_z; 
1FFC:  MOVLB  3
1FFE:  INCF   x9C,F
2000:  BTFSC  FD8.2
2002:  INCF   x9D,F
....................         } 
....................     } 
2004:  MOVLB  0
2006:  GOTO   200C (RETURN)
.................... } 
....................  
.................... void umpasso_z(int16 descanco, short dir) { 
....................     output_low(enable_z); 
....................     if (dir) { 
....................         output_high(dir_z); 
....................         motor_pos_z--; 
....................     } else { 
....................         output_low(dir_z); 
....................         motor_pos_z++; 
....................     } 
....................     output_high(step_z); 
....................     delay_us(descanco); 
....................     output_low(step_z); 
....................     delay_us(descanco); 
....................  
.................... } 
....................  
.................... void zerar_z() { 
....................  
....................     while (le_Input(s_limite_z) == 1) { 
....................         delay_us(200); 
....................         umpasso_z(600, FALSE);//600 
....................     } 
....................     while (le_Input(s_limite_z) == 0) { 
....................         delay_us(200); 
....................         umpasso_z(900, TRUE);//900 
....................     } 
....................     while (le_Input(s_limite_z) == 1) { 
....................         delay_us(200); 
....................         umpasso_z(1000, FALSE);//1000 
....................     } 
....................    // output_high(enable_z); 
....................     motor_pos_z = 0; 
.................... } 
....................  
.................... void medir_z() { 
....................     while (le_Input(i_limite_z) == 0) { 
....................         umpasso_z(900, FALSE); 
....................         delay_us(200); 
....................     } 
....................     while (le_Input(i_limite_z) == 1) { 
....................         umpasso_z(900, TRUE); 
....................         delay_us(200); 
....................     } 
....................     max_posicao_z = motor_pos_z; 
....................     output_high(enable_z); 
....................     printf(lcd_putc, "%04Lu", max_posicao_z); 
.................... } 
.................... // </editor-fold> 
....................  
.................... #include "movimentos_maq_1.c" 
.................... void go_flip(long int flip_posicao) { 
....................     sentido_horario_flag = false; 
*
59A0:  MOVLB  1
59A2:  BCF    x1A.1
....................     sentido_antihorario_flag = false; 
59A4:  BCF    x1A.2
....................     if (flip_posicao > contador_step_flip) {  
59A6:  MOVF   x17,W
59A8:  MOVLB  3
59AA:  SUBWF  xB1,W
59AC:  BNC   59CA
59AE:  BNZ   59C0
59B0:  MOVF   xB0,W
59B2:  MOVLB  1
59B4:  SUBWF  x16,W
59B6:  BTFSS  FD8.0
59B8:  BRA    59BE
59BA:  MOVLB  3
59BC:  BRA    59CA
59BE:  MOVLB  3
....................         sentido_horario(); 
59C0:  MOVLB  0
59C2:  CALL   4920
.................... 	}else{ 
59C6:  BRA    59D0
59C8:  MOVLB  3
....................         sentido_antihorario(); 
59CA:  MOVLB  0
59CC:  CALL   4962
.................... 	} 
....................     while(flip_posicao != contador_step_flip) { 
59D0:  MOVLB  1
59D2:  MOVF   x16,W
59D4:  MOVLB  3
59D6:  SUBWF  xB0,W
59D8:  BNZ   59E4
59DA:  MOVLB  1
59DC:  MOVF   x17,W
59DE:  MOVLB  3
59E0:  SUBWF  xB1,W
59E2:  BZ    5A10
....................         one_step_flip(); 
59E4:  MOVLB  0
59E6:  CALL   492E
....................         delay_us(velocidade_motor); 
59EA:  MOVLW  02
59EC:  MOVLB  3
59EE:  MOVWF  xBE
59F0:  MOVLB  0
59F2:  CALL   2064
59F6:  MOVLW  02
59F8:  MOVLB  3
59FA:  MOVWF  xB2
59FC:  MOVLW  F9
59FE:  MOVWF  xB3
5A00:  MOVLB  0
5A02:  BRA    597E
5A04:  MOVLB  3
5A06:  DECFSZ xB2,F
5A08:  BRA    59FC
5A0A:  MOVLB  0
5A0C:  BRA    59D0
5A0E:  MOVLB  3
....................     } 
5A10:  MOVLB  0
5A12:  RETURN 0
.................... } 
....................  
.................... int   flip_home(void) { 
*
4970:  MOVLB  3
4972:  CLRF   xB1
.................... 	int i; 
....................     int erro=0; 
.................... 	chopper_flip(); 
4974:  MOVLB  0
4976:  BRA    4918
.................... 	delay_ms(50);	 
4978:  MOVLW  32
497A:  MOVLB  3
497C:  MOVWF  xBE
497E:  MOVLB  0
4980:  CALL   2064
.................... 	if(le_Input(S_ROTACAO_LS1) == true) { 
4984:  MOVLW  0B
4986:  MOVLB  3
4988:  MOVWF  xB2
498A:  MOVLB  0
498C:  CALL   4090
4990:  DECFSZ 01,W
4992:  BRA    4A24
.................... 		sentido_horario(); 
4994:  RCALL  4920
.................... 		delay_ms(50); 
4996:  MOVLW  32
4998:  MOVLB  3
499A:  MOVWF  xBE
499C:  MOVLB  0
499E:  CALL   2064
.................... 	    for(i=0;i<=140;i++) {							 
49A2:  MOVLB  3
49A4:  CLRF   xB0
49A6:  MOVF   xB0,W
49A8:  SUBLW  8C
49AA:  BNC   49C2
.................... 		    one_step_flip(); 
49AC:  MOVLB  0
49AE:  RCALL  492E
.................... 			delay_us(4000); 
49B0:  MOVLW  04
49B2:  MOVLB  3
49B4:  MOVWF  xBE
49B6:  MOVLB  0
49B8:  CALL   2064
49BC:  MOVLB  3
49BE:  INCF   xB0,F
49C0:  BRA    49A6
.................... 		} 
.................... 		sentido_antihorario(); 
49C2:  MOVLB  0
49C4:  RCALL  4962
.................... 		delay_ms(100); 
49C6:  MOVLW  64
49C8:  MOVLB  3
49CA:  MOVWF  xBE
49CC:  MOVLB  0
49CE:  CALL   2064
.................... 	    while(le_Input(S_ROTACAO_LS1) == false) {				 
49D2:  MOVLW  0B
49D4:  MOVLB  3
49D6:  MOVWF  xB2
49D8:  MOVLB  0
49DA:  CALL   4090
49DE:  MOVF   01,F
49E0:  BNZ   49F2
....................             one_step_flip(); 
49E2:  RCALL  492E
....................             delay_us(4000); 
49E4:  MOVLW  04
49E6:  MOVLB  3
49E8:  MOVWF  xBE
49EA:  MOVLB  0
49EC:  CALL   2064
49F0:  BRA    49D2
.................... 		}				 
....................         for(i=0;i<=36;i++) { 
49F2:  MOVLB  3
49F4:  CLRF   xB0
49F6:  MOVF   xB0,W
49F8:  SUBLW  24
49FA:  BNC   4A12
....................             one_step_flip(); 
49FC:  MOVLB  0
49FE:  RCALL  492E
....................             delay_us(4000); 
4A00:  MOVLW  04
4A02:  MOVLB  3
4A04:  MOVWF  xBE
4A06:  MOVLB  0
4A08:  CALL   2064
4A0C:  MOVLB  3
4A0E:  INCF   xB0,F
4A10:  BRA    49F6
....................         } 
....................         sentido_horario(); 
4A12:  MOVLB  0
4A14:  RCALL  4920
....................         delay_ms(50);		 
4A16:  MOVLW  32
4A18:  MOVLB  3
4A1A:  MOVWF  xBE
4A1C:  MOVLB  0
4A1E:  CALL   2064
.................... 	}else{			 
4A22:  BRA    4A74
....................         sentido_antihorario(); 
4A24:  RCALL  4962
....................         delay_ms(50); 
4A26:  MOVLW  32
4A28:  MOVLB  3
4A2A:  MOVWF  xBE
4A2C:  MOVLB  0
4A2E:  CALL   2064
....................         while(le_Input(S_ROTACAO_LS1) == false){				 
4A32:  MOVLW  0B
4A34:  MOVLB  3
4A36:  MOVWF  xB2
4A38:  MOVLB  0
4A3A:  CALL   4090
4A3E:  MOVF   01,F
4A40:  BNZ   4A52
....................             one_step_flip(); 
4A42:  RCALL  492E
....................             delay_us(2000); 
4A44:  MOVLW  02
4A46:  MOVLB  3
4A48:  MOVWF  xBE
4A4A:  MOVLB  0
4A4C:  CALL   2064
4A50:  BRA    4A32
....................         }				 
....................         for(i=0;i<=36;i++) { 
4A52:  MOVLB  3
4A54:  CLRF   xB0
4A56:  MOVF   xB0,W
4A58:  SUBLW  24
4A5A:  BNC   4A72
....................             one_step_flip(); 
4A5C:  MOVLB  0
4A5E:  RCALL  492E
....................             delay_us(4000); 
4A60:  MOVLW  04
4A62:  MOVLB  3
4A64:  MOVWF  xBE
4A66:  MOVLB  0
4A68:  CALL   2064
4A6C:  MOVLB  3
4A6E:  INCF   xB0,F
4A70:  BRA    4A56
4A72:  MOVLB  0
....................         } 
.................... 	}	  
....................     sentido_horario(); 
4A74:  RCALL  4920
....................     delay_ms(50); 
4A76:  MOVLW  32
4A78:  MOVLB  3
4A7A:  MOVWF  xBE
4A7C:  MOVLB  0
4A7E:  CALL   2064
....................     for(i=0;i<=71;i++) { 
4A82:  MOVLB  3
4A84:  CLRF   xB0
4A86:  MOVF   xB0,W
4A88:  SUBLW  47
4A8A:  BNC   4AA2
....................         one_step_flip(); 
4A8C:  MOVLB  0
4A8E:  RCALL  492E
....................         delay_us(4000); 
4A90:  MOVLW  04
4A92:  MOVLB  3
4A94:  MOVWF  xBE
4A96:  MOVLB  0
4A98:  CALL   2064
4A9C:  MOVLB  3
4A9E:  INCF   xB0,F
4AA0:  BRA    4A86
....................     } 
....................     contador_step_flip = 0;			 
4AA2:  MOVLB  1
4AA4:  CLRF   x17
4AA6:  CLRF   x16
....................     return erro; 
4AA8:  MOVLB  3
4AAA:  MOVFF  3B1,01
4AAE:  MOVLB  0
4AB0:  RETURN 0
.................... } 
.................... void  x_home_esquerda() { 
.................... 	int i; 
.................... 	chopper_x(); 
*
45DE:  RCALL  4586
.................... 	delay_ms(50);	 
45E0:  MOVLW  32
45E2:  MOVLB  3
45E4:  MOVWF  xBE
45E6:  MOVLB  0
45E8:  CALL   2064
.................... 	if(le_Input(S_X_ESQUERDA) == true) { 
45EC:  MOVLW  06
45EE:  MOVLB  3
45F0:  MOVWF  xB2
45F2:  MOVLB  0
45F4:  RCALL  4090
45F6:  DECFSZ 01,W
45F8:  BRA    4698
.................... 		direita(); 
45FA:  RCALL  458C
.................... 		delay_ms(50); 
45FC:  MOVLW  32
45FE:  MOVLB  3
4600:  MOVWF  xBE
4602:  MOVLB  0
4604:  CALL   2064
....................         while(le_Input(S_X_ESQUERDA) == true) { 
4608:  MOVLW  06
460A:  MOVLB  3
460C:  MOVWF  xB2
460E:  MOVLB  0
4610:  RCALL  4090
4612:  DECFSZ 01,W
4614:  BRA    4626
....................             one_step_x(); 
4616:  RCALL  4596
....................             delay_us(2000); 
4618:  MOVLW  02
461A:  MOVLB  3
461C:  MOVWF  xBE
461E:  MOVLB  0
4620:  CALL   2064
4624:  BRA    4608
....................         } 
....................         for(i=0;i<=40;i++) { 
4626:  MOVLB  3
4628:  CLRF   xB0
462A:  MOVF   xB0,W
462C:  SUBLW  28
462E:  BNC   4646
....................             one_step_x(); 
4630:  MOVLB  0
4632:  RCALL  4596
....................             delay_us(2000); 
4634:  MOVLW  02
4636:  MOVLB  3
4638:  MOVWF  xBE
463A:  MOVLB  0
463C:  CALL   2064
4640:  MOVLB  3
4642:  INCF   xB0,F
4644:  BRA    462A
....................         } 
.................... 		esquerda(); 
4646:  MOVLB  0
4648:  RCALL  45CE
.................... 		delay_ms(50); 
464A:  MOVLW  32
464C:  MOVLB  3
464E:  MOVWF  xBE
4650:  MOVLB  0
4652:  CALL   2064
....................         while(le_Input(S_X_ESQUERDA) == false) {				 
4656:  MOVLW  06
4658:  MOVLB  3
465A:  MOVWF  xB2
465C:  MOVLB  0
465E:  RCALL  4090
4660:  MOVF   01,F
4662:  BNZ   4674
....................             one_step_x(); 
4664:  RCALL  4596
....................             delay_us(2000); 
4666:  MOVLW  02
4668:  MOVLB  3
466A:  MOVWF  xBE
466C:  MOVLB  0
466E:  CALL   2064
4672:  BRA    4656
.................... 		}			 
....................         for(i=0;i<=40;i++) { 
4674:  MOVLB  3
4676:  CLRF   xB0
4678:  MOVF   xB0,W
467A:  SUBLW  28
467C:  BNC   4694
....................             one_step_x(); 
467E:  MOVLB  0
4680:  RCALL  4596
....................             delay_us(2000); 
4682:  MOVLW  02
4684:  MOVLB  3
4686:  MOVWF  xBE
4688:  MOVLB  0
468A:  CALL   2064
468E:  MOVLB  3
4690:  INCF   xB0,F
4692:  BRA    4678
....................         } 
.................... 	}else{ 
4694:  BRA    46E4
4696:  MOVLB  0
....................         esquerda(); 
4698:  RCALL  45CE
....................         delay_ms(50); 
469A:  MOVLW  32
469C:  MOVLB  3
469E:  MOVWF  xBE
46A0:  MOVLB  0
46A2:  CALL   2064
....................         while(le_Input(S_X_ESQUERDA) == false) { 
46A6:  MOVLW  06
46A8:  MOVLB  3
46AA:  MOVWF  xB2
46AC:  MOVLB  0
46AE:  RCALL  4090
46B0:  MOVF   01,F
46B2:  BNZ   46C4
....................             one_step_x(); 
46B4:  RCALL  4596
....................             delay_us(2000); 
46B6:  MOVLW  02
46B8:  MOVLB  3
46BA:  MOVWF  xBE
46BC:  MOVLB  0
46BE:  CALL   2064
46C2:  BRA    46A6
....................         }				 
....................         for(i=0;i<=40;i++) { 
46C4:  MOVLB  3
46C6:  CLRF   xB0
46C8:  MOVF   xB0,W
46CA:  SUBLW  28
46CC:  BNC   46E4
....................             one_step_x(); 
46CE:  MOVLB  0
46D0:  RCALL  4596
....................             delay_us(2000); 
46D2:  MOVLW  02
46D4:  MOVLB  3
46D6:  MOVWF  xBE
46D8:  MOVLB  0
46DA:  CALL   2064
46DE:  MOVLB  3
46E0:  INCF   xB0,F
46E2:  BRA    46C8
....................         } 
.................... 	}	 
....................     motor_pos_x = 0;  
46E4:  MOVLB  1
46E6:  CLRF   x13
46E8:  CLRF   x12
....................     stop_x();			 
46EA:  MOVLB  0
46EC:  RCALL  45D8
46EE:  RETURN 0
.................... } 
.................... void  y_home_frente(){ 
.................... 	int i; 
.................... 	chopper_y(); 
46F0:  RCALL  441A
.................... 	delay_ms(50);	 
46F2:  MOVLW  32
46F4:  MOVLB  3
46F6:  MOVWF  xBE
46F8:  MOVLB  0
46FA:  CALL   2064
.................... 	if(le_Input(S_Y_FRENTE) == true) { 
46FE:  MOVLW  07
4700:  MOVLB  3
4702:  MOVWF  xB2
4704:  MOVLB  0
4706:  RCALL  4090
4708:  DECFSZ 01,W
470A:  BRA    47AA
.................... 		atras(); 
470C:  RCALL  4462
.................... 		delay_ms(50); 
470E:  MOVLW  32
4710:  MOVLB  3
4712:  MOVWF  xBE
4714:  MOVLB  0
4716:  CALL   2064
....................         while(le_Input(S_Y_FRENTE) == true) { 
471A:  MOVLW  07
471C:  MOVLB  3
471E:  MOVWF  xB2
4720:  MOVLB  0
4722:  RCALL  4090
4724:  DECFSZ 01,W
4726:  BRA    4738
....................             one_step_y(); 
4728:  RCALL  442A
....................             delay_us(2000); 
472A:  MOVLW  02
472C:  MOVLB  3
472E:  MOVWF  xBE
4730:  MOVLB  0
4732:  CALL   2064
4736:  BRA    471A
....................         } 
....................         for(i=0;i<=40;i++) { //para sair do histerese do sensor dando maior precisao 
4738:  MOVLB  3
473A:  CLRF   xB0
473C:  MOVF   xB0,W
473E:  SUBLW  28
4740:  BNC   4758
....................             one_step_y(); 
4742:  MOVLB  0
4744:  RCALL  442A
....................             delay_us(2000); 
4746:  MOVLW  02
4748:  MOVLB  3
474A:  MOVWF  xBE
474C:  MOVLB  0
474E:  CALL   2064
4752:  MOVLB  3
4754:  INCF   xB0,F
4756:  BRA    473C
....................         } 
.................... 		frente(); 
4758:  MOVLB  0
475A:  RCALL  4420
.................... 		delay_ms(50); 
475C:  MOVLW  32
475E:  MOVLB  3
4760:  MOVWF  xBE
4762:  MOVLB  0
4764:  CALL   2064
....................         while(le_Input(S_Y_FRENTE) == false){				 
4768:  MOVLW  07
476A:  MOVLB  3
476C:  MOVWF  xB2
476E:  MOVLB  0
4770:  RCALL  4090
4772:  MOVF   01,F
4774:  BNZ   4786
....................             one_step_y(); 
4776:  RCALL  442A
....................             delay_us(2000); 
4778:  MOVLW  02
477A:  MOVLB  3
477C:  MOVWF  xBE
477E:  MOVLB  0
4780:  CALL   2064
4784:  BRA    4768
....................         }				 
....................         for(i=0;i<=40;i++){ 
4786:  MOVLB  3
4788:  CLRF   xB0
478A:  MOVF   xB0,W
478C:  SUBLW  28
478E:  BNC   47A6
....................             one_step_y(); 
4790:  MOVLB  0
4792:  RCALL  442A
....................             delay_us(2000); 
4794:  MOVLW  02
4796:  MOVLB  3
4798:  MOVWF  xBE
479A:  MOVLB  0
479C:  CALL   2064
47A0:  MOVLB  3
47A2:  INCF   xB0,F
47A4:  BRA    478A
....................         } 
.................... 	}else{ 
47A6:  BRA    47F6
47A8:  MOVLB  0
....................         frente(); 
47AA:  RCALL  4420
....................         delay_ms(50); 
47AC:  MOVLW  32
47AE:  MOVLB  3
47B0:  MOVWF  xBE
47B2:  MOVLB  0
47B4:  CALL   2064
....................         while(le_Input(S_Y_FRENTE) == false) { 
47B8:  MOVLW  07
47BA:  MOVLB  3
47BC:  MOVWF  xB2
47BE:  MOVLB  0
47C0:  RCALL  4090
47C2:  MOVF   01,F
47C4:  BNZ   47D6
....................             one_step_y(); 
47C6:  RCALL  442A
....................             delay_us(2000); 
47C8:  MOVLW  02
47CA:  MOVLB  3
47CC:  MOVWF  xBE
47CE:  MOVLB  0
47D0:  CALL   2064
47D4:  BRA    47B8
....................         }				 
....................         for(i=0;i<=40;i++) { 
47D6:  MOVLB  3
47D8:  CLRF   xB0
47DA:  MOVF   xB0,W
47DC:  SUBLW  28
47DE:  BNC   47F6
....................             one_step_y(); 
47E0:  MOVLB  0
47E2:  RCALL  442A
....................             delay_us(2000); 
47E4:  MOVLW  02
47E6:  MOVLB  3
47E8:  MOVWF  xBE
47EA:  MOVLB  0
47EC:  CALL   2064
47F0:  MOVLB  3
47F2:  INCF   xB0,F
47F4:  BRA    47DA
....................         } 
.................... 	}	 
....................     motor_pos_y = 0;   
47F6:  MOVLB  1
47F8:  CLRF   x15
47FA:  CLRF   x14
....................     stop_y();			 
47FC:  MOVLB  0
47FE:  RCALL  446C
4800:  RETURN 0
.................... } 
.................... void  y_home_atras() { 
.................... 	int i; 
.................... 	chopper_y(); 
*
4472:  RCALL  441A
.................... 	delay_ms(50);	 
4474:  MOVLW  32
4476:  MOVLB  3
4478:  MOVWF  xBE
447A:  MOVLB  0
447C:  CALL   2064
.................... 	if(le_Input(S_Y_ATRAS) == true) { 
4480:  MOVLW  08
4482:  MOVLB  3
4484:  MOVWF  xB2
4486:  MOVLB  0
4488:  RCALL  4090
448A:  DECFSZ 01,W
448C:  BRA    452C
.................... 		frente(); 
448E:  RCALL  4420
.................... 		delay_ms(50); 
4490:  MOVLW  32
4492:  MOVLB  3
4494:  MOVWF  xBE
4496:  MOVLB  0
4498:  CALL   2064
....................         while(le_Input(S_Y_ATRAS) == true){ 
449C:  MOVLW  08
449E:  MOVLB  3
44A0:  MOVWF  xB2
44A2:  MOVLB  0
44A4:  RCALL  4090
44A6:  DECFSZ 01,W
44A8:  BRA    44BA
....................             one_step_y(); 
44AA:  RCALL  442A
....................             delay_us(2000); 
44AC:  MOVLW  02
44AE:  MOVLB  3
44B0:  MOVWF  xBE
44B2:  MOVLB  0
44B4:  CALL   2064
44B8:  BRA    449C
....................         } 
....................         for(i=0;i<=40;i++){ //para sair do histerese do sensor dando maior precisao 
44BA:  MOVLB  3
44BC:  CLRF   xB0
44BE:  MOVF   xB0,W
44C0:  SUBLW  28
44C2:  BNC   44DA
....................             one_step_y(); 
44C4:  MOVLB  0
44C6:  RCALL  442A
....................             delay_us(2000); 
44C8:  MOVLW  02
44CA:  MOVLB  3
44CC:  MOVWF  xBE
44CE:  MOVLB  0
44D0:  CALL   2064
44D4:  MOVLB  3
44D6:  INCF   xB0,F
44D8:  BRA    44BE
....................         } 
.................... 		atras(); 
44DA:  MOVLB  0
44DC:  RCALL  4462
.................... 		delay_ms(50); 
44DE:  MOVLW  32
44E0:  MOVLB  3
44E2:  MOVWF  xBE
44E4:  MOVLB  0
44E6:  CALL   2064
....................         while(le_Input(S_Y_ATRAS) == false) {				 
44EA:  MOVLW  08
44EC:  MOVLB  3
44EE:  MOVWF  xB2
44F0:  MOVLB  0
44F2:  RCALL  4090
44F4:  MOVF   01,F
44F6:  BNZ   4508
....................             one_step_y(); 
44F8:  RCALL  442A
....................             delay_us(2000); 
44FA:  MOVLW  02
44FC:  MOVLB  3
44FE:  MOVWF  xBE
4500:  MOVLB  0
4502:  CALL   2064
4506:  BRA    44EA
....................         }				 
....................         for(i=0;i<=40;i++){ 
4508:  MOVLB  3
450A:  CLRF   xB0
450C:  MOVF   xB0,W
450E:  SUBLW  28
4510:  BNC   4528
....................             one_step_y(); 
4512:  MOVLB  0
4514:  RCALL  442A
....................             delay_us(2000); 
4516:  MOVLW  02
4518:  MOVLB  3
451A:  MOVWF  xBE
451C:  MOVLB  0
451E:  CALL   2064
4522:  MOVLB  3
4524:  INCF   xB0,F
4526:  BRA    450C
....................         } 
.................... 	}else{ 
4528:  BRA    4578
452A:  MOVLB  0
....................         atras(); 
452C:  RCALL  4462
....................         delay_ms(50); 
452E:  MOVLW  32
4530:  MOVLB  3
4532:  MOVWF  xBE
4534:  MOVLB  0
4536:  CALL   2064
....................         while(le_Input(S_Y_ATRAS) == false) { 
453A:  MOVLW  08
453C:  MOVLB  3
453E:  MOVWF  xB2
4540:  MOVLB  0
4542:  RCALL  4090
4544:  MOVF   01,F
4546:  BNZ   4558
....................             one_step_y(); 
4548:  RCALL  442A
....................             delay_us(2000); 
454A:  MOVLW  02
454C:  MOVLB  3
454E:  MOVWF  xBE
4550:  MOVLB  0
4552:  CALL   2064
4556:  BRA    453A
....................         } 
....................         for(i=0;i<=40;i++) { 
4558:  MOVLB  3
455A:  CLRF   xB0
455C:  MOVF   xB0,W
455E:  SUBLW  28
4560:  BNC   4578
....................             one_step_y(); 
4562:  MOVLB  0
4564:  RCALL  442A
....................             delay_us(2000); 
4566:  MOVLW  02
4568:  MOVLB  3
456A:  MOVWF  xBE
456C:  MOVLB  0
456E:  CALL   2064
4572:  MOVLB  3
4574:  INCF   xB0,F
4576:  BRA    455C
....................         } 
.................... 	}	 
....................     motor_pos_y = 0;    
4578:  MOVLB  1
457A:  CLRF   x15
457C:  CLRF   x14
....................     stop_y();			 
457E:  MOVLB  0
4580:  RCALL  446C
4582:  GOTO   4D3E (RETURN)
.................... } 
.................... void  x_home_direita() {  
.................... 	int i; 
.................... 	chopper_x(); 
*
4802:  RCALL  4586
.................... 	delay_ms(50);	 
4804:  MOVLW  32
4806:  MOVLB  3
4808:  MOVWF  xBE
480A:  MOVLB  0
480C:  CALL   2064
.................... 	if(le_Input(S_X_DIREITA) == true) { 
4810:  MOVLW  05
4812:  MOVLB  3
4814:  MOVWF  xB2
4816:  MOVLB  0
4818:  RCALL  4090
481A:  DECFSZ 01,W
481C:  BRA    48BC
.................... 		esquerda(); 
481E:  RCALL  45CE
.................... 		delay_ms(50); 
4820:  MOVLW  32
4822:  MOVLB  3
4824:  MOVWF  xBE
4826:  MOVLB  0
4828:  CALL   2064
....................         while(le_Input(S_X_DIREITA) == true) { 
482C:  MOVLW  05
482E:  MOVLB  3
4830:  MOVWF  xB2
4832:  MOVLB  0
4834:  RCALL  4090
4836:  DECFSZ 01,W
4838:  BRA    484A
....................             one_step_x(); 
483A:  RCALL  4596
....................             delay_us(2000); 
483C:  MOVLW  02
483E:  MOVLB  3
4840:  MOVWF  xBE
4842:  MOVLB  0
4844:  CALL   2064
4848:  BRA    482C
....................         } 
....................         for(i=0;i<=40;i++){ //para sair do histerese do sensor dando maior precisao 
484A:  MOVLB  3
484C:  CLRF   xB0
484E:  MOVF   xB0,W
4850:  SUBLW  28
4852:  BNC   486A
....................             one_step_x(); 
4854:  MOVLB  0
4856:  RCALL  4596
....................             delay_us(2000); 
4858:  MOVLW  02
485A:  MOVLB  3
485C:  MOVWF  xBE
485E:  MOVLB  0
4860:  CALL   2064
4864:  MOVLB  3
4866:  INCF   xB0,F
4868:  BRA    484E
....................         } 
.................... 		direita(); 
486A:  MOVLB  0
486C:  RCALL  458C
.................... 		delay_ms(50); 
486E:  MOVLW  32
4870:  MOVLB  3
4872:  MOVWF  xBE
4874:  MOVLB  0
4876:  CALL   2064
....................         while(le_Input(S_X_DIREITA) == false) {				 
487A:  MOVLW  05
487C:  MOVLB  3
487E:  MOVWF  xB2
4880:  MOVLB  0
4882:  RCALL  4090
4884:  MOVF   01,F
4886:  BNZ   4898
....................             one_step_x(); 
4888:  RCALL  4596
....................             delay_us(2000); 
488A:  MOVLW  02
488C:  MOVLB  3
488E:  MOVWF  xBE
4890:  MOVLB  0
4892:  CALL   2064
4896:  BRA    487A
....................         }				 
....................         for(i=0;i<=40;i++) { 
4898:  MOVLB  3
489A:  CLRF   xB0
489C:  MOVF   xB0,W
489E:  SUBLW  28
48A0:  BNC   48B8
....................             one_step_x(); 
48A2:  MOVLB  0
48A4:  RCALL  4596
....................             delay_us(2000); 
48A6:  MOVLW  02
48A8:  MOVLB  3
48AA:  MOVWF  xBE
48AC:  MOVLB  0
48AE:  CALL   2064
48B2:  MOVLB  3
48B4:  INCF   xB0,F
48B6:  BRA    489C
....................         } 
.................... 	}else{			 
48B8:  BRA    490A
48BA:  MOVLB  0
....................         direita(); 
48BC:  RCALL  458C
....................         delay_ms(50); 
48BE:  MOVLW  32
48C0:  MOVLB  3
48C2:  MOVWF  xBE
48C4:  MOVLB  0
48C6:  CALL   2064
....................         while(le_Input(S_X_DIREITA) == false) { 
48CA:  MOVLW  05
48CC:  MOVLB  3
48CE:  MOVWF  xB2
48D0:  MOVLB  0
48D2:  CALL   4090
48D6:  MOVF   01,F
48D8:  BNZ   48EA
....................             one_step_x(); 
48DA:  RCALL  4596
....................             delay_us(2000); 
48DC:  MOVLW  02
48DE:  MOVLB  3
48E0:  MOVWF  xBE
48E2:  MOVLB  0
48E4:  CALL   2064
48E8:  BRA    48CA
....................         } 
....................         for(i=0;i<=40;i++) { 
48EA:  MOVLB  3
48EC:  CLRF   xB0
48EE:  MOVF   xB0,W
48F0:  SUBLW  28
48F2:  BNC   490A
....................             one_step_x(); 
48F4:  MOVLB  0
48F6:  RCALL  4596
....................             delay_us(2000); 
48F8:  MOVLW  02
48FA:  MOVLB  3
48FC:  MOVWF  xBE
48FE:  MOVLB  0
4900:  CALL   2064
4904:  MOVLB  3
4906:  INCF   xB0,F
4908:  BRA    48EE
....................         } 
.................... 	} 
....................     motor_pos_x = 0;    
490A:  MOVLB  1
490C:  CLRF   x13
490E:  CLRF   x12
....................     stop_x();			 
4910:  MOVLB  0
4912:  RCALL  45D8
4914:  GOTO   4D60 (RETURN)
.................... } 
.................... void  z_home() { 
.................... 	int i; 
.................... 	chopper_z(); 
*
4324:  BRA    3FCA
.................... 	delay_ms(50);	 
4326:  MOVLW  32
4328:  MOVLB  3
432A:  MOVWF  xBE
432C:  MOVLB  0
432E:  CALL   2064
.................... 	if(le_Input(S_Z_TOP) == true) { 
4332:  MOVLW  0D
4334:  MOVLB  3
4336:  MOVWF  xB2
4338:  MOVLB  0
433A:  RCALL  4090
433C:  DECFSZ 01,W
433E:  BRA    43C0
.................... 		desce(); 
4340:  RCALL  42CC
.................... 		delay_ms(50); 
4342:  MOVLW  32
4344:  MOVLB  3
4346:  MOVWF  xBE
4348:  MOVLB  0
434A:  CALL   2064
....................         for(i=0;i<=50;i++){ 
434E:  MOVLB  3
4350:  CLRF   xB0
4352:  MOVF   xB0,W
4354:  SUBLW  32
4356:  BNC   436E
....................             one_step_z(); 
4358:  MOVLB  0
435A:  RCALL  42DA
....................             delay_us(2000); 
435C:  MOVLW  02
435E:  MOVLB  3
4360:  MOVWF  xBE
4362:  MOVLB  0
4364:  CALL   2064
4368:  MOVLB  3
436A:  INCF   xB0,F
436C:  BRA    4352
....................         } 
....................         sobe(); 
436E:  MOVLB  0
4370:  RCALL  430E
....................         delay_ms(50); 
4372:  MOVLW  32
4374:  MOVLB  3
4376:  MOVWF  xBE
4378:  MOVLB  0
437A:  CALL   2064
....................         while(le_Input(S_Z_TOP) == false) {				 
437E:  MOVLW  0D
4380:  MOVLB  3
4382:  MOVWF  xB2
4384:  MOVLB  0
4386:  RCALL  4090
4388:  MOVF   01,F
438A:  BNZ   439C
....................             one_step_z(); 
438C:  RCALL  42DA
....................             delay_us(2000); 
438E:  MOVLW  02
4390:  MOVLB  3
4392:  MOVWF  xBE
4394:  MOVLB  0
4396:  CALL   2064
439A:  BRA    437E
....................         }				 
....................         for(i=0;i<=18;i++){ 
439C:  MOVLB  3
439E:  CLRF   xB0
43A0:  MOVF   xB0,W
43A2:  SUBLW  12
43A4:  BNC   43BC
....................             one_step_z(); 
43A6:  MOVLB  0
43A8:  RCALL  42DA
....................             delay_us(2000); 
43AA:  MOVLW  02
43AC:  MOVLB  3
43AE:  MOVWF  xBE
43B0:  MOVLB  0
43B2:  CALL   2064
43B6:  MOVLB  3
43B8:  INCF   xB0,F
43BA:  BRA    43A0
....................         } 
.................... 	}else{ 
43BC:  BRA    440C
43BE:  MOVLB  0
....................         sobe(); 
43C0:  RCALL  430E
....................         delay_ms(50); 
43C2:  MOVLW  32
43C4:  MOVLB  3
43C6:  MOVWF  xBE
43C8:  MOVLB  0
43CA:  CALL   2064
....................         while(le_Input(S_Z_TOP) == false) { 
43CE:  MOVLW  0D
43D0:  MOVLB  3
43D2:  MOVWF  xB2
43D4:  MOVLB  0
43D6:  RCALL  4090
43D8:  MOVF   01,F
43DA:  BNZ   43EC
....................             one_step_z(); 
43DC:  RCALL  42DA
....................             delay_us(2000); 
43DE:  MOVLW  02
43E0:  MOVLB  3
43E2:  MOVWF  xBE
43E4:  MOVLB  0
43E6:  CALL   2064
43EA:  BRA    43CE
....................         } 
....................         for(i=0;i<=18;i++) { 
43EC:  MOVLB  3
43EE:  CLRF   xB0
43F0:  MOVF   xB0,W
43F2:  SUBLW  12
43F4:  BNC   440C
....................             one_step_z(); 
43F6:  MOVLB  0
43F8:  RCALL  42DA
....................             delay_us(2000); 
43FA:  MOVLW  02
43FC:  MOVLB  3
43FE:  MOVWF  xBE
4400:  MOVLB  0
4402:  CALL   2064
4406:  MOVLB  3
4408:  INCF   xB0,F
440A:  BRA    43F0
....................         } 
.................... 	} 
....................     motor_pos_z = 0;    
440C:  MOVLB  1
440E:  CLRF   x19
4410:  CLRF   x18
.................... 	stop_z();			 
4412:  MOVLB  0
4414:  BRA    431C
4416:  GOTO   4D2A (RETURN)
.................... } 
....................  
.................... void posicao_maquina_1_default(void) { 
*
4CF0:  CALL   3B14
4CF4:  MOVFF  01,3AD
....................     int posicao_outra_maquina = le_posicao_outra_maquina(); 
....................     while (posicao_outra_maquina != HOME1){ 
4CF8:  MOVLB  3
4CFA:  DECFSZ xAD,W
4CFC:  BRA    4D00
4CFE:  BRA    4D16
....................         tela_esperando_mov_outra_maquina(HOME1); 
4D00:  MOVLW  01
4D02:  MOVWF  xB0
4D04:  MOVLB  0
4D06:  GOTO   3C08
....................         posicao_outra_maquina = le_posicao_outra_maquina(); 
4D0A:  CALL   3B14
4D0E:  MOVFF  01,3AD
4D12:  BRA    4CF8
4D14:  MOVLB  3
....................     } 
....................     tela_movimentando_maquina(ALIMENTADOR); 
4D16:  CLRF   xB0
4D18:  MOVLB  0
4D1A:  CALL   3E12
....................     long int i = 0; 
4D1E:  MOVLB  3
4D20:  CLRF   xAF
4D22:  CLRF   xAE
....................     z_home(); 
4D24:  MOVLB  0
4D26:  GOTO   4324
....................     if (le_Input(S_Y_ATRAS) == true) { 
4D2A:  MOVLW  08
4D2C:  MOVLB  3
4D2E:  MOVWF  xB2
4D30:  MOVLB  0
4D32:  CALL   4090
4D36:  DECFSZ 01,W
4D38:  BRA    4D44
....................         y_home_atras(); 
4D3A:  GOTO   4472
....................         x_home_esquerda(); 
4D3E:  RCALL  45DE
....................         y_home_frente(); 
4D40:  RCALL  46F0
....................          
....................     } else { 
4D42:  BRA    4D5E
....................         if (le_Input(S_Y_FRENTE) == true) { 
4D44:  MOVLW  07
4D46:  MOVLB  3
4D48:  MOVWF  xB2
4D4A:  MOVLB  0
4D4C:  CALL   4090
4D50:  DECFSZ 01,W
4D52:  BRA    4D5A
....................  
....................             y_home_frente(); 
4D54:  RCALL  46F0
....................             x_home_esquerda(); 
4D56:  RCALL  45DE
....................         } else { 
4D58:  BRA    4D5E
....................             x_home_esquerda(); 
4D5A:  RCALL  45DE
....................             y_home_frente(); 
4D5C:  RCALL  46F0
....................         } 
....................     } 
....................     x_home_direita(); 
4D5E:  BRA    4802
....................     flip_home(); 
4D60:  RCALL  4970
....................     chopper_y(); 
4D62:  CALL   441A
....................     frente(); 
4D66:  CALL   4420
....................     delay_ms(50); 
4D6A:  MOVLW  32
4D6C:  MOVLB  3
4D6E:  MOVWF  xBE
4D70:  MOVLB  0
4D72:  CALL   2064
....................     for (i = 0; i < 700; i++) { 
4D76:  MOVLB  3
4D78:  CLRF   xAF
4D7A:  CLRF   xAE
4D7C:  MOVF   xAF,W
4D7E:  SUBLW  02
4D80:  BNC   4DA6
4D82:  BNZ   4D8A
4D84:  MOVF   xAE,W
4D86:  SUBLW  BB
4D88:  BNC   4DA6
....................         one_step_y(); 
4D8A:  MOVLB  0
4D8C:  CALL   442A
....................         delay_us(2000); 
4D90:  MOVLW  02
4D92:  MOVLB  3
4D94:  MOVWF  xBE
4D96:  MOVLB  0
4D98:  CALL   2064
4D9C:  MOVLB  3
4D9E:  INCF   xAE,F
4DA0:  BTFSC  FD8.2
4DA2:  INCF   xAF,F
4DA4:  BRA    4D7C
....................     } 
....................     chopper_x(); 
4DA6:  MOVLB  0
4DA8:  CALL   4586
....................     esquerda(); 
4DAC:  RCALL  45CE
....................     delay_ms(50);     
4DAE:  MOVLW  32
4DB0:  MOVLB  3
4DB2:  MOVWF  xBE
4DB4:  MOVLB  0
4DB6:  CALL   2064
....................     motor_pos_x = 0x0000; 
4DBA:  MOVLB  1
4DBC:  CLRF   x13
4DBE:  CLRF   x12
....................     motor_pos_y = 0x0000; 
4DC0:  CLRF   x15
4DC2:  CLRF   x14
....................     contador_step_flip = 0x0000; 
4DC4:  CLRF   x17
4DC6:  CLRF   x16
....................     motor_pos_z = 0x0000; 
4DC8:  CLRF   x19
4DCA:  CLRF   x18
....................     motor_run_x(50, 19); 
4DCC:  MOVLB  3
4DCE:  CLRF   xB7
4DD0:  CLRF   xB6
4DD2:  CLRF   xB5
4DD4:  MOVLW  32
4DD6:  MOVWF  xB4
4DD8:  MOVLW  13
4DDA:  MOVWF  xB8
4DDC:  MOVLB  0
4DDE:  RCALL  4AB2
....................     posicao_atual = ALIMENTADOR; 
4DE0:  CLRF   25
....................     envia_posicao_para_outra_maquina(ALIMENTADOR); 
4DE2:  MOVLB  3
4DE4:  CLRF   xB0
4DE6:  MOVLB  0
4DE8:  RCALL  4C24
4DEA:  RETURN 0
.................... } 
.................... void envia_maquina_para_posicao(int posicao_futura){ 
....................     motor_run_z(0, 19); 
*
5A14:  MOVLB  3
5A16:  CLRF   xB7
5A18:  CLRF   xB6
5A1A:  CLRF   xB5
5A1C:  CLRF   xB4
5A1E:  MOVLW  13
5A20:  MOVWF  xB8
5A22:  MOVLB  0
5A24:  RCALL  5638
....................     while ((run_flg_z)); 
5A26:  MOVLB  3
5A28:  BTFSC  x9B.0
5A2A:  BRA    5A28
....................     switch (posicao_futura){ 
5A2C:  MOVF   xAF,W
5A2E:  ADDLW  F8
5A30:  BTFSC  FD8.0
5A32:  GOTO   6392
5A36:  ADDLW  08
5A38:  MOVLB  0
5A3A:  GOTO   6396
....................         case ALIMENTADOR: 
....................             if(posicao_atual != ALIMENTADOR){ 
5A3E:  MOVF   25,F
5A40:  BZ    5ADA
....................                 while (posicao_atual != HOME1){ 
5A42:  DECFSZ 25,W
5A44:  BRA    5A48
5A46:  BRA    5A4C
....................                     tela_esperando_mov_maquina();                 
5A48:  RCALL  5792
5A4A:  BRA    5A42
....................                 } 
....................                 posicao_outra_maquina = le_posicao_outra_maquina(); 
5A4C:  CALL   3B14
5A50:  MOVFF  01,27
....................                 while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)||(posicao_outra_maquina == ALIMENTADOR)){ 
5A54:  MOVF   27,W
5A56:  SUBLW  06
5A58:  BZ    5A64
5A5A:  MOVF   27,W
5A5C:  SUBLW  07
5A5E:  BZ    5A64
5A60:  MOVF   27,F
5A62:  BNZ   5A70
....................                     tela_esperando_sair_posicao_outra_maquina(); 
5A64:  RCALL  57C4
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
5A66:  CALL   3B14
5A6A:  MOVFF  01,27
5A6E:  BRA    5A54
....................                 } 
....................                 tela_movimentando_maquina(ALIMENTADOR); 
5A70:  MOVLB  3
5A72:  CLRF   xB0
5A74:  MOVLB  0
5A76:  CALL   3E12
....................                 motor_run_x(0, 19); 
5A7A:  MOVLB  3
5A7C:  CLRF   xB7
5A7E:  CLRF   xB6
5A80:  CLRF   xB5
5A82:  CLRF   xB4
5A84:  MOVLW  13
5A86:  MOVWF  xB8
5A88:  MOVLB  0
5A8A:  CALL   4AB2
....................                 while ((run_flg_x)); 
5A8E:  MOVLB  1
5A90:  BTFSC  x1A.3
5A92:  BRA    5A90
....................                 flip_home(); 
5A94:  MOVLB  0
5A96:  CALL   4970
....................                 motor_run_y(0, 19); 
5A9A:  MOVLB  3
5A9C:  CLRF   xB7
5A9E:  CLRF   xB6
5AA0:  CLRF   xB5
5AA2:  CLRF   xB4
5AA4:  MOVLW  13
5AA6:  MOVWF  xB8
5AA8:  MOVLB  0
5AAA:  RCALL  5802
....................                 motor_run_x(50, 19); 
5AAC:  MOVLB  3
5AAE:  CLRF   xB7
5AB0:  CLRF   xB6
5AB2:  CLRF   xB5
5AB4:  MOVLW  32
5AB6:  MOVWF  xB4
5AB8:  MOVLW  13
5ABA:  MOVWF  xB8
5ABC:  MOVLB  0
5ABE:  CALL   4AB2
....................                 while ((run_flg_x || run_flg_y)); 
5AC2:  MOVLB  1
5AC4:  BTFSC  x1A.3
5AC6:  BRA    5AC4
5AC8:  BTFSC  x1A.5
5ACA:  BRA    5AC4
....................                 envia_posicao_para_outra_maquina(ALIMENTADOR); 
5ACC:  MOVLB  3
5ACE:  CLRF   xB0
5AD0:  MOVLB  0
5AD2:  CALL   4C24
....................                 posicao_atual = ALIMENTADOR; 
5AD6:  CLRF   25
....................             } else { 
5AD8:  BRA    5AF2
....................                 delay_ms(300); 
5ADA:  MOVLW  02
5ADC:  MOVLB  3
5ADE:  MOVWF  xB0
5AE0:  MOVLW  96
5AE2:  MOVWF  xBE
5AE4:  MOVLB  0
5AE6:  CALL   2064
5AEA:  MOVLB  3
5AEC:  DECFSZ xB0,F
5AEE:  BRA    5AE0
5AF0:  MOVLB  0
....................             } 
....................         break; 
5AF2:  MOVLB  3
5AF4:  GOTO   6392
....................         case HOME1: 
....................             if(posicao_atual != HOME1){             
5AF8:  DECFSZ 25,W
5AFA:  BRA    5AFE
5AFC:  BRA    5DBA
....................                 while (posicao_atual == DISPENSADOR){ 
5AFE:  MOVF   25,W
5B00:  SUBLW  05
5B02:  BNZ   5B08
....................                     tela_esperando_mov_maquina();                 
5B04:  RCALL  5792
5B06:  BRA    5AFE
....................                 } 
....................                 if (posicao_atual == SOLDAGEM){ 
5B08:  MOVF   25,W
5B0A:  SUBLW  03
5B0C:  BNZ   5B7E
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
5B0E:  CALL   3B14
5B12:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
5B16:  MOVF   27,W
5B18:  SUBLW  06
5B1A:  BZ    5B22
5B1C:  MOVF   27,W
5B1E:  SUBLW  07
5B20:  BNZ   5B2E
....................                         tela_esperando_sair_posicao_outra_maquina(); 
5B22:  RCALL  57C4
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
5B24:  CALL   3B14
5B28:  MOVFF  01,27
5B2C:  BRA    5B16
....................                     } 
....................                     tela_movimentando_maquina(HOME1); 
5B2E:  MOVLW  01
5B30:  MOVLB  3
5B32:  MOVWF  xB0
5B34:  MOVLB  0
5B36:  CALL   3E12
....................                     motor_run_y(800, 19); 
5B3A:  MOVLB  3
5B3C:  CLRF   xB7
5B3E:  CLRF   xB6
5B40:  MOVLW  03
5B42:  MOVWF  xB5
5B44:  MOVLW  20
5B46:  MOVWF  xB4
5B48:  MOVLW  13
5B4A:  MOVWF  xB8
5B4C:  MOVLB  0
5B4E:  RCALL  5802
....................                     motor_run_x(4250, 19); 
5B50:  MOVLB  3
5B52:  CLRF   xB7
5B54:  CLRF   xB6
5B56:  MOVLW  10
5B58:  MOVWF  xB5
5B5A:  MOVLW  9A
5B5C:  MOVWF  xB4
5B5E:  MOVLW  13
5B60:  MOVWF  xB8
5B62:  MOVLB  0
5B64:  CALL   4AB2
....................                     while ((run_flg_x || run_flg_y)); 
5B68:  MOVLB  1
5B6A:  BTFSC  x1A.3
5B6C:  BRA    5B6A
5B6E:  BTFSC  x1A.5
5B70:  BRA    5B6A
....................                     envia_posicao_para_outra_maquina(HOME1);                    
5B72:  MOVLW  01
5B74:  MOVLB  3
5B76:  MOVWF  xB0
5B78:  MOVLB  0
5B7A:  CALL   4C24
....................                 } 
....................                 if (posicao_atual == HOME2){ 
5B7E:  MOVF   25,W
5B80:  SUBLW  04
5B82:  BNZ   5C04
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
5B84:  MOVF   27,W
5B86:  SUBLW  06
5B88:  BZ    5B90
5B8A:  MOVF   27,W
5B8C:  SUBLW  07
5B8E:  BNZ   5B9C
....................                         tela_esperando_sair_posicao_outra_maquina(); 
5B90:  RCALL  57C4
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
5B92:  CALL   3B14
5B96:  MOVFF  01,27
5B9A:  BRA    5B84
....................                     } 
....................                     tela_movimentando_maquina(HOME1); 
5B9C:  MOVLW  01
5B9E:  MOVLB  3
5BA0:  MOVWF  xB0
5BA2:  MOVLB  0
5BA4:  CALL   3E12
....................                     motor_run_x(3835, 19); 
5BA8:  MOVLB  3
5BAA:  CLRF   xB7
5BAC:  CLRF   xB6
5BAE:  MOVLW  0E
5BB0:  MOVWF  xB5
5BB2:  MOVLW  FB
5BB4:  MOVWF  xB4
5BB6:  MOVLW  13
5BB8:  MOVWF  xB8
5BBA:  MOVLB  0
5BBC:  CALL   4AB2
....................                     motor_run_y(800, 19); 
5BC0:  MOVLB  3
5BC2:  CLRF   xB7
5BC4:  CLRF   xB6
5BC6:  MOVLW  03
5BC8:  MOVWF  xB5
5BCA:  MOVLW  20
5BCC:  MOVWF  xB4
5BCE:  MOVLW  13
5BD0:  MOVWF  xB8
5BD2:  MOVLB  0
5BD4:  RCALL  5802
....................                     motor_run_x(4250, 19); 
5BD6:  MOVLB  3
5BD8:  CLRF   xB7
5BDA:  CLRF   xB6
5BDC:  MOVLW  10
5BDE:  MOVWF  xB5
5BE0:  MOVLW  9A
5BE2:  MOVWF  xB4
5BE4:  MOVLW  13
5BE6:  MOVWF  xB8
5BE8:  MOVLB  0
5BEA:  CALL   4AB2
....................                     while ((run_flg_x || run_flg_y)); 
5BEE:  MOVLB  1
5BF0:  BTFSC  x1A.3
5BF2:  BRA    5BF0
5BF4:  BTFSC  x1A.5
5BF6:  BRA    5BF0
....................                     envia_posicao_para_outra_maquina(HOME1);                    
5BF8:  MOVLW  01
5BFA:  MOVLB  3
5BFC:  MOVWF  xB0
5BFE:  MOVLB  0
5C00:  CALL   4C24
....................                 } 
....................                 if (posicao_atual == ALIMENTADOR){ 
5C04:  MOVF   25,F
5C06:  BNZ   5C80
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
5C08:  MOVF   27,W
5C0A:  SUBLW  06
5C0C:  BZ    5C14
5C0E:  MOVF   27,W
5C10:  SUBLW  07
5C12:  BNZ   5C20
....................                         tela_esperando_sair_posicao_outra_maquina(); 
5C14:  RCALL  57C4
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
5C16:  CALL   3B14
5C1A:  MOVFF  01,27
5C1E:  BRA    5C08
....................                     } 
....................                     tela_movimentando_maquina(HOME1); 
5C20:  MOVLW  01
5C22:  MOVLB  3
5C24:  MOVWF  xB0
5C26:  MOVLB  0
5C28:  CALL   3E12
....................                     motor_run_y(800, 19); 
5C2C:  MOVLB  3
5C2E:  CLRF   xB7
5C30:  CLRF   xB6
5C32:  MOVLW  03
5C34:  MOVWF  xB5
5C36:  MOVLW  20
5C38:  MOVWF  xB4
5C3A:  MOVLW  13
5C3C:  MOVWF  xB8
5C3E:  MOVLB  0
5C40:  RCALL  5802
....................                     while ((run_flg_y)); 
5C42:  MOVLB  1
5C44:  BTFSC  x1A.5
5C46:  BRA    5C44
....................                     go_flip(1866); 
5C48:  MOVLW  07
5C4A:  MOVLB  3
5C4C:  MOVWF  xB1
5C4E:  MOVLW  4A
5C50:  MOVWF  xB0
5C52:  MOVLB  0
5C54:  RCALL  59A0
....................                     motor_run_x(4250, 19); 
5C56:  MOVLB  3
5C58:  CLRF   xB7
5C5A:  CLRF   xB6
5C5C:  MOVLW  10
5C5E:  MOVWF  xB5
5C60:  MOVLW  9A
5C62:  MOVWF  xB4
5C64:  MOVLW  13
5C66:  MOVWF  xB8
5C68:  MOVLB  0
5C6A:  CALL   4AB2
....................                     while ((run_flg_x)); 
5C6E:  MOVLB  1
5C70:  BTFSC  x1A.3
5C72:  BRA    5C70
....................                     envia_posicao_para_outra_maquina(HOME1);                    
5C74:  MOVLW  01
5C76:  MOVLB  3
5C78:  MOVWF  xB0
5C7A:  MOVLB  0
5C7C:  CALL   4C24
....................                 } 
....................                 if (posicao_atual == LIMPEZA){ 
5C80:  MOVF   25,W
5C82:  SUBLW  06
5C84:  BNZ   5D1A
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
5C86:  MOVF   27,W
5C88:  SUBLW  06
5C8A:  BZ    5C92
5C8C:  MOVF   27,W
5C8E:  SUBLW  07
5C90:  BNZ   5C9E
....................                         tela_esperando_sair_posicao_outra_maquina(); 
5C92:  RCALL  57C4
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
5C94:  CALL   3B14
5C98:  MOVFF  01,27
5C9C:  BRA    5C86
....................                     } 
....................                     tela_movimentando_maquina(HOME1); 
5C9E:  MOVLW  01
5CA0:  MOVLB  3
5CA2:  MOVWF  xB0
5CA4:  MOVLB  0
5CA6:  CALL   3E12
....................                     motor_run_x(3825, 19); 
5CAA:  MOVLB  3
5CAC:  CLRF   xB7
5CAE:  CLRF   xB6
5CB0:  MOVLW  0E
5CB2:  MOVWF  xB5
5CB4:  MOVLW  F1
5CB6:  MOVWF  xB4
5CB8:  MOVLW  13
5CBA:  MOVWF  xB8
5CBC:  MOVLB  0
5CBE:  CALL   4AB2
....................                     while ((run_flg_x)); 
5CC2:  MOVLB  1
5CC4:  BTFSC  x1A.3
5CC6:  BRA    5CC4
....................                     go_flip(1866); 
5CC8:  MOVLW  07
5CCA:  MOVLB  3
5CCC:  MOVWF  xB1
5CCE:  MOVLW  4A
5CD0:  MOVWF  xB0
5CD2:  MOVLB  0
5CD4:  RCALL  59A0
....................                     motor_run_y(800, 19); 
5CD6:  MOVLB  3
5CD8:  CLRF   xB7
5CDA:  CLRF   xB6
5CDC:  MOVLW  03
5CDE:  MOVWF  xB5
5CE0:  MOVLW  20
5CE2:  MOVWF  xB4
5CE4:  MOVLW  13
5CE6:  MOVWF  xB8
5CE8:  MOVLB  0
5CEA:  RCALL  5802
....................                     motor_run_x(4250, 19); 
5CEC:  MOVLB  3
5CEE:  CLRF   xB7
5CF0:  CLRF   xB6
5CF2:  MOVLW  10
5CF4:  MOVWF  xB5
5CF6:  MOVLW  9A
5CF8:  MOVWF  xB4
5CFA:  MOVLW  13
5CFC:  MOVWF  xB8
5CFE:  MOVLB  0
5D00:  CALL   4AB2
....................                     while ((run_flg_x || run_flg_y)); 
5D04:  MOVLB  1
5D06:  BTFSC  x1A.3
5D08:  BRA    5D06
5D0A:  BTFSC  x1A.5
5D0C:  BRA    5D06
....................                     envia_posicao_para_outra_maquina(HOME1);                    
5D0E:  MOVLW  01
5D10:  MOVLB  3
5D12:  MOVWF  xB0
5D14:  MOVLB  0
5D16:  CALL   4C24
....................                 } 
....................                 if (posicao_atual == LIMPEZA_2){ 
5D1A:  MOVF   25,W
5D1C:  SUBLW  07
5D1E:  BNZ   5DB4
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
5D20:  MOVF   27,W
5D22:  SUBLW  06
5D24:  BZ    5D2C
5D26:  MOVF   27,W
5D28:  SUBLW  07
5D2A:  BNZ   5D38
....................                         tela_esperando_sair_posicao_outra_maquina(); 
5D2C:  RCALL  57C4
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
5D2E:  CALL   3B14
5D32:  MOVFF  01,27
5D36:  BRA    5D20
....................                     } 
....................                     tela_movimentando_maquina(HOME1); 
5D38:  MOVLW  01
5D3A:  MOVLB  3
5D3C:  MOVWF  xB0
5D3E:  MOVLB  0
5D40:  CALL   3E12
....................                     motor_run_x(3825, 19); 
5D44:  MOVLB  3
5D46:  CLRF   xB7
5D48:  CLRF   xB6
5D4A:  MOVLW  0E
5D4C:  MOVWF  xB5
5D4E:  MOVLW  F1
5D50:  MOVWF  xB4
5D52:  MOVLW  13
5D54:  MOVWF  xB8
5D56:  MOVLB  0
5D58:  CALL   4AB2
....................                     while ((run_flg_x)); 
5D5C:  MOVLB  1
5D5E:  BTFSC  x1A.3
5D60:  BRA    5D5E
....................                     go_flip(1866); 
5D62:  MOVLW  07
5D64:  MOVLB  3
5D66:  MOVWF  xB1
5D68:  MOVLW  4A
5D6A:  MOVWF  xB0
5D6C:  MOVLB  0
5D6E:  RCALL  59A0
....................                     motor_run_y(800, 19); 
5D70:  MOVLB  3
5D72:  CLRF   xB7
5D74:  CLRF   xB6
5D76:  MOVLW  03
5D78:  MOVWF  xB5
5D7A:  MOVLW  20
5D7C:  MOVWF  xB4
5D7E:  MOVLW  13
5D80:  MOVWF  xB8
5D82:  MOVLB  0
5D84:  RCALL  5802
....................                     motor_run_x(4250, 19); 
5D86:  MOVLB  3
5D88:  CLRF   xB7
5D8A:  CLRF   xB6
5D8C:  MOVLW  10
5D8E:  MOVWF  xB5
5D90:  MOVLW  9A
5D92:  MOVWF  xB4
5D94:  MOVLW  13
5D96:  MOVWF  xB8
5D98:  MOVLB  0
5D9A:  CALL   4AB2
....................                     while ((run_flg_x || run_flg_y)); 
5D9E:  MOVLB  1
5DA0:  BTFSC  x1A.3
5DA2:  BRA    5DA0
5DA4:  BTFSC  x1A.5
5DA6:  BRA    5DA0
....................                     envia_posicao_para_outra_maquina(HOME1);                    
5DA8:  MOVLW  01
5DAA:  MOVLB  3
5DAC:  MOVWF  xB0
5DAE:  MOVLB  0
5DB0:  CALL   4C24
....................                 } 
....................                 posicao_atual = HOME1; 
5DB4:  MOVLW  01
5DB6:  MOVWF  25
....................             }else { 
5DB8:  BRA    5DD2
....................                 delay_ms(300); 
5DBA:  MOVLW  02
5DBC:  MOVLB  3
5DBE:  MOVWF  xB0
5DC0:  MOVLW  96
5DC2:  MOVWF  xBE
5DC4:  MOVLB  0
5DC6:  CALL   2064
5DCA:  MOVLB  3
5DCC:  DECFSZ xB0,F
5DCE:  BRA    5DC0
5DD0:  MOVLB  0
....................             } 
....................         break; 
5DD2:  MOVLB  3
5DD4:  BRA    6392
....................         case SOLDAGEM: 
....................             if(posicao_atual != SOLDAGEM){ 
5DD6:  MOVF   25,W
5DD8:  SUBLW  03
5DDA:  BTFSC  FD8.2
5DDC:  BRA    5F06
....................                 while ((posicao_atual == DISPENSADOR)||(posicao_atual == HOME2)){ 
5DDE:  MOVF   25,W
5DE0:  SUBLW  05
5DE2:  BZ    5DEA
5DE4:  MOVF   25,W
5DE6:  SUBLW  04
5DE8:  BNZ   5DEE
....................                     tela_esperando_mov_maquina();                 
5DEA:  RCALL  5792
5DEC:  BRA    5DDE
....................                 } 
....................                 if (posicao_atual == HOME1){ 
5DEE:  DECFSZ 25,W
5DF0:  BRA    5E62
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
5DF2:  CALL   3B14
5DF6:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
5DFA:  MOVF   27,W
5DFC:  SUBLW  06
5DFE:  BZ    5E06
5E00:  MOVF   27,W
5E02:  SUBLW  07
5E04:  BNZ   5E12
....................                         tela_esperando_sair_posicao_outra_maquina(); 
5E06:  RCALL  57C4
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
5E08:  CALL   3B14
5E0C:  MOVFF  01,27
5E10:  BRA    5DFA
....................                     } 
....................                     tela_movimentando_maquina(SOLDAGEM); 
5E12:  MOVLW  03
5E14:  MOVLB  3
5E16:  MOVWF  xB0
5E18:  MOVLB  0
5E1A:  CALL   3E12
....................                     motor_run_x(3835, 19); 
5E1E:  MOVLB  3
5E20:  CLRF   xB7
5E22:  CLRF   xB6
5E24:  MOVLW  0E
5E26:  MOVWF  xB5
5E28:  MOVLW  FB
5E2A:  MOVWF  xB4
5E2C:  MOVLW  13
5E2E:  MOVWF  xB8
5E30:  MOVLB  0
5E32:  CALL   4AB2
....................                     motor_run_y(2540, 19); 
5E36:  MOVLB  3
5E38:  CLRF   xB7
5E3A:  CLRF   xB6
5E3C:  MOVLW  09
5E3E:  MOVWF  xB5
5E40:  MOVLW  EC
5E42:  MOVWF  xB4
5E44:  MOVLW  13
5E46:  MOVWF  xB8
5E48:  MOVLB  0
5E4A:  RCALL  5802
....................                     while ((run_flg_x || run_flg_y)); 
5E4C:  MOVLB  1
5E4E:  BTFSC  x1A.3
5E50:  BRA    5E4E
5E52:  BTFSC  x1A.5
5E54:  BRA    5E4E
....................                     envia_posicao_para_outra_maquina(SOLDAGEM);                    
5E56:  MOVLW  03
5E58:  MOVLB  3
5E5A:  MOVWF  xB0
5E5C:  MOVLB  0
5E5E:  CALL   4C24
....................                 } 
....................                 if (posicao_atual == ALIMENTADOR){ 
5E62:  MOVF   25,F
5E64:  BNZ   5F00
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
5E66:  CALL   3B14
5E6A:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
5E6E:  MOVF   27,W
5E70:  SUBLW  06
5E72:  BZ    5E7A
5E74:  MOVF   27,W
5E76:  SUBLW  07
5E78:  BNZ   5E86
....................                         tela_esperando_sair_posicao_outra_maquina(); 
5E7A:  RCALL  57C4
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
5E7C:  CALL   3B14
5E80:  MOVFF  01,27
5E84:  BRA    5E6E
....................                     } 
....................                     tela_movimentando_maquina(SOLDAGEM); 
5E86:  MOVLW  03
5E88:  MOVLB  3
5E8A:  MOVWF  xB0
5E8C:  MOVLB  0
5E8E:  CALL   3E12
....................                     motor_run_y(800, 19); 
5E92:  MOVLB  3
5E94:  CLRF   xB7
5E96:  CLRF   xB6
5E98:  MOVLW  03
5E9A:  MOVWF  xB5
5E9C:  MOVLW  20
5E9E:  MOVWF  xB4
5EA0:  MOVLW  13
5EA2:  MOVWF  xB8
5EA4:  MOVLB  0
5EA6:  RCALL  5802
....................                     while ((run_flg_y)); 
5EA8:  MOVLB  1
5EAA:  BTFSC  x1A.5
5EAC:  BRA    5EAA
....................                     go_flip(1866); 
5EAE:  MOVLW  07
5EB0:  MOVLB  3
5EB2:  MOVWF  xB1
5EB4:  MOVLW  4A
5EB6:  MOVWF  xB0
5EB8:  MOVLB  0
5EBA:  RCALL  59A0
....................                     motor_run_x(3835, 19); 
5EBC:  MOVLB  3
5EBE:  CLRF   xB7
5EC0:  CLRF   xB6
5EC2:  MOVLW  0E
5EC4:  MOVWF  xB5
5EC6:  MOVLW  FB
5EC8:  MOVWF  xB4
5ECA:  MOVLW  13
5ECC:  MOVWF  xB8
5ECE:  MOVLB  0
5ED0:  CALL   4AB2
....................                     motor_run_y(2540, 19); 
5ED4:  MOVLB  3
5ED6:  CLRF   xB7
5ED8:  CLRF   xB6
5EDA:  MOVLW  09
5EDC:  MOVWF  xB5
5EDE:  MOVLW  EC
5EE0:  MOVWF  xB4
5EE2:  MOVLW  13
5EE4:  MOVWF  xB8
5EE6:  MOVLB  0
5EE8:  RCALL  5802
....................                     while ((run_flg_x || run_flg_y)); 
5EEA:  MOVLB  1
5EEC:  BTFSC  x1A.3
5EEE:  BRA    5EEC
5EF0:  BTFSC  x1A.5
5EF2:  BRA    5EEC
....................                     envia_posicao_para_outra_maquina(SOLDAGEM);                    
5EF4:  MOVLW  03
5EF6:  MOVLB  3
5EF8:  MOVWF  xB0
5EFA:  MOVLB  0
5EFC:  CALL   4C24
....................                 } 
....................                 posicao_atual = SOLDAGEM; 
5F00:  MOVLW  03
5F02:  MOVWF  25
....................             } else { 
5F04:  BRA    5F1E
....................                 delay_ms(300); 
5F06:  MOVLW  02
5F08:  MOVLB  3
5F0A:  MOVWF  xB0
5F0C:  MOVLW  96
5F0E:  MOVWF  xBE
5F10:  MOVLB  0
5F12:  CALL   2064
5F16:  MOVLB  3
5F18:  DECFSZ xB0,F
5F1A:  BRA    5F0C
5F1C:  MOVLB  0
....................             } 
....................         break; 
5F1E:  MOVLB  3
5F20:  BRA    6392
....................         case HOME2: 
....................             if(posicao_atual != HOME2){ 
5F22:  MOVF   25,W
5F24:  SUBLW  04
5F26:  BTFSC  FD8.2
5F28:  BRA    60B2
....................                 while ((posicao_atual == ALIMENTADOR)||(posicao_atual == LIMPEZA)||(posicao_atual == LIMPEZA_2)){ 
5F2A:  MOVF   25,F
5F2C:  BZ    5F3A
5F2E:  MOVF   25,W
5F30:  SUBLW  06
5F32:  BZ    5F3A
5F34:  MOVF   25,W
5F36:  SUBLW  07
5F38:  BNZ   5F3E
....................                     tela_esperando_mov_maquina();                 
5F3A:  RCALL  5792
5F3C:  BRA    5F2A
....................                 } 
....................                 if (posicao_atual == DISPENSADOR){ 
5F3E:  MOVF   25,W
5F40:  SUBLW  05
5F42:  BNZ   5FB4
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
5F44:  CALL   3B14
5F48:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
5F4C:  MOVF   27,W
5F4E:  SUBLW  06
5F50:  BZ    5F58
5F52:  MOVF   27,W
5F54:  SUBLW  07
5F56:  BNZ   5F64
....................                         tela_esperando_sair_posicao_outra_maquina(); 
5F58:  RCALL  57C4
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
5F5A:  CALL   3B14
5F5E:  MOVFF  01,27
5F62:  BRA    5F4C
....................                     } 
....................                     tela_movimentando_maquina(HOME2); 
5F64:  MOVLW  04
5F66:  MOVLB  3
5F68:  MOVWF  xB0
5F6A:  MOVLB  0
5F6C:  CALL   3E12
....................                     motor_run_y(5540, 19); 
5F70:  MOVLB  3
5F72:  CLRF   xB7
5F74:  CLRF   xB6
5F76:  MOVLW  15
5F78:  MOVWF  xB5
5F7A:  MOVLW  A4
5F7C:  MOVWF  xB4
5F7E:  MOVLW  13
5F80:  MOVWF  xB8
5F82:  MOVLB  0
5F84:  RCALL  5802
....................                     motor_run_x(4250, 19); 
5F86:  MOVLB  3
5F88:  CLRF   xB7
5F8A:  CLRF   xB6
5F8C:  MOVLW  10
5F8E:  MOVWF  xB5
5F90:  MOVLW  9A
5F92:  MOVWF  xB4
5F94:  MOVLW  13
5F96:  MOVWF  xB8
5F98:  MOVLB  0
5F9A:  CALL   4AB2
....................                     while ((run_flg_x || run_flg_y)); 
5F9E:  MOVLB  1
5FA0:  BTFSC  x1A.3
5FA2:  BRA    5FA0
5FA4:  BTFSC  x1A.5
5FA6:  BRA    5FA0
....................                     envia_posicao_para_outra_maquina(HOME2);                    
5FA8:  MOVLW  04
5FAA:  MOVLB  3
5FAC:  MOVWF  xB0
5FAE:  MOVLB  0
5FB0:  CALL   4C24
....................                 } 
....................                 if (posicao_atual == SOLDAGEM){ 
5FB4:  MOVF   25,W
5FB6:  SUBLW  03
5FB8:  BNZ   6024
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
5FBA:  MOVF   27,W
5FBC:  SUBLW  06
5FBE:  BZ    5FC6
5FC0:  MOVF   27,W
5FC2:  SUBLW  07
5FC4:  BNZ   5FD4
....................                         tela_esperando_sair_posicao_outra_maquina(); 
5FC6:  CALL   57C4
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
5FCA:  CALL   3B14
5FCE:  MOVFF  01,27
5FD2:  BRA    5FBA
....................                     } 
....................                     tela_movimentando_maquina(HOME2); 
5FD4:  MOVLW  04
5FD6:  MOVLB  3
5FD8:  MOVWF  xB0
5FDA:  MOVLB  0
5FDC:  CALL   3E12
....................                     motor_run_y(5540, 19); 
5FE0:  MOVLB  3
5FE2:  CLRF   xB7
5FE4:  CLRF   xB6
5FE6:  MOVLW  15
5FE8:  MOVWF  xB5
5FEA:  MOVLW  A4
5FEC:  MOVWF  xB4
5FEE:  MOVLW  13
5FF0:  MOVWF  xB8
5FF2:  MOVLB  0
5FF4:  RCALL  5802
....................                     motor_run_x(4250, 19); 
5FF6:  MOVLB  3
5FF8:  CLRF   xB7
5FFA:  CLRF   xB6
5FFC:  MOVLW  10
5FFE:  MOVWF  xB5
6000:  MOVLW  9A
6002:  MOVWF  xB4
6004:  MOVLW  13
6006:  MOVWF  xB8
6008:  MOVLB  0
600A:  CALL   4AB2
....................                     while ((run_flg_x || run_flg_y)); 
600E:  MOVLB  1
6010:  BTFSC  x1A.3
6012:  BRA    6010
6014:  BTFSC  x1A.5
6016:  BRA    6010
....................                     envia_posicao_para_outra_maquina(HOME2);                    
6018:  MOVLW  04
601A:  MOVLB  3
601C:  MOVWF  xB0
601E:  MOVLB  0
6020:  CALL   4C24
....................                 } 
....................                 if (posicao_atual == HOME1){ 
6024:  DECFSZ 25,W
6026:  BRA    60AC
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
6028:  MOVF   27,W
602A:  SUBLW  06
602C:  BZ    6034
602E:  MOVF   27,W
6030:  SUBLW  07
6032:  BNZ   6042
....................                         tela_esperando_sair_posicao_outra_maquina(); 
6034:  CALL   57C4
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
6038:  CALL   3B14
603C:  MOVFF  01,27
6040:  BRA    6028
....................                     } 
....................                     tela_movimentando_maquina(HOME2); 
6042:  MOVLW  04
6044:  MOVLB  3
6046:  MOVWF  xB0
6048:  MOVLB  0
604A:  CALL   3E12
....................                     motor_run_x(3835, 19); 
604E:  MOVLB  3
6050:  CLRF   xB7
6052:  CLRF   xB6
6054:  MOVLW  0E
6056:  MOVWF  xB5
6058:  MOVLW  FB
605A:  MOVWF  xB4
605C:  MOVLW  13
605E:  MOVWF  xB8
6060:  MOVLB  0
6062:  CALL   4AB2
....................                     motor_run_y(5540, 19); 
6066:  MOVLB  3
6068:  CLRF   xB7
606A:  CLRF   xB6
606C:  MOVLW  15
606E:  MOVWF  xB5
6070:  MOVLW  A4
6072:  MOVWF  xB4
6074:  MOVLW  13
6076:  MOVWF  xB8
6078:  MOVLB  0
607A:  CALL   5802
....................                     motor_run_x(4250, 19); 
607E:  MOVLB  3
6080:  CLRF   xB7
6082:  CLRF   xB6
6084:  MOVLW  10
6086:  MOVWF  xB5
6088:  MOVLW  9A
608A:  MOVWF  xB4
608C:  MOVLW  13
608E:  MOVWF  xB8
6090:  MOVLB  0
6092:  CALL   4AB2
....................                     while ((run_flg_x || run_flg_y)); 
6096:  MOVLB  1
6098:  BTFSC  x1A.3
609A:  BRA    6098
609C:  BTFSC  x1A.5
609E:  BRA    6098
....................                     envia_posicao_para_outra_maquina(HOME2);                    
60A0:  MOVLW  04
60A2:  MOVLB  3
60A4:  MOVWF  xB0
60A6:  MOVLB  0
60A8:  CALL   4C24
....................                 } 
....................                 posicao_atual = HOME2; 
60AC:  MOVLW  04
60AE:  MOVWF  25
....................             }else { 
60B0:  BRA    60CA
....................                 delay_ms(300); 
60B2:  MOVLW  02
60B4:  MOVLB  3
60B6:  MOVWF  xB0
60B8:  MOVLW  96
60BA:  MOVWF  xBE
60BC:  MOVLB  0
60BE:  CALL   2064
60C2:  MOVLB  3
60C4:  DECFSZ xB0,F
60C6:  BRA    60B8
60C8:  MOVLB  0
....................             } 
....................         break; 
60CA:  MOVLB  3
60CC:  BRA    6392
....................         case DISPENSADOR: 
....................             if(posicao_atual != DISPENSADOR){ 
60CE:  MOVF   25,W
60D0:  SUBLW  05
60D2:  BZ    6162
....................                 while (posicao_atual != HOME2){ 
60D4:  MOVF   25,W
60D6:  SUBLW  04
60D8:  BZ    60E0
....................                     tela_esperando_mov_maquina();                 
60DA:  CALL   5792
60DE:  BRA    60D4
....................                 } 
....................                 if (posicao_atual == HOME2){ 
60E0:  MOVF   25,W
60E2:  SUBLW  04
60E4:  BNZ   615C
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
60E6:  CALL   3B14
60EA:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)||(posicao_outra_maquina == DISPENSADOR)){ 
60EE:  MOVF   27,W
60F0:  SUBLW  06
60F2:  BZ    6100
60F4:  MOVF   27,W
60F6:  SUBLW  07
60F8:  BZ    6100
60FA:  MOVF   27,W
60FC:  SUBLW  05
60FE:  BNZ   610E
....................                         tela_esperando_sair_posicao_outra_maquina(); 
6100:  CALL   57C4
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
6104:  CALL   3B14
6108:  MOVFF  01,27
610C:  BRA    60EE
....................                     } 
....................                     tela_movimentando_maquina(DISPENSADOR); 
610E:  MOVLW  05
6110:  MOVLB  3
6112:  MOVWF  xB0
6114:  MOVLB  0
6116:  CALL   3E12
....................                     motor_run_x(0, 19); 
611A:  MOVLB  3
611C:  CLRF   xB7
611E:  CLRF   xB6
6120:  CLRF   xB5
6122:  CLRF   xB4
6124:  MOVLW  13
6126:  MOVWF  xB8
6128:  MOVLB  0
612A:  CALL   4AB2
....................                     motor_run_y(6110, 19); 
612E:  MOVLB  3
6130:  CLRF   xB7
6132:  CLRF   xB6
6134:  MOVLW  17
6136:  MOVWF  xB5
6138:  MOVLW  DE
613A:  MOVWF  xB4
613C:  MOVLW  13
613E:  MOVWF  xB8
6140:  MOVLB  0
6142:  CALL   5802
....................                     while ((run_flg_x || run_flg_y)); 
6146:  MOVLB  1
6148:  BTFSC  x1A.3
614A:  BRA    6148
614C:  BTFSC  x1A.5
614E:  BRA    6148
....................                     envia_posicao_para_outra_maquina(DISPENSADOR);                    
6150:  MOVLW  05
6152:  MOVLB  3
6154:  MOVWF  xB0
6156:  MOVLB  0
6158:  CALL   4C24
....................                 } 
....................                 posicao_atual = DISPENSADOR; 
615C:  MOVLW  05
615E:  MOVWF  25
....................             }else { 
6160:  BRA    617A
....................                 delay_ms(300); 
6162:  MOVLW  02
6164:  MOVLB  3
6166:  MOVWF  xB0
6168:  MOVLW  96
616A:  MOVWF  xBE
616C:  MOVLB  0
616E:  CALL   2064
6172:  MOVLB  3
6174:  DECFSZ xB0,F
6176:  BRA    6168
6178:  MOVLB  0
....................             } 
....................         break; 
617A:  MOVLB  3
617C:  BRA    6392
....................         case LIMPEZA: 
....................             if(posicao_atual != LIMPEZA){ 
617E:  MOVF   25,W
6180:  SUBLW  06
6182:  BTFSC  FD8.2
6184:  BRA    62D2
....................                 while ((posicao_atual == DISPENSADOR)||(posicao_atual == SOLDAGEM)||(posicao_atual == HOME1)||(posicao_atual == ALIMENTADOR)){ 
6186:  MOVF   25,W
6188:  SUBLW  05
618A:  BZ    619C
618C:  MOVF   25,W
618E:  SUBLW  03
6190:  BZ    619C
6192:  DECFSZ 25,W
6194:  BRA    6198
6196:  BRA    619C
6198:  MOVF   25,F
619A:  BNZ   61A2
....................                     tela_esperando_mov_maquina();                 
619C:  CALL   5792
61A0:  BRA    6186
....................                 } 
....................                 if (posicao_atual == HOME2){ 
61A2:  MOVF   25,W
61A4:  SUBLW  04
61A6:  BNZ   625C
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
61A8:  CALL   3B14
61AC:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == ALIMENTADOR)||(posicao_outra_maquina == DISPENSADOR)||(posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)||(posicao_outra_maquina == SOLDAGEM)){ 
61B0:  MOVF   27,F
61B2:  BZ    61CC
61B4:  MOVF   27,W
61B6:  SUBLW  05
61B8:  BZ    61CC
61BA:  MOVF   27,W
61BC:  SUBLW  06
61BE:  BZ    61CC
61C0:  MOVF   27,W
61C2:  SUBLW  07
61C4:  BZ    61CC
61C6:  MOVF   27,W
61C8:  SUBLW  03
61CA:  BNZ   61E6
....................                         tela_esperando_sair_posicao_outra_maquina(); 
61CC:  CALL   57C4
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
61D0:  CALL   3B14
61D4:  MOVFF  01,27
....................                         envia_posicao_para_outra_maquina(LIMPEZA);  
61D8:  MOVLW  06
61DA:  MOVLB  3
61DC:  MOVWF  xB0
61DE:  MOVLB  0
61E0:  CALL   4C24
61E4:  BRA    61B0
....................                     } 
....................                     tela_movimentando_maquina(LIMPEZA); 
61E6:  MOVLW  06
61E8:  MOVLB  3
61EA:  MOVWF  xB0
61EC:  MOVLB  0
61EE:  CALL   3E12
....................                     motor_run_x(3835, 19); 
61F2:  MOVLB  3
61F4:  CLRF   xB7
61F6:  CLRF   xB6
61F8:  MOVLW  0E
61FA:  MOVWF  xB5
61FC:  MOVLW  FB
61FE:  MOVWF  xB4
6200:  MOVLW  13
6202:  MOVWF  xB8
6204:  MOVLB  0
6206:  CALL   4AB2
....................                     motor_run_y(2920, 19); 
620A:  MOVLB  3
620C:  CLRF   xB7
620E:  CLRF   xB6
6210:  MOVLW  0B
6212:  MOVWF  xB5
6214:  MOVLW  68
6216:  MOVWF  xB4
6218:  MOVLW  13
621A:  MOVWF  xB8
621C:  MOVLB  0
621E:  CALL   5802
....................                     while ((run_flg_x || run_flg_y)); 
6222:  MOVLB  1
6224:  BTFSC  x1A.3
6226:  BRA    6224
6228:  BTFSC  x1A.5
622A:  BRA    6224
....................                     go_flip(2000); 
622C:  MOVLW  07
622E:  MOVLB  3
6230:  MOVWF  xB1
6232:  MOVLW  D0
6234:  MOVWF  xB0
6236:  MOVLB  0
6238:  CALL   59A0
....................                     motor_run_x(1540, 19); 
623C:  MOVLB  3
623E:  CLRF   xB7
6240:  CLRF   xB6
6242:  MOVLW  06
6244:  MOVWF  xB5
6246:  MOVLW  04
6248:  MOVWF  xB4
624A:  MOVLW  13
624C:  MOVWF  xB8
624E:  MOVLB  0
6250:  CALL   4AB2
....................                     while ((run_flg_x)); 
6254:  MOVLB  1
6256:  BTFSC  x1A.3
6258:  BRA    6256
625A:  MOVLB  0
....................                 } 
....................                 if (posicao_atual == LIMPEZA_2){ 
625C:  MOVF   25,W
625E:  SUBLW  07
6260:  BNZ   62CC
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
6262:  CALL   3B14
6266:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == ALIMENTADOR)||(posicao_outra_maquina == DISPENSADOR)||(posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)||(posicao_outra_maquina == SOLDAGEM)){ 
626A:  MOVF   27,F
626C:  BZ    6286
626E:  MOVF   27,W
6270:  SUBLW  05
6272:  BZ    6286
6274:  MOVF   27,W
6276:  SUBLW  06
6278:  BZ    6286
627A:  MOVF   27,W
627C:  SUBLW  07
627E:  BZ    6286
6280:  MOVF   27,W
6282:  SUBLW  03
6284:  BNZ   62A0
....................                         tela_esperando_sair_posicao_outra_maquina(); 
6286:  CALL   57C4
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
628A:  CALL   3B14
628E:  MOVFF  01,27
....................                         envia_posicao_para_outra_maquina(LIMPEZA); 
6292:  MOVLW  06
6294:  MOVLB  3
6296:  MOVWF  xB0
6298:  MOVLB  0
629A:  CALL   4C24
629E:  BRA    626A
....................                     } 
....................                     tela_movimentando_maquina(LIMPEZA); 
62A0:  MOVLW  06
62A2:  MOVLB  3
62A4:  MOVWF  xB0
62A6:  MOVLB  0
62A8:  CALL   3E12
....................                     motor_run_x(1540, 19); 
62AC:  MOVLB  3
62AE:  CLRF   xB7
62B0:  CLRF   xB6
62B2:  MOVLW  06
62B4:  MOVWF  xB5
62B6:  MOVLW  04
62B8:  MOVWF  xB4
62BA:  MOVLW  13
62BC:  MOVWF  xB8
62BE:  MOVLB  0
62C0:  CALL   4AB2
....................                     while ((run_flg_x));                                  
62C4:  MOVLB  1
62C6:  BTFSC  x1A.3
62C8:  BRA    62C6
62CA:  MOVLB  0
....................                 } 
....................                 posicao_atual = LIMPEZA; 
62CC:  MOVLW  06
62CE:  MOVWF  25
....................             }else { 
62D0:  BRA    62EA
....................                 delay_ms(300); 
62D2:  MOVLW  02
62D4:  MOVLB  3
62D6:  MOVWF  xB0
62D8:  MOVLW  96
62DA:  MOVWF  xBE
62DC:  MOVLB  0
62DE:  CALL   2064
62E2:  MOVLB  3
62E4:  DECFSZ xB0,F
62E6:  BRA    62D8
62E8:  MOVLB  0
....................             } 
....................         break; 
62EA:  MOVLB  3
62EC:  BRA    6392
....................         case LIMPEZA_2: 
....................             if(posicao_atual != LIMPEZA_2){ 
62EE:  MOVF   25,W
62F0:  SUBLW  07
62F2:  BZ    6374
....................                 while (posicao_atual != LIMPEZA){ 
62F4:  MOVF   25,W
62F6:  SUBLW  06
62F8:  BZ    6300
....................                     tela_esperando_mov_maquina();                 
62FA:  CALL   5792
62FE:  BRA    62F4
....................                 } 
....................                 if (posicao_atual == LIMPEZA){ 
6300:  MOVF   25,W
6302:  SUBLW  06
6304:  BNZ   636E
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
6306:  CALL   3B14
630A:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == ALIMENTADOR)||(posicao_outra_maquina == DISPENSADOR)||(posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)||(posicao_outra_maquina == SOLDAGEM)){ 
630E:  MOVF   27,F
6310:  BZ    632A
6312:  MOVF   27,W
6314:  SUBLW  05
6316:  BZ    632A
6318:  MOVF   27,W
631A:  SUBLW  06
631C:  BZ    632A
631E:  MOVF   27,W
6320:  SUBLW  07
6322:  BZ    632A
6324:  MOVF   27,W
6326:  SUBLW  03
6328:  BNZ   6344
....................                         tela_esperando_sair_posicao_outra_maquina(); 
632A:  CALL   57C4
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
632E:  CALL   3B14
6332:  MOVFF  01,27
....................                         envia_posicao_para_outra_maquina(LIMPEZA_2);   
6336:  MOVLW  07
6338:  MOVLB  3
633A:  MOVWF  xB0
633C:  MOVLB  0
633E:  CALL   4C24
6342:  BRA    630E
....................                     } 
....................                     tela_movimentando_maquina(LIMPEZA_2); 
6344:  MOVLW  07
6346:  MOVLB  3
6348:  MOVWF  xB0
634A:  MOVLB  0
634C:  CALL   3E12
....................                     motor_run_x(50, 19); 
6350:  MOVLB  3
6352:  CLRF   xB7
6354:  CLRF   xB6
6356:  CLRF   xB5
6358:  MOVLW  32
635A:  MOVWF  xB4
635C:  MOVLW  13
635E:  MOVWF  xB8
6360:  MOVLB  0
6362:  CALL   4AB2
....................                     while ((run_flg_x));                                 
6366:  MOVLB  1
6368:  BTFSC  x1A.3
636A:  BRA    6368
636C:  MOVLB  0
....................                 } 
....................                 posicao_atual = LIMPEZA_2; 
636E:  MOVLW  07
6370:  MOVWF  25
....................             }else { 
6372:  BRA    638C
....................                 delay_ms(300); 
6374:  MOVLW  02
6376:  MOVLB  3
6378:  MOVWF  xB0
637A:  MOVLW  96
637C:  MOVWF  xBE
637E:  MOVLB  0
6380:  CALL   2064
6384:  MOVLB  3
6386:  DECFSZ xB0,F
6388:  BRA    637A
638A:  MOVLB  0
....................             } 
....................         break;         
638C:  MOVLB  3
638E:  BRA    6392
6390:  MOVLB  3
....................     } 
6392:  MOVLB  0
6394:  RETURN 0
.................... } 
....................  
.................... #include "maquinas_maq_1.c" 
.................... void liga_pressor (void){ 
....................     aciona_saida(PRESSOR); 
*
6516:  MOVLB  3
6518:  CLRF   xB8
651A:  MOVLW  04
651C:  MOVWF  xB7
651E:  MOVLB  0
6520:  CALL   2522
6524:  RETURN 0
.................... } 
.................... void desliga_pressor (void){ 
....................     desaciona_saida(PRESSOR); 
*
6AA8:  MOVLB  3
6AAA:  CLRF   xB8
6AAC:  MOVLW  04
6AAE:  MOVWF  xB7
6AB0:  MOVLB  0
6AB2:  CALL   24E0
6AB6:  RETURN 0
.................... } 
.................... void empurra_placa(void){ 
....................     short x; 
....................     short y; 
....................     aciona_saida(DEDO_ENTRADA); 
*
95B6:  MOVLB  3
95B8:  CLRF   xB8
95BA:  MOVLW  07
95BC:  MOVWF  xB7
95BE:  MOVLB  0
95C0:  CALL   2522
....................     aciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
95C4:  MOVLB  3
95C6:  CLRF   xB8
95C8:  MOVLW  06
95CA:  MOVWF  xB7
95CC:  MOVLB  0
95CE:  CALL   2522
....................     x = le_Input(S_EMPURRADOR_IN_LS1); 
95D2:  MOVLW  02
95D4:  MOVLB  3
95D6:  MOVWF  xB2
95D8:  MOVLB  0
95DA:  CALL   4090
95DE:  MOVLB  3
95E0:  BCF    xAF.0
95E2:  BTFSC  01.0
95E4:  BSF    xAF.0
....................     while (x == 0){ 
95E6:  BTFSC  xAF.0
95E8:  BRA    95FE
....................         x = le_Input(S_EMPURRADOR_IN_LS1); 
95EA:  MOVLW  02
95EC:  MOVWF  xB2
95EE:  MOVLB  0
95F0:  CALL   4090
95F4:  MOVLB  3
95F6:  BCF    xAF.0
95F8:  BTFSC  01.0
95FA:  BSF    xAF.0
95FC:  BRA    95E6
....................     } 
....................     desaciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
95FE:  CLRF   xB8
9600:  MOVLW  06
9602:  MOVWF  xB7
9604:  MOVLB  0
9606:  CALL   24E0
....................     aciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
960A:  MOVLB  3
960C:  CLRF   xB8
960E:  MOVLW  05
9610:  MOVWF  xB7
9612:  MOVLB  0
9614:  CALL   2522
....................     y = le_Input(S_EMPURRADOR_IN_LS2); 
9618:  MOVLW  03
961A:  MOVLB  3
961C:  MOVWF  xB2
961E:  MOVLB  0
9620:  CALL   4090
9624:  MOVLB  3
9626:  BCF    xAF.1
9628:  BTFSC  01.0
962A:  BSF    xAF.1
....................     while (y == 0){ 
962C:  BTFSC  xAF.1
962E:  BRA    9644
....................         y = le_Input(S_EMPURRADOR_IN_LS2); 
9630:  MOVLW  03
9632:  MOVWF  xB2
9634:  MOVLB  0
9636:  CALL   4090
963A:  MOVLB  3
963C:  BCF    xAF.1
963E:  BTFSC  01.0
9640:  BSF    xAF.1
9642:  BRA    962C
....................     } 
....................     desaciona_saida(DEDO_ENTRADA); 
9644:  CLRF   xB8
9646:  MOVLW  07
9648:  MOVWF  xB7
964A:  MOVLB  0
964C:  CALL   24E0
....................     desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
9650:  MOVLB  3
9652:  CLRF   xB8
9654:  MOVLW  05
9656:  MOVWF  xB7
9658:  MOVLB  0
965A:  CALL   24E0
965E:  GOTO   A3F2 (RETURN)
.................... } 
.................... void dispensa_placa(void){ 
....................     short x; 
....................     short y; 
....................     aciona_saida(DEDO_SAIDA); 
*
A25A:  MOVLB  3
A25C:  CLRF   xB8
A25E:  MOVLW  01
A260:  MOVWF  xB7
A262:  MOVLB  0
A264:  CALL   2522
....................     aciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
A268:  MOVLB  3
A26A:  CLRF   xB8
A26C:  CLRF   xB7
A26E:  MOVLB  0
A270:  CALL   2522
....................     x = le_Input(S_EMPURRADOR_OUT_LS1); 
A274:  MOVLW  12
A276:  MOVLB  3
A278:  MOVWF  xB2
A27A:  MOVLB  0
A27C:  CALL   4090
A280:  MOVLB  3
A282:  BCF    xAF.0
A284:  BTFSC  01.0
A286:  BSF    xAF.0
....................     while (x == 0){ 
A288:  BTFSC  xAF.0
A28A:  BRA    A2A0
....................         x = le_Input(S_EMPURRADOR_OUT_LS1); 
A28C:  MOVLW  12
A28E:  MOVWF  xB2
A290:  MOVLB  0
A292:  CALL   4090
A296:  MOVLB  3
A298:  BCF    xAF.0
A29A:  BTFSC  01.0
A29C:  BSF    xAF.0
A29E:  BRA    A288
....................     } 
....................     desaciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
A2A0:  CLRF   xB8
A2A2:  CLRF   xB7
A2A4:  MOVLB  0
A2A6:  CALL   24E0
....................     aciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
A2AA:  MOVLB  3
A2AC:  CLRF   xB8
A2AE:  MOVLW  0F
A2B0:  MOVWF  xB7
A2B2:  MOVLB  0
A2B4:  CALL   2522
....................     y = le_Input(S_EMPURRADOR_OUT_LS2); 
A2B8:  MOVLW  13
A2BA:  MOVLB  3
A2BC:  MOVWF  xB2
A2BE:  MOVLB  0
A2C0:  CALL   4090
A2C4:  MOVLB  3
A2C6:  BCF    xAF.1
A2C8:  BTFSC  01.0
A2CA:  BSF    xAF.1
....................     while (y == 0){ 
A2CC:  BTFSC  xAF.1
A2CE:  BRA    A2E4
....................         y = le_Input(S_EMPURRADOR_OUT_LS2); 
A2D0:  MOVLW  13
A2D2:  MOVWF  xB2
A2D4:  MOVLB  0
A2D6:  CALL   4090
A2DA:  MOVLB  3
A2DC:  BCF    xAF.1
A2DE:  BTFSC  01.0
A2E0:  BSF    xAF.1
A2E2:  BRA    A2CC
....................     } 
....................     desaciona_saida(DEDO_SAIDA); 
A2E4:  CLRF   xB8
A2E6:  MOVLW  01
A2E8:  MOVWF  xB7
A2EA:  MOVLB  0
A2EC:  CALL   24E0
....................     desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
A2F0:  MOVLB  3
A2F2:  CLRF   xB8
A2F4:  MOVLW  0F
A2F6:  MOVWF  xB7
A2F8:  MOVLB  0
A2FA:  CALL   24E0
A2FE:  GOTO   A53E (RETURN)
.................... } 
.................... void ligar_alimentador_solda(int quantidade, long int tempo){ 
....................     if (quantidade == 2){ 
*
707E:  MOVLB  3
7080:  MOVF   xB4,W
7082:  SUBLW  02
7084:  BNZ   70E2
....................         aciona_saida(ALIMENTADOR2); 
7086:  CLRF   xB8
7088:  MOVLW  0D
708A:  MOVWF  xB7
708C:  MOVLB  0
708E:  CALL   2522
....................         aciona_saida(ALIMENTADOR3); 
7092:  MOVLB  3
7094:  CLRF   xB8
7096:  MOVLW  0C
7098:  MOVWF  xB7
709A:  MOVLB  0
709C:  CALL   2522
....................         delay_ms(tempo); 
70A0:  MOVFF  3B6,3B7
70A4:  MOVLB  3
70A6:  INCF   xB7,F
70A8:  DECF   xB7,F
70AA:  BTFSC  FD8.2
70AC:  BRA    70BA
70AE:  SETF   xBE
70B0:  MOVLB  0
70B2:  CALL   2064
70B6:  MOVLB  3
70B8:  BRA    70A8
70BA:  MOVFF  3B5,3BE
70BE:  MOVLB  0
70C0:  CALL   2064
....................         desaciona_saida(ALIMENTADOR2); 
70C4:  MOVLB  3
70C6:  CLRF   xB8
70C8:  MOVLW  0D
70CA:  MOVWF  xB7
70CC:  MOVLB  0
70CE:  CALL   24E0
....................         desaciona_saida(ALIMENTADOR3); 
70D2:  MOVLB  3
70D4:  CLRF   xB8
70D6:  MOVLW  0C
70D8:  MOVWF  xB7
70DA:  MOVLB  0
70DC:  CALL   24E0
70E0:  MOVLB  3
....................     } 
....................     if (quantidade == 3){ 
70E2:  MOVF   xB4,W
70E4:  SUBLW  03
70E6:  BNZ   7160
....................         aciona_saida(ALIMENTADOR1); 
70E8:  CLRF   xB8
70EA:  MOVLW  0E
70EC:  MOVWF  xB7
70EE:  MOVLB  0
70F0:  CALL   2522
....................         aciona_saida(ALIMENTADOR2); 
70F4:  MOVLB  3
70F6:  CLRF   xB8
70F8:  MOVLW  0D
70FA:  MOVWF  xB7
70FC:  MOVLB  0
70FE:  CALL   2522
....................         aciona_saida(ALIMENTADOR3); 
7102:  MOVLB  3
7104:  CLRF   xB8
7106:  MOVLW  0C
7108:  MOVWF  xB7
710A:  MOVLB  0
710C:  CALL   2522
....................         delay_ms(tempo); 
7110:  MOVFF  3B6,3B7
7114:  MOVLB  3
7116:  INCF   xB7,F
7118:  DECF   xB7,F
711A:  BTFSC  FD8.2
711C:  BRA    712A
711E:  SETF   xBE
7120:  MOVLB  0
7122:  CALL   2064
7126:  MOVLB  3
7128:  BRA    7118
712A:  MOVFF  3B5,3BE
712E:  MOVLB  0
7130:  CALL   2064
....................         desaciona_saida(ALIMENTADOR1); 
7134:  MOVLB  3
7136:  CLRF   xB8
7138:  MOVLW  0E
713A:  MOVWF  xB7
713C:  MOVLB  0
713E:  CALL   24E0
....................         desaciona_saida(ALIMENTADOR2); 
7142:  MOVLB  3
7144:  CLRF   xB8
7146:  MOVLW  0D
7148:  MOVWF  xB7
714A:  MOVLB  0
714C:  CALL   24E0
....................         desaciona_saida(ALIMENTADOR3); 
7150:  MOVLB  3
7152:  CLRF   xB8
7154:  MOVLW  0C
7156:  MOVWF  xB7
7158:  MOVLB  0
715A:  CALL   24E0
715E:  MOVLB  3
....................     } 
7160:  MOVLB  0
7162:  RETURN 0
.................... } 
.................... void desce_ferros(int quantidade){ 
....................     if (quantidade == 2){ 
*
6D62:  MOVLB  3
6D64:  MOVF   xB2,W
6D66:  SUBLW  02
6D68:  BNZ   6D78
....................         aciona_saida(FERRO_SOLDA2); 
6D6A:  CLRF   xB8
6D6C:  MOVLW  02
6D6E:  MOVWF  xB7
6D70:  MOVLB  0
6D72:  CALL   2522
6D76:  MOVLB  3
....................     } 
....................     if (quantidade == 3){ 
6D78:  MOVF   xB2,W
6D7A:  SUBLW  03
6D7C:  BNZ   6D9A
....................         aciona_saida(FERRO_SOLDA1); 
6D7E:  CLRF   xB8
6D80:  MOVLW  03
6D82:  MOVWF  xB7
6D84:  MOVLB  0
6D86:  CALL   2522
....................         aciona_saida(FERRO_SOLDA2); 
6D8A:  MOVLB  3
6D8C:  CLRF   xB8
6D8E:  MOVLW  02
6D90:  MOVWF  xB7
6D92:  MOVLB  0
6D94:  CALL   2522
6D98:  MOVLB  3
....................     } 
6D9A:  MOVLB  0
6D9C:  RETURN 0
.................... } 
.................... void sobe_ferros(int quantidade){ 
....................     if (quantidade == 2){ 
*
6D26:  MOVLB  3
6D28:  MOVF   xB2,W
6D2A:  SUBLW  02
6D2C:  BNZ   6D3C
....................         desaciona_saida(FERRO_SOLDA2); 
6D2E:  CLRF   xB8
6D30:  MOVLW  02
6D32:  MOVWF  xB7
6D34:  MOVLB  0
6D36:  CALL   24E0
6D3A:  MOVLB  3
....................     } 
....................     if (quantidade == 3){ 
6D3C:  MOVF   xB2,W
6D3E:  SUBLW  03
6D40:  BNZ   6D5E
....................         desaciona_saida(FERRO_SOLDA1); 
6D42:  CLRF   xB8
6D44:  MOVLW  03
6D46:  MOVWF  xB7
6D48:  MOVLB  0
6D4A:  CALL   24E0
....................         desaciona_saida(FERRO_SOLDA2); 
6D4E:  MOVLB  3
6D50:  CLRF   xB8
6D52:  MOVLW  02
6D54:  MOVWF  xB7
6D56:  MOVLB  0
6D58:  CALL   24E0
6D5C:  MOVLB  3
....................     } 
6D5E:  MOVLB  0
6D60:  RETURN 0
.................... } 
.................... void liga_esteira(void){ 
....................     aciona_saida(RELE_ESTEIRA); 
*
9592:  MOVLB  3
9594:  CLRF   xB8
9596:  MOVLW  0A
9598:  MOVWF  xB7
959A:  MOVLB  0
959C:  CALL   2522
95A0:  GOTO   A384 (RETURN)
.................... } 
.................... void desliga_esteira(void){ 
....................     desaciona_saida(RELE_ESTEIRA); 
95A4:  MOVLB  3
95A6:  CLRF   xB8
95A8:  MOVLW  0A
95AA:  MOVWF  xB7
95AC:  MOVLB  0
95AE:  CALL   24E0
95B2:  GOTO   A3EE (RETURN)
.................... } 
.................... void limpa_bicos(long int tempo){ 
....................     aciona_saida(LIMPA_BICO1); 
*
A302:  MOVLB  3
A304:  CLRF   xB8
A306:  MOVLW  08
A308:  MOVWF  xB7
A30A:  MOVLB  0
A30C:  CALL   2522
....................     aciona_saida(LIMPA_BICO2); 
A310:  MOVLB  3
A312:  CLRF   xB8
A314:  MOVLW  09
A316:  MOVWF  xB7
A318:  MOVLB  0
A31A:  CALL   2522
....................     delay_ms(tempo); 
A31E:  MOVFF  3B0,3B1
A322:  MOVLB  3
A324:  INCF   xB1,F
A326:  DECF   xB1,F
A328:  BTFSC  FD8.2
A32A:  BRA    A338
A32C:  SETF   xBE
A32E:  MOVLB  0
A330:  CALL   2064
A334:  MOVLB  3
A336:  BRA    A326
A338:  MOVFF  3AF,3BE
A33C:  MOVLB  0
A33E:  CALL   2064
....................     desaciona_saida(LIMPA_BICO1); 
A342:  MOVLB  3
A344:  CLRF   xB8
A346:  MOVLW  08
A348:  MOVWF  xB7
A34A:  MOVLB  0
A34C:  CALL   24E0
....................     desaciona_saida(LIMPA_BICO2);     
A350:  MOVLB  3
A352:  CLRF   xB8
A354:  MOVLW  09
A356:  MOVWF  xB7
A358:  MOVLB  0
A35A:  CALL   24E0
A35E:  RETURN 0
.................... } 
.................... void home_solenoides(void){ 
....................     desaciona_saida(DEDO_ENTRADA); 
*
256E:  MOVLB  3
2570:  CLRF   xB8
2572:  MOVLW  07
2574:  MOVWF  xB7
2576:  MOVLB  0
2578:  RCALL  24E0
....................     desaciona_saida(DEDO_SAIDA); 
257A:  MOVLB  3
257C:  CLRF   xB8
257E:  MOVLW  01
2580:  MOVWF  xB7
2582:  MOVLB  0
2584:  RCALL  24E0
....................     desaciona_saida(FERRO_SOLDA1); 
2586:  MOVLB  3
2588:  CLRF   xB8
258A:  MOVLW  03
258C:  MOVWF  xB7
258E:  MOVLB  0
2590:  RCALL  24E0
....................     desaciona_saida(FERRO_SOLDA2); 
2592:  MOVLB  3
2594:  CLRF   xB8
2596:  MOVLW  02
2598:  MOVWF  xB7
259A:  MOVLB  0
259C:  RCALL  24E0
....................     desaciona_saida(PRESSOR); 
259E:  MOVLB  3
25A0:  CLRF   xB8
25A2:  MOVLW  04
25A4:  MOVWF  xB7
25A6:  MOVLB  0
25A8:  RCALL  24E0
....................     desaciona_saida(LIMPA_BICO1); 
25AA:  MOVLB  3
25AC:  CLRF   xB8
25AE:  MOVLW  08
25B0:  MOVWF  xB7
25B2:  MOVLB  0
25B4:  RCALL  24E0
....................     desaciona_saida(LIMPA_BICO2); 
25B6:  MOVLB  3
25B8:  CLRF   xB8
25BA:  MOVLW  09
25BC:  MOVWF  xB7
25BE:  MOVLB  0
25C0:  RCALL  24E0
....................      
....................     aciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
25C2:  MOVLB  3
25C4:  CLRF   xB8
25C6:  MOVLW  05
25C8:  MOVWF  xB7
25CA:  MOVLB  0
25CC:  RCALL  2522
....................     aciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
25CE:  MOVLB  3
25D0:  CLRF   xB8
25D2:  MOVLW  0F
25D4:  MOVWF  xB7
25D6:  MOVLB  0
25D8:  RCALL  2522
....................     delay_ms(2500); 
25DA:  MOVLW  0A
25DC:  MOVLB  3
25DE:  MOVWF  xAD
25E0:  MOVLW  FA
25E2:  MOVWF  xBE
25E4:  MOVLB  0
25E6:  RCALL  2064
25E8:  MOVLB  3
25EA:  DECFSZ xAD,F
25EC:  BRA    25E0
....................     desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
25EE:  CLRF   xB8
25F0:  MOVLW  05
25F2:  MOVWF  xB7
25F4:  MOVLB  0
25F6:  RCALL  24E0
....................     desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
25F8:  MOVLB  3
25FA:  CLRF   xB8
25FC:  MOVLW  0F
25FE:  MOVWF  xB7
2600:  MOVLB  0
2602:  RCALL  24E0
2604:  RETURN 0
.................... } 
....................  
.................... void soldar_teste(int componente, int local){ 
....................     int q; 
....................     int ferros; 
....................     q = (pontos_no_modelo/2); 
*
7164:  BCF    FD8.0
7166:  MOVLB  1
7168:  RRCF   x0A,W
716A:  MOVLB  3
716C:  MOVWF  xB0
....................     if (local < q){ 
716E:  MOVF   xB0,W
7170:  SUBWF  xAF,W
7172:  BC    717A
....................         ferros = 3; 
7174:  MOVLW  03
7176:  MOVWF  xB1
....................     } else { 
7178:  BRA    717E
....................         ferros = 2; 
717A:  MOVLW  02
717C:  MOVWF  xB1
....................     } 
....................     liga_pressor(); 
717E:  MOVLB  0
7180:  CALL   6516
....................     ligar_alimentador_solda(ferros,700); 
7184:  MOVFF  3B1,3B4
7188:  MOVLW  02
718A:  MOVLB  3
718C:  MOVWF  xB6
718E:  MOVLW  BC
7190:  MOVWF  xB5
7192:  MOVLB  0
7194:  RCALL  707E
....................     if ((y[local] > 700)&&(x[local] > 0)){ 
7196:  BCF    FD8.0
7198:  MOVLB  3
719A:  RLCF   xAF,W
719C:  CLRF   03
719E:  ADDLW  56
71A0:  MOVWF  FE9
71A2:  MOVLW  00
71A4:  ADDWFC 03,W
71A6:  MOVWF  FEA
71A8:  MOVFF  FEC,3B3
71AC:  MOVF   FED,F
71AE:  MOVFF  FEF,3B2
71B2:  MOVF   xB3,W
71B4:  SUBLW  01
71B6:  BTFSC  FD8.0
71B8:  GOTO   7C26
71BC:  XORLW  FF
71BE:  BNZ   71CA
71C0:  MOVF   xB2,W
71C2:  SUBLW  BC
71C4:  BTFSC  FD8.0
71C6:  GOTO   7C26
71CA:  BCF    FD8.0
71CC:  RLCF   xAF,W
71CE:  CLRF   03
71D0:  ADDLW  2E
71D2:  MOVWF  FE9
71D4:  MOVLW  00
71D6:  ADDWFC 03,W
71D8:  MOVWF  FEA
71DA:  MOVFF  FEC,3B3
71DE:  MOVF   FED,F
71E0:  MOVFF  FEF,3B2
71E4:  MOVF   xB2,F
71E6:  BNZ   71F0
71E8:  MOVF   xB3,F
71EA:  BTFSC  FD8.2
71EC:  GOTO   7C26
....................         desce_ferros(ferros); 
71F0:  MOVFF  3B1,3B2
71F4:  MOVLB  0
71F6:  RCALL  6D62
....................         switch (componente){ 
71F8:  MOVLB  3
71FA:  MOVF   xAE,W
71FC:  ADDLW  FC
71FE:  BTFSC  FD8.0
7200:  GOTO   7C24
7204:  ADDLW  04
7206:  MOVLB  0
7208:  GOTO   7C78
....................             case 0: 
....................                 motor_run_y(y[local], 19); 
720C:  BCF    FD8.0
720E:  MOVLB  3
7210:  RLCF   xAF,W
7212:  CLRF   03
7214:  ADDLW  56
7216:  MOVWF  FE9
7218:  MOVLW  00
721A:  ADDWFC 03,W
721C:  MOVWF  FEA
721E:  MOVFF  FEC,3B3
7222:  MOVF   FED,F
7224:  MOVFF  FEF,3B2
7228:  CLRF   xB7
722A:  CLRF   xB6
722C:  MOVFF  3B3,3B5
7230:  MOVFF  3B2,3B4
7234:  MOVLW  13
7236:  MOVWF  xB8
7238:  MOVLB  0
723A:  CALL   5802
....................                 motor_run_x(x[local], 19); 
723E:  BCF    FD8.0
7240:  MOVLB  3
7242:  RLCF   xAF,W
7244:  CLRF   03
7246:  ADDLW  2E
7248:  MOVWF  FE9
724A:  MOVLW  00
724C:  ADDWFC 03,W
724E:  MOVWF  FEA
7250:  MOVFF  FEC,3B3
7254:  MOVF   FED,F
7256:  MOVFF  FEF,3B2
725A:  CLRF   xB7
725C:  CLRF   xB6
725E:  MOVFF  3B3,3B5
7262:  MOVFF  3B2,3B4
7266:  MOVLW  13
7268:  MOVWF  xB8
726A:  MOVLB  0
726C:  CALL   4AB2
....................                 while ((run_flg_x || run_flg_y)); 
7270:  MOVLB  1
7272:  BTFSC  x1A.3
7274:  BRA    7272
7276:  BTFSC  x1A.5
7278:  BRA    7272
....................                 ligar_alimentador_solda(ferros,t_solda[local]); 
727A:  BCF    FD8.0
727C:  MOVLB  3
727E:  RLCF   xAF,W
7280:  CLRF   03
7282:  ADDLW  A6
7284:  MOVWF  FE9
7286:  MOVLW  00
7288:  ADDWFC 03,W
728A:  MOVWF  FEA
728C:  MOVFF  FEC,3B3
7290:  MOVF   FED,F
7292:  MOVFF  FEF,3B2
7296:  MOVFF  3B1,3B4
729A:  MOVFF  3B3,3B6
729E:  MOVFF  3B2,3B5
72A2:  MOVLB  0
72A4:  RCALL  707E
....................                 motor_run_z(z[local], 19); 
72A6:  BCF    FD8.0
72A8:  MOVLB  3
72AA:  RLCF   xAF,W
72AC:  CLRF   03
72AE:  ADDLW  7E
72B0:  MOVWF  FE9
72B2:  MOVLW  00
72B4:  ADDWFC 03,W
72B6:  MOVWF  FEA
72B8:  MOVFF  FEC,3B3
72BC:  MOVF   FED,F
72BE:  MOVFF  FEF,3B2
72C2:  CLRF   xB7
72C4:  CLRF   xB6
72C6:  MOVFF  3B3,3B5
72CA:  MOVFF  3B2,3B4
72CE:  MOVLW  13
72D0:  MOVWF  xB8
72D2:  MOVLB  0
72D4:  CALL   5638
....................                 while ((run_flg_z)); 
72D8:  MOVLB  3
72DA:  BTFSC  x9B.0
72DC:  BRA    72DA
....................                 delay_ms(t_wait[local]);  
72DE:  BCF    FD8.0
72E0:  RLCF   xAF,W
72E2:  CLRF   03
72E4:  ADDLW  CE
72E6:  MOVWF  FE9
72E8:  MOVLW  00
72EA:  ADDWFC 03,W
72EC:  MOVWF  FEA
72EE:  MOVFF  FEC,3B3
72F2:  MOVF   FED,F
72F4:  MOVFF  FEF,3B2
72F8:  MOVFF  3B3,3B4
72FC:  INCF   xB4,F
72FE:  DECF   xB4,F
7300:  BTFSC  FD8.2
7302:  BRA    7310
7304:  SETF   xBE
7306:  MOVLB  0
7308:  CALL   2064
730C:  MOVLB  3
730E:  BRA    72FE
7310:  MOVFF  3B2,3BE
7314:  MOVLB  0
7316:  CALL   2064
....................                 motor_run_z(0, 19); 
731A:  MOVLB  3
731C:  CLRF   xB7
731E:  CLRF   xB6
7320:  CLRF   xB5
7322:  CLRF   xB4
7324:  MOVLW  13
7326:  MOVWF  xB8
7328:  MOVLB  0
732A:  CALL   5638
....................                 while ((run_flg_z)); 
732E:  MOVLB  3
7330:  BTFSC  x9B.0
7332:  BRA    7330
....................             break; 
7334:  GOTO   7C24
....................             case 1: 
....................                 motor_run_y(y[local], 19); 
7338:  BCF    FD8.0
733A:  MOVLB  3
733C:  RLCF   xAF,W
733E:  CLRF   03
7340:  ADDLW  56
7342:  MOVWF  FE9
7344:  MOVLW  00
7346:  ADDWFC 03,W
7348:  MOVWF  FEA
734A:  MOVFF  FEC,3B3
734E:  MOVF   FED,F
7350:  MOVFF  FEF,3B2
7354:  CLRF   xB7
7356:  CLRF   xB6
7358:  MOVFF  3B3,3B5
735C:  MOVFF  3B2,3B4
7360:  MOVLW  13
7362:  MOVWF  xB8
7364:  MOVLB  0
7366:  CALL   5802
....................                 motor_run_x(x[local], 19); 
736A:  BCF    FD8.0
736C:  MOVLB  3
736E:  RLCF   xAF,W
7370:  CLRF   03
7372:  ADDLW  2E
7374:  MOVWF  FE9
7376:  MOVLW  00
7378:  ADDWFC 03,W
737A:  MOVWF  FEA
737C:  MOVFF  FEC,3B3
7380:  MOVF   FED,F
7382:  MOVFF  FEF,3B2
7386:  CLRF   xB7
7388:  CLRF   xB6
738A:  MOVFF  3B3,3B5
738E:  MOVFF  3B2,3B4
7392:  MOVLW  13
7394:  MOVWF  xB8
7396:  MOVLB  0
7398:  CALL   4AB2
....................                 while ((run_flg_x || run_flg_y)); 
739C:  MOVLB  1
739E:  BTFSC  x1A.3
73A0:  BRA    739E
73A2:  BTFSC  x1A.5
73A4:  BRA    739E
....................                 ligar_alimentador_solda(ferros,t_solda[local]); 
73A6:  BCF    FD8.0
73A8:  MOVLB  3
73AA:  RLCF   xAF,W
73AC:  CLRF   03
73AE:  ADDLW  A6
73B0:  MOVWF  FE9
73B2:  MOVLW  00
73B4:  ADDWFC 03,W
73B6:  MOVWF  FEA
73B8:  MOVFF  FEC,3B3
73BC:  MOVF   FED,F
73BE:  MOVFF  FEF,3B2
73C2:  MOVFF  3B1,3B4
73C6:  MOVFF  3B3,3B6
73CA:  MOVFF  3B2,3B5
73CE:  MOVLB  0
73D0:  RCALL  707E
....................                 motor_run_z(z[local]-20, 19); 
73D2:  BCF    FD8.0
73D4:  MOVLB  3
73D6:  RLCF   xAF,W
73D8:  CLRF   03
73DA:  ADDLW  7E
73DC:  MOVWF  FE9
73DE:  MOVLW  00
73E0:  ADDWFC 03,W
73E2:  MOVWF  FEA
73E4:  MOVFF  FEC,3B3
73E8:  MOVF   FED,F
73EA:  MOVFF  FEF,3B2
73EE:  MOVLW  14
73F0:  SUBWF  xB2,F
73F2:  MOVLW  00
73F4:  SUBWFB xB3,F
73F6:  CLRF   xB7
73F8:  CLRF   xB6
73FA:  MOVFF  3B3,3B5
73FE:  MOVFF  3B2,3B4
7402:  MOVLW  13
7404:  MOVWF  xB8
7406:  MOVLB  0
7408:  CALL   5638
....................                 motor_run_y(y[local]-30, 19); 
740C:  BCF    FD8.0
740E:  MOVLB  3
7410:  RLCF   xAF,W
7412:  CLRF   03
7414:  ADDLW  56
7416:  MOVWF  FE9
7418:  MOVLW  00
741A:  ADDWFC 03,W
741C:  MOVWF  FEA
741E:  MOVFF  FEC,3B3
7422:  MOVF   FED,F
7424:  MOVFF  FEF,3B2
7428:  MOVLW  1E
742A:  SUBWF  xB2,F
742C:  MOVLW  00
742E:  SUBWFB xB3,F
7430:  CLRF   xB7
7432:  CLRF   xB6
7434:  MOVFF  3B3,3B5
7438:  MOVFF  3B2,3B4
743C:  MOVLW  13
743E:  MOVWF  xB8
7440:  MOVLB  0
7442:  CALL   5802
....................                 motor_run_y(y[local], 19); 
7446:  BCF    FD8.0
7448:  MOVLB  3
744A:  RLCF   xAF,W
744C:  CLRF   03
744E:  ADDLW  56
7450:  MOVWF  FE9
7452:  MOVLW  00
7454:  ADDWFC 03,W
7456:  MOVWF  FEA
7458:  MOVFF  FEC,3B3
745C:  MOVF   FED,F
745E:  MOVFF  FEF,3B2
7462:  CLRF   xB7
7464:  CLRF   xB6
7466:  MOVFF  3B3,3B5
746A:  MOVFF  3B2,3B4
746E:  MOVLW  13
7470:  MOVWF  xB8
7472:  MOVLB  0
7474:  CALL   5802
....................                 motor_run_x(x[local]+10, 19); 
7478:  BCF    FD8.0
747A:  MOVLB  3
747C:  RLCF   xAF,W
747E:  CLRF   03
7480:  ADDLW  2E
7482:  MOVWF  FE9
7484:  MOVLW  00
7486:  ADDWFC 03,W
7488:  MOVWF  FEA
748A:  MOVFF  FEC,3B3
748E:  MOVF   FED,F
7490:  MOVFF  FEF,3B2
7494:  MOVLW  0A
7496:  ADDWF  xB2,F
7498:  MOVLW  00
749A:  ADDWFC xB3,F
749C:  CLRF   xB7
749E:  CLRF   xB6
74A0:  MOVFF  3B3,3B5
74A4:  MOVFF  3B2,3B4
74A8:  MOVLW  13
74AA:  MOVWF  xB8
74AC:  MOVLB  0
74AE:  CALL   4AB2
....................                 motor_run_z(z[local], 19); 
74B2:  BCF    FD8.0
74B4:  MOVLB  3
74B6:  RLCF   xAF,W
74B8:  CLRF   03
74BA:  ADDLW  7E
74BC:  MOVWF  FE9
74BE:  MOVLW  00
74C0:  ADDWFC 03,W
74C2:  MOVWF  FEA
74C4:  MOVFF  FEC,3B3
74C8:  MOVF   FED,F
74CA:  MOVFF  FEF,3B2
74CE:  CLRF   xB7
74D0:  CLRF   xB6
74D2:  MOVFF  3B3,3B5
74D6:  MOVFF  3B2,3B4
74DA:  MOVLW  13
74DC:  MOVWF  xB8
74DE:  MOVLB  0
74E0:  CALL   5638
....................                 motor_run_x(x[local], 19); 
74E4:  BCF    FD8.0
74E6:  MOVLB  3
74E8:  RLCF   xAF,W
74EA:  CLRF   03
74EC:  ADDLW  2E
74EE:  MOVWF  FE9
74F0:  MOVLW  00
74F2:  ADDWFC 03,W
74F4:  MOVWF  FEA
74F6:  MOVFF  FEC,3B3
74FA:  MOVF   FED,F
74FC:  MOVFF  FEF,3B2
7500:  CLRF   xB7
7502:  CLRF   xB6
7504:  MOVFF  3B3,3B5
7508:  MOVFF  3B2,3B4
750C:  MOVLW  13
750E:  MOVWF  xB8
7510:  MOVLB  0
7512:  CALL   4AB2
....................                 while ((run_flg_x || run_flg_y || run_flg_z)); 
7516:  MOVLB  1
7518:  BTFSC  x1A.3
751A:  BRA    7518
751C:  BTFSC  x1A.5
751E:  BRA    7518
7520:  MOVLB  3
7522:  BTFSS  x9B.0
7524:  BRA    752A
7526:  MOVLB  0
7528:  BRA    7516
....................                 delay_ms(t_wait[local]);              
752A:  BCF    FD8.0
752C:  RLCF   xAF,W
752E:  CLRF   03
7530:  ADDLW  CE
7532:  MOVWF  FE9
7534:  MOVLW  00
7536:  ADDWFC 03,W
7538:  MOVWF  FEA
753A:  MOVFF  FEC,3B3
753E:  MOVF   FED,F
7540:  MOVFF  FEF,3B2
7544:  MOVFF  3B3,3B4
7548:  INCF   xB4,F
754A:  DECF   xB4,F
754C:  BTFSC  FD8.2
754E:  BRA    755C
7550:  SETF   xBE
7552:  MOVLB  0
7554:  CALL   2064
7558:  MOVLB  3
755A:  BRA    754A
755C:  MOVFF  3B2,3BE
7560:  MOVLB  0
7562:  CALL   2064
....................                 motor_run_z(0, 19); 
7566:  MOVLB  3
7568:  CLRF   xB7
756A:  CLRF   xB6
756C:  CLRF   xB5
756E:  CLRF   xB4
7570:  MOVLW  13
7572:  MOVWF  xB8
7574:  MOVLB  0
7576:  CALL   5638
....................                 while ((run_flg_z)); 
757A:  MOVLB  3
757C:  BTFSC  x9B.0
757E:  BRA    757C
....................             break; 
7580:  BRA    7C24
....................             case 2: 
....................                 motor_run_y(y[local], 19); 
7582:  BCF    FD8.0
7584:  MOVLB  3
7586:  RLCF   xAF,W
7588:  CLRF   03
758A:  ADDLW  56
758C:  MOVWF  FE9
758E:  MOVLW  00
7590:  ADDWFC 03,W
7592:  MOVWF  FEA
7594:  MOVFF  FEC,3B3
7598:  MOVF   FED,F
759A:  MOVFF  FEF,3B2
759E:  CLRF   xB7
75A0:  CLRF   xB6
75A2:  MOVFF  3B3,3B5
75A6:  MOVFF  3B2,3B4
75AA:  MOVLW  13
75AC:  MOVWF  xB8
75AE:  MOVLB  0
75B0:  CALL   5802
....................                 motor_run_x(x[local], 19); 
75B4:  BCF    FD8.0
75B6:  MOVLB  3
75B8:  RLCF   xAF,W
75BA:  CLRF   03
75BC:  ADDLW  2E
75BE:  MOVWF  FE9
75C0:  MOVLW  00
75C2:  ADDWFC 03,W
75C4:  MOVWF  FEA
75C6:  MOVFF  FEC,3B3
75CA:  MOVF   FED,F
75CC:  MOVFF  FEF,3B2
75D0:  CLRF   xB7
75D2:  CLRF   xB6
75D4:  MOVFF  3B3,3B5
75D8:  MOVFF  3B2,3B4
75DC:  MOVLW  13
75DE:  MOVWF  xB8
75E0:  MOVLB  0
75E2:  CALL   4AB2
....................                 while ((run_flg_x || run_flg_y)); 
75E6:  MOVLB  1
75E8:  BTFSC  x1A.3
75EA:  BRA    75E8
75EC:  BTFSC  x1A.5
75EE:  BRA    75E8
....................                 ligar_alimentador_solda(ferros,t_solda[local]); 
75F0:  BCF    FD8.0
75F2:  MOVLB  3
75F4:  RLCF   xAF,W
75F6:  CLRF   03
75F8:  ADDLW  A6
75FA:  MOVWF  FE9
75FC:  MOVLW  00
75FE:  ADDWFC 03,W
7600:  MOVWF  FEA
7602:  MOVFF  FEC,3B3
7606:  MOVF   FED,F
7608:  MOVFF  FEF,3B2
760C:  MOVFF  3B1,3B4
7610:  MOVFF  3B3,3B6
7614:  MOVFF  3B2,3B5
7618:  MOVLB  0
761A:  RCALL  707E
....................                 motor_run_z(z[local], 19); 
761C:  BCF    FD8.0
761E:  MOVLB  3
7620:  RLCF   xAF,W
7622:  CLRF   03
7624:  ADDLW  7E
7626:  MOVWF  FE9
7628:  MOVLW  00
762A:  ADDWFC 03,W
762C:  MOVWF  FEA
762E:  MOVFF  FEC,3B3
7632:  MOVF   FED,F
7634:  MOVFF  FEF,3B2
7638:  CLRF   xB7
763A:  CLRF   xB6
763C:  MOVFF  3B3,3B5
7640:  MOVFF  3B2,3B4
7644:  MOVLW  13
7646:  MOVWF  xB8
7648:  MOVLB  0
764A:  CALL   5638
....................                 while ((run_flg_z)); 
764E:  MOVLB  3
7650:  BTFSC  x9B.0
7652:  BRA    7650
....................                 delay_ms(t_wait[local]); 
7654:  BCF    FD8.0
7656:  RLCF   xAF,W
7658:  CLRF   03
765A:  ADDLW  CE
765C:  MOVWF  FE9
765E:  MOVLW  00
7660:  ADDWFC 03,W
7662:  MOVWF  FEA
7664:  MOVFF  FEC,3B3
7668:  MOVF   FED,F
766A:  MOVFF  FEF,3B2
766E:  MOVFF  3B3,3B4
7672:  INCF   xB4,F
7674:  DECF   xB4,F
7676:  BTFSC  FD8.2
7678:  BRA    7686
767A:  SETF   xBE
767C:  MOVLB  0
767E:  CALL   2064
7682:  MOVLB  3
7684:  BRA    7674
7686:  MOVFF  3B2,3BE
768A:  MOVLB  0
768C:  CALL   2064
....................                 motor_run_z(z[local]-3, 19); 
7690:  BCF    FD8.0
7692:  MOVLB  3
7694:  RLCF   xAF,W
7696:  CLRF   03
7698:  ADDLW  7E
769A:  MOVWF  FE9
769C:  MOVLW  00
769E:  ADDWFC 03,W
76A0:  MOVWF  FEA
76A2:  MOVFF  FEC,3B3
76A6:  MOVF   FED,F
76A8:  MOVFF  FEF,3B2
76AC:  MOVLW  03
76AE:  SUBWF  xB2,F
76B0:  MOVLW  00
76B2:  SUBWFB xB3,F
76B4:  CLRF   xB7
76B6:  CLRF   xB6
76B8:  MOVFF  3B3,3B5
76BC:  MOVFF  3B2,3B4
76C0:  MOVLW  13
76C2:  MOVWF  xB8
76C4:  MOVLB  0
76C6:  CALL   5638
....................                 motor_run_x(x[local]-10, 19); 
76CA:  BCF    FD8.0
76CC:  MOVLB  3
76CE:  RLCF   xAF,W
76D0:  CLRF   03
76D2:  ADDLW  2E
76D4:  MOVWF  FE9
76D6:  MOVLW  00
76D8:  ADDWFC 03,W
76DA:  MOVWF  FEA
76DC:  MOVFF  FEC,3B3
76E0:  MOVF   FED,F
76E2:  MOVFF  FEF,3B2
76E6:  MOVLW  0A
76E8:  SUBWF  xB2,F
76EA:  MOVLW  00
76EC:  SUBWFB xB3,F
76EE:  CLRF   xB7
76F0:  CLRF   xB6
76F2:  MOVFF  3B3,3B5
76F6:  MOVFF  3B2,3B4
76FA:  MOVLW  13
76FC:  MOVWF  xB8
76FE:  MOVLB  0
7700:  CALL   4AB2
....................                 motor_run_z(z[local], 19); 
7704:  BCF    FD8.0
7706:  MOVLB  3
7708:  RLCF   xAF,W
770A:  CLRF   03
770C:  ADDLW  7E
770E:  MOVWF  FE9
7710:  MOVLW  00
7712:  ADDWFC 03,W
7714:  MOVWF  FEA
7716:  MOVFF  FEC,3B3
771A:  MOVF   FED,F
771C:  MOVFF  FEF,3B2
7720:  CLRF   xB7
7722:  CLRF   xB6
7724:  MOVFF  3B3,3B5
7728:  MOVFF  3B2,3B4
772C:  MOVLW  13
772E:  MOVWF  xB8
7730:  MOVLB  0
7732:  CALL   5638
....................                 while ((run_flg_x || run_flg_y || run_flg_z)); 
7736:  MOVLB  1
7738:  BTFSC  x1A.3
773A:  BRA    7738
773C:  BTFSC  x1A.5
773E:  BRA    7738
7740:  MOVLB  3
7742:  BTFSS  x9B.0
7744:  BRA    774A
7746:  MOVLB  0
7748:  BRA    7736
....................                 delay_ms(t_wait[local]);   
774A:  BCF    FD8.0
774C:  RLCF   xAF,W
774E:  CLRF   03
7750:  ADDLW  CE
7752:  MOVWF  FE9
7754:  MOVLW  00
7756:  ADDWFC 03,W
7758:  MOVWF  FEA
775A:  MOVFF  FEC,3B3
775E:  MOVF   FED,F
7760:  MOVFF  FEF,3B2
7764:  MOVFF  3B3,3B4
7768:  INCF   xB4,F
776A:  DECF   xB4,F
776C:  BTFSC  FD8.2
776E:  BRA    777C
7770:  SETF   xBE
7772:  MOVLB  0
7774:  CALL   2064
7778:  MOVLB  3
777A:  BRA    776A
777C:  MOVFF  3B2,3BE
7780:  MOVLB  0
7782:  CALL   2064
....................                 motor_run_z(z[local]-3, 19); 
7786:  BCF    FD8.0
7788:  MOVLB  3
778A:  RLCF   xAF,W
778C:  CLRF   03
778E:  ADDLW  7E
7790:  MOVWF  FE9
7792:  MOVLW  00
7794:  ADDWFC 03,W
7796:  MOVWF  FEA
7798:  MOVFF  FEC,3B3
779C:  MOVF   FED,F
779E:  MOVFF  FEF,3B2
77A2:  MOVLW  03
77A4:  SUBWF  xB2,F
77A6:  MOVLW  00
77A8:  SUBWFB xB3,F
77AA:  CLRF   xB7
77AC:  CLRF   xB6
77AE:  MOVFF  3B3,3B5
77B2:  MOVFF  3B2,3B4
77B6:  MOVLW  13
77B8:  MOVWF  xB8
77BA:  MOVLB  0
77BC:  CALL   5638
....................                 motor_run_x(x[local]+10, 19); 
77C0:  BCF    FD8.0
77C2:  MOVLB  3
77C4:  RLCF   xAF,W
77C6:  CLRF   03
77C8:  ADDLW  2E
77CA:  MOVWF  FE9
77CC:  MOVLW  00
77CE:  ADDWFC 03,W
77D0:  MOVWF  FEA
77D2:  MOVFF  FEC,3B3
77D6:  MOVF   FED,F
77D8:  MOVFF  FEF,3B2
77DC:  MOVLW  0A
77DE:  ADDWF  xB2,F
77E0:  MOVLW  00
77E2:  ADDWFC xB3,F
77E4:  CLRF   xB7
77E6:  CLRF   xB6
77E8:  MOVFF  3B3,3B5
77EC:  MOVFF  3B2,3B4
77F0:  MOVLW  13
77F2:  MOVWF  xB8
77F4:  MOVLB  0
77F6:  CALL   4AB2
....................                 motor_run_z(z[local], 19); 
77FA:  BCF    FD8.0
77FC:  MOVLB  3
77FE:  RLCF   xAF,W
7800:  CLRF   03
7802:  ADDLW  7E
7804:  MOVWF  FE9
7806:  MOVLW  00
7808:  ADDWFC 03,W
780A:  MOVWF  FEA
780C:  MOVFF  FEC,3B3
7810:  MOVF   FED,F
7812:  MOVFF  FEF,3B2
7816:  CLRF   xB7
7818:  CLRF   xB6
781A:  MOVFF  3B3,3B5
781E:  MOVFF  3B2,3B4
7822:  MOVLW  13
7824:  MOVWF  xB8
7826:  MOVLB  0
7828:  CALL   5638
....................                 while ((run_flg_x || run_flg_z)); 
782C:  MOVLB  1
782E:  BTFSC  x1A.3
7830:  BRA    782E
7832:  MOVLB  3
7834:  BTFSS  x9B.0
7836:  BRA    783C
7838:  MOVLB  0
783A:  BRA    782C
....................                 delay_ms(t_wait[local]); 
783C:  BCF    FD8.0
783E:  RLCF   xAF,W
7840:  CLRF   03
7842:  ADDLW  CE
7844:  MOVWF  FE9
7846:  MOVLW  00
7848:  ADDWFC 03,W
784A:  MOVWF  FEA
784C:  MOVFF  FEC,3B3
7850:  MOVF   FED,F
7852:  MOVFF  FEF,3B2
7856:  MOVFF  3B3,3B4
785A:  INCF   xB4,F
785C:  DECF   xB4,F
785E:  BTFSC  FD8.2
7860:  BRA    786E
7862:  SETF   xBE
7864:  MOVLB  0
7866:  CALL   2064
786A:  MOVLB  3
786C:  BRA    785C
786E:  MOVFF  3B2,3BE
7872:  MOVLB  0
7874:  CALL   2064
....................                 motor_run_z(0, 19); 
7878:  MOVLB  3
787A:  CLRF   xB7
787C:  CLRF   xB6
787E:  CLRF   xB5
7880:  CLRF   xB4
7882:  MOVLW  13
7884:  MOVWF  xB8
7886:  MOVLB  0
7888:  CALL   5638
....................                 while ((run_flg_z)); 
788C:  MOVLB  3
788E:  BTFSC  x9B.0
7890:  BRA    788E
....................             break; 
7892:  BRA    7C24
....................             case 3: 
....................                 motor_run_y(y[local], 19); 
7894:  BCF    FD8.0
7896:  MOVLB  3
7898:  RLCF   xAF,W
789A:  CLRF   03
789C:  ADDLW  56
789E:  MOVWF  FE9
78A0:  MOVLW  00
78A2:  ADDWFC 03,W
78A4:  MOVWF  FEA
78A6:  MOVFF  FEC,3B3
78AA:  MOVF   FED,F
78AC:  MOVFF  FEF,3B2
78B0:  CLRF   xB7
78B2:  CLRF   xB6
78B4:  MOVFF  3B3,3B5
78B8:  MOVFF  3B2,3B4
78BC:  MOVLW  13
78BE:  MOVWF  xB8
78C0:  MOVLB  0
78C2:  CALL   5802
....................                 motor_run_x(x[local], 19); 
78C6:  BCF    FD8.0
78C8:  MOVLB  3
78CA:  RLCF   xAF,W
78CC:  CLRF   03
78CE:  ADDLW  2E
78D0:  MOVWF  FE9
78D2:  MOVLW  00
78D4:  ADDWFC 03,W
78D6:  MOVWF  FEA
78D8:  MOVFF  FEC,3B3
78DC:  MOVF   FED,F
78DE:  MOVFF  FEF,3B2
78E2:  CLRF   xB7
78E4:  CLRF   xB6
78E6:  MOVFF  3B3,3B5
78EA:  MOVFF  3B2,3B4
78EE:  MOVLW  13
78F0:  MOVWF  xB8
78F2:  MOVLB  0
78F4:  CALL   4AB2
....................                 while ((run_flg_x || run_flg_y)); 
78F8:  MOVLB  1
78FA:  BTFSC  x1A.3
78FC:  BRA    78FA
78FE:  BTFSC  x1A.5
7900:  BRA    78FA
....................                 ligar_alimentador_solda(ferros,t_solda[local]); 
7902:  BCF    FD8.0
7904:  MOVLB  3
7906:  RLCF   xAF,W
7908:  CLRF   03
790A:  ADDLW  A6
790C:  MOVWF  FE9
790E:  MOVLW  00
7910:  ADDWFC 03,W
7912:  MOVWF  FEA
7914:  MOVFF  FEC,3B3
7918:  MOVF   FED,F
791A:  MOVFF  FEF,3B2
791E:  MOVFF  3B1,3B4
7922:  MOVFF  3B3,3B6
7926:  MOVFF  3B2,3B5
792A:  MOVLB  0
792C:  CALL   707E
....................                 motor_run_z(z[local], 19); 
7930:  BCF    FD8.0
7932:  MOVLB  3
7934:  RLCF   xAF,W
7936:  CLRF   03
7938:  ADDLW  7E
793A:  MOVWF  FE9
793C:  MOVLW  00
793E:  ADDWFC 03,W
7940:  MOVWF  FEA
7942:  MOVFF  FEC,3B3
7946:  MOVF   FED,F
7948:  MOVFF  FEF,3B2
794C:  CLRF   xB7
794E:  CLRF   xB6
7950:  MOVFF  3B3,3B5
7954:  MOVFF  3B2,3B4
7958:  MOVLW  13
795A:  MOVWF  xB8
795C:  MOVLB  0
795E:  CALL   5638
....................                 while ((run_flg_z)); 
7962:  MOVLB  3
7964:  BTFSC  x9B.0
7966:  BRA    7964
....................                 delay_ms(t_wait[local]); 
7968:  BCF    FD8.0
796A:  RLCF   xAF,W
796C:  CLRF   03
796E:  ADDLW  CE
7970:  MOVWF  FE9
7972:  MOVLW  00
7974:  ADDWFC 03,W
7976:  MOVWF  FEA
7978:  MOVFF  FEC,3B3
797C:  MOVF   FED,F
797E:  MOVFF  FEF,3B2
7982:  MOVFF  3B3,3B4
7986:  INCF   xB4,F
7988:  DECF   xB4,F
798A:  BTFSC  FD8.2
798C:  BRA    799A
798E:  SETF   xBE
7990:  MOVLB  0
7992:  CALL   2064
7996:  MOVLB  3
7998:  BRA    7988
799A:  MOVFF  3B2,3BE
799E:  MOVLB  0
79A0:  CALL   2064
....................                 motor_run_z(z[local]-3, 19); 
79A4:  BCF    FD8.0
79A6:  MOVLB  3
79A8:  RLCF   xAF,W
79AA:  CLRF   03
79AC:  ADDLW  7E
79AE:  MOVWF  FE9
79B0:  MOVLW  00
79B2:  ADDWFC 03,W
79B4:  MOVWF  FEA
79B6:  MOVFF  FEC,3B3
79BA:  MOVF   FED,F
79BC:  MOVFF  FEF,3B2
79C0:  MOVLW  03
79C2:  SUBWF  xB2,F
79C4:  MOVLW  00
79C6:  SUBWFB xB3,F
79C8:  CLRF   xB7
79CA:  CLRF   xB6
79CC:  MOVFF  3B3,3B5
79D0:  MOVFF  3B2,3B4
79D4:  MOVLW  13
79D6:  MOVWF  xB8
79D8:  MOVLB  0
79DA:  CALL   5638
....................                 motor_run_x(x[local]-21, 19); 
79DE:  BCF    FD8.0
79E0:  MOVLB  3
79E2:  RLCF   xAF,W
79E4:  CLRF   03
79E6:  ADDLW  2E
79E8:  MOVWF  FE9
79EA:  MOVLW  00
79EC:  ADDWFC 03,W
79EE:  MOVWF  FEA
79F0:  MOVFF  FEC,3B3
79F4:  MOVF   FED,F
79F6:  MOVFF  FEF,3B2
79FA:  MOVLW  15
79FC:  SUBWF  xB2,F
79FE:  MOVLW  00
7A00:  SUBWFB xB3,F
7A02:  CLRF   xB7
7A04:  CLRF   xB6
7A06:  MOVFF  3B3,3B5
7A0A:  MOVFF  3B2,3B4
7A0E:  MOVLW  13
7A10:  MOVWF  xB8
7A12:  MOVLB  0
7A14:  CALL   4AB2
....................                 motor_run_z(z[local], 19); 
7A18:  BCF    FD8.0
7A1A:  MOVLB  3
7A1C:  RLCF   xAF,W
7A1E:  CLRF   03
7A20:  ADDLW  7E
7A22:  MOVWF  FE9
7A24:  MOVLW  00
7A26:  ADDWFC 03,W
7A28:  MOVWF  FEA
7A2A:  MOVFF  FEC,3B3
7A2E:  MOVF   FED,F
7A30:  MOVFF  FEF,3B2
7A34:  CLRF   xB7
7A36:  CLRF   xB6
7A38:  MOVFF  3B3,3B5
7A3C:  MOVFF  3B2,3B4
7A40:  MOVLW  13
7A42:  MOVWF  xB8
7A44:  MOVLB  0
7A46:  CALL   5638
....................                 while ((run_flg_x || run_flg_z)); 
7A4A:  MOVLB  1
7A4C:  BTFSC  x1A.3
7A4E:  BRA    7A4C
7A50:  MOVLB  3
7A52:  BTFSS  x9B.0
7A54:  BRA    7A5A
7A56:  MOVLB  0
7A58:  BRA    7A4A
....................                 delay_ms(t_wait[local]);   
7A5A:  BCF    FD8.0
7A5C:  RLCF   xAF,W
7A5E:  CLRF   03
7A60:  ADDLW  CE
7A62:  MOVWF  FE9
7A64:  MOVLW  00
7A66:  ADDWFC 03,W
7A68:  MOVWF  FEA
7A6A:  MOVFF  FEC,3B3
7A6E:  MOVF   FED,F
7A70:  MOVFF  FEF,3B2
7A74:  MOVFF  3B3,3B4
7A78:  INCF   xB4,F
7A7A:  DECF   xB4,F
7A7C:  BTFSC  FD8.2
7A7E:  BRA    7A8C
7A80:  SETF   xBE
7A82:  MOVLB  0
7A84:  CALL   2064
7A88:  MOVLB  3
7A8A:  BRA    7A7A
7A8C:  MOVFF  3B2,3BE
7A90:  MOVLB  0
7A92:  CALL   2064
....................                 motor_run_z(z[local]-3, 19); 
7A96:  BCF    FD8.0
7A98:  MOVLB  3
7A9A:  RLCF   xAF,W
7A9C:  CLRF   03
7A9E:  ADDLW  7E
7AA0:  MOVWF  FE9
7AA2:  MOVLW  00
7AA4:  ADDWFC 03,W
7AA6:  MOVWF  FEA
7AA8:  MOVFF  FEC,3B3
7AAC:  MOVF   FED,F
7AAE:  MOVFF  FEF,3B2
7AB2:  MOVLW  03
7AB4:  SUBWF  xB2,F
7AB6:  MOVLW  00
7AB8:  SUBWFB xB3,F
7ABA:  CLRF   xB7
7ABC:  CLRF   xB6
7ABE:  MOVFF  3B3,3B5
7AC2:  MOVFF  3B2,3B4
7AC6:  MOVLW  13
7AC8:  MOVWF  xB8
7ACA:  MOVLB  0
7ACC:  CALL   5638
....................                 motor_run_x(x[local]-42, 19); 
7AD0:  BCF    FD8.0
7AD2:  MOVLB  3
7AD4:  RLCF   xAF,W
7AD6:  CLRF   03
7AD8:  ADDLW  2E
7ADA:  MOVWF  FE9
7ADC:  MOVLW  00
7ADE:  ADDWFC 03,W
7AE0:  MOVWF  FEA
7AE2:  MOVFF  FEC,3B3
7AE6:  MOVF   FED,F
7AE8:  MOVFF  FEF,3B2
7AEC:  MOVLW  2A
7AEE:  SUBWF  xB2,F
7AF0:  MOVLW  00
7AF2:  SUBWFB xB3,F
7AF4:  CLRF   xB7
7AF6:  CLRF   xB6
7AF8:  MOVFF  3B3,3B5
7AFC:  MOVFF  3B2,3B4
7B00:  MOVLW  13
7B02:  MOVWF  xB8
7B04:  MOVLB  0
7B06:  CALL   4AB2
....................                 motor_run_z(z[local], 19); 
7B0A:  BCF    FD8.0
7B0C:  MOVLB  3
7B0E:  RLCF   xAF,W
7B10:  CLRF   03
7B12:  ADDLW  7E
7B14:  MOVWF  FE9
7B16:  MOVLW  00
7B18:  ADDWFC 03,W
7B1A:  MOVWF  FEA
7B1C:  MOVFF  FEC,3B3
7B20:  MOVF   FED,F
7B22:  MOVFF  FEF,3B2
7B26:  CLRF   xB7
7B28:  CLRF   xB6
7B2A:  MOVFF  3B3,3B5
7B2E:  MOVFF  3B2,3B4
7B32:  MOVLW  13
7B34:  MOVWF  xB8
7B36:  MOVLB  0
7B38:  CALL   5638
....................                 while ((run_flg_x || run_flg_z)); 
7B3C:  MOVLB  1
7B3E:  BTFSC  x1A.3
7B40:  BRA    7B3E
7B42:  MOVLB  3
7B44:  BTFSS  x9B.0
7B46:  BRA    7B4C
7B48:  MOVLB  0
7B4A:  BRA    7B3C
....................                 delay_ms(t_wait[local]); 
7B4C:  BCF    FD8.0
7B4E:  RLCF   xAF,W
7B50:  CLRF   03
7B52:  ADDLW  CE
7B54:  MOVWF  FE9
7B56:  MOVLW  00
7B58:  ADDWFC 03,W
7B5A:  MOVWF  FEA
7B5C:  MOVFF  FEC,3B3
7B60:  MOVF   FED,F
7B62:  MOVFF  FEF,3B2
7B66:  MOVFF  3B3,3B4
7B6A:  INCF   xB4,F
7B6C:  DECF   xB4,F
7B6E:  BTFSC  FD8.2
7B70:  BRA    7B7E
7B72:  SETF   xBE
7B74:  MOVLB  0
7B76:  CALL   2064
7B7A:  MOVLB  3
7B7C:  BRA    7B6C
7B7E:  MOVFF  3B2,3BE
7B82:  MOVLB  0
7B84:  CALL   2064
....................                 motor_run_z(z[local]-3, 19); 
7B88:  BCF    FD8.0
7B8A:  MOVLB  3
7B8C:  RLCF   xAF,W
7B8E:  CLRF   03
7B90:  ADDLW  7E
7B92:  MOVWF  FE9
7B94:  MOVLW  00
7B96:  ADDWFC 03,W
7B98:  MOVWF  FEA
7B9A:  MOVFF  FEC,3B3
7B9E:  MOVF   FED,F
7BA0:  MOVFF  FEF,3B2
7BA4:  MOVLW  03
7BA6:  SUBWF  xB2,F
7BA8:  MOVLW  00
7BAA:  SUBWFB xB3,F
7BAC:  CLRF   xB7
7BAE:  CLRF   xB6
7BB0:  MOVFF  3B3,3B5
7BB4:  MOVFF  3B2,3B4
7BB8:  MOVLW  13
7BBA:  MOVWF  xB8
7BBC:  MOVLB  0
7BBE:  CALL   5638
....................                 motor_run_z(z[local]+40, 19); 
7BC2:  BCF    FD8.0
7BC4:  MOVLB  3
7BC6:  RLCF   xAF,W
7BC8:  CLRF   03
7BCA:  ADDLW  7E
7BCC:  MOVWF  FE9
7BCE:  MOVLW  00
7BD0:  ADDWFC 03,W
7BD2:  MOVWF  FEA
7BD4:  MOVFF  FEC,3B3
7BD8:  MOVF   FED,F
7BDA:  MOVFF  FEF,3B2
7BDE:  MOVLW  28
7BE0:  ADDWF  xB2,F
7BE2:  MOVLW  00
7BE4:  ADDWFC xB3,F
7BE6:  CLRF   xB7
7BE8:  CLRF   xB6
7BEA:  MOVFF  3B3,3B5
7BEE:  MOVFF  3B2,3B4
7BF2:  MOVLW  13
7BF4:  MOVWF  xB8
7BF6:  MOVLB  0
7BF8:  CALL   5638
....................                 motor_run_z(0, 19); 
7BFC:  MOVLB  3
7BFE:  CLRF   xB7
7C00:  CLRF   xB6
7C02:  CLRF   xB5
7C04:  CLRF   xB4
7C06:  MOVLW  13
7C08:  MOVWF  xB8
7C0A:  MOVLB  0
7C0C:  CALL   5638
....................                 while ((run_flg_x || run_flg_z)); 
7C10:  MOVLB  1
7C12:  BTFSC  x1A.3
7C14:  BRA    7C12
7C16:  MOVLB  3
7C18:  BTFSS  x9B.0
7C1A:  BRA    7C20
7C1C:  MOVLB  0
7C1E:  BRA    7C10
....................             break; 
7C20:  BRA    7C24
7C22:  MOVLB  3
....................         } 
....................     } 
7C24:  BRA    7C6A
....................     else { 
....................         printf(lcd_putc, "\f"); //limpa display 
7C26:  MOVLW  0C
7C28:  MOVWF  xBD
7C2A:  MOVLB  0
7C2C:  CALL   2436
....................         printf(lcd_putc, "  POSICAO IRREGULAR \n\r"); 
7C30:  MOVLW  D2
7C32:  MOVWF  FF6
7C34:  MOVLW  0D
7C36:  MOVWF  FF7
7C38:  CALL   248A
....................         printf(lcd_putc, "   X DEVE SER > 0   \n\r"); 
7C3C:  MOVLW  EA
7C3E:  MOVWF  FF6
7C40:  MOVLW  0D
7C42:  MOVWF  FF7
7C44:  CALL   248A
....................         printf(lcd_putc, "  Y DEVE SER > 700  \n\r"); 
7C48:  MOVLW  02
7C4A:  MOVWF  FF6
7C4C:  MOVLW  0E
7C4E:  MOVWF  FF7
7C50:  CALL   248A
....................         delay_ms(5000); 
7C54:  MOVLW  14
7C56:  MOVLB  3
7C58:  MOVWF  xB2
7C5A:  MOVLW  FA
7C5C:  MOVWF  xBE
7C5E:  MOVLB  0
7C60:  CALL   2064
7C64:  MOVLB  3
7C66:  DECFSZ xB2,F
7C68:  BRA    7C5A
....................     } 
....................     sobe_ferros(ferros); 
7C6A:  MOVFF  3B1,3B2
7C6E:  MOVLB  0
7C70:  CALL   6D26
7C74:  GOTO   843E (RETURN)
.................... } //void soldar_teste(tipo[contador_lcd], contador_lcd) 
.................... void soldar(void){ 
....................     int q; 
....................     int ferros; 
....................     q = (pontos_no_modelo/2); 
*
9662:  BCF    FD8.0
9664:  MOVLB  1
9666:  RRCF   x0A,W
9668:  MOVLB  3
966A:  MOVWF  xAF
....................     for(int i=0; i < pontos_no_modelo; i++){ 
966C:  CLRF   xB1
966E:  MOVLB  1
9670:  MOVF   x0A,W
9672:  MOVLB  3
9674:  SUBWF  xB1,W
9676:  BTFSC  FD8.0
9678:  GOTO   A228
....................         if (i<q){ 
967C:  MOVF   xAF,W
967E:  SUBWF  xB1,W
9680:  BC    9688
....................             ferros = 3; 
9682:  MOVLW  03
9684:  MOVWF  xB0
....................         } else { 
9686:  BRA    968C
....................             ferros = 2; 
9688:  MOVLW  02
968A:  MOVWF  xB0
....................         } 
....................         desce_ferros(ferros); 
968C:  MOVFF  3B0,3B2
9690:  MOVLB  0
9692:  CALL   6D62
....................         if (i == 0){ 
9696:  MOVLB  3
9698:  MOVF   xB1,F
969A:  BNZ   96B0
....................             ligar_alimentador_solda(ferros,700); 
969C:  MOVFF  3B0,3B4
96A0:  MOVLW  02
96A2:  MOVWF  xB6
96A4:  MOVLW  BC
96A6:  MOVWF  xB5
96A8:  MOVLB  0
96AA:  CALL   707E
96AE:  MOVLB  3
....................         } 
....................         if (habilitado[i] == TRUE) { 
96B0:  MOVFF  3B1,3B5
96B4:  MOVLW  01
96B6:  MOVWF  xB7
96B8:  MOVLW  0B
96BA:  MOVWF  xB6
96BC:  MOVLB  0
96BE:  CALL   3A5C
96C2:  MOVF   01,W
96C4:  ANDLW  01
96C6:  SUBLW  01
96C8:  BTFSS  FD8.2
96CA:  GOTO   A214
....................             switch (tipo[i]){ 
96CE:  CLRF   03
96D0:  MOVLB  3
96D2:  MOVF   xB1,W
96D4:  ADDLW  F6
96D6:  MOVWF  FE9
96D8:  MOVLW  00
96DA:  ADDWFC 03,W
96DC:  MOVWF  FEA
96DE:  MOVF   FEF,W
96E0:  ADDLW  FC
96E2:  BTFSC  FD8.0
96E4:  GOTO   A216
96E8:  ADDLW  04
96EA:  MOVLB  0
96EC:  GOTO   A22E
....................                 case 0: 
....................                     motor_run_y(y[i], 19); 
96F0:  BCF    FD8.0
96F2:  MOVLB  3
96F4:  RLCF   xB1,W
96F6:  CLRF   03
96F8:  ADDLW  56
96FA:  MOVWF  FE9
96FC:  MOVLW  00
96FE:  ADDWFC 03,W
9700:  MOVWF  FEA
9702:  MOVFF  FEC,3B3
9706:  MOVF   FED,F
9708:  MOVFF  FEF,3B2
970C:  CLRF   xB7
970E:  CLRF   xB6
9710:  MOVFF  3B3,3B5
9714:  MOVFF  3B2,3B4
9718:  MOVLW  13
971A:  MOVWF  xB8
971C:  MOVLB  0
971E:  CALL   5802
....................                     motor_run_x(x[i], 19); 
9722:  BCF    FD8.0
9724:  MOVLB  3
9726:  RLCF   xB1,W
9728:  CLRF   03
972A:  ADDLW  2E
972C:  MOVWF  FE9
972E:  MOVLW  00
9730:  ADDWFC 03,W
9732:  MOVWF  FEA
9734:  MOVFF  FEC,3B3
9738:  MOVF   FED,F
973A:  MOVFF  FEF,3B2
973E:  CLRF   xB7
9740:  CLRF   xB6
9742:  MOVFF  3B3,3B5
9746:  MOVFF  3B2,3B4
974A:  MOVLW  13
974C:  MOVWF  xB8
974E:  MOVLB  0
9750:  CALL   4AB2
....................                     while ((run_flg_x || run_flg_y)); 
9754:  MOVLB  1
9756:  BTFSC  x1A.3
9758:  BRA    9756
975A:  BTFSC  x1A.5
975C:  BRA    9756
....................                     if (habilitado[0] == 0){ 
975E:  BTFSC  x0B.0
9760:  BRA    9782
....................                         if (i == q){ 
9762:  MOVLB  3
9764:  MOVF   xAF,W
9766:  SUBWF  xB1,W
9768:  BNZ   977E
....................                             ligar_alimentador_solda(ferros,700); 
976A:  MOVFF  3B0,3B4
976E:  MOVLW  02
9770:  MOVWF  xB6
9772:  MOVLW  BC
9774:  MOVWF  xB5
9776:  MOVLB  0
9778:  CALL   707E
977C:  MOVLB  3
....................                         } 
....................                     } else { 
977E:  BRA    979C
9780:  MOVLB  1
....................                         if(i == 0){ 
9782:  MOVLB  3
9784:  MOVF   xB1,F
9786:  BNZ   979C
....................                             ligar_alimentador_solda(ferros,700); 
9788:  MOVFF  3B0,3B4
978C:  MOVLW  02
978E:  MOVWF  xB6
9790:  MOVLW  BC
9792:  MOVWF  xB5
9794:  MOVLB  0
9796:  CALL   707E
979A:  MOVLB  3
....................                         } 
....................                     } 
....................                     ligar_alimentador_solda(ferros,t_solda[i]); 
979C:  BCF    FD8.0
979E:  RLCF   xB1,W
97A0:  CLRF   03
97A2:  ADDLW  A6
97A4:  MOVWF  FE9
97A6:  MOVLW  00
97A8:  ADDWFC 03,W
97AA:  MOVWF  FEA
97AC:  MOVFF  FEC,3B3
97B0:  MOVF   FED,F
97B2:  MOVFF  FEF,3B2
97B6:  MOVFF  3B0,3B4
97BA:  MOVFF  3B3,3B6
97BE:  MOVFF  3B2,3B5
97C2:  MOVLB  0
97C4:  CALL   707E
....................                     motor_run_z(z[i], 19); 
97C8:  BCF    FD8.0
97CA:  MOVLB  3
97CC:  RLCF   xB1,W
97CE:  CLRF   03
97D0:  ADDLW  7E
97D2:  MOVWF  FE9
97D4:  MOVLW  00
97D6:  ADDWFC 03,W
97D8:  MOVWF  FEA
97DA:  MOVFF  FEC,3B3
97DE:  MOVF   FED,F
97E0:  MOVFF  FEF,3B2
97E4:  CLRF   xB7
97E6:  CLRF   xB6
97E8:  MOVFF  3B3,3B5
97EC:  MOVFF  3B2,3B4
97F0:  MOVLW  13
97F2:  MOVWF  xB8
97F4:  MOVLB  0
97F6:  CALL   5638
....................                     while ((run_flg_z)); 
97FA:  MOVLB  3
97FC:  BTFSC  x9B.0
97FE:  BRA    97FC
....................                     delay_ms(t_wait[i]);  
9800:  BCF    FD8.0
9802:  RLCF   xB1,W
9804:  CLRF   03
9806:  ADDLW  CE
9808:  MOVWF  FE9
980A:  MOVLW  00
980C:  ADDWFC 03,W
980E:  MOVWF  FEA
9810:  MOVFF  FEC,3B3
9814:  MOVF   FED,F
9816:  MOVFF  FEF,3B2
981A:  MOVFF  3B3,3B4
981E:  INCF   xB4,F
9820:  DECF   xB4,F
9822:  BTFSC  FD8.2
9824:  BRA    9832
9826:  SETF   xBE
9828:  MOVLB  0
982A:  CALL   2064
982E:  MOVLB  3
9830:  BRA    9820
9832:  MOVFF  3B2,3BE
9836:  MOVLB  0
9838:  CALL   2064
....................                     motor_run_z(0, 19); 
983C:  MOVLB  3
983E:  CLRF   xB7
9840:  CLRF   xB6
9842:  CLRF   xB5
9844:  CLRF   xB4
9846:  MOVLW  13
9848:  MOVWF  xB8
984A:  MOVLB  0
984C:  CALL   5638
....................                     while ((run_flg_z)); 
9850:  MOVLB  3
9852:  BTFSC  x9B.0
9854:  BRA    9852
....................                 break; 
9856:  GOTO   A216
....................                 case 1: 
....................                     motor_run_y(y[i], 19); 
985A:  BCF    FD8.0
985C:  MOVLB  3
985E:  RLCF   xB1,W
9860:  CLRF   03
9862:  ADDLW  56
9864:  MOVWF  FE9
9866:  MOVLW  00
9868:  ADDWFC 03,W
986A:  MOVWF  FEA
986C:  MOVFF  FEC,3B3
9870:  MOVF   FED,F
9872:  MOVFF  FEF,3B2
9876:  CLRF   xB7
9878:  CLRF   xB6
987A:  MOVFF  3B3,3B5
987E:  MOVFF  3B2,3B4
9882:  MOVLW  13
9884:  MOVWF  xB8
9886:  MOVLB  0
9888:  CALL   5802
....................                     motor_run_x(x[i], 19); 
988C:  BCF    FD8.0
988E:  MOVLB  3
9890:  RLCF   xB1,W
9892:  CLRF   03
9894:  ADDLW  2E
9896:  MOVWF  FE9
9898:  MOVLW  00
989A:  ADDWFC 03,W
989C:  MOVWF  FEA
989E:  MOVFF  FEC,3B3
98A2:  MOVF   FED,F
98A4:  MOVFF  FEF,3B2
98A8:  CLRF   xB7
98AA:  CLRF   xB6
98AC:  MOVFF  3B3,3B5
98B0:  MOVFF  3B2,3B4
98B4:  MOVLW  13
98B6:  MOVWF  xB8
98B8:  MOVLB  0
98BA:  CALL   4AB2
....................                     while ((run_flg_x || run_flg_y)); 
98BE:  MOVLB  1
98C0:  BTFSC  x1A.3
98C2:  BRA    98C0
98C4:  BTFSC  x1A.5
98C6:  BRA    98C0
....................                     if (habilitado[0] == 0){ 
98C8:  BTFSC  x0B.0
98CA:  BRA    98F8
....................                         if (i == q){ 
98CC:  MOVLB  3
98CE:  MOVF   xAF,W
98D0:  SUBWF  xB1,W
98D2:  BNZ   98F4
....................                             ligar_alimentador_solda(ferros,700); 
98D4:  MOVFF  3B0,3B4
98D8:  MOVLW  02
98DA:  MOVWF  xB6
98DC:  MOVLW  BC
98DE:  MOVWF  xB5
98E0:  MOVLB  0
98E2:  CALL   707E
....................                             delay_ms(200); 
98E6:  MOVLW  C8
98E8:  MOVLB  3
98EA:  MOVWF  xBE
98EC:  MOVLB  0
98EE:  CALL   2064
98F2:  MOVLB  3
....................                         } 
....................                     } else { 
98F4:  BRA    991E
98F6:  MOVLB  1
....................                         if(i == 0){ 
98F8:  MOVLB  3
98FA:  MOVF   xB1,F
98FC:  BNZ   991E
....................                             ligar_alimentador_solda(ferros,700); 
98FE:  MOVFF  3B0,3B4
9902:  MOVLW  02
9904:  MOVWF  xB6
9906:  MOVLW  BC
9908:  MOVWF  xB5
990A:  MOVLB  0
990C:  CALL   707E
....................                             delay_ms(200); 
9910:  MOVLW  C8
9912:  MOVLB  3
9914:  MOVWF  xBE
9916:  MOVLB  0
9918:  CALL   2064
991C:  MOVLB  3
....................                         } 
....................                     } 
....................                     ligar_alimentador_solda(ferros,t_solda[i]); 
991E:  BCF    FD8.0
9920:  RLCF   xB1,W
9922:  CLRF   03
9924:  ADDLW  A6
9926:  MOVWF  FE9
9928:  MOVLW  00
992A:  ADDWFC 03,W
992C:  MOVWF  FEA
992E:  MOVFF  FEC,3B3
9932:  MOVF   FED,F
9934:  MOVFF  FEF,3B2
9938:  MOVFF  3B0,3B4
993C:  MOVFF  3B3,3B6
9940:  MOVFF  3B2,3B5
9944:  MOVLB  0
9946:  CALL   707E
....................                     motor_run_z(z[i]-20, 19); 
994A:  BCF    FD8.0
994C:  MOVLB  3
994E:  RLCF   xB1,W
9950:  CLRF   03
9952:  ADDLW  7E
9954:  MOVWF  FE9
9956:  MOVLW  00
9958:  ADDWFC 03,W
995A:  MOVWF  FEA
995C:  MOVFF  FEC,3B3
9960:  MOVF   FED,F
9962:  MOVFF  FEF,3B2
9966:  MOVLW  14
9968:  SUBWF  xB2,F
996A:  MOVLW  00
996C:  SUBWFB xB3,F
996E:  CLRF   xB7
9970:  CLRF   xB6
9972:  MOVFF  3B3,3B5
9976:  MOVFF  3B2,3B4
997A:  MOVLW  13
997C:  MOVWF  xB8
997E:  MOVLB  0
9980:  CALL   5638
....................                     motor_run_y(y[i]-30, 19); 
9984:  BCF    FD8.0
9986:  MOVLB  3
9988:  RLCF   xB1,W
998A:  CLRF   03
998C:  ADDLW  56
998E:  MOVWF  FE9
9990:  MOVLW  00
9992:  ADDWFC 03,W
9994:  MOVWF  FEA
9996:  MOVFF  FEC,3B3
999A:  MOVF   FED,F
999C:  MOVFF  FEF,3B2
99A0:  MOVLW  1E
99A2:  SUBWF  xB2,F
99A4:  MOVLW  00
99A6:  SUBWFB xB3,F
99A8:  CLRF   xB7
99AA:  CLRF   xB6
99AC:  MOVFF  3B3,3B5
99B0:  MOVFF  3B2,3B4
99B4:  MOVLW  13
99B6:  MOVWF  xB8
99B8:  MOVLB  0
99BA:  CALL   5802
....................                     motor_run_y(y[i], 19); 
99BE:  BCF    FD8.0
99C0:  MOVLB  3
99C2:  RLCF   xB1,W
99C4:  CLRF   03
99C6:  ADDLW  56
99C8:  MOVWF  FE9
99CA:  MOVLW  00
99CC:  ADDWFC 03,W
99CE:  MOVWF  FEA
99D0:  MOVFF  FEC,3B3
99D4:  MOVF   FED,F
99D6:  MOVFF  FEF,3B2
99DA:  CLRF   xB7
99DC:  CLRF   xB6
99DE:  MOVFF  3B3,3B5
99E2:  MOVFF  3B2,3B4
99E6:  MOVLW  13
99E8:  MOVWF  xB8
99EA:  MOVLB  0
99EC:  CALL   5802
....................                     motor_run_x(x[i]+10, 19); 
99F0:  BCF    FD8.0
99F2:  MOVLB  3
99F4:  RLCF   xB1,W
99F6:  CLRF   03
99F8:  ADDLW  2E
99FA:  MOVWF  FE9
99FC:  MOVLW  00
99FE:  ADDWFC 03,W
9A00:  MOVWF  FEA
9A02:  MOVFF  FEC,3B3
9A06:  MOVF   FED,F
9A08:  MOVFF  FEF,3B2
9A0C:  MOVLW  0A
9A0E:  ADDWF  xB2,F
9A10:  MOVLW  00
9A12:  ADDWFC xB3,F
9A14:  CLRF   xB7
9A16:  CLRF   xB6
9A18:  MOVFF  3B3,3B5
9A1C:  MOVFF  3B2,3B4
9A20:  MOVLW  13
9A22:  MOVWF  xB8
9A24:  MOVLB  0
9A26:  CALL   4AB2
....................                     motor_run_z(z[i], 19); 
9A2A:  BCF    FD8.0
9A2C:  MOVLB  3
9A2E:  RLCF   xB1,W
9A30:  CLRF   03
9A32:  ADDLW  7E
9A34:  MOVWF  FE9
9A36:  MOVLW  00
9A38:  ADDWFC 03,W
9A3A:  MOVWF  FEA
9A3C:  MOVFF  FEC,3B3
9A40:  MOVF   FED,F
9A42:  MOVFF  FEF,3B2
9A46:  CLRF   xB7
9A48:  CLRF   xB6
9A4A:  MOVFF  3B3,3B5
9A4E:  MOVFF  3B2,3B4
9A52:  MOVLW  13
9A54:  MOVWF  xB8
9A56:  MOVLB  0
9A58:  CALL   5638
....................                     motor_run_x(x[i], 19); 
9A5C:  BCF    FD8.0
9A5E:  MOVLB  3
9A60:  RLCF   xB1,W
9A62:  CLRF   03
9A64:  ADDLW  2E
9A66:  MOVWF  FE9
9A68:  MOVLW  00
9A6A:  ADDWFC 03,W
9A6C:  MOVWF  FEA
9A6E:  MOVFF  FEC,3B3
9A72:  MOVF   FED,F
9A74:  MOVFF  FEF,3B2
9A78:  CLRF   xB7
9A7A:  CLRF   xB6
9A7C:  MOVFF  3B3,3B5
9A80:  MOVFF  3B2,3B4
9A84:  MOVLW  13
9A86:  MOVWF  xB8
9A88:  MOVLB  0
9A8A:  CALL   4AB2
....................                     while ((run_flg_x || run_flg_y || run_flg_z)); 
9A8E:  MOVLB  1
9A90:  BTFSC  x1A.3
9A92:  BRA    9A90
9A94:  BTFSC  x1A.5
9A96:  BRA    9A90
9A98:  MOVLB  3
9A9A:  BTFSS  x9B.0
9A9C:  BRA    9AA2
9A9E:  MOVLB  0
9AA0:  BRA    9A8E
....................                     delay_ms(t_wait[i]);              
9AA2:  BCF    FD8.0
9AA4:  RLCF   xB1,W
9AA6:  CLRF   03
9AA8:  ADDLW  CE
9AAA:  MOVWF  FE9
9AAC:  MOVLW  00
9AAE:  ADDWFC 03,W
9AB0:  MOVWF  FEA
9AB2:  MOVFF  FEC,3B3
9AB6:  MOVF   FED,F
9AB8:  MOVFF  FEF,3B2
9ABC:  MOVFF  3B3,3B4
9AC0:  INCF   xB4,F
9AC2:  DECF   xB4,F
9AC4:  BTFSC  FD8.2
9AC6:  BRA    9AD4
9AC8:  SETF   xBE
9ACA:  MOVLB  0
9ACC:  CALL   2064
9AD0:  MOVLB  3
9AD2:  BRA    9AC2
9AD4:  MOVFF  3B2,3BE
9AD8:  MOVLB  0
9ADA:  CALL   2064
....................                     motor_run_z(0, 19); 
9ADE:  MOVLB  3
9AE0:  CLRF   xB7
9AE2:  CLRF   xB6
9AE4:  CLRF   xB5
9AE6:  CLRF   xB4
9AE8:  MOVLW  13
9AEA:  MOVWF  xB8
9AEC:  MOVLB  0
9AEE:  CALL   5638
....................                     while ((run_flg_z)); 
9AF2:  MOVLB  3
9AF4:  BTFSC  x9B.0
9AF6:  BRA    9AF4
....................                 break; 
9AF8:  BRA    A216
....................                 case 2: 
....................                     motor_run_y(y[i], 19); 
9AFA:  BCF    FD8.0
9AFC:  MOVLB  3
9AFE:  RLCF   xB1,W
9B00:  CLRF   03
9B02:  ADDLW  56
9B04:  MOVWF  FE9
9B06:  MOVLW  00
9B08:  ADDWFC 03,W
9B0A:  MOVWF  FEA
9B0C:  MOVFF  FEC,3B3
9B10:  MOVF   FED,F
9B12:  MOVFF  FEF,3B2
9B16:  CLRF   xB7
9B18:  CLRF   xB6
9B1A:  MOVFF  3B3,3B5
9B1E:  MOVFF  3B2,3B4
9B22:  MOVLW  13
9B24:  MOVWF  xB8
9B26:  MOVLB  0
9B28:  CALL   5802
....................                     motor_run_x(x[i], 19); 
9B2C:  BCF    FD8.0
9B2E:  MOVLB  3
9B30:  RLCF   xB1,W
9B32:  CLRF   03
9B34:  ADDLW  2E
9B36:  MOVWF  FE9
9B38:  MOVLW  00
9B3A:  ADDWFC 03,W
9B3C:  MOVWF  FEA
9B3E:  MOVFF  FEC,3B3
9B42:  MOVF   FED,F
9B44:  MOVFF  FEF,3B2
9B48:  CLRF   xB7
9B4A:  CLRF   xB6
9B4C:  MOVFF  3B3,3B5
9B50:  MOVFF  3B2,3B4
9B54:  MOVLW  13
9B56:  MOVWF  xB8
9B58:  MOVLB  0
9B5A:  CALL   4AB2
....................                     while ((run_flg_x || run_flg_y)); 
9B5E:  MOVLB  1
9B60:  BTFSC  x1A.3
9B62:  BRA    9B60
9B64:  BTFSC  x1A.5
9B66:  BRA    9B60
....................                     if (habilitado[0] == 0){ 
9B68:  BTFSC  x0B.0
9B6A:  BRA    9B8C
....................                         if (i == q){ 
9B6C:  MOVLB  3
9B6E:  MOVF   xAF,W
9B70:  SUBWF  xB1,W
9B72:  BNZ   9B88
....................                             ligar_alimentador_solda(ferros,700); 
9B74:  MOVFF  3B0,3B4
9B78:  MOVLW  02
9B7A:  MOVWF  xB6
9B7C:  MOVLW  BC
9B7E:  MOVWF  xB5
9B80:  MOVLB  0
9B82:  CALL   707E
9B86:  MOVLB  3
....................                         } 
....................                     } else { 
9B88:  BRA    9BA6
9B8A:  MOVLB  1
....................                         if(i == 0){ 
9B8C:  MOVLB  3
9B8E:  MOVF   xB1,F
9B90:  BNZ   9BA6
....................                             ligar_alimentador_solda(ferros,700); 
9B92:  MOVFF  3B0,3B4
9B96:  MOVLW  02
9B98:  MOVWF  xB6
9B9A:  MOVLW  BC
9B9C:  MOVWF  xB5
9B9E:  MOVLB  0
9BA0:  CALL   707E
9BA4:  MOVLB  3
....................                         } 
....................                     } 
....................                     ligar_alimentador_solda(ferros,t_solda[i]); 
9BA6:  BCF    FD8.0
9BA8:  RLCF   xB1,W
9BAA:  CLRF   03
9BAC:  ADDLW  A6
9BAE:  MOVWF  FE9
9BB0:  MOVLW  00
9BB2:  ADDWFC 03,W
9BB4:  MOVWF  FEA
9BB6:  MOVFF  FEC,3B3
9BBA:  MOVF   FED,F
9BBC:  MOVFF  FEF,3B2
9BC0:  MOVFF  3B0,3B4
9BC4:  MOVFF  3B3,3B6
9BC8:  MOVFF  3B2,3B5
9BCC:  MOVLB  0
9BCE:  CALL   707E
....................                     motor_run_z(z[i], 19); 
9BD2:  BCF    FD8.0
9BD4:  MOVLB  3
9BD6:  RLCF   xB1,W
9BD8:  CLRF   03
9BDA:  ADDLW  7E
9BDC:  MOVWF  FE9
9BDE:  MOVLW  00
9BE0:  ADDWFC 03,W
9BE2:  MOVWF  FEA
9BE4:  MOVFF  FEC,3B3
9BE8:  MOVF   FED,F
9BEA:  MOVFF  FEF,3B2
9BEE:  CLRF   xB7
9BF0:  CLRF   xB6
9BF2:  MOVFF  3B3,3B5
9BF6:  MOVFF  3B2,3B4
9BFA:  MOVLW  13
9BFC:  MOVWF  xB8
9BFE:  MOVLB  0
9C00:  CALL   5638
....................                     while ((run_flg_z)); 
9C04:  MOVLB  3
9C06:  BTFSC  x9B.0
9C08:  BRA    9C06
....................                     delay_ms(t_wait[i]); 
9C0A:  BCF    FD8.0
9C0C:  RLCF   xB1,W
9C0E:  CLRF   03
9C10:  ADDLW  CE
9C12:  MOVWF  FE9
9C14:  MOVLW  00
9C16:  ADDWFC 03,W
9C18:  MOVWF  FEA
9C1A:  MOVFF  FEC,3B3
9C1E:  MOVF   FED,F
9C20:  MOVFF  FEF,3B2
9C24:  MOVFF  3B3,3B4
9C28:  INCF   xB4,F
9C2A:  DECF   xB4,F
9C2C:  BTFSC  FD8.2
9C2E:  BRA    9C3C
9C30:  SETF   xBE
9C32:  MOVLB  0
9C34:  CALL   2064
9C38:  MOVLB  3
9C3A:  BRA    9C2A
9C3C:  MOVFF  3B2,3BE
9C40:  MOVLB  0
9C42:  CALL   2064
....................                     motor_run_z(z[i]-3, 19); 
9C46:  BCF    FD8.0
9C48:  MOVLB  3
9C4A:  RLCF   xB1,W
9C4C:  CLRF   03
9C4E:  ADDLW  7E
9C50:  MOVWF  FE9
9C52:  MOVLW  00
9C54:  ADDWFC 03,W
9C56:  MOVWF  FEA
9C58:  MOVFF  FEC,3B3
9C5C:  MOVF   FED,F
9C5E:  MOVFF  FEF,3B2
9C62:  MOVLW  03
9C64:  SUBWF  xB2,F
9C66:  MOVLW  00
9C68:  SUBWFB xB3,F
9C6A:  CLRF   xB7
9C6C:  CLRF   xB6
9C6E:  MOVFF  3B3,3B5
9C72:  MOVFF  3B2,3B4
9C76:  MOVLW  13
9C78:  MOVWF  xB8
9C7A:  MOVLB  0
9C7C:  CALL   5638
....................                     motor_run_x(x[i]-10, 19); 
9C80:  BCF    FD8.0
9C82:  MOVLB  3
9C84:  RLCF   xB1,W
9C86:  CLRF   03
9C88:  ADDLW  2E
9C8A:  MOVWF  FE9
9C8C:  MOVLW  00
9C8E:  ADDWFC 03,W
9C90:  MOVWF  FEA
9C92:  MOVFF  FEC,3B3
9C96:  MOVF   FED,F
9C98:  MOVFF  FEF,3B2
9C9C:  MOVLW  0A
9C9E:  SUBWF  xB2,F
9CA0:  MOVLW  00
9CA2:  SUBWFB xB3,F
9CA4:  CLRF   xB7
9CA6:  CLRF   xB6
9CA8:  MOVFF  3B3,3B5
9CAC:  MOVFF  3B2,3B4
9CB0:  MOVLW  13
9CB2:  MOVWF  xB8
9CB4:  MOVLB  0
9CB6:  CALL   4AB2
....................                     motor_run_z(z[i], 19); 
9CBA:  BCF    FD8.0
9CBC:  MOVLB  3
9CBE:  RLCF   xB1,W
9CC0:  CLRF   03
9CC2:  ADDLW  7E
9CC4:  MOVWF  FE9
9CC6:  MOVLW  00
9CC8:  ADDWFC 03,W
9CCA:  MOVWF  FEA
9CCC:  MOVFF  FEC,3B3
9CD0:  MOVF   FED,F
9CD2:  MOVFF  FEF,3B2
9CD6:  CLRF   xB7
9CD8:  CLRF   xB6
9CDA:  MOVFF  3B3,3B5
9CDE:  MOVFF  3B2,3B4
9CE2:  MOVLW  13
9CE4:  MOVWF  xB8
9CE6:  MOVLB  0
9CE8:  CALL   5638
....................                     while ((run_flg_x || run_flg_y || run_flg_z)); 
9CEC:  MOVLB  1
9CEE:  BTFSC  x1A.3
9CF0:  BRA    9CEE
9CF2:  BTFSC  x1A.5
9CF4:  BRA    9CEE
9CF6:  MOVLB  3
9CF8:  BTFSS  x9B.0
9CFA:  BRA    9D00
9CFC:  MOVLB  0
9CFE:  BRA    9CEC
....................                     delay_ms(t_wait[i]);   
9D00:  BCF    FD8.0
9D02:  RLCF   xB1,W
9D04:  CLRF   03
9D06:  ADDLW  CE
9D08:  MOVWF  FE9
9D0A:  MOVLW  00
9D0C:  ADDWFC 03,W
9D0E:  MOVWF  FEA
9D10:  MOVFF  FEC,3B3
9D14:  MOVF   FED,F
9D16:  MOVFF  FEF,3B2
9D1A:  MOVFF  3B3,3B4
9D1E:  INCF   xB4,F
9D20:  DECF   xB4,F
9D22:  BTFSC  FD8.2
9D24:  BRA    9D32
9D26:  SETF   xBE
9D28:  MOVLB  0
9D2A:  CALL   2064
9D2E:  MOVLB  3
9D30:  BRA    9D20
9D32:  MOVFF  3B2,3BE
9D36:  MOVLB  0
9D38:  CALL   2064
....................                     motor_run_z(z[i]-3, 19); 
9D3C:  BCF    FD8.0
9D3E:  MOVLB  3
9D40:  RLCF   xB1,W
9D42:  CLRF   03
9D44:  ADDLW  7E
9D46:  MOVWF  FE9
9D48:  MOVLW  00
9D4A:  ADDWFC 03,W
9D4C:  MOVWF  FEA
9D4E:  MOVFF  FEC,3B3
9D52:  MOVF   FED,F
9D54:  MOVFF  FEF,3B2
9D58:  MOVLW  03
9D5A:  SUBWF  xB2,F
9D5C:  MOVLW  00
9D5E:  SUBWFB xB3,F
9D60:  CLRF   xB7
9D62:  CLRF   xB6
9D64:  MOVFF  3B3,3B5
9D68:  MOVFF  3B2,3B4
9D6C:  MOVLW  13
9D6E:  MOVWF  xB8
9D70:  MOVLB  0
9D72:  CALL   5638
....................                     motor_run_x(x[i]+10, 19); 
9D76:  BCF    FD8.0
9D78:  MOVLB  3
9D7A:  RLCF   xB1,W
9D7C:  CLRF   03
9D7E:  ADDLW  2E
9D80:  MOVWF  FE9
9D82:  MOVLW  00
9D84:  ADDWFC 03,W
9D86:  MOVWF  FEA
9D88:  MOVFF  FEC,3B3
9D8C:  MOVF   FED,F
9D8E:  MOVFF  FEF,3B2
9D92:  MOVLW  0A
9D94:  ADDWF  xB2,F
9D96:  MOVLW  00
9D98:  ADDWFC xB3,F
9D9A:  CLRF   xB7
9D9C:  CLRF   xB6
9D9E:  MOVFF  3B3,3B5
9DA2:  MOVFF  3B2,3B4
9DA6:  MOVLW  13
9DA8:  MOVWF  xB8
9DAA:  MOVLB  0
9DAC:  CALL   4AB2
....................                     motor_run_z(z[i], 19); 
9DB0:  BCF    FD8.0
9DB2:  MOVLB  3
9DB4:  RLCF   xB1,W
9DB6:  CLRF   03
9DB8:  ADDLW  7E
9DBA:  MOVWF  FE9
9DBC:  MOVLW  00
9DBE:  ADDWFC 03,W
9DC0:  MOVWF  FEA
9DC2:  MOVFF  FEC,3B3
9DC6:  MOVF   FED,F
9DC8:  MOVFF  FEF,3B2
9DCC:  CLRF   xB7
9DCE:  CLRF   xB6
9DD0:  MOVFF  3B3,3B5
9DD4:  MOVFF  3B2,3B4
9DD8:  MOVLW  13
9DDA:  MOVWF  xB8
9DDC:  MOVLB  0
9DDE:  CALL   5638
....................                     while ((run_flg_x || run_flg_z)); 
9DE2:  MOVLB  1
9DE4:  BTFSC  x1A.3
9DE6:  BRA    9DE4
9DE8:  MOVLB  3
9DEA:  BTFSS  x9B.0
9DEC:  BRA    9DF2
9DEE:  MOVLB  0
9DF0:  BRA    9DE2
....................                     delay_ms(t_wait[i]); 
9DF2:  BCF    FD8.0
9DF4:  RLCF   xB1,W
9DF6:  CLRF   03
9DF8:  ADDLW  CE
9DFA:  MOVWF  FE9
9DFC:  MOVLW  00
9DFE:  ADDWFC 03,W
9E00:  MOVWF  FEA
9E02:  MOVFF  FEC,3B3
9E06:  MOVF   FED,F
9E08:  MOVFF  FEF,3B2
9E0C:  MOVFF  3B3,3B4
9E10:  INCF   xB4,F
9E12:  DECF   xB4,F
9E14:  BTFSC  FD8.2
9E16:  BRA    9E24
9E18:  SETF   xBE
9E1A:  MOVLB  0
9E1C:  CALL   2064
9E20:  MOVLB  3
9E22:  BRA    9E12
9E24:  MOVFF  3B2,3BE
9E28:  MOVLB  0
9E2A:  CALL   2064
....................                     motor_run_z(0, 19); 
9E2E:  MOVLB  3
9E30:  CLRF   xB7
9E32:  CLRF   xB6
9E34:  CLRF   xB5
9E36:  CLRF   xB4
9E38:  MOVLW  13
9E3A:  MOVWF  xB8
9E3C:  MOVLB  0
9E3E:  CALL   5638
....................                     while ((run_flg_z));                     
9E42:  MOVLB  3
9E44:  BTFSC  x9B.0
9E46:  BRA    9E44
....................                 break; 
9E48:  BRA    A216
....................                 case 3:                     
....................                     motor_run_y(y[i], 19); 
9E4A:  BCF    FD8.0
9E4C:  MOVLB  3
9E4E:  RLCF   xB1,W
9E50:  CLRF   03
9E52:  ADDLW  56
9E54:  MOVWF  FE9
9E56:  MOVLW  00
9E58:  ADDWFC 03,W
9E5A:  MOVWF  FEA
9E5C:  MOVFF  FEC,3B3
9E60:  MOVF   FED,F
9E62:  MOVFF  FEF,3B2
9E66:  CLRF   xB7
9E68:  CLRF   xB6
9E6A:  MOVFF  3B3,3B5
9E6E:  MOVFF  3B2,3B4
9E72:  MOVLW  13
9E74:  MOVWF  xB8
9E76:  MOVLB  0
9E78:  CALL   5802
....................                     motor_run_x(x[i], 19); 
9E7C:  BCF    FD8.0
9E7E:  MOVLB  3
9E80:  RLCF   xB1,W
9E82:  CLRF   03
9E84:  ADDLW  2E
9E86:  MOVWF  FE9
9E88:  MOVLW  00
9E8A:  ADDWFC 03,W
9E8C:  MOVWF  FEA
9E8E:  MOVFF  FEC,3B3
9E92:  MOVF   FED,F
9E94:  MOVFF  FEF,3B2
9E98:  CLRF   xB7
9E9A:  CLRF   xB6
9E9C:  MOVFF  3B3,3B5
9EA0:  MOVFF  3B2,3B4
9EA4:  MOVLW  13
9EA6:  MOVWF  xB8
9EA8:  MOVLB  0
9EAA:  CALL   4AB2
....................                     while ((run_flg_x || run_flg_y)); 
9EAE:  MOVLB  1
9EB0:  BTFSC  x1A.3
9EB2:  BRA    9EB0
9EB4:  BTFSC  x1A.5
9EB6:  BRA    9EB0
....................                     if (habilitado[0] == 0){ 
9EB8:  BTFSC  x0B.0
9EBA:  BRA    9EDC
....................                         if (i == q){ 
9EBC:  MOVLB  3
9EBE:  MOVF   xAF,W
9EC0:  SUBWF  xB1,W
9EC2:  BNZ   9ED8
....................                             ligar_alimentador_solda(ferros,700); 
9EC4:  MOVFF  3B0,3B4
9EC8:  MOVLW  02
9ECA:  MOVWF  xB6
9ECC:  MOVLW  BC
9ECE:  MOVWF  xB5
9ED0:  MOVLB  0
9ED2:  CALL   707E
9ED6:  MOVLB  3
....................                         } 
....................                     } else { 
9ED8:  BRA    9EF6
9EDA:  MOVLB  1
....................                         if(i == 0){ 
9EDC:  MOVLB  3
9EDE:  MOVF   xB1,F
9EE0:  BNZ   9EF6
....................                             ligar_alimentador_solda(ferros,700); 
9EE2:  MOVFF  3B0,3B4
9EE6:  MOVLW  02
9EE8:  MOVWF  xB6
9EEA:  MOVLW  BC
9EEC:  MOVWF  xB5
9EEE:  MOVLB  0
9EF0:  CALL   707E
9EF4:  MOVLB  3
....................                         } 
....................                     } 
....................                     ligar_alimentador_solda(ferros,t_solda[i]); 
9EF6:  BCF    FD8.0
9EF8:  RLCF   xB1,W
9EFA:  CLRF   03
9EFC:  ADDLW  A6
9EFE:  MOVWF  FE9
9F00:  MOVLW  00
9F02:  ADDWFC 03,W
9F04:  MOVWF  FEA
9F06:  MOVFF  FEC,3B3
9F0A:  MOVF   FED,F
9F0C:  MOVFF  FEF,3B2
9F10:  MOVFF  3B0,3B4
9F14:  MOVFF  3B3,3B6
9F18:  MOVFF  3B2,3B5
9F1C:  MOVLB  0
9F1E:  CALL   707E
....................                     motor_run_z(z[i], 19); 
9F22:  BCF    FD8.0
9F24:  MOVLB  3
9F26:  RLCF   xB1,W
9F28:  CLRF   03
9F2A:  ADDLW  7E
9F2C:  MOVWF  FE9
9F2E:  MOVLW  00
9F30:  ADDWFC 03,W
9F32:  MOVWF  FEA
9F34:  MOVFF  FEC,3B3
9F38:  MOVF   FED,F
9F3A:  MOVFF  FEF,3B2
9F3E:  CLRF   xB7
9F40:  CLRF   xB6
9F42:  MOVFF  3B3,3B5
9F46:  MOVFF  3B2,3B4
9F4A:  MOVLW  13
9F4C:  MOVWF  xB8
9F4E:  MOVLB  0
9F50:  CALL   5638
....................                     while ((run_flg_z)); 
9F54:  MOVLB  3
9F56:  BTFSC  x9B.0
9F58:  BRA    9F56
....................                     delay_ms(t_wait[i]); 
9F5A:  BCF    FD8.0
9F5C:  RLCF   xB1,W
9F5E:  CLRF   03
9F60:  ADDLW  CE
9F62:  MOVWF  FE9
9F64:  MOVLW  00
9F66:  ADDWFC 03,W
9F68:  MOVWF  FEA
9F6A:  MOVFF  FEC,3B3
9F6E:  MOVF   FED,F
9F70:  MOVFF  FEF,3B2
9F74:  MOVFF  3B3,3B4
9F78:  INCF   xB4,F
9F7A:  DECF   xB4,F
9F7C:  BTFSC  FD8.2
9F7E:  BRA    9F8C
9F80:  SETF   xBE
9F82:  MOVLB  0
9F84:  CALL   2064
9F88:  MOVLB  3
9F8A:  BRA    9F7A
9F8C:  MOVFF  3B2,3BE
9F90:  MOVLB  0
9F92:  CALL   2064
....................                     motor_run_z(z[i]-3, 19); 
9F96:  BCF    FD8.0
9F98:  MOVLB  3
9F9A:  RLCF   xB1,W
9F9C:  CLRF   03
9F9E:  ADDLW  7E
9FA0:  MOVWF  FE9
9FA2:  MOVLW  00
9FA4:  ADDWFC 03,W
9FA6:  MOVWF  FEA
9FA8:  MOVFF  FEC,3B3
9FAC:  MOVF   FED,F
9FAE:  MOVFF  FEF,3B2
9FB2:  MOVLW  03
9FB4:  SUBWF  xB2,F
9FB6:  MOVLW  00
9FB8:  SUBWFB xB3,F
9FBA:  CLRF   xB7
9FBC:  CLRF   xB6
9FBE:  MOVFF  3B3,3B5
9FC2:  MOVFF  3B2,3B4
9FC6:  MOVLW  13
9FC8:  MOVWF  xB8
9FCA:  MOVLB  0
9FCC:  CALL   5638
....................                     motor_run_x(x[i]-21, 19); 
9FD0:  BCF    FD8.0
9FD2:  MOVLB  3
9FD4:  RLCF   xB1,W
9FD6:  CLRF   03
9FD8:  ADDLW  2E
9FDA:  MOVWF  FE9
9FDC:  MOVLW  00
9FDE:  ADDWFC 03,W
9FE0:  MOVWF  FEA
9FE2:  MOVFF  FEC,3B3
9FE6:  MOVF   FED,F
9FE8:  MOVFF  FEF,3B2
9FEC:  MOVLW  15
9FEE:  SUBWF  xB2,F
9FF0:  MOVLW  00
9FF2:  SUBWFB xB3,F
9FF4:  CLRF   xB7
9FF6:  CLRF   xB6
9FF8:  MOVFF  3B3,3B5
9FFC:  MOVFF  3B2,3B4
A000:  MOVLW  13
A002:  MOVWF  xB8
A004:  MOVLB  0
A006:  CALL   4AB2
....................                     motor_run_z(z[i], 19); 
A00A:  BCF    FD8.0
A00C:  MOVLB  3
A00E:  RLCF   xB1,W
A010:  CLRF   03
A012:  ADDLW  7E
A014:  MOVWF  FE9
A016:  MOVLW  00
A018:  ADDWFC 03,W
A01A:  MOVWF  FEA
A01C:  MOVFF  FEC,3B3
A020:  MOVF   FED,F
A022:  MOVFF  FEF,3B2
A026:  CLRF   xB7
A028:  CLRF   xB6
A02A:  MOVFF  3B3,3B5
A02E:  MOVFF  3B2,3B4
A032:  MOVLW  13
A034:  MOVWF  xB8
A036:  MOVLB  0
A038:  CALL   5638
....................                     while ((run_flg_x || run_flg_z)); 
A03C:  MOVLB  1
A03E:  BTFSC  x1A.3
A040:  BRA    A03E
A042:  MOVLB  3
A044:  BTFSS  x9B.0
A046:  BRA    A04C
A048:  MOVLB  0
A04A:  BRA    A03C
....................                     delay_ms(t_wait[i]);   
A04C:  BCF    FD8.0
A04E:  RLCF   xB1,W
A050:  CLRF   03
A052:  ADDLW  CE
A054:  MOVWF  FE9
A056:  MOVLW  00
A058:  ADDWFC 03,W
A05A:  MOVWF  FEA
A05C:  MOVFF  FEC,3B3
A060:  MOVF   FED,F
A062:  MOVFF  FEF,3B2
A066:  MOVFF  3B3,3B4
A06A:  INCF   xB4,F
A06C:  DECF   xB4,F
A06E:  BTFSC  FD8.2
A070:  BRA    A07E
A072:  SETF   xBE
A074:  MOVLB  0
A076:  CALL   2064
A07A:  MOVLB  3
A07C:  BRA    A06C
A07E:  MOVFF  3B2,3BE
A082:  MOVLB  0
A084:  CALL   2064
....................                     motor_run_z(z[i]-3, 19); 
A088:  BCF    FD8.0
A08A:  MOVLB  3
A08C:  RLCF   xB1,W
A08E:  CLRF   03
A090:  ADDLW  7E
A092:  MOVWF  FE9
A094:  MOVLW  00
A096:  ADDWFC 03,W
A098:  MOVWF  FEA
A09A:  MOVFF  FEC,3B3
A09E:  MOVF   FED,F
A0A0:  MOVFF  FEF,3B2
A0A4:  MOVLW  03
A0A6:  SUBWF  xB2,F
A0A8:  MOVLW  00
A0AA:  SUBWFB xB3,F
A0AC:  CLRF   xB7
A0AE:  CLRF   xB6
A0B0:  MOVFF  3B3,3B5
A0B4:  MOVFF  3B2,3B4
A0B8:  MOVLW  13
A0BA:  MOVWF  xB8
A0BC:  MOVLB  0
A0BE:  CALL   5638
....................                     motor_run_x(x[i]-42, 19); 
A0C2:  BCF    FD8.0
A0C4:  MOVLB  3
A0C6:  RLCF   xB1,W
A0C8:  CLRF   03
A0CA:  ADDLW  2E
A0CC:  MOVWF  FE9
A0CE:  MOVLW  00
A0D0:  ADDWFC 03,W
A0D2:  MOVWF  FEA
A0D4:  MOVFF  FEC,3B3
A0D8:  MOVF   FED,F
A0DA:  MOVFF  FEF,3B2
A0DE:  MOVLW  2A
A0E0:  SUBWF  xB2,F
A0E2:  MOVLW  00
A0E4:  SUBWFB xB3,F
A0E6:  CLRF   xB7
A0E8:  CLRF   xB6
A0EA:  MOVFF  3B3,3B5
A0EE:  MOVFF  3B2,3B4
A0F2:  MOVLW  13
A0F4:  MOVWF  xB8
A0F6:  MOVLB  0
A0F8:  CALL   4AB2
....................                     motor_run_z(z[i], 19); 
A0FC:  BCF    FD8.0
A0FE:  MOVLB  3
A100:  RLCF   xB1,W
A102:  CLRF   03
A104:  ADDLW  7E
A106:  MOVWF  FE9
A108:  MOVLW  00
A10A:  ADDWFC 03,W
A10C:  MOVWF  FEA
A10E:  MOVFF  FEC,3B3
A112:  MOVF   FED,F
A114:  MOVFF  FEF,3B2
A118:  CLRF   xB7
A11A:  CLRF   xB6
A11C:  MOVFF  3B3,3B5
A120:  MOVFF  3B2,3B4
A124:  MOVLW  13
A126:  MOVWF  xB8
A128:  MOVLB  0
A12A:  CALL   5638
....................                     while ((run_flg_x || run_flg_z)); 
A12E:  MOVLB  1
A130:  BTFSC  x1A.3
A132:  BRA    A130
A134:  MOVLB  3
A136:  BTFSS  x9B.0
A138:  BRA    A13E
A13A:  MOVLB  0
A13C:  BRA    A12E
....................                     delay_ms(t_wait[i]); 
A13E:  BCF    FD8.0
A140:  RLCF   xB1,W
A142:  CLRF   03
A144:  ADDLW  CE
A146:  MOVWF  FE9
A148:  MOVLW  00
A14A:  ADDWFC 03,W
A14C:  MOVWF  FEA
A14E:  MOVFF  FEC,3B3
A152:  MOVF   FED,F
A154:  MOVFF  FEF,3B2
A158:  MOVFF  3B3,3B4
A15C:  INCF   xB4,F
A15E:  DECF   xB4,F
A160:  BTFSC  FD8.2
A162:  BRA    A170
A164:  SETF   xBE
A166:  MOVLB  0
A168:  CALL   2064
A16C:  MOVLB  3
A16E:  BRA    A15E
A170:  MOVFF  3B2,3BE
A174:  MOVLB  0
A176:  CALL   2064
....................                     motor_run_z(z[i]-3, 19); 
A17A:  BCF    FD8.0
A17C:  MOVLB  3
A17E:  RLCF   xB1,W
A180:  CLRF   03
A182:  ADDLW  7E
A184:  MOVWF  FE9
A186:  MOVLW  00
A188:  ADDWFC 03,W
A18A:  MOVWF  FEA
A18C:  MOVFF  FEC,3B3
A190:  MOVF   FED,F
A192:  MOVFF  FEF,3B2
A196:  MOVLW  03
A198:  SUBWF  xB2,F
A19A:  MOVLW  00
A19C:  SUBWFB xB3,F
A19E:  CLRF   xB7
A1A0:  CLRF   xB6
A1A2:  MOVFF  3B3,3B5
A1A6:  MOVFF  3B2,3B4
A1AA:  MOVLW  13
A1AC:  MOVWF  xB8
A1AE:  MOVLB  0
A1B0:  CALL   5638
....................                     motor_run_z(z[i]+40, 19); 
A1B4:  BCF    FD8.0
A1B6:  MOVLB  3
A1B8:  RLCF   xB1,W
A1BA:  CLRF   03
A1BC:  ADDLW  7E
A1BE:  MOVWF  FE9
A1C0:  MOVLW  00
A1C2:  ADDWFC 03,W
A1C4:  MOVWF  FEA
A1C6:  MOVFF  FEC,3B3
A1CA:  MOVF   FED,F
A1CC:  MOVFF  FEF,3B2
A1D0:  MOVLW  28
A1D2:  ADDWF  xB2,F
A1D4:  MOVLW  00
A1D6:  ADDWFC xB3,F
A1D8:  CLRF   xB7
A1DA:  CLRF   xB6
A1DC:  MOVFF  3B3,3B5
A1E0:  MOVFF  3B2,3B4
A1E4:  MOVLW  13
A1E6:  MOVWF  xB8
A1E8:  MOVLB  0
A1EA:  CALL   5638
....................                     motor_run_z(0, 19); 
A1EE:  MOVLB  3
A1F0:  CLRF   xB7
A1F2:  CLRF   xB6
A1F4:  CLRF   xB5
A1F6:  CLRF   xB4
A1F8:  MOVLW  13
A1FA:  MOVWF  xB8
A1FC:  MOVLB  0
A1FE:  CALL   5638
....................                     while ((run_flg_x || run_flg_z));                     
A202:  MOVLB  1
A204:  BTFSC  x1A.3
A206:  BRA    A204
A208:  MOVLB  3
A20A:  BTFSS  x9B.0
A20C:  BRA    A212
A20E:  MOVLB  0
A210:  BRA    A202
....................                 break; 
A212:  BRA    A216
A214:  MOVLB  3
....................             } 
....................         } 
....................         sobe_ferros(ferros); 
A216:  MOVFF  3B0,3B2
A21A:  MOVLB  0
A21C:  CALL   6D26
A220:  MOVLB  3
A222:  INCF   xB1,F
A224:  GOTO   966E
....................     } 
A228:  MOVLB  0
A22A:  GOTO   A4B4 (RETURN)
.................... } 
....................  
.................... #include "Modelos_maq_1.c" 
.................... int tamPrograma = 221; 
....................  
.................... void ler_modelo_memoria(int modeloSelecionado){ 
*
5296:  MOVLB  3
5298:  CLRF   xAE
529A:  CLRF   xAF
529C:  MOVLW  01
529E:  SUBWF  xAD,W
52A0:  MULWF  xAC
52A2:  MOVF   FF3,W
52A4:  CLRF   xB1
52A6:  MOVWF  xB0
....................     int i = 0; 
....................     int j = 0; 
....................     long int endInicial = (modeloSelecionado - 1)* tamPrograma; 
....................     pontos_no_modelo = read_ext_eeprom(endInicial); 
52A8:  MOVFF  3B1,3B8
52AC:  MOVFF  3B0,3B7
52B0:  MOVLB  0
52B2:  CALL   232C
52B6:  MOVFF  01,10A
....................     endInicial++; 
52BA:  MOVLB  3
52BC:  INCF   xB0,F
52BE:  BTFSC  FD8.2
52C0:  INCF   xB1,F
....................     for(i = endInicial; i < (endInicial + tamPrograma) -1; i = i + 11) 
52C2:  MOVFF  3B0,3AE
52C6:  MOVF   xAC,W
52C8:  ADDWF  xB0,W
52CA:  MOVWF  xB3
52CC:  MOVLW  00
52CE:  ADDWFC xB1,W
52D0:  MOVWF  xB4
52D2:  MOVLW  01
52D4:  SUBWF  xB3,W
52D6:  MOVWF  00
52D8:  MOVLW  00
52DA:  SUBWFB xB4,W
52DC:  MOVWF  03
52DE:  MOVFF  00,01
52E2:  MOVF   03,F
52E4:  BNZ   52EE
52E6:  MOVF   01,W
52E8:  SUBWF  xAE,W
52EA:  BTFSC  FD8.0
52EC:  BRA    54D0
....................     { 
....................         x[j] = make16(read_ext_eeprom(i),read_ext_eeprom(i+1)); 
52EE:  BCF    FD8.0
52F0:  RLCF   xAF,W
52F2:  CLRF   03
52F4:  ADDLW  2E
52F6:  MOVWF  01
52F8:  MOVLW  00
52FA:  ADDWFC 03,F
52FC:  MOVFF  01,3B3
5300:  MOVFF  03,3B4
5304:  CLRF   xB8
5306:  MOVFF  3AE,3B7
530A:  MOVLB  0
530C:  CALL   232C
5310:  MOVFF  01,3B5
5314:  MOVLW  01
5316:  MOVLB  3
5318:  ADDWF  xAE,W
531A:  MOVWF  xB6
531C:  CLRF   xB8
531E:  MOVWF  xB7
5320:  MOVLB  0
5322:  CALL   232C
5326:  MOVFF  3B4,FEA
532A:  MOVFF  3B3,FE9
532E:  MOVFF  3B5,FEC
5332:  MOVF   FED,F
5334:  MOVFF  01,FEF
....................         y[j] = make16(read_ext_eeprom(i+2),read_ext_eeprom(i+3)); 
5338:  BCF    FD8.0
533A:  MOVLB  3
533C:  RLCF   xAF,W
533E:  CLRF   03
5340:  ADDLW  56
5342:  MOVWF  01
5344:  MOVLW  00
5346:  ADDWFC 03,F
5348:  MOVFF  01,3B3
534C:  MOVFF  03,3B4
5350:  MOVLW  02
5352:  ADDWF  xAE,W
5354:  MOVWF  xB5
5356:  CLRF   xB8
5358:  MOVWF  xB7
535A:  MOVLB  0
535C:  CALL   232C
5360:  MOVFF  01,3B5
5364:  MOVLW  03
5366:  MOVLB  3
5368:  ADDWF  xAE,W
536A:  MOVWF  xB6
536C:  CLRF   xB8
536E:  MOVWF  xB7
5370:  MOVLB  0
5372:  CALL   232C
5376:  MOVFF  3B4,FEA
537A:  MOVFF  3B3,FE9
537E:  MOVFF  3B5,FEC
5382:  MOVF   FED,F
5384:  MOVFF  01,FEF
....................         z[j] = make16(read_ext_eeprom(i+4),read_ext_eeprom(i+5)); 
5388:  BCF    FD8.0
538A:  MOVLB  3
538C:  RLCF   xAF,W
538E:  CLRF   03
5390:  ADDLW  7E
5392:  MOVWF  01
5394:  MOVLW  00
5396:  ADDWFC 03,F
5398:  MOVFF  01,3B3
539C:  MOVFF  03,3B4
53A0:  MOVLW  04
53A2:  ADDWF  xAE,W
53A4:  MOVWF  xB5
53A6:  CLRF   xB8
53A8:  MOVWF  xB7
53AA:  MOVLB  0
53AC:  CALL   232C
53B0:  MOVFF  01,3B5
53B4:  MOVLW  05
53B6:  MOVLB  3
53B8:  ADDWF  xAE,W
53BA:  MOVWF  xB6
53BC:  CLRF   xB8
53BE:  MOVWF  xB7
53C0:  MOVLB  0
53C2:  CALL   232C
53C6:  MOVFF  3B4,FEA
53CA:  MOVFF  3B3,FE9
53CE:  MOVFF  3B5,FEC
53D2:  MOVF   FED,F
53D4:  MOVFF  01,FEF
....................         t_solda[j] = make16(read_ext_eeprom(i+6),read_ext_eeprom(i+7)); 
53D8:  BCF    FD8.0
53DA:  MOVLB  3
53DC:  RLCF   xAF,W
53DE:  CLRF   03
53E0:  ADDLW  A6
53E2:  MOVWF  01
53E4:  MOVLW  00
53E6:  ADDWFC 03,F
53E8:  MOVFF  01,3B3
53EC:  MOVFF  03,3B4
53F0:  MOVLW  06
53F2:  ADDWF  xAE,W
53F4:  MOVWF  xB5
53F6:  CLRF   xB8
53F8:  MOVWF  xB7
53FA:  MOVLB  0
53FC:  CALL   232C
5400:  MOVFF  01,3B5
5404:  MOVLW  07
5406:  MOVLB  3
5408:  ADDWF  xAE,W
540A:  MOVWF  xB6
540C:  CLRF   xB8
540E:  MOVWF  xB7
5410:  MOVLB  0
5412:  CALL   232C
5416:  MOVFF  3B4,FEA
541A:  MOVFF  3B3,FE9
541E:  MOVFF  3B5,FEC
5422:  MOVF   FED,F
5424:  MOVFF  01,FEF
....................         t_wait[j] = make16(read_ext_eeprom(i+8),read_ext_eeprom(i+9)); 
5428:  BCF    FD8.0
542A:  MOVLB  3
542C:  RLCF   xAF,W
542E:  CLRF   03
5430:  ADDLW  CE
5432:  MOVWF  01
5434:  MOVLW  00
5436:  ADDWFC 03,F
5438:  MOVFF  01,3B3
543C:  MOVFF  03,3B4
5440:  MOVLW  08
5442:  ADDWF  xAE,W
5444:  MOVWF  xB5
5446:  CLRF   xB8
5448:  MOVWF  xB7
544A:  MOVLB  0
544C:  CALL   232C
5450:  MOVFF  01,3B5
5454:  MOVLW  09
5456:  MOVLB  3
5458:  ADDWF  xAE,W
545A:  MOVWF  xB6
545C:  CLRF   xB8
545E:  MOVWF  xB7
5460:  MOVLB  0
5462:  CALL   232C
5466:  MOVFF  3B4,FEA
546A:  MOVFF  3B3,FE9
546E:  MOVFF  3B5,FEC
5472:  MOVF   FED,F
5474:  MOVFF  01,FEF
....................         int tipoHabilitado = read_ext_eeprom(i+10); 
5478:  MOVLW  0A
547A:  MOVLB  3
547C:  ADDWF  xAE,W
547E:  MOVWF  xB3
5480:  CLRF   xB8
5482:  MOVWF  xB7
5484:  MOVLB  0
5486:  CALL   232C
548A:  MOVFF  01,3B2
....................         tipo[j] = (tipoHabilitado & 0x06)>>1; 
548E:  CLRF   03
5490:  MOVLB  3
5492:  MOVF   xAF,W
5494:  ADDLW  F6
5496:  MOVWF  FE9
5498:  MOVLW  00
549A:  ADDWFC 03,W
549C:  MOVWF  FEA
549E:  MOVF   xB2,W
54A0:  ANDLW  06
54A2:  MOVWF  00
54A4:  BCF    FD8.0
54A6:  RRCF   00,F
54A8:  MOVFF  00,FEF
....................         habilitado[j] = tipoHabilitado & 0x01; 
54AC:  MOVF   xB2,W
54AE:  ANDLW  01
54B0:  MOVWF  xB3
54B2:  MOVFF  3AF,3B5
54B6:  MOVWF  xB6
54B8:  MOVLW  01
54BA:  MOVWF  xB8
54BC:  MOVLW  0B
54BE:  MOVWF  xB7
54C0:  MOVLB  0
54C2:  CALL   3A1A
....................         j++; 
54C6:  MOVLB  3
54C8:  INCF   xAF,F
54CA:  MOVLW  0B
54CC:  ADDWF  xAE,F
54CE:  BRA    52C6
....................     } 
54D0:  MOVLB  0
54D2:  RETURN 0
.................... } //ler_modelo_memoria(modelo)) 
.................... void escrever_ponto_memoria(int modeloSelecionado, int pontoSelecionado){ 
*
6D9E:  MOVLW  01
6DA0:  MOVLB  3
6DA2:  SUBWF  xAD,W
6DA4:  MULWF  xAC
6DA6:  MOVFF  FF3,3B1
6DAA:  MOVF   xAE,W
6DAC:  MULLW  0B
6DAE:  MOVF   FF3,W
6DB0:  ADDWF  xB1,W
6DB2:  MOVWF  xAF
6DB4:  CLRF   xB0
....................     long int endInicial = ((modeloSelecionado - 1)*tamPrograma) + (pontoSelecionado*11); 
....................     write_ext_eeprom(endInicial+1,((x[pontoSelecionado]&0xff00)>>8));\ 
6DB6:  MOVLW  01
6DB8:  ADDWF  xAF,W
6DBA:  MOVWF  xB1
6DBC:  MOVLW  00
6DBE:  ADDWFC xB0,W
6DC0:  MOVWF  xB2
6DC2:  BCF    FD8.0
6DC4:  RLCF   xAE,W
6DC6:  CLRF   03
6DC8:  ADDLW  2E
6DCA:  MOVWF  FE9
6DCC:  MOVLW  00
6DCE:  ADDWFC 03,W
6DD0:  MOVWF  FEA
6DD2:  MOVFF  FEC,3B4
6DD6:  MOVF   FED,F
6DD8:  MOVFF  FEF,3B3
6DDC:  CLRF   xB3
6DDE:  MOVFF  3B4,3B3
6DE2:  CLRF   xB4
6DE4:  MOVFF  3B2,3B6
6DE8:  MOVFF  3B1,3B5
6DEC:  MOVFF  3B3,3B7
6DF0:  MOVLB  0
6DF2:  CALL   220E
....................     write_ext_eeprom(endInicial+2,(x[pontoSelecionado]&0x00ff)); 
6DF6:  MOVLW  02
6DF8:  MOVLB  3
6DFA:  ADDWF  xAF,W
6DFC:  MOVWF  xB1
6DFE:  MOVLW  00
6E00:  ADDWFC xB0,W
6E02:  MOVWF  xB2
6E04:  BCF    FD8.0
6E06:  RLCF   xAE,W
6E08:  CLRF   03
6E0A:  ADDLW  2E
6E0C:  MOVWF  FE9
6E0E:  MOVLW  00
6E10:  ADDWFC 03,W
6E12:  MOVWF  FEA
6E14:  MOVFF  FEC,3B4
6E18:  MOVF   FED,F
6E1A:  MOVFF  FEF,3B3
6E1E:  CLRF   xB4
6E20:  MOVFF  3B2,3B6
6E24:  MOVFF  3B1,3B5
6E28:  MOVFF  3B3,3B7
6E2C:  MOVLB  0
6E2E:  CALL   220E
....................     write_ext_eeprom(endInicial+3,((y[pontoSelecionado]&0xff00)>>8)); 
6E32:  MOVLW  03
6E34:  MOVLB  3
6E36:  ADDWF  xAF,W
6E38:  MOVWF  xB1
6E3A:  MOVLW  00
6E3C:  ADDWFC xB0,W
6E3E:  MOVWF  xB2
6E40:  BCF    FD8.0
6E42:  RLCF   xAE,W
6E44:  CLRF   03
6E46:  ADDLW  56
6E48:  MOVWF  FE9
6E4A:  MOVLW  00
6E4C:  ADDWFC 03,W
6E4E:  MOVWF  FEA
6E50:  MOVFF  FEC,3B4
6E54:  MOVF   FED,F
6E56:  MOVFF  FEF,3B3
6E5A:  CLRF   xB3
6E5C:  MOVFF  3B4,3B3
6E60:  CLRF   xB4
6E62:  MOVFF  3B2,3B6
6E66:  MOVFF  3B1,3B5
6E6A:  MOVFF  3B3,3B7
6E6E:  MOVLB  0
6E70:  CALL   220E
....................     write_ext_eeprom(endInicial+4,(y[pontoSelecionado]&0x00ff)); 
6E74:  MOVLW  04
6E76:  MOVLB  3
6E78:  ADDWF  xAF,W
6E7A:  MOVWF  xB1
6E7C:  MOVLW  00
6E7E:  ADDWFC xB0,W
6E80:  MOVWF  xB2
6E82:  BCF    FD8.0
6E84:  RLCF   xAE,W
6E86:  CLRF   03
6E88:  ADDLW  56
6E8A:  MOVWF  FE9
6E8C:  MOVLW  00
6E8E:  ADDWFC 03,W
6E90:  MOVWF  FEA
6E92:  MOVFF  FEC,3B4
6E96:  MOVF   FED,F
6E98:  MOVFF  FEF,3B3
6E9C:  CLRF   xB4
6E9E:  MOVFF  3B2,3B6
6EA2:  MOVFF  3B1,3B5
6EA6:  MOVFF  3B3,3B7
6EAA:  MOVLB  0
6EAC:  CALL   220E
....................     write_ext_eeprom(endInicial+5,((z[pontoSelecionado]&0xff00)>>8)); 
6EB0:  MOVLW  05
6EB2:  MOVLB  3
6EB4:  ADDWF  xAF,W
6EB6:  MOVWF  xB1
6EB8:  MOVLW  00
6EBA:  ADDWFC xB0,W
6EBC:  MOVWF  xB2
6EBE:  BCF    FD8.0
6EC0:  RLCF   xAE,W
6EC2:  CLRF   03
6EC4:  ADDLW  7E
6EC6:  MOVWF  FE9
6EC8:  MOVLW  00
6ECA:  ADDWFC 03,W
6ECC:  MOVWF  FEA
6ECE:  MOVFF  FEC,3B4
6ED2:  MOVF   FED,F
6ED4:  MOVFF  FEF,3B3
6ED8:  CLRF   xB3
6EDA:  MOVFF  3B4,3B3
6EDE:  CLRF   xB4
6EE0:  MOVFF  3B2,3B6
6EE4:  MOVFF  3B1,3B5
6EE8:  MOVFF  3B3,3B7
6EEC:  MOVLB  0
6EEE:  CALL   220E
....................     write_ext_eeprom(endInicial+6,(z[pontoSelecionado]&0x00ff)); 
6EF2:  MOVLW  06
6EF4:  MOVLB  3
6EF6:  ADDWF  xAF,W
6EF8:  MOVWF  xB1
6EFA:  MOVLW  00
6EFC:  ADDWFC xB0,W
6EFE:  MOVWF  xB2
6F00:  BCF    FD8.0
6F02:  RLCF   xAE,W
6F04:  CLRF   03
6F06:  ADDLW  7E
6F08:  MOVWF  FE9
6F0A:  MOVLW  00
6F0C:  ADDWFC 03,W
6F0E:  MOVWF  FEA
6F10:  MOVFF  FEC,3B4
6F14:  MOVF   FED,F
6F16:  MOVFF  FEF,3B3
6F1A:  CLRF   xB4
6F1C:  MOVFF  3B2,3B6
6F20:  MOVFF  3B1,3B5
6F24:  MOVFF  3B3,3B7
6F28:  MOVLB  0
6F2A:  CALL   220E
....................     write_ext_eeprom(endInicial+7,((t_solda[pontoSelecionado]&0xff00)>>8)); 
6F2E:  MOVLW  07
6F30:  MOVLB  3
6F32:  ADDWF  xAF,W
6F34:  MOVWF  xB1
6F36:  MOVLW  00
6F38:  ADDWFC xB0,W
6F3A:  MOVWF  xB2
6F3C:  BCF    FD8.0
6F3E:  RLCF   xAE,W
6F40:  CLRF   03
6F42:  ADDLW  A6
6F44:  MOVWF  FE9
6F46:  MOVLW  00
6F48:  ADDWFC 03,W
6F4A:  MOVWF  FEA
6F4C:  MOVFF  FEC,3B4
6F50:  MOVF   FED,F
6F52:  MOVFF  FEF,3B3
6F56:  CLRF   xB3
6F58:  MOVFF  3B4,3B3
6F5C:  CLRF   xB4
6F5E:  MOVFF  3B2,3B6
6F62:  MOVFF  3B1,3B5
6F66:  MOVFF  3B3,3B7
6F6A:  MOVLB  0
6F6C:  CALL   220E
....................     write_ext_eeprom(endInicial+8,(t_solda[pontoSelecionado]&0x00ff)); 
6F70:  MOVLW  08
6F72:  MOVLB  3
6F74:  ADDWF  xAF,W
6F76:  MOVWF  xB1
6F78:  MOVLW  00
6F7A:  ADDWFC xB0,W
6F7C:  MOVWF  xB2
6F7E:  BCF    FD8.0
6F80:  RLCF   xAE,W
6F82:  CLRF   03
6F84:  ADDLW  A6
6F86:  MOVWF  FE9
6F88:  MOVLW  00
6F8A:  ADDWFC 03,W
6F8C:  MOVWF  FEA
6F8E:  MOVFF  FEC,3B4
6F92:  MOVF   FED,F
6F94:  MOVFF  FEF,3B3
6F98:  CLRF   xB4
6F9A:  MOVFF  3B2,3B6
6F9E:  MOVFF  3B1,3B5
6FA2:  MOVFF  3B3,3B7
6FA6:  MOVLB  0
6FA8:  CALL   220E
....................     write_ext_eeprom(endInicial+9,((t_wait[pontoSelecionado]&0xff00)>>8)); 
6FAC:  MOVLW  09
6FAE:  MOVLB  3
6FB0:  ADDWF  xAF,W
6FB2:  MOVWF  xB1
6FB4:  MOVLW  00
6FB6:  ADDWFC xB0,W
6FB8:  MOVWF  xB2
6FBA:  BCF    FD8.0
6FBC:  RLCF   xAE,W
6FBE:  CLRF   03
6FC0:  ADDLW  CE
6FC2:  MOVWF  FE9
6FC4:  MOVLW  00
6FC6:  ADDWFC 03,W
6FC8:  MOVWF  FEA
6FCA:  MOVFF  FEC,3B4
6FCE:  MOVF   FED,F
6FD0:  MOVFF  FEF,3B3
6FD4:  CLRF   xB3
6FD6:  MOVFF  3B4,3B3
6FDA:  CLRF   xB4
6FDC:  MOVFF  3B2,3B6
6FE0:  MOVFF  3B1,3B5
6FE4:  MOVFF  3B3,3B7
6FE8:  MOVLB  0
6FEA:  CALL   220E
....................     write_ext_eeprom(endInicial+10,(t_wait[pontoSelecionado]&0x00ff)); 
6FEE:  MOVLW  0A
6FF0:  MOVLB  3
6FF2:  ADDWF  xAF,W
6FF4:  MOVWF  xB1
6FF6:  MOVLW  00
6FF8:  ADDWFC xB0,W
6FFA:  MOVWF  xB2
6FFC:  BCF    FD8.0
6FFE:  RLCF   xAE,W
7000:  CLRF   03
7002:  ADDLW  CE
7004:  MOVWF  FE9
7006:  MOVLW  00
7008:  ADDWFC 03,W
700A:  MOVWF  FEA
700C:  MOVFF  FEC,3B4
7010:  MOVF   FED,F
7012:  MOVFF  FEF,3B3
7016:  CLRF   xB4
7018:  MOVFF  3B2,3B6
701C:  MOVFF  3B1,3B5
7020:  MOVFF  3B3,3B7
7024:  MOVLB  0
7026:  CALL   220E
....................     write_ext_eeprom(endInicial+11,(tipo[pontoSelecionado]<<1)+habilitado[pontoSelecionado]); 
702A:  MOVLW  0B
702C:  MOVLB  3
702E:  ADDWF  xAF,W
7030:  MOVWF  xB1
7032:  MOVLW  00
7034:  ADDWFC xB0,W
7036:  MOVWF  xB2
7038:  CLRF   03
703A:  MOVF   xAE,W
703C:  ADDLW  F6
703E:  MOVWF  FE9
7040:  MOVLW  00
7042:  ADDWFC 03,W
7044:  MOVWF  FEA
7046:  BCF    FD8.0
7048:  RLCF   FEF,W
704A:  MOVWF  xB3
704C:  MOVFF  3AE,3B5
7050:  MOVLW  01
7052:  MOVWF  xB7
7054:  MOVLW  0B
7056:  MOVWF  xB6
7058:  MOVLB  0
705A:  CALL   3A5C
705E:  MOVLW  00
7060:  BTFSC  01.0
7062:  MOVLW  01
7064:  MOVLB  3
7066:  ADDWF  xB3,F
7068:  MOVFF  3B2,3B6
706C:  MOVFF  3B1,3B5
7070:  MOVFF  3B3,3B7
7074:  MOVLB  0
7076:  CALL   220E
707A:  GOTO   8390 (RETURN)
.................... } //escrever_ponto_memoria(modelo,contador_lcd) 
.................... void excluir_modelo_memoria(int modeloSelecionado){ 
*
849A:  MOVLB  3
849C:  CLRF   xAE
849E:  MOVLW  01
84A0:  SUBWF  xAD,W
84A2:  MULWF  xAC
84A4:  MOVF   FF3,W
84A6:  ADDLW  01
84A8:  MOVWF  xAF
84AA:  CLRF   xB0
....................     int i = 0; 
....................     long int endInicial = ((modeloSelecionado - 1)* tamPrograma)+1;         
....................     for (i = endInicial; i< ((endInicial-1)  + tamPrograma); i++){ 
84AC:  MOVFF  3AF,3AE
84B0:  MOVLW  01
84B2:  SUBWF  xAF,W
84B4:  MOVWF  xB1
84B6:  MOVLW  00
84B8:  SUBWFB xB0,W
84BA:  MOVWF  xB2
84BC:  MOVF   xAC,W
84BE:  ADDWF  xB1,W
84C0:  MOVWF  01
84C2:  MOVLW  00
84C4:  ADDWFC xB2,W
84C6:  MOVWF  03
84C8:  MOVF   01,W
84CA:  MOVF   03,F
84CC:  BNZ   84D4
84CE:  MOVF   01,W
84D0:  SUBWF  xAE,W
84D2:  BC    84E8
....................         write_ext_eeprom(i,0);        
84D4:  CLRF   xB6
84D6:  MOVFF  3AE,3B5
84DA:  CLRF   xB7
84DC:  MOVLB  0
84DE:  CALL   220E
84E2:  MOVLB  3
84E4:  INCF   xAE,F
84E6:  BRA    84B0
....................     } 
84E8:  MOVLB  0
84EA:  GOTO   8534 (RETURN)
.................... } //excluir_modelo_memoria(modelo) 
.................... void escrever_pontos_no_modelo(int modeloSelecionado, int quantidade_pontos){ 
*
6714:  MOVLW  01
6716:  MOVLB  3
6718:  SUBWF  xAD,W
671A:  MULWF  xAC
671C:  MOVF   FF3,W
671E:  CLRF   xB0
6720:  MOVWF  xAF
....................     long int endInicial = ((modeloSelecionado - 1)*tamPrograma); 
....................     write_ext_eeprom(endInicial,pontos_no_modelo); 
6722:  MOVFF  3B0,3B6
6726:  MOVFF  3AF,3B5
672A:  MOVFF  10A,3B7
672E:  MOVLB  0
6730:  CALL   220E
6734:  GOTO   6780 (RETURN)
.................... } //escrever_pontos_no_modelo(modelo,pontos_no_modelo) 
....................  
.................... #include "att_telas_1.c" 
.................... #include "att_telas_1.h" 
.................... void atualiza_tela_principal(void); //atualizacao de tela principal: F1 para degub F2 para main 
....................  
.................... void atualiza_tela_seleciona_maquina(void); //atualiza tela de selecao de maquina f1 para maquina 1 e f2 para maquina 2 
.................... void atualiza_tela_manutencao_outra_maquina(void); //atualizacao de tela enquanto esta sendo feita manutencao na outra maquina 
.................... void atualiza_tela_edita_modelo(void); //atualizacao de tela para editar ou excluir modelo 
.................... void atualiza_tela_seleciona_debug(void); // atualizacao de tela que escolhe f1 para editar ponto e f2 para manutencao 
.................... void atualiza_tela_edita_pontos_no_modelo(void);// atualizacao de tela da edicao de pontos do modelo 
.................... void atualiza_tela_excluir_modelo(void); //atualizacao de tela que exclui o modelo 
.................... void atualiza_tela_seleciona_pontos(void); //atualizacao de tela da escolha de ponto a ser editado 
.................... void atualiza_tela_dados_ponto (void); //atualizacao de tela que age em cima da tela de dados ponto, alterando x, y, z, tempo de solda, tempo de espera, tipo e habilitado 
....................  
.................... void atualiza_tela_seleciona_manutencao (void); //atualizacao de tela de manutencao, escolhe entre entradas e saidas 
.................... void atualiza_tela_debug_entrada_1 (void); //atualizacao de tela que ao passar pro lado mostra a tela 2 de sensores ou sai ao dar esc 
.................... void atualiza_tela_debug_entrada_2 (void); ///atualizacao de tela que ao passar pro lado mostra a tela 1 ou 3 de sensores ou sai ao dar esc 
.................... void atualiza_tela_debug_entrada_3 (void); //atualizacao de tela que ao passar pro lado mostra a tela 2 de sensores ou sai ao dar esc 
.................... void atualiza_tela_debug_saida_1(void); //atualizacao de tela que podemos acionar a esteira, pinos de entrada, e o alimentador de placa 
.................... void atualiza_tela_debug_saida_2(void); //atualizacao de tela que podemos acionar o pressor da placa, pinos de saida e dispensador de placa 
.................... void atualiza_tela_debug_saida_3(void); //atualizacao de tela que podemos acionar os alimentadores de solda, limpar os bicos e acionar os ferros 
.................... void atualiza_tela_debug_saida_4(void); //atualizacao de tela que podemos realizar a movimentacao do eixo x, y, z e o flip individualmenta 
....................  
.................... void programa_principal(void); // atualizacao de tela programa principal 
....................  
....................  
.................... void atualiza_tela_principal(){ 
....................     switch (Teclado()){ 
*
5578:  RCALL  5054
557A:  MOVF   01,W
557C:  XORLW  14
557E:  BZ    558E
5580:  XORLW  07
5582:  BZ    55B4
5584:  XORLW  1D
5586:  BZ    55DC
5588:  XORLW  01
558A:  BZ    55EA
558C:  BRA    55F6
....................         case MENU: 
....................             printf(lcd_putc, "\f"); // limpa display 
558E:  MOVLW  0C
5590:  MOVLB  3
5592:  MOVWF  xBD
5594:  MOVLB  0
5596:  CALL   2436
....................             printf(lcd_putc, "  CARREGANDO MODELO \n\r"); 
559A:  MOVLW  1A
559C:  MOVWF  FF6
559E:  MOVLW  0E
55A0:  MOVWF  FF7
55A2:  CALL   248A
....................             ler_modelo_memoria(modelo); 
55A6:  MOVFF  2D,3AD
55AA:  RCALL  5296
....................             menu_atual = menu_seleciona_maquina; 
55AC:  MOVLW  01
55AE:  MOVWF  1C
....................             tela_seleciona_maquina();             
55B0:  RCALL  54D4
....................         break; 
55B2:  BRA    55F6
....................         case ENTER: 
....................             printf(lcd_putc, "\f"); // limpa display 
55B4:  MOVLW  0C
55B6:  MOVLB  3
55B8:  MOVWF  xBD
55BA:  MOVLB  0
55BC:  CALL   2436
....................             printf(lcd_putc, "  CARREGANDO MODELO \n\r"); 
55C0:  MOVLW  32
55C2:  MOVWF  FF6
55C4:  MOVLW  0E
55C6:  MOVWF  FF7
55C8:  CALL   248A
....................             ler_modelo_memoria(modelo); 
55CC:  MOVFF  2D,3AD
55D0:  RCALL  5296
....................             exit = TRUE; 
55D2:  BSF    2C.1
....................             menu_atual = menu_programa_principal; 
55D4:  MOVLW  0C
55D6:  MOVWF  1C
....................             tela_programa_principal(); 
55D8:  BRA    5512
....................         break; 
55DA:  BRA    55F6
....................         case SETA_SUPERIOR: 
....................             if (modelo < 4){ 
55DC:  MOVF   2D,W
55DE:  SUBLW  03
55E0:  BNC   55E4
....................                 modelo ++; 
55E2:  INCF   2D,F
....................             } 
....................             menu_atual = menu_principal; 
55E4:  CLRF   1C
....................             tela_principal(); 
55E6:  RCALL  4EC4
....................         break; 
55E8:  BRA    55F6
....................         case SETA_INFERIOR: 
....................             if (modelo > 1){ 
55EA:  MOVF   2D,W
55EC:  SUBLW  01
55EE:  BC    55F2
....................                 modelo --; 
55F0:  DECF   2D,F
....................             } 
....................             menu_atual = menu_principal; 
55F2:  CLRF   1C
....................             tela_principal(); 
55F4:  RCALL  4EC4
....................         break; 
....................     } 
55F6:  GOTO   A960 (RETURN)
.................... } 
....................  
.................... void atualiza_tela_seleciona_maquina(){ 
....................     switch (Teclado()){ 
*
640A:  CALL   5054
640E:  MOVF   01,W
6410:  XORLW  0A
6412:  BZ    641E
6414:  XORLW  01
6416:  BZ    6428
6418:  XORLW  19
641A:  BZ    643C
641C:  BRA    6442
....................         case F1: 
....................             menu_atual = menu_edita_modelo; 
641E:  MOVLW  0D
6420:  MOVWF  1C
....................             tela_edita_modelo();  
6422:  CALL   55FA
....................         break; 
6426:  BRA    6442
....................         case F2: 
....................             envia_maquina_para_posicao(HOME1); 
6428:  MOVLW  01
642A:  MOVLB  3
642C:  MOVWF  xAF
642E:  MOVLB  0
6430:  CALL   5A14
....................             tela_manutencao_outra_maquina(); 
6434:  BRA    63CA
....................             menu_atual = menu_manutencao_outra_maquina; 
6436:  MOVLW  07
6438:  MOVWF  1C
....................         break; 
643A:  BRA    6442
....................         case ESC: 
....................             menu_atual = menu_principal; 
643C:  CLRF   1C
....................             tela_principal(); 
643E:  CALL   4EC4
....................         break; 
....................     } 
6442:  GOTO   A968 (RETURN)
.................... } 
.................... void atualiza_tela_manutencao_outra_maquina(){ 
....................     switch(Teclado()){ 
6446:  CALL   5054
644A:  MOVF   01,W
644C:  XORLW  12
644E:  BZ    6452
6450:  BRA    6464
....................         case ESC: 
....................             envia_maquina_para_posicao(ALIMENTADOR); 
6452:  MOVLB  3
6454:  CLRF   xAF
6456:  MOVLB  0
6458:  CALL   5A14
....................             menu_atual = menu_seleciona_maquina; 
645C:  MOVLW  01
645E:  MOVWF  1C
....................             tela_seleciona_maquina(); 
6460:  CALL   54D4
....................         break; 
....................     } 
6464:  GOTO   A970 (RETURN)
.................... } 
.................... void atualiza_tela_edita_modelo(){ 
....................     switch (Teclado()){ 
*
64E6:  CALL   5054
64EA:  MOVF   01,W
64EC:  XORLW  0A
64EE:  BZ    64FA
64F0:  XORLW  01
64F2:  BZ    6502
64F4:  XORLW  19
64F6:  BZ    650A
64F8:  BRA    6512
....................         case F1: 
....................             menu_atual = menu_seleciona_debug; 
64FA:  MOVLW  02
64FC:  MOVWF  1C
....................             tela_seleciona_debug(); 
64FE:  RCALL  6468
....................         break; 
6500:  BRA    6512
....................         case F2: 
....................             menu_atual = menu_excluir_modelo; 
6502:  MOVLW  0E
6504:  MOVWF  1C
....................             tela_excluir_modelo(); 
6506:  BRA    64A6
....................         break; 
6508:  BRA    6512
....................         case ESC: 
....................             menu_atual = menu_seleciona_maquina; 
650A:  MOVLW  01
650C:  MOVWF  1C
....................             tela_seleciona_maquina(); 
650E:  CALL   54D4
....................         break; 
....................     } 
6512:  GOTO   A978 (RETURN)
.................... } 
.................... void atualiza_tela_seleciona_debug (){ 
....................     switch(Teclado()){ 
*
66CA:  CALL   5054
66CE:  MOVF   01,W
66D0:  XORLW  0A
66D2:  BZ    66E2
66D4:  XORLW  01
66D6:  BZ    66F8
66D8:  XORLW  07
66DA:  BZ    6700
66DC:  XORLW  1E
66DE:  BZ    6708
66E0:  BRA    6710
....................         case F1: 
....................             liga_pressor(); 
66E2:  RCALL  6516
....................             envia_maquina_para_posicao(HOME1); 
66E4:  MOVLW  01
66E6:  MOVLB  3
66E8:  MOVWF  xAF
66EA:  MOVLB  0
66EC:  CALL   5A14
....................             menu_atual = menu_seleciona_pontos; 
66F0:  MOVLW  0F
66F2:  MOVWF  1C
....................             tela_seleciona_pontos(); 
66F4:  RCALL  6526
....................         break; 
66F6:  BRA    6710
....................         case F2: 
....................             menu_atual = menu_seleciona_manutencao; 
66F8:  MOVLW  03
66FA:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
66FC:  RCALL  6622
....................         break; 
66FE:  BRA    6710
....................         case F3: 
....................             menu_atual = menu_edita_pontos_no_modelo; 
6700:  MOVLW  11
6702:  MOVWF  1C
....................             tela_edita_pontos_no_modelo(); 
6704:  RCALL  6660
....................         break; 
6706:  BRA    6710
....................         case ESC: 
....................             menu_atual = menu_edita_modelo; 
6708:  MOVLW  0D
670A:  MOVWF  1C
....................             tela_edita_modelo(); 
670C:  CALL   55FA
....................         break; 
....................     } 
6710:  GOTO   A980 (RETURN)
.................... } 
.................... void atualiza_tela_edita_pontos_no_modelo(){ 
....................     switch(Teclado()){ 
*
6738:  CALL   5054
673C:  MOVLW  0E
673E:  SUBWF  01,W
6740:  ADDLW  FA
6742:  BC    67B6
6744:  ADDLW  06
6746:  GOTO   67BA
....................         case SETA_SUPERIOR: 
....................             pontos_no_modelo = pontos_no_modelo + 1; 
674A:  MOVLW  01
674C:  MOVLB  1
674E:  ADDWF  x0A,F
....................             menu_atual = menu_edita_pontos_no_modelo; 
6750:  MOVLW  11
6752:  MOVWF  1C
....................             tela_edita_pontos_no_modelo(); 
6754:  MOVLB  0
6756:  RCALL  6660
....................         break; 
6758:  BRA    67B6
....................         case SETA_INFERIOR: 
....................             if (pontos_no_modelo > 0){ 
675A:  MOVLB  1
675C:  MOVF   x0A,F
675E:  BZ    6764
....................                 pontos_no_modelo = pontos_no_modelo -1; 
6760:  MOVLW  01
6762:  SUBWF  x0A,F
....................             } 
....................             menu_atual = menu_edita_pontos_no_modelo; 
6764:  MOVLW  11
6766:  MOVWF  1C
....................             tela_edita_pontos_no_modelo(); 
6768:  MOVLB  0
676A:  RCALL  6660
....................         break; 
676C:  BRA    67B6
....................         case ESC: 
....................             menu_atual = menu_seleciona_debug; 
676E:  MOVLW  02
6770:  MOVWF  1C
....................             tela_seleciona_debug(); 
6772:  RCALL  6468
....................         break; 
6774:  BRA    67B6
....................         case ENTER: 
....................             escrever_pontos_no_modelo(modelo,pontos_no_modelo); 
6776:  MOVFF  2D,3AD
677A:  MOVFF  10A,3AE
677E:  BRA    6714
....................             printf(lcd_putc, "\f"); // limpa display 
6780:  MOVLW  0C
6782:  MOVLB  3
6784:  MOVWF  xBD
6786:  MOVLB  0
6788:  CALL   2436
....................             printf(lcd_putc, "PONTOS ATUALIZADOS\n\r"); 
678C:  MOVLW  4A
678E:  MOVWF  FF6
6790:  MOVLW  0E
6792:  MOVWF  FF7
6794:  CALL   248A
....................             delay_ms(3000); 
6798:  MOVLW  0C
679A:  MOVLB  3
679C:  MOVWF  xAD
679E:  MOVLW  FA
67A0:  MOVWF  xBE
67A2:  MOVLB  0
67A4:  CALL   2064
67A8:  MOVLB  3
67AA:  DECFSZ xAD,F
67AC:  BRA    679E
....................             menu_atual = menu_seleciona_debug; 
67AE:  MOVLW  02
67B0:  MOVWF  1C
....................             tela_seleciona_debug(); 
67B2:  MOVLB  0
67B4:  RCALL  6468
....................         break; 
....................     } 
67B6:  GOTO   A988 (RETURN)
.................... } 
.................... void atualiza_tela_excluir_modelo(){ 
....................     switch (Teclado()){ 
*
84EE:  CALL   5054
84F2:  MOVF   01,W
84F4:  XORLW  13
84F6:  BZ    84FE
84F8:  XORLW  01
84FA:  BZ    856E
84FC:  BRA    8576
....................         case ENTER: 
....................             printf(lcd_putc, "\f"); // limpa display 
84FE:  MOVLW  0C
8500:  MOVLB  3
8502:  MOVWF  xBD
8504:  MOVLB  0
8506:  CALL   2436
....................             printf(lcd_putc, "  EXCLUINDO MODELO  \n\r"); 
850A:  MOVLW  60
850C:  MOVWF  FF6
850E:  MOVLW  0E
8510:  MOVWF  FF7
8512:  CALL   248A
....................             delay_ms(3000); 
8516:  MOVLW  0C
8518:  MOVLB  3
851A:  MOVWF  xAD
851C:  MOVLW  FA
851E:  MOVWF  xBE
8520:  MOVLB  0
8522:  CALL   2064
8526:  MOVLB  3
8528:  DECFSZ xAD,F
852A:  BRA    851C
....................             excluir_modelo_memoria(modelo); 
852C:  MOVFF  2D,3AD
8530:  MOVLB  0
8532:  BRA    849A
....................             printf(lcd_putc, "\f"); // limpa display 
8534:  MOVLW  0C
8536:  MOVLB  3
8538:  MOVWF  xBD
853A:  MOVLB  0
853C:  CALL   2436
....................             printf(lcd_putc, "   MODELO EXCUIDO   \n\r"); 
8540:  MOVLW  78
8542:  MOVWF  FF6
8544:  MOVLW  0E
8546:  MOVWF  FF7
8548:  CALL   248A
....................             delay_ms(3000); 
854C:  MOVLW  0C
854E:  MOVLB  3
8550:  MOVWF  xAD
8552:  MOVLW  FA
8554:  MOVWF  xBE
8556:  MOVLB  0
8558:  CALL   2064
855C:  MOVLB  3
855E:  DECFSZ xAD,F
8560:  BRA    8552
....................             menu_atual = menu_edita_modelo; 
8562:  MOVLW  0D
8564:  MOVWF  1C
....................             tela_edita_modelo(); 
8566:  MOVLB  0
8568:  CALL   55FA
....................         break; 
856C:  BRA    8576
....................         case ESC: 
....................             menu_atual = menu_edita_modelo; 
856E:  MOVLW  0D
8570:  MOVWF  1C
....................             tela_edita_modelo(); 
8572:  CALL   55FA
....................         break; 
....................     } 
8576:  GOTO   A9A0 (RETURN)
.................... } 
.................... void atualiza_tela_seleciona_pontos(){ 
....................     switch(Teclado()){ 
*
6AB8:  CALL   5054
6ABC:  MOVLW  0E
6ABE:  SUBWF  01,W
6AC0:  ADDLW  FA
6AC2:  BTFSC  FD8.0
6AC4:  BRA    6CF2
6AC6:  ADDLW  06
6AC8:  GOTO   6CF6
....................         case SETA_SUPERIOR: 
....................             contador_lcd --; 
6ACC:  DECF   24,F
....................             if  ((contador_lcd > 0)&&(contador_lcd < pontos_no_modelo)){ 
6ACE:  MOVF   24,F
6AD0:  BZ    6AF4
6AD2:  MOVLB  1
6AD4:  MOVF   x0A,W
6AD6:  SUBWF  24,W
6AD8:  BTFSS  FD8.0
6ADA:  BRA    6AE0
6ADC:  MOVLB  0
6ADE:  BRA    6AF4
....................                 if (ponteiro_lcd == 1){ 
6AE0:  DECFSZ 21,W
6AE2:  BRA    6AEE
....................                     inicial_lcd --; 
6AE4:  DECF   22,F
....................                     final_lcd --; 
6AE6:  DECF   23,F
....................                     ponteiro_lcd = 1; 
6AE8:  MOVLW  01
6AEA:  MOVWF  21
....................                 } else { 
6AEC:  BRA    6AF0
....................                     ponteiro_lcd --; 
6AEE:  DECF   21,F
....................                 }                 
....................             } else { 
6AF0:  BRA    6B02
6AF2:  MOVLB  0
....................                 contador_lcd = 0; 
6AF4:  CLRF   24
....................                 inicial_lcd = 0; 
6AF6:  CLRF   22
....................                 final_lcd = 3; 
6AF8:  MOVLW  03
6AFA:  MOVWF  23
....................                 ponteiro_lcd = 1; 
6AFC:  MOVLW  01
6AFE:  MOVWF  21
6B00:  MOVLB  1
....................             } 
....................             menu_atual = menu_seleciona_pontos; 
6B02:  MOVLW  0F
6B04:  MOVWF  1C
....................             tela_seleciona_pontos(); 
6B06:  MOVLB  0
6B08:  RCALL  6526
....................         break; 
6B0A:  BRA    6CF2
....................         case SETA_INFERIOR: 
....................             contador_lcd ++; 
6B0C:  INCF   24,F
....................             if (contador_lcd < pontos_no_modelo){ 
6B0E:  MOVLB  1
6B10:  MOVF   x0A,W
6B12:  SUBWF  24,W
6B14:  BC    6B2A
....................                 if (ponteiro_lcd == 4){ 
6B16:  MOVF   21,W
6B18:  SUBLW  04
6B1A:  BNZ   6B26
....................                     inicial_lcd ++; 
6B1C:  INCF   22,F
....................                     final_lcd ++; 
6B1E:  INCF   23,F
....................                     ponteiro_lcd = 4; 
6B20:  MOVLW  04
6B22:  MOVWF  21
....................                 } else { 
6B24:  BRA    6B28
....................                     ponteiro_lcd ++; 
6B26:  INCF   21,F
....................                 } 
....................             } else { 
6B28:  BRA    6B2E
....................                 contador_lcd = pontos_no_modelo; 
6B2A:  MOVFF  10A,24
....................             } 
....................             menu_atual = menu_seleciona_pontos; 
6B2E:  MOVLW  0F
6B30:  MOVWF  1C
....................             tela_seleciona_pontos(); 
6B32:  MOVLB  0
6B34:  RCALL  6526
....................         break; 
6B36:  BRA    6CF2
....................         case ENTER: 
....................             ponteiro_lcd = 1; 
6B38:  MOVLW  01
6B3A:  MOVWF  21
....................             inicial_lcd = 0; 
6B3C:  CLRF   22
....................             final_lcd = 3; 
6B3E:  MOVLW  03
6B40:  MOVWF  23
....................             motor_run_z(0, 19); 
6B42:  MOVLB  3
6B44:  CLRF   xB7
6B46:  CLRF   xB6
6B48:  CLRF   xB5
6B4A:  CLRF   xB4
6B4C:  MOVLW  13
6B4E:  MOVWF  xB8
6B50:  MOVLB  0
6B52:  CALL   5638
....................             while ((run_flg_z)); 
6B56:  MOVLB  3
6B58:  BTFSC  x9B.0
6B5A:  BRA    6B58
....................             if ((y[contador_lcd] > 0) && (x[contador_lcd]> 0)){                 
6B5C:  BCF    FD8.0
6B5E:  RLCF   24,W
6B60:  CLRF   03
6B62:  ADDLW  56
6B64:  MOVWF  FE9
6B66:  MOVLW  00
6B68:  ADDWFC 03,W
6B6A:  MOVWF  FEA
6B6C:  MOVFF  FEC,3AE
6B70:  MOVF   FED,F
6B72:  MOVFF  FEF,3AD
6B76:  MOVF   xAD,F
6B78:  BNZ   6B7E
6B7A:  MOVF   xAE,F
6B7C:  BZ    6C46
6B7E:  BCF    FD8.0
6B80:  RLCF   24,W
6B82:  CLRF   03
6B84:  ADDLW  2E
6B86:  MOVWF  FE9
6B88:  MOVLW  00
6B8A:  ADDWFC 03,W
6B8C:  MOVWF  FEA
6B8E:  MOVFF  FEC,3AE
6B92:  MOVF   FED,F
6B94:  MOVFF  FEF,3AD
6B98:  MOVF   xAD,F
6B9A:  BNZ   6BA0
6B9C:  MOVF   xAE,F
6B9E:  BZ    6C46
....................                 motor_run_x(x[contador_lcd],19); 
6BA0:  BCF    FD8.0
6BA2:  RLCF   24,W
6BA4:  CLRF   03
6BA6:  ADDLW  2E
6BA8:  MOVWF  FE9
6BAA:  MOVLW  00
6BAC:  ADDWFC 03,W
6BAE:  MOVWF  FEA
6BB0:  MOVFF  FEC,3AE
6BB4:  MOVF   FED,F
6BB6:  MOVFF  FEF,3AD
6BBA:  CLRF   xB7
6BBC:  CLRF   xB6
6BBE:  MOVFF  3AE,3B5
6BC2:  MOVFF  3AD,3B4
6BC6:  MOVLW  13
6BC8:  MOVWF  xB8
6BCA:  MOVLB  0
6BCC:  CALL   4AB2
....................                 motor_run_y(y[contador_lcd],19); 
6BD0:  BCF    FD8.0
6BD2:  RLCF   24,W
6BD4:  CLRF   03
6BD6:  ADDLW  56
6BD8:  MOVWF  FE9
6BDA:  MOVLW  00
6BDC:  ADDWFC 03,W
6BDE:  MOVWF  FEA
6BE0:  MOVFF  FEC,3AE
6BE4:  MOVF   FED,F
6BE6:  MOVFF  FEF,3AD
6BEA:  MOVLB  3
6BEC:  CLRF   xB7
6BEE:  CLRF   xB6
6BF0:  MOVFF  3AE,3B5
6BF4:  MOVFF  3AD,3B4
6BF8:  MOVLW  13
6BFA:  MOVWF  xB8
6BFC:  MOVLB  0
6BFE:  CALL   5802
....................                 motor_run_z(z[contador_lcd],19); 
6C02:  BCF    FD8.0
6C04:  RLCF   24,W
6C06:  CLRF   03
6C08:  ADDLW  7E
6C0A:  MOVWF  FE9
6C0C:  MOVLW  00
6C0E:  ADDWFC 03,W
6C10:  MOVWF  FEA
6C12:  MOVFF  FEC,3AE
6C16:  MOVF   FED,F
6C18:  MOVFF  FEF,3AD
6C1C:  MOVLB  3
6C1E:  CLRF   xB7
6C20:  CLRF   xB6
6C22:  MOVFF  3AE,3B5
6C26:  MOVFF  3AD,3B4
6C2A:  MOVLW  13
6C2C:  MOVWF  xB8
6C2E:  MOVLB  0
6C30:  CALL   5638
....................                 posicao_atual = SOLDAGEM; 
6C34:  MOVLW  03
6C36:  MOVWF  25
....................                 envia_posicao_para_outra_maquina(SOLDAGEM); 
6C38:  MOVLB  3
6C3A:  MOVWF  xB0
6C3C:  MOVLB  0
6C3E:  CALL   4C24
....................             } else { 
6C42:  BRA    6C9E
6C44:  MOVLB  3
....................                 envia_maquina_para_posicao(SOLDAGEM); 
6C46:  MOVLW  03
6C48:  MOVWF  xAF
6C4A:  MOVLB  0
6C4C:  CALL   5A14
....................                 x[contador_lcd] = motor_pos_x; 
6C50:  BCF    FD8.0
6C52:  RLCF   24,W
6C54:  CLRF   03
6C56:  ADDLW  2E
6C58:  MOVWF  FE9
6C5A:  MOVLW  00
6C5C:  ADDWFC 03,W
6C5E:  MOVWF  FEA
6C60:  MOVFF  113,FEC
6C64:  MOVF   FED,F
6C66:  MOVFF  112,FEF
....................                 y[contador_lcd] = motor_pos_y; 
6C6A:  BCF    FD8.0
6C6C:  RLCF   24,W
6C6E:  CLRF   03
6C70:  ADDLW  56
6C72:  MOVWF  FE9
6C74:  MOVLW  00
6C76:  ADDWFC 03,W
6C78:  MOVWF  FEA
6C7A:  MOVFF  115,FEC
6C7E:  MOVF   FED,F
6C80:  MOVFF  114,FEF
....................                 z[contador_lcd] = motor_pos_z; 
6C84:  BCF    FD8.0
6C86:  RLCF   24,W
6C88:  CLRF   03
6C8A:  ADDLW  7E
6C8C:  MOVWF  FE9
6C8E:  MOVLW  00
6C90:  ADDWFC 03,W
6C92:  MOVWF  FEA
6C94:  MOVFF  119,FEC
6C98:  MOVF   FED,F
6C9A:  MOVFF  118,FEF
....................             } 
....................             menu_atual = menu_dados_ponto; 
6C9E:  MOVLW  10
6CA0:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
6CA2:  MOVFF  24,3AD
6CA6:  RCALL  68A8
....................         break; 
6CA8:  BRA    6CF2
....................         case ESC: 
....................             envia_maquina_para_posicao(HOME1); 
6CAA:  MOVLW  01
6CAC:  MOVLB  3
6CAE:  MOVWF  xAF
6CB0:  MOVLB  0
6CB2:  CALL   5A14
....................             envia_maquina_para_posicao(ALIMENTADOR); 
6CB6:  MOVLB  3
6CB8:  CLRF   xAF
6CBA:  MOVLB  0
6CBC:  CALL   5A14
....................             desliga_pressor(); 
6CC0:  RCALL  6AA8
....................             menu_atual = menu_seleciona_debug; 
6CC2:  MOVLW  02
6CC4:  MOVWF  1C
....................             tela_seleciona_debug(); 
6CC6:  CALL   6468
....................             motor_run_z(0, 19); 
6CCA:  MOVLB  3
6CCC:  CLRF   xB7
6CCE:  CLRF   xB6
6CD0:  CLRF   xB5
6CD2:  CLRF   xB4
6CD4:  MOVLW  13
6CD6:  MOVWF  xB8
6CD8:  MOVLB  0
6CDA:  CALL   5638
....................             while ((run_flg_z)); 
6CDE:  MOVLB  3
6CE0:  BTFSC  x9B.0
6CE2:  BRA    6CE0
....................             ponteiro_lcd = 1; 
6CE4:  MOVLW  01
6CE6:  MOVWF  21
....................             inicial_lcd = 0; 
6CE8:  CLRF   22
....................             final_lcd = 3; 
6CEA:  MOVLW  03
6CEC:  MOVWF  23
....................             contador_lcd = 0; 
6CEE:  CLRF   24
....................         break; 
6CF0:  MOVLB  3
....................     } 
6CF2:  GOTO   A9EC (RETURN)
.................... } 
.................... void atualiza_tela_dados_ponto(){ 
....................     switch (Teclado()){ 
*
7CA4:  CALL   5054
7CA8:  MOVF   01,W
7CAA:  ADDLW  EC
7CAC:  BTFSC  FD8.0
7CAE:  GOTO   844A
7CB2:  ADDLW  14
7CB4:  GOTO   844E
....................         case SETA_SUPERIOR: 
....................             if (y[contador_lcd] > 0){ 
7CB8:  BCF    FD8.0
7CBA:  RLCF   24,W
7CBC:  CLRF   03
7CBE:  ADDLW  56
7CC0:  MOVWF  FE9
7CC2:  MOVLW  00
7CC4:  ADDWFC 03,W
7CC6:  MOVWF  FEA
7CC8:  MOVFF  FEC,3AE
7CCC:  MOVF   FED,F
7CCE:  MOVFF  FEF,3AD
7CD2:  MOVLB  3
7CD4:  MOVF   xAD,F
7CD6:  BNZ   7CDC
7CD8:  MOVF   xAE,F
7CDA:  BZ    7D5A
....................                 y[contador_lcd] = y[contador_lcd] - 1; 
7CDC:  BCF    FD8.0
7CDE:  RLCF   24,W
7CE0:  CLRF   03
7CE2:  ADDLW  56
7CE4:  MOVWF  01
7CE6:  MOVLW  00
7CE8:  ADDWFC 03,F
7CEA:  MOVFF  03,3AE
7CEE:  BCF    FD8.0
7CF0:  RLCF   24,W
7CF2:  CLRF   03
7CF4:  ADDLW  56
7CF6:  MOVWF  FE9
7CF8:  MOVLW  00
7CFA:  ADDWFC 03,W
7CFC:  MOVWF  FEA
7CFE:  MOVFF  FEC,3B0
7D02:  MOVF   FED,F
7D04:  MOVFF  FEF,3AF
7D08:  MOVLW  01
7D0A:  SUBWF  xAF,W
7D0C:  MOVWF  00
7D0E:  MOVLW  00
7D10:  SUBWFB xB0,W
7D12:  MOVFF  3AE,FEA
7D16:  MOVFF  01,FE9
7D1A:  MOVWF  FEC
7D1C:  MOVF   FED,F
7D1E:  MOVFF  00,FEF
....................                 motor_run_y(y[contador_lcd],19); 
7D22:  BCF    FD8.0
7D24:  RLCF   24,W
7D26:  CLRF   03
7D28:  ADDLW  56
7D2A:  MOVWF  FE9
7D2C:  MOVLW  00
7D2E:  ADDWFC 03,W
7D30:  MOVWF  FEA
7D32:  MOVFF  FEC,3AE
7D36:  MOVF   FED,F
7D38:  MOVFF  FEF,3AD
7D3C:  CLRF   xB7
7D3E:  CLRF   xB6
7D40:  MOVFF  3AE,3B5
7D44:  MOVFF  3AD,3B4
7D48:  MOVLW  13
7D4A:  MOVWF  xB8
7D4C:  MOVLB  0
7D4E:  CALL   5802
....................                 while ((run_flg_y)); 
7D52:  MOVLB  1
7D54:  BTFSC  x1A.5
7D56:  BRA    7D54
7D58:  MOVLB  3
....................             } 
....................             menu_atual = menu_dados_ponto; 
7D5A:  MOVLW  10
7D5C:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
7D5E:  MOVFF  24,3AD
7D62:  MOVLB  0
7D64:  CALL   68A8
....................         break; 
7D68:  BRA    844A
....................         case SETA_INFERIOR: 
....................             y[contador_lcd] = y[contador_lcd] + 1; 
7D6A:  BCF    FD8.0
7D6C:  RLCF   24,W
7D6E:  CLRF   03
7D70:  ADDLW  56
7D72:  MOVWF  01
7D74:  MOVLW  00
7D76:  ADDWFC 03,F
7D78:  MOVFF  01,3AD
7D7C:  MOVLB  3
7D7E:  MOVFF  03,3AE
7D82:  BCF    FD8.0
7D84:  RLCF   24,W
7D86:  CLRF   03
7D88:  ADDLW  56
7D8A:  MOVWF  FE9
7D8C:  MOVLW  00
7D8E:  ADDWFC 03,W
7D90:  MOVWF  FEA
7D92:  MOVFF  FEC,3B0
7D96:  MOVF   FED,F
7D98:  MOVFF  FEF,3AF
7D9C:  MOVLW  01
7D9E:  ADDWF  xAF,W
7DA0:  MOVWF  01
7DA2:  MOVLW  00
7DA4:  ADDWFC xB0,W
7DA6:  MOVFF  3AE,FEA
7DAA:  MOVFF  3AD,FE9
7DAE:  MOVWF  FEC
7DB0:  MOVF   FED,F
7DB2:  MOVFF  01,FEF
....................             motor_run_y(y[contador_lcd],19); 
7DB6:  BCF    FD8.0
7DB8:  RLCF   24,W
7DBA:  CLRF   03
7DBC:  ADDLW  56
7DBE:  MOVWF  FE9
7DC0:  MOVLW  00
7DC2:  ADDWFC 03,W
7DC4:  MOVWF  FEA
7DC6:  MOVFF  FEC,3AE
7DCA:  MOVF   FED,F
7DCC:  MOVFF  FEF,3AD
7DD0:  CLRF   xB7
7DD2:  CLRF   xB6
7DD4:  MOVFF  3AE,3B5
7DD8:  MOVFF  3AD,3B4
7DDC:  MOVLW  13
7DDE:  MOVWF  xB8
7DE0:  MOVLB  0
7DE2:  CALL   5802
....................             while ((run_flg_y)); 
7DE6:  MOVLB  1
7DE8:  BTFSC  x1A.5
7DEA:  BRA    7DE8
....................             menu_atual = menu_dados_ponto; 
7DEC:  MOVLW  10
7DEE:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
7DF0:  MOVFF  24,3AD
7DF4:  MOVLB  0
7DF6:  CALL   68A8
....................         break; 
7DFA:  BRA    844A
....................         case SETA_DIREITA: 
....................             x[contador_lcd] = x[contador_lcd] + 1; 
7DFC:  BCF    FD8.0
7DFE:  RLCF   24,W
7E00:  CLRF   03
7E02:  ADDLW  2E
7E04:  MOVWF  01
7E06:  MOVLW  00
7E08:  ADDWFC 03,F
7E0A:  MOVFF  01,3AD
7E0E:  MOVLB  3
7E10:  MOVFF  03,3AE
7E14:  BCF    FD8.0
7E16:  RLCF   24,W
7E18:  CLRF   03
7E1A:  ADDLW  2E
7E1C:  MOVWF  FE9
7E1E:  MOVLW  00
7E20:  ADDWFC 03,W
7E22:  MOVWF  FEA
7E24:  MOVFF  FEC,3B0
7E28:  MOVF   FED,F
7E2A:  MOVFF  FEF,3AF
7E2E:  MOVLW  01
7E30:  ADDWF  xAF,W
7E32:  MOVWF  01
7E34:  MOVLW  00
7E36:  ADDWFC xB0,W
7E38:  MOVFF  3AE,FEA
7E3C:  MOVFF  3AD,FE9
7E40:  MOVWF  FEC
7E42:  MOVF   FED,F
7E44:  MOVFF  01,FEF
....................             motor_run_x(x[contador_lcd],19); 
7E48:  BCF    FD8.0
7E4A:  RLCF   24,W
7E4C:  CLRF   03
7E4E:  ADDLW  2E
7E50:  MOVWF  FE9
7E52:  MOVLW  00
7E54:  ADDWFC 03,W
7E56:  MOVWF  FEA
7E58:  MOVFF  FEC,3AE
7E5C:  MOVF   FED,F
7E5E:  MOVFF  FEF,3AD
7E62:  CLRF   xB7
7E64:  CLRF   xB6
7E66:  MOVFF  3AE,3B5
7E6A:  MOVFF  3AD,3B4
7E6E:  MOVLW  13
7E70:  MOVWF  xB8
7E72:  MOVLB  0
7E74:  CALL   4AB2
....................             while ((run_flg_x)); 
7E78:  MOVLB  1
7E7A:  BTFSC  x1A.3
7E7C:  BRA    7E7A
....................             menu_atual = menu_dados_ponto; 
7E7E:  MOVLW  10
7E80:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
7E82:  MOVFF  24,3AD
7E86:  MOVLB  0
7E88:  CALL   68A8
....................         break; 
7E8C:  BRA    844A
....................         case SETA_ESQUERDA: 
....................             if (x[contador_lcd] > 0){ 
7E8E:  BCF    FD8.0
7E90:  RLCF   24,W
7E92:  CLRF   03
7E94:  ADDLW  2E
7E96:  MOVWF  FE9
7E98:  MOVLW  00
7E9A:  ADDWFC 03,W
7E9C:  MOVWF  FEA
7E9E:  MOVFF  FEC,3AE
7EA2:  MOVF   FED,F
7EA4:  MOVFF  FEF,3AD
7EA8:  MOVLB  3
7EAA:  MOVF   xAD,F
7EAC:  BNZ   7EB2
7EAE:  MOVF   xAE,F
7EB0:  BZ    7F30
....................                 x[contador_lcd] = x[contador_lcd] - 1; 
7EB2:  BCF    FD8.0
7EB4:  RLCF   24,W
7EB6:  CLRF   03
7EB8:  ADDLW  2E
7EBA:  MOVWF  01
7EBC:  MOVLW  00
7EBE:  ADDWFC 03,F
7EC0:  MOVFF  03,3AE
7EC4:  BCF    FD8.0
7EC6:  RLCF   24,W
7EC8:  CLRF   03
7ECA:  ADDLW  2E
7ECC:  MOVWF  FE9
7ECE:  MOVLW  00
7ED0:  ADDWFC 03,W
7ED2:  MOVWF  FEA
7ED4:  MOVFF  FEC,3B0
7ED8:  MOVF   FED,F
7EDA:  MOVFF  FEF,3AF
7EDE:  MOVLW  01
7EE0:  SUBWF  xAF,W
7EE2:  MOVWF  00
7EE4:  MOVLW  00
7EE6:  SUBWFB xB0,W
7EE8:  MOVFF  3AE,FEA
7EEC:  MOVFF  01,FE9
7EF0:  MOVWF  FEC
7EF2:  MOVF   FED,F
7EF4:  MOVFF  00,FEF
....................                 motor_run_x(x[contador_lcd],19); 
7EF8:  BCF    FD8.0
7EFA:  RLCF   24,W
7EFC:  CLRF   03
7EFE:  ADDLW  2E
7F00:  MOVWF  FE9
7F02:  MOVLW  00
7F04:  ADDWFC 03,W
7F06:  MOVWF  FEA
7F08:  MOVFF  FEC,3AE
7F0C:  MOVF   FED,F
7F0E:  MOVFF  FEF,3AD
7F12:  CLRF   xB7
7F14:  CLRF   xB6
7F16:  MOVFF  3AE,3B5
7F1A:  MOVFF  3AD,3B4
7F1E:  MOVLW  13
7F20:  MOVWF  xB8
7F22:  MOVLB  0
7F24:  CALL   4AB2
....................                 while ((run_flg_x)); 
7F28:  MOVLB  1
7F2A:  BTFSC  x1A.3
7F2C:  BRA    7F2A
7F2E:  MOVLB  3
....................             } 
....................             menu_atual = menu_dados_ponto; 
7F30:  MOVLW  10
7F32:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
7F34:  MOVFF  24,3AD
7F38:  MOVLB  0
7F3A:  CALL   68A8
....................         break; 
7F3E:  BRA    844A
....................         case F2: 
....................             if (z[contador_lcd] > 0){ 
7F40:  BCF    FD8.0
7F42:  RLCF   24,W
7F44:  CLRF   03
7F46:  ADDLW  7E
7F48:  MOVWF  FE9
7F4A:  MOVLW  00
7F4C:  ADDWFC 03,W
7F4E:  MOVWF  FEA
7F50:  MOVFF  FEC,3AE
7F54:  MOVF   FED,F
7F56:  MOVFF  FEF,3AD
7F5A:  MOVLB  3
7F5C:  MOVF   xAD,F
7F5E:  BNZ   7F64
7F60:  MOVF   xAE,F
7F62:  BZ    7FE0
....................                 z[contador_lcd] = z[contador_lcd] -1; 
7F64:  BCF    FD8.0
7F66:  RLCF   24,W
7F68:  CLRF   03
7F6A:  ADDLW  7E
7F6C:  MOVWF  01
7F6E:  MOVLW  00
7F70:  ADDWFC 03,F
7F72:  MOVFF  03,3AE
7F76:  BCF    FD8.0
7F78:  RLCF   24,W
7F7A:  CLRF   03
7F7C:  ADDLW  7E
7F7E:  MOVWF  FE9
7F80:  MOVLW  00
7F82:  ADDWFC 03,W
7F84:  MOVWF  FEA
7F86:  MOVFF  FEC,3B0
7F8A:  MOVF   FED,F
7F8C:  MOVFF  FEF,3AF
7F90:  MOVLW  01
7F92:  SUBWF  xAF,W
7F94:  MOVWF  00
7F96:  MOVLW  00
7F98:  SUBWFB xB0,W
7F9A:  MOVFF  3AE,FEA
7F9E:  MOVFF  01,FE9
7FA2:  MOVWF  FEC
7FA4:  MOVF   FED,F
7FA6:  MOVFF  00,FEF
....................                 motor_run_z(z[contador_lcd],19); 
7FAA:  BCF    FD8.0
7FAC:  RLCF   24,W
7FAE:  CLRF   03
7FB0:  ADDLW  7E
7FB2:  MOVWF  FE9
7FB4:  MOVLW  00
7FB6:  ADDWFC 03,W
7FB8:  MOVWF  FEA
7FBA:  MOVFF  FEC,3AE
7FBE:  MOVF   FED,F
7FC0:  MOVFF  FEF,3AD
7FC4:  CLRF   xB7
7FC6:  CLRF   xB6
7FC8:  MOVFF  3AE,3B5
7FCC:  MOVFF  3AD,3B4
7FD0:  MOVLW  13
7FD2:  MOVWF  xB8
7FD4:  MOVLB  0
7FD6:  CALL   5638
....................                 while ((run_flg_z)); 
7FDA:  MOVLB  3
7FDC:  BTFSC  x9B.0
7FDE:  BRA    7FDC
....................             } 
....................             menu_atual = menu_dados_ponto; 
7FE0:  MOVLW  10
7FE2:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
7FE4:  MOVFF  24,3AD
7FE8:  MOVLB  0
7FEA:  CALL   68A8
....................         break; 
7FEE:  BRA    844A
....................         case F4: 
....................             z[contador_lcd] = z[contador_lcd] +1; 
7FF0:  BCF    FD8.0
7FF2:  RLCF   24,W
7FF4:  CLRF   03
7FF6:  ADDLW  7E
7FF8:  MOVWF  01
7FFA:  MOVLW  00
7FFC:  ADDWFC 03,F
7FFE:  MOVFF  01,3AD
8002:  MOVLB  3
8004:  MOVFF  03,3AE
8008:  BCF    FD8.0
800A:  RLCF   24,W
800C:  CLRF   03
800E:  ADDLW  7E
8010:  MOVWF  FE9
8012:  MOVLW  00
8014:  ADDWFC 03,W
8016:  MOVWF  FEA
8018:  MOVFF  FEC,3B0
801C:  MOVF   FED,F
801E:  MOVFF  FEF,3AF
8022:  MOVLW  01
8024:  ADDWF  xAF,W
8026:  MOVWF  01
8028:  MOVLW  00
802A:  ADDWFC xB0,W
802C:  MOVFF  3AE,FEA
8030:  MOVFF  3AD,FE9
8034:  MOVWF  FEC
8036:  MOVF   FED,F
8038:  MOVFF  01,FEF
....................             motor_run_z(z[contador_lcd],19); 
803C:  BCF    FD8.0
803E:  RLCF   24,W
8040:  CLRF   03
8042:  ADDLW  7E
8044:  MOVWF  FE9
8046:  MOVLW  00
8048:  ADDWFC 03,W
804A:  MOVWF  FEA
804C:  MOVFF  FEC,3AE
8050:  MOVF   FED,F
8052:  MOVFF  FEF,3AD
8056:  CLRF   xB7
8058:  CLRF   xB6
805A:  MOVFF  3AE,3B5
805E:  MOVFF  3AD,3B4
8062:  MOVLW  13
8064:  MOVWF  xB8
8066:  MOVLB  0
8068:  CALL   5638
....................             while ((run_flg_z)); 
806C:  MOVLB  3
806E:  BTFSC  x9B.0
8070:  BRA    806E
....................             menu_atual = menu_dados_ponto; 
8072:  MOVLW  10
8074:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
8076:  MOVFF  24,3AD
807A:  MOVLB  0
807C:  CALL   68A8
....................         break; 
8080:  BRA    844A
....................         case 1: 
....................             t_solda[contador_lcd] = t_solda[contador_lcd] + 10; 
8082:  BCF    FD8.0
8084:  RLCF   24,W
8086:  CLRF   03
8088:  ADDLW  A6
808A:  MOVWF  01
808C:  MOVLW  00
808E:  ADDWFC 03,F
8090:  MOVFF  01,3AD
8094:  MOVLB  3
8096:  MOVFF  03,3AE
809A:  BCF    FD8.0
809C:  RLCF   24,W
809E:  CLRF   03
80A0:  ADDLW  A6
80A2:  MOVWF  FE9
80A4:  MOVLW  00
80A6:  ADDWFC 03,W
80A8:  MOVWF  FEA
80AA:  MOVFF  FEC,3B0
80AE:  MOVF   FED,F
80B0:  MOVFF  FEF,3AF
80B4:  MOVLW  0A
80B6:  ADDWF  xAF,W
80B8:  MOVWF  01
80BA:  MOVLW  00
80BC:  ADDWFC xB0,W
80BE:  MOVFF  3AE,FEA
80C2:  MOVFF  3AD,FE9
80C6:  MOVWF  FEC
80C8:  MOVF   FED,F
80CA:  MOVFF  01,FEF
....................             menu_atual = menu_dados_ponto; 
80CE:  MOVLW  10
80D0:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
80D2:  MOVFF  24,3AD
80D6:  MOVLB  0
80D8:  CALL   68A8
....................         break; 
80DC:  BRA    844A
....................         case 4: 
....................             if (t_solda[contador_lcd] > 0){ 
80DE:  BCF    FD8.0
80E0:  RLCF   24,W
80E2:  CLRF   03
80E4:  ADDLW  A6
80E6:  MOVWF  FE9
80E8:  MOVLW  00
80EA:  ADDWFC 03,W
80EC:  MOVWF  FEA
80EE:  MOVFF  FEC,3AE
80F2:  MOVF   FED,F
80F4:  MOVFF  FEF,3AD
80F8:  MOVLB  3
80FA:  MOVF   xAD,F
80FC:  BNZ   8102
80FE:  MOVF   xAE,F
8100:  BZ    8148
....................                 t_solda[contador_lcd] = t_solda[contador_lcd] - 10; 
8102:  BCF    FD8.0
8104:  RLCF   24,W
8106:  CLRF   03
8108:  ADDLW  A6
810A:  MOVWF  01
810C:  MOVLW  00
810E:  ADDWFC 03,F
8110:  MOVFF  03,3AE
8114:  BCF    FD8.0
8116:  RLCF   24,W
8118:  CLRF   03
811A:  ADDLW  A6
811C:  MOVWF  FE9
811E:  MOVLW  00
8120:  ADDWFC 03,W
8122:  MOVWF  FEA
8124:  MOVFF  FEC,3B0
8128:  MOVF   FED,F
812A:  MOVFF  FEF,3AF
812E:  MOVLW  0A
8130:  SUBWF  xAF,W
8132:  MOVWF  00
8134:  MOVLW  00
8136:  SUBWFB xB0,W
8138:  MOVFF  3AE,FEA
813C:  MOVFF  01,FE9
8140:  MOVWF  FEC
8142:  MOVF   FED,F
8144:  MOVFF  00,FEF
....................             } 
....................             menu_atual = menu_dados_ponto; 
8148:  MOVLW  10
814A:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
814C:  MOVFF  24,3AD
8150:  MOVLB  0
8152:  CALL   68A8
....................         break; 
8156:  BRA    844A
....................         case 3: 
....................             t_wait[contador_lcd] = t_wait[contador_lcd] + 10; 
8158:  BCF    FD8.0
815A:  RLCF   24,W
815C:  CLRF   03
815E:  ADDLW  CE
8160:  MOVWF  01
8162:  MOVLW  00
8164:  ADDWFC 03,F
8166:  MOVFF  01,3AD
816A:  MOVLB  3
816C:  MOVFF  03,3AE
8170:  BCF    FD8.0
8172:  RLCF   24,W
8174:  CLRF   03
8176:  ADDLW  CE
8178:  MOVWF  FE9
817A:  MOVLW  00
817C:  ADDWFC 03,W
817E:  MOVWF  FEA
8180:  MOVFF  FEC,3B0
8184:  MOVF   FED,F
8186:  MOVFF  FEF,3AF
818A:  MOVLW  0A
818C:  ADDWF  xAF,W
818E:  MOVWF  01
8190:  MOVLW  00
8192:  ADDWFC xB0,W
8194:  MOVFF  3AE,FEA
8198:  MOVFF  3AD,FE9
819C:  MOVWF  FEC
819E:  MOVF   FED,F
81A0:  MOVFF  01,FEF
....................             menu_atual = menu_dados_ponto; 
81A4:  MOVLW  10
81A6:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
81A8:  MOVFF  24,3AD
81AC:  MOVLB  0
81AE:  CALL   68A8
....................         break; 
81B2:  BRA    844A
....................         case 6: 
....................             if (t_wait[contador_lcd] > 0){ 
81B4:  BCF    FD8.0
81B6:  RLCF   24,W
81B8:  CLRF   03
81BA:  ADDLW  CE
81BC:  MOVWF  FE9
81BE:  MOVLW  00
81C0:  ADDWFC 03,W
81C2:  MOVWF  FEA
81C4:  MOVFF  FEC,3AE
81C8:  MOVF   FED,F
81CA:  MOVFF  FEF,3AD
81CE:  MOVLB  3
81D0:  MOVF   xAD,F
81D2:  BNZ   81D8
81D4:  MOVF   xAE,F
81D6:  BZ    821E
....................                 t_wait[contador_lcd] = t_wait[contador_lcd] - 10; 
81D8:  BCF    FD8.0
81DA:  RLCF   24,W
81DC:  CLRF   03
81DE:  ADDLW  CE
81E0:  MOVWF  01
81E2:  MOVLW  00
81E4:  ADDWFC 03,F
81E6:  MOVFF  03,3AE
81EA:  BCF    FD8.0
81EC:  RLCF   24,W
81EE:  CLRF   03
81F0:  ADDLW  CE
81F2:  MOVWF  FE9
81F4:  MOVLW  00
81F6:  ADDWFC 03,W
81F8:  MOVWF  FEA
81FA:  MOVFF  FEC,3B0
81FE:  MOVF   FED,F
8200:  MOVFF  FEF,3AF
8204:  MOVLW  0A
8206:  SUBWF  xAF,W
8208:  MOVWF  00
820A:  MOVLW  00
820C:  SUBWFB xB0,W
820E:  MOVFF  3AE,FEA
8212:  MOVFF  01,FE9
8216:  MOVWF  FEC
8218:  MOVF   FED,F
821A:  MOVFF  00,FEF
....................             } 
....................             menu_atual = menu_dados_ponto; 
821E:  MOVLW  10
8220:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
8222:  MOVFF  24,3AD
8226:  MOVLB  0
8228:  CALL   68A8
....................         break; 
822C:  BRA    844A
....................         case 2: 
....................             if (tipo[contador_lcd] <= 3){ 
822E:  CLRF   03
8230:  MOVF   24,W
8232:  ADDLW  F6
8234:  MOVWF  FE9
8236:  MOVLW  00
8238:  ADDWFC 03,W
823A:  MOVWF  FEA
823C:  MOVF   FEF,W
823E:  SUBLW  03
8240:  BNC   8272
....................                 tipo[contador_lcd] = tipo[contador_lcd] +1; 
8242:  CLRF   03
8244:  MOVF   24,W
8246:  ADDLW  F6
8248:  MOVWF  01
824A:  MOVLW  00
824C:  ADDWFC 03,F
824E:  MOVLB  3
8250:  MOVFF  03,3AE
8254:  CLRF   03
8256:  MOVF   24,W
8258:  ADDLW  F6
825A:  MOVWF  FE9
825C:  MOVLW  00
825E:  ADDWFC 03,W
8260:  MOVWF  FEA
8262:  MOVLW  01
8264:  ADDWF  FEF,W
8266:  MOVFF  3AE,FEA
826A:  MOVFF  01,FE9
826E:  MOVWF  FEF
8270:  MOVLB  0
....................             } 
....................             if (tipo[contador_lcd] > 3){ 
8272:  CLRF   03
8274:  MOVF   24,W
8276:  ADDLW  F6
8278:  MOVWF  FE9
827A:  MOVLW  00
827C:  ADDWFC 03,W
827E:  MOVWF  FEA
8280:  MOVF   FEF,W
8282:  SUBLW  03
8284:  BC    8296
....................                 tipo[contador_lcd] = 0; 
8286:  CLRF   03
8288:  MOVF   24,W
828A:  ADDLW  F6
828C:  MOVWF  FE9
828E:  MOVLW  00
8290:  ADDWFC 03,W
8292:  MOVWF  FEA
8294:  CLRF   FEF
....................             }             
....................             menu_atual = menu_dados_ponto; 
8296:  MOVLW  10
8298:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
829A:  MOVFF  24,3AD
829E:  CALL   68A8
....................         break; 
82A2:  BRA    844A
....................         case 5: 
....................             if (habilitado[contador_lcd] == TRUE){ 
82A4:  MOVFF  24,3B5
82A8:  MOVLW  01
82AA:  MOVLB  3
82AC:  MOVWF  xB7
82AE:  MOVLW  0B
82B0:  MOVWF  xB6
82B2:  MOVLB  0
82B4:  CALL   3A5C
82B8:  MOVF   01,W
82BA:  ANDLW  01
82BC:  SUBLW  01
82BE:  BNZ   82D8
....................                 habilitado[contador_lcd] = FALSE; 
82C0:  MOVFF  24,3B5
82C4:  MOVLB  3
82C6:  CLRF   xB6
82C8:  MOVLW  01
82CA:  MOVWF  xB8
82CC:  MOVLW  0B
82CE:  MOVWF  xB7
82D0:  MOVLB  0
82D2:  CALL   3A1A
....................             } else { 
82D6:  BRA    82EE
....................                 habilitado[contador_lcd] = TRUE; 
82D8:  MOVFF  24,3B5
82DC:  MOVLW  01
82DE:  MOVLB  3
82E0:  MOVWF  xB6
82E2:  MOVWF  xB8
82E4:  MOVLW  0B
82E6:  MOVWF  xB7
82E8:  MOVLB  0
82EA:  CALL   3A1A
....................             }             
....................             menu_atual = menu_dados_ponto; 
82EE:  MOVLW  10
82F0:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
82F2:  MOVFF  24,3AD
82F6:  CALL   68A8
....................         break; 
82FA:  BRA    844A
....................         case 8: 
....................            if (contador_lcd < (pontos_no_modelo/2)){ 
82FC:  BCF    FD8.0
82FE:  MOVLB  1
8300:  RRCF   x0A,W
8302:  SUBWF  24,W
8304:  BC    8316
....................                 sobe_ferros(3); 
8306:  MOVLW  03
8308:  MOVLB  3
830A:  MOVWF  xB2
830C:  MOVLB  0
830E:  CALL   6D26
....................             } else { 
8312:  BRA    8322
8314:  MOVLB  1
....................                 sobe_ferros(2); 
8316:  MOVLW  02
8318:  MOVLB  3
831A:  MOVWF  xB2
831C:  MOVLB  0
831E:  CALL   6D26
....................             } 
....................             desliga_pressor(); 
8322:  CALL   6AA8
....................         break; 
8326:  BRA    844A
....................         case 0: 
....................             if (contador_lcd < (pontos_no_modelo/2)){ 
8328:  BCF    FD8.0
832A:  MOVLB  1
832C:  RRCF   x0A,W
832E:  SUBWF  24,W
8330:  BC    8342
....................                 desce_ferros(3); 
8332:  MOVLW  03
8334:  MOVLB  3
8336:  MOVWF  xB2
8338:  MOVLB  0
833A:  CALL   6D62
....................             } else { 
833E:  BRA    834E
8340:  MOVLB  1
....................                 desce_ferros(2); 
8342:  MOVLW  02
8344:  MOVLB  3
8346:  MOVWF  xB2
8348:  MOVLB  0
834A:  CALL   6D62
....................             } 
....................             liga_pressor(); 
834E:  CALL   6516
....................         break; 
8352:  BRA    844A
....................         case F1: 
....................             printf(lcd_putc, "\f"); // limpa display 
8354:  MOVLW  0C
8356:  MOVLB  3
8358:  MOVWF  xBD
835A:  MOVLB  0
835C:  CALL   2436
....................             printf(lcd_putc, "GRAVANDO PONTO\n\r"); 
8360:  MOVLW  90
8362:  MOVWF  FF6
8364:  MOVLW  0E
8366:  MOVWF  FF7
8368:  CALL   248A
....................             delay_ms(2000); 
836C:  MOVLW  08
836E:  MOVLB  3
8370:  MOVWF  xAD
8372:  MOVLW  FA
8374:  MOVWF  xBE
8376:  MOVLB  0
8378:  CALL   2064
837C:  MOVLB  3
837E:  DECFSZ xAD,F
8380:  BRA    8372
....................             escrever_ponto_memoria(modelo,contador_lcd); 
8382:  MOVFF  2D,3AD
8386:  MOVFF  24,3AE
838A:  MOVLB  0
838C:  GOTO   6D9E
....................             printf(lcd_putc, "\f"); // limpa display 
8390:  MOVLW  0C
8392:  MOVLB  3
8394:  MOVWF  xBD
8396:  MOVLB  0
8398:  CALL   2436
....................             printf(lcd_putc, "PONTO GRAVADO\n\r"); 
839C:  MOVLW  A2
839E:  MOVWF  FF6
83A0:  MOVLW  0E
83A2:  MOVWF  FF7
83A4:  CALL   248A
....................             delay_ms(2000); 
83A8:  MOVLW  08
83AA:  MOVLB  3
83AC:  MOVWF  xAD
83AE:  MOVLW  FA
83B0:  MOVWF  xBE
83B2:  MOVLB  0
83B4:  CALL   2064
83B8:  MOVLB  3
83BA:  DECFSZ xAD,F
83BC:  BRA    83AE
....................             menu_atual = menu_seleciona_pontos; 
83BE:  MOVLW  0F
83C0:  MOVWF  1C
....................             tela_seleciona_pontos(); 
83C2:  MOVLB  0
83C4:  CALL   6526
....................             contador_lcd = 0; 
83C8:  CLRF   24
....................             motor_run_z(0, 19); 
83CA:  MOVLB  3
83CC:  CLRF   xB7
83CE:  CLRF   xB6
83D0:  CLRF   xB5
83D2:  CLRF   xB4
83D4:  MOVLW  13
83D6:  MOVWF  xB8
83D8:  MOVLB  0
83DA:  CALL   5638
....................             while ((run_flg_z)); 
83DE:  MOVLB  3
83E0:  BTFSC  x9B.0
83E2:  BRA    83E0
....................             sobe_ferros(3); 
83E4:  MOVLW  03
83E6:  MOVWF  xB2
83E8:  MOVLB  0
83EA:  CALL   6D26
....................         break; 
83EE:  BRA    844A
....................         case ESC: 
....................             menu_atual = menu_seleciona_pontos; 
83F0:  MOVLW  0F
83F2:  MOVWF  1C
....................             tela_seleciona_pontos(); 
83F4:  CALL   6526
....................             contador_lcd = 0; 
83F8:  CLRF   24
....................             motor_run_z(0, 19); 
83FA:  MOVLB  3
83FC:  CLRF   xB7
83FE:  CLRF   xB6
8400:  CLRF   xB5
8402:  CLRF   xB4
8404:  MOVLW  13
8406:  MOVWF  xB8
8408:  MOVLB  0
840A:  CALL   5638
....................             while ((run_flg_z)); 
840E:  MOVLB  3
8410:  BTFSC  x9B.0
8412:  BRA    8410
....................             sobe_ferros(3); 
8414:  MOVLW  03
8416:  MOVWF  xB2
8418:  MOVLB  0
841A:  CALL   6D26
....................         break; 
841E:  BRA    844A
....................         case ENTER: 
....................             soldar_teste(tipo[contador_lcd],contador_lcd); 
8420:  CLRF   03
8422:  MOVF   24,W
8424:  ADDLW  F6
8426:  MOVWF  FE9
8428:  MOVLW  00
842A:  ADDWFC 03,W
842C:  MOVWF  FEA
842E:  MOVFF  FEF,3AD
8432:  MOVFF  3AD,3AE
8436:  MOVFF  24,3AF
843A:  GOTO   7164
....................             menu_atual = menu_dados_ponto; 
843E:  MOVLW  10
8440:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
8442:  MOVFF  24,3AD
8446:  CALL   68A8
....................         break;  
....................     } 
844A:  GOTO   A998 (RETURN)
.................... } 
....................  
.................... void atualiza_tela_seleciona_manutencao(){ 
....................     switch(Teclado())    { 
*
87C2:  CALL   5054
87C6:  MOVF   01,W
87C8:  XORLW  0A
87CA:  BZ    87D6
87CC:  XORLW  01
87CE:  BZ    87DE
87D0:  XORLW  19
87D2:  BZ    87E6
87D4:  BRA    87EE
....................         case F1:  
....................             menu_atual = menu_debug_entrada_1; 
87D6:  MOVLW  04
87D8:  MOVWF  1C
....................             tela_debug_entrada_1(); 
87DA:  RCALL  857A
....................         break; 
87DC:  BRA    87EE
....................         case F2: 
....................             menu_atual = menu_debug_saida_1; 
87DE:  MOVLW  08
87E0:  MOVWF  1C
....................             tela_debug_saida_1(); 
87E2:  RCALL  8768
....................         break; 
87E4:  BRA    87EE
....................         case ESC: 
....................             menu_atual = menu_seleciona_debug; 
87E6:  MOVLW  02
87E8:  MOVWF  1C
....................             tela_seleciona_debug(); 
87EA:  CALL   6468
....................         break; 
....................     } 
87EE:  GOTO   A9A8 (RETURN)
.................... } 
.................... void atualiza_tela_debug_entrada_1(){ 
....................     while (Teclado() == 0xff ){ 
*
89E0:  CALL   5054
89E4:  INCFSZ 01,W
89E6:  BRA    8A38
....................         for (int i=0; i<9; i++){ 
89E8:  MOVLB  3
89EA:  CLRF   xAD
89EC:  MOVF   xAD,W
89EE:  SUBLW  08
89F0:  BNC   8A32
....................             if (le_Input(i) == true){ 
89F2:  MOVFF  3AD,3B2
89F6:  MOVLB  0
89F8:  CALL   4090
89FC:  DECFSZ 01,W
89FE:  BRA    8A18
....................                 entradas [i] = 1; 
8A00:  MOVFF  3AD,3B5
8A04:  MOVLW  01
8A06:  MOVLB  3
8A08:  MOVWF  xB6
8A0A:  CLRF   xB8
8A0C:  MOVLW  1D
8A0E:  MOVWF  xB7
8A10:  MOVLB  0
8A12:  CALL   3A1A
....................             } else { 
8A16:  BRA    8A2C
....................                 entradas [i] = 0; 
8A18:  MOVFF  3AD,3B5
8A1C:  MOVLB  3
8A1E:  CLRF   xB6
8A20:  CLRF   xB8
8A22:  MOVLW  1D
8A24:  MOVWF  xB7
8A26:  MOVLB  0
8A28:  CALL   3A1A
....................             } 
8A2C:  MOVLB  3
8A2E:  INCF   xAD,F
8A30:  BRA    89EC
....................         } 
....................         tela_debug_entrada_1(); 
8A32:  MOVLB  0
8A34:  RCALL  857A
8A36:  BRA    89E0
....................     } 
....................     switch(Teclado()){ 
8A38:  CALL   5054
8A3C:  MOVF   01,W
8A3E:  XORLW  10
8A40:  BZ    8A48
8A42:  XORLW  02
8A44:  BZ    8A50
8A46:  BRA    8A58
....................         case SETA_DIREITA:  
....................             menu_atual = menu_debug_entrada_2; 
8A48:  MOVLW  05
8A4A:  MOVWF  1C
....................             tela_debug_entrada_2(); 
8A4C:  RCALL  87F2
....................             break;         
8A4E:  BRA    8A58
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
8A50:  MOVLW  03
8A52:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
8A54:  CALL   6622
....................         break; 
....................     } 
8A58:  GOTO   A9B0 (RETURN)
.................... } 
.................... void atualiza_tela_debug_entrada_2 () { 
....................     while (Teclado () == 0xff ){ 
*
8C7E:  CALL   5054
8C82:  INCFSZ 01,W
8C84:  BRA    8CD8
....................         for (int i=9; i<18; i++){ 
8C86:  MOVLW  09
8C88:  MOVLB  3
8C8A:  MOVWF  xAD
8C8C:  MOVF   xAD,W
8C8E:  SUBLW  11
8C90:  BNC   8CD4
....................             if (le_Input(i) == true){ 
8C92:  MOVFF  3AD,3B2
8C96:  MOVLB  0
8C98:  CALL   4090
8C9C:  DECFSZ 01,W
8C9E:  BRA    8CB8
....................                 entradas [i] = 1; 
8CA0:  MOVFF  3AD,3B5
8CA4:  MOVLW  01
8CA6:  MOVLB  3
8CA8:  MOVWF  xB6
8CAA:  CLRF   xB8
8CAC:  MOVLW  1D
8CAE:  MOVWF  xB7
8CB0:  MOVLB  0
8CB2:  CALL   3A1A
....................             } else { 
8CB6:  BRA    8CCC
....................                 entradas [i] = 0; 
8CB8:  MOVFF  3AD,3B5
8CBC:  MOVLB  3
8CBE:  CLRF   xB6
8CC0:  CLRF   xB8
8CC2:  MOVLW  1D
8CC4:  MOVWF  xB7
8CC6:  MOVLB  0
8CC8:  CALL   3A1A
....................             } 
....................             tela_debug_entrada_2(); 
8CCC:  RCALL  87F2
8CCE:  MOVLB  3
8CD0:  INCF   xAD,F
8CD2:  BRA    8C8C
....................         } 
8CD4:  MOVLB  0
8CD6:  BRA    8C7E
....................     } 
....................     switch(Teclado()){ 
8CD8:  CALL   5054
8CDC:  MOVF   01,W
8CDE:  XORLW  11
8CE0:  BZ    8CEC
8CE2:  XORLW  01
8CE4:  BZ    8CF4
8CE6:  XORLW  02
8CE8:  BZ    8CFC
8CEA:  BRA    8D04
....................         case SETA_ESQUERDA:  
....................             menu_atual = menu_debug_entrada_1; 
8CEC:  MOVLW  04
8CEE:  MOVWF  1C
....................             tela_debug_entrada_1(); 
8CF0:  RCALL  857A
....................             break; 
8CF2:  BRA    8D04
....................         case SETA_DIREITA:  
....................             menu_atual = menu_debug_entrada_3; 
8CF4:  MOVLW  06
8CF6:  MOVWF  1C
....................             tela_debug_entrada_3(); 
8CF8:  RCALL  8A5C
....................             break; 
8CFA:  BRA    8D04
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
8CFC:  MOVLW  03
8CFE:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
8D00:  CALL   6622
....................         break; 
....................     } 
8D04:  GOTO   A9B8 (RETURN)
.................... } 
.................... void atualiza_tela_debug_entrada_3 (){ 
....................     while (Teclado() == 0xff){ 
8D08:  CALL   5054
8D0C:  INCFSZ 01,W
8D0E:  BRA    8D62
....................         for (int i=18; i<28; i++){ 
8D10:  MOVLW  12
8D12:  MOVLB  3
8D14:  MOVWF  xAD
8D16:  MOVF   xAD,W
8D18:  SUBLW  1B
8D1A:  BNC   8D5C
....................             if (le_Input(i) == true){ 
8D1C:  MOVFF  3AD,3B2
8D20:  MOVLB  0
8D22:  CALL   4090
8D26:  DECFSZ 01,W
8D28:  BRA    8D42
....................                 entradas [i] = 1; 
8D2A:  MOVFF  3AD,3B5
8D2E:  MOVLW  01
8D30:  MOVLB  3
8D32:  MOVWF  xB6
8D34:  CLRF   xB8
8D36:  MOVLW  1D
8D38:  MOVWF  xB7
8D3A:  MOVLB  0
8D3C:  CALL   3A1A
....................             } else { 
8D40:  BRA    8D56
....................                 entradas [i] = 0; 
8D42:  MOVFF  3AD,3B5
8D46:  MOVLB  3
8D48:  CLRF   xB6
8D4A:  CLRF   xB8
8D4C:  MOVLW  1D
8D4E:  MOVWF  xB7
8D50:  MOVLB  0
8D52:  CALL   3A1A
....................             } 
8D56:  MOVLB  3
8D58:  INCF   xAD,F
8D5A:  BRA    8D16
....................         } 
....................         tela_debug_entrada_3(); 
8D5C:  MOVLB  0
8D5E:  RCALL  8A5C
8D60:  BRA    8D08
....................     } 
....................     switch(Teclado()){ 
8D62:  CALL   5054
8D66:  MOVF   01,W
8D68:  XORLW  11
8D6A:  BZ    8D72
8D6C:  XORLW  03
8D6E:  BZ    8D7A
8D70:  BRA    8D82
....................         case SETA_ESQUERDA:  
....................             menu_atual = menu_debug_entrada_2; 
8D72:  MOVLW  05
8D74:  MOVWF  1C
....................             tela_debug_entrada_2(); 
8D76:  RCALL  87F2
....................             break; 
8D78:  BRA    8D82
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
8D7A:  MOVLW  03
8D7C:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
8D7E:  CALL   6622
....................         break; 
....................     } 
8D82:  GOTO   A9C0 (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_1(){ 
....................     switch(Teclado()){ 
*
8DE0:  CALL   5054
8DE4:  MOVLW  0A
8DE6:  SUBWF  01,W
8DE8:  ADDLW  F7
8DEA:  BTFSC  FD8.0
8DEC:  BRA    8EFC
8DEE:  ADDLW  09
8DF0:  GOTO   8F00
....................         case F1: 
....................             switch(ponteiro_lcd){ 
8DF4:  MOVF   21,W
8DF6:  XORLW  01
8DF8:  BZ    8E04
8DFA:  XORLW  03
8DFC:  BZ    8E14
8DFE:  XORLW  01
8E00:  BZ    8E24
8E02:  BRA    8E54
....................                 case 1: 
....................                     aciona_saida(RELE_ESTEIRA); 
8E04:  MOVLB  3
8E06:  CLRF   xB8
8E08:  MOVLW  0A
8E0A:  MOVWF  xB7
8E0C:  MOVLB  0
8E0E:  CALL   2522
....................                 break; 
8E12:  BRA    8E54
....................                 case 2: 
....................                     aciona_saida(DEDO_ENTRADA); 
8E14:  MOVLB  3
8E16:  CLRF   xB8
8E18:  MOVLW  07
8E1A:  MOVWF  xB7
8E1C:  MOVLB  0
8E1E:  CALL   2522
....................                 break; 
8E22:  BRA    8E54
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
8E24:  MOVLB  3
8E26:  CLRF   xB8
8E28:  MOVLW  06
8E2A:  MOVWF  xB7
8E2C:  MOVLB  0
8E2E:  CALL   2522
....................                     delay_ms(3000); 
8E32:  MOVLW  0C
8E34:  MOVLB  3
8E36:  MOVWF  xAD
8E38:  MOVLW  FA
8E3A:  MOVWF  xBE
8E3C:  MOVLB  0
8E3E:  CALL   2064
8E42:  MOVLB  3
8E44:  DECFSZ xAD,F
8E46:  BRA    8E38
....................                     desaciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
8E48:  CLRF   xB8
8E4A:  MOVLW  06
8E4C:  MOVWF  xB7
8E4E:  MOVLB  0
8E50:  CALL   24E0
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_1; 
8E54:  MOVLW  08
8E56:  MOVWF  1C
....................             tela_debug_saida_1(); 
8E58:  RCALL  8768
....................         break; 
8E5A:  BRA    8EFC
....................         case F2:             
....................             switch(ponteiro_lcd){ 
8E5C:  MOVF   21,W
8E5E:  XORLW  01
8E60:  BZ    8E6C
8E62:  XORLW  03
8E64:  BZ    8E7C
8E66:  XORLW  01
8E68:  BZ    8E8C
8E6A:  BRA    8EBC
....................                 case 1: 
....................                     desaciona_saida(RELE_ESTEIRA); 
8E6C:  MOVLB  3
8E6E:  CLRF   xB8
8E70:  MOVLW  0A
8E72:  MOVWF  xB7
8E74:  MOVLB  0
8E76:  CALL   24E0
....................                 break; 
8E7A:  BRA    8EBC
....................                 case 2: 
....................                     desaciona_saida(DEDO_ENTRADA); 
8E7C:  MOVLB  3
8E7E:  CLRF   xB8
8E80:  MOVLW  07
8E82:  MOVWF  xB7
8E84:  MOVLB  0
8E86:  CALL   24E0
....................                 break; 
8E8A:  BRA    8EBC
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
8E8C:  MOVLB  3
8E8E:  CLRF   xB8
8E90:  MOVLW  05
8E92:  MOVWF  xB7
8E94:  MOVLB  0
8E96:  CALL   2522
....................                     delay_ms(3000); 
8E9A:  MOVLW  0C
8E9C:  MOVLB  3
8E9E:  MOVWF  xAD
8EA0:  MOVLW  FA
8EA2:  MOVWF  xBE
8EA4:  MOVLB  0
8EA6:  CALL   2064
8EAA:  MOVLB  3
8EAC:  DECFSZ xAD,F
8EAE:  BRA    8EA0
....................                     desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
8EB0:  CLRF   xB8
8EB2:  MOVLW  05
8EB4:  MOVWF  xB7
8EB6:  MOVLB  0
8EB8:  CALL   24E0
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_1; 
8EBC:  MOVLW  08
8EBE:  MOVWF  1C
....................             tela_debug_saida_1(); 
8EC0:  RCALL  8768
....................         break; 
8EC2:  BRA    8EFC
....................         case SETA_DIREITA: 
....................             ponteiro_lcd = 1; 
8EC4:  MOVLW  01
8EC6:  MOVWF  21
....................             menu_atual = menu_debug_saida_2; 
8EC8:  MOVLW  09
8ECA:  MOVWF  1C
....................             tela_debug_saida_2(); 
8ECC:  RCALL  8D86
....................         break; 
8ECE:  BRA    8EFC
....................         case SETA_SUPERIOR: 
....................             if (ponteiro_lcd > 1){ 
8ED0:  MOVF   21,W
8ED2:  SUBLW  01
8ED4:  BC    8ED8
....................                 ponteiro_lcd --; 
8ED6:  DECF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_1; 
8ED8:  MOVLW  08
8EDA:  MOVWF  1C
....................             tela_debug_saida_1(); 
8EDC:  RCALL  8768
....................         break; 
8EDE:  BRA    8EFC
....................         case SETA_INFERIOR: 
....................             if (ponteiro_lcd < 3){ 
8EE0:  MOVF   21,W
8EE2:  SUBLW  02
8EE4:  BNC   8EE8
....................                 ponteiro_lcd ++; 
8EE6:  INCF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_1; 
8EE8:  MOVLW  08
8EEA:  MOVWF  1C
....................             tela_debug_saida_1(); 
8EEC:  RCALL  8768
....................         break; 
8EEE:  BRA    8EFC
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
8EF0:  MOVLW  03
8EF2:  MOVWF  1C
....................             tela_seleciona_manutencao();   
8EF4:  CALL   6622
....................             ponteiro_lcd = 1; 
8EF8:  MOVLW  01
8EFA:  MOVWF  21
....................         break; 
....................     } 
8EFC:  GOTO   A9C8 (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_2(){ 
....................     switch(Teclado()){ 
*
8F90:  CALL   5054
8F94:  MOVLW  0A
8F96:  SUBWF  01,W
8F98:  ADDLW  F7
8F9A:  BTFSC  FD8.0
8F9C:  BRA    90B6
8F9E:  ADDLW  09
8FA0:  GOTO   90BA
....................         case F1: 
....................             switch(ponteiro_lcd){ 
8FA4:  MOVF   21,W
8FA6:  XORLW  01
8FA8:  BZ    8FB4
8FAA:  XORLW  03
8FAC:  BZ    8FC4
8FAE:  XORLW  01
8FB0:  BZ    8FD4
8FB2:  BRA    9000
....................                 case 1: 
....................                     aciona_saida(PRESSOR); 
8FB4:  MOVLB  3
8FB6:  CLRF   xB8
8FB8:  MOVLW  04
8FBA:  MOVWF  xB7
8FBC:  MOVLB  0
8FBE:  CALL   2522
....................                 break; 
8FC2:  BRA    9000
....................                 case 2: 
....................                     aciona_saida(DEDO_SAIDA); 
8FC4:  MOVLB  3
8FC6:  CLRF   xB8
8FC8:  MOVLW  01
8FCA:  MOVWF  xB7
8FCC:  MOVLB  0
8FCE:  CALL   2522
....................                 break; 
8FD2:  BRA    9000
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
8FD4:  MOVLB  3
8FD6:  CLRF   xB8
8FD8:  CLRF   xB7
8FDA:  MOVLB  0
8FDC:  CALL   2522
....................                     delay_ms(3000); 
8FE0:  MOVLW  0C
8FE2:  MOVLB  3
8FE4:  MOVWF  xAD
8FE6:  MOVLW  FA
8FE8:  MOVWF  xBE
8FEA:  MOVLB  0
8FEC:  CALL   2064
8FF0:  MOVLB  3
8FF2:  DECFSZ xAD,F
8FF4:  BRA    8FE6
....................                     desaciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
8FF6:  CLRF   xB8
8FF8:  CLRF   xB7
8FFA:  MOVLB  0
8FFC:  CALL   24E0
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_2; 
9000:  MOVLW  09
9002:  MOVWF  1C
....................             tela_debug_saida_2(); 
9004:  RCALL  8D86
....................         break; 
9006:  BRA    90B6
....................         case F2:             
....................             switch(ponteiro_lcd){ 
9008:  MOVF   21,W
900A:  XORLW  01
900C:  BZ    9018
900E:  XORLW  03
9010:  BZ    9028
9012:  XORLW  01
9014:  BZ    9038
9016:  BRA    9068
....................                 case 1: 
....................                     desaciona_saida(PRESSOR); 
9018:  MOVLB  3
901A:  CLRF   xB8
901C:  MOVLW  04
901E:  MOVWF  xB7
9020:  MOVLB  0
9022:  CALL   24E0
....................                 break; 
9026:  BRA    9068
....................                 case 2: 
....................                     desaciona_saida(DEDO_SAIDA); 
9028:  MOVLB  3
902A:  CLRF   xB8
902C:  MOVLW  01
902E:  MOVWF  xB7
9030:  MOVLB  0
9032:  CALL   24E0
....................                 break; 
9036:  BRA    9068
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
9038:  MOVLB  3
903A:  CLRF   xB8
903C:  MOVLW  0F
903E:  MOVWF  xB7
9040:  MOVLB  0
9042:  CALL   2522
....................                     delay_ms(3000); 
9046:  MOVLW  0C
9048:  MOVLB  3
904A:  MOVWF  xAD
904C:  MOVLW  FA
904E:  MOVWF  xBE
9050:  MOVLB  0
9052:  CALL   2064
9056:  MOVLB  3
9058:  DECFSZ xAD,F
905A:  BRA    904C
....................                     desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
905C:  CLRF   xB8
905E:  MOVLW  0F
9060:  MOVWF  xB7
9062:  MOVLB  0
9064:  CALL   24E0
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_2; 
9068:  MOVLW  09
906A:  MOVWF  1C
....................             tela_debug_saida_2(); 
906C:  RCALL  8D86
....................         break; 
906E:  BRA    90B6
....................         case SETA_DIREITA: 
....................             ponteiro_lcd = 1; 
9070:  MOVLW  01
9072:  MOVWF  21
....................             menu_atual = menu_debug_saida_3; 
9074:  MOVLW  0A
9076:  MOVWF  1C
....................             tela_debug_saida_3(); 
9078:  RCALL  8F36
....................         break; 
907A:  BRA    90B6
....................         case SETA_ESQUERDA: 
....................             ponteiro_lcd = 1; 
907C:  MOVLW  01
907E:  MOVWF  21
....................             menu_atual = menu_debug_saida_1; 
9080:  MOVLW  08
9082:  MOVWF  1C
....................             tela_debug_saida_1(); 
9084:  CALL   8768
....................         break; 
9088:  BRA    90B6
....................         case SETA_SUPERIOR: 
....................             if (ponteiro_lcd > 1){ 
908A:  MOVF   21,W
908C:  SUBLW  01
908E:  BC    9092
....................                 ponteiro_lcd --; 
9090:  DECF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_2; 
9092:  MOVLW  09
9094:  MOVWF  1C
....................             tela_debug_saida_2(); 
9096:  RCALL  8D86
....................         break; 
9098:  BRA    90B6
....................         case SETA_INFERIOR: 
....................             if (ponteiro_lcd < 3){ 
909A:  MOVF   21,W
909C:  SUBLW  02
909E:  BNC   90A2
....................                 ponteiro_lcd ++; 
90A0:  INCF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_2; 
90A2:  MOVLW  09
90A4:  MOVWF  1C
....................             tela_debug_saida_2(); 
90A6:  RCALL  8D86
....................         break; 
90A8:  BRA    90B6
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
90AA:  MOVLW  03
90AC:  MOVWF  1C
....................             tela_seleciona_manutencao();   
90AE:  CALL   6622
....................             ponteiro_lcd = 1; 
90B2:  MOVLW  01
90B4:  MOVWF  21
....................         break; 
....................     } 
90B6:  GOTO   A9D0 (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_3(){ 
....................     switch(Teclado()){ 
*
91CE:  CALL   5054
91D2:  MOVLW  0A
91D4:  SUBWF  01,W
91D6:  ADDLW  F7
91D8:  BTFSC  FD8.0
91DA:  BRA    9322
91DC:  ADDLW  09
91DE:  GOTO   9326
....................         case F1: 
....................             switch(ponteiro_lcd){ 
91E2:  MOVF   21,W
91E4:  XORLW  01
91E6:  BZ    91F2
91E8:  XORLW  03
91EA:  BZ    921E
91EC:  XORLW  01
91EE:  BZ    923C
91F0:  BRA    9258
....................                 case 1: 
....................                     aciona_saida(ALIMENTADOR1); 
91F2:  MOVLB  3
91F4:  CLRF   xB8
91F6:  MOVLW  0E
91F8:  MOVWF  xB7
91FA:  MOVLB  0
91FC:  CALL   2522
....................                     aciona_saida(ALIMENTADOR2); 
9200:  MOVLB  3
9202:  CLRF   xB8
9204:  MOVLW  0D
9206:  MOVWF  xB7
9208:  MOVLB  0
920A:  CALL   2522
....................                     aciona_saida(ALIMENTADOR3); 
920E:  MOVLB  3
9210:  CLRF   xB8
9212:  MOVLW  0C
9214:  MOVWF  xB7
9216:  MOVLB  0
9218:  CALL   2522
....................                 break; 
921C:  BRA    9258
....................                 case 2: 
....................                     aciona_saida(LIMPA_BICO1); 
921E:  MOVLB  3
9220:  CLRF   xB8
9222:  MOVLW  08
9224:  MOVWF  xB7
9226:  MOVLB  0
9228:  CALL   2522
....................                     aciona_saida(LIMPA_BICO2); 
922C:  MOVLB  3
922E:  CLRF   xB8
9230:  MOVLW  09
9232:  MOVWF  xB7
9234:  MOVLB  0
9236:  CALL   2522
....................                 break; 
923A:  BRA    9258
....................                 case 3: 
....................                     aciona_saida(FERRO_SOLDA1); 
923C:  MOVLB  3
923E:  CLRF   xB8
9240:  MOVLW  03
9242:  MOVWF  xB7
9244:  MOVLB  0
9246:  CALL   2522
....................                     aciona_saida(FERRO_SOLDA2); 
924A:  MOVLB  3
924C:  CLRF   xB8
924E:  MOVLW  02
9250:  MOVWF  xB7
9252:  MOVLB  0
9254:  CALL   2522
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_3; 
9258:  MOVLW  0A
925A:  MOVWF  1C
....................             tela_debug_saida_3(); 
925C:  RCALL  8F36
....................         break; 
925E:  BRA    9322
....................         case F2:             
....................             switch(ponteiro_lcd){ 
9260:  MOVF   21,W
9262:  XORLW  01
9264:  BZ    9270
9266:  XORLW  03
9268:  BZ    929C
926A:  XORLW  01
926C:  BZ    92BA
926E:  BRA    92D6
....................                 case 1: 
....................                     desaciona_saida(ALIMENTADOR1); 
9270:  MOVLB  3
9272:  CLRF   xB8
9274:  MOVLW  0E
9276:  MOVWF  xB7
9278:  MOVLB  0
927A:  CALL   24E0
....................                     desaciona_saida(ALIMENTADOR2); 
927E:  MOVLB  3
9280:  CLRF   xB8
9282:  MOVLW  0D
9284:  MOVWF  xB7
9286:  MOVLB  0
9288:  CALL   24E0
....................                     desaciona_saida(ALIMENTADOR3); 
928C:  MOVLB  3
928E:  CLRF   xB8
9290:  MOVLW  0C
9292:  MOVWF  xB7
9294:  MOVLB  0
9296:  CALL   24E0
....................                 break; 
929A:  BRA    92D6
....................                 case 2: 
....................                     desaciona_saida(LIMPA_BICO1); 
929C:  MOVLB  3
929E:  CLRF   xB8
92A0:  MOVLW  08
92A2:  MOVWF  xB7
92A4:  MOVLB  0
92A6:  CALL   24E0
....................                     desaciona_saida(LIMPA_BICO2); 
92AA:  MOVLB  3
92AC:  CLRF   xB8
92AE:  MOVLW  09
92B0:  MOVWF  xB7
92B2:  MOVLB  0
92B4:  CALL   24E0
....................                 break; 
92B8:  BRA    92D6
....................                 case 3: 
....................                     desaciona_saida(FERRO_SOLDA1); 
92BA:  MOVLB  3
92BC:  CLRF   xB8
92BE:  MOVLW  03
92C0:  MOVWF  xB7
92C2:  MOVLB  0
92C4:  CALL   24E0
....................                     desaciona_saida(FERRO_SOLDA2); 
92C8:  MOVLB  3
92CA:  CLRF   xB8
92CC:  MOVLW  02
92CE:  MOVWF  xB7
92D0:  MOVLB  0
92D2:  CALL   24E0
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_3; 
92D6:  MOVLW  0A
92D8:  MOVWF  1C
....................             tela_debug_saida_3(); 
92DA:  RCALL  8F36
....................         break; 
92DC:  BRA    9322
....................         case SETA_DIREITA: 
....................             ponteiro_lcd = 1; 
92DE:  MOVLW  01
92E0:  MOVWF  21
....................             menu_atual = menu_debug_saida_4; 
92E2:  MOVLW  0B
92E4:  MOVWF  1C
....................             tela_debug_saida_4(); 
92E6:  RCALL  90F0
....................         break; 
92E8:  BRA    9322
....................         case SETA_ESQUERDA: 
....................             ponteiro_lcd = 1; 
92EA:  MOVLW  01
92EC:  MOVWF  21
....................             menu_atual = menu_debug_saida_2; 
92EE:  MOVLW  09
92F0:  MOVWF  1C
....................             tela_debug_saida_2(); 
92F2:  RCALL  8D86
....................         break; 
92F4:  BRA    9322
....................         case SETA_SUPERIOR: 
....................             if (ponteiro_lcd > 1){ 
92F6:  MOVF   21,W
92F8:  SUBLW  01
92FA:  BC    92FE
....................                 ponteiro_lcd --; 
92FC:  DECF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_3; 
92FE:  MOVLW  0A
9300:  MOVWF  1C
....................             tela_debug_saida_3(); 
9302:  RCALL  8F36
....................         break; 
9304:  BRA    9322
....................         case SETA_INFERIOR: 
....................             if (ponteiro_lcd < 3){ 
9306:  MOVF   21,W
9308:  SUBLW  02
930A:  BNC   930E
....................                 ponteiro_lcd ++; 
930C:  INCF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_3; 
930E:  MOVLW  0A
9310:  MOVWF  1C
....................             tela_debug_saida_3(); 
9312:  RCALL  8F36
....................         break; 
9314:  BRA    9322
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
9316:  MOVLW  03
9318:  MOVWF  1C
....................             tela_seleciona_manutencao();   
931A:  CALL   6622
....................             ponteiro_lcd = 1; 
931E:  MOVLW  01
9320:  MOVWF  21
....................         break; 
....................     } 
9322:  GOTO   A9D8 (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_4(){ 
....................     switch(Teclado()){ 
*
935C:  CALL   5054
9360:  MOVF   01,W
9362:  ADDLW  ED
9364:  BTFSC  FD8.0
9366:  BRA    9544
9368:  ADDLW  13
936A:  GOTO   9548
....................         case SETA_SUPERIOR: 
....................             atras(); 
936E:  CALL   4462
....................             if (motor_pos_y < 6110){ 
9372:  MOVLB  1
9374:  MOVF   x15,W
9376:  SUBLW  17
9378:  BNC   93AA
937A:  BNZ   9382
937C:  MOVF   x14,W
937E:  SUBLW  DD
9380:  BNC   93AA
....................                 motor_run_y(motor_pos_y+1, 19); 
9382:  MOVLW  01
9384:  ADDWF  x14,W
9386:  MOVLB  3
9388:  MOVWF  xAD
938A:  MOVLW  00
938C:  MOVLB  1
938E:  ADDWFC x15,W
9390:  MOVLB  3
9392:  MOVWF  xAE
9394:  CLRF   xB7
9396:  CLRF   xB6
9398:  MOVWF  xB5
939A:  MOVFF  3AD,3B4
939E:  MOVLW  13
93A0:  MOVWF  xB8
93A2:  MOVLB  0
93A4:  CALL   5802
93A8:  MOVLB  1
....................             } 
....................             menu_atual = menu_debug_saida_4; 
93AA:  MOVLW  0B
93AC:  MOVWF  1C
....................             tela_debug_saida_4(); 
93AE:  MOVLB  0
93B0:  RCALL  90F0
....................         break; 
93B2:  BRA    9544
....................         case SETA_INFERIOR: 
....................             frente(); 
93B4:  CALL   4420
....................             if (motor_pos_y > 0){ 
93B8:  MOVLB  1
93BA:  MOVF   x14,F
93BC:  BNZ   93C2
93BE:  MOVF   x15,F
93C0:  BZ    93EA
....................                 motor_run_y(motor_pos_y-1, 19);  
93C2:  MOVLW  01
93C4:  SUBWF  x14,W
93C6:  MOVLB  3
93C8:  MOVWF  xAD
93CA:  MOVLW  00
93CC:  MOVLB  1
93CE:  SUBWFB x15,W
93D0:  MOVLB  3
93D2:  MOVWF  xAE
93D4:  CLRF   xB7
93D6:  CLRF   xB6
93D8:  MOVWF  xB5
93DA:  MOVFF  3AD,3B4
93DE:  MOVLW  13
93E0:  MOVWF  xB8
93E2:  MOVLB  0
93E4:  CALL   5802
93E8:  MOVLB  1
....................             } 
....................             menu_atual = menu_debug_saida_4; 
93EA:  MOVLW  0B
93EC:  MOVWF  1C
....................             tela_debug_saida_4(); 
93EE:  MOVLB  0
93F0:  RCALL  90F0
....................         break; 
93F2:  BRA    9544
....................         case SETA_DIREITA: 
....................             direita(); 
93F4:  CALL   458C
....................             if (motor_pos_x > 0){ 
93F8:  MOVLB  1
93FA:  MOVF   x12,F
93FC:  BNZ   9402
93FE:  MOVF   x13,F
9400:  BZ    942A
....................                 motor_run_x(motor_pos_x-1, 19); 
9402:  MOVLW  01
9404:  SUBWF  x12,W
9406:  MOVLB  3
9408:  MOVWF  xAD
940A:  MOVLW  00
940C:  MOVLB  1
940E:  SUBWFB x13,W
9410:  MOVLB  3
9412:  MOVWF  xAE
9414:  CLRF   xB7
9416:  CLRF   xB6
9418:  MOVWF  xB5
941A:  MOVFF  3AD,3B4
941E:  MOVLW  13
9420:  MOVWF  xB8
9422:  MOVLB  0
9424:  CALL   4AB2
9428:  MOVLB  1
....................             } 
....................             menu_atual = menu_debug_saida_4; 
942A:  MOVLW  0B
942C:  MOVWF  1C
....................             tela_debug_saida_4(); 
942E:  MOVLB  0
9430:  RCALL  90F0
....................         break; 
9432:  BRA    9544
....................         case SETA_ESQUERDA: 
....................             esquerda(); 
9434:  CALL   45CE
....................             if (motor_pos_x < 4250){ 
9438:  MOVLB  1
943A:  MOVF   x13,W
943C:  SUBLW  10
943E:  BNC   9470
9440:  BNZ   9448
9442:  MOVF   x12,W
9444:  SUBLW  99
9446:  BNC   9470
....................                 motor_run_x(motor_pos_x+1, 19);  
9448:  MOVLW  01
944A:  ADDWF  x12,W
944C:  MOVLB  3
944E:  MOVWF  xAD
9450:  MOVLW  00
9452:  MOVLB  1
9454:  ADDWFC x13,W
9456:  MOVLB  3
9458:  MOVWF  xAE
945A:  CLRF   xB7
945C:  CLRF   xB6
945E:  MOVWF  xB5
9460:  MOVFF  3AD,3B4
9464:  MOVLW  13
9466:  MOVWF  xB8
9468:  MOVLB  0
946A:  CALL   4AB2
946E:  MOVLB  1
....................             } 
....................             menu_atual = menu_debug_saida_4; 
9470:  MOVLW  0B
9472:  MOVWF  1C
....................             tela_debug_saida_4(); 
9474:  MOVLB  0
9476:  RCALL  90F0
....................         break; 
9478:  BRA    9544
....................         case F2: 
....................             sobe(); 
947A:  CALL   430E
....................             if (motor_pos_z > 0){ 
947E:  MOVLB  1
9480:  MOVF   x18,F
9482:  BNZ   9488
9484:  MOVF   x19,F
9486:  BZ    94B0
....................                  motor_run_z(motor_pos_z-1, 19);  
9488:  MOVLW  01
948A:  SUBWF  x18,W
948C:  MOVLB  3
948E:  MOVWF  xAD
9490:  MOVLW  00
9492:  MOVLB  1
9494:  SUBWFB x19,W
9496:  MOVLB  3
9498:  MOVWF  xAE
949A:  CLRF   xB7
949C:  CLRF   xB6
949E:  MOVWF  xB5
94A0:  MOVFF  3AD,3B4
94A4:  MOVLW  13
94A6:  MOVWF  xB8
94A8:  MOVLB  0
94AA:  CALL   5638
94AE:  MOVLB  1
....................             } 
....................             menu_atual = menu_debug_saida_4; 
94B0:  MOVLW  0B
94B2:  MOVWF  1C
....................             tela_debug_saida_4(); 
94B4:  MOVLB  0
94B6:  RCALL  90F0
....................         break; 
94B8:  BRA    9544
....................         case F4: 
....................             desce(); 
94BA:  CALL   42CC
....................             if (motor_pos_z < 1000){ 
94BE:  MOVLB  1
94C0:  MOVF   x19,W
94C2:  SUBLW  03
94C4:  BNC   94F6
94C6:  BNZ   94CE
94C8:  MOVF   x18,W
94CA:  SUBLW  E7
94CC:  BNC   94F6
....................                 motor_run_x(motor_pos_x+1, 19);  
94CE:  MOVLW  01
94D0:  ADDWF  x12,W
94D2:  MOVLB  3
94D4:  MOVWF  xAD
94D6:  MOVLW  00
94D8:  MOVLB  1
94DA:  ADDWFC x13,W
94DC:  MOVLB  3
94DE:  MOVWF  xAE
94E0:  CLRF   xB7
94E2:  CLRF   xB6
94E4:  MOVWF  xB5
94E6:  MOVFF  3AD,3B4
94EA:  MOVLW  13
94EC:  MOVWF  xB8
94EE:  MOVLB  0
94F0:  CALL   4AB2
94F4:  MOVLB  1
....................             }     
....................             menu_atual = menu_debug_saida_4; 
94F6:  MOVLW  0B
94F8:  MOVWF  1C
....................             tela_debug_saida_4(); 
94FA:  MOVLB  0
94FC:  RCALL  90F0
....................         break; 
94FE:  BRA    9544
....................         case 8: 
....................             sentido_horario(); 
9500:  CALL   4920
....................             go_flip(1866); 
9504:  MOVLW  07
9506:  MOVLB  3
9508:  MOVWF  xB1
950A:  MOVLW  4A
950C:  MOVWF  xB0
950E:  MOVLB  0
9510:  CALL   59A0
....................             menu_atual = menu_debug_saida_4; 
9514:  MOVLW  0B
9516:  MOVWF  1C
....................             tela_debug_saida_4(); 
9518:  RCALL  90F0
....................         break; 
951A:  BRA    9544
....................         case 0: 
....................             sentido_antihorario(); 
951C:  CALL   4962
....................             go_flip(0); 
9520:  MOVLB  3
9522:  CLRF   xB1
9524:  CLRF   xB0
9526:  MOVLB  0
9528:  CALL   59A0
....................             menu_atual = menu_debug_saida_4; 
952C:  MOVLW  0B
952E:  MOVWF  1C
....................             tela_debug_saida_4(); 
9530:  RCALL  90F0
....................         break; 
9532:  BRA    9544
....................         case ESC: 
....................             home_solenoides(); 
9534:  CALL   256E
....................             posicao_maquina_1_default();  
9538:  CALL   4CF0
....................             menu_atual = menu_seleciona_manutencao; 
953C:  MOVLW  03
953E:  MOVWF  1C
....................             tela_seleciona_manutencao();   
9540:  CALL   6622
....................         break; 
....................     } 
9544:  GOTO   A9E0 (RETURN)
.................... } 
....................  
.................... void programa_principal(){ 
....................     int i; 
....................     short x; 
....................     short y; 
....................     while (exit){ 
*
A360:  BTFSS  2C.1
A362:  BRA    A616
....................         for (i=0; i<14; i++){ 
A364:  MOVLB  3
A366:  CLRF   xAD
A368:  MOVF   xAD,W
A36A:  SUBLW  0D
A36C:  BTFSS  FD8.0
A36E:  BRA    A612
....................             switch (i){ 
A370:  MOVF   xAD,W
A372:  ADDLW  F2
A374:  BTFSC  FD8.0
A376:  BRA    A60E
A378:  ADDLW  0E
A37A:  MOVLB  0
A37C:  GOTO   A620
....................                 case 0: 
....................                     liga_esteira(); 
A380:  GOTO   9592
....................                     if (Teclado() == ESC){ 
A384:  CALL   5054
A388:  MOVF   01,W
A38A:  SUBLW  12
A38C:  BNZ   A392
....................                         exit = FALSE; 
A38E:  BCF    2C.1
....................                     } else { 
A390:  BRA    A394
....................                         exit = TRUE; 
A392:  BSF    2C.1
....................                     } 
....................                 break; 
A394:  MOVLB  3
A396:  BRA    A60E
....................                 case 1: 
....................                     x = le_Input(S_ESTEIRA); 
A398:  MOVLW  19
A39A:  MOVLB  3
A39C:  MOVWF  xB2
A39E:  MOVLB  0
A3A0:  CALL   4090
A3A4:  MOVLB  3
A3A6:  BCF    xAE.0
A3A8:  BTFSC  01.0
A3AA:  BSF    xAE.0
....................                     while (x == 0){ 
A3AC:  BTFSC  xAE.0
A3AE:  BRA    A3E8
....................                         printf(lcd_putc, "\f"); //limpa display 
A3B0:  MOVLW  0C
A3B2:  MOVWF  xBD
A3B4:  MOVLB  0
A3B6:  CALL   2436
....................                         printf(lcd_putc, "   ESPERANDO PLACA   \n\r"); 
A3BA:  MOVLW  B2
A3BC:  MOVWF  FF6
A3BE:  MOVLW  0E
A3C0:  MOVWF  FF7
A3C2:  CALL   248A
....................                         printf(lcd_putc, "     NA ESTEIRA     \n\r"); 
A3C6:  MOVLW  CA
A3C8:  MOVWF  FF6
A3CA:  MOVLW  0E
A3CC:  MOVWF  FF7
A3CE:  CALL   248A
....................                         x = le_Input(S_ESTEIRA); 
A3D2:  MOVLW  19
A3D4:  MOVLB  3
A3D6:  MOVWF  xB2
A3D8:  MOVLB  0
A3DA:  CALL   4090
A3DE:  MOVLB  3
A3E0:  BCF    xAE.0
A3E2:  BTFSC  01.0
A3E4:  BSF    xAE.0
A3E6:  BRA    A3AC
....................                     } 
....................                     desliga_esteira(); 
A3E8:  MOVLB  0
A3EA:  GOTO   95A4
....................                     empurra_placa();                     
A3EE:  GOTO   95B6
....................                     if (Teclado() == ESC){ 
A3F2:  CALL   5054
A3F6:  MOVF   01,W
A3F8:  SUBLW  12
A3FA:  BNZ   A400
....................                         exit = FALSE; 
A3FC:  BCF    2C.1
....................                     } else { 
A3FE:  BRA    A402
....................                         exit = TRUE; 
A400:  BSF    2C.1
....................                     } 
....................                 break; 
A402:  MOVLB  3
A404:  BRA    A60E
....................                 case 2: 
....................                     y = le_Input(S_BANDEJA); 
A406:  MOVLW  15
A408:  MOVLB  3
A40A:  MOVWF  xB2
A40C:  MOVLB  0
A40E:  CALL   4090
A412:  MOVLB  3
A414:  BCF    xAE.1
A416:  BTFSC  01.0
A418:  BSF    xAE.1
....................                     while (y == 0){ 
A41A:  BTFSC  xAE.1
A41C:  BRA    A456
....................                         printf(lcd_putc, "\f"); //limpa display 
A41E:  MOVLW  0C
A420:  MOVWF  xBD
A422:  MOVLB  0
A424:  CALL   2436
....................                         printf(lcd_putc, "      SEM PLACA     \n\r"); 
A428:  MOVLW  E2
A42A:  MOVWF  FF6
A42C:  MOVLW  0E
A42E:  MOVWF  FF7
A430:  CALL   248A
....................                         printf(lcd_putc, "     NA BANDEJA     \n\r"); 
A434:  MOVLW  FA
A436:  MOVWF  FF6
A438:  MOVLW  0E
A43A:  MOVWF  FF7
A43C:  CALL   248A
....................                         y = le_Input(S_BANDEJA); 
A440:  MOVLW  15
A442:  MOVLB  3
A444:  MOVWF  xB2
A446:  MOVLB  0
A448:  CALL   4090
A44C:  MOVLB  3
A44E:  BCF    xAE.1
A450:  BTFSC  01.0
A452:  BSF    xAE.1
A454:  BRA    A41A
....................                     } 
....................                     liga_pressor(); 
A456:  MOVLB  0
A458:  CALL   6516
....................                 if (Teclado() == ESC){ 
A45C:  CALL   5054
A460:  MOVF   01,W
A462:  SUBLW  12
A464:  BNZ   A46A
....................                         exit = FALSE; 
A466:  BCF    2C.1
....................                     } else { 
A468:  BRA    A46C
....................                         exit = TRUE; 
A46A:  BSF    2C.1
....................                     } 
....................                 break; 
A46C:  MOVLB  3
A46E:  BRA    A60E
....................                 case 3: 
....................                     envia_maquina_para_posicao(HOME1); 
A470:  MOVLW  01
A472:  MOVLB  3
A474:  MOVWF  xAF
A476:  MOVLB  0
A478:  CALL   5A14
....................                     if (Teclado() == ESC){ 
A47C:  CALL   5054
A480:  MOVF   01,W
A482:  SUBLW  12
A484:  BNZ   A48A
....................                         exit = FALSE; 
A486:  BCF    2C.1
....................                     } else { 
A488:  BRA    A48C
....................                         exit = TRUE; 
A48A:  BSF    2C.1
....................                     } 
....................                 break;  
A48C:  MOVLB  3
A48E:  BRA    A60E
....................                 case 4: 
....................                     envia_maquina_para_posicao(SOLDAGEM); 
A490:  MOVLW  03
A492:  MOVLB  3
A494:  MOVWF  xAF
A496:  MOVLB  0
A498:  CALL   5A14
....................                     if (Teclado() == ESC){ 
A49C:  CALL   5054
A4A0:  MOVF   01,W
A4A2:  SUBLW  12
A4A4:  BNZ   A4AA
....................                         exit = FALSE; 
A4A6:  BCF    2C.1
....................                     } else { 
A4A8:  BRA    A4AC
....................                         exit = TRUE; 
A4AA:  BSF    2C.1
....................                     } 
....................                 break; 
A4AC:  MOVLB  3
A4AE:  BRA    A60E
....................                 case 5: 
....................                     soldar(); 
A4B0:  GOTO   9662
....................                     motor_run_x(3835, 19); 
A4B4:  MOVLB  3
A4B6:  CLRF   xB7
A4B8:  CLRF   xB6
A4BA:  MOVLW  0E
A4BC:  MOVWF  xB5
A4BE:  MOVLW  FB
A4C0:  MOVWF  xB4
A4C2:  MOVLW  13
A4C4:  MOVWF  xB8
A4C6:  MOVLB  0
A4C8:  CALL   4AB2
....................                     motor_run_y(2540, 19); 
A4CC:  MOVLB  3
A4CE:  CLRF   xB7
A4D0:  CLRF   xB6
A4D2:  MOVLW  09
A4D4:  MOVWF  xB5
A4D6:  MOVLW  EC
A4D8:  MOVWF  xB4
A4DA:  MOVLW  13
A4DC:  MOVWF  xB8
A4DE:  MOVLB  0
A4E0:  CALL   5802
....................                     //go_x(3835); 
....................                     //go_y(2540); 
....................                     if (Teclado() == ESC){ 
A4E4:  CALL   5054
A4E8:  MOVF   01,W
A4EA:  SUBLW  12
A4EC:  BNZ   A4F2
....................                         exit = FALSE; 
A4EE:  BCF    2C.1
....................                     } else { 
A4F0:  BRA    A4F4
....................                         exit = TRUE; 
A4F2:  BSF    2C.1
....................                     } 
....................                 break; 
A4F4:  MOVLB  3
A4F6:  BRA    A60E
....................                 case 6: 
....................                     envia_maquina_para_posicao(HOME2); 
A4F8:  MOVLW  04
A4FA:  MOVLB  3
A4FC:  MOVWF  xAF
A4FE:  MOVLB  0
A500:  CALL   5A14
....................                     if (Teclado() == ESC){ 
A504:  CALL   5054
A508:  MOVF   01,W
A50A:  SUBLW  12
A50C:  BNZ   A512
....................                         exit = FALSE; 
A50E:  BCF    2C.1
....................                     } else { 
A510:  BRA    A514
....................                         exit = TRUE; 
A512:  BSF    2C.1
....................                     } 
....................                 break; 
A514:  MOVLB  3
A516:  BRA    A60E
....................                 case 7: 
....................                     envia_maquina_para_posicao(DISPENSADOR); 
A518:  MOVLW  05
A51A:  MOVLB  3
A51C:  MOVWF  xAF
A51E:  MOVLB  0
A520:  CALL   5A14
....................                     if (Teclado() == ESC){ 
A524:  CALL   5054
A528:  MOVF   01,W
A52A:  SUBLW  12
A52C:  BNZ   A532
....................                         exit = FALSE; 
A52E:  BCF    2C.1
....................                     } else { 
A530:  BRA    A534
....................                         exit = TRUE; 
A532:  BSF    2C.1
....................                     } 
....................                 break; 
A534:  MOVLB  3
A536:  BRA    A60E
....................                 case 8: 
....................                     desliga_pressor(); 
A538:  CALL   6AA8
....................                     dispensa_placa(); 
A53C:  BRA    A25A
....................                     if (Teclado() == ESC){ 
A53E:  CALL   5054
A542:  MOVF   01,W
A544:  SUBLW  12
A546:  BNZ   A54C
....................                         exit = FALSE; 
A548:  BCF    2C.1
....................                     } else { 
A54A:  BRA    A54E
....................                         exit = TRUE; 
A54C:  BSF    2C.1
....................                     } 
....................                 break; 
A54E:  MOVLB  3
A550:  BRA    A60E
....................                 case 9: 
....................                     envia_maquina_para_posicao(HOME2); 
A552:  MOVLW  04
A554:  MOVLB  3
A556:  MOVWF  xAF
A558:  MOVLB  0
A55A:  CALL   5A14
....................                     if (Teclado() == ESC){ 
A55E:  CALL   5054
A562:  MOVF   01,W
A564:  SUBLW  12
A566:  BNZ   A56C
....................                         exit = FALSE; 
A568:  BCF    2C.1
....................                     } else { 
A56A:  BRA    A56E
....................                         exit = TRUE; 
A56C:  BSF    2C.1
....................                     } 
....................                 break; 
A56E:  MOVLB  3
A570:  BRA    A60E
....................                 case 10: 
....................                     envia_maquina_para_posicao(LIMPEZA); 
A572:  MOVLW  06
A574:  MOVLB  3
A576:  MOVWF  xAF
A578:  MOVLB  0
A57A:  CALL   5A14
....................                     limpa_bicos(2000); 
A57E:  MOVLW  07
A580:  MOVLB  3
A582:  MOVWF  xB0
A584:  MOVLW  D0
A586:  MOVWF  xAF
A588:  MOVLB  0
A58A:  RCALL  A302
....................                     if (Teclado() == ESC){ 
A58C:  CALL   5054
A590:  MOVF   01,W
A592:  SUBLW  12
A594:  BNZ   A59A
....................                         exit = FALSE; 
A596:  BCF    2C.1
....................                     } else { 
A598:  BRA    A59C
....................                         exit = TRUE; 
A59A:  BSF    2C.1
....................                     } 
....................                 break; 
A59C:  MOVLB  3
A59E:  BRA    A60E
....................                 case 11: 
....................                     envia_maquina_para_posicao(LIMPEZA_2); 
A5A0:  MOVLW  07
A5A2:  MOVLB  3
A5A4:  MOVWF  xAF
A5A6:  MOVLB  0
A5A8:  CALL   5A14
....................                     limpa_bicos(2000); 
A5AC:  MOVLW  07
A5AE:  MOVLB  3
A5B0:  MOVWF  xB0
A5B2:  MOVLW  D0
A5B4:  MOVWF  xAF
A5B6:  MOVLB  0
A5B8:  RCALL  A302
....................                     if (Teclado() == ESC){ 
A5BA:  CALL   5054
A5BE:  MOVF   01,W
A5C0:  SUBLW  12
A5C2:  BNZ   A5C8
....................                         exit = FALSE; 
A5C4:  BCF    2C.1
....................                     } else { 
A5C6:  BRA    A5CA
....................                         exit = TRUE; 
A5C8:  BSF    2C.1
....................                     } 
....................                 break; 
A5CA:  MOVLB  3
A5CC:  BRA    A60E
....................                 case 12: 
....................                     envia_maquina_para_posicao(HOME1); 
A5CE:  MOVLW  01
A5D0:  MOVLB  3
A5D2:  MOVWF  xAF
A5D4:  MOVLB  0
A5D6:  CALL   5A14
....................                     if (Teclado() == ESC){ 
A5DA:  CALL   5054
A5DE:  MOVF   01,W
A5E0:  SUBLW  12
A5E2:  BNZ   A5E8
....................                         exit = FALSE; 
A5E4:  BCF    2C.1
....................                     } else { 
A5E6:  BRA    A5EA
....................                         exit = TRUE; 
A5E8:  BSF    2C.1
....................                     } 
....................                 break; 
A5EA:  MOVLB  3
A5EC:  BRA    A60E
....................                 case 13: 
....................                     envia_maquina_para_posicao(ALIMENTADOR); 
A5EE:  MOVLB  3
A5F0:  CLRF   xAF
A5F2:  MOVLB  0
A5F4:  CALL   5A14
....................                     if (Teclado() == ESC){ 
A5F8:  CALL   5054
A5FC:  MOVF   01,W
A5FE:  SUBLW  12
A600:  BNZ   A606
....................                         exit = FALSE; 
A602:  BCF    2C.1
....................                     } else { 
A604:  BRA    A608
....................                         exit = TRUE; 
A606:  BSF    2C.1
....................                     } 
....................                 break; 
A608:  MOVLB  3
A60A:  BRA    A60E
A60C:  MOVLB  3
....................             } 
A60E:  INCF   xAD,F
A610:  BRA    A368
....................         } 
A612:  MOVLB  0
A614:  BRA    A360
....................     } 
....................     menu_atual = menu_principal; 
A616:  CLRF   1C
....................     tela_principal(); 
A618:  CALL   4EC4
A61C:  GOTO   A9E6 (RETURN)
.................... } 
....................  
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Interrupoes de Tempo"> 
....................  
.................... #int_timer0 
....................  
.................... void trata_timer0(void) { 
....................     movimenta_eixo_x(); 
*
14B8:  BRA    13F2
.................... } 
14BA:  BCF    FF2.2
14BC:  GOTO   0078
.................... #int_timer1 
....................  
.................... void trata_timer1(void) { 
....................     movimenta_eixo_y(); 
*
1A7C:  BRA    19A0
.................... } 
1A7E:  BCF    F9E.0
1A80:  GOTO   0078
.................... #int_timer2 
....................  
.................... void trata_timer2(void) {//Timer responsavel por contar tempo de execuo 
....................     ciclo++; 
1A84:  MOVLW  01
1A86:  ADDWF  28,F
1A88:  BTFSC  FD8.0
1A8A:  INCF   29,F
1A8C:  BTFSC  FD8.2
1A8E:  INCF   2A,F
1A90:  BTFSC  FD8.2
1A92:  INCF   2B,F
.................... } 
1A94:  BCF    F9E.1
1A96:  GOTO   0078
.................... #int_timer3 
....................  
.................... void trata_timer3(void) { 
....................     movimenta_eixo_z(); 
*
200A:  BRA    1F3A
200C:  BCF    FA1.1
200E:  GOTO   0078
.................... } 
.................... // </editor-fold> 
....................  
.................... void main() {     
*
A660:  CLRF   FF8
A662:  BCF    FD0.7
A664:  BSF    07.7
A666:  BSF    F94.3
A668:  BSF    F94.4
A66A:  MOVLW  31
A66C:  MOVWF  FC8
A66E:  MOVLW  28
A670:  MOVWF  FC6
A672:  BSF    FC7.7
A674:  BCF    FC7.6
A676:  CLRF   1C
A678:  MOVLW  01
A67A:  MOVWF  21
A67C:  CLRF   22
A67E:  MOVLW  03
A680:  MOVWF  23
A682:  CLRF   24
A684:  BSF    2C.0
A686:  BSF    2C.1
A688:  MOVLW  01
A68A:  MOVWF  2D
A68C:  MOVLB  1
A68E:  MOVWF  x0E
A690:  MOVWF  x0F
A692:  CLRF   x21
A694:  CLRF   x20
A696:  MOVLW  48
A698:  MOVWF  x1F
A69A:  MOVLW  86
A69C:  MOVWF  x1E
A69E:  CLRF   x25
A6A0:  CLRF   x24
A6A2:  CLRF   x23
A6A4:  MOVLW  7F
A6A6:  MOVWF  x22
A6A8:  CLRF   x29
A6AA:  CLRF   x28
A6AC:  MOVLW  10
A6AE:  MOVWF  x27
A6B0:  MOVLW  82
A6B2:  MOVWF  x26
A6B4:  CLRF   x2D
A6B6:  CLRF   x2C
A6B8:  MOVLW  16
A6BA:  MOVWF  x2B
A6BC:  MOVLW  86
A6BE:  MOVWF  x2A
A6C0:  CLRF   x31
A6C2:  CLRF   x30
A6C4:  MOVLW  70
A6C6:  MOVWF  x2F
A6C8:  MOVLW  83
A6CA:  MOVWF  x2E
A6CC:  CLRF   x35
A6CE:  CLRF   x34
A6D0:  MOVLW  20
A6D2:  MOVWF  x33
A6D4:  MOVLW  82
A6D6:  MOVWF  x32
A6D8:  CLRF   x39
A6DA:  CLRF   x38
A6DC:  MOVLW  48
A6DE:  MOVWF  x37
A6E0:  MOVLW  86
A6E2:  MOVWF  x36
A6E4:  CLRF   x3D
A6E6:  CLRF   x3C
A6E8:  CLRF   x3B
A6EA:  CLRF   x3A
A6EC:  MOVLW  14
A6EE:  MOVWF  x3E
A6F0:  CLRF   x42
A6F2:  CLRF   x41
A6F4:  CLRF   x40
A6F6:  CLRF   x3F
A6F8:  CLRF   x46
A6FA:  CLRF   x45
A6FC:  MOVLW  48
A6FE:  MOVWF  x44
A700:  MOVLW  85
A702:  MOVWF  x43
A704:  CLRF   xE8
A706:  CLRF   xE7
A708:  CLRF   xE9
A70A:  CLRF   xEA
A70C:  BCF    x1A.3
A70E:  BCF    x1A.4
A710:  CLRF   xEC
A712:  CLRF   xEB
A714:  CLRF   xEE
A716:  CLRF   xED
A718:  CLRF   xF0
A71A:  CLRF   xEF
A71C:  CLRF   xF2
A71E:  CLRF   xF1
A720:  CLRF   xF6
A722:  CLRF   xF5
A724:  CLRF   xF4
A726:  CLRF   xF3
A728:  CLRF   xF7
A72A:  MOVLW  13
A72C:  MOVWF  xF8
A72E:  CLRF   xFC
A730:  CLRF   xFB
A732:  MOVLW  48
A734:  MOVWF  xFA
A736:  MOVLW  86
A738:  MOVWF  xF9
A73A:  MOVLB  2
A73C:  CLRF   x00
A73E:  MOVLB  1
A740:  CLRF   xFF
A742:  CLRF   xFE
A744:  MOVLW  7F
A746:  MOVWF  xFD
A748:  MOVLB  2
A74A:  CLRF   x04
A74C:  CLRF   x03
A74E:  MOVLW  10
A750:  MOVWF  x02
A752:  MOVLW  82
A754:  MOVWF  x01
A756:  CLRF   x08
A758:  CLRF   x07
A75A:  MOVLW  16
A75C:  MOVWF  x06
A75E:  MOVLW  86
A760:  MOVWF  x05
A762:  CLRF   x0C
A764:  CLRF   x0B
A766:  MOVLW  70
A768:  MOVWF  x0A
A76A:  MOVLW  83
A76C:  MOVWF  x09
A76E:  CLRF   x10
A770:  CLRF   x0F
A772:  MOVLW  20
A774:  MOVWF  x0E
A776:  MOVLW  82
A778:  MOVWF  x0D
A77A:  CLRF   x14
A77C:  CLRF   x13
A77E:  MOVLW  48
A780:  MOVWF  x12
A782:  MOVLW  86
A784:  MOVWF  x11
A786:  CLRF   x18
A788:  CLRF   x17
A78A:  CLRF   x16
A78C:  CLRF   x15
A78E:  MOVLW  14
A790:  MOVWF  x19
A792:  CLRF   x1D
A794:  CLRF   x1C
A796:  CLRF   x1B
A798:  CLRF   x1A
A79A:  CLRF   x21
A79C:  CLRF   x20
A79E:  MOVLW  48
A7A0:  MOVWF  x1F
A7A2:  MOVLW  85
A7A4:  MOVWF  x1E
A7A6:  CLRF   xC3
A7A8:  CLRF   xC2
A7AA:  CLRF   xC4
A7AC:  CLRF   xC5
A7AE:  MOVLB  1
A7B0:  BCF    x1A.5
A7B2:  BCF    x1A.6
A7B4:  BCF    x1A.7
A7B6:  MOVLB  2
A7B8:  CLRF   xC7
A7BA:  CLRF   xC6
A7BC:  CLRF   xC9
A7BE:  CLRF   xC8
A7C0:  CLRF   xCB
A7C2:  CLRF   xCA
A7C4:  CLRF   xCD
A7C6:  CLRF   xCC
A7C8:  CLRF   xD1
A7CA:  CLRF   xD0
A7CC:  CLRF   xCF
A7CE:  CLRF   xCE
A7D0:  CLRF   xD2
A7D2:  MOVLW  13
A7D4:  MOVWF  xD3
A7D6:  CLRF   xD5
A7D8:  CLRF   xD4
A7DA:  CLRF   xD9
A7DC:  CLRF   xD8
A7DE:  MOVLW  48
A7E0:  MOVWF  xD7
A7E2:  MOVLW  86
A7E4:  MOVWF  xD6
A7E6:  CLRF   xDD
A7E8:  CLRF   xDC
A7EA:  CLRF   xDB
A7EC:  MOVLW  7F
A7EE:  MOVWF  xDA
A7F0:  CLRF   xE1
A7F2:  CLRF   xE0
A7F4:  MOVLW  10
A7F6:  MOVWF  xDF
A7F8:  MOVLW  82
A7FA:  MOVWF  xDE
A7FC:  CLRF   xE5
A7FE:  CLRF   xE4
A800:  MOVLW  16
A802:  MOVWF  xE3
A804:  MOVLW  86
A806:  MOVWF  xE2
A808:  CLRF   xE9
A80A:  CLRF   xE8
A80C:  MOVLW  20
A80E:  MOVWF  xE7
A810:  MOVLW  84
A812:  MOVWF  xE6
A814:  CLRF   xED
A816:  CLRF   xEC
A818:  MOVLW  48
A81A:  MOVWF  xEB
A81C:  MOVLW  86
A81E:  MOVWF  xEA
A820:  CLRF   xF1
A822:  CLRF   xF0
A824:  CLRF   xEF
A826:  CLRF   xEE
A828:  MOVLW  14
A82A:  MOVWF  xF2
A82C:  CLRF   xF6
A82E:  CLRF   xF5
A830:  CLRF   xF4
A832:  CLRF   xF3
A834:  MOVLB  3
A836:  CLRF   x98
A838:  CLRF   x97
A83A:  CLRF   x99
A83C:  CLRF   x9A
A83E:  BCF    x9B.0
A840:  BCF    x9B.1
A842:  CLRF   x9D
A844:  CLRF   x9C
A846:  CLRF   x9F
A848:  CLRF   x9E
A84A:  CLRF   xA1
A84C:  CLRF   xA0
A84E:  CLRF   xA3
A850:  CLRF   xA2
A852:  CLRF   xA7
A854:  CLRF   xA6
A856:  CLRF   xA5
A858:  CLRF   xA4
A85A:  CLRF   xA8
A85C:  MOVLW  13
A85E:  MOVWF  xA9
A860:  CLRF   xAB
A862:  CLRF   xAA
A864:  MOVLW  DD
A866:  MOVWF  xAC
A868:  MOVF   FC1,W
A86A:  ANDLW  C0
A86C:  IORLW  0F
A86E:  MOVWF  FC1
A870:  MOVLW  07
A872:  MOVWF  FB4
A874:  CLRF   16
A876:  CLRF   17
....................     // <editor-fold defaultstate="collapsed" desc="Inicializao saidas e entradas"> 
....................     setup_adc(ADC_OFF); 
A878:  BCF    FC2.0
....................     setup_ccp1(CCP_OFF); 
A87A:  MOVLW  F0
A87C:  ANDWF  FBD,F
....................     setup_ccp2(CCP_OFF); 
A87E:  ANDWF  FBA,F
....................     enable_interrupts(GLOBAL); 
A880:  MOVLW  C0
A882:  IORWF  FF2,F
....................     setup_psp(PSP_DISABLED); 
A884:  BCF    F96.4
....................     output_low(step_y); 
A886:  BCF    F94.2
A888:  BCF    F8B.2
....................     output_low(dir_y); 
A88A:  BCF    F94.1
A88C:  BCF    F8B.1
....................     output_high(enable_y); 
A88E:  BCF    F94.0
A890:  BSF    F8B.0
....................     output_low(step_x); 
A892:  BCF    F95.2
A894:  BCF    F8C.2
....................     output_low(dir_x); 
A896:  BCF    F95.1
A898:  BCF    F8C.1
....................     output_high(enable_x); 
A89A:  BCF    F95.0
A89C:  BSF    F8C.0
....................     output_low(step_z); 
A89E:  BCF    F92.5
A8A0:  BCF    F89.5
....................     output_low(dir_z); 
A8A2:  BCF    F92.4
A8A4:  BCF    F89.4
....................     output_high(enable_z); 
A8A6:  BCF    F92.3
A8A8:  BSF    F89.3
....................     output_low(step_flip); 
A8AA:  BCF    F96.2
A8AC:  BCF    F8D.2
....................     output_low(dir_flip); 
A8AE:  BCF    F96.1
A8B0:  BCF    F8D.1
....................     output_high(enable_flip); 
A8B2:  BCF    F96.0
A8B4:  BSF    F8D.0
....................     setup_timer_2(T2_DIV_BY_16, 255, 16); 
A8B6:  MOVLW  78
A8B8:  IORLW  06
A8BA:  MOVWF  FCA
A8BC:  MOVLW  FF
A8BE:  MOVWF  FCB
....................     enable_interrupts(INT_TIMER2); 
A8C0:  BSF    F9D.1
....................     inicializa_display(); 
A8C2:  MOVLB  0
A8C4:  GOTO   20D6
....................     Init_Keyboard(); 
A8C8:  GOTO   218E
....................     Init_Sensores_porta1(); 
A8CC:  GOTO   21BA
....................     Init_saidas(); 
A8D0:  GOTO   21D0
....................     desaciona_todas_saidas(); 
A8D4:  GOTO   21E6
....................     init_ext_eeprom(); 
A8D8:  GOTO   2392
....................     // </editor-fold> 
....................     tela_apresentacao(); 
A8DC:  GOTO   24AA
....................     home_solenoides(); 
A8E0:  CALL   256E
....................     tela_iniciando_maquina(); 
A8E4:  GOTO   2606
....................     init_axis_x(); 
A8E8:  GOTO   2C00
....................     init_axis_y(); 
A8EC:  GOTO   30DE
....................     init_axis_z(); 
A8F0:  GOTO   35DE
....................     posicao_maquina_1_default(); 
A8F4:  CALL   4CF0
....................     tela_principal(); 
A8F8:  CALL   4EC4
....................      
....................     while(run_ok){ 
A8FC:  BTFSS  2C.0
A8FE:  BRA    A9F0
....................         if (ciclo % 10 == 0){ 
A900:  BSF    FD8.1
A902:  MOVLW  03
A904:  MOVWF  FEA
A906:  MOVLW  AD
A908:  MOVWF  FE9
A90A:  MOVFF  2B,3B4
A90E:  MOVFF  2A,3B3
A912:  MOVFF  29,3B2
A916:  MOVFF  28,3B1
A91A:  MOVLB  3
A91C:  CLRF   xB8
A91E:  CLRF   xB7
A920:  CLRF   xB6
A922:  MOVLW  0A
A924:  MOVWF  xB5
A926:  MOVLB  0
A928:  GOTO   4F28
A92C:  MOVFF  3B0,3B4
A930:  MOVFF  3AF,3B3
A934:  MOVFF  3AE,3B2
A938:  MOVFF  3AD,3B1
A93C:  MOVLB  3
A93E:  MOVF   xB1,F
A940:  BNZ   A9EC
A942:  MOVF   xB2,F
A944:  BNZ   A9EC
A946:  MOVF   xB3,F
A948:  BNZ   A9EC
A94A:  MOVF   xB4,F
A94C:  BNZ   A9EC
....................             switch(menu_atual){ 
A94E:  MOVF   1C,W
A950:  ADDLW  EE
A952:  BC    A9EC
A954:  ADDLW  12
A956:  MOVLB  0
A958:  GOTO   A9F2
....................                 case menu_principal: //menu_principal = 0 
....................                     atualiza_tela_principal(); //essa funao gera uma tela e depois espera interaoes 
A95C:  GOTO   5578
....................                 break;  
A960:  MOVLB  3
A962:  BRA    A9EC
....................                 case menu_seleciona_maquina: 
....................                     atualiza_tela_seleciona_maquina(); 
A964:  GOTO   640A
....................                 break; 
A968:  MOVLB  3
A96A:  BRA    A9EC
....................                 case menu_manutencao_outra_maquina: 
....................                     atualiza_tela_manutencao_outra_maquina(); 
A96C:  GOTO   6446
....................                 break; 
A970:  MOVLB  3
A972:  BRA    A9EC
....................  
....................                 case menu_edita_modelo: 
....................                     atualiza_tela_edita_modelo(); 
A974:  GOTO   64E6
....................                 break; 
A978:  MOVLB  3
A97A:  BRA    A9EC
....................                 case menu_seleciona_debug: 
....................                     atualiza_tela_seleciona_debug(); 
A97C:  GOTO   66CA
....................                 break;                 
A980:  MOVLB  3
A982:  BRA    A9EC
....................                 case menu_edita_pontos_no_modelo: 
....................                     atualiza_tela_edita_pontos_no_modelo(); 
A984:  GOTO   6738
....................                 break;                 
A988:  MOVLB  3
A98A:  BRA    A9EC
....................                 case menu_seleciona_pontos: 
....................                     atualiza_tela_seleciona_pontos(); 
A98C:  GOTO   6AB8
....................                 break; 
A990:  MOVLB  3
A992:  BRA    A9EC
....................                 case menu_dados_ponto: 
....................                     atualiza_tela_dados_ponto(); 
A994:  GOTO   7CA4
....................                 break; 
A998:  MOVLB  3
A99A:  BRA    A9EC
....................                 case menu_excluir_modelo: 
....................                     atualiza_tela_excluir_modelo(); 
A99C:  GOTO   84EE
....................                 break;          
A9A0:  MOVLB  3
A9A2:  BRA    A9EC
....................                  
....................  
....................                 case menu_seleciona_manutencao: 
....................                     atualiza_tela_seleciona_manutencao(); 
A9A4:  GOTO   87C2
....................                 break;                 
A9A8:  MOVLB  3
A9AA:  BRA    A9EC
....................                 case menu_debug_entrada_1: 
....................                     atualiza_tela_debug_entrada_1(); 
A9AC:  GOTO   89E0
....................                 break; 
A9B0:  MOVLB  3
A9B2:  BRA    A9EC
....................                 case menu_debug_entrada_2: 
....................                     atualiza_tela_debug_entrada_2(); 
A9B4:  GOTO   8C7E
....................                 break; 
A9B8:  MOVLB  3
A9BA:  BRA    A9EC
....................                 case menu_debug_entrada_3: 
....................                     atualiza_tela_debug_entrada_3(); 
A9BC:  GOTO   8D08
....................                 break; 
A9C0:  MOVLB  3
A9C2:  BRA    A9EC
....................                 case menu_debug_saida_1: 
....................                     atualiza_tela_debug_saida_1(); 
A9C4:  GOTO   8DE0
....................                 break; 
A9C8:  MOVLB  3
A9CA:  BRA    A9EC
....................                 case menu_debug_saida_2: 
....................                     atualiza_tela_debug_saida_2(); 
A9CC:  GOTO   8F90
....................                 break; 
A9D0:  MOVLB  3
A9D2:  BRA    A9EC
....................                 case menu_debug_saida_3: 
....................                     atualiza_tela_debug_saida_3(); 
A9D4:  GOTO   91CE
....................                 break; 
A9D8:  MOVLB  3
A9DA:  BRA    A9EC
....................                 case menu_debug_saida_4: 
....................                     atualiza_tela_debug_saida_4(); 
A9DC:  GOTO   935C
....................                 break; 
A9E0:  MOVLB  3
A9E2:  BRA    A9EC
....................  
....................  
....................                 case menu_programa_principal: 
....................                     programa_principal(); 
A9E4:  BRA    A360
....................                 break; 
A9E6:  MOVLB  3
A9E8:  BRA    A9EC
A9EA:  MOVLB  3
....................             } 
....................         } 
A9EC:  MOVLB  0
A9EE:  BRA    A8FC
....................     }    
.................... } 
A9F0:  BRA    A9F0

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E19   NOPUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0000   NOSTVREN NOLVP NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
