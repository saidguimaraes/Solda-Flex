CCS PCH C Compiler, Version 5.007, 61971               17-jan-19 14:30

               Filename:   C:\Users\ICTS-0101\Desktop\software solda\Maquina 1\SoldaFlex_Maquina 1.X\build\default\production\_ext\1472\main.lst

               ROM used:   43584 bytes (67%)
                           Largest free fragment is 21948
               RAM used:   949 (24%) at main() level
                           995 (25%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   A664
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  FF2.5
0004A:  GOTO   0054
0004E:  BTFSC  FF2.2
00050:  GOTO   14B8
00054:  BTFSS  F9D.0
00056:  GOTO   0060
0005A:  BTFSC  F9E.0
0005C:  GOTO   1A7C
00060:  BTFSS  F9D.1
00062:  GOTO   006C
00066:  BTFSC  F9E.1
00068:  GOTO   1A84
0006C:  BTFSS  FA0.1
0006E:  GOTO   0078
00072:  BTFSC  FA1.1
00074:  GOTO   2014
00078:  MOVFF  0E,00
0007C:  MOVFF  0F,01
00080:  MOVFF  10,02
00084:  MOVFF  11,03
00088:  MOVFF  0C,FE9
0008C:  MOVFF  07,FEA
00090:  BSF    07.7
00092:  MOVFF  08,FE1
00096:  MOVFF  09,FE2
0009A:  MOVFF  0A,FD9
0009E:  MOVFF  0B,FDA
000A2:  MOVFF  12,FF3
000A6:  MOVFF  13,FF4
000AA:  MOVFF  14,FFA
000AE:  MOVF   04,W
000B0:  MOVFF  06,FE0
000B4:  MOVFF  05,FD8
000B8:  RETFIE 0
.................... #include <18F4620.h> 
.................... //////// Standard Header file for the PIC18F4620 device //////////////// 
.................... #device PIC18F4620 
000BA:  DATA 65,72
000BC:  DATA 72,6F
000BE:  DATA 20,64
000C0:  DATA 65,20
000C2:  DATA 65,73
000C4:  DATA 63,72
000C6:  DATA 69,74
000C8:  DATA 61,20
000CA:  DATA 00,00
000CC:  DATA 20,20
000CE:  DATA 20,45
000D0:  DATA 45,50
000D2:  DATA 52,4F
000D4:  DATA 4D,20
000D6:  DATA 20,20
000D8:  DATA 20,20
000DA:  DATA 20,20
000DC:  DATA 00,00
000DE:  DATA 65,72
000E0:  DATA 72,6F
000E2:  DATA 20,64
000E4:  DATA 65,20
000E6:  DATA 6C,65
000E8:  DATA 69,74
000EA:  DATA 75,72
000EC:  DATA 61,20
000EE:  DATA 20,00
000F0:  DATA 20,20
000F2:  DATA 20,20
000F4:  DATA 20,45
000F6:  DATA 45,50
000F8:  DATA 52,4F
000FA:  DATA 4D,20
000FC:  DATA 20,20
000FE:  DATA 20,20
00100:  DATA 20,00
00102:  DATA 20,20
00104:  DATA 20,20
00106:  DATA 20,20
00108:  DATA 20,20
0010A:  DATA 49,43
0010C:  DATA 54,53
0010E:  DATA 20,20
00110:  DATA 20,20
00112:  DATA 20,20
00114:  DATA 20,20
00116:  DATA 0A,0D
00118:  DATA 00,00
0011A:  DATA 20,20
0011C:  DATA 49,4E
0011E:  DATA 53,54
00120:  DATA 49,54
00122:  DATA 55,54
00124:  DATA 4F,20
00126:  DATA 43,45
00128:  DATA 4E,54
0012A:  DATA 52,4F
0012C:  DATA 20,20
0012E:  DATA 0A,0D
00130:  DATA 00,00
00132:  DATA 20,20
00134:  DATA 20,20
00136:  DATA 54,45
00138:  DATA 43,4E
0013A:  DATA 4F,4C
0013C:  DATA 4F,47
0013E:  DATA 49,41
00140:  DATA 20,45
00142:  DATA 4D,20
00144:  DATA 20,20
00146:  DATA 0A,0D
00148:  DATA 00,00
0014A:  DATA 20,20
0014C:  DATA 20,20
0014E:  DATA 20,20
00150:  DATA 53,4F
00152:  DATA 46,54
00154:  DATA 57,41
00156:  DATA 52,45
00158:  DATA 20,20
0015A:  DATA 20,20
0015C:  DATA 20,20
0015E:  DATA 0A,0D
00160:  DATA 00,00
00162:  DATA 20,20
00164:  DATA 20,20
00166:  DATA 20,49
00168:  DATA 4E,49
0016A:  DATA 43,49
0016C:  DATA 41,4E
0016E:  DATA 44,4F
00170:  DATA 20,20
00172:  DATA 20,20
00174:  DATA 20,0A
00176:  DATA 0D,00
00178:  DATA 20,20
0017A:  DATA 20,20
0017C:  DATA 20,20
0017E:  DATA 4D,41
00180:  DATA 51,55
00182:  DATA 49,4E
00184:  DATA 41,20
00186:  DATA 20,20
00188:  DATA 20,20
0018A:  DATA 0A,0D
0018C:  DATA 00,00
0018E:  DATA 4D,4F
00190:  DATA 56,49
00192:  DATA 4D,45
00194:  DATA 4E,54
00196:  DATA 41,4E
00198:  DATA 44,4F
0019A:  DATA 20,4D
0019C:  DATA 41,51
0019E:  DATA 55,49
001A0:  DATA 4E,41
001A2:  DATA 0A,0D
001A4:  DATA 00,00
001A6:  DATA 20,20
001A8:  DATA 20,20
001AA:  DATA 50,41
001AC:  DATA 52,41
001AE:  DATA 20,50
001B0:  DATA 4F,53
001B2:  DATA 49,43
001B4:  DATA 41,4F
001B6:  DATA 20,20
001B8:  DATA 20,20
001BA:  DATA 0A,0D
001BC:  DATA 00,00
001BE:  DATA 20,20
001C0:  DATA 20,20
001C2:  DATA 20,41
001C4:  DATA 4C,49
001C6:  DATA 4D,45
001C8:  DATA 4E,54
001CA:  DATA 41,44
001CC:  DATA 4F,52
001CE:  DATA 20,20
001D0:  DATA 20,20
001D2:  DATA 0A,0D
001D4:  DATA 00,00
001D6:  DATA 4D,4F
001D8:  DATA 56,49
001DA:  DATA 4D,45
001DC:  DATA 4E,54
001DE:  DATA 41,4E
001E0:  DATA 44,4F
001E2:  DATA 20,4D
001E4:  DATA 41,51
001E6:  DATA 55,49
001E8:  DATA 4E,41
001EA:  DATA 0A,0D
001EC:  DATA 00,00
001EE:  DATA 20,20
001F0:  DATA 20,20
001F2:  DATA 50,41
001F4:  DATA 52,41
001F6:  DATA 20,50
001F8:  DATA 4F,53
001FA:  DATA 49,43
001FC:  DATA 41,4F
001FE:  DATA 20,20
00200:  DATA 20,20
00202:  DATA 0A,0D
00204:  DATA 00,00
00206:  DATA 20,20
00208:  DATA 20,20
0020A:  DATA 20,20
0020C:  DATA 20,48
0020E:  DATA 4F,4D
00210:  DATA 45,20
00212:  DATA 31,20
00214:  DATA 20,20
00216:  DATA 20,20
00218:  DATA 20,20
0021A:  DATA 0A,0D
0021C:  DATA 00,00
0021E:  DATA 4D,4F
00220:  DATA 56,49
00222:  DATA 4D,45
00224:  DATA 4E,54
00226:  DATA 41,4E
00228:  DATA 44,4F
0022A:  DATA 20,4D
0022C:  DATA 41,51
0022E:  DATA 55,49
00230:  DATA 4E,41
00232:  DATA 0A,0D
00234:  DATA 00,00
00236:  DATA 20,20
00238:  DATA 20,20
0023A:  DATA 50,41
0023C:  DATA 52,41
0023E:  DATA 20,50
00240:  DATA 4F,53
00242:  DATA 49,43
00244:  DATA 41,4F
00246:  DATA 20,20
00248:  DATA 20,20
0024A:  DATA 0A,0D
0024C:  DATA 00,00
0024E:  DATA 20,20
00250:  DATA 20,20
00252:  DATA 20,20
00254:  DATA 53,4F
00256:  DATA 4C,44
00258:  DATA 41,47
0025A:  DATA 45,4D
0025C:  DATA 20,20
0025E:  DATA 20,20
00260:  DATA 20,0A
00262:  DATA 0D,00
00264:  DATA 4D,4F
00266:  DATA 56,49
00268:  DATA 4D,45
0026A:  DATA 4E,54
0026C:  DATA 41,4E
0026E:  DATA 44,4F
00270:  DATA 20,4D
00272:  DATA 41,51
00274:  DATA 55,49
00276:  DATA 4E,41
00278:  DATA 0A,0D
0027A:  DATA 00,00
0027C:  DATA 20,20
0027E:  DATA 20,20
00280:  DATA 50,41
00282:  DATA 52,41
00284:  DATA 20,50
00286:  DATA 4F,53
00288:  DATA 49,43
0028A:  DATA 41,4F
0028C:  DATA 20,20
0028E:  DATA 20,20
00290:  DATA 0A,0D
00292:  DATA 00,00
00294:  DATA 20,20
00296:  DATA 20,20
00298:  DATA 20,20
0029A:  DATA 20,48
0029C:  DATA 4F,4D
0029E:  DATA 45,20
002A0:  DATA 32,20
002A2:  DATA 20,20
002A4:  DATA 20,20
002A6:  DATA 20,20
002A8:  DATA 0A,0D
002AA:  DATA 00,00
002AC:  DATA 4D,4F
002AE:  DATA 56,49
002B0:  DATA 4D,45
002B2:  DATA 4E,54
002B4:  DATA 41,4E
002B6:  DATA 44,4F
002B8:  DATA 20,4D
002BA:  DATA 41,51
002BC:  DATA 55,49
002BE:  DATA 4E,41
002C0:  DATA 0A,0D
002C2:  DATA 00,00
002C4:  DATA 20,20
002C6:  DATA 20,20
002C8:  DATA 50,41
002CA:  DATA 52,41
002CC:  DATA 20,50
002CE:  DATA 4F,53
002D0:  DATA 49,43
002D2:  DATA 41,4F
002D4:  DATA 20,20
002D6:  DATA 20,20
002D8:  DATA 0A,0D
002DA:  DATA 00,00
002DC:  DATA 20,20
002DE:  DATA 20,20
002E0:  DATA 44,49
002E2:  DATA 53,50
002E4:  DATA 45,4E
002E6:  DATA 53,41
002E8:  DATA 44,4F
002EA:  DATA 52,20
002EC:  DATA 20,20
002EE:  DATA 20,20
002F0:  DATA 0A,0D
002F2:  DATA 00,00
002F4:  DATA 4D,4F
002F6:  DATA 56,49
002F8:  DATA 4D,45
002FA:  DATA 4E,54
002FC:  DATA 41,4E
002FE:  DATA 44,4F
00300:  DATA 20,4D
00302:  DATA 41,51
00304:  DATA 55,49
00306:  DATA 4E,41
00308:  DATA 0A,0D
0030A:  DATA 00,00
0030C:  DATA 20,20
0030E:  DATA 20,20
00310:  DATA 50,41
00312:  DATA 52,41
00314:  DATA 20,50
00316:  DATA 4F,53
00318:  DATA 49,43
0031A:  DATA 41,4F
0031C:  DATA 20,20
0031E:  DATA 20,20
00320:  DATA 0A,0D
00322:  DATA 00,00
00324:  DATA 20,20
00326:  DATA 20,20
00328:  DATA 20,20
0032A:  DATA 20,4C
0032C:  DATA 49,4D
0032E:  DATA 50,45
00330:  DATA 5A,41
00332:  DATA 20,20
00334:  DATA 20,20
00336:  DATA 20,20
00338:  DATA 0A,0D
0033A:  DATA 00,00
0033C:  DATA 4D,4F
0033E:  DATA 56,49
00340:  DATA 4D,45
00342:  DATA 4E,54
00344:  DATA 41,4E
00346:  DATA 44,4F
00348:  DATA 20,4D
0034A:  DATA 41,51
0034C:  DATA 55,49
0034E:  DATA 4E,41
00350:  DATA 0A,0D
00352:  DATA 00,00
00354:  DATA 20,20
00356:  DATA 20,20
00358:  DATA 50,41
0035A:  DATA 52,41
0035C:  DATA 20,50
0035E:  DATA 4F,53
00360:  DATA 49,43
00362:  DATA 41,4F
00364:  DATA 20,20
00366:  DATA 20,20
00368:  DATA 0A,0D
0036A:  DATA 00,00
0036C:  DATA 20,20
0036E:  DATA 20,20
00370:  DATA 20,4C
00372:  DATA 49,4D
00374:  DATA 50,45
00376:  DATA 5A,41
00378:  DATA 5F,32
0037A:  DATA 20,20
0037C:  DATA 20,20
0037E:  DATA 20,20
00380:  DATA 0A,0D
00382:  DATA 00,00
00384:  DATA 20,20
00386:  DATA 45,53
00388:  DATA 50,45
0038A:  DATA 52,41
0038C:  DATA 4E,44
0038E:  DATA 4F,20
00390:  DATA 4D,41
00392:  DATA 51,55
00394:  DATA 49,4E
00396:  DATA 41,20
00398:  DATA 0A,0D
0039A:  DATA 00,00
0039C:  DATA 20,20
0039E:  DATA 20,49
003A0:  DATA 52,20
003A2:  DATA 50,41
003A4:  DATA 52,41
003A6:  DATA 20,50
003A8:  DATA 4F,53
003AA:  DATA 49,43
003AC:  DATA 41,4F
003AE:  DATA 20,20
003B0:  DATA 0A,0D
003B2:  DATA 00,00
003B4:  DATA 20,20
003B6:  DATA 20,20
003B8:  DATA 50,52
003BA:  DATA 45,2D
003BC:  DATA 52,45
003BE:  DATA 51,55
003C0:  DATA 49,53
003C2:  DATA 49,54
003C4:  DATA 4F,20
003C6:  DATA 20,20
003C8:  DATA 0A,0D
003CA:  DATA 00,00
003CC:  DATA 20,20
003CE:  DATA 20,45
003D0:  DATA 53,50
003D2:  DATA 45,52
003D4:  DATA 41,4E
003D6:  DATA 44,4F
003D8:  DATA 20,4F
003DA:  DATA 55,54
003DC:  DATA 52,41
003DE:  DATA 20,20
003E0:  DATA 0A,0D
003E2:  DATA 00,00
003E4:  DATA 20,20
003E6:  DATA 20,20
003E8:  DATA 20,20
003EA:  DATA 20,4D
003EC:  DATA 41,51
003EE:  DATA 55,49
003F0:  DATA 4E,41
003F2:  DATA 20,20
003F4:  DATA 20,20
003F6:  DATA 20,20
003F8:  DATA 0A,0D
003FA:  DATA 00,00
003FC:  DATA 20,20
003FE:  DATA 20,49
00400:  DATA 52,20
00402:  DATA 50,41
00404:  DATA 52,41
00406:  DATA 20,50
00408:  DATA 4F,53
0040A:  DATA 49,43
0040C:  DATA 41,4F
0040E:  DATA 20,20
00410:  DATA 0A,0D
00412:  DATA 00,00
00414:  DATA 20,20
00416:  DATA 20,20
00418:  DATA 20,41
0041A:  DATA 4C,49
0041C:  DATA 4D,45
0041E:  DATA 4E,54
00420:  DATA 41,44
00422:  DATA 4F,52
00424:  DATA 20,20
00426:  DATA 20,20
00428:  DATA 0A,0D
0042A:  DATA 00,00
0042C:  DATA 20,20
0042E:  DATA 20,45
00430:  DATA 53,50
00432:  DATA 45,52
00434:  DATA 41,4E
00436:  DATA 44,4F
00438:  DATA 20,4F
0043A:  DATA 55,54
0043C:  DATA 52,41
0043E:  DATA 20,20
00440:  DATA 0A,0D
00442:  DATA 00,00
00444:  DATA 20,20
00446:  DATA 20,20
00448:  DATA 20,20
0044A:  DATA 20,4D
0044C:  DATA 41,51
0044E:  DATA 55,49
00450:  DATA 4E,41
00452:  DATA 20,20
00454:  DATA 20,20
00456:  DATA 20,20
00458:  DATA 0A,0D
0045A:  DATA 00,00
0045C:  DATA 20,20
0045E:  DATA 20,49
00460:  DATA 52,20
00462:  DATA 50,41
00464:  DATA 52,41
00466:  DATA 20,50
00468:  DATA 4F,53
0046A:  DATA 49,43
0046C:  DATA 41,4F
0046E:  DATA 20,20
00470:  DATA 0A,0D
00472:  DATA 00,00
00474:  DATA 20,20
00476:  DATA 20,20
00478:  DATA 20,20
0047A:  DATA 20,48
0047C:  DATA 4F,4D
0047E:  DATA 45,20
00480:  DATA 31,20
00482:  DATA 20,20
00484:  DATA 20,20
00486:  DATA 20,20
00488:  DATA 0A,0D
0048A:  DATA 00,00
0048C:  DATA 20,20
0048E:  DATA 20,45
00490:  DATA 53,50
00492:  DATA 45,52
00494:  DATA 41,4E
00496:  DATA 44,4F
00498:  DATA 20,4F
0049A:  DATA 55,54
0049C:  DATA 52,41
0049E:  DATA 20,20
004A0:  DATA 0A,0D
004A2:  DATA 00,00
004A4:  DATA 20,20
004A6:  DATA 20,20
004A8:  DATA 20,20
004AA:  DATA 20,4D
004AC:  DATA 41,51
004AE:  DATA 55,49
004B0:  DATA 4E,41
004B2:  DATA 20,20
004B4:  DATA 20,20
004B6:  DATA 20,20
004B8:  DATA 0A,0D
004BA:  DATA 00,00
004BC:  DATA 20,20
004BE:  DATA 20,49
004C0:  DATA 52,20
004C2:  DATA 50,41
004C4:  DATA 52,41
004C6:  DATA 20,50
004C8:  DATA 4F,53
004CA:  DATA 49,43
004CC:  DATA 41,4F
004CE:  DATA 20,20
004D0:  DATA 0A,0D
004D2:  DATA 00,00
004D4:  DATA 20,20
004D6:  DATA 20,20
004D8:  DATA 20,53
004DA:  DATA 4F,4C
004DC:  DATA 44,41
004DE:  DATA 47,45
004E0:  DATA 4D,20
004E2:  DATA 31,20
004E4:  DATA 20,20
004E6:  DATA 20,20
004E8:  DATA 0A,0D
004EA:  DATA 00,00
004EC:  DATA 20,20
004EE:  DATA 20,45
004F0:  DATA 53,50
004F2:  DATA 45,52
004F4:  DATA 41,4E
004F6:  DATA 44,4F
004F8:  DATA 20,4F
004FA:  DATA 55,54
004FC:  DATA 52,41
004FE:  DATA 20,20
00500:  DATA 0A,0D
00502:  DATA 00,00
00504:  DATA 20,20
00506:  DATA 20,20
00508:  DATA 20,20
0050A:  DATA 20,4D
0050C:  DATA 41,51
0050E:  DATA 55,49
00510:  DATA 4E,41
00512:  DATA 20,20
00514:  DATA 20,20
00516:  DATA 20,20
00518:  DATA 0A,0D
0051A:  DATA 00,00
0051C:  DATA 20,20
0051E:  DATA 20,49
00520:  DATA 52,20
00522:  DATA 50,41
00524:  DATA 52,41
00526:  DATA 20,50
00528:  DATA 4F,53
0052A:  DATA 49,43
0052C:  DATA 41,4F
0052E:  DATA 20,20
00530:  DATA 0A,0D
00532:  DATA 00,00
00534:  DATA 20,20
00536:  DATA 20,20
00538:  DATA 20,20
0053A:  DATA 20,48
0053C:  DATA 4F,4D
0053E:  DATA 45,20
00540:  DATA 32,20
00542:  DATA 20,20
00544:  DATA 20,20
00546:  DATA 20,20
00548:  DATA 0A,0D
0054A:  DATA 00,00
0054C:  DATA 20,20
0054E:  DATA 20,45
00550:  DATA 53,50
00552:  DATA 45,52
00554:  DATA 41,4E
00556:  DATA 44,4F
00558:  DATA 20,4F
0055A:  DATA 55,54
0055C:  DATA 52,41
0055E:  DATA 20,20
00560:  DATA 0A,0D
00562:  DATA 00,00
00564:  DATA 20,20
00566:  DATA 20,20
00568:  DATA 20,20
0056A:  DATA 20,4D
0056C:  DATA 41,51
0056E:  DATA 55,49
00570:  DATA 4E,41
00572:  DATA 20,20
00574:  DATA 20,20
00576:  DATA 20,20
00578:  DATA 0A,0D
0057A:  DATA 00,00
0057C:  DATA 20,20
0057E:  DATA 20,49
00580:  DATA 52,20
00582:  DATA 50,41
00584:  DATA 52,41
00586:  DATA 20,50
00588:  DATA 4F,53
0058A:  DATA 49,43
0058C:  DATA 41,4F
0058E:  DATA 20,20
00590:  DATA 0A,0D
00592:  DATA 00,00
00594:  DATA 20,20
00596:  DATA 20,20
00598:  DATA 20,44
0059A:  DATA 49,53
0059C:  DATA 50,45
0059E:  DATA 4E,53
005A0:  DATA 41,44
005A2:  DATA 4F,52
005A4:  DATA 20,20
005A6:  DATA 20,20
005A8:  DATA 0A,0D
005AA:  DATA 00,00
005AC:  DATA 20,20
005AE:  DATA 20,45
005B0:  DATA 53,50
005B2:  DATA 45,52
005B4:  DATA 41,4E
005B6:  DATA 44,4F
005B8:  DATA 20,4F
005BA:  DATA 55,54
005BC:  DATA 52,41
005BE:  DATA 20,20
005C0:  DATA 0A,0D
005C2:  DATA 00,00
005C4:  DATA 20,20
005C6:  DATA 20,20
005C8:  DATA 20,20
005CA:  DATA 20,4D
005CC:  DATA 41,51
005CE:  DATA 55,49
005D0:  DATA 4E,41
005D2:  DATA 20,20
005D4:  DATA 20,20
005D6:  DATA 20,20
005D8:  DATA 0A,0D
005DA:  DATA 00,00
005DC:  DATA 20,20
005DE:  DATA 20,49
005E0:  DATA 52,20
005E2:  DATA 50,41
005E4:  DATA 52,41
005E6:  DATA 20,50
005E8:  DATA 4F,53
005EA:  DATA 49,43
005EC:  DATA 41,4F
005EE:  DATA 20,20
005F0:  DATA 0A,0D
005F2:  DATA 00,00
005F4:  DATA 20,20
005F6:  DATA 20,20
005F8:  DATA 20,20
005FA:  DATA 20,4C
005FC:  DATA 49,4D
005FE:  DATA 50,45
00600:  DATA 5A,41
00602:  DATA 20,20
00604:  DATA 20,20
00606:  DATA 20,20
00608:  DATA 0A,0D
0060A:  DATA 00,00
0060C:  DATA 20,20
0060E:  DATA 20,45
00610:  DATA 53,50
00612:  DATA 45,52
00614:  DATA 41,4E
00616:  DATA 44,4F
00618:  DATA 20,4F
0061A:  DATA 55,54
0061C:  DATA 52,41
0061E:  DATA 20,20
00620:  DATA 0A,0D
00622:  DATA 00,00
00624:  DATA 20,20
00626:  DATA 20,20
00628:  DATA 20,20
0062A:  DATA 20,4D
0062C:  DATA 41,51
0062E:  DATA 55,49
00630:  DATA 4E,41
00632:  DATA 20,20
00634:  DATA 20,20
00636:  DATA 20,20
00638:  DATA 0A,0D
0063A:  DATA 00,00
0063C:  DATA 20,20
0063E:  DATA 20,49
00640:  DATA 52,20
00642:  DATA 50,41
00644:  DATA 52,41
00646:  DATA 20,50
00648:  DATA 4F,53
0064A:  DATA 49,43
0064C:  DATA 41,4F
0064E:  DATA 20,20
00650:  DATA 0A,0D
00652:  DATA 00,00
00654:  DATA 20,20
00656:  DATA 20,20
00658:  DATA 20,20
0065A:  DATA 4C,49
0065C:  DATA 4D,50
0065E:  DATA 45,5A
00660:  DATA 41,5F
00662:  DATA 32,20
00664:  DATA 20,20
00666:  DATA 20,20
00668:  DATA 0A,0D
0066A:  DATA 00,00
0066C:  DATA 20,20
0066E:  DATA 20,45
00670:  DATA 53,50
00672:  DATA 45,52
00674:  DATA 41,4E
00676:  DATA 44,4F
00678:  DATA 20,4F
0067A:  DATA 55,54
0067C:  DATA 52,41
0067E:  DATA 20,20
00680:  DATA 0A,0D
00682:  DATA 00,00
00684:  DATA 20,20
00686:  DATA 20,20
00688:  DATA 20,20
0068A:  DATA 20,4D
0068C:  DATA 41,51
0068E:  DATA 55,49
00690:  DATA 4E,41
00692:  DATA 20,20
00694:  DATA 20,20
00696:  DATA 20,20
00698:  DATA 0A,0D
0069A:  DATA 00,00
0069C:  DATA 20,20
0069E:  DATA 20,53
006A0:  DATA 41,49
006A2:  DATA 52,20
006A4:  DATA 44,41
006A6:  DATA 20,50
006A8:  DATA 4F,53
006AA:  DATA 49,43
006AC:  DATA 41,4F
006AE:  DATA 20,20
006B0:  DATA 0A,0D
006B2:  DATA 00,00
006B4:  DATA 20,20
006B6:  DATA 20,20
006B8:  DATA 20,20
006BA:  DATA 20,20
006BC:  DATA 41,54
006BE:  DATA 55,41
006C0:  DATA 4C,20
006C2:  DATA 20,20
006C4:  DATA 20,20
006C6:  DATA 20,20
006C8:  DATA 0A,0D
006CA:  DATA 00,00
006CC:  DATA 20,53
006CE:  DATA 4F,4C
006D0:  DATA 44,41
006D2:  DATA 44,4F
006D4:  DATA 52,20
006D6:  DATA 41,55
006D8:  DATA 54,4F
006DA:  DATA 4D,41
006DC:  DATA 54,49
006DE:  DATA 43,4F
006E0:  DATA 0A,0D
006E2:  DATA 00,00
006E4:  DATA 20,20
006E6:  DATA 20,20
006E8:  DATA 20,20
006EA:  DATA 4D,4F
006EC:  DATA 44,45
006EE:  DATA 4C,4F
006F0:  DATA 3A,25
006F2:  DATA 30,32
006F4:  DATA 75,20
006F6:  DATA 20,20
006F8:  DATA 0A,0D
006FA:  DATA 00,00
006FC:  DATA 5E,2F
006FE:  DATA 3F,3A
00700:  DATA 4D,4F
00702:  DATA 44,45
00704:  DATA 4C,4F
00706:  DATA 7C,4D
00708:  DATA 45,4E
0070A:  DATA 55,3A
0070C:  DATA 44,42
0070E:  DATA 55,47
00710:  DATA 0A,0D
00712:  DATA 00,00
00714:  DATA 20,20
00716:  DATA 20,20
00718:  DATA 20,45
0071A:  DATA 4E,54
0071C:  DATA 45,52
0071E:  DATA 3A,4D
00720:  DATA 41,49
00722:  DATA 4E,20
00724:  DATA 20,20
00726:  DATA 20,20
00728:  DATA 0A,0D
0072A:  DATA 00,00
0072C:  DATA 20,53
0072E:  DATA 45,4C
00730:  DATA 45,43
00732:  DATA 49,4F
00734:  DATA 4E,45
00736:  DATA 20,41
00738:  DATA 20,4D
0073A:  DATA 41,51
0073C:  DATA 55,49
0073E:  DATA 4E,41
00740:  DATA 0A,0D
00742:  DATA 00,00
00744:  DATA 20,20
00746:  DATA 20,20
00748:  DATA 46,31
0074A:  DATA 3A,20
0074C:  DATA 4D,41
0074E:  DATA 51,55
00750:  DATA 49,4E
00752:  DATA 41,20
00754:  DATA 31,20
00756:  DATA 20,20
00758:  DATA 0A,0D
0075A:  DATA 00,00
0075C:  DATA 20,20
0075E:  DATA 20,20
00760:  DATA 46,32
00762:  DATA 3A,20
00764:  DATA 4D,41
00766:  DATA 51,55
00768:  DATA 49,4E
0076A:  DATA 41,20
0076C:  DATA 32,20
0076E:  DATA 20,20
00770:  DATA 0A,0D
00772:  DATA 00,00
00774:  DATA 20,20
00776:  DATA 20,20
00778:  DATA 45,53
0077A:  DATA 43,3A
0077C:  DATA 42,41
0077E:  DATA 43,4B
00780:  DATA 20,20
00782:  DATA 20,20
00784:  DATA 20,20
00786:  DATA 20,20
00788:  DATA 0A,0D
0078A:  DATA 00,00
0078C:  DATA 20,20
0078E:  DATA 20,20
00790:  DATA 20,4D
00792:  DATA 41,4E
00794:  DATA 55,54
00796:  DATA 45,4E
00798:  DATA 43,41
0079A:  DATA 4F,20
0079C:  DATA 20,20
0079E:  DATA 20,20
007A0:  DATA 0A,0D
007A2:  DATA 00,00
007A4:  DATA 20,20
007A6:  DATA 20,20
007A8:  DATA 20,20
007AA:  DATA 4D,41
007AC:  DATA 51,55
007AE:  DATA 49,4E
007B0:  DATA 41,20
007B2:  DATA 32,20
007B4:  DATA 20,20
007B6:  DATA 20,20
007B8:  DATA 0A,0D
007BA:  DATA 00,00
007BC:  DATA 20,20
007BE:  DATA 20,20
007C0:  DATA 20,20
007C2:  DATA 20,20
007C4:  DATA 20,20
007C6:  DATA 20,20
007C8:  DATA 20,20
007CA:  DATA 20,20
007CC:  DATA 20,20
007CE:  DATA 20,20
007D0:  DATA 0A,0D
007D2:  DATA 00,00
007D4:  DATA 20,20
007D6:  DATA 20,20
007D8:  DATA 20,20
007DA:  DATA 45,53
007DC:  DATA 43,3A
007DE:  DATA 42,41
007E0:  DATA 43,4B
007E2:  DATA 20,20
007E4:  DATA 20,20
007E6:  DATA 20,20
007E8:  DATA 0A,0D
007EA:  DATA 00,00
007EC:  DATA 20,20
007EE:  DATA 20,20
007F0:  DATA 45,53
007F2:  DATA 43,4F
007F4:  DATA 4C,48
007F6:  DATA 45,52
007F8:  DATA 20,41
007FA:  DATA 43,41
007FC:  DATA 4F,20
007FE:  DATA 20,20
00800:  DATA 0A,0D
00802:  DATA 00,00
00804:  DATA 20,20
00806:  DATA 46,31
00808:  DATA 3A,20
0080A:  DATA 45,44
0080C:  DATA 49,54
0080E:  DATA 41,52
00810:  DATA 20,4D
00812:  DATA 4F,44
00814:  DATA 45,4C
00816:  DATA 4F,20
00818:  DATA 0A,0D
0081A:  DATA 00,00
0081C:  DATA 20,20
0081E:  DATA 46,32
00820:  DATA 3A,20
00822:  DATA 45,58
00824:  DATA 43,4C
00826:  DATA 55,49
00828:  DATA 20,4D
0082A:  DATA 4F,44
0082C:  DATA 45,4C
0082E:  DATA 4F,20
00830:  DATA 0A,0D
00832:  DATA 00,00
00834:  DATA 20,20
00836:  DATA 45,53
00838:  DATA 43,3A
0083A:  DATA 42,41
0083C:  DATA 43,4B
0083E:  DATA 20,20
00840:  DATA 20,20
00842:  DATA 20,20
00844:  DATA 20,20
00846:  DATA 20,20
00848:  DATA 0A,0D
0084A:  DATA 00,00
0084C:  DATA 20,20
0084E:  DATA 46,31
00850:  DATA 3A,20
00852:  DATA 45,44
00854:  DATA 49,54
00856:  DATA 41,52
00858:  DATA 20,50
0085A:  DATA 4F,4E
0085C:  DATA 54,4F
0085E:  DATA 53,20
00860:  DATA 0A,0D
00862:  DATA 00,00
00864:  DATA 20,20
00866:  DATA 46,32
00868:  DATA 3A,20
0086A:  DATA 4D,41
0086C:  DATA 4E,55
0086E:  DATA 54,45
00870:  DATA 4E,43
00872:  DATA 41,4F
00874:  DATA 20,20
00876:  DATA 20,20
00878:  DATA 0A,0D
0087A:  DATA 00,00
0087C:  DATA 20,20
0087E:  DATA 46,33
00880:  DATA 3A,20
00882:  DATA 51,4E
00884:  DATA 54,5F
00886:  DATA 50,4F
00888:  DATA 4E,54
0088A:  DATA 4F,53
0088C:  DATA 20,20
0088E:  DATA 20,20
00890:  DATA 0A,0D
00892:  DATA 00,00
00894:  DATA 20,20
00896:  DATA 45,53
00898:  DATA 43,3A
0089A:  DATA 42,41
0089C:  DATA 43,4B
0089E:  DATA 20,20
008A0:  DATA 20,20
008A2:  DATA 20,20
008A4:  DATA 20,20
008A6:  DATA 20,20
008A8:  DATA 0A,0D
008AA:  DATA 00,00
008AC:  DATA 20,20
008AE:  DATA 50,4F
008B0:  DATA 4E,54
008B2:  DATA 4F,53
008B4:  DATA 20,4E
008B6:  DATA 4F,20
008B8:  DATA 4D,4F
008BA:  DATA 44,45
008BC:  DATA 4C,4F
008BE:  DATA 20,20
008C0:  DATA 0A,0D
008C2:  DATA 00,00
008C4:  DATA 20,20
008C6:  DATA 20,20
008C8:  DATA 20,20
008CA:  DATA 20,20
008CC:  DATA 20,25
008CE:  DATA 30,32
008D0:  DATA 75,20
008D2:  DATA 20,20
008D4:  DATA 20,20
008D6:  DATA 20,20
008D8:  DATA 0A,0D
008DA:  DATA 00,00
008DC:  DATA 20,20
008DE:  DATA 20,20
008E0:  DATA 3F,2F
008E2:  DATA 3F,3A
008E4:  DATA 4E,5F
008E6:  DATA 50,4F
008E8:  DATA 4E,54
008EA:  DATA 4F,53
008EC:  DATA 20,20
008EE:  DATA 20,0A
008F0:  DATA 0D,00
008F2:  DATA 20,45
008F4:  DATA 4E,54
008F6:  DATA 45,52
008F8:  DATA 3A,53
008FA:  DATA 41,56
008FC:  DATA 45,7C
008FE:  DATA 45,53
00900:  DATA 43,3A
00902:  DATA 42,41
00904:  DATA 43,4B
00906:  DATA 0A,0D
00908:  DATA 00,00
0090A:  DATA 20,20
0090C:  DATA 20,44
0090E:  DATA 45,53
00910:  DATA 45,4A
00912:  DATA 41,20
00914:  DATA 45,58
00916:  DATA 43,4C
00918:  DATA 55,49
0091A:  DATA 52,20
0091C:  DATA 20,20
0091E:  DATA 0A,0D
00920:  DATA 00,00
00922:  DATA 20,20
00924:  DATA 20,20
00926:  DATA 20,4F
00928:  DATA 20,4D
0092A:  DATA 4F,44
0092C:  DATA 45,4C
0092E:  DATA 4F,20
00930:  DATA 3F,20
00932:  DATA 20,20
00934:  DATA 20,20
00936:  DATA 0A,0D
00938:  DATA 00,00
0093A:  DATA 20,20
0093C:  DATA 20,20
0093E:  DATA 20,20
00940:  DATA 45,4E
00942:  DATA 54,45
00944:  DATA 52,3D
00946:  DATA 4F,4B
00948:  DATA 20,20
0094A:  DATA 20,20
0094C:  DATA 20,20
0094E:  DATA 0A,0D
00950:  DATA 00,00
00952:  DATA 20,20
00954:  DATA 20,20
00956:  DATA 45,53
00958:  DATA 43,3A
0095A:  DATA 4E,4F
0095C:  DATA 2F,42
0095E:  DATA 41,43
00960:  DATA 4B,20
00962:  DATA 20,20
00964:  DATA 20,20
00966:  DATA 0A,0D
00968:  DATA 00,00
0096A:  DATA 50,25
0096C:  DATA 30,32
0096E:  DATA 75,20
00970:  DATA 20,20
00972:  DATA 20,20
00974:  DATA 20,20
00976:  DATA 20,20
00978:  DATA 45,4E
0097A:  DATA 54,3D
0097C:  DATA 45,44
0097E:  DATA 49,54
00980:  DATA 0A,0D
00982:  DATA 00,00
00984:  DATA 50,25
00986:  DATA 30,32
00988:  DATA 75,20
0098A:  DATA 20,20
0098C:  DATA 20,20
0098E:  DATA 20,20
00990:  DATA 20,20
00992:  DATA 45,53
00994:  DATA 43,3D
00996:  DATA 42,41
00998:  DATA 43,4B
0099A:  DATA 0A,0D
0099C:  DATA 00,00
0099E:  DATA 50,25
009A0:  DATA 30,32
009A2:  DATA 75,20
009A4:  DATA 20,20
009A6:  DATA 20,20
009A8:  DATA 20,20
009AA:  DATA 20,20
009AC:  DATA 20,20
009AE:  DATA 20,20
009B0:  DATA 20,20
009B2:  DATA 20,20
009B4:  DATA 0A,0D
009B6:  DATA 00,00
009B8:  DATA 50,25
009BA:  DATA 30,32
009BC:  DATA 75,20
009BE:  DATA 20,20
009C0:  DATA 20,20
009C2:  DATA 20,20
009C4:  DATA 20,20
009C6:  DATA 20,20
009C8:  DATA 20,20
009CA:  DATA 20,20
009CC:  DATA 20,20
009CE:  DATA 0A,0D
009D0:  DATA 00,00
009D2:  DATA 58,3A
009D4:  DATA 25,30
009D6:  DATA 34,4C
009D8:  DATA 75,20
009DA:  DATA 59,3A
009DC:  DATA 25,30
009DE:  DATA 34,4C
009E0:  DATA 75,20
009E2:  DATA 5A,3A
009E4:  DATA 25,30
009E6:  DATA 34,4C
009E8:  DATA 75,0A
009EA:  DATA 0D,00
009EC:  DATA 20,20
009EE:  DATA 54,5F
009F0:  DATA 53,3A
009F2:  DATA 25,30
009F4:  DATA 34,4C
009F6:  DATA 75,20
009F8:  DATA 54,5F
009FA:  DATA 45,3A
009FC:  DATA 25,30
009FE:  DATA 34,4C
00A00:  DATA 75,20
00A02:  DATA 0A,0D
00A04:  DATA 00,00
00A06:  DATA 20,20
00A08:  DATA 20,54
00A0A:  DATA 49,50
00A0C:  DATA 4F,3A
00A0E:  DATA 25,30
00A10:  DATA 32,75
00A12:  DATA 20,48
00A14:  DATA 41,42
00A16:  DATA 3A,25
00A18:  DATA 30,32
00A1A:  DATA 75,20
00A1C:  DATA 20,20
00A1E:  DATA 0A,0D
00A20:  DATA 00,00
00A22:  DATA 46,31
00A24:  DATA 3A,47
00A26:  DATA 52,41
00A28:  DATA 56,41
00A2A:  DATA 7C,45
00A2C:  DATA 4E,54
00A2E:  DATA 45,52
00A30:  DATA 3A,54
00A32:  DATA 45,53
00A34:  DATA 54,45
00A36:  DATA 0A,0D
00A38:  DATA 00,00
00A3A:  DATA 20,46
00A3C:  DATA 31,3A
00A3E:  DATA 20,44
00A40:  DATA 45,42
00A42:  DATA 55,47
00A44:  DATA 20,45
00A46:  DATA 4E,54
00A48:  DATA 52,41
00A4A:  DATA 44,41
00A4C:  DATA 53,20
00A4E:  DATA 0A,0D
00A50:  DATA 00,00
00A52:  DATA 20,46
00A54:  DATA 32,3A
00A56:  DATA 20,20
00A58:  DATA 44,45
00A5A:  DATA 42,55
00A5C:  DATA 47,20
00A5E:  DATA 53,41
00A60:  DATA 49,44
00A62:  DATA 41,53
00A64:  DATA 20,20
00A66:  DATA 0A,0D
00A68:  DATA 00,00
00A6A:  DATA 20,20
00A6C:  DATA 20,20
00A6E:  DATA 20,20
00A70:  DATA 20,20
00A72:  DATA 20,20
00A74:  DATA 20,20
00A76:  DATA 20,20
00A78:  DATA 20,20
00A7A:  DATA 20,20
00A7C:  DATA 20,20
00A7E:  DATA 0A,0D
00A80:  DATA 00,00
00A82:  DATA 20,20
00A84:  DATA 20,20
00A86:  DATA 20,20
00A88:  DATA 45,53
00A8A:  DATA 43,3A
00A8C:  DATA 42,41
00A8E:  DATA 43,4B
00A90:  DATA 20,20
00A92:  DATA 20,20
00A94:  DATA 20,20
00A96:  DATA 0A,0D
00A98:  DATA 00,00
00A9A:  DATA 45,30
00A9C:  DATA 30,3A
00A9E:  DATA 25,30
00AA0:  DATA 32,75
00AA2:  DATA 20,45
00AA4:  DATA 30,31
00AA6:  DATA 3A,25
00AA8:  DATA 30,32
00AAA:  DATA 75,20
00AAC:  DATA 45,30
00AAE:  DATA 32,3A
00AB0:  DATA 25,30
00AB2:  DATA 32,75
00AB4:  DATA 0A,0D
00AB6:  DATA 00,00
00AB8:  DATA 45,30
00ABA:  DATA 33,3A
00ABC:  DATA 25,30
00ABE:  DATA 32,75
00AC0:  DATA 20,45
00AC2:  DATA 30,34
00AC4:  DATA 3A,25
00AC6:  DATA 30,32
00AC8:  DATA 75,20
00ACA:  DATA 45,30
00ACC:  DATA 35,3A
00ACE:  DATA 25,30
00AD0:  DATA 32,75
00AD2:  DATA 0A,0D
00AD4:  DATA 00,00
00AD6:  DATA 45,30
00AD8:  DATA 36,3A
00ADA:  DATA 25,30
00ADC:  DATA 32,75
00ADE:  DATA 20,45
00AE0:  DATA 30,37
00AE2:  DATA 3A,25
00AE4:  DATA 30,32
00AE6:  DATA 75,20
00AE8:  DATA 45,30
00AEA:  DATA 38,3A
00AEC:  DATA 25,30
00AEE:  DATA 32,75
00AF0:  DATA 0A,0D
00AF2:  DATA 00,00
00AF4:  DATA 20,20
00AF6:  DATA 20,3E
00AF8:  DATA 3A,50
00AFA:  DATA 52,4F
00AFC:  DATA 58,7C
00AFE:  DATA 45,53
00B00:  DATA 43,3A
00B02:  DATA 42,41
00B04:  DATA 43,4B
00B06:  DATA 20,20
00B08:  DATA 0A,0D
00B0A:  DATA 00,00
00B0C:  DATA 45,30
00B0E:  DATA 39,3A
00B10:  DATA 25,30
00B12:  DATA 32,75
00B14:  DATA 20,45
00B16:  DATA 31,30
00B18:  DATA 3A,25
00B1A:  DATA 30,32
00B1C:  DATA 75,20
00B1E:  DATA 45,31
00B20:  DATA 31,3A
00B22:  DATA 25,30
00B24:  DATA 32,75
00B26:  DATA 0A,0D
00B28:  DATA 00,00
00B2A:  DATA 45,31
00B2C:  DATA 32,3A
00B2E:  DATA 25,30
00B30:  DATA 32,75
00B32:  DATA 20,45
00B34:  DATA 31,33
00B36:  DATA 3A,25
00B38:  DATA 30,32
00B3A:  DATA 75,20
00B3C:  DATA 45,31
00B3E:  DATA 34,3A
00B40:  DATA 25,30
00B42:  DATA 32,75
00B44:  DATA 0A,0D
00B46:  DATA 00,00
00B48:  DATA 45,31
00B4A:  DATA 35,3A
00B4C:  DATA 25,30
00B4E:  DATA 32,75
00B50:  DATA 20,45
00B52:  DATA 31,36
00B54:  DATA 3A,25
00B56:  DATA 30,32
00B58:  DATA 75,20
00B5A:  DATA 45,31
00B5C:  DATA 37,3A
00B5E:  DATA 25,30
00B60:  DATA 32,75
00B62:  DATA 0A,0D
00B64:  DATA 00,00
00B66:  DATA 20,20
00B68:  DATA 3C,7C
00B6A:  DATA 3E,3A
00B6C:  DATA 50,52
00B6E:  DATA 4F,58
00B70:  DATA 7C,45
00B72:  DATA 53,43
00B74:  DATA 3A,42
00B76:  DATA 41,43
00B78:  DATA 4B,20
00B7A:  DATA 0A,0D
00B7C:  DATA 00,00
00B7E:  DATA 45,31
00B80:  DATA 38,3A
00B82:  DATA 25,30
00B84:  DATA 32,75
00B86:  DATA 20,45
00B88:  DATA 31,39
00B8A:  DATA 3A,25
00B8C:  DATA 30,32
00B8E:  DATA 75,20
00B90:  DATA 45,32
00B92:  DATA 30,3A
00B94:  DATA 25,30
00B96:  DATA 32,75
00B98:  DATA 0A,0D
00B9A:  DATA 00,00
00B9C:  DATA 45,32
00B9E:  DATA 31,3A
00BA0:  DATA 25,30
00BA2:  DATA 32,75
00BA4:  DATA 20,45
00BA6:  DATA 32,32
00BA8:  DATA 3A,25
00BAA:  DATA 30,32
00BAC:  DATA 75,20
00BAE:  DATA 45,32
00BB0:  DATA 33,3A
00BB2:  DATA 25,30
00BB4:  DATA 32,75
00BB6:  DATA 0A,0D
00BB8:  DATA 00,00
00BBA:  DATA 45,32
00BBC:  DATA 34,3A
00BBE:  DATA 25,30
00BC0:  DATA 32,75
00BC2:  DATA 20,45
00BC4:  DATA 32,35
00BC6:  DATA 3A,25
00BC8:  DATA 30,32
00BCA:  DATA 75,20
00BCC:  DATA 45,32
00BCE:  DATA 36,3A
00BD0:  DATA 25,30
00BD2:  DATA 32,75
00BD4:  DATA 0A,0D
00BD6:  DATA 00,00
00BD8:  DATA 45,32
00BDA:  DATA 37,3A
00BDC:  DATA 25,30
00BDE:  DATA 32,75
00BE0:  DATA 20,3C
00BE2:  DATA 3A,41
00BE4:  DATA 4E,54
00BE6:  DATA 7C,45
00BE8:  DATA 53,43
00BEA:  DATA 3A,42
00BEC:  DATA 41,43
00BEE:  DATA 4B,0A
00BF0:  DATA 0D,00
00BF2:  DATA 45,53
00BF4:  DATA 54,45
00BF6:  DATA 49,52
00BF8:  DATA 41,20
00BFA:  DATA 20,20
00BFC:  DATA 20,20
00BFE:  DATA 20,20
00C00:  DATA 20,20
00C02:  DATA 20,20
00C04:  DATA 20,20
00C06:  DATA 0A,0D
00C08:  DATA 00,00
00C0A:  DATA 44,45
00C0C:  DATA 44,4F
00C0E:  DATA 53,20
00C10:  DATA 45,4E
00C12:  DATA 54,52
00C14:  DATA 41,44
00C16:  DATA 41,20
00C18:  DATA 20,20
00C1A:  DATA 20,20
00C1C:  DATA 20,20
00C1E:  DATA 0A,0D
00C20:  DATA 00,00
00C22:  DATA 41,4C
00C24:  DATA 49,4D
00C26:  DATA 45,4E
00C28:  DATA 54,41
00C2A:  DATA 44,4F
00C2C:  DATA 52,5F
00C2E:  DATA 50,4C
00C30:  DATA 41,43
00C32:  DATA 41,20
00C34:  DATA 20,20
00C36:  DATA 0A,0D
00C38:  DATA 00,00
00C3A:  DATA 46,31
00C3C:  DATA 3A,4F
00C3E:  DATA 4E,7C
00C40:  DATA 46,32
00C42:  DATA 3A,4F
00C44:  DATA 46,7C
00C46:  DATA 45,53
00C48:  DATA 43,3A
00C4A:  DATA 42,41
00C4C:  DATA 43,4B
00C4E:  DATA 0A,0D
00C50:  DATA 00,00
00C52:  DATA 50,52
00C54:  DATA 45,53
00C56:  DATA 53,4F
00C58:  DATA 52,20
00C5A:  DATA 20,20
00C5C:  DATA 20,20
00C5E:  DATA 20,20
00C60:  DATA 20,20
00C62:  DATA 20,20
00C64:  DATA 20,20
00C66:  DATA 0A,0D
00C68:  DATA 00,00
00C6A:  DATA 44,45
00C6C:  DATA 44,4F
00C6E:  DATA 53,5F
00C70:  DATA 53,41
00C72:  DATA 49,44
00C74:  DATA 41,20
00C76:  DATA 20,20
00C78:  DATA 20,20
00C7A:  DATA 20,20
00C7C:  DATA 20,20
00C7E:  DATA 0A,0D
00C80:  DATA 00,00
00C82:  DATA 44,49
00C84:  DATA 53,50
00C86:  DATA 45,4E
00C88:  DATA 53,41
00C8A:  DATA 44,4F
00C8C:  DATA 52,5F
00C8E:  DATA 50,4C
00C90:  DATA 41,43
00C92:  DATA 41,20
00C94:  DATA 20,20
00C96:  DATA 0A,0D
00C98:  DATA 00,00
00C9A:  DATA 46,31
00C9C:  DATA 3A,4F
00C9E:  DATA 4E,7C
00CA0:  DATA 46,32
00CA2:  DATA 3A,4F
00CA4:  DATA 46,7C
00CA6:  DATA 45,53
00CA8:  DATA 43,3A
00CAA:  DATA 42,41
00CAC:  DATA 43,4B
00CAE:  DATA 0A,0D
00CB0:  DATA 00,00
00CB2:  DATA 41,4C
00CB4:  DATA 49,4D
00CB6:  DATA 45,4E
00CB8:  DATA 54,41
00CBA:  DATA 44,4F
00CBC:  DATA 52,5F
00CBE:  DATA 53,4F
00CC0:  DATA 4C,44
00CC2:  DATA 41,20
00CC4:  DATA 20,20
00CC6:  DATA 0A,0D
00CC8:  DATA 00,00
00CCA:  DATA 4C,49
00CCC:  DATA 4D,50
00CCE:  DATA 41,44
00CD0:  DATA 4F,52
00CD2:  DATA 5F,42
00CD4:  DATA 49,43
00CD6:  DATA 4F,20
00CD8:  DATA 20,20
00CDA:  DATA 20,20
00CDC:  DATA 20,20
00CDE:  DATA 0A,0D
00CE0:  DATA 00,00
00CE2:  DATA 46,45
00CE4:  DATA 52,52
00CE6:  DATA 4F,53
00CE8:  DATA 5F,44
00CEA:  DATA 45,5F
00CEC:  DATA 53,4F
00CEE:  DATA 4C,44
00CF0:  DATA 41,20
00CF2:  DATA 20,20
00CF4:  DATA 20,20
00CF6:  DATA 0A,0D
00CF8:  DATA 00,00
00CFA:  DATA 46,31
00CFC:  DATA 3A,4F
00CFE:  DATA 4E,7C
00D00:  DATA 46,32
00D02:  DATA 3A,4F
00D04:  DATA 46,7C
00D06:  DATA 45,53
00D08:  DATA 43,3A
00D0A:  DATA 42,41
00D0C:  DATA 43,4B
00D0E:  DATA 0A,0D
00D10:  DATA 00,00
00D12:  DATA 20,20
00D14:  DATA 20,58
00D16:  DATA 3A,25
00D18:  DATA 30,34
00D1A:  DATA 4C,75
00D1C:  DATA 20,20
00D1E:  DATA 59,3A
00D20:  DATA 25,30
00D22:  DATA 34,4C
00D24:  DATA 75,20
00D26:  DATA 20,0A
00D28:  DATA 0D,00
00D2A:  DATA 20,20
00D2C:  DATA 20,5A
00D2E:  DATA 3A,25
00D30:  DATA 30,34
00D32:  DATA 4C,75
00D34:  DATA 20,20
00D36:  DATA 46,3A
00D38:  DATA 25,30
00D3A:  DATA 34,4C
00D3C:  DATA 75,20
00D3E:  DATA 20,0A
00D40:  DATA 0D,00
00D42:  DATA 20,20
00D44:  DATA 5E,7C
00D46:  DATA 3F,7C
00D48:  DATA 7C,3E
00D4A:  DATA 7C,3C
00D4C:  DATA 7C,46
00D4E:  DATA 31,7C
00D50:  DATA 46,32
00D52:  DATA 7C,38
00D54:  DATA 7C,30
00D56:  DATA 20,0A
00D58:  DATA 0D,00
00D5A:  DATA 20,20
00D5C:  DATA 20,20
00D5E:  DATA 20,20
00D60:  DATA 20,45
00D62:  DATA 53,43
00D64:  DATA 3A,42
00D66:  DATA 41,43
00D68:  DATA 4B,20
00D6A:  DATA 20,20
00D6C:  DATA 20,20
00D6E:  DATA 20,0A
00D70:  DATA 0D,00
00D72:  DATA 20,45
00D74:  DATA 58,45
00D76:  DATA 43,55
00D78:  DATA 54,41
00D7A:  DATA 4E,44
00D7C:  DATA 4F,20
00D7E:  DATA 50,52
00D80:  DATA 4F,47
00D82:  DATA 52,41
00D84:  DATA 4D,41
00D86:  DATA 0A,0D
00D88:  DATA 00,00
00D8A:  DATA 20,20
00D8C:  DATA 20,20
00D8E:  DATA 20,4D
00D90:  DATA 4F,44
00D92:  DATA 45,4C
00D94:  DATA 4F,3A
00D96:  DATA 25,30
00D98:  DATA 32,75
00D9A:  DATA 20,20
00D9C:  DATA 20,20
00D9E:  DATA 0A,0D
00DA0:  DATA 00,00
00DA2:  DATA 20,20
00DA4:  DATA 20,20
00DA6:  DATA 20,20
00DA8:  DATA 20,20
00DAA:  DATA 20,20
00DAC:  DATA 20,20
00DAE:  DATA 20,20
00DB0:  DATA 20,20
00DB2:  DATA 20,20
00DB4:  DATA 20,20
00DB6:  DATA 0A,0D
00DB8:  DATA 00,00
00DBA:  DATA 20,20
00DBC:  DATA 20,20
00DBE:  DATA 20,20
00DC0:  DATA 45,53
00DC2:  DATA 43,3A
00DC4:  DATA 53,54
00DC6:  DATA 4F,50
00DC8:  DATA 20,20
00DCA:  DATA 20,20
00DCC:  DATA 20,20
00DCE:  DATA 0A,0D
00DD0:  DATA 00,00
00DD2:  DATA 20,20
00DD4:  DATA 50,4F
00DD6:  DATA 53,49
00DD8:  DATA 43,41
00DDA:  DATA 4F,20
00DDC:  DATA 49,52
00DDE:  DATA 52,45
00DE0:  DATA 47,55
00DE2:  DATA 4C,41
00DE4:  DATA 52,20
00DE6:  DATA 0A,0D
00DE8:  DATA 00,00
00DEA:  DATA 20,20
00DEC:  DATA 20,58
00DEE:  DATA 20,44
00DF0:  DATA 45,56
00DF2:  DATA 45,20
00DF4:  DATA 53,45
00DF6:  DATA 52,20
00DF8:  DATA 3E,20
00DFA:  DATA 30,20
00DFC:  DATA 20,20
00DFE:  DATA 0A,0D
00E00:  DATA 00,00
00E02:  DATA 20,20
00E04:  DATA 59,20
00E06:  DATA 44,45
00E08:  DATA 56,45
00E0A:  DATA 20,53
00E0C:  DATA 45,52
00E0E:  DATA 20,3E
00E10:  DATA 20,37
00E12:  DATA 30,30
00E14:  DATA 20,20
00E16:  DATA 0A,0D
00E18:  DATA 00,00
00E1A:  DATA 20,20
00E1C:  DATA 43,41
00E1E:  DATA 52,52
00E20:  DATA 45,47
00E22:  DATA 41,4E
00E24:  DATA 44,4F
00E26:  DATA 20,4D
00E28:  DATA 4F,44
00E2A:  DATA 45,4C
00E2C:  DATA 4F,20
00E2E:  DATA 0A,0D
00E30:  DATA 00,00
00E32:  DATA 20,20
00E34:  DATA 43,41
00E36:  DATA 52,52
00E38:  DATA 45,47
00E3A:  DATA 41,4E
00E3C:  DATA 44,4F
00E3E:  DATA 20,4D
00E40:  DATA 4F,44
00E42:  DATA 45,4C
00E44:  DATA 4F,20
00E46:  DATA 0A,0D
00E48:  DATA 00,00
00E4A:  DATA 50,4F
00E4C:  DATA 4E,54
00E4E:  DATA 4F,53
00E50:  DATA 20,41
00E52:  DATA 54,55
00E54:  DATA 41,4C
00E56:  DATA 49,5A
00E58:  DATA 41,44
00E5A:  DATA 4F,53
00E5C:  DATA 0A,0D
00E5E:  DATA 00,00
00E60:  DATA 20,20
00E62:  DATA 45,58
00E64:  DATA 43,4C
00E66:  DATA 55,49
00E68:  DATA 4E,44
00E6A:  DATA 4F,20
00E6C:  DATA 4D,4F
00E6E:  DATA 44,45
00E70:  DATA 4C,4F
00E72:  DATA 20,20
00E74:  DATA 0A,0D
00E76:  DATA 00,00
00E78:  DATA 20,20
00E7A:  DATA 20,4D
00E7C:  DATA 4F,44
00E7E:  DATA 45,4C
00E80:  DATA 4F,20
00E82:  DATA 45,58
00E84:  DATA 43,55
00E86:  DATA 49,44
00E88:  DATA 4F,20
00E8A:  DATA 20,20
00E8C:  DATA 0A,0D
00E8E:  DATA 00,00
00E90:  DATA 47,52
00E92:  DATA 41,56
00E94:  DATA 41,4E
00E96:  DATA 44,4F
00E98:  DATA 20,50
00E9A:  DATA 4F,4E
00E9C:  DATA 54,4F
00E9E:  DATA 0A,0D
00EA0:  DATA 00,00
00EA2:  DATA 50,4F
00EA4:  DATA 4E,54
00EA6:  DATA 4F,20
00EA8:  DATA 47,52
00EAA:  DATA 41,56
00EAC:  DATA 41,44
00EAE:  DATA 4F,0A
00EB0:  DATA 0D,00
00EB2:  DATA 20,20
00EB4:  DATA 20,45
00EB6:  DATA 53,50
00EB8:  DATA 45,52
00EBA:  DATA 41,4E
00EBC:  DATA 44,4F
00EBE:  DATA 20,50
00EC0:  DATA 4C,41
00EC2:  DATA 43,41
00EC4:  DATA 20,20
00EC6:  DATA 20,0A
00EC8:  DATA 0D,00
00ECA:  DATA 20,20
00ECC:  DATA 20,20
00ECE:  DATA 20,4E
00ED0:  DATA 41,20
00ED2:  DATA 45,53
00ED4:  DATA 54,45
00ED6:  DATA 49,52
00ED8:  DATA 41,20
00EDA:  DATA 20,20
00EDC:  DATA 20,20
00EDE:  DATA 0A,0D
00EE0:  DATA 00,00
00EE2:  DATA 20,20
00EE4:  DATA 20,20
00EE6:  DATA 20,20
00EE8:  DATA 53,45
00EEA:  DATA 4D,20
00EEC:  DATA 50,4C
00EEE:  DATA 41,43
00EF0:  DATA 41,20
00EF2:  DATA 20,20
00EF4:  DATA 20,20
00EF6:  DATA 0A,0D
00EF8:  DATA 00,00
00EFA:  DATA 20,20
00EFC:  DATA 20,20
00EFE:  DATA 20,4E
00F00:  DATA 41,20
00F02:  DATA 42,41
00F04:  DATA 4E,44
00F06:  DATA 45,4A
00F08:  DATA 41,20
00F0A:  DATA 20,20
00F0C:  DATA 20,20
00F0E:  DATA 0A,0D
00F10:  DATA 00,00
*
022FA:  TBLRD*+
022FC:  MOVF   FF5,F
022FE:  BZ    2318
02300:  MOVFF  FF6,3AE
02304:  MOVFF  FF7,3AF
02308:  MOVFF  FF5,3BE
0230C:  RCALL  22EE
0230E:  MOVFF  3AE,FF6
02312:  MOVFF  3AF,FF7
02316:  BRA    22FA
02318:  RETURN 0
*
02494:  TBLRD*+
02496:  MOVF   FF5,F
02498:  BZ    24B2
0249A:  MOVFF  FF6,3B2
0249E:  MOVFF  FF7,3B3
024A2:  MOVFF  FF5,3BD
024A6:  RCALL  2440
024A8:  MOVFF  3B2,FF6
024AC:  MOVFF  3B3,FF7
024B0:  BRA    2494
024B2:  RETURN 0
*
02632:  MOVLB  3
02634:  MOVF   xC8,W
02636:  BTFSC  FD8.2
02638:  BRA    271C
0263A:  MOVWF  00
0263C:  MOVF   xCC,W
0263E:  BTFSC  FD8.2
02640:  BRA    271C
02642:  ADDWF  00,F
02644:  BNC   264E
02646:  MOVLW  81
02648:  ADDWF  00,F
0264A:  BC    271C
0264C:  BRA    2656
0264E:  MOVLW  7F
02650:  SUBWF  00,F
02652:  BNC   271C
02654:  BZ    271C
02656:  MOVFF  3C9,3D0
0265A:  MOVF   xCD,W
0265C:  XORWF  xD0,F
0265E:  BSF    xC9.7
02660:  BSF    xCD.7
02662:  MOVF   xCB,W
02664:  MULWF  xCF
02666:  MOVFF  FF4,3D2
0266A:  MOVF   xCA,W
0266C:  MULWF  xCE
0266E:  MOVFF  FF4,03
02672:  MOVFF  FF3,3D1
02676:  MULWF  xCF
02678:  MOVF   FF3,W
0267A:  ADDWF  xD2,F
0267C:  MOVF   FF4,W
0267E:  ADDWFC xD1,F
02680:  MOVLW  00
02682:  ADDWFC 03,F
02684:  MOVF   xCB,W
02686:  MULWF  xCE
02688:  MOVF   FF3,W
0268A:  ADDWF  xD2,F
0268C:  MOVF   FF4,W
0268E:  ADDWFC xD1,F
02690:  MOVLW  00
02692:  CLRF   02
02694:  ADDWFC 03,F
02696:  ADDWFC 02,F
02698:  MOVF   xC9,W
0269A:  MULWF  xCF
0269C:  MOVF   FF3,W
0269E:  ADDWF  xD1,F
026A0:  MOVF   FF4,W
026A2:  ADDWFC 03,F
026A4:  MOVLW  00
026A6:  ADDWFC 02,F
026A8:  MOVF   xC9,W
026AA:  MULWF  xCE
026AC:  MOVF   FF3,W
026AE:  ADDWF  03,F
026B0:  MOVF   FF4,W
026B2:  ADDWFC 02,F
026B4:  MOVLW  00
026B6:  CLRF   01
026B8:  ADDWFC 01,F
026BA:  MOVF   xCB,W
026BC:  MULWF  xCD
026BE:  MOVF   FF3,W
026C0:  ADDWF  xD1,F
026C2:  MOVF   FF4,W
026C4:  ADDWFC 03,F
026C6:  MOVLW  00
026C8:  ADDWFC 02,F
026CA:  ADDWFC 01,F
026CC:  MOVF   xCA,W
026CE:  MULWF  xCD
026D0:  MOVF   FF3,W
026D2:  ADDWF  03,F
026D4:  MOVF   FF4,W
026D6:  ADDWFC 02,F
026D8:  MOVLW  00
026DA:  ADDWFC 01,F
026DC:  MOVF   xC9,W
026DE:  MULWF  xCD
026E0:  MOVF   FF3,W
026E2:  ADDWF  02,F
026E4:  MOVF   FF4,W
026E6:  ADDWFC 01,F
026E8:  INCF   00,F
026EA:  BTFSC  01.7
026EC:  BRA    26F8
026EE:  RLCF   xD1,F
026F0:  RLCF   03,F
026F2:  RLCF   02,F
026F4:  RLCF   01,F
026F6:  DECF   00,F
026F8:  MOVLW  00
026FA:  BTFSS  xD1.7
026FC:  BRA    2712
026FE:  INCF   03,F
02700:  ADDWFC 02,F
02702:  ADDWFC 01,F
02704:  MOVF   01,W
02706:  BNZ   2712
02708:  MOVF   02,W
0270A:  BNZ   2712
0270C:  MOVF   03,W
0270E:  BNZ   2712
02710:  INCF   00,F
02712:  BTFSC  xD0.7
02714:  BSF    01.7
02716:  BTFSS  xD0.7
02718:  BCF    01.7
0271A:  BRA    2724
0271C:  CLRF   00
0271E:  CLRF   01
02720:  CLRF   02
02722:  CLRF   03
02724:  MOVLB  0
02726:  RETURN 0
02728:  MOVLB  3
0272A:  MOVF   xCE,W
0272C:  BTFSC  FD8.2
0272E:  BRA    287A
02730:  MOVWF  xDA
02732:  MOVF   xD2,W
02734:  BTFSC  FD8.2
02736:  BRA    287A
02738:  SUBWF  xDA,F
0273A:  BNC   2746
0273C:  MOVLW  7F
0273E:  ADDWF  xDA,F
02740:  BTFSC  FD8.0
02742:  BRA    287A
02744:  BRA    2752
02746:  MOVLW  81
02748:  SUBWF  xDA,F
0274A:  BTFSS  FD8.0
0274C:  BRA    287A
0274E:  BTFSC  FD8.2
02750:  BRA    287A
02752:  MOVFF  3DA,00
02756:  CLRF   01
02758:  CLRF   02
0275A:  CLRF   03
0275C:  CLRF   xD9
0275E:  MOVFF  3CF,3D8
02762:  BSF    xD8.7
02764:  MOVFF  3D0,3D7
02768:  MOVFF  3D1,3D6
0276C:  MOVLW  19
0276E:  MOVWF  xDA
02770:  MOVF   xD5,W
02772:  SUBWF  xD6,F
02774:  BC    2790
02776:  MOVLW  01
02778:  SUBWF  xD7,F
0277A:  BC    2790
0277C:  SUBWF  xD8,F
0277E:  BC    2790
02780:  SUBWF  xD9,F
02782:  BC    2790
02784:  INCF   xD9,F
02786:  INCF   xD8,F
02788:  INCF   xD7,F
0278A:  MOVF   xD5,W
0278C:  ADDWF  xD6,F
0278E:  BRA    27E0
02790:  MOVF   xD4,W
02792:  SUBWF  xD7,F
02794:  BC    27BA
02796:  MOVLW  01
02798:  SUBWF  xD8,F
0279A:  BC    27BA
0279C:  SUBWF  xD9,F
0279E:  BC    27BA
027A0:  INCF   xD9,F
027A2:  INCF   xD8,F
027A4:  MOVF   xD4,W
027A6:  ADDWF  xD7,F
027A8:  MOVF   xD5,W
027AA:  ADDWF  xD6,F
027AC:  BNC   27E0
027AE:  INCF   xD7,F
027B0:  BNZ   27E0
027B2:  INCF   xD8,F
027B4:  BNZ   27E0
027B6:  INCF   xD9,F
027B8:  BRA    27E0
027BA:  MOVF   xD3,W
027BC:  IORLW  80
027BE:  SUBWF  xD8,F
027C0:  BC    27DE
027C2:  MOVLW  01
027C4:  SUBWF  xD9,F
027C6:  BC    27DE
027C8:  INCF   xD9,F
027CA:  MOVF   xD3,W
027CC:  IORLW  80
027CE:  ADDWF  xD8,F
027D0:  MOVF   xD4,W
027D2:  ADDWF  xD7,F
027D4:  BNC   27A8
027D6:  INCF   xD8,F
027D8:  BNZ   27A8
027DA:  INCF   xD9,F
027DC:  BRA    27A8
027DE:  BSF    03.0
027E0:  DECFSZ xDA,F
027E2:  BRA    27E6
027E4:  BRA    27FC
027E6:  BCF    FD8.0
027E8:  RLCF   xD6,F
027EA:  RLCF   xD7,F
027EC:  RLCF   xD8,F
027EE:  RLCF   xD9,F
027F0:  BCF    FD8.0
027F2:  RLCF   03,F
027F4:  RLCF   02,F
027F6:  RLCF   01,F
027F8:  RLCF   xDB,F
027FA:  BRA    2770
027FC:  BTFSS  xDB.0
027FE:  BRA    280C
02800:  BCF    FD8.0
02802:  RRCF   01,F
02804:  RRCF   02,F
02806:  RRCF   03,F
02808:  RRCF   xDB,F
0280A:  BRA    2810
0280C:  DECF   00,F
0280E:  BZ    287A
02810:  BTFSC  xDB.7
02812:  BRA    2850
02814:  BCF    FD8.0
02816:  RLCF   xD6,F
02818:  RLCF   xD7,F
0281A:  RLCF   xD8,F
0281C:  RLCF   xD9,F
0281E:  MOVF   xD5,W
02820:  SUBWF  xD6,F
02822:  BC    2832
02824:  MOVLW  01
02826:  SUBWF  xD7,F
02828:  BC    2832
0282A:  SUBWF  xD8,F
0282C:  BC    2832
0282E:  SUBWF  xD9,F
02830:  BNC   2866
02832:  MOVF   xD4,W
02834:  SUBWF  xD7,F
02836:  BC    2842
02838:  MOVLW  01
0283A:  SUBWF  xD8,F
0283C:  BC    2842
0283E:  SUBWF  xD9,F
02840:  BNC   2866
02842:  MOVF   xD3,W
02844:  IORLW  80
02846:  SUBWF  xD8,F
02848:  BC    2850
0284A:  MOVLW  01
0284C:  SUBWF  xD9,F
0284E:  BNC   2866
02850:  INCF   03,F
02852:  BNZ   2866
02854:  INCF   02,F
02856:  BNZ   2866
02858:  INCF   01,F
0285A:  BNZ   2866
0285C:  INCF   00,F
0285E:  BZ    287A
02860:  RRCF   01,F
02862:  RRCF   02,F
02864:  RRCF   03,F
02866:  MOVFF  3CF,3DA
0286A:  MOVF   xD3,W
0286C:  XORWF  xDA,F
0286E:  BTFSS  xDA.7
02870:  BRA    2876
02872:  BSF    01.7
02874:  BRA    2882
02876:  BCF    01.7
02878:  BRA    2882
0287A:  CLRF   00
0287C:  CLRF   01
0287E:  CLRF   02
02880:  CLRF   03
02882:  MOVLB  0
02884:  RETURN 0
02886:  MOVLW  8E
02888:  MOVWF  00
0288A:  MOVFF  3C9,01
0288E:  MOVFF  3C8,02
02892:  CLRF   03
02894:  MOVF   01,F
02896:  BNZ   28AA
02898:  MOVFF  02,01
0289C:  CLRF   02
0289E:  MOVLW  08
028A0:  SUBWF  00,F
028A2:  MOVF   01,F
028A4:  BNZ   28AA
028A6:  CLRF   00
028A8:  BRA    28BA
028AA:  BCF    FD8.0
028AC:  BTFSC  01.7
028AE:  BRA    28B8
028B0:  RLCF   02,F
028B2:  RLCF   01,F
028B4:  DECF   00,F
028B6:  BRA    28AA
028B8:  BCF    01.7
028BA:  RETURN 0
028BC:  MOVLW  80
028BE:  BTFSS  FD8.1
028C0:  BRA    28C6
028C2:  MOVLB  3
028C4:  XORWF  xD3,F
028C6:  MOVLB  3
028C8:  CLRF   xD8
028CA:  CLRF   xD9
028CC:  MOVFF  3CF,3D7
028D0:  MOVF   xD3,W
028D2:  XORWF  xD7,F
028D4:  MOVF   xCE,W
028D6:  BTFSC  FD8.2
028D8:  BRA    2A98
028DA:  MOVWF  xD6
028DC:  MOVWF  00
028DE:  MOVF   xD2,W
028E0:  BTFSC  FD8.2
028E2:  BRA    2AAA
028E4:  SUBWF  xD6,F
028E6:  BTFSC  FD8.2
028E8:  BRA    29F0
028EA:  BNC   2968
028EC:  MOVFF  3D3,3DC
028F0:  BSF    xDC.7
028F2:  MOVFF  3D4,3DB
028F6:  MOVFF  3D5,3DA
028FA:  CLRF   xD9
028FC:  BCF    FD8.0
028FE:  RRCF   xDC,F
02900:  RRCF   xDB,F
02902:  RRCF   xDA,F
02904:  RRCF   xD9,F
02906:  DECFSZ xD6,F
02908:  BRA    28FA
0290A:  BTFSS  xD7.7
0290C:  BRA    2914
0290E:  BSF    xD8.0
02910:  BRA    2AD2
02912:  BCF    xD8.0
02914:  BCF    xD6.0
02916:  BSF    xD8.4
02918:  MOVLW  03
0291A:  MOVWF  FEA
0291C:  MOVLW  D1
0291E:  MOVWF  FE9
02920:  BRA    2AF8
02922:  BCF    xD8.4
02924:  BTFSC  xD7.7
02926:  BRA    293C
02928:  BTFSS  xD6.0
0292A:  BRA    2952
0292C:  RRCF   xDC,F
0292E:  RRCF   xDB,F
02930:  RRCF   xDA,F
02932:  RRCF   xD9,F
02934:  INCF   00,F
02936:  BTFSC  FD8.2
02938:  BRA    2AC8
0293A:  BRA    2952
0293C:  BTFSC  xDC.7
0293E:  BRA    2958
02940:  BCF    FD8.0
02942:  RLCF   xD9,F
02944:  RLCF   xDA,F
02946:  RLCF   xDB,F
02948:  RLCF   xDC,F
0294A:  DECF   00,F
0294C:  BTFSC  FD8.2
0294E:  BRA    2AC8
02950:  BRA    293C
02952:  BSF    xD8.6
02954:  BRA    2A30
02956:  BCF    xD8.6
02958:  MOVFF  3CF,3D7
0295C:  BTFSS  xCF.7
0295E:  BRA    2964
02960:  BSF    xDC.7
02962:  BRA    2ABA
02964:  BCF    xDC.7
02966:  BRA    2ABA
02968:  MOVFF  3D2,3D6
0296C:  MOVFF  3D2,00
02970:  MOVF   xCE,W
02972:  SUBWF  xD6,F
02974:  MOVFF  3CF,3DC
02978:  BSF    xDC.7
0297A:  MOVFF  3D0,3DB
0297E:  MOVFF  3D1,3DA
02982:  CLRF   xD9
02984:  BCF    FD8.0
02986:  RRCF   xDC,F
02988:  RRCF   xDB,F
0298A:  RRCF   xDA,F
0298C:  RRCF   xD9,F
0298E:  DECFSZ xD6,F
02990:  BRA    2982
02992:  BTFSS  xD7.7
02994:  BRA    299C
02996:  BSF    xD8.1
02998:  BRA    2AD2
0299A:  BCF    xD8.1
0299C:  BCF    xD6.0
0299E:  BSF    xD8.5
029A0:  MOVLW  03
029A2:  MOVWF  FEA
029A4:  MOVLW  D5
029A6:  MOVWF  FE9
029A8:  BRA    2AF8
029AA:  BCF    xD8.5
029AC:  BTFSC  xD7.7
029AE:  BRA    29C4
029B0:  BTFSS  xD6.0
029B2:  BRA    29DA
029B4:  RRCF   xDC,F
029B6:  RRCF   xDB,F
029B8:  RRCF   xDA,F
029BA:  RRCF   xD9,F
029BC:  INCF   00,F
029BE:  BTFSC  FD8.2
029C0:  BRA    2AC8
029C2:  BRA    29DA
029C4:  BTFSC  xDC.7
029C6:  BRA    29E0
029C8:  BCF    FD8.0
029CA:  RLCF   xD9,F
029CC:  RLCF   xDA,F
029CE:  RLCF   xDB,F
029D0:  RLCF   xDC,F
029D2:  DECF   00,F
029D4:  BTFSC  FD8.2
029D6:  BRA    2AC8
029D8:  BRA    29C4
029DA:  BSF    xD8.7
029DC:  BRA    2A30
029DE:  BCF    xD8.7
029E0:  MOVFF  3D3,3D7
029E4:  BTFSS  xD3.7
029E6:  BRA    29EC
029E8:  BSF    xDC.7
029EA:  BRA    2ABA
029EC:  BCF    xDC.7
029EE:  BRA    2ABA
029F0:  MOVFF  3D3,3DC
029F4:  BSF    xDC.7
029F6:  MOVFF  3D4,3DB
029FA:  MOVFF  3D5,3DA
029FE:  BTFSS  xD7.7
02A00:  BRA    2A0A
02A02:  BCF    xDC.7
02A04:  BSF    xD8.2
02A06:  BRA    2AD2
02A08:  BCF    xD8.2
02A0A:  CLRF   xD9
02A0C:  BCF    xD6.0
02A0E:  MOVLW  03
02A10:  MOVWF  FEA
02A12:  MOVLW  D1
02A14:  MOVWF  FE9
02A16:  BRA    2AF8
02A18:  BTFSC  xD7.7
02A1A:  BRA    2A54
02A1C:  MOVFF  3CF,3D7
02A20:  BTFSS  xD6.0
02A22:  BRA    2A30
02A24:  RRCF   xDC,F
02A26:  RRCF   xDB,F
02A28:  RRCF   xDA,F
02A2A:  RRCF   xD9,F
02A2C:  INCF   00,F
02A2E:  BZ    2AC8
02A30:  BTFSS  xD9.7
02A32:  BRA    2A4A
02A34:  INCF   xDA,F
02A36:  BNZ   2A4A
02A38:  INCF   xDB,F
02A3A:  BNZ   2A4A
02A3C:  INCF   xDC,F
02A3E:  BNZ   2A4A
02A40:  RRCF   xDC,F
02A42:  RRCF   xDB,F
02A44:  RRCF   xDA,F
02A46:  INCF   00,F
02A48:  BZ    2AC8
02A4A:  BTFSC  xD8.6
02A4C:  BRA    2956
02A4E:  BTFSC  xD8.7
02A50:  BRA    29DE
02A52:  BRA    2A8C
02A54:  MOVLW  80
02A56:  XORWF  xDC,F
02A58:  BTFSS  xDC.7
02A5A:  BRA    2A64
02A5C:  BRA    2AD2
02A5E:  MOVFF  3D3,3D7
02A62:  BRA    2A78
02A64:  MOVFF  3CF,3D7
02A68:  MOVF   xDC,F
02A6A:  BNZ   2A78
02A6C:  MOVF   xDB,F
02A6E:  BNZ   2A78
02A70:  MOVF   xDA,F
02A72:  BNZ   2A78
02A74:  CLRF   00
02A76:  BRA    2ABA
02A78:  BTFSC  xDC.7
02A7A:  BRA    2A8C
02A7C:  BCF    FD8.0
02A7E:  RLCF   xD9,F
02A80:  RLCF   xDA,F
02A82:  RLCF   xDB,F
02A84:  RLCF   xDC,F
02A86:  DECFSZ 00,F
02A88:  BRA    2A78
02A8A:  BRA    2AC8
02A8C:  BTFSS  xD7.7
02A8E:  BRA    2A94
02A90:  BSF    xDC.7
02A92:  BRA    2ABA
02A94:  BCF    xDC.7
02A96:  BRA    2ABA
02A98:  MOVFF  3D2,00
02A9C:  MOVFF  3D3,3DC
02AA0:  MOVFF  3D4,3DB
02AA4:  MOVFF  3D5,3DA
02AA8:  BRA    2ABA
02AAA:  MOVFF  3CE,00
02AAE:  MOVFF  3CF,3DC
02AB2:  MOVFF  3D0,3DB
02AB6:  MOVFF  3D1,3DA
02ABA:  MOVFF  3DC,01
02ABE:  MOVFF  3DB,02
02AC2:  MOVFF  3DA,03
02AC6:  BRA    2B30
02AC8:  CLRF   00
02ACA:  CLRF   01
02ACC:  CLRF   02
02ACE:  CLRF   03
02AD0:  BRA    2B30
02AD2:  CLRF   xD9
02AD4:  COMF   xDA,F
02AD6:  COMF   xDB,F
02AD8:  COMF   xDC,F
02ADA:  COMF   xD9,F
02ADC:  INCF   xD9,F
02ADE:  BNZ   2AEA
02AE0:  INCF   xDA,F
02AE2:  BNZ   2AEA
02AE4:  INCF   xDB,F
02AE6:  BNZ   2AEA
02AE8:  INCF   xDC,F
02AEA:  BTFSC  xD8.0
02AEC:  BRA    2912
02AEE:  BTFSC  xD8.1
02AF0:  BRA    299A
02AF2:  BTFSC  xD8.2
02AF4:  BRA    2A08
02AF6:  BRA    2A5E
02AF8:  MOVF   FEF,W
02AFA:  ADDWF  xDA,F
02AFC:  BNC   2B08
02AFE:  INCF   xDB,F
02B00:  BNZ   2B08
02B02:  INCF   xDC,F
02B04:  BTFSC  FD8.2
02B06:  BSF    xD6.0
02B08:  MOVF   FED,F
02B0A:  MOVF   FEF,W
02B0C:  ADDWF  xDB,F
02B0E:  BNC   2B16
02B10:  INCF   xDC,F
02B12:  BTFSC  FD8.2
02B14:  BSF    xD6.0
02B16:  MOVF   FED,F
02B18:  MOVF   FEF,W
02B1A:  BTFSC  FEF.7
02B1C:  BRA    2B20
02B1E:  XORLW  80
02B20:  ADDWF  xDC,F
02B22:  BTFSC  FD8.0
02B24:  BSF    xD6.0
02B26:  BTFSC  xD8.4
02B28:  BRA    2922
02B2A:  BTFSC  xD8.5
02B2C:  BRA    29AA
02B2E:  BRA    2A18
02B30:  MOVLB  0
02B32:  RETURN 0
02B34:  MOVLB  3
02B36:  CLRF   xC6
02B38:  CLRF   xC7
02B3A:  MOVLW  01
02B3C:  MOVWF  xC8
02B3E:  CLRF   FDA
02B40:  CLRF   FD9
02B42:  MOVLW  03
02B44:  MOVWF  xCB
02B46:  MOVLW  BE
02B48:  MOVWF  xCA
02B4A:  MOVLW  03
02B4C:  MOVWF  FEA
02B4E:  MOVLW  C2
02B50:  MOVWF  FE9
02B52:  MOVFF  3CB,FE2
02B56:  MOVFF  3CA,FE1
02B5A:  MOVFF  3C8,3C9
02B5E:  BCF    FD8.0
02B60:  MOVF   FE5,W
02B62:  MULWF  FEE
02B64:  MOVF   FF3,W
02B66:  ADDWFC xC6,F
02B68:  MOVF   FF4,W
02B6A:  ADDWFC xC7,F
02B6C:  DECFSZ xC9,F
02B6E:  BRA    2B5E
02B70:  MOVFF  3C6,FDE
02B74:  MOVFF  3C7,3C6
02B78:  CLRF   xC7
02B7A:  BTFSC  FD8.0
02B7C:  INCF   xC7,F
02B7E:  INCF   xCA,F
02B80:  BTFSC  FD8.2
02B82:  INCF   xCB,F
02B84:  INCF   xC8,F
02B86:  MOVF   xC8,W
02B88:  SUBLW  05
02B8A:  BNZ   2B4A
02B8C:  MOVLB  0
02B8E:  RETURN 0
02B90:  MOVLW  B6
02B92:  MOVWF  00
02B94:  CLRF   03
02B96:  CLRF   02
02B98:  CLRF   01
02B9A:  MOVLB  3
02B9C:  MOVF   xCE,W
02B9E:  IORWF  xCF,W
02BA0:  IORWF  xD0,W
02BA2:  IORWF  xD1,W
02BA4:  BNZ   2BAA
02BA6:  CLRF   00
02BA8:  BRA    2BC4
02BAA:  BCF    FD8.0
02BAC:  BTFSC  01.7
02BAE:  BRA    2BC2
02BB0:  RLCF   xCE,F
02BB2:  RLCF   xCF,F
02BB4:  RLCF   xD0,F
02BB6:  RLCF   xD1,F
02BB8:  RLCF   03,F
02BBA:  RLCF   02,F
02BBC:  RLCF   01,F
02BBE:  DECFSZ 00,F
02BC0:  BRA    2BAA
02BC2:  BCF    01.7
02BC4:  MOVLB  0
02BC6:  RETURN 0
02BC8:  MOVLB  3
02BCA:  MOVF   xCE,W
02BCC:  SUBLW  B6
02BCE:  MOVWF  xCE
02BD0:  CLRF   03
02BD2:  MOVFF  3CF,3D2
02BD6:  BSF    xCF.7
02BD8:  BCF    FD8.0
02BDA:  RRCF   xCF,F
02BDC:  RRCF   xD0,F
02BDE:  RRCF   xD1,F
02BE0:  RRCF   03,F
02BE2:  RRCF   02,F
02BE4:  RRCF   01,F
02BE6:  RRCF   00,F
02BE8:  DECFSZ xCE,F
02BEA:  BRA    2BD8
02BEC:  BTFSS  xD2.7
02BEE:  BRA    2C06
02BF0:  COMF   00,F
02BF2:  COMF   01,F
02BF4:  COMF   02,F
02BF6:  COMF   03,F
02BF8:  INCF   00,F
02BFA:  BTFSC  FD8.2
02BFC:  INCF   01,F
02BFE:  BTFSC  FD8.2
02C00:  INCF   02,F
02C02:  BTFSC  FD8.2
02C04:  INCF   03,F
02C06:  MOVLB  0
02C08:  RETURN 0
*
03A24:  MOVLB  3
03A26:  MOVF   xB5,W
03A28:  ANDLW  07
03A2A:  MOVWF  00
03A2C:  RRCF   xB5,W
03A2E:  MOVWF  01
03A30:  RRCF   01,F
03A32:  RRCF   01,F
03A34:  MOVLW  1F
03A36:  ANDWF  01,F
03A38:  MOVF   01,W
03A3A:  ADDWF  xB7,W
03A3C:  MOVWF  FE9
03A3E:  MOVLW  00
03A40:  ADDWFC xB8,W
03A42:  MOVWF  FEA
03A44:  CLRF   01
03A46:  INCF   01,F
03A48:  INCF   00,F
03A4A:  BRA    3A4E
03A4C:  RLCF   01,F
03A4E:  DECFSZ 00,F
03A50:  BRA    3A4C
03A52:  MOVF   xB6,F
03A54:  BZ    3A5C
03A56:  MOVF   01,W
03A58:  IORWF  FEF,F
03A5A:  BRA    3A62
03A5C:  COMF   01,F
03A5E:  MOVF   01,W
03A60:  ANDWF  FEF,F
03A62:  MOVLB  0
03A64:  RETURN 0
03A66:  MOVLB  3
03A68:  MOVF   xB5,W
03A6A:  ANDLW  07
03A6C:  MOVWF  00
03A6E:  RRCF   xB5,W
03A70:  MOVWF  01
03A72:  RRCF   01,F
03A74:  RRCF   01,F
03A76:  MOVLW  1F
03A78:  ANDWF  01,F
03A7A:  MOVF   01,W
03A7C:  ADDWF  xB6,W
03A7E:  MOVWF  FE9
03A80:  MOVLW  00
03A82:  ADDWFC xB7,W
03A84:  MOVWF  FEA
03A86:  MOVFF  FEF,01
03A8A:  INCF   00,F
03A8C:  BRA    3A90
03A8E:  RRCF   01,F
03A90:  DECFSZ 00,F
03A92:  BRA    3A8E
03A94:  MOVLB  0
03A96:  RETURN 0
*
03DE8:  MOVFF  FF2,0D
03DEC:  BCF    FF2.7
03DEE:  ADDWF  FE8,W
03DF0:  CLRF   FF7
03DF2:  RLCF   FF7,F
03DF4:  ADDLW  0D
03DF6:  MOVWF  FF6
03DF8:  MOVLW  3E
03DFA:  ADDWFC FF7,F
03DFC:  TBLRD*-
03DFE:  MOVF   FF5,W
03E00:  MOVWF  FFA
03E02:  TBLRD*
03E04:  MOVF   FF5,W
03E06:  BTFSC  0D.7
03E08:  BSF    FF2.7
03E0A:  MOVWF  FF9
03E0C:  DATA 24,3C
03E0E:  DATA 60,3C
03E10:  DATA E0,3D
03E12:  DATA A0,3C
03E14:  DATA E0,3C
03E16:  DATA 20,3D
03E18:  DATA 60,3D
03E1A:  DATA A0,3D
*
03FA0:  MOVFF  FF2,0D
03FA4:  BCF    FF2.7
03FA6:  ADDWF  FE8,W
03FA8:  CLRF   FF7
03FAA:  RLCF   FF7,F
03FAC:  ADDLW  C5
03FAE:  MOVWF  FF6
03FB0:  MOVLW  3F
03FB2:  ADDWFC FF7,F
03FB4:  TBLRD*-
03FB6:  MOVF   FF5,W
03FB8:  MOVWF  FFA
03FBA:  TBLRD*
03FBC:  MOVF   FF5,W
03FBE:  BTFSC  0D.7
03FC0:  BSF    FF2.7
03FC2:  MOVWF  FF9
03FC4:  DATA 2E,3E
03FC6:  DATA 62,3E
03FC8:  DATA 9A,3F
03FCA:  DATA 96,3E
03FCC:  DATA CA,3E
03FCE:  DATA FE,3E
03FD0:  DATA 32,3F
03FD2:  DATA 66,3F
*
042AA:  MOVFF  FF2,0D
042AE:  BCF    FF2.7
042B0:  ADDWF  FE8,W
042B2:  CLRF   FF7
042B4:  RLCF   FF7,F
042B6:  ADDLW  CF
042B8:  MOVWF  FF6
042BA:  MOVLW  42
042BC:  ADDWFC FF7,F
042BE:  TBLRD*-
042C0:  MOVF   FF5,W
042C2:  MOVWF  FFA
042C4:  TBLRD*
042C6:  MOVF   FF5,W
042C8:  BTFSC  0D.7
042CA:  BSF    FF2.7
042CC:  MOVWF  FF9
042CE:  DATA B4,41
042D0:  DATA F0,41
042D2:  DATA 2C,42
042D4:  DATA 68,42
*
04CC4:  MOVFF  FF2,0D
04CC8:  BCF    FF2.7
04CCA:  ADDWF  FE8,W
04CCC:  CLRF   FF7
04CCE:  RLCF   FF7,F
04CD0:  ADDLW  E9
04CD2:  MOVWF  FF6
04CD4:  MOVLW  4C
04CD6:  ADDWFC FF7,F
04CD8:  TBLRD*-
04CDA:  MOVF   FF5,W
04CDC:  MOVWF  FFA
04CDE:  TBLRD*
04CE0:  MOVF   FF5,W
04CE2:  BTFSC  0D.7
04CE4:  BSF    FF2.7
04CE6:  MOVWF  FF9
04CE8:  DATA 3E,4C
04CEA:  DATA 4E,4C
04CEC:  DATA BE,4C
04CEE:  DATA 5E,4C
04CF0:  DATA 6E,4C
04CF2:  DATA 7E,4C
04CF4:  DATA 8E,4C
04CF6:  DATA 9E,4C
04CF8:  DATA AE,4C
*
04DF6:  TBLRD*+
04DF8:  MOVFF  FF6,3B5
04DFC:  MOVFF  FF7,3B6
04E00:  MOVFF  FF5,3BD
04E04:  CALL   2440
04E08:  MOVFF  3B5,FF6
04E0C:  MOVFF  3B6,FF7
04E10:  MOVLB  3
04E12:  DECFSZ xB4,F
04E14:  BRA    4E18
04E16:  BRA    4E1C
04E18:  MOVLB  0
04E1A:  BRA    4DF6
04E1C:  MOVLB  0
04E1E:  RETURN 0
04E20:  MOVLB  3
04E22:  MOVF   xB4,W
04E24:  CLRF   01
04E26:  SUBWF  xB3,W
04E28:  BC    4E30
04E2A:  MOVFF  3B3,00
04E2E:  BRA    4E48
04E30:  CLRF   00
04E32:  MOVLW  08
04E34:  MOVWF  xB5
04E36:  RLCF   xB3,F
04E38:  RLCF   00,F
04E3A:  MOVF   xB4,W
04E3C:  SUBWF  00,W
04E3E:  BTFSC  FD8.0
04E40:  MOVWF  00
04E42:  RLCF   01,F
04E44:  DECFSZ xB5,F
04E46:  BRA    4E36
04E48:  MOVLB  0
04E4A:  RETURN 0
04E4C:  MOVF   01,W
04E4E:  MOVFF  3B1,3B3
04E52:  MOVLW  64
04E54:  MOVLB  3
04E56:  MOVWF  xB4
04E58:  MOVLB  0
04E5A:  RCALL  4E20
04E5C:  MOVFF  00,3B1
04E60:  MOVF   01,W
04E62:  MOVLW  30
04E64:  BNZ   4E76
04E66:  MOVLB  3
04E68:  BTFSS  xB2.1
04E6A:  BRA    4E8C
04E6C:  BTFSC  xB2.3
04E6E:  BRA    4E8C
04E70:  BTFSC  xB2.4
04E72:  MOVLW  20
04E74:  BRA    4E7E
04E76:  MOVLB  3
04E78:  BCF    xB2.3
04E7A:  BCF    xB2.4
04E7C:  BSF    xB2.0
04E7E:  ADDWF  01,F
04E80:  MOVFF  01,3BD
04E84:  MOVLB  0
04E86:  CALL   2440
04E8A:  MOVLB  3
04E8C:  MOVFF  3B1,3B3
04E90:  MOVLW  0A
04E92:  MOVWF  xB4
04E94:  MOVLB  0
04E96:  RCALL  4E20
04E98:  MOVFF  00,3B1
04E9C:  MOVF   01,W
04E9E:  MOVLW  30
04EA0:  BNZ   4EB2
04EA2:  MOVLB  3
04EA4:  BTFSC  xB2.3
04EA6:  BRA    4EBE
04EA8:  BTFSS  xB2.0
04EAA:  BRA    4EBE
04EAC:  BTFSC  xB2.4
04EAE:  MOVLW  20
04EB0:  MOVLB  0
04EB2:  ADDWF  01,F
04EB4:  MOVFF  01,3BD
04EB8:  CALL   2440
04EBC:  MOVLB  3
04EBE:  MOVLW  30
04EC0:  ADDWF  xB1,F
04EC2:  MOVFF  3B1,3BD
04EC6:  MOVLB  0
04EC8:  CALL   2440
04ECC:  RETURN 0
*
04F32:  BTFSC  FD8.1
04F34:  BRA    4F3E
04F36:  MOVLW  03
04F38:  MOVWF  FEA
04F3A:  MOVLW  B9
04F3C:  MOVWF  FE9
04F3E:  CLRF   00
04F40:  CLRF   01
04F42:  CLRF   02
04F44:  CLRF   03
04F46:  MOVLB  3
04F48:  CLRF   xB9
04F4A:  CLRF   xBA
04F4C:  CLRF   xBB
04F4E:  CLRF   xBC
04F50:  MOVF   xB8,W
04F52:  IORWF  xB7,W
04F54:  IORWF  xB6,W
04F56:  IORWF  xB5,W
04F58:  BZ    4FB2
04F5A:  MOVLW  20
04F5C:  MOVWF  xBD
04F5E:  BCF    FD8.0
04F60:  RLCF   xB1,F
04F62:  RLCF   xB2,F
04F64:  RLCF   xB3,F
04F66:  RLCF   xB4,F
04F68:  RLCF   xB9,F
04F6A:  RLCF   xBA,F
04F6C:  RLCF   xBB,F
04F6E:  RLCF   xBC,F
04F70:  MOVF   xB8,W
04F72:  SUBWF  xBC,W
04F74:  BNZ   4F86
04F76:  MOVF   xB7,W
04F78:  SUBWF  xBB,W
04F7A:  BNZ   4F86
04F7C:  MOVF   xB6,W
04F7E:  SUBWF  xBA,W
04F80:  BNZ   4F86
04F82:  MOVF   xB5,W
04F84:  SUBWF  xB9,W
04F86:  BNC   4FA6
04F88:  MOVF   xB5,W
04F8A:  SUBWF  xB9,F
04F8C:  MOVF   xB6,W
04F8E:  BTFSS  FD8.0
04F90:  INCFSZ xB6,W
04F92:  SUBWF  xBA,F
04F94:  MOVF   xB7,W
04F96:  BTFSS  FD8.0
04F98:  INCFSZ xB7,W
04F9A:  SUBWF  xBB,F
04F9C:  MOVF   xB8,W
04F9E:  BTFSS  FD8.0
04FA0:  INCFSZ xB8,W
04FA2:  SUBWF  xBC,F
04FA4:  BSF    FD8.0
04FA6:  RLCF   00,F
04FA8:  RLCF   01,F
04FAA:  RLCF   02,F
04FAC:  RLCF   03,F
04FAE:  DECFSZ xBD,F
04FB0:  BRA    4F5E
04FB2:  MOVFF  3B9,FEF
04FB6:  MOVFF  3BA,FEC
04FBA:  MOVFF  3BB,FEC
04FBE:  MOVFF  3BC,FEC
04FC2:  MOVLB  0
04FC4:  GOTO   A936 (RETURN)
*
0639E:  MOVFF  FF2,0D
063A2:  BCF    FF2.7
063A4:  ADDWF  FE8,W
063A6:  CLRF   FF7
063A8:  RLCF   FF7,F
063AA:  ADDLW  C3
063AC:  MOVWF  FF6
063AE:  MOVLW  63
063B0:  ADDWFC FF7,F
063B2:  TBLRD*-
063B4:  MOVF   FF5,W
063B6:  MOVWF  FFA
063B8:  TBLRD*
063BA:  MOVF   FF5,W
063BC:  BTFSC  0D.7
063BE:  BSF    FF2.7
063C0:  MOVWF  FF9
063C2:  DATA 12,5A
063C4:  DATA D0,5A
063C6:  DATA 98,63
063C8:  DATA BC,5D
063CA:  DATA 0C,5F
063CC:  DATA C2,60
063CE:  DATA 88,61
063D0:  DATA F8,62
*
067C2:  MOVFF  FF2,0D
067C6:  BCF    FF2.7
067C8:  ADDWF  FE8,W
067CA:  CLRF   FF7
067CC:  RLCF   FF7,F
067CE:  ADDLW  E7
067D0:  MOVWF  FF6
067D2:  MOVLW  67
067D4:  ADDWFC FF7,F
067D6:  TBLRD*-
067D8:  MOVF   FF5,W
067DA:  MOVWF  FFA
067DC:  TBLRD*
067DE:  MOVF   FF5,W
067E0:  BTFSC  0D.7
067E2:  BSF    FF2.7
067E4:  MOVWF  FF9
067E6:  DATA 52,67
067E8:  DATA 62,67
067EA:  DATA BE,67
067EC:  DATA BE,67
067EE:  DATA 76,67
067F0:  DATA 7E,67
067F2:  MOVFF  FEA,3BC
067F6:  MOVFF  FE9,3BB
067FA:  MOVLB  3
067FC:  SWAPF  xB5,W
067FE:  IORLW  F0
06800:  MOVWF  xB7
06802:  ADDWF  xB7,F
06804:  ADDLW  E2
06806:  MOVWF  xB8
06808:  ADDLW  32
0680A:  MOVWF  xBA
0680C:  MOVF   xB5,W
0680E:  ANDLW  0F
06810:  ADDWF  xB8,F
06812:  ADDWF  xB8,F
06814:  ADDWF  xBA,F
06816:  ADDLW  E9
06818:  MOVWF  xB9
0681A:  ADDWF  xB9,F
0681C:  ADDWF  xB9,F
0681E:  SWAPF  xB4,W
06820:  ANDLW  0F
06822:  ADDWF  xB9,F
06824:  ADDWF  xBA,F
06826:  RLCF   xB9,F
06828:  RLCF   xBA,F
0682A:  COMF   xBA,F
0682C:  RLCF   xBA,F
0682E:  MOVF   xB4,W
06830:  ANDLW  0F
06832:  ADDWF  xBA,F
06834:  RLCF   xB7,F
06836:  MOVLW  07
06838:  MOVWF  xB6
0683A:  MOVLW  0A
0683C:  DECF   xB9,F
0683E:  ADDWF  xBA,F
06840:  BNC   683C
06842:  DECF   xB8,F
06844:  ADDWF  xB9,F
06846:  BNC   6842
06848:  DECF   xB7,F
0684A:  ADDWF  xB8,F
0684C:  BNC   6848
0684E:  DECF   xB6,F
06850:  ADDWF  xB7,F
06852:  BNC   684E
06854:  MOVLW  03
06856:  MOVWF  FEA
06858:  MOVLW  B6
0685A:  MOVWF  FE9
0685C:  MOVLW  07
0685E:  ANDWF  xBB,W
06860:  BCF    xBB.6
06862:  ADDWF  FE9,F
06864:  MOVLW  BA
06866:  SUBWF  FE9,W
06868:  BTFSC  FD8.2
0686A:  BSF    xBB.6
0686C:  MOVF   FEF,W
0686E:  MOVWF  00
06870:  BNZ   6882
06872:  BTFSC  xBB.6
06874:  BRA    6882
06876:  BTFSC  xBB.4
06878:  BRA    68A6
0687A:  BTFSC  xBB.3
0687C:  BRA    6882
0687E:  MOVLW  20
06880:  BRA    6888
06882:  BSF    xBB.3
06884:  BCF    xBB.4
06886:  MOVLW  30
06888:  ADDWF  00,F
0688A:  MOVFF  FEA,3B5
0688E:  MOVFF  FE9,3B4
06892:  MOVFF  00,3BD
06896:  MOVLB  0
06898:  CALL   2440
0689C:  MOVFF  3B5,FEA
068A0:  MOVFF  3B4,FE9
068A4:  MOVLB  3
068A6:  MOVF   FEE,W
068A8:  BTFSS  xBB.6
068AA:  BRA    6864
068AC:  MOVLB  0
068AE:  RETURN 0
*
06D00:  MOVFF  FF2,0D
06D04:  BCF    FF2.7
06D06:  ADDWF  FE8,W
06D08:  CLRF   FF7
06D0A:  RLCF   FF7,F
06D0C:  ADDLW  25
06D0E:  MOVWF  FF6
06D10:  MOVLW  6D
06D12:  ADDWFC FF7,F
06D14:  TBLRD*-
06D16:  MOVF   FF5,W
06D18:  MOVWF  FFA
06D1A:  TBLRD*
06D1C:  MOVF   FF5,W
06D1E:  BTFSC  0D.7
06D20:  BSF    FF2.7
06D22:  MOVWF  FF9
06D24:  DATA D4,6A
06D26:  DATA 14,6B
06D28:  DATA FC,6C
06D2A:  DATA FC,6C
06D2C:  DATA B4,6C
06D2E:  DATA 40,6B
*
07C9A:  MOVFF  FF2,0D
07C9E:  BCF    FF2.7
07CA0:  ADDWF  FE8,W
07CA2:  CLRF   FF7
07CA4:  RLCF   FF7,F
07CA6:  ADDLW  BF
07CA8:  MOVWF  FF6
07CAA:  MOVLW  7C
07CAC:  ADDWFC FF7,F
07CAE:  TBLRD*-
07CB0:  MOVF   FF5,W
07CB2:  MOVWF  FFA
07CB4:  TBLRD*
07CB6:  MOVF   FF5,W
07CB8:  BTFSC  0D.7
07CBA:  BSF    FF2.7
07CBC:  MOVWF  FF9
07CBE:  DATA 16,72
07CC0:  DATA 46,73
07CC2:  DATA 94,75
07CC4:  DATA AE,78
*
08476:  MOVFF  FF2,0D
0847A:  BCF    FF2.7
0847C:  ADDWF  FE8,W
0847E:  CLRF   FF7
08480:  RLCF   FF7,F
08482:  ADDLW  9B
08484:  MOVWF  FF6
08486:  MOVLW  84
08488:  ADDWFC FF7,F
0848A:  TBLRD*-
0848C:  MOVF   FF5,W
0848E:  MOVWF  FFA
08490:  TBLRD*
08492:  MOVF   FF5,W
08494:  BTFSC  0D.7
08496:  BSF    FF2.7
08498:  MOVWF  FF9
0849A:  DATA 4C,83
0849C:  DATA A6,80
0849E:  DATA 52,82
084A0:  DATA 7C,81
084A2:  DATA 02,81
084A4:  DATA C8,82
084A6:  DATA D8,81
084A8:  DATA 72,84
084AA:  DATA 20,83
084AC:  DATA 72,84
084AE:  DATA 78,83
084B0:  DATA 62,7F
084B2:  DATA 72,84
084B4:  DATA 14,80
084B6:  DATA DA,7C
084B8:  DATA 8C,7D
084BA:  DATA 1E,7E
084BC:  DATA B0,7E
084BE:  DATA 16,84
084C0:  DATA 48,84
*
08F28:  MOVFF  FF2,0D
08F2C:  BCF    FF2.7
08F2E:  ADDWF  FE8,W
08F30:  CLRF   FF7
08F32:  RLCF   FF7,F
08F34:  ADDLW  4D
08F36:  MOVWF  FF6
08F38:  MOVLW  8F
08F3A:  ADDWFC FF7,F
08F3C:  TBLRD*-
08F3E:  MOVF   FF5,W
08F40:  MOVWF  FFA
08F42:  TBLRD*
08F44:  MOVF   FF5,W
08F46:  BTFSC  0D.7
08F48:  BSF    FF2.7
08F4A:  MOVWF  FF9
08F4C:  DATA 1C,8E
08F4E:  DATA 84,8E
08F50:  DATA 24,8F
08F52:  DATA 24,8F
08F54:  DATA F8,8E
08F56:  DATA 08,8F
08F58:  DATA EC,8E
08F5A:  DATA 24,8F
08F5C:  DATA 18,8F
*
090E2:  MOVFF  FF2,0D
090E6:  BCF    FF2.7
090E8:  ADDWF  FE8,W
090EA:  CLRF   FF7
090EC:  RLCF   FF7,F
090EE:  ADDLW  07
090F0:  MOVWF  FF6
090F2:  MOVLW  91
090F4:  ADDWFC FF7,F
090F6:  TBLRD*-
090F8:  MOVF   FF5,W
090FA:  MOVWF  FFA
090FC:  TBLRD*
090FE:  MOVF   FF5,W
09100:  BTFSC  0D.7
09102:  BSF    FF2.7
09104:  MOVWF  FF9
09106:  DATA CC,8F
09108:  DATA 30,90
0910A:  DATA DE,90
0910C:  DATA DE,90
0910E:  DATA B2,90
09110:  DATA C2,90
09112:  DATA 98,90
09114:  DATA A4,90
09116:  DATA D2,90
*
0934E:  MOVFF  FF2,0D
09352:  BCF    FF2.7
09354:  ADDWF  FE8,W
09356:  CLRF   FF7
09358:  RLCF   FF7,F
0935A:  ADDLW  73
0935C:  MOVWF  FF6
0935E:  MOVLW  93
09360:  ADDWFC FF7,F
09362:  TBLRD*-
09364:  MOVF   FF5,W
09366:  MOVWF  FFA
09368:  TBLRD*
0936A:  MOVF   FF5,W
0936C:  BTFSC  0D.7
0936E:  BSF    FF2.7
09370:  MOVWF  FF9
09372:  DATA 0A,92
09374:  DATA 88,92
09376:  DATA 4A,93
09378:  DATA 4A,93
0937A:  DATA 1E,93
0937C:  DATA 2E,93
0937E:  DATA 06,93
09380:  DATA 12,93
09382:  DATA 3E,93
*
0958C:  MOVFF  FF2,0D
09590:  BCF    FF2.7
09592:  ADDWF  FE8,W
09594:  CLRF   FF7
09596:  RLCF   FF7,F
09598:  ADDLW  B1
0959A:  MOVWF  FF6
0959C:  MOVLW  95
0959E:  ADDWFC FF7,F
095A0:  TBLRD*-
095A2:  MOVF   FF5,W
095A4:  MOVWF  FFA
095A6:  TBLRD*
095A8:  MOVF   FF5,W
095AA:  BTFSC  0D.7
095AC:  BSF    FF2.7
095AE:  MOVWF  FF9
095B0:  DATA 60,95
095B2:  DATA 88,95
095B4:  DATA 88,95
095B6:  DATA 88,95
095B8:  DATA 88,95
095BA:  DATA 88,95
095BC:  DATA 88,95
095BE:  DATA 88,95
095C0:  DATA 44,95
095C2:  DATA 88,95
095C4:  DATA 88,95
095C6:  DATA B2,94
095C8:  DATA 88,95
095CA:  DATA F8,94
095CC:  DATA 96,93
095CE:  DATA E0,93
095D0:  DATA 24,94
095D2:  DATA 68,94
095D4:  DATA 78,95
*
0A25E:  MOVFF  FF2,0D
0A262:  BCF    FF2.7
0A264:  ADDWF  FE8,W
0A266:  CLRF   FF7
0A268:  RLCF   FF7,F
0A26A:  ADDLW  83
0A26C:  MOVWF  FF6
0A26E:  MOVLW  A2
0A270:  ADDWFC FF7,F
0A272:  TBLRD*-
0A274:  MOVF   FF5,W
0A276:  MOVWF  FFA
0A278:  TBLRD*
0A27A:  MOVF   FF5,W
0A27C:  BTFSC  0D.7
0A27E:  BSF    FF2.7
0A280:  MOVWF  FF9
0A282:  DATA 08,97
0A284:  DATA 76,98
0A286:  DATA 1A,9B
0A288:  DATA 72,9E
*
0A624:  MOVFF  FF2,0D
0A628:  BCF    FF2.7
0A62A:  ADDWF  FE8,W
0A62C:  CLRF   FF7
0A62E:  RLCF   FF7,F
0A630:  ADDLW  49
0A632:  MOVWF  FF6
0A634:  MOVLW  A6
0A636:  ADDWFC FF7,F
0A638:  TBLRD*-
0A63A:  MOVF   FF5,W
0A63C:  MOVWF  FFA
0A63E:  TBLRD*
0A640:  MOVF   FF5,W
0A642:  BTFSC  0D.7
0A644:  BSF    FF2.7
0A646:  MOVWF  FF9
0A648:  DATA 84,A3
0A64A:  DATA 9C,A3
0A64C:  DATA 0A,A4
0A64E:  DATA 74,A4
0A650:  DATA 94,A4
0A652:  DATA B4,A4
0A654:  DATA FC,A4
0A656:  DATA 1C,A5
0A658:  DATA 3C,A5
0A65A:  DATA 56,A5
0A65C:  DATA 76,A5
0A65E:  DATA A4,A5
0A660:  DATA D2,A5
0A662:  DATA F2,A5
*
0A9FC:  MOVFF  FF2,0D
0AA00:  BCF    FF2.7
0AA02:  ADDWF  FE8,W
0AA04:  CLRF   FF7
0AA06:  RLCF   FF7,F
0AA08:  ADDLW  21
0AA0A:  MOVWF  FF6
0AA0C:  MOVLW  AA
0AA0E:  ADDWFC FF7,F
0AA10:  TBLRD*-
0AA12:  MOVF   FF5,W
0AA14:  MOVWF  FFA
0AA16:  TBLRD*
0AA18:  MOVF   FF5,W
0AA1A:  BTFSC  0D.7
0AA1C:  BSF    FF2.7
0AA1E:  MOVWF  FF9
0AA20:  DATA 66,A9
0AA22:  DATA 6E,A9
0AA24:  DATA 86,A9
0AA26:  DATA AE,A9
0AA28:  DATA B6,A9
0AA2A:  DATA BE,A9
0AA2C:  DATA C6,A9
0AA2E:  DATA 76,A9
0AA30:  DATA CE,A9
0AA32:  DATA D6,A9
0AA34:  DATA DE,A9
0AA36:  DATA E6,A9
0AA38:  DATA EE,A9
0AA3A:  DATA 7E,A9
0AA3C:  DATA A6,A9
0AA3E:  DATA 96,A9
0AA40:  DATA 9E,A9
0AA42:  DATA 8E,A9
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "main.h" 
.................... #fuses HS,NOWDT,PROTECT,NOLVP,NODEBUG,MCLR 
.................... #use delay(clock=20000000) 
*
0206E:  MOVLW  03
02070:  MOVWF  FEA
02072:  MOVLW  BE
02074:  MOVWF  FE9
02076:  MOVF   FEF,W
02078:  BZ    2094
0207A:  MOVLW  06
0207C:  MOVWF  01
0207E:  CLRF   00
02080:  DECFSZ 00,F
02082:  BRA    2080
02084:  DECFSZ 01,F
02086:  BRA    207E
02088:  MOVLW  7B
0208A:  MOVWF  00
0208C:  DECFSZ 00,F
0208E:  BRA    208C
02090:  DECFSZ FEF,F
02092:  BRA    207A
02094:  RETURN 0
.................... #use i2c(master,sda = pin_C4,scl = pin_C3,force_hw) 
*
0201C:  BCF    FC6.7
0201E:  BCF    F9E.3
02020:  MOVFF  3C6,FC9
02024:  MOVLW  02
02026:  BTFSC  FC6.7
02028:  BRA    2034
0202A:  BTFSS  F9E.3
0202C:  BRA    202A
0202E:  MOVLW  00
02030:  BTFSC  FC5.6
02032:  MOVLW  01
02034:  MOVWF  01
02036:  RETURN 0
*
0231A:  BCF    FC6.6
0231C:  BSF    FC5.3
0231E:  BTFSC  FC5.3
02320:  BRA    231E
02322:  BTFSC  00.0
02324:  BCF    FC5.5
02326:  BTFSS  00.0
02328:  BSF    FC5.5
0232A:  BSF    FC5.4
0232C:  BTFSC  FC5.4
0232E:  BRA    232C
02330:  MOVFF  FC9,01
02334:  RETURN 0
....................  
.................... #use 		standard_io(a) 
.................... #use 		standard_io(b) 
.................... #use 		standard_io(c) 
.................... #use 		standard_io(d) 
.................... #use 		standard_io(e) 
....................  
....................  
.................... #DEFINE   	RS    pin_B5			 
.................... #DEFINE	  	E	  pin_A0 
....................  
....................  
.................... #DEFINE		EEPROM_SCL	    	pin_C3 
.................... #DEFINE 	EEPROM_SDA		    pin_C4 
....................  
....................  
.................... #DEFINE     in24_bit			pin_B0 
.................... #DEFINE     in25_bit			pin_B1 
.................... #DEFINE     in26_bit			pin_B3 
.................... #DEFINE     in27_bit			pin_B4 
....................  
.................... #DEFINE     H0					pin_D7 
.................... #DEFINE     H1					pin_D6 
.................... #DEFINE     H2					pin_D5 
.................... #DEFINE     H3					pin_D4 
.................... #DEFINE     H4					pin_C7	 
.................... #DEFINE     H5					pin_C6 
....................  
.................... #DEFINE ALIMENTADOR        0 // 000          
.................... #DEFINE HOME1              1 // 001 
.................... #DEFINE SOLDAGEM           3 // 010 
.................... #DEFINE HOME2              4 // 011 
.................... #DEFINE DISPENSADOR        5 // 100 
.................... #DEFINE LIMPEZA            6 // 101 
.................... #DEFINE LIMPEZA_2          7 // 110 
.................... #DEFINE POSICAO_8          8 // 111 
....................  
.................... #define ramp_idle 0 
.................... #define ramp_up   1 
.................... #define ramp_max  2 
.................... #define ramp_down 3 
.................... #define ramp_last 4 
....................  
.................... #DEFINE velocidade_motor        2000 
.................... #DEFINE     LED                 0 
.................... #DEFINE     PONTO               1 
.................... #DEFINE     MOLA                2 
....................  
.................... int menu_atual = 0; 
.................... short int entradas[27]; 
....................  
.................... int ponteiro_lcd = 1; 
.................... int inicial_lcd = 0; 
.................... int final_lcd = 3; 
.................... int contador_lcd = 0; 
....................  
.................... int posicao_atual; 
.................... int posicao_futura; 
.................... int posicao_outra_maquina; 
.................... int32 ciclo; 
.................... short run_ok = 1; 
.................... short exit = 1; 
.................... short prioridade = TRUE; 
....................  
.................... void grava_coordenada_na_eeprom(int passo,long int coordenada_x,long int coordenada_y,long int coordenada_z); 
.................... void pega_data_eeprom(int passo); 
....................  
.................... int modelo = 1; 
.................... long int x[20]; 
.................... long int y[20]; 
.................... long int z[20]; 
.................... long int t_solda[20]; 
.................... long int t_wait[20]; 
.................... int tipo[20]; 
.................... int pontos_no_modelo; 
.................... short int habilitado[20]; 
....................  
.................... #include "pcf8574.c" 
.................... short int ack; 
.................... int	lcdcoluna = 1; 
.................... int	lcdlinha  = 1; 
....................  
.................... void escreve_pcf8574(int dispositivo,int data) { 
....................    i2c_start(); 
*
02038:  BSF    FC5.0
0203A:  BTFSC  FC5.0
0203C:  BRA    203A
....................    ack=i2c_write(0x40 |(dispositivo << 1)); 
0203E:  BCF    FD8.0
02040:  MOVLB  3
02042:  RLCF   xC3,W
02044:  IORLW  40
02046:  MOVWF  xC5
02048:  MOVWF  xC6
0204A:  MOVLB  0
0204C:  RCALL  201C
0204E:  MOVF   01,W
02050:  BCF    2C.3
02052:  BTFSC  01.0
02054:  BSF    2C.3
....................    ack=i2c_write(data); 
02056:  MOVFF  3C4,3C6
0205A:  RCALL  201C
0205C:  MOVF   01,W
0205E:  BCF    2C.3
02060:  BTFSC  01.0
02062:  BSF    2C.3
....................    i2c_stop(); 
02064:  BSF    FC5.2
02066:  BTFSC  FC5.2
02068:  BRA    2066
....................    ack=!ack; 
0206A:  BTG    2C.3
0206C:  RETURN 0
.................... } 
....................  
.................... int le_pcf8574(int dispositivo) { 
....................     int data; 
....................     i2c_start(); 
....................     i2c_write(0x41 |(dispositivo << 1)); 
....................     data=i2c_read(0); 
....................     i2c_stop(); 
....................     ack=!ack; 
....................     return(data); 
.................... } 
....................  
.................... int le_pcf8574A(int dispositivo) { 
....................     int data; 
....................     i2c_start(); 
*
04064:  BSF    FC5.0
04066:  BTFSC  FC5.0
04068:  BRA    4066
....................     i2c_write(0x71 |(dispositivo << 1)); 
0406A:  BCF    FD8.0
0406C:  MOVLB  3
0406E:  RLCF   xB7,W
04070:  IORLW  71
04072:  MOVWF  xB9
04074:  MOVWF  xC6
04076:  MOVLB  0
04078:  CALL   201C
....................     data=i2c_read(0); 
0407C:  CLRF   00
0407E:  CALL   231A
04082:  MOVFF  01,3B8
....................     i2c_stop(); 
04086:  BSF    FC5.2
04088:  BTFSC  FC5.2
0408A:  BRA    4088
....................     ack=!ack; 
0408C:  BTG    2C.3
.................... 	return(data); 
0408E:  MOVLB  3
04090:  MOVFF  3B8,01
04094:  MOVLB  0
04096:  GOTO   4130 (RETURN)
.................... } 
....................  
....................  
.................... #include "pca9555.c" 
.................... void escreve_PCA9555(int dispositivo,int comando,int data1,int data2) { 
....................    i2c_start(); 
*
02146:  BSF    FC5.0
02148:  BTFSC  FC5.0
0214A:  BRA    2148
....................    ack=i2c_write(0x40 |(dispositivo << 1)); 
0214C:  BCF    FD8.0
0214E:  MOVLB  3
02150:  RLCF   xBB,W
02152:  IORLW  40
02154:  MOVWF  xBF
02156:  MOVWF  xC6
02158:  MOVLB  0
0215A:  RCALL  201C
0215C:  MOVF   01,W
0215E:  BCF    2C.3
02160:  BTFSC  01.0
02162:  BSF    2C.3
....................    ack=i2c_write(comando); 
02164:  MOVFF  3BC,3C6
02168:  RCALL  201C
0216A:  MOVF   01,W
0216C:  BCF    2C.3
0216E:  BTFSC  01.0
02170:  BSF    2C.3
....................    ack=i2c_write(data2); 
02172:  MOVFF  3BE,3C6
02176:  RCALL  201C
02178:  MOVF   01,W
0217A:  BCF    2C.3
0217C:  BTFSC  01.0
0217E:  BSF    2C.3
....................    ack=i2c_write(data1); 
02180:  MOVFF  3BD,3C6
02184:  RCALL  201C
02186:  MOVF   01,W
02188:  BCF    2C.3
0218A:  BTFSC  01.0
0218C:  BSF    2C.3
....................    i2c_stop(); 
0218E:  BSF    FC5.2
02190:  BTFSC  FC5.2
02192:  BRA    2190
....................    ack=!ack; 
02194:  BTG    2C.3
02196:  RETURN 0
.................... }   
....................  
.................... unsigned long  int le_PCA9555(int dispositivo,int comando) {     
*
03FDC:  MOVLB  3
03FDE:  CLRF   xBB
03FE0:  CLRF   xBA
03FE2:  CLRF   xBC
....................    unsigned long int data1 = 0x0000;  
....................    int data2= 0x00; 
....................    i2c_start(); 	 
03FE4:  BSF    FC5.0
03FE6:  BTFSC  FC5.0
03FE8:  BRA    3FE6
....................    ack=i2c_write(0x40 |(dispositivo << 1));  
03FEA:  BCF    FD8.0
03FEC:  RLCF   xB8,W
03FEE:  IORLW  40
03FF0:  MOVWF  xBD
03FF2:  MOVWF  xC6
03FF4:  MOVLB  0
03FF6:  CALL   201C
03FFA:  MOVF   01,W
03FFC:  BCF    2C.3
03FFE:  BTFSC  01.0
04000:  BSF    2C.3
....................    ack=i2c_write(comando); 
04002:  MOVFF  3B9,3C6
04006:  CALL   201C
0400A:  MOVF   01,W
0400C:  BCF    2C.3
0400E:  BTFSC  01.0
04010:  BSF    2C.3
....................    i2c_start(); 
04012:  BSF    FC5.1
04014:  BTFSC  FC5.1
04016:  BRA    4014
....................    ack=i2c_write(0x41 |(dispositivo << 1)); 
04018:  BCF    FD8.0
0401A:  MOVLB  3
0401C:  RLCF   xB8,W
0401E:  IORLW  41
04020:  MOVWF  xBD
04022:  MOVWF  xC6
04024:  MOVLB  0
04026:  CALL   201C
0402A:  MOVF   01,W
0402C:  BCF    2C.3
0402E:  BTFSC  01.0
04030:  BSF    2C.3
....................    data2=i2c_read(1);            // acknoledgment 
04032:  MOVLW  01
04034:  MOVWF  00
04036:  CALL   231A
0403A:  MOVFF  01,3BC
....................    data1=i2c_read(0) << 8;      // no  acknoledgment 
0403E:  CLRF   00
04040:  CALL   231A
04044:  MOVFF  01,3BB
04048:  MOVLB  3
0404A:  CLRF   xBA
....................    i2c_stop(); 
0404C:  BSF    FC5.2
0404E:  BTFSC  FC5.2
04050:  BRA    404E
....................    ack=!ack; 
04052:  BTG    2C.3
....................    data1|=data2; 
04054:  MOVF   xBC,W
04056:  IORWF  xBA,F
....................    return(data1); 
04058:  MOVFF  3BA,01
0405C:  MOVFF  3BB,02
04060:  MOVLB  0
04062:  RETURN 0
.................... }     
....................  
.................... #include "display_maq.c"  
.................... void write (char dado){ 
.................... 	delay_us(30); 
*
02096:  MOVLW  31
02098:  MOVWF  00
0209A:  DECFSZ 00,F
0209C:  BRA    209A
0209E:  BRA    20A0
.................... 	escreve_pcf8574(0x00,dado); 
020A0:  MOVLB  3
020A2:  CLRF   xC3
020A4:  MOVFF  3C2,3C4
020A8:  MOVLB  0
020AA:  RCALL  2038
.................... 	delay_us(30); 
020AC:  MOVLW  31
020AE:  MOVWF  00
020B0:  DECFSZ 00,F
020B2:  BRA    20B0
020B4:  BRA    20B6
.................... 	output_high (E); 
020B6:  BCF    F92.0
020B8:  BSF    F89.0
.................... 	delay_us(30); 
020BA:  MOVLW  31
020BC:  MOVWF  00
020BE:  DECFSZ 00,F
020C0:  BRA    20BE
020C2:  BRA    20C4
.................... 	output_low  (E) ; 
020C4:  BCF    F92.0
020C6:  BCF    F89.0
.................... 	delay_us(30); 
020C8:  MOVLW  31
020CA:  MOVWF  00
020CC:  DECFSZ 00,F
020CE:  BRA    20CC
020D0:  BRA    20D2
020D2:  RETURN 0
.................... } 
.................... void displayprog (int valor) { 
.................... 	output_low (RS); 
020D4:  BCF    F93.5
020D6:  BCF    F8A.5
.................... 	write (valor); 
020D8:  MOVFF  3C1,3C2
020DC:  RCALL  2096
020DE:  RETURN 0
.................... } 
.................... void limpa_display (void){ 
....................  	displayprog (0x1); 
*
02284:  MOVLW  01
02286:  MOVLB  3
02288:  MOVWF  xC1
0228A:  MOVLB  0
0228C:  RCALL  20D4
.................... 	delay_ms(5); 
0228E:  MOVLW  05
02290:  MOVLB  3
02292:  MOVWF  xBE
02294:  MOVLB  0
02296:  RCALL  206E
02298:  RETURN 0
.................... } 
.................... void inicializa_display(void){ 
....................     escreve_pcf8574(0x00,0Xff); //;output_b(0xff);				//	porta_display (0XFF); 
*
020E0:  MOVLB  3
020E2:  CLRF   xC3
020E4:  SETF   xC4
020E6:  MOVLB  0
020E8:  RCALL  2038
.................... 	output_low(E); 
020EA:  BCF    F92.0
020EC:  BCF    F89.0
.................... 	output_high(RS); 
020EE:  BCF    F93.5
020F0:  BSF    F8A.5
.................... 	delay_ms(15); 
020F2:  MOVLW  0F
020F4:  MOVLB  3
020F6:  MOVWF  xBE
020F8:  MOVLB  0
020FA:  RCALL  206E
.................... 	displayprog(0x38);      // 2 linha / 5x7 /8 bit 
020FC:  MOVLW  38
020FE:  MOVLB  3
02100:  MOVWF  xC1
02102:  MOVLB  0
02104:  RCALL  20D4
.................... 	delay_ms(15); 
02106:  MOVLW  0F
02108:  MOVLB  3
0210A:  MOVWF  xBE
0210C:  MOVLB  0
0210E:  RCALL  206E
.................... 	displayprog(0x0c);		// display aceso s/ cursor 
02110:  MOVLW  0C
02112:  MOVLB  3
02114:  MOVWF  xC1
02116:  MOVLB  0
02118:  RCALL  20D4
.................... 	delay_ms(15); 
0211A:  MOVLW  0F
0211C:  MOVLB  3
0211E:  MOVWF  xBE
02120:  MOVLB  0
02122:  RCALL  206E
.................... 	displayprog(0x06);      // escreve deslocando o cursor para direita 
02124:  MOVLW  06
02126:  MOVLB  3
02128:  MOVWF  xC1
0212A:  MOVLB  0
0212C:  RCALL  20D4
.................... 	delay_ms(15); 
0212E:  MOVLW  0F
02130:  MOVLB  3
02132:  MOVWF  xBE
02134:  MOVLB  0
02136:  RCALL  206E
.................... 	lcdcoluna = 1; 
02138:  MOVLW  01
0213A:  MOVLB  1
0213C:  MOVWF  x0E
.................... 	lcdlinha = 1; 
0213E:  MOVWF  x0F
02140:  MOVLB  0
02142:  GOTO   A8D2 (RETURN)
.................... } 
.................... void posiciona_cursor (int linha,int coluna){ 
.................... 	lcdcoluna = coluna; 
*
0229A:  MOVFF  3BF,10E
.................... 	lcdlinha  = linha; 
0229E:  MOVFF  3BE,10F
.................... 	int	x; 
.................... 	if (linha == 1)	x=(0x00 + coluna) - 1; 
022A2:  MOVLB  3
022A4:  DECFSZ xBE,W
022A6:  BRA    22AE
022A8:  MOVLW  01
022AA:  SUBWF  xBF,W
022AC:  MOVWF  xC0
.................... 	if (linha == 2) x=(0x40 + coluna) - 1;  
022AE:  MOVF   xBE,W
022B0:  SUBLW  02
022B2:  BNZ   22BC
022B4:  MOVLW  40
022B6:  ADDWF  xBF,W
022B8:  ADDLW  FF
022BA:  MOVWF  xC0
....................     if (linha == 3) x=(0x14 + coluna) - 1; 
022BC:  MOVF   xBE,W
022BE:  SUBLW  03
022C0:  BNZ   22CA
022C2:  MOVLW  14
022C4:  ADDWF  xBF,W
022C6:  ADDLW  FF
022C8:  MOVWF  xC0
.................... 	if (linha == 4) x=(0x54 + coluna) - 1; 
022CA:  MOVF   xBE,W
022CC:  SUBLW  04
022CE:  BNZ   22D8
022D0:  MOVLW  54
022D2:  ADDWF  xBF,W
022D4:  ADDLW  FF
022D6:  MOVWF  xC0
.................... 	x =x | 0x80; 
022D8:  BSF    xC0.7
.................... 	displayprog (x); 
022DA:  MOVFF  3C0,3C1
022DE:  MOVLB  0
022E0:  RCALL  20D4
.................... 	delay_us(100); 
022E2:  MOVLW  A6
022E4:  MOVWF  00
022E6:  DECFSZ 00,F
022E8:  BRA    22E6
022EA:  NOP   
022EC:  RETURN 0
.................... } 
.................... void display (char  c){ 
.................... 	output_high (RS); 
022EE:  BCF    F93.5
022F0:  BSF    F8A.5
.................... 	write (c); 
022F2:  MOVFF  3BE,3C2
022F6:  RCALL  2096
022F8:  RETURN 0
.................... } 
.................... void lcd_putc(char c) { 
.................... 	// \n nova linha muda o cursor para uma linha abaixo 
....................     // \r retorno 
....................     // \f limpa display 
....................  
....................  
....................    switch (c) { 
*
02440:  MOVLB  3
02442:  MOVF   xBD,W
02444:  XORLW  0C
02446:  MOVLB  0
02448:  BZ    2454
0244A:  XORLW  06
0244C:  BZ    2460
0244E:  XORLW  07
02450:  BZ    2474
02452:  BRA    2488
....................      case '\f'   : limpa_display(); 
02454:  RCALL  2284
....................                    lcdlinha = 1; 
02456:  MOVLW  01
02458:  MOVLB  1
0245A:  MOVWF  x0F
.................... 				   lcdcoluna= 1; 
0245C:  MOVWF  x0E
....................                    break; 
0245E:  BRA    2490
....................  
....................      case '\n'   : posiciona_cursor(++lcdlinha,lcdcoluna);  
02460:  MOVLB  1
02462:  INCF   x0F,F
02464:  MOVFF  10F,3BE
02468:  MOVFF  10E,3BF
0246C:  MOVLB  0
0246E:  RCALL  229A
.................... 			       break; 
02470:  MOVLB  1
02472:  BRA    2490
....................  
....................      case '\r'   : posiciona_cursor(lcdlinha,1);  
02474:  MOVFF  10F,3BE
02478:  MOVLW  01
0247A:  MOVLB  3
0247C:  MOVWF  xBF
0247E:  MOVLB  0
02480:  RCALL  229A
....................                    break; 
02482:  MOVLB  1
02484:  BRA    2490
02486:  MOVLB  0
....................  
....................      default     : display(c);   
02488:  MOVFF  3BD,3BE
0248C:  RCALL  22EE
....................                    break; 
0248E:  MOVLB  1
....................    } 
02490:  MOVLB  0
02492:  RETURN 0
.................... } 
.................... void Show_String(char matriz[]) { 
.................... 	int result; 
.................... 	int	a; 
.................... 	char x1[21]; 
.................... 	strcpy (x1,matriz); 
.................... 	result = strlen(x1); 
.................... 	for (a=0;a < result;a++){ 
....................         display(x1[a]); 
....................     } 
.................... } 
....................  
.................... #include "24c64.c" 
.................... void write_ext_eeprom(long int address,int data) { 
....................  
....................    disable_interrupts(GLOBAL); 
*
02218:  BCF    FF2.6
0221A:  BCF    FF2.7
0221C:  BTFSC  FF2.7
0221E:  BRA    221A
....................    i2c_start(); 
02220:  BSF    FC5.0
02222:  BTFSC  FC5.0
02224:  BRA    2222
....................    ack=i2c_write(0xa0); 
02226:  MOVLW  A0
02228:  MOVLB  3
0222A:  MOVWF  xC6
0222C:  MOVLB  0
0222E:  RCALL  201C
02230:  MOVF   01,W
02232:  BCF    2C.3
02234:  BTFSC  01.0
02236:  BSF    2C.3
....................    ack=i2c_write(address >> 8); 
02238:  MOVFF  3B6,3B8
0223C:  MOVLB  3
0223E:  CLRF   xB9
02240:  MOVFF  3B6,3C6
02244:  MOVLB  0
02246:  RCALL  201C
02248:  MOVF   01,W
0224A:  BCF    2C.3
0224C:  BTFSC  01.0
0224E:  BSF    2C.3
....................    ack=i2c_write(address); 
02250:  MOVFF  3B5,3C6
02254:  RCALL  201C
02256:  MOVF   01,W
02258:  BCF    2C.3
0225A:  BTFSC  01.0
0225C:  BSF    2C.3
....................    ack=i2c_write(data); 
0225E:  MOVFF  3B7,3C6
02262:  RCALL  201C
02264:  MOVF   01,W
02266:  BCF    2C.3
02268:  BTFSC  01.0
0226A:  BSF    2C.3
....................    i2c_stop(); 
0226C:  BSF    FC5.2
0226E:  BTFSC  FC5.2
02270:  BRA    226E
....................    ack=!ack; 
02272:  BTG    2C.3
....................    delay_ms(5); 
02274:  MOVLW  05
02276:  MOVLB  3
02278:  MOVWF  xBE
0227A:  MOVLB  0
0227C:  RCALL  206E
....................    enable_interrupts(GLOBAL); 
0227E:  MOVLW  C0
02280:  IORWF  FF2,F
02282:  RETURN 0
....................  
.................... } 
.................... int read_ext_eeprom(long int address) { 
....................    int data; 
....................  
....................    disable_interrupts(GLOBAL); 
*
02336:  BCF    FF2.6
02338:  BCF    FF2.7
0233A:  BTFSC  FF2.7
0233C:  BRA    2338
....................    i2c_start(); 
0233E:  BSF    FC5.0
02340:  BTFSC  FC5.0
02342:  BRA    2340
....................    i2c_write(0xa0); 
02344:  MOVLW  A0
02346:  MOVLB  3
02348:  MOVWF  xC6
0234A:  MOVLB  0
0234C:  RCALL  201C
....................    i2c_write(address >> 8); 
0234E:  MOVFF  3B8,3BA
02352:  MOVLB  3
02354:  CLRF   xBB
02356:  MOVFF  3B8,3C6
0235A:  MOVLB  0
0235C:  RCALL  201C
....................    i2c_write(address); 
0235E:  MOVFF  3B7,3C6
02362:  RCALL  201C
....................    i2c_start(); 
02364:  BSF    FC5.1
02366:  BTFSC  FC5.1
02368:  BRA    2366
....................    i2c_write(0xa1); 
0236A:  MOVLW  A1
0236C:  MOVLB  3
0236E:  MOVWF  xC6
02370:  MOVLB  0
02372:  RCALL  201C
....................    data=i2c_read(0); 
02374:  CLRF   00
02376:  RCALL  231A
02378:  MOVFF  01,3B9
....................    i2c_stop(); 
0237C:  BSF    FC5.2
0237E:  BTFSC  FC5.2
02380:  BRA    237E
....................    ack=!ack; 
02382:  BTG    2C.3
....................    delay_ms(5); 
02384:  MOVLW  05
02386:  MOVLB  3
02388:  MOVWF  xBE
0238A:  MOVLB  0
0238C:  RCALL  206E
....................    enable_interrupts(GLOBAL); 
0238E:  MOVLW  C0
02390:  IORWF  FF2,F
....................  
....................    return(data); 
02392:  MOVLB  3
02394:  MOVFF  3B9,01
02398:  MOVLB  0
0239A:  RETURN 0
....................  
.................... } 
.................... void init_ext_eeprom() { 
.................... 	int a; 
....................  
....................     output_float(EEPROM_SCL); 
0239C:  BSF    F94.3
....................     output_float(EEPROM_SDA); 
0239E:  BSF    F94.4
....................  
.................... 	write_ext_eeprom(0x00ff,0xAA); 
023A0:  MOVLB  3
023A2:  CLRF   xB6
023A4:  SETF   xB5
023A6:  MOVLW  AA
023A8:  MOVWF  xB7
023AA:  MOVLB  0
023AC:  RCALL  2218
.................... 	if (ack == false) 
023AE:  BTFSC  2C.3
023B0:  BRA    23E4
.................... 	{ 
.................... 	limpa_display(); 
023B2:  RCALL  2284
.................... 	posiciona_cursor(1,1); 
023B4:  MOVLW  01
023B6:  MOVLB  3
023B8:  MOVWF  xBE
023BA:  MOVWF  xBF
023BC:  MOVLB  0
023BE:  RCALL  229A
.................... 	display("erro de escrita "); 
023C0:  MOVLW  BA
023C2:  MOVWF  FF6
023C4:  MOVLW  00
023C6:  MOVWF  FF7
023C8:  RCALL  22FA
.................... 	posiciona_cursor(2,1); 
023CA:  MOVLW  02
023CC:  MOVLB  3
023CE:  MOVWF  xBE
023D0:  MOVLW  01
023D2:  MOVWF  xBF
023D4:  MOVLB  0
023D6:  RCALL  229A
.................... 	display("   EEPROM       "); 
023D8:  MOVLW  CC
023DA:  MOVWF  FF6
023DC:  MOVLW  00
023DE:  MOVWF  FF7
023E0:  RCALL  22FA
.................... 	while(true){} 
023E2:  BRA    23E2
.................... 	} 
.................... 	 
.................... 	delay_ms(5);	 
023E4:  MOVLW  05
023E6:  MOVLB  3
023E8:  MOVWF  xBE
023EA:  MOVLB  0
023EC:  RCALL  206E
....................  
.................... 	a = read_ext_eeprom(0x00ff); 
023EE:  MOVLB  3
023F0:  CLRF   xB8
023F2:  SETF   xB7
023F4:  MOVLB  0
023F6:  RCALL  2336
023F8:  MOVFF  01,3AD
.................... 	if (a != 0xAA) 
023FC:  MOVLB  3
023FE:  MOVF   xAD,W
02400:  SUBLW  AA
02402:  BZ    243A
.................... 	{ 
.................... 	limpa_display(); 
02404:  MOVLB  0
02406:  RCALL  2284
.................... 	posiciona_cursor(1,1); 
02408:  MOVLW  01
0240A:  MOVLB  3
0240C:  MOVWF  xBE
0240E:  MOVWF  xBF
02410:  MOVLB  0
02412:  RCALL  229A
.................... 	display("erro de leitura  "); 
02414:  MOVLW  DE
02416:  MOVWF  FF6
02418:  MOVLW  00
0241A:  MOVWF  FF7
0241C:  RCALL  22FA
.................... 	posiciona_cursor(2,1); 
0241E:  MOVLW  02
02420:  MOVLB  3
02422:  MOVWF  xBE
02424:  MOVLW  01
02426:  MOVWF  xBF
02428:  MOVLB  0
0242A:  RCALL  229A
.................... 	display("     EEPROM      "); 
0242C:  MOVLW  F0
0242E:  MOVWF  FF6
02430:  MOVLW  00
02432:  MOVWF  FF7
02434:  RCALL  22FA
.................... 	while(true){} 
02436:  BRA    2436
02438:  MOVLB  3
.................... 	} 
0243A:  MOVLB  0
0243C:  GOTO   A8E6 (RETURN)
....................  
....................  
....................      
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
.................... #include "teclado_21_teclas.c" 
.................... #define		F1					10 
.................... #define		F2					11 
.................... #define     F3					12 
.................... #define		F4					13 
.................... #define     SETA_SUPERIOR   	14 
.................... #define     SETA_INFERIOR   	15  
.................... #define		SETA_DIREITA    	16  
.................... #define     SETA_ESQUERDA  	    17 
.................... #define     ESC					18 
.................... #define     ENTER				19	 
.................... #define     MENU				20 
....................  
.................... void Init_Keyboard(void){ 
.................... 	escreve_PCA9555(0X01,0X06,0Xff,0xf8);// programa bit 0,bit 1,bit 2  como saida e os demais como entrada 
*
02198:  MOVLW  01
0219A:  MOVLB  3
0219C:  MOVWF  xBB
0219E:  MOVLW  06
021A0:  MOVWF  xBC
021A2:  SETF   xBD
021A4:  MOVLW  F8
021A6:  MOVWF  xBE
021A8:  MOVLB  0
021AA:  RCALL  2146
....................  	escreve_PCA9555(0X01,0X02,0X00,0X07);//coloca colunas em  high level 
021AC:  MOVLW  01
021AE:  MOVLB  3
021B0:  MOVWF  xBB
021B2:  MOVLW  02
021B4:  MOVWF  xBC
021B6:  CLRF   xBD
021B8:  MOVLW  07
021BA:  MOVWF  xBE
021BC:  MOVLB  0
021BE:  RCALL  2146
021C0:  GOTO   A8D6 (RETURN)
.................... } 
.................... unsigned long int  Get_Key(void){	 
*
04FC8:  MOVLB  3
04FCA:  CLRF   xB3
04FCC:  CLRF   xB2
04FCE:  MOVLW  06
04FD0:  MOVWF  xB4
04FD2:  MOVLW  7F
04FD4:  MOVWF  xB5
.................... 	long int dado = 0x0000; 
.................... 	int    coluna = 0x06; 
....................     int    mascara = 0x7f; 
.................... 	long int i; 
.................... 	for (i = 0 ; i < 3 ; i++) { 
04FD6:  CLRF   xB7
04FD8:  CLRF   xB6
04FDA:  MOVF   xB7,F
04FDC:  BNZ   5050
04FDE:  MOVF   xB6,W
04FE0:  SUBLW  02
04FE2:  BNC   5050
....................     	coluna -= i; 
04FE4:  MOVF   xB6,W
04FE6:  SUBWF  xB4,F
.................... 		escreve_PCA9555(0X01,0X02,0X00,coluna);     // coloca coluna  em  low level 
04FE8:  MOVLW  01
04FEA:  MOVWF  xBB
04FEC:  MOVLW  02
04FEE:  MOVWF  xBC
04FF0:  CLRF   xBD
04FF2:  MOVFF  3B4,3BE
04FF6:  MOVLB  0
04FF8:  CALL   2146
.................... 		dado =  le_PCA9555(0X01,0X00) >> 3;         // desloca bits 
04FFC:  MOVLW  01
04FFE:  MOVLB  3
05000:  MOVWF  xB8
05002:  CLRF   xB9
05004:  MOVLB  0
05006:  CALL   3FDC
0500A:  MOVLB  3
0500C:  RRCF   02,W
0500E:  MOVWF  xB3
05010:  RRCF   01,W
05012:  MOVWF  xB2
05014:  RRCF   xB3,F
05016:  RRCF   xB2,F
05018:  RRCF   xB3,F
0501A:  RRCF   xB2,F
0501C:  MOVLW  1F
0501E:  ANDWF  xB3,F
.................... 		dado &= mascara;  							// mascara bits 
05020:  MOVF   xB5,W
05022:  ANDWF  xB2,F
05024:  CLRF   xB3
....................         dado = 127 - dado;                            
05026:  MOVLW  7F
05028:  BSF    FD8.0
0502A:  SUBFWB xB2,F
0502C:  MOVLW  00
0502E:  SUBFWB xB3,F
.................... 		if(dado != 0) { 
05030:  MOVF   xB2,F
05032:  BNZ   5038
05034:  MOVF   xB3,F
05036:  BZ    5048
....................             i = i << 8; 
05038:  MOVFF  3B6,3B7
0503C:  CLRF   xB6
....................             dado |= i ; 
0503E:  MOVF   xB6,W
05040:  IORWF  xB2,F
05042:  MOVF   xB7,W
05044:  IORWF  xB3,F
....................             break; 
05046:  BRA    5050
.................... 		}		 
05048:  INCF   xB6,F
0504A:  BTFSC  FD8.2
0504C:  INCF   xB7,F
0504E:  BRA    4FDA
.................... 	}		 
....................     return(dado); 
05050:  MOVFF  3B2,01
05054:  MOVFF  3B3,02
05058:  MOVLB  0
0505A:  GOTO   506A (RETURN)
.................... } 
.................... int Teclado(void) { 
0505E:  MOVLB  3
05060:  CLRF   xB0
05062:  CLRF   xAF
05064:  CLRF   xB1
....................  // l o teclado 
....................  // se nenhuma tecla acionada retorna 0xff 
....................  // se acionada retorna o codigo da tecla 
....................    unsigned long int codigo_teclado = 0x0000; 
....................    int key_code = 0x00; 
....................    codigo_teclado = Get_Key(); 
05066:  MOVLB  0
05068:  BRA    4FC8
0506A:  MOVFF  02,3B0
0506E:  MOVFF  01,3AF
....................    if(codigo_teclado == 0x00) return( key_code =0xff);	 
05072:  MOVLB  3
05074:  MOVF   xAF,F
05076:  BNZ   5084
05078:  MOVF   xB0,F
0507A:  BNZ   5084
0507C:  SETF   xB1
0507E:  MOVFF  3B1,01
05082:  BRA    529C
.................... 	switch(codigo_teclado){ 
05084:  MOVF   xAF,W
05086:  MOVWF  00
05088:  MOVF   xB0,W
0508A:  MOVWF  03
0508C:  MOVLW  01
0508E:  SUBWF  03,W
05090:  BNZ   509E
05092:  MOVLW  40
05094:  SUBWF  00,W
05096:  MOVLB  0
05098:  BTFSC  FD8.2
0509A:  BRA    51F2
0509C:  MOVLB  3
0509E:  MOVF   03,W
050A0:  BNZ   50AE
050A2:  MOVLW  08
050A4:  SUBWF  00,W
050A6:  MOVLB  0
050A8:  BTFSC  FD8.2
050AA:  BRA    51F8
050AC:  MOVLB  3
050AE:  MOVLW  01
050B0:  SUBWF  03,W
050B2:  BNZ   50C0
050B4:  MOVLW  08
050B6:  SUBWF  00,W
050B8:  MOVLB  0
050BA:  BTFSC  FD8.2
050BC:  BRA    5200
050BE:  MOVLB  3
050C0:  MOVLW  02
050C2:  SUBWF  03,W
050C4:  BNZ   50D2
050C6:  MOVLW  08
050C8:  SUBWF  00,W
050CA:  MOVLB  0
050CC:  BTFSC  FD8.2
050CE:  BRA    5208
050D0:  MOVLB  3
050D2:  MOVF   03,W
050D4:  BNZ   50E2
050D6:  MOVLW  10
050D8:  SUBWF  00,W
050DA:  MOVLB  0
050DC:  BTFSC  FD8.2
050DE:  BRA    5210
050E0:  MOVLB  3
050E2:  MOVLW  01
050E4:  SUBWF  03,W
050E6:  BNZ   50F4
050E8:  MOVLW  10
050EA:  SUBWF  00,W
050EC:  MOVLB  0
050EE:  BTFSC  FD8.2
050F0:  BRA    5218
050F2:  MOVLB  3
050F4:  MOVLW  02
050F6:  SUBWF  03,W
050F8:  BNZ   5106
050FA:  MOVLW  10
050FC:  SUBWF  00,W
050FE:  MOVLB  0
05100:  BTFSC  FD8.2
05102:  BRA    5220
05104:  MOVLB  3
05106:  MOVF   03,W
05108:  BNZ   5116
0510A:  MOVLW  20
0510C:  SUBWF  00,W
0510E:  MOVLB  0
05110:  BTFSC  FD8.2
05112:  BRA    5228
05114:  MOVLB  3
05116:  MOVLW  01
05118:  SUBWF  03,W
0511A:  BNZ   5128
0511C:  MOVLW  20
0511E:  SUBWF  00,W
05120:  MOVLB  0
05122:  BTFSC  FD8.2
05124:  BRA    5230
05126:  MOVLB  3
05128:  MOVLW  02
0512A:  SUBWF  03,W
0512C:  BNZ   513A
0512E:  MOVLW  20
05130:  SUBWF  00,W
05132:  MOVLB  0
05134:  BTFSC  FD8.2
05136:  BRA    5238
05138:  MOVLB  3
0513A:  MOVF   03,W
0513C:  BNZ   514A
0513E:  MOVLW  01
05140:  SUBWF  00,W
05142:  MOVLB  0
05144:  BTFSC  FD8.2
05146:  BRA    5240
05148:  MOVLB  3
0514A:  MOVLW  02
0514C:  SUBWF  03,W
0514E:  BNZ   515C
05150:  MOVLW  01
05152:  SUBWF  00,W
05154:  MOVLB  0
05156:  BTFSC  FD8.2
05158:  BRA    5248
0515A:  MOVLB  3
0515C:  MOVF   03,W
0515E:  BNZ   516C
05160:  MOVLW  04
05162:  SUBWF  00,W
05164:  MOVLB  0
05166:  BTFSC  FD8.2
05168:  BRA    5250
0516A:  MOVLB  3
0516C:  MOVLW  02
0516E:  SUBWF  03,W
05170:  BNZ   517E
05172:  MOVLW  04
05174:  SUBWF  00,W
05176:  MOVLB  0
05178:  BTFSC  FD8.2
0517A:  BRA    5258
0517C:  MOVLB  3
0517E:  MOVF   03,W
05180:  BNZ   518E
05182:  MOVLW  40
05184:  SUBWF  00,W
05186:  MOVLB  0
05188:  BTFSC  FD8.2
0518A:  BRA    5260
0518C:  MOVLB  3
0518E:  MOVLW  02
05190:  SUBWF  03,W
05192:  BNZ   51A0
05194:  MOVLW  40
05196:  SUBWF  00,W
05198:  MOVLB  0
0519A:  BTFSC  FD8.2
0519C:  BRA    5268
0519E:  MOVLB  3
051A0:  MOVLW  01
051A2:  SUBWF  03,W
051A4:  BNZ   51B2
051A6:  MOVLW  01
051A8:  SUBWF  00,W
051AA:  MOVLB  0
051AC:  BTFSC  FD8.2
051AE:  BRA    5270
051B0:  MOVLB  3
051B2:  MOVF   03,W
051B4:  BNZ   51C0
051B6:  MOVLW  02
051B8:  SUBWF  00,W
051BA:  MOVLB  0
051BC:  BZ    5278
051BE:  MOVLB  3
051C0:  MOVLW  02
051C2:  SUBWF  03,W
051C4:  BNZ   51D0
051C6:  MOVLW  02
051C8:  SUBWF  00,W
051CA:  MOVLB  0
051CC:  BZ    5280
051CE:  MOVLB  3
051D0:  MOVLW  01
051D2:  SUBWF  03,W
051D4:  BNZ   51E0
051D6:  MOVLW  04
051D8:  SUBWF  00,W
051DA:  MOVLB  0
051DC:  BZ    5288
051DE:  MOVLB  3
051E0:  MOVLW  01
051E2:  SUBWF  03,W
051E4:  BNZ   51F0
051E6:  MOVLW  02
051E8:  SUBWF  00,W
051EA:  MOVLB  0
051EC:  BZ    5290
051EE:  MOVLB  3
051F0:  BRA    5298
.................... 		case 320:key_code=0; 
051F2:  MOVLB  3
051F4:  CLRF   xB1
.................... 				break; 
051F6:  BRA    5298
.................... 		case 8:	key_code=1; 
051F8:  MOVLW  01
051FA:  MOVLB  3
051FC:  MOVWF  xB1
.................... 				break; 
051FE:  BRA    5298
.................... 		case 264:key_code=2; 
05200:  MOVLW  02
05202:  MOVLB  3
05204:  MOVWF  xB1
.................... 				break; 
05206:  BRA    5298
.................... 		case 520:key_code=3; 
05208:  MOVLW  03
0520A:  MOVLB  3
0520C:  MOVWF  xB1
.................... 				break;	 
0520E:  BRA    5298
.................... 		case 16: key_code=4; 
05210:  MOVLW  04
05212:  MOVLB  3
05214:  MOVWF  xB1
.................... 				break; 
05216:  BRA    5298
.................... 		case 272:key_code=5; 
05218:  MOVLW  05
0521A:  MOVLB  3
0521C:  MOVWF  xB1
.................... 				break; 
0521E:  BRA    5298
.................... 		case 528:key_code=6; 
05220:  MOVLW  06
05222:  MOVLB  3
05224:  MOVWF  xB1
.................... 				break; 
05226:  BRA    5298
.................... 		case 32:key_code=7; 
05228:  MOVLW  07
0522A:  MOVLB  3
0522C:  MOVWF  xB1
.................... 				break; 
0522E:  BRA    5298
.................... 		case 288:key_code=8; 
05230:  MOVLW  08
05232:  MOVLB  3
05234:  MOVWF  xB1
.................... 				break; 
05236:  BRA    5298
.................... 		case 544:key_code=9; 
05238:  MOVLW  09
0523A:  MOVLB  3
0523C:  MOVWF  xB1
....................                 break; 
0523E:  BRA    5298
.................... 		case 1:	key_code=F1; 
05240:  MOVLW  0A
05242:  MOVLB  3
05244:  MOVWF  xB1
....................                 break; 
05246:  BRA    5298
.................... 		case 513:key_code=F2; 
05248:  MOVLW  0B
0524A:  MOVLB  3
0524C:  MOVWF  xB1
....................                 break; 
0524E:  BRA    5298
.................... 		case 4:	key_code=F3; 
05250:  MOVLW  0C
05252:  MOVLB  3
05254:  MOVWF  xB1
....................                 break; 
05256:  BRA    5298
.................... 		case 516:key_code=F4; 
05258:  MOVLW  0D
0525A:  MOVLB  3
0525C:  MOVWF  xB1
....................                 break; 
0525E:  BRA    5298
.................... 		case 64:key_code=ESC; 
05260:  MOVLW  12
05262:  MOVLB  3
05264:  MOVWF  xB1
....................                 break; 
05266:  BRA    5298
.................... 		case 576:key_code=ENTER; 
05268:  MOVLW  13
0526A:  MOVLB  3
0526C:  MOVWF  xB1
....................                 break; 
0526E:  BRA    5298
.................... 		case 257:key_code=SETA_SUPERIOR ; 
05270:  MOVLW  0E
05272:  MOVLB  3
05274:  MOVWF  xB1
....................                 break; 
05276:  BRA    5298
.................... 		case 2:	key_code=SETA_ESQUERDA ; 
05278:  MOVLW  11
0527A:  MOVLB  3
0527C:  MOVWF  xB1
....................                 break; 
0527E:  BRA    5298
.................... 		case 514:key_code=SETA_DIREITA ; 
05280:  MOVLW  10
05282:  MOVLB  3
05284:  MOVWF  xB1
....................                 break; 
05286:  BRA    5298
.................... 		case 260:key_code=SETA_INFERIOR; 
05288:  MOVLW  0F
0528A:  MOVLB  3
0528C:  MOVWF  xB1
....................                 break; 
0528E:  BRA    5298
.................... 		case 258:key_code=MENU; 
05290:  MOVLW  14
05292:  MOVLB  3
05294:  MOVWF  xB1
....................                 break; 
05296:  BRA    5298
.................... 	    default: 
.................... 				break; 
.................... 	} 
.................... 	return( key_code ); 
05298:  MOVFF  3B1,01
0529C:  MOVLB  0
0529E:  RETURN 0
.................... } 
.................... void espera_desacionar_teclas(void) { 
....................   int key_code = 0x00; 
....................   key_code = Teclado(); 
....................   while(key_code != 0xff){ 
....................     key_code = Teclado(); 
....................   } 
.................... } 
....................  
.................... #include "stepper_motor.c" 
.................... #DEFINE     step_y			    pin_C2 
.................... #DEFINE     dir_y				pin_C1 
.................... #DEFINE     enable_y			pin_C0 
....................  
.................... #DEFINE     step_x 		        pin_D2 
.................... #DEFINE     dir_x				pin_D1 
.................... #DEFINE     enable_x			pin_D0 
.................... #DEFINE     step_z              pin_A5              
.................... #DEFINE     dir_z               pin_A4 
.................... #DEFINE     enable_z            pin_A3 
.................... #DEFINE     step_flip           pin_E2 
.................... #DEFINE     dir_flip            pin_E1  
.................... #DEFINE     enable_flip         pin_E0 
....................  
.................... long int buffer_saida; 
.................... int16 motor_pos_x; 
.................... int16 motor_pos_y; 
.................... long int contador_step_flip; 
.................... int16 motor_pos_z; 
.................... short int direita_flag; 
.................... short int esquerda_flag; 
.................... short int frente_flag; 
.................... short int atras_flag; 
.................... short int sobe_flag; 
.................... short int desce_flag; 
.................... short int sentido_horario_flag; 
.................... short int sentido_antihorario_flag; 
....................  
.................... void direita(void) { 
....................     direita_flag = true; 
*
04596:  BSF    2C.4
....................     esquerda_flag = false; 
04598:  BCF    2C.5
....................     output_low(dir_x); 
0459A:  BCF    F95.1
0459C:  BCF    F8C.1
0459E:  RETURN 0
.................... } 
.................... void esquerda(void) { 
....................     direita_flag = false; 
*
045D8:  BCF    2C.4
....................     esquerda_flag = true; 
045DA:  BSF    2C.5
....................     output_high(dir_x); 
045DC:  BCF    F95.1
045DE:  BSF    F8C.1
045E0:  RETURN 0
.................... } 
.................... void frente(void) { 
....................     frente_flag = true; 
*
0442A:  BSF    2C.6
....................     atras_flag = false; 
0442C:  BCF    2C.7
....................     output_low(dir_y); 
0442E:  BCF    F94.1
04430:  BCF    F8B.1
04432:  RETURN 0
.................... } 
.................... void atras(void) { 
....................     frente_flag = false; 
*
0446C:  BCF    2C.6
....................     atras_flag = true; 
0446E:  BSF    2C.7
....................     output_high(dir_y); 
04470:  BCF    F94.1
04472:  BSF    F8B.1
04474:  RETURN 0
.................... } 
.................... void sentido_horario(void) { 
....................     sentido_horario_flag = true; 
*
0492A:  MOVLB  1
0492C:  BSF    x1A.2
....................     sentido_antihorario_flag = false; 
0492E:  BCF    x1A.3
....................     output_low(dir_flip); 
04930:  BCF    F96.1
04932:  BCF    F8D.1
04934:  MOVLB  0
04936:  RETURN 0
.................... } 
.................... void sentido_antihorario(void) { 
....................     sentido_horario_flag = false; 
*
0496C:  MOVLB  1
0496E:  BCF    x1A.2
....................     sentido_antihorario_flag = true; 
04970:  BSF    x1A.3
....................     output_high(dir_flip); 
04972:  BCF    F96.1
04974:  BSF    F8D.1
04976:  MOVLB  0
04978:  RETURN 0
.................... } 
.................... void sobe(void) { 
....................     sobe_flag = true; 
*
04318:  MOVLB  1
0431A:  BSF    x1A.0
....................     desce_flag = false; 
0431C:  BCF    x1A.1
....................     output_low(dir_z); 
0431E:  BCF    F92.4
04320:  BCF    F89.4
04322:  MOVLB  0
04324:  RETURN 0
.................... } 
.................... void desce(void) { 
....................     sobe_flag = false; 
*
042D6:  MOVLB  1
042D8:  BCF    x1A.0
....................     desce_flag = true; 
042DA:  BSF    x1A.1
....................     output_high(dir_z); 
042DC:  BCF    F92.4
042DE:  BSF    F89.4
042E0:  MOVLB  0
042E2:  RETURN 0
.................... } 
....................  
.................... void one_step_x(void) { 
....................     output_high(step_x); 
*
045A0:  BCF    F95.2
045A2:  BSF    F8C.2
....................     delay_us(10); 
045A4:  MOVLW  10
045A6:  MOVWF  00
045A8:  DECFSZ 00,F
045AA:  BRA    45A8
045AC:  NOP   
....................     output_low(step_x); 
045AE:  BCF    F95.2
045B0:  BCF    F8C.2
....................     if (esquerda_flag == true) { 
045B2:  BTFSS  2C.5
045B4:  BRA    45C2
....................         motor_pos_x++; 
045B6:  MOVLB  1
045B8:  INCF   x12,F
045BA:  BTFSC  FD8.2
045BC:  INCF   x13,F
....................     } else { 
045BE:  BRA    45D4
045C0:  MOVLB  0
....................         if (motor_pos_x != 0000){ 
045C2:  MOVLB  1
045C4:  MOVF   x12,F
045C6:  BNZ   45CC
045C8:  MOVF   x13,F
045CA:  BZ    45D4
....................             motor_pos_x--; 
045CC:  MOVF   x12,W
045CE:  BTFSC  FD8.2
045D0:  DECF   x13,F
045D2:  DECF   x12,F
....................         } 
....................     } 
045D4:  MOVLB  0
045D6:  RETURN 0
.................... } 
.................... void one_step_y(void) { 
....................     output_high(step_y); 
*
04434:  BCF    F94.2
04436:  BSF    F8B.2
....................     delay_us(10); 
04438:  MOVLW  10
0443A:  MOVWF  00
0443C:  DECFSZ 00,F
0443E:  BRA    443C
04440:  NOP   
....................     output_low(step_y); 
04442:  BCF    F94.2
04444:  BCF    F8B.2
....................     if (atras_flag == true) { 
04446:  BTFSS  2C.7
04448:  BRA    4456
....................         motor_pos_y++; 
0444A:  MOVLB  1
0444C:  INCF   x14,F
0444E:  BTFSC  FD8.2
04450:  INCF   x15,F
....................     } else { 
04452:  BRA    4468
04454:  MOVLB  0
....................         if (motor_pos_y != 0000) { 
04456:  MOVLB  1
04458:  MOVF   x14,F
0445A:  BNZ   4460
0445C:  MOVF   x15,F
0445E:  BZ    4468
....................             motor_pos_y--; 
04460:  MOVF   x14,W
04462:  BTFSC  FD8.2
04464:  DECF   x15,F
04466:  DECF   x14,F
....................         } 
....................     } 
04468:  MOVLB  0
0446A:  RETURN 0
.................... } 
.................... void one_step_flip(void) { 
....................     output_high(step_flip); 
*
04938:  BCF    F96.2
0493A:  BSF    F8D.2
....................     delay_us(10); 
0493C:  MOVLW  10
0493E:  MOVWF  00
04940:  DECFSZ 00,F
04942:  BRA    4940
04944:  NOP   
....................     output_low(step_flip); 
04946:  BCF    F96.2
04948:  BCF    F8D.2
....................     if (sentido_horario_flag == true) { 
0494A:  MOVLB  1
0494C:  BTFSS  x1A.2
0494E:  BRA    4958
....................         contador_step_flip++; 
04950:  INCF   x16,F
04952:  BTFSC  FD8.2
04954:  INCF   x17,F
....................     } else { 
04956:  BRA    4968
....................         if (contador_step_flip != 0000) { 
04958:  MOVF   x16,F
0495A:  BNZ   4960
0495C:  MOVF   x17,F
0495E:  BZ    4968
....................             contador_step_flip--; 
04960:  MOVF   x16,W
04962:  BTFSC  FD8.2
04964:  DECF   x17,F
04966:  DECF   x16,F
....................         } 
....................     } 
04968:  MOVLB  0
0496A:  RETURN 0
.................... } 
.................... void one_step_z(void) { 
....................     output_high(step_z); 
*
042E4:  BCF    F92.5
042E6:  BSF    F89.5
....................     delay_us(10); 
042E8:  MOVLW  10
042EA:  MOVWF  00
042EC:  DECFSZ 00,F
042EE:  BRA    42EC
042F0:  NOP   
....................     output_low(step_z); 
042F2:  BCF    F92.5
042F4:  BCF    F89.5
....................     if (desce_flag == true) { 
042F6:  MOVLB  1
042F8:  BTFSS  x1A.1
042FA:  BRA    4304
....................         motor_pos_z++; 
042FC:  INCF   x18,F
042FE:  BTFSC  FD8.2
04300:  INCF   x19,F
....................     } else { 
04302:  BRA    4314
....................         if (motor_pos_z != 0000) { 
04304:  MOVF   x18,F
04306:  BNZ   430C
04308:  MOVF   x19,F
0430A:  BZ    4314
....................             motor_pos_z--; 
0430C:  MOVF   x18,W
0430E:  BTFSC  FD8.2
04310:  DECF   x19,F
04312:  DECF   x18,F
....................         } 
....................     } 
04314:  MOVLB  0
04316:  RETURN 0
.................... } 
....................  
.................... void chopper_x(void) { 
....................     output_low(enable_x); 
*
04590:  BCF    F95.0
04592:  BCF    F8C.0
04594:  RETURN 0
.................... } 
.................... void chopper_y(void) { 
....................     output_low(enable_y); 
*
04424:  BCF    F94.0
04426:  BCF    F8B.0
04428:  RETURN 0
.................... } 
.................... void chopper_flip(void) { 
....................     output_low(enable_flip); 
*
04922:  BCF    F96.0
04924:  BCF    F8D.0
04926:  GOTO   4982 (RETURN)
.................... } 
.................... void chopper_z(void) { 
....................     output_low(enable_z); 
*
03FD4:  BCF    F92.3
03FD6:  BCF    F89.3
03FD8:  GOTO   4330 (RETURN)
.................... } 
.................... void stop_x(void) { 
....................     output_low(enable_x); 
*
045E2:  BCF    F95.0
045E4:  BCF    F8C.0
045E6:  RETURN 0
.................... } 
.................... void stop_y(void) { 
....................    output_low(enable_y); 
*
04476:  BCF    F94.0
04478:  BCF    F8B.0
0447A:  RETURN 0
.................... } 
.................... void stop_flip(void) { 
....................     output_low(enable_flip); 
.................... } 
.................... void stop_z(void) { 
....................     output_low(enable_z); 
*
04326:  BCF    F92.3
04328:  BCF    F89.3
0432A:  GOTO   4420 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "I_O.c" 
.................... #define     IN0				0 
.................... #define     IN1				1 
.................... #define     IN2				2 
.................... #define     IN3				3 
.................... #define     IN4				4 
.................... #define     IN5				5 
.................... #define     IN6				6 
.................... #define     IN7				7 
.................... #define     IN8				8 
.................... #define     IN9				9 
.................... #define     IN10			10 
.................... #define     IN11			11 
.................... #define     IN12			12 
.................... #define     IN13			13 
.................... #define     IN14			14 
.................... #define     IN15			15 
.................... #define     IN16			16 
.................... #define     IN17			17 
.................... #define     IN18			18 
.................... #define     IN19			19 
.................... #define     IN20			20 
.................... #define     IN21			21	 
.................... #define     IN22			22 
.................... #define     IN23			23 
.................... #define     IN24			24 
.................... #define     IN25			25 
.................... #define     IN26    		26 
.................... #define     IN27	    	27 
.................... 	 
.................... #define     S_DEDO_IN_LS1      	    IN0  	//SENSOR AVANO CILINRO  1		 
.................... #define     S_DEDO_IN_LS2      	    IN1	 	//SENSOR AVANO CILINDRO 2			 
.................... #define     S_EMPURRADOR_IN_LS1	    IN2	 	//NT 
.................... #define     S_EMPURRADOR_IN_LS2     IN3	 	//SENSOR RECUO  CLP1			 
.................... #define     S_PRESSOR_LS2           IN4	 	//SENSOR AVANCO 
.................... #define     S_X_DIREITA			    IN5	 	//LIMITE DIREITA			 
.................... #define     S_X_ESQUERDA		    IN6	 	//LIMITE ESQUERDA			 
.................... #define     S_Y_FRENTE   		    IN7  	//LIMITE FRENTE			 
.................... #define     S_Y_ATRAS               IN8  	//LIMITE ATRAS	 
.................... #define     S_Y_DIREITA_PROT  	    IN9  	//LIMITE DIREITA DA OUTRA PLACA			 
.................... #define     S_Y_ESQUERDA_PROT       IN10 	//LIMITE ESQUERDA DA OUTRA PLACA	 
.................... #define     S_ROTACAO_LS1           IN11 	//SENSOR LIMITE GIRO HORARIO			 
.................... #define     S_FERRO_SOLDA1          IN12 	//SENSOR FERRO DE SOLDA 1 			 
.................... #define     S_Z_TOP	    		    IN13 	//SENSOR LIMITE  SUPEIOR			 
.................... #define     S_Z_BOTTOM			    IN14 	//SENSOR LIMITE  INFERIOR			 
.................... #define     S_FERRO_SOLDA2          IN15 	//SENSOR FERRO DE SOLDA 2			 
.................... #define     S_DEDO_OUT_LS1		    IN16 	//SENSOR AVANO 
.................... #define     S_DEDO_OUT_LS2	        IN17 	//SENSOR AVANO 
.................... #define     S_EMPURRADOR_OUT_LS1    IN18 	//SENSOR AVANO 			 
.................... #define     S_EMPURRADOR_OUT_LS2    IN19 	//SENSOR recuo	 
.................... #define     SENSOR_BOARD   			IN20 	 
.................... #define     S_BANDEJA               IN21 	//SENSOR BANDEJA CLP1 & CLP2 
.................... #define     S_FIO_SOLDA1	        IN22 	//SENSOR FIO DE SOLDA 1 
.................... #define     S_FIO_SOLDA2	        IN23 	//SENSOR FIO DE SOLDA 2 
.................... #define     S_FIO_SOLDA3	        IN24 	//SENSOR FIO DE SOLDA 3 
.................... #define     S_ESTEIRA               IN25 	//SENSOR DESLIGA ESTEIRA 
.................... #define     RESERVADO2 				IN26 	 
.................... #define     RESERVADO3              IN27    //RESET 
....................    	  
.................... // definio das saidas de comandos 
....................  
.................... #define     DEDO_ENTRADA				     7  //OUT 0 
.................... #define     EMPURRADOR_ENTRADA_SOL_EMPURRA   6  //OUT 1 
.................... #define     EMPURRADOR_ENTRADA_SOL_RETORNA 	 5  //OUT 2 
.................... #define     PRESSOR						     4  //OUT 3 
.................... #define     FERRO_SOLDA1				     3  //OUT 4 
.................... #define     FERRO_SOLDA2				     2  //OUT 5 
.................... #define     DEDO_SAIDA					     1  //OUT 6 
.................... #define     EMPURRADOR_SAIDA_SOL_EMPURRA     0  //OUT 7 
.................... #define     EMPURRADOR_SAIDA_SOL_RETORNA     15 //OUT 8 
.................... #define     ALIMENTADOR1					 14 //OUT 9  RL2 
.................... #define     ALIMENTADOR2					 13 //OUT 10 RL3 
.................... #define     ALIMENTADOR3					 12	//OUT 11 RL4  
.................... #define     LIMPADOR					     11	//OUT 12 RL5 
.................... #define     RELE_ESTEIRA                     10 //OUT 13  
.................... #define     LIMPA_BICO1                       8 //OUT 15    
.................... #define     LIMPA_BICO2                       9 //OUT 14  
....................  
.................... short int le_Input(int input_number){ 
*
0409A:  MOVLB  3
0409C:  CLRF   xB5
0409E:  CLRF   xB4
040A0:  CLRF   xB6
.................... 	short int retorno; 
....................     long int  data_sensores  = 0x0000; 
.................... 	int		  data_sensores2 = 0x00;	 
.................... 	if(input_number < 16) { 
040A2:  MOVF   xB2,W
040A4:  SUBLW  0F
040A6:  BNC   411C
.................... 	 	data_sensores = le_PCA9555(0X03,0X00); 
040A8:  MOVLW  03
040AA:  MOVWF  xB8
040AC:  CLRF   xB9
040AE:  MOVLB  0
040B0:  RCALL  3FDC
040B2:  MOVFF  02,3B5
040B6:  MOVFF  01,3B4
.................... 		if(bit_test (data_sensores,input_number) == 0){ 
040BA:  MOVFF  3B5,03
040BE:  MOVLB  3
040C0:  MOVFF  3B4,02
040C4:  MOVF   xB2,W
040C6:  MOVWF  00
040C8:  BZ    40D4
040CA:  BCF    FD8.0
040CC:  RRCF   03,F
040CE:  RRCF   02,F
040D0:  DECFSZ 00,F
040D2:  BRA    40CA
040D4:  MOVF   02,W
040D6:  BTFSC  02.0
040D8:  BRA    4114
.................... 			delay_us(30); 
040DA:  MOVLW  31
040DC:  MOVWF  00
040DE:  DECFSZ 00,F
040E0:  BRA    40DE
040E2:  BRA    40E4
.................... 			if(bit_test (data_sensores,input_number) == 0) return retorno = true; 
040E4:  MOVFF  3B5,03
040E8:  MOVFF  3B4,02
040EC:  MOVF   xB2,W
040EE:  MOVWF  00
040F0:  BZ    40FC
040F2:  BCF    FD8.0
040F4:  RRCF   03,F
040F6:  RRCF   02,F
040F8:  DECFSZ 00,F
040FA:  BRA    40F2
040FC:  MOVF   02,W
040FE:  BTFSC  02.0
04100:  BRA    410A
04102:  BSF    xB3.0
04104:  MOVLW  01
04106:  MOVWF  01
04108:  BRA    42A6
.................... 			return  retorno = false; 
0410A:  BCF    xB3.0
0410C:  MOVLW  00
0410E:  MOVWF  01
04110:  BRA    42A6
.................... 		} 
04112:  BRA    411C
....................         else  
....................             return  retorno = false; 
04114:  BCF    xB3.0
04116:  MOVLW  00
04118:  MOVWF  01
0411A:  BRA    42A6
.................... 	}		 
.................... 	if((input_number >= 16) && (input_number < 24)){ 
0411C:  MOVF   xB2,W
0411E:  SUBLW  0F
04120:  BC    4192
04122:  MOVF   xB2,W
04124:  SUBLW  17
04126:  BNC   4192
.................... 		data_sensores2 = le_pcf8574A(0x04); 
04128:  MOVLW  04
0412A:  MOVWF  xB7
0412C:  MOVLB  0
0412E:  BRA    4064
04130:  MOVFF  01,3B6
.................... 		if(bit_test (data_sensores2,input_number - 16) == 0) { 
04134:  MOVLW  10
04136:  MOVLB  3
04138:  SUBWF  xB2,W
0413A:  MOVWF  xB7
0413C:  MOVFF  3B6,00
04140:  MOVF   xB7,W
04142:  MOVWF  01
04144:  BZ    414E
04146:  BCF    FD8.0
04148:  RRCF   00,F
0414A:  DECFSZ 01,F
0414C:  BRA    4146
0414E:  BTFSC  00.0
04150:  BRA    418A
.................... 			delay_us(30); 
04152:  MOVLW  31
04154:  MOVWF  00
04156:  DECFSZ 00,F
04158:  BRA    4156
0415A:  BRA    415C
.................... 			if(bit_test (data_sensores2,input_number - 16) == 0) return retorno = true; 
0415C:  MOVLW  10
0415E:  SUBWF  xB2,W
04160:  MOVWF  xB7
04162:  MOVFF  3B6,00
04166:  MOVF   xB7,W
04168:  MOVWF  01
0416A:  BZ    4174
0416C:  BCF    FD8.0
0416E:  RRCF   00,F
04170:  DECFSZ 01,F
04172:  BRA    416C
04174:  BTFSC  00.0
04176:  BRA    4180
04178:  BSF    xB3.0
0417A:  MOVLW  01
0417C:  MOVWF  01
0417E:  BRA    42A6
.................... 			return    retorno = false; 
04180:  BCF    xB3.0
04182:  MOVLW  00
04184:  MOVWF  01
04186:  BRA    42A6
.................... 		} 
04188:  BRA    4192
....................         else { 
....................             return  retorno = false; 
0418A:  BCF    xB3.0
0418C:  MOVLW  00
0418E:  MOVWF  01
04190:  BRA    42A6
....................         } 
.................... 	} 
.................... 	if((input_number >= 24) && (input_number <= 27)) {	 
04192:  MOVF   xB2,W
04194:  SUBLW  17
04196:  BTFSC  FD8.0
04198:  BRA    42A6
0419A:  MOVF   xB2,W
0419C:  SUBLW  1B
0419E:  BTFSS  FD8.0
041A0:  BRA    42A6
.................... 		switch(input_number) { 
041A2:  MOVLW  18
041A4:  SUBWF  xB2,W
041A6:  ADDLW  FC
041A8:  BTFSC  FD8.0
041AA:  BRA    42A6
041AC:  ADDLW  04
041AE:  MOVLB  0
041B0:  GOTO   42AA
.................... 			case 24: 
....................                 if(input(in24_bit) == 0) { 
041B4:  BSF    F93.0
041B6:  BTFSC  F81.0
041B8:  BRA    41E0
....................                     delay_us(30); 
041BA:  MOVLW  31
041BC:  MOVWF  00
041BE:  DECFSZ 00,F
041C0:  BRA    41BE
041C2:  BRA    41C4
....................                     if(input(in24_bit) == 0) { 
041C4:  BSF    F93.0
041C6:  BTFSC  F81.0
041C8:  BRA    41DE
....................                         return retorno	= true;		 
041CA:  MOVLB  3
041CC:  BSF    xB3.0
041CE:  MOVLW  01
041D0:  MOVWF  01
041D2:  BRA    42A6
....................                         return retorno	= false;	 
041D4:  BCF    xB3.0
041D6:  MOVLW  00
041D8:  MOVWF  01
041DA:  BRA    42A6
041DC:  MOVLB  0
....................                     } 
....................                 } 
041DE:  BRA    41EC
....................                 else {	 
....................                     return retorno	= false; 
041E0:  MOVLB  3
041E2:  BCF    xB3.0
041E4:  MOVLW  00
041E6:  MOVWF  01
041E8:  BRA    42A6
041EA:  MOVLB  0
....................                 } 
....................             break; 
041EC:  MOVLB  3
041EE:  BRA    42A6
.................... 			case 25: 
....................                 if(input(in25_bit) == 0){ 
041F0:  BSF    F93.1
041F2:  BTFSC  F81.1
041F4:  BRA    421C
....................                     delay_us(30); 
041F6:  MOVLW  31
041F8:  MOVWF  00
041FA:  DECFSZ 00,F
041FC:  BRA    41FA
041FE:  BRA    4200
....................                     if(input(in25_bit) == 0) { 
04200:  BSF    F93.1
04202:  BTFSC  F81.1
04204:  BRA    421A
....................                         return retorno	= true;		 
04206:  MOVLB  3
04208:  BSF    xB3.0
0420A:  MOVLW  01
0420C:  MOVWF  01
0420E:  BRA    42A6
....................                         return retorno	= false;	 
04210:  BCF    xB3.0
04212:  MOVLW  00
04214:  MOVWF  01
04216:  BRA    42A6
04218:  MOVLB  0
....................                     } 
....................                 }else {	 
0421A:  BRA    4228
....................                     return retorno	= false; 
0421C:  MOVLB  3
0421E:  BCF    xB3.0
04220:  MOVLW  00
04222:  MOVWF  01
04224:  BRA    42A6
04226:  MOVLB  0
....................                 } 
....................             break; 
04228:  MOVLB  3
0422A:  BRA    42A6
.................... 			case 26: 
....................                 if(input(in26_bit) == 0){ 
0422C:  BSF    F93.3
0422E:  BTFSC  F81.3
04230:  BRA    4258
....................                     delay_us(30); 
04232:  MOVLW  31
04234:  MOVWF  00
04236:  DECFSZ 00,F
04238:  BRA    4236
0423A:  BRA    423C
....................                     if(input(in26_bit) == 0) { 
0423C:  BSF    F93.3
0423E:  BTFSC  F81.3
04240:  BRA    4256
....................                         return retorno	= true;		 
04242:  MOVLB  3
04244:  BSF    xB3.0
04246:  MOVLW  01
04248:  MOVWF  01
0424A:  BRA    42A6
....................                         return retorno	= false;	 
0424C:  BCF    xB3.0
0424E:  MOVLW  00
04250:  MOVWF  01
04252:  BRA    42A6
04254:  MOVLB  0
....................                     } 
....................                 }else{ 	 
04256:  BRA    4264
....................                     return retorno	= false; 
04258:  MOVLB  3
0425A:  BCF    xB3.0
0425C:  MOVLW  00
0425E:  MOVWF  01
04260:  BRA    42A6
04262:  MOVLB  0
....................                 } 
....................             break; 
04264:  MOVLB  3
04266:  BRA    42A6
.................... 			case 27: 
....................                 if(input(in27_bit) == 0) { 
04268:  BSF    F93.4
0426A:  BTFSC  F81.4
0426C:  BRA    4294
....................                     delay_us(30); 
0426E:  MOVLW  31
04270:  MOVWF  00
04272:  DECFSZ 00,F
04274:  BRA    4272
04276:  BRA    4278
....................                     if(input(in27_bit) == 0) { 
04278:  BSF    F93.4
0427A:  BTFSC  F81.4
0427C:  BRA    4292
....................                         return retorno	= true;		 
0427E:  MOVLB  3
04280:  BSF    xB3.0
04282:  MOVLW  01
04284:  MOVWF  01
04286:  BRA    42A6
....................                         return retorno	= false;	 
04288:  BCF    xB3.0
0428A:  MOVLW  00
0428C:  MOVWF  01
0428E:  BRA    42A6
04290:  MOVLB  0
....................                     } 
....................                 }else{ 	 
04292:  BRA    42A0
....................                     return retorno	= false; 
04294:  MOVLB  3
04296:  BCF    xB3.0
04298:  MOVLW  00
0429A:  MOVWF  01
0429C:  BRA    42A6
0429E:  MOVLB  0
....................                 } 
....................             break; 
042A0:  MOVLB  3
042A2:  BRA    42A6
042A4:  MOVLB  3
.................... 	 	} 
.................... 	} 
042A6:  MOVLB  0
042A8:  RETURN 0
.................... } 
.................... void aciona_saida(long int output_word){ 
.................... 	int valor_lsb; 
.................... 	int valor_msb; 
.................... 	bit_clear(buffer_saida,output_word); 
*
0252C:  CLRF   03
0252E:  MOVLW  01
02530:  MOVWF  02
02532:  MOVLB  3
02534:  MOVF   xB7,W
02536:  MOVWF  00
02538:  BZ    2544
0253A:  BCF    FD8.0
0253C:  RLCF   02,F
0253E:  RLCF   03,F
02540:  DECFSZ 00,F
02542:  BRA    253A
02544:  MOVF   02,W
02546:  XORLW  FF
02548:  MOVWF  00
0254A:  MOVLW  FF
0254C:  XORWF  03,F
0254E:  MOVF   00,W
02550:  MOVLB  1
02552:  ANDWF  x10,F
02554:  MOVF   03,W
02556:  ANDWF  x11,F
.................... 	valor_lsb = make8(buffer_saida,0);   
02558:  MOVFF  110,3B9
0255C:  MOVLB  3
.................... 	valor_msb = make8(buffer_saida,1); 
0255E:  MOVFF  111,3BA
02562:  MOVLB  3
.................... 	escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
02564:  MOVLW  02
02566:  MOVWF  xBB
02568:  MOVWF  xBC
0256A:  MOVFF  3BA,3BD
0256E:  MOVFF  3B9,3BE
02572:  MOVLB  0
02574:  RCALL  2146
02576:  RETURN 0
.................... } 
.................... void desaciona_saida(long int output_word){ 
.................... 	int valor_lsb; 
.................... 	int valor_msb; 
.................... 	bit_set(buffer_saida,output_word); 
*
024EA:  CLRF   03
024EC:  MOVLW  01
024EE:  MOVWF  02
024F0:  MOVLB  3
024F2:  MOVF   xB7,W
024F4:  MOVWF  00
024F6:  BZ    2502
024F8:  BCF    FD8.0
024FA:  RLCF   02,F
024FC:  RLCF   03,F
024FE:  DECFSZ 00,F
02500:  BRA    24F8
02502:  MOVF   02,W
02504:  MOVLB  1
02506:  IORWF  x10,F
02508:  MOVF   03,W
0250A:  IORWF  x11,F
.................... 	valor_lsb = make8(buffer_saida,0);   
0250C:  MOVFF  110,3B9
02510:  MOVLB  3
.................... 	valor_msb = make8(buffer_saida,1); 
02512:  MOVFF  111,3BA
02516:  MOVLB  3
.................... 	escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
02518:  MOVLW  02
0251A:  MOVWF  xBB
0251C:  MOVWF  xBC
0251E:  MOVFF  3BA,3BD
02522:  MOVFF  3B9,3BE
02526:  MOVLB  0
02528:  RCALL  2146
0252A:  RETURN 0
.................... } 
.................... void desaciona_todas_saidas(void){ 
.................... 	int valor_lsb; 
.................... 	int valor_msb; 
.................... 	buffer_saida = 0x0ffff; 
*
021F0:  MOVLB  1
021F2:  SETF   x11
021F4:  SETF   x10
.................... 	valor_lsb = make8(buffer_saida,0);   
021F6:  MOVFF  110,3AD
021FA:  MOVLB  3
.................... 	valor_msb = make8(buffer_saida,1); 
021FC:  MOVFF  111,3AE
02200:  MOVLB  3
.................... 	escreve_PCA9555(0x02,0x02,valor_msb,valor_lsb); 
02202:  MOVLW  02
02204:  MOVWF  xBB
02206:  MOVWF  xBC
02208:  MOVFF  3AE,3BD
0220C:  MOVFF  3AD,3BE
02210:  MOVLB  0
02212:  RCALL  2146
02214:  GOTO   A8E2 (RETURN)
.................... } 
.................... void Init_Sensores_porta1(void){ 
.................... 	escreve_PCA9555(0X03,0X06,0Xff,0xff);	// programa bits entradas  
*
021C4:  MOVLW  03
021C6:  MOVLB  3
021C8:  MOVWF  xBB
021CA:  MOVLW  06
021CC:  MOVWF  xBC
021CE:  SETF   xBD
021D0:  SETF   xBE
021D2:  MOVLB  0
021D4:  RCALL  2146
021D6:  GOTO   A8DA (RETURN)
.................... } 
.................... void Init_saidas(void){ 
.................... 	escreve_PCA9555(0X02,0X06,0X00,0x00);	// programa bits saidas //como saida e os demais como entrada     
021DA:  MOVLW  02
021DC:  MOVLB  3
021DE:  MOVWF  xBB
021E0:  MOVLW  06
021E2:  MOVWF  xBC
021E4:  CLRF   xBD
021E6:  CLRF   xBE
021E8:  MOVLB  0
021EA:  RCALL  2146
021EC:  GOTO   A8DE (RETURN)
.................... } 
....................  
.................... #include "comunicacao_entre_maquinas.c" 
.................... #include "comunicacao_entre_maquinas.h" 
.................... /*  
....................  * File:   comunicacao_entre_maquinas.h 
....................  * Author: ictsam0100 
....................  * 
....................  * Created on 6 de Dezembro de 2018, 11:13 
....................  */ 
....................  
.................... int posicao_maq; 
.................... int n_posicao; 
.................... int n_bit; 
....................  
.................... short int le_bit(int n_bit); //l bit especifico e verifica o valor "0 ou 1" 
.................... int ler_posicao_maquina_1 (void); //le os bits H3, H4 e H5 para verificar a posicao da maquina 1 
.................... void enviar_posicao_para_maquina_1 (int n_posicao); //aciona os outputs H0, H1 e H2 para enviar posicao para maquina 1    
....................  
....................  
.................... short int le_bit(int n_bit) { 
....................     short int retorno; 
....................  
....................     if (input(n_bit) == 1) { 
*
03A98:  MOVFF  3B3,3B5
03A9C:  MOVLW  01
03A9E:  MOVLB  3
03AA0:  MOVWF  xB6
03AA2:  MOVLW  0F
03AA4:  MOVWF  xB8
03AA6:  MOVLW  92
03AA8:  MOVWF  xB7
03AAA:  MOVLB  0
03AAC:  RCALL  3A24
03AAE:  MOVFF  3B3,3B5
03AB2:  MOVLW  0F
03AB4:  MOVLB  3
03AB6:  MOVWF  xB7
03AB8:  MOVLW  80
03ABA:  MOVWF  xB6
03ABC:  MOVLB  0
03ABE:  RCALL  3A66
03AC0:  BTFSS  01.0
03AC2:  BRA    3ADA
....................         return retorno = 1; 
03AC4:  MOVLB  3
03AC6:  BSF    xB4.0
03AC8:  MOVLW  01
03ACA:  MOVWF  01
03ACC:  BRA    3B1A
....................         delay_us(30); 
03ACE:  MOVLW  31
03AD0:  MOVWF  00
03AD2:  DECFSZ 00,F
03AD4:  BRA    3AD2
03AD6:  BRA    3AD8
03AD8:  MOVLB  0
....................     } 
....................     if (input(n_bit) == 0) { 
03ADA:  MOVFF  3B3,3B5
03ADE:  MOVLW  01
03AE0:  MOVLB  3
03AE2:  MOVWF  xB6
03AE4:  MOVLW  0F
03AE6:  MOVWF  xB8
03AE8:  MOVLW  92
03AEA:  MOVWF  xB7
03AEC:  MOVLB  0
03AEE:  RCALL  3A24
03AF0:  MOVFF  3B3,3B5
03AF4:  MOVLW  0F
03AF6:  MOVLB  3
03AF8:  MOVWF  xB7
03AFA:  MOVLW  80
03AFC:  MOVWF  xB6
03AFE:  MOVLB  0
03B00:  RCALL  3A66
03B02:  BTFSC  01.0
03B04:  BRA    3B1C
....................         return retorno = 0; 
03B06:  MOVLB  3
03B08:  BCF    xB4.0
03B0A:  MOVLW  00
03B0C:  MOVWF  01
03B0E:  BRA    3B1A
....................         delay_us(30); 
03B10:  MOVLW  31
03B12:  MOVWF  00
03B14:  DECFSZ 00,F
03B16:  BRA    3B14
03B18:  BRA    3B1A
03B1A:  MOVLB  0
....................     } 
03B1C:  RETURN 0
.................... } 
.................... int le_posicao_outra_maquina (void){ 
03B1E:  MOVLW  1F
03B20:  MOVLB  3
03B22:  MOVWF  xB3
03B24:  MOVLB  0
03B26:  RCALL  3A98
03B28:  MOVFF  01,3B0
03B2C:  MOVLW  1E
03B2E:  MOVLB  3
03B30:  MOVWF  xB3
03B32:  MOVLB  0
03B34:  RCALL  3A98
03B36:  MOVFF  01,3B1
03B3A:  MOVLW  1D
03B3C:  MOVLB  3
03B3E:  MOVWF  xB3
03B40:  MOVLB  0
03B42:  RCALL  3A98
03B44:  MOVFF  01,3B2
....................     int x = le_bit(H0); 
....................     int y = le_bit(H1); 
....................     int z = le_bit(H2); 
....................      
....................     switch (z) { 
03B48:  MOVLB  3
03B4A:  MOVF   xB2,W
03B4C:  XORLW  00
03B4E:  MOVLB  0
03B50:  BZ    3B58
03B52:  XORLW  01
03B54:  BZ    3BB0
03B56:  BRA    3C08
....................         case 0: 
....................             switch (y) { 
03B58:  MOVLB  3
03B5A:  MOVF   xB1,W
03B5C:  XORLW  00
03B5E:  MOVLB  0
03B60:  BZ    3B68
03B62:  XORLW  01
03B64:  BZ    3B8A
03B66:  BRA    3BAE
....................                 case 0: 
....................                     switch (x) { 
03B68:  MOVLB  3
03B6A:  MOVF   xB0,W
03B6C:  XORLW  00
03B6E:  MOVLB  0
03B70:  BZ    3B78
03B72:  XORLW  01
03B74:  BZ    3B80
03B76:  BRA    3B88
....................                         case 0: 
....................                             posicao_maq = ALIMENTADOR; 
03B78:  MOVLB  1
03B7A:  CLRF   x1B
....................                         break; 
03B7C:  MOVLB  0
03B7E:  BRA    3B88
....................                         case 1: 
....................                             posicao_maq = HOME1; 
03B80:  MOVLW  01
03B82:  MOVLB  1
03B84:  MOVWF  x1B
....................                         break; 
03B86:  MOVLB  0
....................                     } 
....................                 break; 
03B88:  BRA    3BAE
....................                 case 1: 
....................                     switch (x) { 
03B8A:  MOVLB  3
03B8C:  MOVF   xB0,W
03B8E:  XORLW  00
03B90:  MOVLB  0
03B92:  BZ    3B9A
03B94:  XORLW  01
03B96:  BZ    3BA4
03B98:  BRA    3BAC
....................                         case 0: 
....................                             posicao_maq = SOLDAGEM; 
03B9A:  MOVLW  03
03B9C:  MOVLB  1
03B9E:  MOVWF  x1B
....................                         break; 
03BA0:  MOVLB  0
03BA2:  BRA    3BAC
....................                         case 1: 
....................                             posicao_maq = HOME2; 
03BA4:  MOVLW  04
03BA6:  MOVLB  1
03BA8:  MOVWF  x1B
....................                         break; 
03BAA:  MOVLB  0
....................                     } 
....................                 break;                     
03BAC:  BRA    3BAE
....................             } 
....................         break; 
03BAE:  BRA    3C08
....................         case 1: 
....................             switch (y) { 
03BB0:  MOVLB  3
03BB2:  MOVF   xB1,W
03BB4:  XORLW  00
03BB6:  MOVLB  0
03BB8:  BZ    3BC0
03BBA:  XORLW  01
03BBC:  BZ    3BE4
03BBE:  BRA    3C08
....................                 case 0: 
....................                     switch (x) { 
03BC0:  MOVLB  3
03BC2:  MOVF   xB0,W
03BC4:  XORLW  00
03BC6:  MOVLB  0
03BC8:  BZ    3BD0
03BCA:  XORLW  01
03BCC:  BZ    3BDA
03BCE:  BRA    3BE2
....................                         case 0: 
....................                             posicao_maq = DISPENSADOR; 
03BD0:  MOVLW  05
03BD2:  MOVLB  1
03BD4:  MOVWF  x1B
....................                         break; 
03BD6:  MOVLB  0
03BD8:  BRA    3BE2
....................                         case 1: 
....................                             posicao_maq = LIMPEZA; 
03BDA:  MOVLW  06
03BDC:  MOVLB  1
03BDE:  MOVWF  x1B
....................                         break; 
03BE0:  MOVLB  0
....................                     } 
....................                 break; 
03BE2:  BRA    3C08
....................                 case 1: 
....................                     switch (x) { 
03BE4:  MOVLB  3
03BE6:  MOVF   xB0,W
03BE8:  XORLW  00
03BEA:  MOVLB  0
03BEC:  BZ    3BF4
03BEE:  XORLW  01
03BF0:  BZ    3BFE
03BF2:  BRA    3C06
....................                         case 0: 
....................                             posicao_maq = LIMPEZA_2; 
03BF4:  MOVLW  07
03BF6:  MOVLB  1
03BF8:  MOVWF  x1B
....................                         break; 
03BFA:  MOVLB  0
03BFC:  BRA    3C06
....................                         case 1: 
....................                             posicao_maq = POSICAO_8; 
03BFE:  MOVLW  08
03C00:  MOVLB  1
03C02:  MOVWF  x1B
....................                         break; 
03C04:  MOVLB  0
....................                     } 
....................                 break;  
03C06:  BRA    3C08
....................             }                 
....................         break; 
....................     } 
....................     return posicao_maq; 
03C08:  MOVLB  1
03C0A:  MOVFF  11B,01
03C0E:  MOVLB  0
03C10:  RETURN 0
.................... } 
.................... void envia_posicao_para_outra_maquina (int n_posicao) { 
....................     switch (n_posicao){ 
*
04C2E:  MOVLB  3
04C30:  MOVF   xB0,W
04C32:  ADDLW  F7
04C34:  BC    4CC0
04C36:  ADDLW  09
04C38:  MOVLB  0
04C3A:  GOTO   4CC4
....................         case ALIMENTADOR: 
....................             output_low(H3); 
04C3E:  BCF    F95.4
04C40:  BCF    F8C.4
....................             output_low(H4); 
04C42:  BCF    F94.7
04C44:  BCF    F8B.7
....................             output_low(H5); 
04C46:  BCF    F94.6
04C48:  BCF    F8B.6
....................         break; 
04C4A:  MOVLB  3
04C4C:  BRA    4CC0
....................         case HOME1: 
....................             output_high(H3); 
04C4E:  BCF    F95.4
04C50:  BSF    F8C.4
....................             output_low (H4); 
04C52:  BCF    F94.7
04C54:  BCF    F8B.7
....................             output_low (H5); 
04C56:  BCF    F94.6
04C58:  BCF    F8B.6
....................         break; 
04C5A:  MOVLB  3
04C5C:  BRA    4CC0
....................         case SOLDAGEM: 
....................             output_low (H3); 
04C5E:  BCF    F95.4
04C60:  BCF    F8C.4
....................             output_high(H4); 
04C62:  BCF    F94.7
04C64:  BSF    F8B.7
....................             output_low (H5); 
04C66:  BCF    F94.6
04C68:  BCF    F8B.6
....................         break; 
04C6A:  MOVLB  3
04C6C:  BRA    4CC0
....................         case HOME2: 
....................             output_high (H3); 
04C6E:  BCF    F95.4
04C70:  BSF    F8C.4
....................             output_high(H4); 
04C72:  BCF    F94.7
04C74:  BSF    F8B.7
....................             output_low (H5); 
04C76:  BCF    F94.6
04C78:  BCF    F8B.6
....................         break; 
04C7A:  MOVLB  3
04C7C:  BRA    4CC0
....................         case DISPENSADOR: 
....................             output_low (H3); 
04C7E:  BCF    F95.4
04C80:  BCF    F8C.4
....................             output_low (H4); 
04C82:  BCF    F94.7
04C84:  BCF    F8B.7
....................             output_high(H5); 
04C86:  BCF    F94.6
04C88:  BSF    F8B.6
....................         break; 
04C8A:  MOVLB  3
04C8C:  BRA    4CC0
....................         case LIMPEZA: 
....................             output_high(H3); 
04C8E:  BCF    F95.4
04C90:  BSF    F8C.4
....................             output_low (H4); 
04C92:  BCF    F94.7
04C94:  BCF    F8B.7
....................             output_high(H5); 
04C96:  BCF    F94.6
04C98:  BSF    F8B.6
....................         break; 
04C9A:  MOVLB  3
04C9C:  BRA    4CC0
....................         case LIMPEZA_2: 
....................             output_low(H3); 
04C9E:  BCF    F95.4
04CA0:  BCF    F8C.4
....................             output_high(H4); 
04CA2:  BCF    F94.7
04CA4:  BSF    F8B.7
....................             output_high (H5); 
04CA6:  BCF    F94.6
04CA8:  BSF    F8B.6
....................         break; 
04CAA:  MOVLB  3
04CAC:  BRA    4CC0
....................         case POSICAO_8: 
....................             output_high(H3); 
04CAE:  BCF    F95.4
04CB0:  BSF    F8C.4
....................             output_high(H4); 
04CB2:  BCF    F94.7
04CB4:  BSF    F8B.7
....................             output_high(H5); 
04CB6:  BCF    F94.6
04CB8:  BSF    F8B.6
....................         break; 
04CBA:  MOVLB  3
04CBC:  BRA    4CC0
04CBE:  MOVLB  3
....................     } 
04CC0:  MOVLB  0
04CC2:  RETURN 0
.................... } 
....................  
.................... #include "telas_maquina_1.c" 
.................... #include "telas_maquina_1.h" 
.................... #define menu_principal                          0 
.................... #define menu_seleciona_maquina                  1 
.................... #define menu_seleciona_debug                    2 
.................... #define menu_seleciona_manutencao               3 
.................... #define menu_debug_entrada_1                    4 
.................... #define menu_debug_entrada_2                    5 
.................... #define menu_debug_entrada_3                    6 
.................... #define menu_manutencao_outra_maquina           7 
.................... #define menu_debug_saida_1                      8 
.................... #define menu_debug_saida_2                      9 
.................... #define menu_debug_saida_3                      10 
.................... #define menu_debug_saida_4                      11 
....................  
.................... #define menu_programa_principal                 12 
....................  
.................... #define menu_edita_modelo                       13 
.................... #define menu_excluir_modelo                     14 
.................... #define menu_seleciona_pontos                   15 
.................... #define menu_dados_ponto                        16 
.................... #define menu_edita_pontos_no_modelo             17 
....................  
.................... void tela_apresentacao(void); //Tela que aparece quando liga a maquina 
.................... void tela_iniciando_maquina (void); //tela que aparece quando a maquina esta iniciando 
.................... void tela_movimentando_maquina (int posicao); //tela de movimentacao que aparece na maquina 2 
.................... void tela_esperando_mov_maquina(void); //tela esperando movimentacao da maquina 
.................... void tela_esperando_mov_outra_maquina (int posicao); //tela de espera de movimentacao da maquina 1 
.................... void tela_esperando_sair_posicao_outra_maquina(void); //tela de espera a outra maquina sair da posicao atual 
....................  
.................... void tela_principal(void); //tela principal 
.................... void tela_seleciona_maquina(void); // tela de selecao maquina 1 ou maquina 2 
.................... void tela_manutencao_outra_maquina(void); //tela de manutencao na outra maquina 
.................... void tela_edita_modelo (void); //tela que escolhe entre edicao e exclusao do modelo escolhido 
.................... void tela_seleciona_debug(void); //tela de selecao de debug: manutencao ou pontos 
.................... void tela_edita_pontos_no_modelo(void); //tela de edicao dos pontos no modelo 
.................... void tela_excluir_modelo(void); //tela que pergunta se voce quer realmente exlcuir o modelo 
.................... void tela_seleciona_pontos(void); //tela de escolha do ponto a ser editado 
.................... void tela_dados_ponto (void); //tela que mostra todos os dados do respectivo ponto da placa 
....................  
.................... void tela_seleciona_manutencao (void); //tela que mostra as opcoes sensores de entrada e atuadores de saida 
.................... void tela_debug_entrada_1 (void); //tela 1 de sensores da maquina 
.................... void tela_debug_entrada_2 (void); //tela 2 de sensores da maquina 
.................... void tela_debug_entrada_3 (void); //tela 3 de sensores da maquina 
.................... void tela_debug_saida_1(void); //tela que podemos acionar a esteira, pinos de entrada, e o alimentador de placa 
.................... void tela_debug_saida_2(void); //tela que podemos acionar o pressor da placa, pinos de saida e dispensador de placa 
.................... void tela_debug_saida_3(void); //tela que podemos acionar os alimentadores de solda, limpar os bicos e acionar os ferros 
.................... void tela_debug_saida_4(void); //tela que podemos realizar a movimentacao do eixo x, y, z e o flip individualmenta 
....................  
....................  
.................... void tela_programa_principal(void);//tela que aparece quando estamos no programa principal 
....................  
....................  
.................... void tela_apresentacao(){ 
....................     printf(lcd_putc, "\f"); //limpa display 
*
024B4:  MOVLW  0C
024B6:  MOVLB  3
024B8:  MOVWF  xBD
024BA:  MOVLB  0
024BC:  RCALL  2440
....................     printf(lcd_putc, "        ICTS        \n\r"); 
024BE:  MOVLW  02
024C0:  MOVWF  FF6
024C2:  MOVLW  01
024C4:  MOVWF  FF7
024C6:  RCALL  2494
....................     printf(lcd_putc, "  INSTITUTO CENTRO  \n\r"); 
024C8:  MOVLW  1A
024CA:  MOVWF  FF6
024CC:  MOVLW  01
024CE:  MOVWF  FF7
024D0:  RCALL  2494
....................     printf(lcd_putc, "    TECNOLOGIA EM   \n\r"); 
024D2:  MOVLW  32
024D4:  MOVWF  FF6
024D6:  MOVLW  01
024D8:  MOVWF  FF7
024DA:  RCALL  2494
....................     printf(lcd_putc, "      SOFTWARE      \n\r"); 
024DC:  MOVLW  4A
024DE:  MOVWF  FF6
024E0:  MOVLW  01
024E2:  MOVWF  FF7
024E4:  RCALL  2494
024E6:  GOTO   A8EA (RETURN)
.................... } 
.................... void tela_iniciando_maquina(){ 
....................     printf(lcd_putc, "\f"); //limpa display 
*
02610:  MOVLW  0C
02612:  MOVLB  3
02614:  MOVWF  xBD
02616:  MOVLB  0
02618:  RCALL  2440
....................     printf(lcd_putc, "     INICIANDO     \n\r"); 
0261A:  MOVLW  62
0261C:  MOVWF  FF6
0261E:  MOVLW  01
02620:  MOVWF  FF7
02622:  RCALL  2494
....................     printf(lcd_putc, "      MAQUINA     \n\r"); 
02624:  MOVLW  78
02626:  MOVWF  FF6
02628:  MOVLW  01
0262A:  MOVWF  FF7
0262C:  RCALL  2494
0262E:  GOTO   A8F2 (RETURN)
.................... } 
.................... void tela_movimentando_maquina (int posicao) { 
....................     switch (posicao){ 
*
03E1C:  MOVLB  3
03E1E:  MOVF   xB0,W
03E20:  ADDLW  F8
03E22:  BTFSC  FD8.0
03E24:  BRA    3F9C
03E26:  ADDLW  08
03E28:  MOVLB  0
03E2A:  GOTO   3FA0
....................         case ALIMENTADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
03E2E:  MOVLW  0C
03E30:  MOVLB  3
03E32:  MOVWF  xBD
03E34:  MOVLB  0
03E36:  CALL   2440
....................             printf(lcd_putc, "MOVIMENTANDO MAQUINA\n\r"); 
03E3A:  MOVLW  8E
03E3C:  MOVWF  FF6
03E3E:  MOVLW  01
03E40:  MOVWF  FF7
03E42:  CALL   2494
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
03E46:  MOVLW  A6
03E48:  MOVWF  FF6
03E4A:  MOVLW  01
03E4C:  MOVWF  FF7
03E4E:  CALL   2494
....................             printf(lcd_putc, "     ALIMENTADOR    \n\r"); 
03E52:  MOVLW  BE
03E54:  MOVWF  FF6
03E56:  MOVLW  01
03E58:  MOVWF  FF7
03E5A:  CALL   2494
....................         break; 
03E5E:  MOVLB  3
03E60:  BRA    3F9C
....................         case HOME1: 
....................             printf(lcd_putc, "\f"); //limpa display 
03E62:  MOVLW  0C
03E64:  MOVLB  3
03E66:  MOVWF  xBD
03E68:  MOVLB  0
03E6A:  CALL   2440
....................             printf(lcd_putc, "MOVIMENTANDO MAQUINA\n\r"); 
03E6E:  MOVLW  D6
03E70:  MOVWF  FF6
03E72:  MOVLW  01
03E74:  MOVWF  FF7
03E76:  CALL   2494
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
03E7A:  MOVLW  EE
03E7C:  MOVWF  FF6
03E7E:  MOVLW  01
03E80:  MOVWF  FF7
03E82:  CALL   2494
....................             printf(lcd_putc, "       HOME 1       \n\r"); 
03E86:  MOVLW  06
03E88:  MOVWF  FF6
03E8A:  MOVLW  02
03E8C:  MOVWF  FF7
03E8E:  CALL   2494
....................         break; 
03E92:  MOVLB  3
03E94:  BRA    3F9C
....................         case SOLDAGEM: 
....................             printf(lcd_putc, "\f"); //limpa display 
03E96:  MOVLW  0C
03E98:  MOVLB  3
03E9A:  MOVWF  xBD
03E9C:  MOVLB  0
03E9E:  CALL   2440
....................             printf(lcd_putc, "MOVIMENTANDO MAQUINA\n\r"); 
03EA2:  MOVLW  1E
03EA4:  MOVWF  FF6
03EA6:  MOVLW  02
03EA8:  MOVWF  FF7
03EAA:  CALL   2494
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
03EAE:  MOVLW  36
03EB0:  MOVWF  FF6
03EB2:  MOVLW  02
03EB4:  MOVWF  FF7
03EB6:  CALL   2494
....................             printf(lcd_putc, "      SOLDAGEM     \n\r"); 
03EBA:  MOVLW  4E
03EBC:  MOVWF  FF6
03EBE:  MOVLW  02
03EC0:  MOVWF  FF7
03EC2:  CALL   2494
....................         break; 
03EC6:  MOVLB  3
03EC8:  BRA    3F9C
....................         case HOME2: 
....................             printf(lcd_putc, "\f"); //limpa display 
03ECA:  MOVLW  0C
03ECC:  MOVLB  3
03ECE:  MOVWF  xBD
03ED0:  MOVLB  0
03ED2:  CALL   2440
....................             printf(lcd_putc, "MOVIMENTANDO MAQUINA\n\r"); 
03ED6:  MOVLW  64
03ED8:  MOVWF  FF6
03EDA:  MOVLW  02
03EDC:  MOVWF  FF7
03EDE:  CALL   2494
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
03EE2:  MOVLW  7C
03EE4:  MOVWF  FF6
03EE6:  MOVLW  02
03EE8:  MOVWF  FF7
03EEA:  CALL   2494
....................             printf(lcd_putc, "       HOME 2       \n\r"); 
03EEE:  MOVLW  94
03EF0:  MOVWF  FF6
03EF2:  MOVLW  02
03EF4:  MOVWF  FF7
03EF6:  CALL   2494
....................         break; 
03EFA:  MOVLB  3
03EFC:  BRA    3F9C
....................         case DISPENSADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
03EFE:  MOVLW  0C
03F00:  MOVLB  3
03F02:  MOVWF  xBD
03F04:  MOVLB  0
03F06:  CALL   2440
....................             printf(lcd_putc, "MOVIMENTANDO MAQUINA\n\r"); 
03F0A:  MOVLW  AC
03F0C:  MOVWF  FF6
03F0E:  MOVLW  02
03F10:  MOVWF  FF7
03F12:  CALL   2494
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
03F16:  MOVLW  C4
03F18:  MOVWF  FF6
03F1A:  MOVLW  02
03F1C:  MOVWF  FF7
03F1E:  CALL   2494
....................             printf(lcd_putc, "    DISPENSADOR     \n\r"); 
03F22:  MOVLW  DC
03F24:  MOVWF  FF6
03F26:  MOVLW  02
03F28:  MOVWF  FF7
03F2A:  CALL   2494
....................         break; 
03F2E:  MOVLB  3
03F30:  BRA    3F9C
....................         case LIMPEZA: 
....................             printf(lcd_putc, "\f"); //limpa display 
03F32:  MOVLW  0C
03F34:  MOVLB  3
03F36:  MOVWF  xBD
03F38:  MOVLB  0
03F3A:  CALL   2440
....................             printf(lcd_putc, "MOVIMENTANDO MAQUINA\n\r"); 
03F3E:  MOVLW  F4
03F40:  MOVWF  FF6
03F42:  MOVLW  02
03F44:  MOVWF  FF7
03F46:  CALL   2494
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
03F4A:  MOVLW  0C
03F4C:  MOVWF  FF6
03F4E:  MOVLW  03
03F50:  MOVWF  FF7
03F52:  CALL   2494
....................             printf(lcd_putc, "       LIMPEZA      \n\r"); 
03F56:  MOVLW  24
03F58:  MOVWF  FF6
03F5A:  MOVLW  03
03F5C:  MOVWF  FF7
03F5E:  CALL   2494
....................         break; 
03F62:  MOVLB  3
03F64:  BRA    3F9C
....................         case LIMPEZA_2: 
....................             printf(lcd_putc, "\f"); //limpa display 
03F66:  MOVLW  0C
03F68:  MOVLB  3
03F6A:  MOVWF  xBD
03F6C:  MOVLB  0
03F6E:  CALL   2440
....................             printf(lcd_putc, "MOVIMENTANDO MAQUINA\n\r"); 
03F72:  MOVLW  3C
03F74:  MOVWF  FF6
03F76:  MOVLW  03
03F78:  MOVWF  FF7
03F7A:  CALL   2494
....................             printf(lcd_putc, "    PARA POSICAO    \n\r"); 
03F7E:  MOVLW  54
03F80:  MOVWF  FF6
03F82:  MOVLW  03
03F84:  MOVWF  FF7
03F86:  CALL   2494
....................             printf(lcd_putc, "     LIMPEZA_2      \n\r"); 
03F8A:  MOVLW  6C
03F8C:  MOVWF  FF6
03F8E:  MOVLW  03
03F90:  MOVWF  FF7
03F92:  CALL   2494
....................         break; 
03F96:  MOVLB  3
03F98:  BRA    3F9C
03F9A:  MOVLB  3
....................     } 
03F9C:  MOVLB  0
03F9E:  RETURN 0
.................... } 
.................... void tela_esperando_mov_maquina(void) { 
....................     printf(lcd_putc, "\f"); //limpa display 
*
0579C:  MOVLW  0C
0579E:  MOVLB  3
057A0:  MOVWF  xBD
057A2:  MOVLB  0
057A4:  CALL   2440
....................     printf(lcd_putc, "  ESPERANDO MAQUINA \n\r"); 
057A8:  MOVLW  84
057AA:  MOVWF  FF6
057AC:  MOVLW  03
057AE:  MOVWF  FF7
057B0:  CALL   2494
....................     printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
057B4:  MOVLW  9C
057B6:  MOVWF  FF6
057B8:  MOVLW  03
057BA:  MOVWF  FF7
057BC:  CALL   2494
....................     printf(lcd_putc, "    PRE-REQUISITO   \n\r"); 
057C0:  MOVLW  B4
057C2:  MOVWF  FF6
057C4:  MOVLW  03
057C6:  MOVWF  FF7
057C8:  CALL   2494
057CC:  RETURN 0
.................... } 
.................... void tela_esperando_mov_outra_maquina(int posicao) { 
....................     switch (posicao){ 
*
03C12:  MOVLB  3
03C14:  MOVF   xB0,W
03C16:  ADDLW  F8
03C18:  BTFSC  FD8.0
03C1A:  BRA    3DE2
03C1C:  ADDLW  08
03C1E:  MOVLB  0
03C20:  GOTO   3DE8
....................         case ALIMENTADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
03C24:  MOVLW  0C
03C26:  MOVLB  3
03C28:  MOVWF  xBD
03C2A:  MOVLB  0
03C2C:  CALL   2440
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
03C30:  MOVLW  CC
03C32:  MOVWF  FF6
03C34:  MOVLW  03
03C36:  MOVWF  FF7
03C38:  CALL   2494
....................             printf(lcd_putc, "       MAQUINA      \n\r"); 
03C3C:  MOVLW  E4
03C3E:  MOVWF  FF6
03C40:  MOVLW  03
03C42:  MOVWF  FF7
03C44:  CALL   2494
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
03C48:  MOVLW  FC
03C4A:  MOVWF  FF6
03C4C:  MOVLW  03
03C4E:  MOVWF  FF7
03C50:  CALL   2494
....................             printf(lcd_putc, "     ALIMENTADOR    \n\r"); 
03C54:  MOVLW  14
03C56:  MOVWF  FF6
03C58:  MOVLW  04
03C5A:  MOVWF  FF7
03C5C:  CALL   2494
....................         case HOME1: 
....................             printf(lcd_putc, "\f"); //limpa display 
03C60:  MOVLW  0C
03C62:  MOVLB  3
03C64:  MOVWF  xBD
03C66:  MOVLB  0
03C68:  CALL   2440
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
03C6C:  MOVLW  2C
03C6E:  MOVWF  FF6
03C70:  MOVLW  04
03C72:  MOVWF  FF7
03C74:  CALL   2494
....................             printf(lcd_putc, "       MAQUINA      \n\r"); 
03C78:  MOVLW  44
03C7A:  MOVWF  FF6
03C7C:  MOVLW  04
03C7E:  MOVWF  FF7
03C80:  CALL   2494
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
03C84:  MOVLW  5C
03C86:  MOVWF  FF6
03C88:  MOVLW  04
03C8A:  MOVWF  FF7
03C8C:  CALL   2494
....................             printf(lcd_putc, "       HOME 1       \n\r"); 
03C90:  MOVLW  74
03C92:  MOVWF  FF6
03C94:  MOVLW  04
03C96:  MOVWF  FF7
03C98:  CALL   2494
....................         break; 
03C9C:  MOVLB  3
03C9E:  BRA    3DE2
....................         case SOLDAGEM: 
....................             printf(lcd_putc, "\f"); //limpa display 
03CA0:  MOVLW  0C
03CA2:  MOVLB  3
03CA4:  MOVWF  xBD
03CA6:  MOVLB  0
03CA8:  CALL   2440
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
03CAC:  MOVLW  8C
03CAE:  MOVWF  FF6
03CB0:  MOVLW  04
03CB2:  MOVWF  FF7
03CB4:  CALL   2494
....................             printf(lcd_putc, "       MAQUINA      \n\r"); 
03CB8:  MOVLW  A4
03CBA:  MOVWF  FF6
03CBC:  MOVLW  04
03CBE:  MOVWF  FF7
03CC0:  CALL   2494
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
03CC4:  MOVLW  BC
03CC6:  MOVWF  FF6
03CC8:  MOVLW  04
03CCA:  MOVWF  FF7
03CCC:  CALL   2494
....................             printf(lcd_putc, "     SOLDAGEM 1     \n\r"); 
03CD0:  MOVLW  D4
03CD2:  MOVWF  FF6
03CD4:  MOVLW  04
03CD6:  MOVWF  FF7
03CD8:  CALL   2494
....................         break; 
03CDC:  MOVLB  3
03CDE:  BRA    3DE2
....................         case HOME2: 
....................             printf(lcd_putc, "\f"); //limpa display 
03CE0:  MOVLW  0C
03CE2:  MOVLB  3
03CE4:  MOVWF  xBD
03CE6:  MOVLB  0
03CE8:  CALL   2440
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
03CEC:  MOVLW  EC
03CEE:  MOVWF  FF6
03CF0:  MOVLW  04
03CF2:  MOVWF  FF7
03CF4:  CALL   2494
....................             printf(lcd_putc, "       MAQUINA      \n\r"); 
03CF8:  MOVLW  04
03CFA:  MOVWF  FF6
03CFC:  MOVLW  05
03CFE:  MOVWF  FF7
03D00:  CALL   2494
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
03D04:  MOVLW  1C
03D06:  MOVWF  FF6
03D08:  MOVLW  05
03D0A:  MOVWF  FF7
03D0C:  CALL   2494
....................             printf(lcd_putc, "       HOME 2       \n\r"); 
03D10:  MOVLW  34
03D12:  MOVWF  FF6
03D14:  MOVLW  05
03D16:  MOVWF  FF7
03D18:  CALL   2494
....................         break; 
03D1C:  MOVLB  3
03D1E:  BRA    3DE2
....................         case DISPENSADOR: 
....................             printf(lcd_putc, "\f"); //limpa display 
03D20:  MOVLW  0C
03D22:  MOVLB  3
03D24:  MOVWF  xBD
03D26:  MOVLB  0
03D28:  CALL   2440
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
03D2C:  MOVLW  4C
03D2E:  MOVWF  FF6
03D30:  MOVLW  05
03D32:  MOVWF  FF7
03D34:  CALL   2494
....................             printf(lcd_putc, "       MAQUINA      \n\r"); 
03D38:  MOVLW  64
03D3A:  MOVWF  FF6
03D3C:  MOVLW  05
03D3E:  MOVWF  FF7
03D40:  CALL   2494
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
03D44:  MOVLW  7C
03D46:  MOVWF  FF6
03D48:  MOVLW  05
03D4A:  MOVWF  FF7
03D4C:  CALL   2494
....................             printf(lcd_putc, "     DISPENSADOR    \n\r"); 
03D50:  MOVLW  94
03D52:  MOVWF  FF6
03D54:  MOVLW  05
03D56:  MOVWF  FF7
03D58:  CALL   2494
....................         break; 
03D5C:  MOVLB  3
03D5E:  BRA    3DE2
....................         case LIMPEZA: 
....................             printf(lcd_putc, "\f"); //limpa display 
03D60:  MOVLW  0C
03D62:  MOVLB  3
03D64:  MOVWF  xBD
03D66:  MOVLB  0
03D68:  CALL   2440
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
03D6C:  MOVLW  AC
03D6E:  MOVWF  FF6
03D70:  MOVLW  05
03D72:  MOVWF  FF7
03D74:  CALL   2494
....................             printf(lcd_putc, "       MAQUINA      \n\r"); 
03D78:  MOVLW  C4
03D7A:  MOVWF  FF6
03D7C:  MOVLW  05
03D7E:  MOVWF  FF7
03D80:  CALL   2494
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
03D84:  MOVLW  DC
03D86:  MOVWF  FF6
03D88:  MOVLW  05
03D8A:  MOVWF  FF7
03D8C:  CALL   2494
....................             printf(lcd_putc, "       LIMPEZA      \n\r"); 
03D90:  MOVLW  F4
03D92:  MOVWF  FF6
03D94:  MOVLW  05
03D96:  MOVWF  FF7
03D98:  CALL   2494
....................         break; 
03D9C:  MOVLB  3
03D9E:  BRA    3DE2
....................         case LIMPEZA_2: 
....................             printf(lcd_putc, "\f"); //limpa display 
03DA0:  MOVLW  0C
03DA2:  MOVLB  3
03DA4:  MOVWF  xBD
03DA6:  MOVLB  0
03DA8:  CALL   2440
....................             printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
03DAC:  MOVLW  0C
03DAE:  MOVWF  FF6
03DB0:  MOVLW  06
03DB2:  MOVWF  FF7
03DB4:  CALL   2494
....................             printf(lcd_putc, "       MAQUINA      \n\r"); 
03DB8:  MOVLW  24
03DBA:  MOVWF  FF6
03DBC:  MOVLW  06
03DBE:  MOVWF  FF7
03DC0:  CALL   2494
....................             printf(lcd_putc, "   IR PARA POSICAO  \n\r"); 
03DC4:  MOVLW  3C
03DC6:  MOVWF  FF6
03DC8:  MOVLW  06
03DCA:  MOVWF  FF7
03DCC:  CALL   2494
....................             printf(lcd_putc, "      LIMPEZA_2     \n\r"); 
03DD0:  MOVLW  54
03DD2:  MOVWF  FF6
03DD4:  MOVLW  06
03DD6:  MOVWF  FF7
03DD8:  CALL   2494
....................         break; 
03DDC:  MOVLB  3
03DDE:  BRA    3DE2
03DE0:  MOVLB  3
....................     } 
03DE2:  MOVLB  0
03DE4:  GOTO   4D14 (RETURN)
.................... } 
.................... void tela_esperando_sair_posicao_outra_maquina(void){ 
....................     printf(lcd_putc, "\f"); //limpa display 
*
057CE:  MOVLW  0C
057D0:  MOVLB  3
057D2:  MOVWF  xBD
057D4:  MOVLB  0
057D6:  CALL   2440
....................     printf(lcd_putc, "   ESPERANDO OUTRA  \n\r"); 
057DA:  MOVLW  6C
057DC:  MOVWF  FF6
057DE:  MOVLW  06
057E0:  MOVWF  FF7
057E2:  CALL   2494
....................     printf(lcd_putc, "       MAQUINA      \n\r"); 
057E6:  MOVLW  84
057E8:  MOVWF  FF6
057EA:  MOVLW  06
057EC:  MOVWF  FF7
057EE:  CALL   2494
....................     printf(lcd_putc, "   SAIR DA POSICAO  \n\r"); 
057F2:  MOVLW  9C
057F4:  MOVWF  FF6
057F6:  MOVLW  06
057F8:  MOVWF  FF7
057FA:  CALL   2494
....................     printf(lcd_putc, "        ATUAL       \n\r"); 
057FE:  MOVLW  B4
05800:  MOVWF  FF6
05802:  MOVLW  06
05804:  MOVWF  FF7
05806:  CALL   2494
0580A:  RETURN 0
.................... } 
....................  
.................... void tela_principal() { 
....................     printf(lcd_putc, "\f"); // limpa display 
*
04ECE:  MOVLW  0C
04ED0:  MOVLB  3
04ED2:  MOVWF  xBD
04ED4:  MOVLB  0
04ED6:  CALL   2440
....................     printf(lcd_putc, " SOLDADOR AUTOMATICO\n\r"); 
04EDA:  MOVLW  CC
04EDC:  MOVWF  FF6
04EDE:  MOVLW  06
04EE0:  MOVWF  FF7
04EE2:  CALL   2494
....................     printf(lcd_putc, "      MODELO:%02u   \n\r",modelo); 
04EE6:  MOVLW  E4
04EE8:  MOVWF  FF6
04EEA:  MOVLW  06
04EEC:  MOVWF  FF7
04EEE:  MOVLW  0D
04EF0:  MOVLB  3
04EF2:  MOVWF  xB4
04EF4:  MOVLB  0
04EF6:  RCALL  4DF6
04EF8:  MOVFF  2D,3B1
04EFC:  MOVLW  01
04EFE:  MOVLB  3
04F00:  MOVWF  xB2
04F02:  MOVLB  0
04F04:  RCALL  4E4C
04F06:  MOVLW  F5
04F08:  MOVWF  FF6
04F0A:  MOVLW  06
04F0C:  MOVWF  FF7
04F0E:  MOVLW  05
04F10:  MOVLB  3
04F12:  MOVWF  xB4
04F14:  MOVLB  0
04F16:  RCALL  4DF6
....................     printf(lcd_putc, "^/?:MODELO|MENU:DBUG\n\r"); 
04F18:  MOVLW  FC
04F1A:  MOVWF  FF6
04F1C:  MOVLW  06
04F1E:  MOVWF  FF7
04F20:  CALL   2494
....................     printf(lcd_putc, "     ENTER:MAIN     \n\r"); 
04F24:  MOVLW  14
04F26:  MOVWF  FF6
04F28:  MOVLW  07
04F2A:  MOVWF  FF7
04F2C:  CALL   2494
04F30:  RETURN 0
.................... } 
.................... void tela_seleciona_maquina(){ 
....................     printf(lcd_putc, "\f"); 
*
054DE:  MOVLW  0C
054E0:  MOVLB  3
054E2:  MOVWF  xBD
054E4:  MOVLB  0
054E6:  CALL   2440
....................     printf(lcd_putc, " SELECIONE A MAQUINA\n\r"); 
054EA:  MOVLW  2C
054EC:  MOVWF  FF6
054EE:  MOVLW  07
054F0:  MOVWF  FF7
054F2:  CALL   2494
....................     printf(lcd_putc, "    F1: MAQUINA 1   \n\r"); 
054F6:  MOVLW  44
054F8:  MOVWF  FF6
054FA:  MOVLW  07
054FC:  MOVWF  FF7
054FE:  CALL   2494
....................     printf(lcd_putc, "    F2: MAQUINA 2   \n\r"); 
05502:  MOVLW  5C
05504:  MOVWF  FF6
05506:  MOVLW  07
05508:  MOVWF  FF7
0550A:  CALL   2494
....................     printf(lcd_putc, "    ESC:BACK        \n\r"); 
0550E:  MOVLW  74
05510:  MOVWF  FF6
05512:  MOVLW  07
05514:  MOVWF  FF7
05516:  CALL   2494
0551A:  RETURN 0
.................... } 
.................... void tela_manutencao_outra_maquina() { 
....................     printf(lcd_putc, "\f"); // limpa display 
*
063D2:  MOVLW  0C
063D4:  MOVLB  3
063D6:  MOVWF  xBD
063D8:  MOVLB  0
063DA:  CALL   2440
....................     printf(lcd_putc, "     MANUTENCAO     \n\r"); 
063DE:  MOVLW  8C
063E0:  MOVWF  FF6
063E2:  MOVLW  07
063E4:  MOVWF  FF7
063E6:  CALL   2494
....................     printf(lcd_putc, "      MAQUINA 2     \n\r"); 
063EA:  MOVLW  A4
063EC:  MOVWF  FF6
063EE:  MOVLW  07
063F0:  MOVWF  FF7
063F2:  CALL   2494
....................     printf(lcd_putc, "                    \n\r"); 
063F6:  MOVLW  BC
063F8:  MOVWF  FF6
063FA:  MOVLW  07
063FC:  MOVWF  FF7
063FE:  CALL   2494
....................     printf(lcd_putc, "      ESC:BACK      \n\r"); 
06402:  MOVLW  D4
06404:  MOVWF  FF6
06406:  MOVLW  07
06408:  MOVWF  FF7
0640A:  CALL   2494
0640E:  GOTO   643E (RETURN)
.................... } 
.................... void tela_edita_modelo(){ 
....................     printf(lcd_putc, "\f"); 
*
05604:  MOVLW  0C
05606:  MOVLB  3
05608:  MOVWF  xBD
0560A:  MOVLB  0
0560C:  CALL   2440
....................     printf(lcd_putc, "    ESCOLHER ACAO   \n\r"); 
05610:  MOVLW  EC
05612:  MOVWF  FF6
05614:  MOVLW  07
05616:  MOVWF  FF7
05618:  CALL   2494
....................     printf(lcd_putc, "  F1: EDITAR MODELO \n\r"); 
0561C:  MOVLW  04
0561E:  MOVWF  FF6
05620:  MOVLW  08
05622:  MOVWF  FF7
05624:  CALL   2494
....................     printf(lcd_putc, "  F2: EXCLUI MODELO \n\r"); 
05628:  MOVLW  1C
0562A:  MOVWF  FF6
0562C:  MOVLW  08
0562E:  MOVWF  FF7
05630:  CALL   2494
....................     printf(lcd_putc, "  ESC:BACK          \n\r"); 
05634:  MOVLW  34
05636:  MOVWF  FF6
05638:  MOVLW  08
0563A:  MOVWF  FF7
0563C:  CALL   2494
05640:  RETURN 0
.................... } 
.................... void tela_seleciona_debug(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
06470:  MOVLW  0C
06472:  MOVLB  3
06474:  MOVWF  xBD
06476:  MOVLB  0
06478:  CALL   2440
....................     printf(lcd_putc, "  F1: EDITAR PONTOS \n\r"); 
0647C:  MOVLW  4C
0647E:  MOVWF  FF6
06480:  MOVLW  08
06482:  MOVWF  FF7
06484:  CALL   2494
....................     printf(lcd_putc, "  F2: MANUTENCAO    \n\r"); 
06488:  MOVLW  64
0648A:  MOVWF  FF6
0648C:  MOVLW  08
0648E:  MOVWF  FF7
06490:  CALL   2494
....................     printf(lcd_putc, "  F3: QNT_PONTOS    \n\r"); 
06494:  MOVLW  7C
06496:  MOVWF  FF6
06498:  MOVLW  08
0649A:  MOVWF  FF7
0649C:  CALL   2494
....................     printf(lcd_putc, "  ESC:BACK          \n\r"); 
064A0:  MOVLW  94
064A2:  MOVWF  FF6
064A4:  MOVLW  08
064A6:  MOVWF  FF7
064A8:  CALL   2494
064AC:  RETURN 0
.................... } 
.................... void tela_edita_pontos_no_modelo(){ 
....................     printf(lcd_putc, "\f"); 
*
06668:  MOVLW  0C
0666A:  MOVLB  3
0666C:  MOVWF  xBD
0666E:  MOVLB  0
06670:  CALL   2440
....................     printf(lcd_putc, "  PONTOS NO MODELO  \n\r"); 
06674:  MOVLW  AC
06676:  MOVWF  FF6
06678:  MOVLW  08
0667A:  MOVWF  FF7
0667C:  CALL   2494
....................     printf(lcd_putc, "         %02u       \n\r",pontos_no_modelo); 
06680:  MOVLW  C4
06682:  MOVWF  FF6
06684:  MOVLW  08
06686:  MOVWF  FF7
06688:  MOVLW  09
0668A:  MOVLB  3
0668C:  MOVWF  xB4
0668E:  MOVLB  0
06690:  CALL   4DF6
06694:  MOVFF  10A,3B1
06698:  MOVLW  01
0669A:  MOVLB  3
0669C:  MOVWF  xB2
0669E:  MOVLB  0
066A0:  CALL   4E4C
066A4:  MOVLW  D1
066A6:  MOVWF  FF6
066A8:  MOVLW  08
066AA:  MOVWF  FF7
066AC:  MOVLW  09
066AE:  MOVLB  3
066B0:  MOVWF  xB4
066B2:  MOVLB  0
066B4:  CALL   4DF6
....................     printf(lcd_putc, "    ?/?:N_PONTOS   \n\r"); 
066B8:  MOVLW  DC
066BA:  MOVWF  FF6
066BC:  MOVLW  08
066BE:  MOVWF  FF7
066C0:  CALL   2494
....................     printf(lcd_putc, " ENTER:SAVE|ESC:BACK\n\r"); 
066C4:  MOVLW  F2
066C6:  MOVWF  FF6
066C8:  MOVLW  08
066CA:  MOVWF  FF7
066CC:  CALL   2494
066D0:  RETURN 0
.................... } 
.................... void tela_excluir_modelo(){ 
....................     printf(lcd_putc, "\f"); 
*
064AE:  MOVLW  0C
064B0:  MOVLB  3
064B2:  MOVWF  xBD
064B4:  MOVLB  0
064B6:  CALL   2440
....................     printf(lcd_putc, "   DESEJA EXCLUIR   \n\r"); 
064BA:  MOVLW  0A
064BC:  MOVWF  FF6
064BE:  MOVLW  09
064C0:  MOVWF  FF7
064C2:  CALL   2494
....................     printf(lcd_putc, "     O MODELO ?     \n\r"); 
064C6:  MOVLW  22
064C8:  MOVWF  FF6
064CA:  MOVLW  09
064CC:  MOVWF  FF7
064CE:  CALL   2494
....................     printf(lcd_putc, "      ENTER=OK      \n\r"); 
064D2:  MOVLW  3A
064D4:  MOVWF  FF6
064D6:  MOVLW  09
064D8:  MOVWF  FF7
064DA:  CALL   2494
....................     printf(lcd_putc, "    ESC:NO/BACK     \n\r"); 
064DE:  MOVLW  52
064E0:  MOVWF  FF6
064E2:  MOVLW  09
064E4:  MOVWF  FF7
064E6:  CALL   2494
064EA:  GOTO   651A (RETURN)
.................... } 
.................... void tela_seleciona_pontos(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0652E:  MOVLW  0C
06530:  MOVLB  3
06532:  MOVWF  xBD
06534:  MOVLB  0
06536:  CALL   2440
....................     printf(lcd_putc, "P%02u         ENT=EDIT\n\r",inicial_lcd); 
0653A:  MOVLW  50
0653C:  MOVLB  3
0653E:  MOVWF  xBD
06540:  MOVLB  0
06542:  CALL   2440
06546:  MOVFF  22,3B1
0654A:  MOVLW  01
0654C:  MOVLB  3
0654E:  MOVWF  xB2
06550:  MOVLB  0
06552:  CALL   4E4C
06556:  MOVLW  6F
06558:  MOVWF  FF6
0655A:  MOVLW  09
0655C:  MOVWF  FF7
0655E:  MOVLW  13
06560:  MOVLB  3
06562:  MOVWF  xB4
06564:  MOVLB  0
06566:  CALL   4DF6
....................     printf(lcd_putc, "P%02u         ESC=BACK\n\r",inicial_lcd+1); 
0656A:  MOVLW  01
0656C:  ADDWF  22,W
0656E:  MOVLB  3
06570:  MOVWF  xAD
06572:  MOVLW  50
06574:  MOVWF  xBD
06576:  MOVLB  0
06578:  CALL   2440
0657C:  MOVFF  3AD,3B1
06580:  MOVLW  01
06582:  MOVLB  3
06584:  MOVWF  xB2
06586:  MOVLB  0
06588:  CALL   4E4C
0658C:  MOVLW  89
0658E:  MOVWF  FF6
06590:  MOVLW  09
06592:  MOVWF  FF7
06594:  MOVLW  13
06596:  MOVLB  3
06598:  MOVWF  xB4
0659A:  MOVLB  0
0659C:  CALL   4DF6
....................     printf(lcd_putc, "P%02u                 \n\r",inicial_lcd+2); 
065A0:  MOVLW  02
065A2:  ADDWF  22,W
065A4:  MOVLB  3
065A6:  MOVWF  xAD
065A8:  MOVLW  50
065AA:  MOVWF  xBD
065AC:  MOVLB  0
065AE:  CALL   2440
065B2:  MOVFF  3AD,3B1
065B6:  MOVLW  01
065B8:  MOVLB  3
065BA:  MOVWF  xB2
065BC:  MOVLB  0
065BE:  CALL   4E4C
065C2:  MOVLW  A3
065C4:  MOVWF  FF6
065C6:  MOVLW  09
065C8:  MOVWF  FF7
065CA:  MOVLW  13
065CC:  MOVLB  3
065CE:  MOVWF  xB4
065D0:  MOVLB  0
065D2:  CALL   4DF6
....................     printf(lcd_putc, "P%02u                 \n\r",inicial_lcd+3); 
065D6:  MOVLW  03
065D8:  ADDWF  22,W
065DA:  MOVLB  3
065DC:  MOVWF  xAD
065DE:  MOVLW  50
065E0:  MOVWF  xBD
065E2:  MOVLB  0
065E4:  CALL   2440
065E8:  MOVFF  3AD,3B1
065EC:  MOVLW  01
065EE:  MOVLB  3
065F0:  MOVWF  xB2
065F2:  MOVLB  0
065F4:  CALL   4E4C
065F8:  MOVLW  BD
065FA:  MOVWF  FF6
065FC:  MOVLW  09
065FE:  MOVWF  FF7
06600:  MOVLW  13
06602:  MOVLB  3
06604:  MOVWF  xB4
06606:  MOVLB  0
06608:  CALL   4DF6
....................     posiciona_cursor(ponteiro_lcd,5); 
0660C:  MOVFF  21,3BE
06610:  MOVLW  05
06612:  MOVLB  3
06614:  MOVWF  xBF
06616:  MOVLB  0
06618:  CALL   229A
....................     printf(lcd_putc,"<"); 
0661C:  MOVLW  3C
0661E:  MOVLB  3
06620:  MOVWF  xBD
06622:  MOVLB  0
06624:  CALL   2440
06628:  RETURN 0
.................... } 
.................... void tela_dados_ponto (contador_lcd){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
068B0:  MOVLW  0C
068B2:  MOVLB  3
068B4:  MOVWF  xBD
068B6:  MOVLB  0
068B8:  CALL   2440
....................     printf(lcd_putc, "X:%04Lu Y:%04Lu Z:%04Lu\n\r",x[contador_lcd],y[contador_lcd],z[contador_lcd]); 
068BC:  BCF    FD8.0
068BE:  MOVLB  3
068C0:  RLCF   xAD,W
068C2:  CLRF   03
068C4:  ADDLW  2E
068C6:  MOVWF  FE9
068C8:  MOVLW  00
068CA:  ADDWFC 03,W
068CC:  MOVWF  FEA
068CE:  MOVFF  FEC,3AF
068D2:  MOVF   FED,F
068D4:  MOVFF  FEF,3AE
068D8:  BCF    FD8.0
068DA:  RLCF   xAD,W
068DC:  CLRF   03
068DE:  ADDLW  56
068E0:  MOVWF  FE9
068E2:  MOVLW  00
068E4:  ADDWFC 03,W
068E6:  MOVWF  FEA
068E8:  MOVFF  FEC,3B1
068EC:  MOVF   FED,F
068EE:  MOVFF  FEF,3B0
068F2:  BCF    FD8.0
068F4:  RLCF   xAD,W
068F6:  CLRF   03
068F8:  ADDLW  7E
068FA:  MOVWF  FE9
068FC:  MOVLW  00
068FE:  ADDWFC 03,W
06900:  MOVWF  FEA
06902:  MOVFF  FEC,3B3
06906:  MOVF   FED,F
06908:  MOVFF  FEF,3B2
0690C:  MOVLW  58
0690E:  MOVWF  xBD
06910:  MOVLB  0
06912:  CALL   2440
06916:  MOVLW  3A
06918:  MOVLB  3
0691A:  MOVWF  xBD
0691C:  MOVLB  0
0691E:  CALL   2440
06922:  MOVLW  09
06924:  MOVWF  FE9
06926:  MOVFF  3AF,3B5
0692A:  MOVFF  3AE,3B4
0692E:  RCALL  67F2
06930:  MOVLW  D9
06932:  MOVWF  FF6
06934:  MOVLW  09
06936:  MOVWF  FF7
06938:  MOVLW  03
0693A:  MOVLB  3
0693C:  MOVWF  xB4
0693E:  MOVLB  0
06940:  CALL   4DF6
06944:  MOVLW  09
06946:  MOVWF  FE9
06948:  MOVFF  3B1,3B5
0694C:  MOVFF  3B0,3B4
06950:  RCALL  67F2
06952:  MOVLW  E1
06954:  MOVWF  FF6
06956:  MOVLW  09
06958:  MOVWF  FF7
0695A:  MOVLW  03
0695C:  MOVLB  3
0695E:  MOVWF  xB4
06960:  MOVLB  0
06962:  CALL   4DF6
06966:  MOVLW  09
06968:  MOVWF  FE9
0696A:  MOVFF  3B3,3B5
0696E:  MOVFF  3B2,3B4
06972:  RCALL  67F2
06974:  MOVLW  0A
06976:  MOVLB  3
06978:  MOVWF  xBD
0697A:  MOVLB  0
0697C:  CALL   2440
06980:  MOVLW  0D
06982:  MOVLB  3
06984:  MOVWF  xBD
06986:  MOVLB  0
06988:  CALL   2440
....................     printf(lcd_putc, "  T_S:%04Lu T_E:%04Lu \n\r",t_solda[contador_lcd],t_wait[contador_lcd]); 
0698C:  BCF    FD8.0
0698E:  MOVLB  3
06990:  RLCF   xAD,W
06992:  CLRF   03
06994:  ADDLW  A6
06996:  MOVWF  FE9
06998:  MOVLW  00
0699A:  ADDWFC 03,W
0699C:  MOVWF  FEA
0699E:  MOVFF  FEC,3AF
069A2:  MOVF   FED,F
069A4:  MOVFF  FEF,3AE
069A8:  BCF    FD8.0
069AA:  RLCF   xAD,W
069AC:  CLRF   03
069AE:  ADDLW  CE
069B0:  MOVWF  FE9
069B2:  MOVLW  00
069B4:  ADDWFC 03,W
069B6:  MOVWF  FEA
069B8:  MOVFF  FEC,3B1
069BC:  MOVF   FED,F
069BE:  MOVFF  FEF,3B0
069C2:  MOVLW  EC
069C4:  MOVWF  FF6
069C6:  MOVLW  09
069C8:  MOVWF  FF7
069CA:  MOVLW  06
069CC:  MOVWF  xB4
069CE:  MOVLB  0
069D0:  CALL   4DF6
069D4:  MOVLW  09
069D6:  MOVWF  FE9
069D8:  MOVFF  3AF,3B5
069DC:  MOVFF  3AE,3B4
069E0:  RCALL  67F2
069E2:  MOVLW  F7
069E4:  MOVWF  FF6
069E6:  MOVLW  09
069E8:  MOVWF  FF7
069EA:  MOVLW  05
069EC:  MOVLB  3
069EE:  MOVWF  xB4
069F0:  MOVLB  0
069F2:  CALL   4DF6
069F6:  MOVLW  09
069F8:  MOVWF  FE9
069FA:  MOVFF  3B1,3B5
069FE:  MOVFF  3B0,3B4
06A02:  RCALL  67F2
06A04:  MOVLW  01
06A06:  MOVWF  FF6
06A08:  MOVLW  0A
06A0A:  MOVWF  FF7
06A0C:  MOVLW  03
06A0E:  MOVLB  3
06A10:  MOVWF  xB4
06A12:  MOVLB  0
06A14:  CALL   4DF6
....................     printf(lcd_putc, "   TIPO:%02u HAB:%02u   \n\r",tipo[contador_lcd],habilitado[contador_lcd]); 
06A18:  CLRF   03
06A1A:  MOVLB  3
06A1C:  MOVF   xAD,W
06A1E:  ADDLW  F6
06A20:  MOVWF  FE9
06A22:  MOVLW  00
06A24:  ADDWFC 03,W
06A26:  MOVWF  FEA
06A28:  MOVFF  FEF,3AE
06A2C:  MOVFF  3AD,3B5
06A30:  MOVLW  01
06A32:  MOVWF  xB7
06A34:  MOVLW  0B
06A36:  MOVWF  xB6
06A38:  MOVLB  0
06A3A:  CALL   3A66
06A3E:  MOVLW  00
06A40:  BTFSC  01.0
06A42:  MOVLW  01
06A44:  MOVLB  3
06A46:  MOVWF  xAF
06A48:  MOVLW  06
06A4A:  MOVWF  FF6
06A4C:  MOVLW  0A
06A4E:  MOVWF  FF7
06A50:  MOVLW  08
06A52:  MOVWF  xB4
06A54:  MOVLB  0
06A56:  CALL   4DF6
06A5A:  MOVFF  3AE,3B1
06A5E:  MOVLW  01
06A60:  MOVLB  3
06A62:  MOVWF  xB2
06A64:  MOVLB  0
06A66:  CALL   4E4C
06A6A:  MOVLW  12
06A6C:  MOVWF  FF6
06A6E:  MOVLW  0A
06A70:  MOVWF  FF7
06A72:  MOVLW  05
06A74:  MOVLB  3
06A76:  MOVWF  xB4
06A78:  MOVLB  0
06A7A:  CALL   4DF6
06A7E:  MOVFF  3AF,3B1
06A82:  MOVLW  01
06A84:  MOVLB  3
06A86:  MOVWF  xB2
06A88:  MOVLB  0
06A8A:  CALL   4E4C
06A8E:  MOVLW  1B
06A90:  MOVWF  FF6
06A92:  MOVLW  0A
06A94:  MOVWF  FF7
06A96:  MOVLW  05
06A98:  MOVLB  3
06A9A:  MOVWF  xB4
06A9C:  MOVLB  0
06A9E:  CALL   4DF6
....................     printf(lcd_putc, "F1:GRAVA|ENTER:TESTE\n\r"); 
06AA2:  MOVLW  22
06AA4:  MOVWF  FF6
06AA6:  MOVLW  0A
06AA8:  MOVWF  FF7
06AAA:  CALL   2494
06AAE:  RETURN 0
.................... } 
....................  
.................... void tela_seleciona_manutencao(){ 
....................     printf(lcd_putc, "\f"); 
*
0662A:  MOVLW  0C
0662C:  MOVLB  3
0662E:  MOVWF  xBD
06630:  MOVLB  0
06632:  CALL   2440
....................     printf(lcd_putc, " F1: DEBUG ENTRADAS \n\r"); 
06636:  MOVLW  3A
06638:  MOVWF  FF6
0663A:  MOVLW  0A
0663C:  MOVWF  FF7
0663E:  CALL   2494
....................     printf(lcd_putc, " F2:  DEBUG SAIDAS  \n\r"); 
06642:  MOVLW  52
06644:  MOVWF  FF6
06646:  MOVLW  0A
06648:  MOVWF  FF7
0664A:  CALL   2494
....................     printf(lcd_putc, "                    \n\r"); 
0664E:  MOVLW  6A
06650:  MOVWF  FF6
06652:  MOVLW  0A
06654:  MOVWF  FF7
06656:  CALL   2494
....................     printf(lcd_putc, "      ESC:BACK      \n\r"); 
0665A:  MOVLW  82
0665C:  MOVWF  FF6
0665E:  MOVLW  0A
06660:  MOVWF  FF7
06662:  CALL   2494
06666:  RETURN 0
.................... } 
.................... void tela_debug_entrada_1 (){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
085A2:  MOVLW  0C
085A4:  MOVLB  3
085A6:  MOVWF  xBD
085A8:  MOVLB  0
085AA:  CALL   2440
....................     printf(lcd_putc, "E00:%02u E01:%02u E02:%02u\n\r", entradas[0], entradas[1], entradas[2]); 
085AE:  MOVLW  00
085B0:  BTFSC  1D.0
085B2:  MOVLW  01
085B4:  MOVLB  3
085B6:  MOVWF  xAE
085B8:  MOVLW  00
085BA:  BTFSC  1D.1
085BC:  MOVLW  01
085BE:  MOVWF  xAF
085C0:  MOVLW  00
085C2:  BTFSC  1D.2
085C4:  MOVLW  01
085C6:  MOVWF  xB0
085C8:  MOVLW  9A
085CA:  MOVWF  FF6
085CC:  MOVLW  0A
085CE:  MOVWF  FF7
085D0:  MOVLW  04
085D2:  MOVWF  xB4
085D4:  MOVLB  0
085D6:  CALL   4DF6
085DA:  MOVFF  3AE,3B1
085DE:  MOVLW  01
085E0:  MOVLB  3
085E2:  MOVWF  xB2
085E4:  MOVLB  0
085E6:  CALL   4E4C
085EA:  MOVLW  A2
085EC:  MOVWF  FF6
085EE:  MOVLW  0A
085F0:  MOVWF  FF7
085F2:  MOVLW  05
085F4:  MOVLB  3
085F6:  MOVWF  xB4
085F8:  MOVLB  0
085FA:  CALL   4DF6
085FE:  MOVFF  3AF,3B1
08602:  MOVLW  01
08604:  MOVLB  3
08606:  MOVWF  xB2
08608:  MOVLB  0
0860A:  CALL   4E4C
0860E:  MOVLW  AB
08610:  MOVWF  FF6
08612:  MOVLW  0A
08614:  MOVWF  FF7
08616:  MOVLW  05
08618:  MOVLB  3
0861A:  MOVWF  xB4
0861C:  MOVLB  0
0861E:  CALL   4DF6
08622:  MOVFF  3B0,3B1
08626:  MOVLW  01
08628:  MOVLB  3
0862A:  MOVWF  xB2
0862C:  MOVLB  0
0862E:  CALL   4E4C
08632:  MOVLW  0A
08634:  MOVLB  3
08636:  MOVWF  xBD
08638:  MOVLB  0
0863A:  CALL   2440
0863E:  MOVLW  0D
08640:  MOVLB  3
08642:  MOVWF  xBD
08644:  MOVLB  0
08646:  CALL   2440
....................     printf(lcd_putc, "E03:%02u E04:%02u E05:%02u\n\r", entradas[3], entradas[4], entradas[5]); 
0864A:  MOVLW  00
0864C:  BTFSC  1D.3
0864E:  MOVLW  01
08650:  MOVLB  3
08652:  MOVWF  xAE
08654:  MOVLW  00
08656:  BTFSC  1D.4
08658:  MOVLW  01
0865A:  MOVWF  xAF
0865C:  MOVLW  00
0865E:  BTFSC  1D.5
08660:  MOVLW  01
08662:  MOVWF  xB0
08664:  MOVLW  B8
08666:  MOVWF  FF6
08668:  MOVLW  0A
0866A:  MOVWF  FF7
0866C:  MOVLW  04
0866E:  MOVWF  xB4
08670:  MOVLB  0
08672:  CALL   4DF6
08676:  MOVFF  3AE,3B1
0867A:  MOVLW  01
0867C:  MOVLB  3
0867E:  MOVWF  xB2
08680:  MOVLB  0
08682:  CALL   4E4C
08686:  MOVLW  C0
08688:  MOVWF  FF6
0868A:  MOVLW  0A
0868C:  MOVWF  FF7
0868E:  MOVLW  05
08690:  MOVLB  3
08692:  MOVWF  xB4
08694:  MOVLB  0
08696:  CALL   4DF6
0869A:  MOVFF  3AF,3B1
0869E:  MOVLW  01
086A0:  MOVLB  3
086A2:  MOVWF  xB2
086A4:  MOVLB  0
086A6:  CALL   4E4C
086AA:  MOVLW  C9
086AC:  MOVWF  FF6
086AE:  MOVLW  0A
086B0:  MOVWF  FF7
086B2:  MOVLW  05
086B4:  MOVLB  3
086B6:  MOVWF  xB4
086B8:  MOVLB  0
086BA:  CALL   4DF6
086BE:  MOVFF  3B0,3B1
086C2:  MOVLW  01
086C4:  MOVLB  3
086C6:  MOVWF  xB2
086C8:  MOVLB  0
086CA:  CALL   4E4C
086CE:  MOVLW  0A
086D0:  MOVLB  3
086D2:  MOVWF  xBD
086D4:  MOVLB  0
086D6:  CALL   2440
086DA:  MOVLW  0D
086DC:  MOVLB  3
086DE:  MOVWF  xBD
086E0:  MOVLB  0
086E2:  CALL   2440
....................     printf(lcd_putc, "E06:%02u E07:%02u E08:%02u\n\r", entradas[6], entradas[7], entradas[8]);     
086E6:  MOVLW  00
086E8:  BTFSC  1D.6
086EA:  MOVLW  01
086EC:  MOVLB  3
086EE:  MOVWF  xAE
086F0:  MOVLW  00
086F2:  BTFSC  1D.7
086F4:  MOVLW  01
086F6:  MOVWF  xAF
086F8:  MOVLW  00
086FA:  BTFSC  1E.0
086FC:  MOVLW  01
086FE:  MOVWF  xB0
08700:  MOVLW  D6
08702:  MOVWF  FF6
08704:  MOVLW  0A
08706:  MOVWF  FF7
08708:  MOVLW  04
0870A:  MOVWF  xB4
0870C:  MOVLB  0
0870E:  CALL   4DF6
08712:  MOVFF  3AE,3B1
08716:  MOVLW  01
08718:  MOVLB  3
0871A:  MOVWF  xB2
0871C:  MOVLB  0
0871E:  CALL   4E4C
08722:  MOVLW  DE
08724:  MOVWF  FF6
08726:  MOVLW  0A
08728:  MOVWF  FF7
0872A:  MOVLW  05
0872C:  MOVLB  3
0872E:  MOVWF  xB4
08730:  MOVLB  0
08732:  CALL   4DF6
08736:  MOVFF  3AF,3B1
0873A:  MOVLW  01
0873C:  MOVLB  3
0873E:  MOVWF  xB2
08740:  MOVLB  0
08742:  CALL   4E4C
08746:  MOVLW  E7
08748:  MOVWF  FF6
0874A:  MOVLW  0A
0874C:  MOVWF  FF7
0874E:  MOVLW  05
08750:  MOVLB  3
08752:  MOVWF  xB4
08754:  MOVLB  0
08756:  CALL   4DF6
0875A:  MOVFF  3B0,3B1
0875E:  MOVLW  01
08760:  MOVLB  3
08762:  MOVWF  xB2
08764:  MOVLB  0
08766:  CALL   4E4C
0876A:  MOVLW  0A
0876C:  MOVLB  3
0876E:  MOVWF  xBD
08770:  MOVLB  0
08772:  CALL   2440
08776:  MOVLW  0D
08778:  MOVLB  3
0877A:  MOVWF  xBD
0877C:  MOVLB  0
0877E:  CALL   2440
....................     printf(lcd_putc, "   >:PROX|ESC:BACK  \n\r"); 
08782:  MOVLW  F4
08784:  MOVWF  FF6
08786:  MOVLW  0A
08788:  MOVWF  FF7
0878A:  CALL   2494
0878E:  RETURN 0
.................... } 
.................... void tela_debug_entrada_2 (){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0881A:  MOVLW  0C
0881C:  MOVLB  3
0881E:  MOVWF  xBD
08820:  MOVLB  0
08822:  CALL   2440
....................     printf(lcd_putc, "E09:%02u E10:%02u E11:%02u\n\r", entradas[9], entradas[10], entradas[11]); 
08826:  MOVLW  00
08828:  BTFSC  1E.1
0882A:  MOVLW  01
0882C:  MOVLB  3
0882E:  MOVWF  xAE
08830:  MOVLW  00
08832:  BTFSC  1E.2
08834:  MOVLW  01
08836:  MOVWF  xAF
08838:  MOVLW  00
0883A:  BTFSC  1E.3
0883C:  MOVLW  01
0883E:  MOVWF  xB0
08840:  MOVLW  0C
08842:  MOVWF  FF6
08844:  MOVLW  0B
08846:  MOVWF  FF7
08848:  MOVLW  04
0884A:  MOVWF  xB4
0884C:  MOVLB  0
0884E:  CALL   4DF6
08852:  MOVFF  3AE,3B1
08856:  MOVLW  01
08858:  MOVLB  3
0885A:  MOVWF  xB2
0885C:  MOVLB  0
0885E:  CALL   4E4C
08862:  MOVLW  14
08864:  MOVWF  FF6
08866:  MOVLW  0B
08868:  MOVWF  FF7
0886A:  MOVLW  05
0886C:  MOVLB  3
0886E:  MOVWF  xB4
08870:  MOVLB  0
08872:  CALL   4DF6
08876:  MOVFF  3AF,3B1
0887A:  MOVLW  01
0887C:  MOVLB  3
0887E:  MOVWF  xB2
08880:  MOVLB  0
08882:  CALL   4E4C
08886:  MOVLW  1D
08888:  MOVWF  FF6
0888A:  MOVLW  0B
0888C:  MOVWF  FF7
0888E:  MOVLW  05
08890:  MOVLB  3
08892:  MOVWF  xB4
08894:  MOVLB  0
08896:  CALL   4DF6
0889A:  MOVFF  3B0,3B1
0889E:  MOVLW  01
088A0:  MOVLB  3
088A2:  MOVWF  xB2
088A4:  MOVLB  0
088A6:  CALL   4E4C
088AA:  MOVLW  0A
088AC:  MOVLB  3
088AE:  MOVWF  xBD
088B0:  MOVLB  0
088B2:  CALL   2440
088B6:  MOVLW  0D
088B8:  MOVLB  3
088BA:  MOVWF  xBD
088BC:  MOVLB  0
088BE:  CALL   2440
....................     printf(lcd_putc, "E12:%02u E13:%02u E14:%02u\n\r", entradas[12], entradas[13], entradas[14]); 
088C2:  MOVLW  00
088C4:  BTFSC  1E.4
088C6:  MOVLW  01
088C8:  MOVLB  3
088CA:  MOVWF  xAE
088CC:  MOVLW  00
088CE:  BTFSC  1E.5
088D0:  MOVLW  01
088D2:  MOVWF  xAF
088D4:  MOVLW  00
088D6:  BTFSC  1E.6
088D8:  MOVLW  01
088DA:  MOVWF  xB0
088DC:  MOVLW  2A
088DE:  MOVWF  FF6
088E0:  MOVLW  0B
088E2:  MOVWF  FF7
088E4:  MOVLW  04
088E6:  MOVWF  xB4
088E8:  MOVLB  0
088EA:  CALL   4DF6
088EE:  MOVFF  3AE,3B1
088F2:  MOVLW  01
088F4:  MOVLB  3
088F6:  MOVWF  xB2
088F8:  MOVLB  0
088FA:  CALL   4E4C
088FE:  MOVLW  32
08900:  MOVWF  FF6
08902:  MOVLW  0B
08904:  MOVWF  FF7
08906:  MOVLW  05
08908:  MOVLB  3
0890A:  MOVWF  xB4
0890C:  MOVLB  0
0890E:  CALL   4DF6
08912:  MOVFF  3AF,3B1
08916:  MOVLW  01
08918:  MOVLB  3
0891A:  MOVWF  xB2
0891C:  MOVLB  0
0891E:  CALL   4E4C
08922:  MOVLW  3B
08924:  MOVWF  FF6
08926:  MOVLW  0B
08928:  MOVWF  FF7
0892A:  MOVLW  05
0892C:  MOVLB  3
0892E:  MOVWF  xB4
08930:  MOVLB  0
08932:  CALL   4DF6
08936:  MOVFF  3B0,3B1
0893A:  MOVLW  01
0893C:  MOVLB  3
0893E:  MOVWF  xB2
08940:  MOVLB  0
08942:  CALL   4E4C
08946:  MOVLW  0A
08948:  MOVLB  3
0894A:  MOVWF  xBD
0894C:  MOVLB  0
0894E:  CALL   2440
08952:  MOVLW  0D
08954:  MOVLB  3
08956:  MOVWF  xBD
08958:  MOVLB  0
0895A:  CALL   2440
....................     printf(lcd_putc, "E15:%02u E16:%02u E17:%02u\n\r", entradas[15], entradas[16], entradas[17]);     
0895E:  MOVLW  00
08960:  BTFSC  1E.7
08962:  MOVLW  01
08964:  MOVLB  3
08966:  MOVWF  xAE
08968:  MOVLW  00
0896A:  BTFSC  1F.0
0896C:  MOVLW  01
0896E:  MOVWF  xAF
08970:  MOVLW  00
08972:  BTFSC  1F.1
08974:  MOVLW  01
08976:  MOVWF  xB0
08978:  MOVLW  48
0897A:  MOVWF  FF6
0897C:  MOVLW  0B
0897E:  MOVWF  FF7
08980:  MOVLW  04
08982:  MOVWF  xB4
08984:  MOVLB  0
08986:  CALL   4DF6
0898A:  MOVFF  3AE,3B1
0898E:  MOVLW  01
08990:  MOVLB  3
08992:  MOVWF  xB2
08994:  MOVLB  0
08996:  CALL   4E4C
0899A:  MOVLW  50
0899C:  MOVWF  FF6
0899E:  MOVLW  0B
089A0:  MOVWF  FF7
089A2:  MOVLW  05
089A4:  MOVLB  3
089A6:  MOVWF  xB4
089A8:  MOVLB  0
089AA:  CALL   4DF6
089AE:  MOVFF  3AF,3B1
089B2:  MOVLW  01
089B4:  MOVLB  3
089B6:  MOVWF  xB2
089B8:  MOVLB  0
089BA:  CALL   4E4C
089BE:  MOVLW  59
089C0:  MOVWF  FF6
089C2:  MOVLW  0B
089C4:  MOVWF  FF7
089C6:  MOVLW  05
089C8:  MOVLB  3
089CA:  MOVWF  xB4
089CC:  MOVLB  0
089CE:  CALL   4DF6
089D2:  MOVFF  3B0,3B1
089D6:  MOVLW  01
089D8:  MOVLB  3
089DA:  MOVWF  xB2
089DC:  MOVLB  0
089DE:  CALL   4E4C
089E2:  MOVLW  0A
089E4:  MOVLB  3
089E6:  MOVWF  xBD
089E8:  MOVLB  0
089EA:  CALL   2440
089EE:  MOVLW  0D
089F0:  MOVLB  3
089F2:  MOVWF  xBD
089F4:  MOVLB  0
089F6:  CALL   2440
....................     printf(lcd_putc, "  <|>:PROX|ESC:BACK \n\r"); 
089FA:  MOVLW  66
089FC:  MOVWF  FF6
089FE:  MOVLW  0B
08A00:  MOVWF  FF7
08A02:  CALL   2494
08A06:  RETURN 0
.................... } 
.................... void tela_debug_entrada_3 (){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
08A84:  MOVLW  0C
08A86:  MOVLB  3
08A88:  MOVWF  xBD
08A8A:  MOVLB  0
08A8C:  CALL   2440
....................     printf(lcd_putc, "E18:%02u E19:%02u E20:%02u\n\r", entradas[18], entradas[19], entradas[20]); 
08A90:  MOVLW  00
08A92:  BTFSC  1F.2
08A94:  MOVLW  01
08A96:  MOVLB  3
08A98:  MOVWF  xAE
08A9A:  MOVLW  00
08A9C:  BTFSC  1F.3
08A9E:  MOVLW  01
08AA0:  MOVWF  xAF
08AA2:  MOVLW  00
08AA4:  BTFSC  1F.4
08AA6:  MOVLW  01
08AA8:  MOVWF  xB0
08AAA:  MOVLW  7E
08AAC:  MOVWF  FF6
08AAE:  MOVLW  0B
08AB0:  MOVWF  FF7
08AB2:  MOVLW  04
08AB4:  MOVWF  xB4
08AB6:  MOVLB  0
08AB8:  CALL   4DF6
08ABC:  MOVFF  3AE,3B1
08AC0:  MOVLW  01
08AC2:  MOVLB  3
08AC4:  MOVWF  xB2
08AC6:  MOVLB  0
08AC8:  CALL   4E4C
08ACC:  MOVLW  86
08ACE:  MOVWF  FF6
08AD0:  MOVLW  0B
08AD2:  MOVWF  FF7
08AD4:  MOVLW  05
08AD6:  MOVLB  3
08AD8:  MOVWF  xB4
08ADA:  MOVLB  0
08ADC:  CALL   4DF6
08AE0:  MOVFF  3AF,3B1
08AE4:  MOVLW  01
08AE6:  MOVLB  3
08AE8:  MOVWF  xB2
08AEA:  MOVLB  0
08AEC:  CALL   4E4C
08AF0:  MOVLW  8F
08AF2:  MOVWF  FF6
08AF4:  MOVLW  0B
08AF6:  MOVWF  FF7
08AF8:  MOVLW  05
08AFA:  MOVLB  3
08AFC:  MOVWF  xB4
08AFE:  MOVLB  0
08B00:  CALL   4DF6
08B04:  MOVFF  3B0,3B1
08B08:  MOVLW  01
08B0A:  MOVLB  3
08B0C:  MOVWF  xB2
08B0E:  MOVLB  0
08B10:  CALL   4E4C
08B14:  MOVLW  0A
08B16:  MOVLB  3
08B18:  MOVWF  xBD
08B1A:  MOVLB  0
08B1C:  CALL   2440
08B20:  MOVLW  0D
08B22:  MOVLB  3
08B24:  MOVWF  xBD
08B26:  MOVLB  0
08B28:  CALL   2440
....................     printf(lcd_putc, "E21:%02u E22:%02u E23:%02u\n\r", entradas[21], entradas[22], entradas[23]); 
08B2C:  MOVLW  00
08B2E:  BTFSC  1F.5
08B30:  MOVLW  01
08B32:  MOVLB  3
08B34:  MOVWF  xAE
08B36:  MOVLW  00
08B38:  BTFSC  1F.6
08B3A:  MOVLW  01
08B3C:  MOVWF  xAF
08B3E:  MOVLW  00
08B40:  BTFSC  1F.7
08B42:  MOVLW  01
08B44:  MOVWF  xB0
08B46:  MOVLW  9C
08B48:  MOVWF  FF6
08B4A:  MOVLW  0B
08B4C:  MOVWF  FF7
08B4E:  MOVLW  04
08B50:  MOVWF  xB4
08B52:  MOVLB  0
08B54:  CALL   4DF6
08B58:  MOVFF  3AE,3B1
08B5C:  MOVLW  01
08B5E:  MOVLB  3
08B60:  MOVWF  xB2
08B62:  MOVLB  0
08B64:  CALL   4E4C
08B68:  MOVLW  A4
08B6A:  MOVWF  FF6
08B6C:  MOVLW  0B
08B6E:  MOVWF  FF7
08B70:  MOVLW  05
08B72:  MOVLB  3
08B74:  MOVWF  xB4
08B76:  MOVLB  0
08B78:  CALL   4DF6
08B7C:  MOVFF  3AF,3B1
08B80:  MOVLW  01
08B82:  MOVLB  3
08B84:  MOVWF  xB2
08B86:  MOVLB  0
08B88:  CALL   4E4C
08B8C:  MOVLW  AD
08B8E:  MOVWF  FF6
08B90:  MOVLW  0B
08B92:  MOVWF  FF7
08B94:  MOVLW  05
08B96:  MOVLB  3
08B98:  MOVWF  xB4
08B9A:  MOVLB  0
08B9C:  CALL   4DF6
08BA0:  MOVFF  3B0,3B1
08BA4:  MOVLW  01
08BA6:  MOVLB  3
08BA8:  MOVWF  xB2
08BAA:  MOVLB  0
08BAC:  CALL   4E4C
08BB0:  MOVLW  0A
08BB2:  MOVLB  3
08BB4:  MOVWF  xBD
08BB6:  MOVLB  0
08BB8:  CALL   2440
08BBC:  MOVLW  0D
08BBE:  MOVLB  3
08BC0:  MOVWF  xBD
08BC2:  MOVLB  0
08BC4:  CALL   2440
....................     printf(lcd_putc, "E24:%02u E25:%02u E26:%02u\n\r", entradas[24], entradas[25], entradas[26]); 
08BC8:  MOVLW  00
08BCA:  BTFSC  20.0
08BCC:  MOVLW  01
08BCE:  MOVLB  3
08BD0:  MOVWF  xAE
08BD2:  MOVLW  00
08BD4:  BTFSC  20.1
08BD6:  MOVLW  01
08BD8:  MOVWF  xAF
08BDA:  MOVLW  00
08BDC:  BTFSC  20.2
08BDE:  MOVLW  01
08BE0:  MOVWF  xB0
08BE2:  MOVLW  BA
08BE4:  MOVWF  FF6
08BE6:  MOVLW  0B
08BE8:  MOVWF  FF7
08BEA:  MOVLW  04
08BEC:  MOVWF  xB4
08BEE:  MOVLB  0
08BF0:  CALL   4DF6
08BF4:  MOVFF  3AE,3B1
08BF8:  MOVLW  01
08BFA:  MOVLB  3
08BFC:  MOVWF  xB2
08BFE:  MOVLB  0
08C00:  CALL   4E4C
08C04:  MOVLW  C2
08C06:  MOVWF  FF6
08C08:  MOVLW  0B
08C0A:  MOVWF  FF7
08C0C:  MOVLW  05
08C0E:  MOVLB  3
08C10:  MOVWF  xB4
08C12:  MOVLB  0
08C14:  CALL   4DF6
08C18:  MOVFF  3AF,3B1
08C1C:  MOVLW  01
08C1E:  MOVLB  3
08C20:  MOVWF  xB2
08C22:  MOVLB  0
08C24:  CALL   4E4C
08C28:  MOVLW  CB
08C2A:  MOVWF  FF6
08C2C:  MOVLW  0B
08C2E:  MOVWF  FF7
08C30:  MOVLW  05
08C32:  MOVLB  3
08C34:  MOVWF  xB4
08C36:  MOVLB  0
08C38:  CALL   4DF6
08C3C:  MOVFF  3B0,3B1
08C40:  MOVLW  01
08C42:  MOVLB  3
08C44:  MOVWF  xB2
08C46:  MOVLB  0
08C48:  CALL   4E4C
08C4C:  MOVLW  0A
08C4E:  MOVLB  3
08C50:  MOVWF  xBD
08C52:  MOVLB  0
08C54:  CALL   2440
08C58:  MOVLW  0D
08C5A:  MOVLB  3
08C5C:  MOVWF  xBD
08C5E:  MOVLB  0
08C60:  CALL   2440
....................     printf(lcd_putc, "E27:%02u <:ANT|ESC:BACK\n\r", entradas[27]); 
08C64:  MOVLW  00
08C66:  BTFSC  20.3
08C68:  MOVLW  01
08C6A:  MOVLB  3
08C6C:  MOVWF  xAE
08C6E:  MOVLW  D8
08C70:  MOVWF  FF6
08C72:  MOVLW  0B
08C74:  MOVWF  FF7
08C76:  MOVLW  04
08C78:  MOVWF  xB4
08C7A:  MOVLB  0
08C7C:  CALL   4DF6
08C80:  MOVFF  3AE,3B1
08C84:  MOVLW  01
08C86:  MOVLB  3
08C88:  MOVWF  xB2
08C8A:  MOVLB  0
08C8C:  CALL   4E4C
08C90:  MOVLW  E0
08C92:  MOVWF  FF6
08C94:  MOVLW  0B
08C96:  MOVWF  FF7
08C98:  MOVLW  11
08C9A:  MOVLB  3
08C9C:  MOVWF  xB4
08C9E:  MOVLB  0
08CA0:  CALL   4DF6
08CA4:  RETURN 0
.................... } 
.................... void tela_debug_saida_1 (){ 
....................     printf(lcd_putc, "\f"); 
*
08790:  MOVLW  0C
08792:  MOVLB  3
08794:  MOVWF  xBD
08796:  MOVLB  0
08798:  CALL   2440
....................     printf(lcd_putc, "ESTEIRA             \n\r"); 
0879C:  MOVLW  F2
0879E:  MOVWF  FF6
087A0:  MOVLW  0B
087A2:  MOVWF  FF7
087A4:  CALL   2494
....................     printf(lcd_putc, "DEDOS ENTRADA       \n\r"); 
087A8:  MOVLW  0A
087AA:  MOVWF  FF6
087AC:  MOVLW  0C
087AE:  MOVWF  FF7
087B0:  CALL   2494
....................     printf(lcd_putc, "ALIMENTADOR_PLACA   \n\r"); 
087B4:  MOVLW  22
087B6:  MOVWF  FF6
087B8:  MOVLW  0C
087BA:  MOVWF  FF7
087BC:  CALL   2494
....................     printf(lcd_putc, "F1:ON|F2:OF|ESC:BACK\n\r"); 
087C0:  MOVLW  3A
087C2:  MOVWF  FF6
087C4:  MOVLW  0C
087C6:  MOVWF  FF7
087C8:  CALL   2494
....................     posiciona_cursor(ponteiro_lcd,19); 
087CC:  MOVFF  21,3BE
087D0:  MOVLW  13
087D2:  MOVLB  3
087D4:  MOVWF  xBF
087D6:  MOVLB  0
087D8:  CALL   229A
....................     printf(lcd_putc,"<"); 
087DC:  MOVLW  3C
087DE:  MOVLB  3
087E0:  MOVWF  xBD
087E2:  MOVLB  0
087E4:  CALL   2440
087E8:  RETURN 0
.................... } 
.................... void tela_debug_saida_2 (){ 
....................     printf(lcd_putc, "\f"); 
*
08DAE:  MOVLW  0C
08DB0:  MOVLB  3
08DB2:  MOVWF  xBD
08DB4:  MOVLB  0
08DB6:  CALL   2440
....................     printf(lcd_putc, "PRESSOR             \n\r"); 
08DBA:  MOVLW  52
08DBC:  MOVWF  FF6
08DBE:  MOVLW  0C
08DC0:  MOVWF  FF7
08DC2:  CALL   2494
....................     printf(lcd_putc, "DEDOS_SAIDA         \n\r"); 
08DC6:  MOVLW  6A
08DC8:  MOVWF  FF6
08DCA:  MOVLW  0C
08DCC:  MOVWF  FF7
08DCE:  CALL   2494
....................     printf(lcd_putc, "DISPENSADOR_PLACA   \n\r"); 
08DD2:  MOVLW  82
08DD4:  MOVWF  FF6
08DD6:  MOVLW  0C
08DD8:  MOVWF  FF7
08DDA:  CALL   2494
....................     printf(lcd_putc, "F1:ON|F2:OF|ESC:BACK\n\r"); 
08DDE:  MOVLW  9A
08DE0:  MOVWF  FF6
08DE2:  MOVLW  0C
08DE4:  MOVWF  FF7
08DE6:  CALL   2494
....................     posiciona_cursor(ponteiro_lcd,19); 
08DEA:  MOVFF  21,3BE
08DEE:  MOVLW  13
08DF0:  MOVLB  3
08DF2:  MOVWF  xBF
08DF4:  MOVLB  0
08DF6:  CALL   229A
....................     printf(lcd_putc,"<"); 
08DFA:  MOVLW  3C
08DFC:  MOVLB  3
08DFE:  MOVWF  xBD
08E00:  MOVLB  0
08E02:  CALL   2440
08E06:  RETURN 0
.................... } 
.................... void tela_debug_saida_3 (){ 
....................     printf(lcd_putc, "\f"); 
*
08F5E:  MOVLW  0C
08F60:  MOVLB  3
08F62:  MOVWF  xBD
08F64:  MOVLB  0
08F66:  CALL   2440
....................     printf(lcd_putc, "ALIMENTADOR_SOLDA   \n\r"); 
08F6A:  MOVLW  B2
08F6C:  MOVWF  FF6
08F6E:  MOVLW  0C
08F70:  MOVWF  FF7
08F72:  CALL   2494
....................     printf(lcd_putc, "LIMPADOR_BICO       \n\r"); 
08F76:  MOVLW  CA
08F78:  MOVWF  FF6
08F7A:  MOVLW  0C
08F7C:  MOVWF  FF7
08F7E:  CALL   2494
....................     printf(lcd_putc, "FERROS_DE_SOLDA     \n\r"); 
08F82:  MOVLW  E2
08F84:  MOVWF  FF6
08F86:  MOVLW  0C
08F88:  MOVWF  FF7
08F8A:  CALL   2494
....................     printf(lcd_putc, "F1:ON|F2:OF|ESC:BACK\n\r"); 
08F8E:  MOVLW  FA
08F90:  MOVWF  FF6
08F92:  MOVLW  0C
08F94:  MOVWF  FF7
08F96:  CALL   2494
....................     posiciona_cursor(ponteiro_lcd,19); 
08F9A:  MOVFF  21,3BE
08F9E:  MOVLW  13
08FA0:  MOVLB  3
08FA2:  MOVWF  xBF
08FA4:  MOVLB  0
08FA6:  CALL   229A
....................     printf(lcd_putc,"<"); 
08FAA:  MOVLW  3C
08FAC:  MOVLB  3
08FAE:  MOVWF  xBD
08FB0:  MOVLB  0
08FB2:  CALL   2440
08FB6:  RETURN 0
.................... } 
.................... void tela_debug_saida_4(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
09118:  MOVLW  0C
0911A:  MOVLB  3
0911C:  MOVWF  xBD
0911E:  MOVLB  0
09120:  CALL   2440
....................     printf(lcd_putc, "   X:%04Lu  Y:%04Lu  \n\r",motor_pos_x,motor_pos_y); 
09124:  MOVLW  12
09126:  MOVWF  FF6
09128:  MOVLW  0D
0912A:  MOVWF  FF7
0912C:  MOVLW  05
0912E:  MOVLB  3
09130:  MOVWF  xB4
09132:  MOVLB  0
09134:  CALL   4DF6
09138:  MOVLW  09
0913A:  MOVWF  FE9
0913C:  MOVFF  113,3B5
09140:  MOVFF  112,3B4
09144:  CALL   67F2
09148:  MOVLW  1C
0914A:  MOVWF  FF6
0914C:  MOVLW  0D
0914E:  MOVWF  FF7
09150:  MOVLW  04
09152:  MOVLB  3
09154:  MOVWF  xB4
09156:  MOVLB  0
09158:  CALL   4DF6
0915C:  MOVLW  09
0915E:  MOVWF  FE9
09160:  MOVFF  115,3B5
09164:  MOVFF  114,3B4
09168:  CALL   67F2
0916C:  MOVLW  25
0916E:  MOVWF  FF6
09170:  MOVLW  0D
09172:  MOVWF  FF7
09174:  MOVLW  04
09176:  MOVLB  3
09178:  MOVWF  xB4
0917A:  MOVLB  0
0917C:  CALL   4DF6
....................     printf(lcd_putc, "   Z:%04Lu  F:%04Lu  \n\r",motor_pos_z,contador_step_flip); 
09180:  MOVLW  2A
09182:  MOVWF  FF6
09184:  MOVLW  0D
09186:  MOVWF  FF7
09188:  MOVLW  05
0918A:  MOVLB  3
0918C:  MOVWF  xB4
0918E:  MOVLB  0
09190:  CALL   4DF6
09194:  MOVLW  09
09196:  MOVWF  FE9
09198:  MOVFF  119,3B5
0919C:  MOVFF  118,3B4
091A0:  CALL   67F2
091A4:  MOVLW  34
091A6:  MOVWF  FF6
091A8:  MOVLW  0D
091AA:  MOVWF  FF7
091AC:  MOVLW  04
091AE:  MOVLB  3
091B0:  MOVWF  xB4
091B2:  MOVLB  0
091B4:  CALL   4DF6
091B8:  MOVLW  09
091BA:  MOVWF  FE9
091BC:  MOVFF  117,3B5
091C0:  MOVFF  116,3B4
091C4:  CALL   67F2
091C8:  MOVLW  3D
091CA:  MOVWF  FF6
091CC:  MOVLW  0D
091CE:  MOVWF  FF7
091D0:  MOVLW  04
091D2:  MOVLB  3
091D4:  MOVWF  xB4
091D6:  MOVLB  0
091D8:  CALL   4DF6
....................     printf(lcd_putc, "  ^|?||>|<|F1|F2|8|0 \n\r"); 
091DC:  MOVLW  42
091DE:  MOVWF  FF6
091E0:  MOVLW  0D
091E2:  MOVWF  FF7
091E4:  CALL   2494
....................     printf(lcd_putc, "       ESC:BACK      \n\r"); 
091E8:  MOVLW  5A
091EA:  MOVWF  FF6
091EC:  MOVLW  0D
091EE:  MOVWF  FF7
091F0:  CALL   2494
091F4:  RETURN 0
.................... } 
....................  
.................... void tela_programa_principal(){ 
....................     printf(lcd_putc, "\f"); // limpa display 
*
0551C:  MOVLW  0C
0551E:  MOVLB  3
05520:  MOVWF  xBD
05522:  MOVLB  0
05524:  CALL   2440
....................     printf(lcd_putc, " EXECUTANDO PROGRAMA\n\r"); 
05528:  MOVLW  72
0552A:  MOVWF  FF6
0552C:  MOVLW  0D
0552E:  MOVWF  FF7
05530:  CALL   2494
....................     printf(lcd_putc, "     MODELO:%02u    \n\r",modelo); 
05534:  MOVLW  8A
05536:  MOVWF  FF6
05538:  MOVLW  0D
0553A:  MOVWF  FF7
0553C:  MOVLW  0C
0553E:  MOVLB  3
05540:  MOVWF  xB4
05542:  MOVLB  0
05544:  RCALL  4DF6
05546:  MOVFF  2D,3B1
0554A:  MOVLW  01
0554C:  MOVLB  3
0554E:  MOVWF  xB2
05550:  MOVLB  0
05552:  RCALL  4E4C
05554:  MOVLW  9A
05556:  MOVWF  FF6
05558:  MOVLW  0D
0555A:  MOVWF  FF7
0555C:  MOVLW  06
0555E:  MOVLB  3
05560:  MOVWF  xB4
05562:  MOVLB  0
05564:  RCALL  4DF6
....................     printf(lcd_putc, "                    \n\r"); 
05566:  MOVLW  A2
05568:  MOVWF  FF6
0556A:  MOVLW  0D
0556C:  MOVWF  FF7
0556E:  CALL   2494
....................     printf(lcd_putc, "      ESC:STOP      \n\r"); 
05572:  MOVLW  BA
05574:  MOVWF  FF6
05576:  MOVLW  0D
05578:  MOVWF  FF7
0557A:  CALL   2494
0557E:  GOTO   5600 (RETURN)
.................... } 
....................  
.................... #include "Axis_x.c" 
.................... // <editor-fold defaultstate="collapsed" desc="Valores que devem ser inseridos"> 
.................... float stepbyrev_x = 200; //pulso por volta (datasheet) 
.................... float driver_u_step_x = 1; //divisao entre chave/pulso por volta 
.................... float Leadscrew_x = 9; //tipo de redutor 
.................... float Leadscrew_Pich_x = 150; //comprimento da polia (datasheet) 
.................... float Vmax_x = 600;//esse valor deve ser em mm por segundo 
.................... float Vmin_x = 200; 
.................... float Amax_x = 500; //esse valor deve ser em mm por segundo 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Valores calculo rampa"> 
.................... float MMbyStep_x = 0; 
.................... int8 StepinAcc_x = 20; 
.................... float Fmax_x = 0; 
.................... float Fmin_x = 100; 
.................... int32 Ts_x[20]; 
.................... int32 StepbyF_x[20]; 
.................... int16 total_acc_step_x = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Flags e Controles de Movimento"> 
.................... signed int8 pos_inc_x = 0; 
.................... int8 ramp_sts_x = ramp_idle; 
.................... short run_flg_x = FALSE; 
.................... short rest_x = FALSE; 
.................... int16 step_no_x = 0; 
.................... int16 step_down_x = 0; 
.................... int16 move_x = 0; 
.................... int16 midpt_x = 0; 
.................... int32 step_acumulado_x = 0; 
.................... int atual_frequencia_x = 0; 
.................... int vel_x = 19; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Pinos Motor"> 
.................... #DEFINE     i_limite_x            5 
.................... #DEFINE     s_limite_x            6 
.................... // </editor-fold>    
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Inicializa Motor"> 
.................... void init_axis_x(){ 
....................     set_tris_d(0xf8); 
*
02C0A:  MOVLW  F8
02C0C:  MOVWF  F95
....................     output_high(step_x); 
02C0E:  BCF    F95.2
02C10:  BSF    F8C.2
....................     output_high(enable_x); 
02C12:  BCF    F95.0
02C14:  BSF    F8C.0
....................     output_high(dir_x); 
02C16:  BCF    F95.1
02C18:  BSF    F8C.1
....................      
....................     MMbyStep_x = Leadscrew_Pich_x/(stepbyrev_x*driver_u_step_x*Leadscrew_x); 
02C1A:  MOVFF  121,3CB
02C1E:  MOVFF  120,3CA
02C22:  MOVFF  11F,3C9
02C26:  MOVFF  11E,3C8
02C2A:  MOVFF  125,3CF
02C2E:  MOVFF  124,3CE
02C32:  MOVFF  123,3CD
02C36:  MOVFF  122,3CC
02C3A:  RCALL  2632
02C3C:  MOVFF  03,3BD
02C40:  MOVFF  02,3BC
02C44:  MOVFF  01,3BB
02C48:  MOVFF  00,3BA
02C4C:  MOVFF  03,3CB
02C50:  MOVFF  02,3CA
02C54:  MOVFF  01,3C9
02C58:  MOVFF  00,3C8
02C5C:  MOVFF  129,3CF
02C60:  MOVFF  128,3CE
02C64:  MOVFF  127,3CD
02C68:  MOVFF  126,3CC
02C6C:  RCALL  2632
02C6E:  MOVFF  12D,3D1
02C72:  MOVFF  12C,3D0
02C76:  MOVFF  12B,3CF
02C7A:  MOVFF  12A,3CE
02C7E:  MOVFF  03,3D5
02C82:  MOVFF  02,3D4
02C86:  MOVFF  01,3D3
02C8A:  MOVFF  00,3D2
02C8E:  RCALL  2728
02C90:  MOVFF  03,13D
02C94:  MOVFF  02,13C
02C98:  MOVFF  01,13B
02C9C:  MOVFF  00,13A
....................     Fmax_x = Vmax_x/MMbyStep_x; //Valor de ferequencia adiquirido em hz 
02CA0:  MOVFF  131,3D1
02CA4:  MOVFF  130,3D0
02CA8:  MOVFF  12F,3CF
02CAC:  MOVFF  12E,3CE
02CB0:  MOVFF  13D,3D5
02CB4:  MOVFF  13C,3D4
02CB8:  MOVFF  13B,3D3
02CBC:  MOVFF  13A,3D2
02CC0:  RCALL  2728
02CC2:  MOVFF  03,142
02CC6:  MOVFF  02,141
02CCA:  MOVFF  01,140
02CCE:  MOVFF  00,13F
....................     //Fmin_x = Vmin_x/MMbyStep_x; 
....................      
....................     float den = Amax_x*StepinAcc_x; 
....................     float num = (Vmax_x - Vmin_x)*1000000; 
....................     float TbyF = num/den;//tempo em us 
....................      
....................     int i = 0; 
02CD2:  MOVLB  3
02CD4:  CLRF   xC9
02CD6:  MOVFF  13E,3C8
02CDA:  MOVLB  0
02CDC:  RCALL  2886
02CDE:  MOVFF  139,3CB
02CE2:  MOVFF  138,3CA
02CE6:  MOVFF  137,3C9
02CEA:  MOVFF  136,3C8
02CEE:  MOVFF  03,3CF
02CF2:  MOVFF  02,3CE
02CF6:  MOVFF  01,3CD
02CFA:  MOVFF  00,3CC
02CFE:  RCALL  2632
02D00:  MOVFF  03,3B0
02D04:  MOVFF  02,3AF
02D08:  MOVFF  01,3AE
02D0C:  MOVFF  00,3AD
02D10:  BSF    FD8.1
02D12:  MOVFF  131,3D1
02D16:  MOVFF  130,3D0
02D1A:  MOVFF  12F,3CF
02D1E:  MOVFF  12E,3CE
02D22:  MOVFF  135,3D5
02D26:  MOVFF  134,3D4
02D2A:  MOVFF  133,3D3
02D2E:  MOVFF  132,3D2
02D32:  RCALL  28BC
02D34:  MOVFF  03,3BD
02D38:  MOVFF  02,3BC
02D3C:  MOVFF  01,3BB
02D40:  MOVFF  00,3BA
02D44:  MOVFF  03,3CB
02D48:  MOVFF  02,3CA
02D4C:  MOVFF  01,3C9
02D50:  MOVFF  00,3C8
02D54:  MOVLB  3
02D56:  CLRF   xCF
02D58:  MOVLW  24
02D5A:  MOVWF  xCE
02D5C:  MOVLW  74
02D5E:  MOVWF  xCD
02D60:  MOVLW  92
02D62:  MOVWF  xCC
02D64:  MOVLB  0
02D66:  RCALL  2632
02D68:  MOVFF  03,3B4
02D6C:  MOVFF  02,3B3
02D70:  MOVFF  01,3B2
02D74:  MOVFF  00,3B1
02D78:  MOVFF  3B4,3D1
02D7C:  MOVFF  3B3,3D0
02D80:  MOVFF  3B2,3CF
02D84:  MOVFF  3B1,3CE
02D88:  MOVFF  3B0,3D5
02D8C:  MOVFF  3AF,3D4
02D90:  MOVFF  3AE,3D3
02D94:  MOVFF  3AD,3D2
02D98:  RCALL  2728
02D9A:  MOVFF  03,3B8
02D9E:  MOVFF  02,3B7
02DA2:  MOVFF  01,3B6
02DA6:  MOVFF  00,3B5
02DAA:  MOVLB  3
02DAC:  CLRF   xB9
....................     for(i = 1; i <=StepinAcc_x;i++) 
02DAE:  MOVLW  01
02DB0:  MOVWF  xB9
02DB2:  MOVF   xB9,W
02DB4:  MOVLB  1
02DB6:  SUBWF  x3E,W
02DB8:  BTFSS  FD8.0
02DBA:  BRA    30DE
....................     { 
....................         Ts_x[i-1]=(1000000*StepinAcc_x)/(i*(Fmax_x-Fmin_x)+Fmin_x); 
02DBC:  MOVLW  01
02DBE:  MOVLB  3
02DC0:  SUBWF  xB9,W
02DC2:  MULLW  04
02DC4:  MOVF   FF3,W
02DC6:  CLRF   03
02DC8:  ADDLW  47
02DCA:  MOVWF  FE9
02DCC:  MOVLW  01
02DCE:  ADDWFC 03,W
02DD0:  MOVWF  FEA
02DD2:  MOVFF  FEA,3BD
02DD6:  MOVFF  FE9,3BC
02DDA:  CLRF   xC1
02DDC:  MOVLW  0F
02DDE:  MOVWF  xC0
02DE0:  MOVLW  42
02DE2:  MOVWF  xBF
02DE4:  MOVLW  40
02DE6:  MOVWF  xBE
02DE8:  CLRF   xC5
02DEA:  CLRF   xC4
02DEC:  CLRF   xC3
02DEE:  MOVFF  13E,3C2
02DF2:  MOVLB  0
02DF4:  RCALL  2B34
02DF6:  MOVFF  3BD,FEA
02DFA:  MOVFF  3BC,FE9
02DFE:  MOVFF  03,3C1
02E02:  MOVFF  02,3C0
02E06:  MOVFF  01,3BF
02E0A:  MOVFF  00,3BE
02E0E:  MOVFF  FEA,3C3
02E12:  MOVFF  FE9,3C2
02E16:  BSF    FD8.1
02E18:  MOVFF  142,3D1
02E1C:  MOVFF  141,3D0
02E20:  MOVFF  140,3CF
02E24:  MOVFF  13F,3CE
02E28:  MOVFF  146,3D5
02E2C:  MOVFF  145,3D4
02E30:  MOVFF  144,3D3
02E34:  MOVFF  143,3D2
02E38:  RCALL  28BC
02E3A:  MOVFF  3C3,FEA
02E3E:  MOVFF  3C2,FE9
02E42:  MOVFF  03,3C7
02E46:  MOVFF  02,3C6
02E4A:  MOVFF  01,3C5
02E4E:  MOVFF  00,3C4
02E52:  MOVLB  3
02E54:  CLRF   xC9
02E56:  MOVFF  3B9,3C8
02E5A:  MOVLB  0
02E5C:  RCALL  2886
02E5E:  MOVFF  03,3CB
02E62:  MOVFF  02,3CA
02E66:  MOVFF  01,3C9
02E6A:  MOVFF  00,3C8
02E6E:  MOVFF  3C7,3CF
02E72:  MOVFF  3C6,3CE
02E76:  MOVFF  3C5,3CD
02E7A:  MOVFF  3C4,3CC
02E7E:  CALL   2632
02E82:  MOVFF  03,3CB
02E86:  MOVFF  02,3CA
02E8A:  MOVFF  01,3C9
02E8E:  MOVFF  00,3C8
02E92:  MOVFF  FEA,3CD
02E96:  MOVFF  FE9,3CC
02E9A:  BCF    FD8.1
02E9C:  MOVFF  03,3D1
02EA0:  MOVFF  02,3D0
02EA4:  MOVFF  01,3CF
02EA8:  MOVFF  00,3CE
02EAC:  MOVFF  146,3D5
02EB0:  MOVFF  145,3D4
02EB4:  MOVFF  144,3D3
02EB8:  MOVFF  143,3D2
02EBC:  RCALL  28BC
02EBE:  MOVFF  3CD,FEA
02EC2:  MOVFF  3CC,FE9
02EC6:  MOVFF  03,3CB
02ECA:  MOVFF  02,3CA
02ECE:  MOVFF  01,3C9
02ED2:  MOVFF  00,3C8
02ED6:  MOVFF  3C1,3D1
02EDA:  MOVFF  3C0,3D0
02EDE:  MOVFF  3BF,3CF
02EE2:  MOVFF  3BE,3CE
02EE6:  RCALL  2B90
02EE8:  MOVFF  03,3D1
02EEC:  MOVFF  02,3D0
02EF0:  MOVFF  01,3CF
02EF4:  MOVFF  00,3CE
02EF8:  MOVFF  3CB,3D5
02EFC:  MOVFF  3CA,3D4
02F00:  MOVFF  3C9,3D3
02F04:  MOVFF  3C8,3D2
02F08:  RCALL  2728
02F0A:  MOVFF  03,3D1
02F0E:  MOVFF  02,3D0
02F12:  MOVFF  01,3CF
02F16:  MOVFF  00,3CE
02F1A:  RCALL  2BC8
02F1C:  MOVFF  00,FEF
02F20:  MOVFF  01,FEC
02F24:  MOVFF  02,FEC
02F28:  MOVFF  03,FEC
....................         StepbyF_x[i-1] = 2*TbyF/Ts_x[i-1]; 
02F2C:  MOVLW  01
02F2E:  MOVLB  3
02F30:  SUBWF  xB9,W
02F32:  MULLW  04
02F34:  MOVF   FF3,W
02F36:  CLRF   03
02F38:  ADDLW  97
02F3A:  MOVWF  01
02F3C:  MOVLW  01
02F3E:  ADDWFC 03,F
02F40:  MOVFF  01,3BA
02F44:  MOVFF  03,3BB
02F48:  CLRF   xCB
02F4A:  CLRF   xCA
02F4C:  CLRF   xC9
02F4E:  MOVLW  80
02F50:  MOVWF  xC8
02F52:  MOVFF  3B8,3CF
02F56:  MOVFF  3B7,3CE
02F5A:  MOVFF  3B6,3CD
02F5E:  MOVFF  3B5,3CC
02F62:  MOVLB  0
02F64:  CALL   2632
02F68:  MOVFF  03,3BF
02F6C:  MOVFF  02,3BE
02F70:  MOVFF  01,3BD
02F74:  MOVFF  00,3BC
02F78:  MOVLW  01
02F7A:  MOVLB  3
02F7C:  SUBWF  xB9,W
02F7E:  MULLW  04
02F80:  MOVF   FF3,W
02F82:  CLRF   03
02F84:  ADDLW  47
02F86:  MOVWF  FE9
02F88:  MOVLW  01
02F8A:  ADDWFC 03,W
02F8C:  MOVWF  FEA
02F8E:  MOVFF  FEF,00
02F92:  MOVFF  FEC,01
02F96:  MOVFF  FEC,02
02F9A:  MOVFF  FEC,03
02F9E:  MOVFF  03,3D1
02FA2:  MOVFF  02,3D0
02FA6:  MOVFF  01,3CF
02FAA:  MOVFF  00,3CE
02FAE:  MOVLB  0
02FB0:  RCALL  2B90
02FB2:  MOVFF  3BF,3D1
02FB6:  MOVFF  3BE,3D0
02FBA:  MOVFF  3BD,3CF
02FBE:  MOVFF  3BC,3CE
02FC2:  MOVFF  03,3D5
02FC6:  MOVFF  02,3D4
02FCA:  MOVFF  01,3D3
02FCE:  MOVFF  00,3D2
02FD2:  CALL   2728
02FD6:  MOVFF  03,3D1
02FDA:  MOVFF  02,3D0
02FDE:  MOVFF  01,3CF
02FE2:  MOVFF  00,3CE
02FE6:  RCALL  2BC8
02FE8:  MOVFF  3BB,FEA
02FEC:  MOVFF  3BA,FE9
02FF0:  MOVFF  00,FEF
02FF4:  MOVFF  01,FEC
02FF8:  MOVFF  02,FEC
02FFC:  MOVFF  03,FEC
....................         total_acc_step_x += StepbyF_x[i-1]; 
03000:  MOVLW  01
03002:  MOVLB  3
03004:  SUBWF  xB9,W
03006:  MULLW  04
03008:  MOVF   FF3,W
0300A:  CLRF   03
0300C:  ADDLW  97
0300E:  MOVWF  FE9
03010:  MOVLW  01
03012:  ADDWFC 03,W
03014:  MOVWF  FEA
03016:  MOVFF  FEF,00
0301A:  MOVFF  FEC,01
0301E:  MOVFF  FEC,02
03022:  MOVFF  FEC,03
03026:  MOVF   00,W
03028:  MOVLB  1
0302A:  ADDWF  xE7,F
0302C:  MOVF   01,W
0302E:  ADDWFC xE8,F
....................         Ts_x[i-1] = Ts_x[i-1]/(8*0.2*2);//Tempo/(prescale*ciclodemaquina*metadedociclo) 
03030:  MOVLW  01
03032:  MOVLB  3
03034:  SUBWF  xB9,W
03036:  MULLW  04
03038:  MOVF   FF3,W
0303A:  CLRF   03
0303C:  ADDLW  47
0303E:  MOVWF  01
03040:  MOVLW  01
03042:  ADDWFC 03,F
03044:  MOVFF  01,3BA
03048:  MOVFF  03,3BB
0304C:  MOVLW  01
0304E:  SUBWF  xB9,W
03050:  MULLW  04
03052:  MOVF   FF3,W
03054:  CLRF   03
03056:  ADDLW  47
03058:  MOVWF  FE9
0305A:  MOVLW  01
0305C:  ADDWFC 03,W
0305E:  MOVWF  FEA
03060:  MOVFF  FEF,3BC
03064:  MOVFF  FEC,3BD
03068:  MOVFF  FEC,3BE
0306C:  MOVFF  FEC,3BF
03070:  MOVFF  3BF,3D1
03074:  MOVFF  3BE,3D0
03078:  MOVFF  3BD,3CF
0307C:  MOVFF  3BC,3CE
03080:  MOVLB  0
03082:  RCALL  2B90
03084:  MOVFF  03,3D1
03088:  MOVFF  02,3D0
0308C:  MOVFF  01,3CF
03090:  MOVFF  00,3CE
03094:  MOVLW  CD
03096:  MOVLB  3
03098:  MOVWF  xD5
0309A:  MOVLW  CC
0309C:  MOVWF  xD4
0309E:  MOVLW  4C
030A0:  MOVWF  xD3
030A2:  MOVLW  80
030A4:  MOVWF  xD2
030A6:  MOVLB  0
030A8:  CALL   2728
030AC:  MOVFF  03,3D1
030B0:  MOVFF  02,3D0
030B4:  MOVFF  01,3CF
030B8:  MOVFF  00,3CE
030BC:  RCALL  2BC8
030BE:  MOVFF  3BB,FEA
030C2:  MOVFF  3BA,FE9
030C6:  MOVFF  00,FEF
030CA:  MOVFF  01,FEC
030CE:  MOVFF  02,FEC
030D2:  MOVFF  03,FEC
030D6:  MOVLB  3
030D8:  INCF   xB9,F
030DA:  BRA    2DB2
030DC:  MOVLB  1
....................     } 
....................     i++; 
030DE:  MOVLB  3
030E0:  INCF   xB9,F
030E2:  MOVLB  0
030E4:  GOTO   A8F6 (RETURN)
.................... } 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Movimento Motor"> 
.................... void motor_stop_x(){ 
....................     step_no_x = step_down_x; 
....................     ramp_sts_x = ramp_down; 
.................... } 
....................  
.................... void motor_disable_x(){ 
....................     output_high(enable_x); 
....................     disable_interrupts(INT_TIMER0); 
.................... } 
....................  
.................... void motor_run_x(int32 pos_new, int velocidade) { // set up to drive motor to pos_new (absolute step#) 
....................      
....................     vel_x = velocidade; 
*
04ABC:  MOVFF  3B8,1F8
....................     total_acc_step_x = 0; 
04AC0:  MOVLB  1
04AC2:  CLRF   xE8
04AC4:  CLRF   xE7
....................      
....................     /*Obtem a Direo do motor*/ 
....................     if (pos_new < motor_pos_x)  
04AC6:  MOVLB  3
04AC8:  MOVF   xB7,F
04ACA:  BNZ   4B06
04ACC:  MOVF   xB6,F
04ACE:  BNZ   4B06
04AD0:  MOVF   xB5,W
04AD2:  MOVLB  1
04AD4:  SUBWF  x13,W
04AD6:  BTFSC  FD8.0
04AD8:  BRA    4ADE
04ADA:  MOVLB  3
04ADC:  BRA    4B06
04ADE:  BNZ   4AEA
04AE0:  MOVF   x12,W
04AE2:  MOVLB  3
04AE4:  SUBWF  xB4,W
04AE6:  BC    4B06
04AE8:  MOVLB  1
....................     { 
....................         output_low(dir_x); 
04AEA:  BCF    F95.1
04AEC:  BCF    F8C.1
....................         move_x = motor_pos_x - pos_new; 
04AEE:  MOVLB  3
04AF0:  MOVF   xB4,W
04AF2:  MOVLB  1
04AF4:  SUBWF  x12,W
04AF6:  MOVWF  xEF
04AF8:  MOVLB  3
04AFA:  MOVF   xB5,W
04AFC:  MOVLB  1
04AFE:  SUBWFB x13,W
04B00:  MOVWF  xF0
....................         pos_inc_x = -1; 
04B02:  SETF   xE9
....................     } else if (pos_new != motor_pos_x) { 
04B04:  BRA    4B48
04B06:  MOVLB  1
04B08:  MOVF   x12,W
04B0A:  MOVLB  3
04B0C:  SUBWF  xB4,W
04B0E:  BNZ   4B22
04B10:  MOVLB  1
04B12:  MOVF   x13,W
04B14:  MOVLB  3
04B16:  SUBWF  xB5,W
04B18:  BNZ   4B22
04B1A:  MOVF   xB6,F
04B1C:  BNZ   4B22
04B1E:  MOVF   xB7,F
04B20:  BZ    4B44
....................         output_high(dir_x); 
04B22:  BCF    F95.1
04B24:  BSF    F8C.1
....................         move_x = pos_new - motor_pos_x; 
04B26:  MOVLB  1
04B28:  MOVF   x12,W
04B2A:  MOVLB  3
04B2C:  SUBWF  xB4,W
04B2E:  MOVLB  1
04B30:  MOVWF  xEF
04B32:  MOVF   x13,W
04B34:  MOVLB  3
04B36:  SUBWFB xB5,W
04B38:  MOVLB  1
04B3A:  MOVWF  xF0
....................         pos_inc_x = 1; 
04B3C:  MOVLW  01
04B3E:  MOVWF  xE9
....................     } else return; 
04B40:  BRA    4B48
04B42:  MOVLB  3
04B44:  BRA    4C2A
04B46:  MOVLB  1
....................      
....................     /*Calcula a quantidade de passos para chegar na velocidade desejada*/ 
....................     for(int j = 0; j <= velocidade;j++) 
04B48:  MOVLB  3
04B4A:  CLRF   xB9
04B4C:  MOVF   xB9,W
04B4E:  SUBWF  xB8,W
04B50:  BNC   4B84
....................     { 
....................         total_acc_step_x += StepbyF_x[j]; 
04B52:  MOVF   xB9,W
04B54:  MULLW  04
04B56:  MOVF   FF3,W
04B58:  CLRF   03
04B5A:  ADDLW  97
04B5C:  MOVWF  FE9
04B5E:  MOVLW  01
04B60:  ADDWFC 03,W
04B62:  MOVWF  FEA
04B64:  MOVFF  FEF,00
04B68:  MOVFF  FEC,01
04B6C:  MOVFF  FEC,02
04B70:  MOVFF  FEC,03
04B74:  MOVF   00,W
04B76:  MOVLB  1
04B78:  ADDWF  xE7,F
04B7A:  MOVF   01,W
04B7C:  ADDWFC xE8,F
04B7E:  MOVLB  3
04B80:  INCF   xB9,F
04B82:  BRA    4B4C
....................     } 
....................     /*Define Formato da Rampa(Trapezio,triangulo ou constante)*/ 
....................     if (move_x > 2 * total_acc_step_x) { 
04B84:  BCF    FD8.0
04B86:  MOVLB  1
04B88:  RLCF   xE7,W
04B8A:  MOVWF  02
04B8C:  RLCF   xE8,W
04B8E:  MOVWF  03
04B90:  MOVFF  02,01
04B94:  MOVF   03,W
04B96:  SUBWF  xF0,W
04B98:  BNC   4BB8
04B9A:  BNZ   4BA2
04B9C:  MOVF   xEF,W
04B9E:  SUBWF  01,W
04BA0:  BC    4BB8
....................         midpt_x = total_acc_step_x; 
04BA2:  MOVFF  1E8,1F2
04BA6:  MOVFF  1E7,1F1
....................         step_down_x = move_x - total_acc_step_x; 
04BAA:  MOVF   xE7,W
04BAC:  SUBWF  xEF,W
04BAE:  MOVWF  xED
04BB0:  MOVF   xE8,W
04BB2:  SUBWFB xF0,W
04BB4:  MOVWF  xEE
....................     }  
04BB6:  BRA    4BE2
....................     else 
....................     { 
....................         midpt_x = (move_x - 1) >> 1; 
04BB8:  MOVLW  01
04BBA:  SUBWF  xEF,W
04BBC:  MOVLB  3
04BBE:  MOVWF  xBA
04BC0:  MOVLW  00
04BC2:  MOVLB  1
04BC4:  SUBWFB xF0,W
04BC6:  MOVLB  3
04BC8:  MOVWF  xBB
04BCA:  BCF    FD8.0
04BCC:  RRCF   xBB,W
04BCE:  MOVLB  1
04BD0:  MOVWF  xF2
04BD2:  MOVLB  3
04BD4:  RRCF   xBA,W
04BD6:  MOVLB  1
04BD8:  MOVWF  xF1
....................         step_down_x = midpt_x; 
04BDA:  MOVFF  1F2,1EE
04BDE:  MOVFF  1F1,1ED
....................     } 
....................     step_no_x = 0; 
04BE2:  CLRF   xEC
04BE4:  CLRF   xEB
....................     step_acumulado_x = 0; 
04BE6:  CLRF   xF6
04BE8:  CLRF   xF5
04BEA:  CLRF   xF4
04BEC:  CLRF   xF3
....................     atual_frequencia_x = 0; 
04BEE:  CLRF   xF7
....................     ramp_sts_x = ramp_up; // start ramp state-machine 
04BF0:  MOVLW  01
04BF2:  MOVWF  xEA
....................     run_flg_x = TRUE; 
04BF4:  BSF    x1A.4
....................     output_low(enable_x); 
04BF6:  BCF    F95.0
04BF8:  BCF    F8C.0
....................     setup_timer_0(T0_INTERNAL | T0_DIV_8); 
04BFA:  MOVLW  82
04BFC:  MOVWF  FD5
....................     set_timer0(65535 - Ts_x[0]); 
04BFE:  MOVLW  FF
04C00:  BSF    FD8.0
04C02:  SUBFWB x47,W
04C04:  MOVLB  3
04C06:  MOVWF  xBA
04C08:  MOVLW  FF
04C0A:  MOVLB  1
04C0C:  SUBFWB x48,W
04C0E:  MOVLB  3
04C10:  MOVWF  xBB
04C12:  MOVLW  00
04C14:  MOVLB  1
04C16:  SUBFWB x49,W
04C18:  MOVLW  00
04C1A:  MOVLB  1
04C1C:  SUBFWB x4A,W
04C1E:  MOVLB  3
04C20:  MOVFF  3BB,FD7
04C24:  MOVFF  3BA,FD6
....................     enable_interrupts(INT_TIMER0); 
04C28:  BSF    FF2.5
04C2A:  MOVLB  0
04C2C:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_subida_x() { 
....................     if (atual_frequencia_x == 0) { 
*
00F12:  MOVLB  1
00F14:  MOVF   xF7,F
00F16:  BTFSS  FD8.2
00F18:  BRA    1048
....................         if (step_no_x == StepbyF_x[atual_frequencia_x]) { 
00F1A:  MOVF   xF7,W
00F1C:  MULLW  04
00F1E:  MOVF   FF3,W
00F20:  CLRF   03
00F22:  ADDLW  97
00F24:  MOVWF  FE9
00F26:  MOVLW  01
00F28:  ADDWFC 03,W
00F2A:  MOVWF  FEA
00F2C:  MOVFF  FEF,00
00F30:  MOVFF  FEC,01
00F34:  MOVFF  FEC,02
00F38:  MOVFF  FEC,03
00F3C:  MOVF   00,W
00F3E:  SUBWF  xEB,W
00F40:  BNZ   1002
00F42:  MOVF   01,W
00F44:  SUBWF  xEC,W
00F46:  BNZ   1002
00F48:  MOVF   02,F
00F4A:  BNZ   1002
00F4C:  MOVF   03,F
00F4E:  BNZ   1002
....................             step_acumulado_x += StepbyF_x[atual_frequencia_x] + StepbyF_x[atual_frequencia_x + 1]; 
00F50:  MOVF   xF7,W
00F52:  MULLW  04
00F54:  MOVF   FF3,W
00F56:  CLRF   03
00F58:  ADDLW  97
00F5A:  MOVWF  FE9
00F5C:  MOVLW  01
00F5E:  ADDWFC 03,W
00F60:  MOVWF  FEA
00F62:  MOVFF  FEF,3DE
00F66:  MOVFF  FEC,3DF
00F6A:  MOVFF  FEC,3E0
00F6E:  MOVFF  FEC,3E1
00F72:  MOVLW  01
00F74:  ADDWF  xF7,W
00F76:  MULLW  04
00F78:  MOVF   FF3,W
00F7A:  CLRF   03
00F7C:  ADDLW  97
00F7E:  MOVWF  FE9
00F80:  MOVLW  01
00F82:  ADDWFC 03,W
00F84:  MOVWF  FEA
00F86:  MOVFF  FEF,00
00F8A:  MOVFF  FEC,01
00F8E:  MOVFF  FEC,02
00F92:  MOVFF  FEC,03
00F96:  MOVLB  3
00F98:  MOVF   xDE,W
00F9A:  ADDWF  00,F
00F9C:  MOVF   xDF,W
00F9E:  ADDWFC 01,F
00FA0:  MOVF   xE0,W
00FA2:  ADDWFC 02,F
00FA4:  MOVF   xE1,W
00FA6:  ADDWFC 03,F
00FA8:  MOVF   00,W
00FAA:  MOVLB  1
00FAC:  ADDWF  xF3,F
00FAE:  MOVF   01,W
00FB0:  ADDWFC xF4,F
00FB2:  MOVF   02,W
00FB4:  ADDWFC xF5,F
00FB6:  MOVF   03,W
00FB8:  ADDWFC xF6,F
....................             atual_frequencia_x++; 
00FBA:  INCF   xF7,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
00FBC:  MOVF   xF7,W
00FBE:  MULLW  04
00FC0:  MOVF   FF3,W
00FC2:  CLRF   03
00FC4:  ADDLW  47
00FC6:  MOVWF  FE9
00FC8:  MOVLW  01
00FCA:  ADDWFC 03,W
00FCC:  MOVWF  FEA
00FCE:  MOVFF  FEF,00
00FD2:  MOVFF  FEC,01
00FD6:  MOVFF  FEC,02
00FDA:  MOVFF  FEC,03
00FDE:  MOVLW  FF
00FE0:  BSF    FD8.0
00FE2:  SUBFWB 00,W
00FE4:  MOVLB  3
00FE6:  MOVWF  xDE
00FE8:  MOVLW  FF
00FEA:  SUBFWB 01,W
00FEC:  MOVWF  xDF
00FEE:  MOVLW  00
00FF0:  SUBFWB 02,W
00FF2:  MOVLW  00
00FF4:  SUBFWB 03,W
00FF6:  MOVFF  3DF,FD7
00FFA:  MOVFF  3DE,FD6
....................         } else { 
00FFE:  BRA    1044
01000:  MOVLB  1
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
01002:  MOVF   xF7,W
01004:  MULLW  04
01006:  MOVF   FF3,W
01008:  CLRF   03
0100A:  ADDLW  47
0100C:  MOVWF  FE9
0100E:  MOVLW  01
01010:  ADDWFC 03,W
01012:  MOVWF  FEA
01014:  MOVFF  FEF,00
01018:  MOVFF  FEC,01
0101C:  MOVFF  FEC,02
01020:  MOVFF  FEC,03
01024:  MOVLW  FF
01026:  BSF    FD8.0
01028:  SUBFWB 00,W
0102A:  MOVLB  3
0102C:  MOVWF  xDE
0102E:  MOVLW  FF
01030:  SUBFWB 01,W
01032:  MOVWF  xDF
01034:  MOVLW  00
01036:  SUBFWB 02,W
01038:  MOVLW  00
0103A:  SUBFWB 03,W
0103C:  MOVFF  3DF,FD7
01040:  MOVFF  3DE,FD6
....................         } 
....................     } else if (atual_frequencia_x == vel_x) { 
01044:  BRA    1164
01046:  MOVLB  1
01048:  MOVF   xF8,W
0104A:  SUBWF  xF7,W
0104C:  BNZ   1094
....................         set_timer0(65535 - Ts_x[atual_frequencia_x]); 
0104E:  MOVF   xF7,W
01050:  MULLW  04
01052:  MOVF   FF3,W
01054:  CLRF   03
01056:  ADDLW  47
01058:  MOVWF  FE9
0105A:  MOVLW  01
0105C:  ADDWFC 03,W
0105E:  MOVWF  FEA
01060:  MOVFF  FEF,00
01064:  MOVFF  FEC,01
01068:  MOVFF  FEC,02
0106C:  MOVFF  FEC,03
01070:  MOVLW  FF
01072:  BSF    FD8.0
01074:  SUBFWB 00,W
01076:  MOVLB  3
01078:  MOVWF  xDE
0107A:  MOVLW  FF
0107C:  SUBFWB 01,W
0107E:  MOVWF  xDF
01080:  MOVLW  00
01082:  SUBFWB 02,W
01084:  MOVLW  00
01086:  SUBFWB 03,W
01088:  MOVFF  3DF,FD7
0108C:  MOVFF  3DE,FD6
....................     } else { 
01090:  BRA    1164
01092:  MOVLB  1
....................         if (step_no_x == step_acumulado_x) { 
01094:  MOVF   xF3,W
01096:  SUBWF  xEB,W
01098:  BNZ   1122
0109A:  MOVF   xF4,W
0109C:  SUBWF  xEC,W
0109E:  BNZ   1122
010A0:  MOVF   xF5,F
010A2:  BNZ   1122
010A4:  MOVF   xF6,F
010A6:  BNZ   1122
....................             atual_frequencia_x++; 
010A8:  INCF   xF7,F
....................             step_acumulado_x += StepbyF_x[atual_frequencia_x]; 
010AA:  MOVF   xF7,W
010AC:  MULLW  04
010AE:  MOVF   FF3,W
010B0:  CLRF   03
010B2:  ADDLW  97
010B4:  MOVWF  FE9
010B6:  MOVLW  01
010B8:  ADDWFC 03,W
010BA:  MOVWF  FEA
010BC:  MOVFF  FEF,00
010C0:  MOVFF  FEC,01
010C4:  MOVFF  FEC,02
010C8:  MOVFF  FEC,03
010CC:  MOVF   00,W
010CE:  ADDWF  xF3,F
010D0:  MOVF   01,W
010D2:  ADDWFC xF4,F
010D4:  MOVF   02,W
010D6:  ADDWFC xF5,F
010D8:  MOVF   03,W
010DA:  ADDWFC xF6,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
010DC:  MOVF   xF7,W
010DE:  MULLW  04
010E0:  MOVF   FF3,W
010E2:  CLRF   03
010E4:  ADDLW  47
010E6:  MOVWF  FE9
010E8:  MOVLW  01
010EA:  ADDWFC 03,W
010EC:  MOVWF  FEA
010EE:  MOVFF  FEF,00
010F2:  MOVFF  FEC,01
010F6:  MOVFF  FEC,02
010FA:  MOVFF  FEC,03
010FE:  MOVLW  FF
01100:  BSF    FD8.0
01102:  SUBFWB 00,W
01104:  MOVLB  3
01106:  MOVWF  xDE
01108:  MOVLW  FF
0110A:  SUBFWB 01,W
0110C:  MOVWF  xDF
0110E:  MOVLW  00
01110:  SUBFWB 02,W
01112:  MOVLW  00
01114:  SUBFWB 03,W
01116:  MOVFF  3DF,FD7
0111A:  MOVFF  3DE,FD6
....................         } else { 
0111E:  BRA    1164
01120:  MOVLB  1
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
01122:  MOVF   xF7,W
01124:  MULLW  04
01126:  MOVF   FF3,W
01128:  CLRF   03
0112A:  ADDLW  47
0112C:  MOVWF  FE9
0112E:  MOVLW  01
01130:  ADDWFC 03,W
01132:  MOVWF  FEA
01134:  MOVFF  FEF,00
01138:  MOVFF  FEC,01
0113C:  MOVFF  FEC,02
01140:  MOVFF  FEC,03
01144:  MOVLW  FF
01146:  BSF    FD8.0
01148:  SUBFWB 00,W
0114A:  MOVLB  3
0114C:  MOVWF  xDE
0114E:  MOVLW  FF
01150:  SUBFWB 01,W
01152:  MOVWF  xDF
01154:  MOVLW  00
01156:  SUBFWB 02,W
01158:  MOVLW  00
0115A:  SUBFWB 03,W
0115C:  MOVFF  3DF,FD7
01160:  MOVFF  3DE,FD6
....................         } 
....................         break; 
....................     } 
01164:  MOVLB  0
01166:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_descida_x() { 
....................     if (atual_frequencia_x == 0) { 
01168:  MOVLB  1
0116A:  MOVF   xF7,F
0116C:  BNZ   11B4
....................         set_timer0(65535 - Ts_x[atual_frequencia_x]); 
0116E:  MOVF   xF7,W
01170:  MULLW  04
01172:  MOVF   FF3,W
01174:  CLRF   03
01176:  ADDLW  47
01178:  MOVWF  FE9
0117A:  MOVLW  01
0117C:  ADDWFC 03,W
0117E:  MOVWF  FEA
01180:  MOVFF  FEF,00
01184:  MOVFF  FEC,01
01188:  MOVFF  FEC,02
0118C:  MOVFF  FEC,03
01190:  MOVLW  FF
01192:  BSF    FD8.0
01194:  SUBFWB 00,W
01196:  MOVLB  3
01198:  MOVWF  xDE
0119A:  MOVLW  FF
0119C:  SUBFWB 01,W
0119E:  MOVWF  xDF
011A0:  MOVLW  00
011A2:  SUBFWB 02,W
011A4:  MOVLW  00
011A6:  SUBFWB 03,W
011A8:  MOVFF  3DF,FD7
011AC:  MOVFF  3DE,FD6
....................     }  
011B0:  BRA    13EC
011B2:  MOVLB  1
....................     else if (atual_frequencia_x == vel_x) { 
011B4:  MOVF   xF8,W
011B6:  SUBWF  xF7,W
011B8:  BTFSS  FD8.2
011BA:  BRA    131C
....................         if (step_no_x == (step_down_x + StepbyF_x[atual_frequencia_x])) { 
011BC:  MOVF   xF7,W
011BE:  MULLW  04
011C0:  MOVF   FF3,W
011C2:  CLRF   03
011C4:  ADDLW  97
011C6:  MOVWF  FE9
011C8:  MOVLW  01
011CA:  ADDWFC 03,W
011CC:  MOVWF  FEA
011CE:  MOVFF  FEF,00
011D2:  MOVFF  FEC,01
011D6:  MOVFF  FEC,02
011DA:  MOVFF  FEC,03
011DE:  MOVF   xED,W
011E0:  ADDWF  00,F
011E2:  MOVF   xEE,W
011E4:  ADDWFC 01,F
011E6:  MOVLW  00
011E8:  ADDWFC 02,F
011EA:  ADDWFC 03,F
011EC:  MOVF   00,W
011EE:  SUBWF  xEB,W
011F0:  BNZ   12D6
011F2:  MOVF   01,W
011F4:  SUBWF  xEC,W
011F6:  BNZ   12D6
011F8:  MOVF   02,F
011FA:  BNZ   12D6
011FC:  MOVF   03,F
011FE:  BNZ   12D6
....................             step_acumulado_x = step_down_x + StepbyF_x[atual_frequencia_x] + StepbyF_x[atual_frequencia_x - 1]; 
01200:  MOVF   xF7,W
01202:  MULLW  04
01204:  MOVF   FF3,W
01206:  CLRF   03
01208:  ADDLW  97
0120A:  MOVWF  FE9
0120C:  MOVLW  01
0120E:  ADDWFC 03,W
01210:  MOVWF  FEA
01212:  MOVFF  FEF,00
01216:  MOVFF  FEC,01
0121A:  MOVFF  FEC,02
0121E:  MOVFF  FEC,03
01222:  MOVF   00,W
01224:  ADDWF  xED,W
01226:  MOVLB  3
01228:  MOVWF  xDE
0122A:  MOVF   01,W
0122C:  MOVLB  1
0122E:  ADDWFC xEE,W
01230:  MOVLB  3
01232:  MOVWF  xDF
01234:  MOVLW  00
01236:  ADDWFC 02,W
01238:  MOVWF  xE0
0123A:  MOVLW  00
0123C:  ADDWFC 03,W
0123E:  MOVWF  xE1
01240:  MOVLW  01
01242:  MOVLB  1
01244:  SUBWF  xF7,W
01246:  MULLW  04
01248:  MOVF   FF3,W
0124A:  CLRF   03
0124C:  ADDLW  97
0124E:  MOVWF  FE9
01250:  MOVLW  01
01252:  ADDWFC 03,W
01254:  MOVWF  FEA
01256:  MOVFF  FEF,00
0125A:  MOVFF  FEC,01
0125E:  MOVFF  FEC,02
01262:  MOVFF  FEC,03
01266:  MOVF   00,W
01268:  MOVLB  3
0126A:  ADDWF  xDE,W
0126C:  MOVLB  1
0126E:  MOVWF  xF3
01270:  MOVF   01,W
01272:  MOVLB  3
01274:  ADDWFC xDF,W
01276:  MOVLB  1
01278:  MOVWF  xF4
0127A:  MOVF   02,W
0127C:  MOVLB  3
0127E:  ADDWFC xE0,W
01280:  MOVLB  1
01282:  MOVWF  xF5
01284:  MOVF   03,W
01286:  MOVLB  3
01288:  ADDWFC xE1,W
0128A:  MOVLB  1
0128C:  MOVWF  xF6
....................             atual_frequencia_x--; 
0128E:  DECF   xF7,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
01290:  MOVF   xF7,W
01292:  MULLW  04
01294:  MOVF   FF3,W
01296:  CLRF   03
01298:  ADDLW  47
0129A:  MOVWF  FE9
0129C:  MOVLW  01
0129E:  ADDWFC 03,W
012A0:  MOVWF  FEA
012A2:  MOVFF  FEF,00
012A6:  MOVFF  FEC,01
012AA:  MOVFF  FEC,02
012AE:  MOVFF  FEC,03
012B2:  MOVLW  FF
012B4:  BSF    FD8.0
012B6:  SUBFWB 00,W
012B8:  MOVLB  3
012BA:  MOVWF  xDE
012BC:  MOVLW  FF
012BE:  SUBFWB 01,W
012C0:  MOVWF  xDF
012C2:  MOVLW  00
012C4:  SUBFWB 02,W
012C6:  MOVLW  00
012C8:  SUBFWB 03,W
012CA:  MOVFF  3DF,FD7
012CE:  MOVFF  3DE,FD6
....................         } else { 
012D2:  BRA    1318
012D4:  MOVLB  1
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
012D6:  MOVF   xF7,W
012D8:  MULLW  04
012DA:  MOVF   FF3,W
012DC:  CLRF   03
012DE:  ADDLW  47
012E0:  MOVWF  FE9
012E2:  MOVLW  01
012E4:  ADDWFC 03,W
012E6:  MOVWF  FEA
012E8:  MOVFF  FEF,00
012EC:  MOVFF  FEC,01
012F0:  MOVFF  FEC,02
012F4:  MOVFF  FEC,03
012F8:  MOVLW  FF
012FA:  BSF    FD8.0
012FC:  SUBFWB 00,W
012FE:  MOVLB  3
01300:  MOVWF  xDE
01302:  MOVLW  FF
01304:  SUBFWB 01,W
01306:  MOVWF  xDF
01308:  MOVLW  00
0130A:  SUBFWB 02,W
0130C:  MOVLW  00
0130E:  SUBFWB 03,W
01310:  MOVFF  3DF,FD7
01314:  MOVFF  3DE,FD6
....................         } 
....................     } else { 
01318:  BRA    13EC
0131A:  MOVLB  1
....................         if (step_no_x == step_acumulado_x) { 
0131C:  MOVF   xF3,W
0131E:  SUBWF  xEB,W
01320:  BNZ   13AA
01322:  MOVF   xF4,W
01324:  SUBWF  xEC,W
01326:  BNZ   13AA
01328:  MOVF   xF5,F
0132A:  BNZ   13AA
0132C:  MOVF   xF6,F
0132E:  BNZ   13AA
....................             atual_frequencia_x--; 
01330:  DECF   xF7,F
....................             step_acumulado_x += StepbyF_x[atual_frequencia_x]; 
01332:  MOVF   xF7,W
01334:  MULLW  04
01336:  MOVF   FF3,W
01338:  CLRF   03
0133A:  ADDLW  97
0133C:  MOVWF  FE9
0133E:  MOVLW  01
01340:  ADDWFC 03,W
01342:  MOVWF  FEA
01344:  MOVFF  FEF,00
01348:  MOVFF  FEC,01
0134C:  MOVFF  FEC,02
01350:  MOVFF  FEC,03
01354:  MOVF   00,W
01356:  ADDWF  xF3,F
01358:  MOVF   01,W
0135A:  ADDWFC xF4,F
0135C:  MOVF   02,W
0135E:  ADDWFC xF5,F
01360:  MOVF   03,W
01362:  ADDWFC xF6,F
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
01364:  MOVF   xF7,W
01366:  MULLW  04
01368:  MOVF   FF3,W
0136A:  CLRF   03
0136C:  ADDLW  47
0136E:  MOVWF  FE9
01370:  MOVLW  01
01372:  ADDWFC 03,W
01374:  MOVWF  FEA
01376:  MOVFF  FEF,00
0137A:  MOVFF  FEC,01
0137E:  MOVFF  FEC,02
01382:  MOVFF  FEC,03
01386:  MOVLW  FF
01388:  BSF    FD8.0
0138A:  SUBFWB 00,W
0138C:  MOVLB  3
0138E:  MOVWF  xDE
01390:  MOVLW  FF
01392:  SUBFWB 01,W
01394:  MOVWF  xDF
01396:  MOVLW  00
01398:  SUBFWB 02,W
0139A:  MOVLW  00
0139C:  SUBFWB 03,W
0139E:  MOVFF  3DF,FD7
013A2:  MOVFF  3DE,FD6
....................         } else { 
013A6:  BRA    13EC
013A8:  MOVLB  1
....................             set_timer0(65535 - Ts_x[atual_frequencia_x]); 
013AA:  MOVF   xF7,W
013AC:  MULLW  04
013AE:  MOVF   FF3,W
013B0:  CLRF   03
013B2:  ADDLW  47
013B4:  MOVWF  FE9
013B6:  MOVLW  01
013B8:  ADDWFC 03,W
013BA:  MOVWF  FEA
013BC:  MOVFF  FEF,00
013C0:  MOVFF  FEC,01
013C4:  MOVFF  FEC,02
013C8:  MOVFF  FEC,03
013CC:  MOVLW  FF
013CE:  BSF    FD8.0
013D0:  SUBFWB 00,W
013D2:  MOVLB  3
013D4:  MOVWF  xDE
013D6:  MOVLW  FF
013D8:  SUBFWB 01,W
013DA:  MOVWF  xDF
013DC:  MOVLW  00
013DE:  SUBFWB 02,W
013E0:  MOVLW  00
013E2:  SUBFWB 03,W
013E4:  MOVFF  3DF,FD7
013E8:  MOVFF  3DE,FD6
....................         } 
....................     } 
013EC:  MOVLB  0
013EE:  GOTO   1446 (RETURN)
.................... } 
....................  
.................... void movimenta_eixo_x() { 
....................   
....................     switch (ramp_sts_x) { 
013F2:  MOVLB  1
013F4:  MOVF   xEA,W
013F6:  XORLW  01
013F8:  MOVLB  0
013FA:  BZ    1406
013FC:  XORLW  02
013FE:  BZ    1444
01400:  XORLW  01
01402:  BZ    1460
01404:  BRA    147E
....................         case ramp_up: // accel 
....................             proximo_valor_subida_x(); 
01406:  RCALL  0F12
....................             if (step_no_x == midpt_x) { // midpoint: decel 
01408:  MOVLB  1
0140A:  MOVF   xF1,W
0140C:  SUBWF  xEB,W
0140E:  BNZ   143C
01410:  MOVF   xF2,W
01412:  SUBWF  xEC,W
01414:  BNZ   143C
....................                 if (move_x > 2 * total_acc_step_x) 
01416:  BCF    FD8.0
01418:  RLCF   xE7,W
0141A:  MOVWF  02
0141C:  RLCF   xE8,W
0141E:  MOVWF  03
01420:  MOVFF  02,01
01424:  MOVF   03,W
01426:  SUBWF  xF0,W
01428:  BNC   1438
0142A:  BNZ   1432
0142C:  MOVF   xEF,W
0142E:  SUBWF  01,W
01430:  BC    1438
....................                     ramp_sts_x = ramp_max; 
01432:  MOVLW  02
01434:  MOVWF  xEA
01436:  BRA    143C
....................                 else 
....................                     ramp_sts_x = ramp_down; 
01438:  MOVLW  03
0143A:  MOVWF  xEA
....................             } 
....................             output_toggle(step_x); 
0143C:  BCF    F95.2
0143E:  BTG    F8C.2
....................             rest_x = ~rest_x; 
01440:  BTG    x1A.5
....................             break; 
01442:  BRA    1486
....................  
....................         case ramp_down: // decel 
....................             proximo_valor_descida_x(); 
01444:  BRA    1168
....................             if (step_no_x == move_x) 
01446:  MOVLB  1
01448:  MOVF   xEF,W
0144A:  SUBWF  xEB,W
0144C:  BNZ   1458
0144E:  MOVF   xF0,W
01450:  SUBWF  xEC,W
01452:  BNZ   1458
....................                 ramp_sts_x = ramp_last; 
01454:  MOVLW  04
01456:  MOVWF  xEA
....................             output_toggle(step_x); 
01458:  BCF    F95.2
0145A:  BTG    F8C.2
....................             rest_x = ~rest_x; 
0145C:  BTG    x1A.5
....................             break; 
0145E:  BRA    1486
....................  
....................         case ramp_max: // constant speed 
....................             proximo_valor_subida_x(); 
01460:  RCALL  0F12
....................             if (step_no_x == step_down_x) // start decel 
01462:  MOVLB  1
01464:  MOVF   xED,W
01466:  SUBWF  xEB,W
01468:  BNZ   1474
0146A:  MOVF   xEE,W
0146C:  SUBWF  xEC,W
0146E:  BNZ   1474
....................                 ramp_sts_x = ramp_down; 
01470:  MOVLW  03
01472:  MOVWF  xEA
....................             output_toggle(step_x); 
01474:  BCF    F95.2
01476:  BTG    F8C.2
....................             rest_x = ~rest_x; 
01478:  BTG    x1A.5
....................             break; 
0147A:  BRA    1486
0147C:  MOVLB  0
....................  
....................         default: // last step: cleanup 
....................             ramp_sts_x = ramp_idle; 
0147E:  MOVLB  1
01480:  CLRF   xEA
....................             disable_interrupts(INT_TIMER0); 
01482:  BCF    FF2.5
....................             run_flg_x = FALSE; // move_x complete 
01484:  BCF    x1A.4
....................             break; 
....................     } // switch (ramp_sts_x) 
....................     if ((ramp_sts_x != ramp_idle)&&(ramp_sts_x != ramp_last)) { 
01486:  MOVF   xEA,F
01488:  BZ    14B2
0148A:  MOVF   xEA,W
0148C:  SUBLW  04
0148E:  BZ    14B2
....................         if (rest_x) { 
01490:  BTFSS  x1A.5
01492:  BRA    14B2
....................             motor_pos_x += pos_inc_x; 
01494:  CLRF   03
01496:  MOVF   xE9,W
01498:  BTFSC  FE8.7
0149A:  DECF   03,F
0149C:  ADDWF  x12,W
0149E:  MOVWF  01
014A0:  MOVF   x13,W
014A2:  ADDWFC 03,F
014A4:  MOVFF  01,112
014A8:  MOVFF  03,113
....................             ++step_no_x;    
014AC:  INCF   xEB,F
014AE:  BTFSC  FD8.2
014B0:  INCF   xEC,F
....................         } 
....................     } 
014B2:  MOVLB  0
014B4:  GOTO   14BA (RETURN)
.................... } 
....................  
.................... void umpasso_x(int16 descanco, short dir) { 
....................     output_low(enable_x); 
....................     if (dir) { 
....................         output_high(dir_x); 
....................         motor_pos_x++; 
....................     } else { 
....................         output_low(dir_x); 
....................         motor_pos_x--; 
....................     } 
....................     output_high(step_x); 
....................     delay_us(descanco); 
....................     output_low(step_x); 
....................     delay_us(descanco); 
....................      
.................... } 
....................  
.................... void zerar_x() { 
....................     while(le_Input(i_limite_x)==1){ 
....................         delay_us(200); 
....................         umpasso_x(600, TRUE); 
....................     } 
....................     while (le_Input(i_limite_x)==0){ 
....................         umpasso_x(900, FALSE); 
....................         delay_us(200); 
....................     } 
....................     while(le_Input(i_limite_x)==1){ 
....................         delay_us(200); 
....................         umpasso_x(1000, TRUE); 
....................     } 
....................     motor_pos_x = 0; 
....................     output_high(enable_x); 
.................... } 
.................... // </editor-fold> 
....................  
.................... #include "Axis_y.c" 
.................... // <editor-fold defaultstate="collapsed" desc="Valores que devem ser inseridos"> 
.................... float stepbyrev_y = 200; 
.................... float driver_u_step_y = 1; // caso o driver esteja em 400 
.................... float Leadscrew_y = 9; //redutor de voltas do motor 
.................... float Leadscrew_Pich_y = 150; //esse valor deve ser em mm/revoluo 
.................... float Vmax_y = 600; //esse valor deve ser em mm por segundo 
.................... float Vmin_y = 200; 
.................... float Amax_y = 500; //esse valor deve ser em mm por segundo 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Valores calculo rampa"> 
.................... float MMbyStep_y = 0; 
.................... int8 StepinAcc_y = 20; 
.................... float Fmax_y = 0; 
.................... float Fmin_y = 100; 
.................... int32 Ts_y[20]; 
.................... int32 StepbyF_y[20]; 
.................... int16 total_acc_step_y = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Flags e Controles de Movimento"> 
.................... signed int8 pos_inc_y = 0; 
.................... int8 ramp_sts_y = ramp_idle; 
.................... short run_flg_y = FALSE; 
.................... short rest_y = FALSE; 
.................... short stop_yf = FALSE; 
.................... int16 step_no_y = 0; 
.................... int16 step_down_y = 0; 
.................... int16 move_y = 0; 
.................... int16 midpt_y = 0; 
.................... int32 step_acumulado_y = 0; 
.................... int atual_frequencia_y = 0; 
.................... int vel_y = 19; 
.................... int16 max_posicao_y=0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Pinos Motor"> 
....................  
.................... #DEFINE     i_limite_y            7 
.................... #DEFINE     s_limite_y            8 
....................  
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Inicializa Motor"> 
.................... void init_axis_y() { 
....................     set_tris_c(0xf8); 
*
030E8:  MOVLW  F8
030EA:  MOVWF  F94
....................     output_high(step_y); 
030EC:  BCF    F94.2
030EE:  BSF    F8B.2
....................     output_high(enable_y); 
030F0:  BCF    F94.0
030F2:  BSF    F8B.0
....................     output_high(dir_y); 
030F4:  BCF    F94.1
030F6:  BSF    F8B.1
....................  
....................     MMbyStep_y = Leadscrew_Pich_y / (stepbyrev_y * driver_u_step_y * Leadscrew_y); 
030F8:  MOVFF  1FC,3CB
030FC:  MOVFF  1FB,3CA
03100:  MOVFF  1FA,3C9
03104:  MOVFF  1F9,3C8
03108:  MOVFF  200,3CF
0310C:  MOVFF  1FF,3CE
03110:  MOVFF  1FE,3CD
03114:  MOVFF  1FD,3CC
03118:  CALL   2632
0311C:  MOVFF  03,3BD
03120:  MOVFF  02,3BC
03124:  MOVFF  01,3BB
03128:  MOVFF  00,3BA
0312C:  MOVFF  03,3CB
03130:  MOVFF  02,3CA
03134:  MOVFF  01,3C9
03138:  MOVFF  00,3C8
0313C:  MOVFF  204,3CF
03140:  MOVFF  203,3CE
03144:  MOVFF  202,3CD
03148:  MOVFF  201,3CC
0314C:  CALL   2632
03150:  MOVFF  208,3D1
03154:  MOVFF  207,3D0
03158:  MOVFF  206,3CF
0315C:  MOVFF  205,3CE
03160:  MOVFF  03,3D5
03164:  MOVFF  02,3D4
03168:  MOVFF  01,3D3
0316C:  MOVFF  00,3D2
03170:  CALL   2728
03174:  MOVFF  03,218
03178:  MOVFF  02,217
0317C:  MOVFF  01,216
03180:  MOVFF  00,215
....................     Fmax_y = Vmax_y/MMbyStep_y; //Valor de ferequencia adiquirido em hz 
03184:  MOVFF  20C,3D1
03188:  MOVFF  20B,3D0
0318C:  MOVFF  20A,3CF
03190:  MOVFF  209,3CE
03194:  MOVFF  218,3D5
03198:  MOVFF  217,3D4
0319C:  MOVFF  216,3D3
031A0:  MOVFF  215,3D2
031A4:  CALL   2728
031A8:  MOVFF  03,21D
031AC:  MOVFF  02,21C
031B0:  MOVFF  01,21B
031B4:  MOVFF  00,21A
....................      
....................     float den = Amax_y*StepinAcc_y; 
....................     float num = (Vmax_y-Vmin_y)*1000000; 
....................     float TbyF = num/den;//tempo em us 
....................      
....................     int i = 0; 
031B8:  MOVLB  3
031BA:  CLRF   xC9
031BC:  MOVFF  219,3C8
031C0:  MOVLB  0
031C2:  CALL   2886
031C6:  MOVFF  214,3CB
031CA:  MOVFF  213,3CA
031CE:  MOVFF  212,3C9
031D2:  MOVFF  211,3C8
031D6:  MOVFF  03,3CF
031DA:  MOVFF  02,3CE
031DE:  MOVFF  01,3CD
031E2:  MOVFF  00,3CC
031E6:  CALL   2632
031EA:  MOVFF  03,3B0
031EE:  MOVFF  02,3AF
031F2:  MOVFF  01,3AE
031F6:  MOVFF  00,3AD
031FA:  BSF    FD8.1
031FC:  MOVFF  20C,3D1
03200:  MOVFF  20B,3D0
03204:  MOVFF  20A,3CF
03208:  MOVFF  209,3CE
0320C:  MOVFF  210,3D5
03210:  MOVFF  20F,3D4
03214:  MOVFF  20E,3D3
03218:  MOVFF  20D,3D2
0321C:  CALL   28BC
03220:  MOVFF  03,3BD
03224:  MOVFF  02,3BC
03228:  MOVFF  01,3BB
0322C:  MOVFF  00,3BA
03230:  MOVFF  03,3CB
03234:  MOVFF  02,3CA
03238:  MOVFF  01,3C9
0323C:  MOVFF  00,3C8
03240:  MOVLB  3
03242:  CLRF   xCF
03244:  MOVLW  24
03246:  MOVWF  xCE
03248:  MOVLW  74
0324A:  MOVWF  xCD
0324C:  MOVLW  92
0324E:  MOVWF  xCC
03250:  MOVLB  0
03252:  CALL   2632
03256:  MOVFF  03,3B4
0325A:  MOVFF  02,3B3
0325E:  MOVFF  01,3B2
03262:  MOVFF  00,3B1
03266:  MOVFF  3B4,3D1
0326A:  MOVFF  3B3,3D0
0326E:  MOVFF  3B2,3CF
03272:  MOVFF  3B1,3CE
03276:  MOVFF  3B0,3D5
0327A:  MOVFF  3AF,3D4
0327E:  MOVFF  3AE,3D3
03282:  MOVFF  3AD,3D2
03286:  CALL   2728
0328A:  MOVFF  03,3B8
0328E:  MOVFF  02,3B7
03292:  MOVFF  01,3B6
03296:  MOVFF  00,3B5
0329A:  MOVLB  3
0329C:  CLRF   xB9
....................     for(i = 1; i <=StepinAcc_y;i++) 
0329E:  MOVLW  01
032A0:  MOVWF  xB9
032A2:  MOVF   xB9,W
032A4:  MOVLB  2
032A6:  SUBWF  x19,W
032A8:  BTFSS  FD8.0
032AA:  BRA    35E2
....................     { 
....................         Ts_y[i-1]=(1000000*StepinAcc_y)/((i*(Fmax_y-Fmin_y)+Fmin_y)); 
032AC:  MOVLW  01
032AE:  MOVLB  3
032B0:  SUBWF  xB9,W
032B2:  MULLW  04
032B4:  MOVF   FF3,W
032B6:  CLRF   03
032B8:  ADDLW  22
032BA:  MOVWF  FE9
032BC:  MOVLW  02
032BE:  ADDWFC 03,W
032C0:  MOVWF  FEA
032C2:  MOVFF  FEA,3BD
032C6:  MOVFF  FE9,3BC
032CA:  CLRF   xC1
032CC:  MOVLW  0F
032CE:  MOVWF  xC0
032D0:  MOVLW  42
032D2:  MOVWF  xBF
032D4:  MOVLW  40
032D6:  MOVWF  xBE
032D8:  CLRF   xC5
032DA:  CLRF   xC4
032DC:  CLRF   xC3
032DE:  MOVFF  219,3C2
032E2:  MOVLB  0
032E4:  RCALL  2B34
032E6:  MOVFF  3BD,FEA
032EA:  MOVFF  3BC,FE9
032EE:  MOVFF  03,3C1
032F2:  MOVFF  02,3C0
032F6:  MOVFF  01,3BF
032FA:  MOVFF  00,3BE
032FE:  MOVFF  FEA,3C3
03302:  MOVFF  FE9,3C2
03306:  BSF    FD8.1
03308:  MOVFF  21D,3D1
0330C:  MOVFF  21C,3D0
03310:  MOVFF  21B,3CF
03314:  MOVFF  21A,3CE
03318:  MOVFF  221,3D5
0331C:  MOVFF  220,3D4
03320:  MOVFF  21F,3D3
03324:  MOVFF  21E,3D2
03328:  CALL   28BC
0332C:  MOVFF  3C3,FEA
03330:  MOVFF  3C2,FE9
03334:  MOVFF  03,3C7
03338:  MOVFF  02,3C6
0333C:  MOVFF  01,3C5
03340:  MOVFF  00,3C4
03344:  MOVLB  3
03346:  CLRF   xC9
03348:  MOVFF  3B9,3C8
0334C:  MOVLB  0
0334E:  CALL   2886
03352:  MOVFF  03,3CB
03356:  MOVFF  02,3CA
0335A:  MOVFF  01,3C9
0335E:  MOVFF  00,3C8
03362:  MOVFF  3C7,3CF
03366:  MOVFF  3C6,3CE
0336A:  MOVFF  3C5,3CD
0336E:  MOVFF  3C4,3CC
03372:  CALL   2632
03376:  MOVFF  03,3CB
0337A:  MOVFF  02,3CA
0337E:  MOVFF  01,3C9
03382:  MOVFF  00,3C8
03386:  MOVFF  FEA,3CD
0338A:  MOVFF  FE9,3CC
0338E:  BCF    FD8.1
03390:  MOVFF  03,3D1
03394:  MOVFF  02,3D0
03398:  MOVFF  01,3CF
0339C:  MOVFF  00,3CE
033A0:  MOVFF  221,3D5
033A4:  MOVFF  220,3D4
033A8:  MOVFF  21F,3D3
033AC:  MOVFF  21E,3D2
033B0:  CALL   28BC
033B4:  MOVFF  3CD,FEA
033B8:  MOVFF  3CC,FE9
033BC:  MOVFF  03,3CB
033C0:  MOVFF  02,3CA
033C4:  MOVFF  01,3C9
033C8:  MOVFF  00,3C8
033CC:  MOVFF  3C1,3D1
033D0:  MOVFF  3C0,3D0
033D4:  MOVFF  3BF,3CF
033D8:  MOVFF  3BE,3CE
033DC:  CALL   2B90
033E0:  MOVFF  03,3D1
033E4:  MOVFF  02,3D0
033E8:  MOVFF  01,3CF
033EC:  MOVFF  00,3CE
033F0:  MOVFF  3CB,3D5
033F4:  MOVFF  3CA,3D4
033F8:  MOVFF  3C9,3D3
033FC:  MOVFF  3C8,3D2
03400:  CALL   2728
03404:  MOVFF  03,3D1
03408:  MOVFF  02,3D0
0340C:  MOVFF  01,3CF
03410:  MOVFF  00,3CE
03414:  CALL   2BC8
03418:  MOVFF  00,FEF
0341C:  MOVFF  01,FEC
03420:  MOVFF  02,FEC
03424:  MOVFF  03,FEC
....................         StepbyF_y[i-1] = 2*TbyF/Ts_y[i-1]; 
03428:  MOVLW  01
0342A:  MOVLB  3
0342C:  SUBWF  xB9,W
0342E:  MULLW  04
03430:  MOVF   FF3,W
03432:  CLRF   03
03434:  ADDLW  72
03436:  MOVWF  01
03438:  MOVLW  02
0343A:  ADDWFC 03,F
0343C:  MOVFF  01,3BA
03440:  MOVFF  03,3BB
03444:  CLRF   xCB
03446:  CLRF   xCA
03448:  CLRF   xC9
0344A:  MOVLW  80
0344C:  MOVWF  xC8
0344E:  MOVFF  3B8,3CF
03452:  MOVFF  3B7,3CE
03456:  MOVFF  3B6,3CD
0345A:  MOVFF  3B5,3CC
0345E:  MOVLB  0
03460:  CALL   2632
03464:  MOVFF  03,3BF
03468:  MOVFF  02,3BE
0346C:  MOVFF  01,3BD
03470:  MOVFF  00,3BC
03474:  MOVLW  01
03476:  MOVLB  3
03478:  SUBWF  xB9,W
0347A:  MULLW  04
0347C:  MOVF   FF3,W
0347E:  CLRF   03
03480:  ADDLW  22
03482:  MOVWF  FE9
03484:  MOVLW  02
03486:  ADDWFC 03,W
03488:  MOVWF  FEA
0348A:  MOVFF  FEF,00
0348E:  MOVFF  FEC,01
03492:  MOVFF  FEC,02
03496:  MOVFF  FEC,03
0349A:  MOVFF  03,3D1
0349E:  MOVFF  02,3D0
034A2:  MOVFF  01,3CF
034A6:  MOVFF  00,3CE
034AA:  MOVLB  0
034AC:  CALL   2B90
034B0:  MOVFF  3BF,3D1
034B4:  MOVFF  3BE,3D0
034B8:  MOVFF  3BD,3CF
034BC:  MOVFF  3BC,3CE
034C0:  MOVFF  03,3D5
034C4:  MOVFF  02,3D4
034C8:  MOVFF  01,3D3
034CC:  MOVFF  00,3D2
034D0:  CALL   2728
034D4:  MOVFF  03,3D1
034D8:  MOVFF  02,3D0
034DC:  MOVFF  01,3CF
034E0:  MOVFF  00,3CE
034E4:  CALL   2BC8
034E8:  MOVFF  3BB,FEA
034EC:  MOVFF  3BA,FE9
034F0:  MOVFF  00,FEF
034F4:  MOVFF  01,FEC
034F8:  MOVFF  02,FEC
034FC:  MOVFF  03,FEC
....................         total_acc_step_y += StepbyF_y[i-1]; 
03500:  MOVLW  01
03502:  MOVLB  3
03504:  SUBWF  xB9,W
03506:  MULLW  04
03508:  MOVF   FF3,W
0350A:  CLRF   03
0350C:  ADDLW  72
0350E:  MOVWF  FE9
03510:  MOVLW  02
03512:  ADDWFC 03,W
03514:  MOVWF  FEA
03516:  MOVFF  FEF,00
0351A:  MOVFF  FEC,01
0351E:  MOVFF  FEC,02
03522:  MOVFF  FEC,03
03526:  MOVF   00,W
03528:  MOVLB  2
0352A:  ADDWF  xC2,F
0352C:  MOVF   01,W
0352E:  ADDWFC xC3,F
....................         Ts_y[i-1] = Ts_y[i-1]/(8*0.2*2);//Tempo/(prescale*ciclodemaquina*metadedociclo) 
03530:  MOVLW  01
03532:  MOVLB  3
03534:  SUBWF  xB9,W
03536:  MULLW  04
03538:  MOVF   FF3,W
0353A:  CLRF   03
0353C:  ADDLW  22
0353E:  MOVWF  01
03540:  MOVLW  02
03542:  ADDWFC 03,F
03544:  MOVFF  01,3BA
03548:  MOVFF  03,3BB
0354C:  MOVLW  01
0354E:  SUBWF  xB9,W
03550:  MULLW  04
03552:  MOVF   FF3,W
03554:  CLRF   03
03556:  ADDLW  22
03558:  MOVWF  FE9
0355A:  MOVLW  02
0355C:  ADDWFC 03,W
0355E:  MOVWF  FEA
03560:  MOVFF  FEF,3BC
03564:  MOVFF  FEC,3BD
03568:  MOVFF  FEC,3BE
0356C:  MOVFF  FEC,3BF
03570:  MOVFF  3BF,3D1
03574:  MOVFF  3BE,3D0
03578:  MOVFF  3BD,3CF
0357C:  MOVFF  3BC,3CE
03580:  MOVLB  0
03582:  CALL   2B90
03586:  MOVFF  03,3D1
0358A:  MOVFF  02,3D0
0358E:  MOVFF  01,3CF
03592:  MOVFF  00,3CE
03596:  MOVLW  CD
03598:  MOVLB  3
0359A:  MOVWF  xD5
0359C:  MOVLW  CC
0359E:  MOVWF  xD4
035A0:  MOVLW  4C
035A2:  MOVWF  xD3
035A4:  MOVLW  80
035A6:  MOVWF  xD2
035A8:  MOVLB  0
035AA:  CALL   2728
035AE:  MOVFF  03,3D1
035B2:  MOVFF  02,3D0
035B6:  MOVFF  01,3CF
035BA:  MOVFF  00,3CE
035BE:  CALL   2BC8
035C2:  MOVFF  3BB,FEA
035C6:  MOVFF  3BA,FE9
035CA:  MOVFF  00,FEF
035CE:  MOVFF  01,FEC
035D2:  MOVFF  02,FEC
035D6:  MOVFF  03,FEC
035DA:  MOVLB  3
035DC:  INCF   xB9,F
035DE:  BRA    32A2
035E0:  MOVLB  2
....................     } 
035E2:  MOVLB  0
035E4:  GOTO   A8FA (RETURN)
.................... } 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Movimento Motor"> 
.................... void motor_stop_y(){ 
....................     step_no_y = step_down_y; 
....................     ramp_sts_y = ramp_down; 
.................... } 
....................  
.................... void motor_disable_y(){ 
....................     output_high(enable_y); 
....................     disable_interrupts(INT_TIMER1); 
.................... } 
....................  
.................... void motor_run_y(int32 pos_new, int velocidade) { // set up to drive motor to pos_new (absolute step#) 
....................     vel_y = velocidade; 
*
0580C:  MOVFF  3B8,2D4
....................     total_acc_step_y = 0; 
05810:  MOVLB  2
05812:  CLRF   xC3
05814:  CLRF   xC2
....................      
....................     if (pos_new < motor_pos_y) // get dir_yection & #steps 
05816:  MOVLB  3
05818:  MOVF   xB7,F
0581A:  BNZ   585A
0581C:  MOVF   xB6,F
0581E:  BNZ   585A
05820:  MOVF   xB5,W
05822:  MOVLB  1
05824:  SUBWF  x15,W
05826:  BTFSC  FD8.0
05828:  BRA    582E
0582A:  MOVLB  3
0582C:  BRA    585A
0582E:  BNZ   583A
05830:  MOVF   x14,W
05832:  MOVLB  3
05834:  SUBWF  xB4,W
05836:  BC    585A
05838:  MOVLB  1
....................     { 
....................         output_low(dir_y); 
0583A:  BCF    F94.1
0583C:  BCF    F8B.1
....................         move_y = motor_pos_y - pos_new; 
0583E:  MOVLB  3
05840:  MOVF   xB4,W
05842:  MOVLB  1
05844:  SUBWF  x14,W
05846:  MOVLB  2
05848:  MOVWF  xCB
0584A:  MOVLB  3
0584C:  MOVF   xB5,W
0584E:  MOVLB  1
05850:  SUBWFB x15,W
05852:  MOVLB  2
05854:  MOVWF  xCC
....................         pos_inc_y = -1; 
05856:  SETF   xC4
....................     } else if (pos_new != motor_pos_y) { 
05858:  BRA    589E
0585A:  MOVLB  1
0585C:  MOVF   x14,W
0585E:  MOVLB  3
05860:  SUBWF  xB4,W
05862:  BNZ   5876
05864:  MOVLB  1
05866:  MOVF   x15,W
05868:  MOVLB  3
0586A:  SUBWF  xB5,W
0586C:  BNZ   5876
0586E:  MOVF   xB6,F
05870:  BNZ   5876
05872:  MOVF   xB7,F
05874:  BZ    589A
....................         output_high(dir_y); 
05876:  BCF    F94.1
05878:  BSF    F8B.1
....................         move_y = pos_new - motor_pos_y; 
0587A:  MOVLB  1
0587C:  MOVF   x14,W
0587E:  MOVLB  3
05880:  SUBWF  xB4,W
05882:  MOVLB  2
05884:  MOVWF  xCB
05886:  MOVLB  1
05888:  MOVF   x15,W
0588A:  MOVLB  3
0588C:  SUBWFB xB5,W
0588E:  MOVLB  2
05890:  MOVWF  xCC
....................         pos_inc_y = 1; 
05892:  MOVLW  01
05894:  MOVWF  xC4
....................     } else return; 
05896:  BRA    589E
05898:  MOVLB  3
0589A:  BRA    5984
0589C:  MOVLB  2
....................  
....................     for(int j = 0; j <= velocidade;j++) 
0589E:  MOVLB  3
058A0:  CLRF   xB9
058A2:  MOVF   xB9,W
058A4:  SUBWF  xB8,W
058A6:  BNC   58DA
....................     { 
....................         total_acc_step_y += StepbyF_y[j]; 
058A8:  MOVF   xB9,W
058AA:  MULLW  04
058AC:  MOVF   FF3,W
058AE:  CLRF   03
058B0:  ADDLW  72
058B2:  MOVWF  FE9
058B4:  MOVLW  02
058B6:  ADDWFC 03,W
058B8:  MOVWF  FEA
058BA:  MOVFF  FEF,00
058BE:  MOVFF  FEC,01
058C2:  MOVFF  FEC,02
058C6:  MOVFF  FEC,03
058CA:  MOVF   00,W
058CC:  MOVLB  2
058CE:  ADDWF  xC2,F
058D0:  MOVF   01,W
058D2:  ADDWFC xC3,F
058D4:  MOVLB  3
058D6:  INCF   xB9,F
058D8:  BRA    58A2
....................     } 
....................     if (move_y > 2 * total_acc_step_y) { 
058DA:  BCF    FD8.0
058DC:  MOVLB  2
058DE:  RLCF   xC2,W
058E0:  MOVWF  02
058E2:  RLCF   xC3,W
058E4:  MOVWF  03
058E6:  MOVFF  02,01
058EA:  MOVF   03,W
058EC:  SUBWF  xCC,W
058EE:  BNC   590E
058F0:  BNZ   58F8
058F2:  MOVF   xCB,W
058F4:  SUBWF  01,W
058F6:  BC    590E
....................         midpt_y = total_acc_step_y; 
058F8:  MOVFF  2C3,2CE
058FC:  MOVFF  2C2,2CD
....................         step_down_y = move_y - total_acc_step_y; 
05900:  MOVF   xC2,W
05902:  SUBWF  xCB,W
05904:  MOVWF  xC9
05906:  MOVF   xC3,W
05908:  SUBWFB xCC,W
0590A:  MOVWF  xCA
....................     }  
0590C:  BRA    5938
....................     else 
....................     { 
....................         midpt_y = (move_y - 1) >> 1; 
0590E:  MOVLW  01
05910:  SUBWF  xCB,W
05912:  MOVLB  3
05914:  MOVWF  xBA
05916:  MOVLW  00
05918:  MOVLB  2
0591A:  SUBWFB xCC,W
0591C:  MOVLB  3
0591E:  MOVWF  xBB
05920:  BCF    FD8.0
05922:  RRCF   xBB,W
05924:  MOVLB  2
05926:  MOVWF  xCE
05928:  MOVLB  3
0592A:  RRCF   xBA,W
0592C:  MOVLB  2
0592E:  MOVWF  xCD
....................         step_down_y = midpt_y; 
05930:  MOVFF  2CE,2CA
05934:  MOVFF  2CD,2C9
....................     } 
....................     step_no_y = 0; 
05938:  CLRF   xC8
0593A:  CLRF   xC7
....................     step_acumulado_y = 0; 
0593C:  CLRF   xD2
0593E:  CLRF   xD1
05940:  CLRF   xD0
05942:  CLRF   xCF
....................     atual_frequencia_y = 0; 
05944:  CLRF   xD3
....................     ramp_sts_y = ramp_up; // start ramp state-machine 
05946:  MOVLW  01
05948:  MOVWF  xC5
....................     run_flg_y = TRUE; 
0594A:  MOVLB  1
0594C:  BSF    x1A.6
....................     output_low(enable_y); 
0594E:  BCF    F94.0
05950:  BCF    F8B.0
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
05952:  MOVLW  B5
05954:  MOVWF  FCD
....................     set_timer1(65535 - Ts_y[0]); 
05956:  MOVLW  FF
05958:  BSF    FD8.0
0595A:  MOVLB  2
0595C:  SUBFWB x22,W
0595E:  MOVLB  3
05960:  MOVWF  xBA
05962:  MOVLW  FF
05964:  MOVLB  2
05966:  SUBFWB x23,W
05968:  MOVLB  3
0596A:  MOVWF  xBB
0596C:  MOVLW  00
0596E:  MOVLB  2
05970:  SUBFWB x24,W
05972:  MOVLW  00
05974:  MOVLB  2
05976:  SUBFWB x25,W
05978:  MOVLB  3
0597A:  MOVFF  3BB,FCF
0597E:  MOVFF  3BA,FCE
....................     enable_interrupts(INT_TIMER1); 
05982:  BSF    F9D.0
05984:  MOVLB  0
05986:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_subida_y() { 
....................     if (atual_frequencia_y == 0) { 
*
014C0:  MOVLB  2
014C2:  MOVF   xD3,F
014C4:  BTFSS  FD8.2
014C6:  BRA    15F6
....................         if (step_no_y == StepbyF_y[atual_frequencia_y]) { 
014C8:  MOVF   xD3,W
014CA:  MULLW  04
014CC:  MOVF   FF3,W
014CE:  CLRF   03
014D0:  ADDLW  72
014D2:  MOVWF  FE9
014D4:  MOVLW  02
014D6:  ADDWFC 03,W
014D8:  MOVWF  FEA
014DA:  MOVFF  FEF,00
014DE:  MOVFF  FEC,01
014E2:  MOVFF  FEC,02
014E6:  MOVFF  FEC,03
014EA:  MOVF   00,W
014EC:  SUBWF  xC7,W
014EE:  BNZ   15B0
014F0:  MOVF   01,W
014F2:  SUBWF  xC8,W
014F4:  BNZ   15B0
014F6:  MOVF   02,F
014F8:  BNZ   15B0
014FA:  MOVF   03,F
014FC:  BNZ   15B0
....................             step_acumulado_y += StepbyF_y[atual_frequencia_y] + StepbyF_y[atual_frequencia_y + 1]; 
014FE:  MOVF   xD3,W
01500:  MULLW  04
01502:  MOVF   FF3,W
01504:  CLRF   03
01506:  ADDLW  72
01508:  MOVWF  FE9
0150A:  MOVLW  02
0150C:  ADDWFC 03,W
0150E:  MOVWF  FEA
01510:  MOVFF  FEF,3DE
01514:  MOVFF  FEC,3DF
01518:  MOVFF  FEC,3E0
0151C:  MOVFF  FEC,3E1
01520:  MOVLW  01
01522:  ADDWF  xD3,W
01524:  MULLW  04
01526:  MOVF   FF3,W
01528:  CLRF   03
0152A:  ADDLW  72
0152C:  MOVWF  FE9
0152E:  MOVLW  02
01530:  ADDWFC 03,W
01532:  MOVWF  FEA
01534:  MOVFF  FEF,00
01538:  MOVFF  FEC,01
0153C:  MOVFF  FEC,02
01540:  MOVFF  FEC,03
01544:  MOVLB  3
01546:  MOVF   xDE,W
01548:  ADDWF  00,F
0154A:  MOVF   xDF,W
0154C:  ADDWFC 01,F
0154E:  MOVF   xE0,W
01550:  ADDWFC 02,F
01552:  MOVF   xE1,W
01554:  ADDWFC 03,F
01556:  MOVF   00,W
01558:  MOVLB  2
0155A:  ADDWF  xCF,F
0155C:  MOVF   01,W
0155E:  ADDWFC xD0,F
01560:  MOVF   02,W
01562:  ADDWFC xD1,F
01564:  MOVF   03,W
01566:  ADDWFC xD2,F
....................             atual_frequencia_y++; 
01568:  INCF   xD3,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
0156A:  MOVF   xD3,W
0156C:  MULLW  04
0156E:  MOVF   FF3,W
01570:  CLRF   03
01572:  ADDLW  22
01574:  MOVWF  FE9
01576:  MOVLW  02
01578:  ADDWFC 03,W
0157A:  MOVWF  FEA
0157C:  MOVFF  FEF,00
01580:  MOVFF  FEC,01
01584:  MOVFF  FEC,02
01588:  MOVFF  FEC,03
0158C:  MOVLW  FF
0158E:  BSF    FD8.0
01590:  SUBFWB 00,W
01592:  MOVLB  3
01594:  MOVWF  xDE
01596:  MOVLW  FF
01598:  SUBFWB 01,W
0159A:  MOVWF  xDF
0159C:  MOVLW  00
0159E:  SUBFWB 02,W
015A0:  MOVLW  00
015A2:  SUBFWB 03,W
015A4:  MOVFF  3DF,FCF
015A8:  MOVFF  3DE,FCE
....................         } else { 
015AC:  BRA    15F2
015AE:  MOVLB  2
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
015B0:  MOVF   xD3,W
015B2:  MULLW  04
015B4:  MOVF   FF3,W
015B6:  CLRF   03
015B8:  ADDLW  22
015BA:  MOVWF  FE9
015BC:  MOVLW  02
015BE:  ADDWFC 03,W
015C0:  MOVWF  FEA
015C2:  MOVFF  FEF,00
015C6:  MOVFF  FEC,01
015CA:  MOVFF  FEC,02
015CE:  MOVFF  FEC,03
015D2:  MOVLW  FF
015D4:  BSF    FD8.0
015D6:  SUBFWB 00,W
015D8:  MOVLB  3
015DA:  MOVWF  xDE
015DC:  MOVLW  FF
015DE:  SUBFWB 01,W
015E0:  MOVWF  xDF
015E2:  MOVLW  00
015E4:  SUBFWB 02,W
015E6:  MOVLW  00
015E8:  SUBFWB 03,W
015EA:  MOVFF  3DF,FCF
015EE:  MOVFF  3DE,FCE
....................         } 
....................     } else if (atual_frequencia_y == vel_y) { 
015F2:  BRA    1712
015F4:  MOVLB  2
015F6:  MOVF   xD4,W
015F8:  SUBWF  xD3,W
015FA:  BNZ   1642
....................         set_timer1(65535 - Ts_y[atual_frequencia_y]); 
015FC:  MOVF   xD3,W
015FE:  MULLW  04
01600:  MOVF   FF3,W
01602:  CLRF   03
01604:  ADDLW  22
01606:  MOVWF  FE9
01608:  MOVLW  02
0160A:  ADDWFC 03,W
0160C:  MOVWF  FEA
0160E:  MOVFF  FEF,00
01612:  MOVFF  FEC,01
01616:  MOVFF  FEC,02
0161A:  MOVFF  FEC,03
0161E:  MOVLW  FF
01620:  BSF    FD8.0
01622:  SUBFWB 00,W
01624:  MOVLB  3
01626:  MOVWF  xDE
01628:  MOVLW  FF
0162A:  SUBFWB 01,W
0162C:  MOVWF  xDF
0162E:  MOVLW  00
01630:  SUBFWB 02,W
01632:  MOVLW  00
01634:  SUBFWB 03,W
01636:  MOVFF  3DF,FCF
0163A:  MOVFF  3DE,FCE
....................     } else { 
0163E:  BRA    1712
01640:  MOVLB  2
....................         if (step_no_y == step_acumulado_y) { 
01642:  MOVF   xCF,W
01644:  SUBWF  xC7,W
01646:  BNZ   16D0
01648:  MOVF   xD0,W
0164A:  SUBWF  xC8,W
0164C:  BNZ   16D0
0164E:  MOVF   xD1,F
01650:  BNZ   16D0
01652:  MOVF   xD2,F
01654:  BNZ   16D0
....................             atual_frequencia_y++; 
01656:  INCF   xD3,F
....................             step_acumulado_y += StepbyF_y[atual_frequencia_y]; 
01658:  MOVF   xD3,W
0165A:  MULLW  04
0165C:  MOVF   FF3,W
0165E:  CLRF   03
01660:  ADDLW  72
01662:  MOVWF  FE9
01664:  MOVLW  02
01666:  ADDWFC 03,W
01668:  MOVWF  FEA
0166A:  MOVFF  FEF,00
0166E:  MOVFF  FEC,01
01672:  MOVFF  FEC,02
01676:  MOVFF  FEC,03
0167A:  MOVF   00,W
0167C:  ADDWF  xCF,F
0167E:  MOVF   01,W
01680:  ADDWFC xD0,F
01682:  MOVF   02,W
01684:  ADDWFC xD1,F
01686:  MOVF   03,W
01688:  ADDWFC xD2,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
0168A:  MOVF   xD3,W
0168C:  MULLW  04
0168E:  MOVF   FF3,W
01690:  CLRF   03
01692:  ADDLW  22
01694:  MOVWF  FE9
01696:  MOVLW  02
01698:  ADDWFC 03,W
0169A:  MOVWF  FEA
0169C:  MOVFF  FEF,00
016A0:  MOVFF  FEC,01
016A4:  MOVFF  FEC,02
016A8:  MOVFF  FEC,03
016AC:  MOVLW  FF
016AE:  BSF    FD8.0
016B0:  SUBFWB 00,W
016B2:  MOVLB  3
016B4:  MOVWF  xDE
016B6:  MOVLW  FF
016B8:  SUBFWB 01,W
016BA:  MOVWF  xDF
016BC:  MOVLW  00
016BE:  SUBFWB 02,W
016C0:  MOVLW  00
016C2:  SUBFWB 03,W
016C4:  MOVFF  3DF,FCF
016C8:  MOVFF  3DE,FCE
....................         } else { 
016CC:  BRA    1712
016CE:  MOVLB  2
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
016D0:  MOVF   xD3,W
016D2:  MULLW  04
016D4:  MOVF   FF3,W
016D6:  CLRF   03
016D8:  ADDLW  22
016DA:  MOVWF  FE9
016DC:  MOVLW  02
016DE:  ADDWFC 03,W
016E0:  MOVWF  FEA
016E2:  MOVFF  FEF,00
016E6:  MOVFF  FEC,01
016EA:  MOVFF  FEC,02
016EE:  MOVFF  FEC,03
016F2:  MOVLW  FF
016F4:  BSF    FD8.0
016F6:  SUBFWB 00,W
016F8:  MOVLB  3
016FA:  MOVWF  xDE
016FC:  MOVLW  FF
016FE:  SUBFWB 01,W
01700:  MOVWF  xDF
01702:  MOVLW  00
01704:  SUBFWB 02,W
01706:  MOVLW  00
01708:  SUBFWB 03,W
0170A:  MOVFF  3DF,FCF
0170E:  MOVFF  3DE,FCE
....................         } 
....................         break; 
....................     } 
01712:  MOVLB  0
01714:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_descida_y() { 
....................     if (atual_frequencia_y == 0) { 
01716:  MOVLB  2
01718:  MOVF   xD3,F
0171A:  BNZ   1762
....................         set_timer1(65535 - Ts_y[atual_frequencia_y]); 
0171C:  MOVF   xD3,W
0171E:  MULLW  04
01720:  MOVF   FF3,W
01722:  CLRF   03
01724:  ADDLW  22
01726:  MOVWF  FE9
01728:  MOVLW  02
0172A:  ADDWFC 03,W
0172C:  MOVWF  FEA
0172E:  MOVFF  FEF,00
01732:  MOVFF  FEC,01
01736:  MOVFF  FEC,02
0173A:  MOVFF  FEC,03
0173E:  MOVLW  FF
01740:  BSF    FD8.0
01742:  SUBFWB 00,W
01744:  MOVLB  3
01746:  MOVWF  xDE
01748:  MOVLW  FF
0174A:  SUBFWB 01,W
0174C:  MOVWF  xDF
0174E:  MOVLW  00
01750:  SUBFWB 02,W
01752:  MOVLW  00
01754:  SUBFWB 03,W
01756:  MOVFF  3DF,FCF
0175A:  MOVFF  3DE,FCE
....................     }  
0175E:  BRA    199A
01760:  MOVLB  2
....................     else if (atual_frequencia_y == vel_y) { 
01762:  MOVF   xD4,W
01764:  SUBWF  xD3,W
01766:  BTFSS  FD8.2
01768:  BRA    18CA
....................         if (step_no_y == (step_down_y + StepbyF_y[atual_frequencia_y])) { 
0176A:  MOVF   xD3,W
0176C:  MULLW  04
0176E:  MOVF   FF3,W
01770:  CLRF   03
01772:  ADDLW  72
01774:  MOVWF  FE9
01776:  MOVLW  02
01778:  ADDWFC 03,W
0177A:  MOVWF  FEA
0177C:  MOVFF  FEF,00
01780:  MOVFF  FEC,01
01784:  MOVFF  FEC,02
01788:  MOVFF  FEC,03
0178C:  MOVF   xC9,W
0178E:  ADDWF  00,F
01790:  MOVF   xCA,W
01792:  ADDWFC 01,F
01794:  MOVLW  00
01796:  ADDWFC 02,F
01798:  ADDWFC 03,F
0179A:  MOVF   00,W
0179C:  SUBWF  xC7,W
0179E:  BNZ   1884
017A0:  MOVF   01,W
017A2:  SUBWF  xC8,W
017A4:  BNZ   1884
017A6:  MOVF   02,F
017A8:  BNZ   1884
017AA:  MOVF   03,F
017AC:  BNZ   1884
....................             step_acumulado_y = step_down_y + StepbyF_y[atual_frequencia_y] + StepbyF_y[atual_frequencia_y - 1]; 
017AE:  MOVF   xD3,W
017B0:  MULLW  04
017B2:  MOVF   FF3,W
017B4:  CLRF   03
017B6:  ADDLW  72
017B8:  MOVWF  FE9
017BA:  MOVLW  02
017BC:  ADDWFC 03,W
017BE:  MOVWF  FEA
017C0:  MOVFF  FEF,00
017C4:  MOVFF  FEC,01
017C8:  MOVFF  FEC,02
017CC:  MOVFF  FEC,03
017D0:  MOVF   00,W
017D2:  ADDWF  xC9,W
017D4:  MOVLB  3
017D6:  MOVWF  xDE
017D8:  MOVF   01,W
017DA:  MOVLB  2
017DC:  ADDWFC xCA,W
017DE:  MOVLB  3
017E0:  MOVWF  xDF
017E2:  MOVLW  00
017E4:  ADDWFC 02,W
017E6:  MOVWF  xE0
017E8:  MOVLW  00
017EA:  ADDWFC 03,W
017EC:  MOVWF  xE1
017EE:  MOVLW  01
017F0:  MOVLB  2
017F2:  SUBWF  xD3,W
017F4:  MULLW  04
017F6:  MOVF   FF3,W
017F8:  CLRF   03
017FA:  ADDLW  72
017FC:  MOVWF  FE9
017FE:  MOVLW  02
01800:  ADDWFC 03,W
01802:  MOVWF  FEA
01804:  MOVFF  FEF,00
01808:  MOVFF  FEC,01
0180C:  MOVFF  FEC,02
01810:  MOVFF  FEC,03
01814:  MOVF   00,W
01816:  MOVLB  3
01818:  ADDWF  xDE,W
0181A:  MOVLB  2
0181C:  MOVWF  xCF
0181E:  MOVF   01,W
01820:  MOVLB  3
01822:  ADDWFC xDF,W
01824:  MOVLB  2
01826:  MOVWF  xD0
01828:  MOVF   02,W
0182A:  MOVLB  3
0182C:  ADDWFC xE0,W
0182E:  MOVLB  2
01830:  MOVWF  xD1
01832:  MOVF   03,W
01834:  MOVLB  3
01836:  ADDWFC xE1,W
01838:  MOVLB  2
0183A:  MOVWF  xD2
....................             atual_frequencia_y--; 
0183C:  DECF   xD3,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
0183E:  MOVF   xD3,W
01840:  MULLW  04
01842:  MOVF   FF3,W
01844:  CLRF   03
01846:  ADDLW  22
01848:  MOVWF  FE9
0184A:  MOVLW  02
0184C:  ADDWFC 03,W
0184E:  MOVWF  FEA
01850:  MOVFF  FEF,00
01854:  MOVFF  FEC,01
01858:  MOVFF  FEC,02
0185C:  MOVFF  FEC,03
01860:  MOVLW  FF
01862:  BSF    FD8.0
01864:  SUBFWB 00,W
01866:  MOVLB  3
01868:  MOVWF  xDE
0186A:  MOVLW  FF
0186C:  SUBFWB 01,W
0186E:  MOVWF  xDF
01870:  MOVLW  00
01872:  SUBFWB 02,W
01874:  MOVLW  00
01876:  SUBFWB 03,W
01878:  MOVFF  3DF,FCF
0187C:  MOVFF  3DE,FCE
....................         } else { 
01880:  BRA    18C6
01882:  MOVLB  2
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01884:  MOVF   xD3,W
01886:  MULLW  04
01888:  MOVF   FF3,W
0188A:  CLRF   03
0188C:  ADDLW  22
0188E:  MOVWF  FE9
01890:  MOVLW  02
01892:  ADDWFC 03,W
01894:  MOVWF  FEA
01896:  MOVFF  FEF,00
0189A:  MOVFF  FEC,01
0189E:  MOVFF  FEC,02
018A2:  MOVFF  FEC,03
018A6:  MOVLW  FF
018A8:  BSF    FD8.0
018AA:  SUBFWB 00,W
018AC:  MOVLB  3
018AE:  MOVWF  xDE
018B0:  MOVLW  FF
018B2:  SUBFWB 01,W
018B4:  MOVWF  xDF
018B6:  MOVLW  00
018B8:  SUBFWB 02,W
018BA:  MOVLW  00
018BC:  SUBFWB 03,W
018BE:  MOVFF  3DF,FCF
018C2:  MOVFF  3DE,FCE
....................         } 
....................     } else { 
018C6:  BRA    199A
018C8:  MOVLB  2
....................         if (step_no_y == step_acumulado_y) { 
018CA:  MOVF   xCF,W
018CC:  SUBWF  xC7,W
018CE:  BNZ   1958
018D0:  MOVF   xD0,W
018D2:  SUBWF  xC8,W
018D4:  BNZ   1958
018D6:  MOVF   xD1,F
018D8:  BNZ   1958
018DA:  MOVF   xD2,F
018DC:  BNZ   1958
....................             atual_frequencia_y--; 
018DE:  DECF   xD3,F
....................             step_acumulado_y += StepbyF_y[atual_frequencia_y]; 
018E0:  MOVF   xD3,W
018E2:  MULLW  04
018E4:  MOVF   FF3,W
018E6:  CLRF   03
018E8:  ADDLW  72
018EA:  MOVWF  FE9
018EC:  MOVLW  02
018EE:  ADDWFC 03,W
018F0:  MOVWF  FEA
018F2:  MOVFF  FEF,00
018F6:  MOVFF  FEC,01
018FA:  MOVFF  FEC,02
018FE:  MOVFF  FEC,03
01902:  MOVF   00,W
01904:  ADDWF  xCF,F
01906:  MOVF   01,W
01908:  ADDWFC xD0,F
0190A:  MOVF   02,W
0190C:  ADDWFC xD1,F
0190E:  MOVF   03,W
01910:  ADDWFC xD2,F
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01912:  MOVF   xD3,W
01914:  MULLW  04
01916:  MOVF   FF3,W
01918:  CLRF   03
0191A:  ADDLW  22
0191C:  MOVWF  FE9
0191E:  MOVLW  02
01920:  ADDWFC 03,W
01922:  MOVWF  FEA
01924:  MOVFF  FEF,00
01928:  MOVFF  FEC,01
0192C:  MOVFF  FEC,02
01930:  MOVFF  FEC,03
01934:  MOVLW  FF
01936:  BSF    FD8.0
01938:  SUBFWB 00,W
0193A:  MOVLB  3
0193C:  MOVWF  xDE
0193E:  MOVLW  FF
01940:  SUBFWB 01,W
01942:  MOVWF  xDF
01944:  MOVLW  00
01946:  SUBFWB 02,W
01948:  MOVLW  00
0194A:  SUBFWB 03,W
0194C:  MOVFF  3DF,FCF
01950:  MOVFF  3DE,FCE
....................         } else { 
01954:  BRA    199A
01956:  MOVLB  2
....................             set_timer1(65535 - Ts_y[atual_frequencia_y]); 
01958:  MOVF   xD3,W
0195A:  MULLW  04
0195C:  MOVF   FF3,W
0195E:  CLRF   03
01960:  ADDLW  22
01962:  MOVWF  FE9
01964:  MOVLW  02
01966:  ADDWFC 03,W
01968:  MOVWF  FEA
0196A:  MOVFF  FEF,00
0196E:  MOVFF  FEC,01
01972:  MOVFF  FEC,02
01976:  MOVFF  FEC,03
0197A:  MOVLW  FF
0197C:  BSF    FD8.0
0197E:  SUBFWB 00,W
01980:  MOVLB  3
01982:  MOVWF  xDE
01984:  MOVLW  FF
01986:  SUBFWB 01,W
01988:  MOVWF  xDF
0198A:  MOVLW  00
0198C:  SUBFWB 02,W
0198E:  MOVLW  00
01990:  SUBFWB 03,W
01992:  MOVFF  3DF,FCF
01996:  MOVFF  3DE,FCE
....................         } 
....................     } 
0199A:  MOVLB  0
0199C:  GOTO   19F8 (RETURN)
.................... } 
....................  
.................... void movimenta_eixo_y() { 
....................      
....................     switch (ramp_sts_y) { 
019A0:  MOVLB  2
019A2:  MOVF   xC5,W
019A4:  XORLW  01
019A6:  MOVLB  0
019A8:  BZ    19B4
019AA:  XORLW  02
019AC:  BZ    19F6
019AE:  XORLW  01
019B0:  BZ    1A16
019B2:  BRA    1A38
....................  
....................         case ramp_up: // accel 
....................             output_toggle(step_y); 
019B4:  BCF    F94.2
019B6:  BTG    F8B.2
....................             rest_y = ~rest_y; 
019B8:  MOVLB  1
019BA:  BTG    x1A.7
....................             proximo_valor_subida_y(); 
019BC:  MOVLB  0
019BE:  RCALL  14C0
....................             if (step_no_y == midpt_y) { // midpoint: decel 
019C0:  MOVLB  2
019C2:  MOVF   xCD,W
019C4:  SUBWF  xC7,W
019C6:  BNZ   19F4
019C8:  MOVF   xCE,W
019CA:  SUBWF  xC8,W
019CC:  BNZ   19F4
....................                 if (move_y > 2 * total_acc_step_y) 
019CE:  BCF    FD8.0
019D0:  RLCF   xC2,W
019D2:  MOVWF  02
019D4:  RLCF   xC3,W
019D6:  MOVWF  03
019D8:  MOVFF  02,01
019DC:  MOVF   03,W
019DE:  SUBWF  xCC,W
019E0:  BNC   19F0
019E2:  BNZ   19EA
019E4:  MOVF   xCB,W
019E6:  SUBWF  01,W
019E8:  BC    19F0
....................                     ramp_sts_y = ramp_max; 
019EA:  MOVLW  02
019EC:  MOVWF  xC5
019EE:  BRA    19F4
....................                 else 
....................                     ramp_sts_y = ramp_down; 
019F0:  MOVLW  03
019F2:  MOVWF  xC5
....................             } 
....................             break; 
019F4:  BRA    1A46
....................  
....................         case ramp_down: // decel 
....................             proximo_valor_descida_y(); 
019F6:  BRA    1716
....................             if (step_no_y == move_y) 
019F8:  MOVLB  2
019FA:  MOVF   xCB,W
019FC:  SUBWF  xC7,W
019FE:  BNZ   1A0A
01A00:  MOVF   xCC,W
01A02:  SUBWF  xC8,W
01A04:  BNZ   1A0A
....................                 ramp_sts_y = ramp_last; 
01A06:  MOVLW  04
01A08:  MOVWF  xC5
....................             output_toggle(step_y); 
01A0A:  BCF    F94.2
01A0C:  BTG    F8B.2
....................             rest_y = ~rest_y; 
01A0E:  MOVLB  1
01A10:  BTG    x1A.7
....................             break; 
01A12:  MOVLB  2
01A14:  BRA    1A46
....................  
....................         case ramp_max: // constant speed 
....................             proximo_valor_subida_y(); 
01A16:  RCALL  14C0
....................             if (step_no_y == step_down_y) // start decel 
01A18:  MOVLB  2
01A1A:  MOVF   xC9,W
01A1C:  SUBWF  xC7,W
01A1E:  BNZ   1A2A
01A20:  MOVF   xCA,W
01A22:  SUBWF  xC8,W
01A24:  BNZ   1A2A
....................                 ramp_sts_y = ramp_down; 
01A26:  MOVLW  03
01A28:  MOVWF  xC5
....................             output_toggle(step_y); 
01A2A:  BCF    F94.2
01A2C:  BTG    F8B.2
....................             rest_y = ~rest_y; 
01A2E:  MOVLB  1
01A30:  BTG    x1A.7
....................             break; 
01A32:  MOVLB  2
01A34:  BRA    1A46
01A36:  MOVLB  0
....................  
....................         default: // last step: cleanup 
....................             ramp_sts_y = ramp_idle; 
01A38:  MOVLB  2
01A3A:  CLRF   xC5
....................             stop_yf = FALSE; 
01A3C:  BCF    xC6.0
....................             disable_interrupts(INT_TIMER1); 
01A3E:  BCF    F9D.0
....................             run_flg_y = FALSE; // move_y complete 
01A40:  MOVLB  1
01A42:  BCF    x1A.6
....................             break; 
01A44:  MOVLB  2
....................     } // switch (ramp_sts_y) 
....................     if (ramp_sts_y != ramp_idle) { 
01A46:  MOVF   xC5,F
01A48:  BZ    1A74
....................         if (rest_y) { 
01A4A:  MOVLB  1
01A4C:  BTFSS  x1A.7
01A4E:  BRA    1A76
....................             motor_pos_y += pos_inc_y; 
01A50:  CLRF   03
01A52:  MOVLB  2
01A54:  MOVF   xC4,W
01A56:  BTFSC  FE8.7
01A58:  DECF   03,F
01A5A:  MOVLB  1
01A5C:  ADDWF  x14,W
01A5E:  MOVWF  01
01A60:  MOVF   x15,W
01A62:  ADDWFC 03,F
01A64:  MOVFF  01,114
01A68:  MOVFF  03,115
....................             ++step_no_y; 
01A6C:  MOVLB  2
01A6E:  INCF   xC7,F
01A70:  BTFSC  FD8.2
01A72:  INCF   xC8,F
01A74:  MOVLB  1
....................         } 
....................     } 
01A76:  MOVLB  0
01A78:  GOTO   1A7E (RETURN)
.................... } 
....................  
.................... void umpasso_y(int16 descanco, short dir) { 
....................     output_low(enable_y); 
....................     if (dir) { 
....................         output_high(dir_y); 
....................         motor_pos_y--; 
....................     } else { 
....................         output_low(dir_y); 
....................         motor_pos_y++; 
....................     } 
....................     output_high(step_y); 
....................     delay_us(descanco); 
....................     output_low(step_y); 
....................     delay_us(descanco); 
....................     //output_high(enable_y); 
.................... } 
....................  
.................... void zerar_y() { 
....................     while(le_Input(i_limite_y)==1){ 
....................         umpasso_y(600, FALSE); 
....................         delay_us(200); 
....................     } 
....................     while (le_Input(i_limite_y)==0){ 
....................         umpasso_y(900,TRUE); 
....................         delay_us(200); 
....................     } 
....................     while(le_Input(i_limite_y)==1){ 
....................         umpasso_y(1000, FALSE); 
....................         delay_us(200); 
....................     } 
....................     motor_pos_y = 0; 
....................     output_high(enable_y); 
.................... } 
.................... void medir_y(){ 
....................     while (le_Input(s_limite_y)==0){ 
....................         umpasso_y(900,FALSE); 
....................         delay_us(200); 
....................     } 
....................     while (le_Input(s_limite_y)==1){ 
....................         umpasso_y(900,TRUE); 
....................         delay_us(200); 
....................     } 
....................     max_posicao_y = motor_pos_y; 
....................     output_high(enable_y); 
.................... } 
.................... // </editor-fold> 
....................  
.................... #include "Axis_z.c" 
.................... // <editor-fold defaultstate="collapsed" desc="Valores que devem ser inseridos"> 
.................... float stepbyrev_z = 200; 
.................... float driver_u_step_z = 1; // caso o driver esteja em 400 
.................... float Leadscrew_z = 9; //redutor de voltas do motor 
.................... float Leadscrew_Pich_z = 150; //esse valor deve ser em mm/revoluo 
.................... float Vmax_z = 400; //esse valor deve ser em mm por segundo 
.................... float Amax_z = 250; //esse valor deve ser em mm por segundo 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Valores calculo rampa"> 
.................... float MMbyStep_z = 0; 
.................... int8 StepinAcc_z = 20; 
.................... float Fmax_z = 0; 
.................... int32 Ts_z[20]; 
.................... int32 StepbyF_z[20]; 
.................... int16 total_acc_step_z = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Flags e Controles de Movimento"> 
.................... signed int8 pos_inc_z = 0; 
.................... int8 ramp_sts_z = ramp_idle; 
.................... short run_flg_z = FALSE; 
.................... short rest_z = false; 
.................... int16 step_no_z = 0; 
.................... int16 step_down_z = 0; 
.................... int16 move_z = 0; 
.................... int16 midpt_z = 0; 
.................... int32 step_acumulado_z = 0; 
.................... int atual_frequencia_z = 0; 
.................... int vel_z = 19; 
.................... int16 max_posicao_z = 0; 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Pinos Motor"> 
.................... #DEFINE     i_limite_z            13 
.................... #DEFINE     s_limite_z            14 
....................  
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Inicializa Motor"> 
.................... void init_axis_z() { 
....................     set_tris_a(0x00); 
*
035E8:  MOVLW  00
035EA:  MOVWF  F92
....................     output_high(step_z); 
035EC:  BCF    F92.5
035EE:  BSF    F89.5
....................     output_high(enable_z); 
035F0:  BCF    F92.3
035F2:  BSF    F89.3
....................     output_high(dir_z); 
035F4:  BCF    F92.4
035F6:  BSF    F89.4
....................  
....................     MMbyStep_z = Leadscrew_Pich_z / (stepbyrev_z * driver_u_step_z * Leadscrew_z); 
035F8:  MOVFF  2DA,3CB
035FC:  MOVFF  2D9,3CA
03600:  MOVFF  2D8,3C9
03604:  MOVFF  2D7,3C8
03608:  MOVFF  2DE,3CF
0360C:  MOVFF  2DD,3CE
03610:  MOVFF  2DC,3CD
03614:  MOVFF  2DB,3CC
03618:  CALL   2632
0361C:  MOVFF  03,3BD
03620:  MOVFF  02,3BC
03624:  MOVFF  01,3BB
03628:  MOVFF  00,3BA
0362C:  MOVFF  03,3CB
03630:  MOVFF  02,3CA
03634:  MOVFF  01,3C9
03638:  MOVFF  00,3C8
0363C:  MOVFF  2E2,3CF
03640:  MOVFF  2E1,3CE
03644:  MOVFF  2E0,3CD
03648:  MOVFF  2DF,3CC
0364C:  CALL   2632
03650:  MOVFF  2E6,3D1
03654:  MOVFF  2E5,3D0
03658:  MOVFF  2E4,3CF
0365C:  MOVFF  2E3,3CE
03660:  MOVFF  03,3D5
03664:  MOVFF  02,3D4
03668:  MOVFF  01,3D3
0366C:  MOVFF  00,3D2
03670:  CALL   2728
03674:  MOVFF  03,2F2
03678:  MOVFF  02,2F1
0367C:  MOVFF  01,2F0
03680:  MOVFF  00,2EF
....................     Fmax_z = Vmax_z / MMbyStep_z; //Valor de ferequencia adiquirido em hz 
03684:  MOVFF  2EA,3D1
03688:  MOVFF  2E9,3D0
0368C:  MOVFF  2E8,3CF
03690:  MOVFF  2E7,3CE
03694:  MOVFF  2F2,3D5
03698:  MOVFF  2F1,3D4
0369C:  MOVFF  2F0,3D3
036A0:  MOVFF  2EF,3D2
036A4:  CALL   2728
036A8:  MOVFF  03,2F7
036AC:  MOVFF  02,2F6
036B0:  MOVFF  01,2F5
036B4:  MOVFF  00,2F4
....................  
....................     float den = Amax_z*StepinAcc_z; 
....................     float num = Vmax_z * 1000000; 
....................     float TbyF = num / den; //tempo em us 
....................  
....................     int i = 0; 
036B8:  MOVLB  3
036BA:  CLRF   xC9
036BC:  MOVFF  2F3,3C8
036C0:  MOVLB  0
036C2:  CALL   2886
036C6:  MOVFF  2EE,3CB
036CA:  MOVFF  2ED,3CA
036CE:  MOVFF  2EC,3C9
036D2:  MOVFF  2EB,3C8
036D6:  MOVFF  03,3CF
036DA:  MOVFF  02,3CE
036DE:  MOVFF  01,3CD
036E2:  MOVFF  00,3CC
036E6:  CALL   2632
036EA:  MOVFF  03,3B0
036EE:  MOVFF  02,3AF
036F2:  MOVFF  01,3AE
036F6:  MOVFF  00,3AD
036FA:  MOVFF  2EA,3CB
036FE:  MOVFF  2E9,3CA
03702:  MOVFF  2E8,3C9
03706:  MOVFF  2E7,3C8
0370A:  MOVLB  3
0370C:  CLRF   xCF
0370E:  MOVLW  24
03710:  MOVWF  xCE
03712:  MOVLW  74
03714:  MOVWF  xCD
03716:  MOVLW  92
03718:  MOVWF  xCC
0371A:  MOVLB  0
0371C:  CALL   2632
03720:  MOVFF  03,3B4
03724:  MOVFF  02,3B3
03728:  MOVFF  01,3B2
0372C:  MOVFF  00,3B1
03730:  MOVFF  3B4,3D1
03734:  MOVFF  3B3,3D0
03738:  MOVFF  3B2,3CF
0373C:  MOVFF  3B1,3CE
03740:  MOVFF  3B0,3D5
03744:  MOVFF  3AF,3D4
03748:  MOVFF  3AE,3D3
0374C:  MOVFF  3AD,3D2
03750:  CALL   2728
03754:  MOVFF  03,3B8
03758:  MOVFF  02,3B7
0375C:  MOVFF  01,3B6
03760:  MOVFF  00,3B5
03764:  MOVLB  3
03766:  CLRF   xB9
....................     for (i = 1; i <= StepinAcc_z; i++) { 
03768:  MOVLW  01
0376A:  MOVWF  xB9
0376C:  MOVF   xB9,W
0376E:  MOVLB  2
03770:  SUBWF  xF3,W
03772:  BTFSS  FD8.0
03774:  BRA    3A1E
....................         Ts_z[i - 1] = (1000000 * StepinAcc_z) / (i * Fmax_z); 
03776:  MOVLW  01
03778:  MOVLB  3
0377A:  SUBWF  xB9,W
0377C:  MULLW  04
0377E:  MOVF   FF3,W
03780:  CLRF   03
03782:  ADDLW  F8
03784:  MOVWF  FE9
03786:  MOVLW  02
03788:  ADDWFC 03,W
0378A:  MOVWF  FEA
0378C:  MOVFF  FEA,3BD
03790:  MOVFF  FE9,3BC
03794:  CLRF   xC1
03796:  MOVLW  0F
03798:  MOVWF  xC0
0379A:  MOVLW  42
0379C:  MOVWF  xBF
0379E:  MOVLW  40
037A0:  MOVWF  xBE
037A2:  CLRF   xC5
037A4:  CLRF   xC4
037A6:  CLRF   xC3
037A8:  MOVFF  2F3,3C2
037AC:  MOVLB  0
037AE:  CALL   2B34
037B2:  MOVFF  3BD,FEA
037B6:  MOVFF  3BC,FE9
037BA:  MOVFF  03,3C1
037BE:  MOVFF  02,3C0
037C2:  MOVFF  01,3BF
037C6:  MOVFF  00,3BE
037CA:  MOVLB  3
037CC:  CLRF   xC9
037CE:  MOVFF  3B9,3C8
037D2:  MOVLB  0
037D4:  CALL   2886
037D8:  MOVFF  03,3CB
037DC:  MOVFF  02,3CA
037E0:  MOVFF  01,3C9
037E4:  MOVFF  00,3C8
037E8:  MOVFF  2F7,3CF
037EC:  MOVFF  2F6,3CE
037F0:  MOVFF  2F5,3CD
037F4:  MOVFF  2F4,3CC
037F8:  CALL   2632
037FC:  MOVFF  03,3C5
03800:  MOVFF  02,3C4
03804:  MOVFF  01,3C3
03808:  MOVFF  00,3C2
0380C:  MOVFF  3C1,3D1
03810:  MOVFF  3C0,3D0
03814:  MOVFF  3BF,3CF
03818:  MOVFF  3BE,3CE
0381C:  CALL   2B90
03820:  MOVFF  03,3D1
03824:  MOVFF  02,3D0
03828:  MOVFF  01,3CF
0382C:  MOVFF  00,3CE
03830:  MOVFF  3C5,3D5
03834:  MOVFF  3C4,3D4
03838:  MOVFF  3C3,3D3
0383C:  MOVFF  3C2,3D2
03840:  CALL   2728
03844:  MOVFF  03,3D1
03848:  MOVFF  02,3D0
0384C:  MOVFF  01,3CF
03850:  MOVFF  00,3CE
03854:  CALL   2BC8
03858:  MOVFF  00,FEF
0385C:  MOVFF  01,FEC
03860:  MOVFF  02,FEC
03864:  MOVFF  03,FEC
....................         StepbyF_z[i - 1] = 2 * TbyF / Ts_z[i - 1]; 
03868:  MOVLW  01
0386A:  MOVLB  3
0386C:  SUBWF  xB9,W
0386E:  MULLW  04
03870:  MOVF   FF3,W
03872:  CLRF   03
03874:  ADDLW  48
03876:  MOVWF  01
03878:  MOVLW  03
0387A:  ADDWFC 03,F
0387C:  MOVFF  01,3BA
03880:  MOVFF  03,3BB
03884:  CLRF   xCB
03886:  CLRF   xCA
03888:  CLRF   xC9
0388A:  MOVLW  80
0388C:  MOVWF  xC8
0388E:  MOVFF  3B8,3CF
03892:  MOVFF  3B7,3CE
03896:  MOVFF  3B6,3CD
0389A:  MOVFF  3B5,3CC
0389E:  MOVLB  0
038A0:  CALL   2632
038A4:  MOVFF  03,3BF
038A8:  MOVFF  02,3BE
038AC:  MOVFF  01,3BD
038B0:  MOVFF  00,3BC
038B4:  MOVLW  01
038B6:  MOVLB  3
038B8:  SUBWF  xB9,W
038BA:  MULLW  04
038BC:  MOVF   FF3,W
038BE:  CLRF   03
038C0:  ADDLW  F8
038C2:  MOVWF  FE9
038C4:  MOVLW  02
038C6:  ADDWFC 03,W
038C8:  MOVWF  FEA
038CA:  MOVFF  FEF,00
038CE:  MOVFF  FEC,01
038D2:  MOVFF  FEC,02
038D6:  MOVFF  FEC,03
038DA:  MOVFF  03,3D1
038DE:  MOVFF  02,3D0
038E2:  MOVFF  01,3CF
038E6:  MOVFF  00,3CE
038EA:  MOVLB  0
038EC:  CALL   2B90
038F0:  MOVFF  3BF,3D1
038F4:  MOVFF  3BE,3D0
038F8:  MOVFF  3BD,3CF
038FC:  MOVFF  3BC,3CE
03900:  MOVFF  03,3D5
03904:  MOVFF  02,3D4
03908:  MOVFF  01,3D3
0390C:  MOVFF  00,3D2
03910:  CALL   2728
03914:  MOVFF  03,3D1
03918:  MOVFF  02,3D0
0391C:  MOVFF  01,3CF
03920:  MOVFF  00,3CE
03924:  CALL   2BC8
03928:  MOVFF  3BB,FEA
0392C:  MOVFF  3BA,FE9
03930:  MOVFF  00,FEF
03934:  MOVFF  01,FEC
03938:  MOVFF  02,FEC
0393C:  MOVFF  03,FEC
....................         total_acc_step_z += StepbyF_z[i - 1]; 
03940:  MOVLW  01
03942:  MOVLB  3
03944:  SUBWF  xB9,W
03946:  MULLW  04
03948:  MOVF   FF3,W
0394A:  CLRF   03
0394C:  ADDLW  48
0394E:  MOVWF  FE9
03950:  MOVLW  03
03952:  ADDWFC 03,W
03954:  MOVWF  FEA
03956:  MOVFF  FEF,00
0395A:  MOVFF  FEC,01
0395E:  MOVFF  FEC,02
03962:  MOVFF  FEC,03
03966:  MOVF   00,W
03968:  ADDWF  x98,F
0396A:  MOVF   01,W
0396C:  ADDWFC x99,F
....................         Ts_z[i - 1] = Ts_z[i - 1] / (8 * 0.2 * 2); //Tempo/(prescale*ciclodemaquina*metadedociclo) 
0396E:  MOVLW  01
03970:  SUBWF  xB9,W
03972:  MULLW  04
03974:  MOVF   FF3,W
03976:  CLRF   03
03978:  ADDLW  F8
0397A:  MOVWF  01
0397C:  MOVLW  02
0397E:  ADDWFC 03,F
03980:  MOVFF  01,3BA
03984:  MOVFF  03,3BB
03988:  MOVLW  01
0398A:  SUBWF  xB9,W
0398C:  MULLW  04
0398E:  MOVF   FF3,W
03990:  CLRF   03
03992:  ADDLW  F8
03994:  MOVWF  FE9
03996:  MOVLW  02
03998:  ADDWFC 03,W
0399A:  MOVWF  FEA
0399C:  MOVFF  FEF,3BC
039A0:  MOVFF  FEC,3BD
039A4:  MOVFF  FEC,3BE
039A8:  MOVFF  FEC,3BF
039AC:  MOVFF  3BF,3D1
039B0:  MOVFF  3BE,3D0
039B4:  MOVFF  3BD,3CF
039B8:  MOVFF  3BC,3CE
039BC:  MOVLB  0
039BE:  CALL   2B90
039C2:  MOVFF  03,3D1
039C6:  MOVFF  02,3D0
039CA:  MOVFF  01,3CF
039CE:  MOVFF  00,3CE
039D2:  MOVLW  CD
039D4:  MOVLB  3
039D6:  MOVWF  xD5
039D8:  MOVLW  CC
039DA:  MOVWF  xD4
039DC:  MOVLW  4C
039DE:  MOVWF  xD3
039E0:  MOVLW  80
039E2:  MOVWF  xD2
039E4:  MOVLB  0
039E6:  CALL   2728
039EA:  MOVFF  03,3D1
039EE:  MOVFF  02,3D0
039F2:  MOVFF  01,3CF
039F6:  MOVFF  00,3CE
039FA:  CALL   2BC8
039FE:  MOVFF  3BB,FEA
03A02:  MOVFF  3BA,FE9
03A06:  MOVFF  00,FEF
03A0A:  MOVFF  01,FEC
03A0E:  MOVFF  02,FEC
03A12:  MOVFF  03,FEC
03A16:  MOVLB  3
03A18:  INCF   xB9,F
03A1A:  BRA    376C
03A1C:  MOVLB  2
....................     } 
03A1E:  MOVLB  0
03A20:  GOTO   A8FE (RETURN)
.................... } 
.................... // </editor-fold> 
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Movimento Motor"> 
.................... void motor_stop_z() { 
....................     step_no_z = step_down_z; 
....................     ramp_sts_z = ramp_down; 
.................... } 
....................  
.................... void motor_disable_z() { 
....................     output_high(enable_z); 
....................     disable_interrupts(INT_TIMER3); 
.................... } 
....................  
.................... void motor_run_z(int32 pos_new, int velocidade) { // set up to drive motor to pos_new (absolute step#) 
....................     vel_z = velocidade; 
*
05642:  MOVFF  3B8,3A9
....................     total_acc_step_z = 0; 
05646:  MOVLB  3
05648:  CLRF   x99
0564A:  CLRF   x98
....................  
....................     if (pos_new < motor_pos_z) // get dir_yection & #steps 
0564C:  MOVF   xB7,F
0564E:  BNZ   568C
05650:  MOVF   xB6,F
05652:  BNZ   568C
05654:  MOVF   xB5,W
05656:  MOVLB  1
05658:  SUBWF  x19,W
0565A:  BTFSC  FD8.0
0565C:  BRA    5662
0565E:  MOVLB  3
05660:  BRA    568C
05662:  BNZ   566E
05664:  MOVF   x18,W
05666:  MOVLB  3
05668:  SUBWF  xB4,W
0566A:  BC    568C
0566C:  MOVLB  1
....................     { 
....................         output_low(dir_z); 
0566E:  BCF    F92.4
05670:  BCF    F89.4
....................         move_z = motor_pos_z - pos_new; 
05672:  MOVLB  3
05674:  MOVF   xB4,W
05676:  MOVLB  1
05678:  SUBWF  x18,W
0567A:  MOVLB  3
0567C:  MOVWF  xA0
0567E:  MOVF   xB5,W
05680:  MOVLB  1
05682:  SUBWFB x19,W
05684:  MOVLB  3
05686:  MOVWF  xA1
....................         pos_inc_z = -1; 
05688:  SETF   x9A
....................     } else if (pos_new != motor_pos_z) { 
0568A:  BRA    56C8
0568C:  MOVLB  1
0568E:  MOVF   x18,W
05690:  MOVLB  3
05692:  SUBWF  xB4,W
05694:  BNZ   56A8
05696:  MOVLB  1
05698:  MOVF   x19,W
0569A:  MOVLB  3
0569C:  SUBWF  xB5,W
0569E:  BNZ   56A8
056A0:  MOVF   xB6,F
056A2:  BNZ   56A8
056A4:  MOVF   xB7,F
056A6:  BZ    56C6
....................         output_high(dir_z); 
056A8:  BCF    F92.4
056AA:  BSF    F89.4
....................         move_z = pos_new - motor_pos_z; 
056AC:  MOVLB  1
056AE:  MOVF   x18,W
056B0:  MOVLB  3
056B2:  SUBWF  xB4,W
056B4:  MOVWF  xA0
056B6:  MOVLB  1
056B8:  MOVF   x19,W
056BA:  MOVLB  3
056BC:  SUBWFB xB5,W
056BE:  MOVWF  xA1
....................         pos_inc_z = 1; 
056C0:  MOVLW  01
056C2:  MOVWF  x9A
....................     } else return; 
056C4:  BRA    56C8
056C6:  BRA    5798
....................  
....................     for (int j = 0; j <= velocidade; j++) { 
056C8:  CLRF   xB9
056CA:  MOVF   xB9,W
056CC:  SUBWF  xB8,W
056CE:  BNC   56FE
....................         total_acc_step_z += StepbyF_z[j]; 
056D0:  MOVF   xB9,W
056D2:  MULLW  04
056D4:  MOVF   FF3,W
056D6:  CLRF   03
056D8:  ADDLW  48
056DA:  MOVWF  FE9
056DC:  MOVLW  03
056DE:  ADDWFC 03,W
056E0:  MOVWF  FEA
056E2:  MOVFF  FEF,00
056E6:  MOVFF  FEC,01
056EA:  MOVFF  FEC,02
056EE:  MOVFF  FEC,03
056F2:  MOVF   00,W
056F4:  ADDWF  x98,F
056F6:  MOVF   01,W
056F8:  ADDWFC x99,F
056FA:  INCF   xB9,F
056FC:  BRA    56CA
....................     } 
....................  
....................     if (move_z > 2 * total_acc_step_z) { 
056FE:  BCF    FD8.0
05700:  RLCF   x98,W
05702:  MOVWF  02
05704:  RLCF   x99,W
05706:  MOVWF  03
05708:  MOVFF  02,01
0570C:  MOVF   03,W
0570E:  SUBWF  xA1,W
05710:  BNC   5730
05712:  BNZ   571A
05714:  MOVF   xA0,W
05716:  SUBWF  01,W
05718:  BC    5730
....................         midpt_z = total_acc_step_z; 
0571A:  MOVFF  399,3A3
0571E:  MOVFF  398,3A2
....................         step_down_z = move_z - total_acc_step_z; 
05722:  MOVF   x98,W
05724:  SUBWF  xA0,W
05726:  MOVWF  x9E
05728:  MOVF   x99,W
0572A:  SUBWFB xA1,W
0572C:  MOVWF  x9F
....................     } else { 
0572E:  BRA    574E
....................         midpt_z = (move_z - 1) >> 1; 
05730:  MOVLW  01
05732:  SUBWF  xA0,W
05734:  MOVWF  xBA
05736:  MOVLW  00
05738:  SUBWFB xA1,W
0573A:  MOVWF  xBB
0573C:  BCF    FD8.0
0573E:  RRCF   xBB,W
05740:  MOVWF  xA3
05742:  RRCF   xBA,W
05744:  MOVWF  xA2
....................         step_down_z = midpt_z; 
05746:  MOVFF  3A3,39F
0574A:  MOVFF  3A2,39E
....................     } 
....................     step_no_z = 0; 
0574E:  CLRF   x9D
05750:  CLRF   x9C
....................     step_acumulado_z = 0; 
05752:  CLRF   xA7
05754:  CLRF   xA6
05756:  CLRF   xA5
05758:  CLRF   xA4
....................     atual_frequencia_z = 0; 
0575A:  CLRF   xA8
....................     ramp_sts_z = ramp_up; // start ramp state-machine 
0575C:  MOVLW  01
0575E:  MOVWF  x9B
....................     run_flg_z = TRUE; 
05760:  MOVLB  2
05762:  BSF    xC6.1
....................     output_low(enable_z); 
05764:  BCF    F92.3
05766:  BCF    F89.3
....................     setup_timer_3(T3_INTERNAL | T3_DIV_BY_8); 
05768:  MOVLW  B5
0576A:  MOVWF  FB1
....................     set_timer3(65535 - Ts_z[0]); 
0576C:  MOVLW  FF
0576E:  BSF    FD8.0
05770:  SUBFWB xF8,W
05772:  MOVLB  3
05774:  MOVWF  xBA
05776:  MOVLW  FF
05778:  MOVLB  2
0577A:  SUBFWB xF9,W
0577C:  MOVLB  3
0577E:  MOVWF  xBB
05780:  MOVLW  00
05782:  MOVLB  2
05784:  SUBFWB xFA,W
05786:  MOVLW  00
05788:  MOVLB  2
0578A:  SUBFWB xFB,W
0578C:  MOVLB  3
0578E:  MOVFF  3BB,FB3
05792:  MOVFF  3BA,FB2
....................     enable_interrupts(INT_TIMER3); 
05796:  BSF    FA0.1
05798:  MOVLB  0
0579A:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_subida_z() { 
....................     if (atual_frequencia_z == 0) { 
*
01A9A:  MOVLB  3
01A9C:  MOVF   xA8,F
01A9E:  BTFSS  FD8.2
01AA0:  BRA    1BC4
....................         if (step_no_z == StepbyF_z[atual_frequencia_z]) { 
01AA2:  MOVF   xA8,W
01AA4:  MULLW  04
01AA6:  MOVF   FF3,W
01AA8:  CLRF   03
01AAA:  ADDLW  48
01AAC:  MOVWF  FE9
01AAE:  MOVLW  03
01AB0:  ADDWFC 03,W
01AB2:  MOVWF  FEA
01AB4:  MOVFF  FEF,00
01AB8:  MOVFF  FEC,01
01ABC:  MOVFF  FEC,02
01AC0:  MOVFF  FEC,03
01AC4:  MOVF   00,W
01AC6:  SUBWF  x9C,W
01AC8:  BNZ   1B82
01ACA:  MOVF   01,W
01ACC:  SUBWF  x9D,W
01ACE:  BNZ   1B82
01AD0:  MOVF   02,F
01AD2:  BNZ   1B82
01AD4:  MOVF   03,F
01AD6:  BNZ   1B82
....................             step_acumulado_z += StepbyF_z[atual_frequencia_z] + StepbyF_z[atual_frequencia_z + 1]; 
01AD8:  MOVF   xA8,W
01ADA:  MULLW  04
01ADC:  MOVF   FF3,W
01ADE:  CLRF   03
01AE0:  ADDLW  48
01AE2:  MOVWF  FE9
01AE4:  MOVLW  03
01AE6:  ADDWFC 03,W
01AE8:  MOVWF  FEA
01AEA:  MOVFF  FEF,3DE
01AEE:  MOVFF  FEC,3DF
01AF2:  MOVFF  FEC,3E0
01AF6:  MOVFF  FEC,3E1
01AFA:  MOVLW  01
01AFC:  ADDWF  xA8,W
01AFE:  MULLW  04
01B00:  MOVF   FF3,W
01B02:  CLRF   03
01B04:  ADDLW  48
01B06:  MOVWF  FE9
01B08:  MOVLW  03
01B0A:  ADDWFC 03,W
01B0C:  MOVWF  FEA
01B0E:  MOVFF  FEF,00
01B12:  MOVFF  FEC,01
01B16:  MOVFF  FEC,02
01B1A:  MOVFF  FEC,03
01B1E:  MOVF   xDE,W
01B20:  ADDWF  00,F
01B22:  MOVF   xDF,W
01B24:  ADDWFC 01,F
01B26:  MOVF   xE0,W
01B28:  ADDWFC 02,F
01B2A:  MOVF   xE1,W
01B2C:  ADDWFC 03,F
01B2E:  MOVF   00,W
01B30:  ADDWF  xA4,F
01B32:  MOVF   01,W
01B34:  ADDWFC xA5,F
01B36:  MOVF   02,W
01B38:  ADDWFC xA6,F
01B3A:  MOVF   03,W
01B3C:  ADDWFC xA7,F
....................             atual_frequencia_z++; 
01B3E:  INCF   xA8,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01B40:  MOVF   xA8,W
01B42:  MULLW  04
01B44:  MOVF   FF3,W
01B46:  CLRF   03
01B48:  ADDLW  F8
01B4A:  MOVWF  FE9
01B4C:  MOVLW  02
01B4E:  ADDWFC 03,W
01B50:  MOVWF  FEA
01B52:  MOVFF  FEF,00
01B56:  MOVFF  FEC,01
01B5A:  MOVFF  FEC,02
01B5E:  MOVFF  FEC,03
01B62:  MOVLW  FF
01B64:  BSF    FD8.0
01B66:  SUBFWB 00,W
01B68:  MOVWF  xDE
01B6A:  MOVLW  FF
01B6C:  SUBFWB 01,W
01B6E:  MOVWF  xDF
01B70:  MOVLW  00
01B72:  SUBFWB 02,W
01B74:  MOVLW  00
01B76:  SUBFWB 03,W
01B78:  MOVFF  3DF,FB3
01B7C:  MOVFF  3DE,FB2
....................         } else { 
01B80:  BRA    1BC2
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01B82:  MOVF   xA8,W
01B84:  MULLW  04
01B86:  MOVF   FF3,W
01B88:  CLRF   03
01B8A:  ADDLW  F8
01B8C:  MOVWF  FE9
01B8E:  MOVLW  02
01B90:  ADDWFC 03,W
01B92:  MOVWF  FEA
01B94:  MOVFF  FEF,00
01B98:  MOVFF  FEC,01
01B9C:  MOVFF  FEC,02
01BA0:  MOVFF  FEC,03
01BA4:  MOVLW  FF
01BA6:  BSF    FD8.0
01BA8:  SUBFWB 00,W
01BAA:  MOVWF  xDE
01BAC:  MOVLW  FF
01BAE:  SUBFWB 01,W
01BB0:  MOVWF  xDF
01BB2:  MOVLW  00
01BB4:  SUBFWB 02,W
01BB6:  MOVLW  00
01BB8:  SUBFWB 03,W
01BBA:  MOVFF  3DF,FB3
01BBE:  MOVFF  3DE,FB2
....................         } 
....................     } else if (atual_frequencia_z == vel_z) { 
01BC2:  BRA    1CD6
01BC4:  MOVF   xA9,W
01BC6:  SUBWF  xA8,W
01BC8:  BNZ   1C0C
....................         set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01BCA:  MOVF   xA8,W
01BCC:  MULLW  04
01BCE:  MOVF   FF3,W
01BD0:  CLRF   03
01BD2:  ADDLW  F8
01BD4:  MOVWF  FE9
01BD6:  MOVLW  02
01BD8:  ADDWFC 03,W
01BDA:  MOVWF  FEA
01BDC:  MOVFF  FEF,00
01BE0:  MOVFF  FEC,01
01BE4:  MOVFF  FEC,02
01BE8:  MOVFF  FEC,03
01BEC:  MOVLW  FF
01BEE:  BSF    FD8.0
01BF0:  SUBFWB 00,W
01BF2:  MOVWF  xDE
01BF4:  MOVLW  FF
01BF6:  SUBFWB 01,W
01BF8:  MOVWF  xDF
01BFA:  MOVLW  00
01BFC:  SUBFWB 02,W
01BFE:  MOVLW  00
01C00:  SUBFWB 03,W
01C02:  MOVFF  3DF,FB3
01C06:  MOVFF  3DE,FB2
....................     } else { 
01C0A:  BRA    1CD6
....................         if (step_no_z == step_acumulado_z) { 
01C0C:  MOVF   xA4,W
01C0E:  SUBWF  x9C,W
01C10:  BNZ   1C96
01C12:  MOVF   xA5,W
01C14:  SUBWF  x9D,W
01C16:  BNZ   1C96
01C18:  MOVF   xA6,F
01C1A:  BNZ   1C96
01C1C:  MOVF   xA7,F
01C1E:  BNZ   1C96
....................             atual_frequencia_z++; 
01C20:  INCF   xA8,F
....................             step_acumulado_z += StepbyF_z[atual_frequencia_z]; 
01C22:  MOVF   xA8,W
01C24:  MULLW  04
01C26:  MOVF   FF3,W
01C28:  CLRF   03
01C2A:  ADDLW  48
01C2C:  MOVWF  FE9
01C2E:  MOVLW  03
01C30:  ADDWFC 03,W
01C32:  MOVWF  FEA
01C34:  MOVFF  FEF,00
01C38:  MOVFF  FEC,01
01C3C:  MOVFF  FEC,02
01C40:  MOVFF  FEC,03
01C44:  MOVF   00,W
01C46:  ADDWF  xA4,F
01C48:  MOVF   01,W
01C4A:  ADDWFC xA5,F
01C4C:  MOVF   02,W
01C4E:  ADDWFC xA6,F
01C50:  MOVF   03,W
01C52:  ADDWFC xA7,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01C54:  MOVF   xA8,W
01C56:  MULLW  04
01C58:  MOVF   FF3,W
01C5A:  CLRF   03
01C5C:  ADDLW  F8
01C5E:  MOVWF  FE9
01C60:  MOVLW  02
01C62:  ADDWFC 03,W
01C64:  MOVWF  FEA
01C66:  MOVFF  FEF,00
01C6A:  MOVFF  FEC,01
01C6E:  MOVFF  FEC,02
01C72:  MOVFF  FEC,03
01C76:  MOVLW  FF
01C78:  BSF    FD8.0
01C7A:  SUBFWB 00,W
01C7C:  MOVWF  xDE
01C7E:  MOVLW  FF
01C80:  SUBFWB 01,W
01C82:  MOVWF  xDF
01C84:  MOVLW  00
01C86:  SUBFWB 02,W
01C88:  MOVLW  00
01C8A:  SUBFWB 03,W
01C8C:  MOVFF  3DF,FB3
01C90:  MOVFF  3DE,FB2
....................         } else { 
01C94:  BRA    1CD6
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01C96:  MOVF   xA8,W
01C98:  MULLW  04
01C9A:  MOVF   FF3,W
01C9C:  CLRF   03
01C9E:  ADDLW  F8
01CA0:  MOVWF  FE9
01CA2:  MOVLW  02
01CA4:  ADDWFC 03,W
01CA6:  MOVWF  FEA
01CA8:  MOVFF  FEF,00
01CAC:  MOVFF  FEC,01
01CB0:  MOVFF  FEC,02
01CB4:  MOVFF  FEC,03
01CB8:  MOVLW  FF
01CBA:  BSF    FD8.0
01CBC:  SUBFWB 00,W
01CBE:  MOVWF  xDE
01CC0:  MOVLW  FF
01CC2:  SUBFWB 01,W
01CC4:  MOVWF  xDF
01CC6:  MOVLW  00
01CC8:  SUBFWB 02,W
01CCA:  MOVLW  00
01CCC:  SUBFWB 03,W
01CCE:  MOVFF  3DF,FB3
01CD2:  MOVFF  3DE,FB2
....................         } 
....................         break; 
....................     } 
01CD6:  MOVLB  0
01CD8:  RETURN 0
.................... } 
....................  
.................... void proximo_valor_descida_z() { 
....................     if (atual_frequencia_z == 0) { 
01CDA:  MOVLB  3
01CDC:  MOVF   xA8,F
01CDE:  BNZ   1D22
....................         set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01CE0:  MOVF   xA8,W
01CE2:  MULLW  04
01CE4:  MOVF   FF3,W
01CE6:  CLRF   03
01CE8:  ADDLW  F8
01CEA:  MOVWF  FE9
01CEC:  MOVLW  02
01CEE:  ADDWFC 03,W
01CF0:  MOVWF  FEA
01CF2:  MOVFF  FEF,00
01CF6:  MOVFF  FEC,01
01CFA:  MOVFF  FEC,02
01CFE:  MOVFF  FEC,03
01D02:  MOVLW  FF
01D04:  BSF    FD8.0
01D06:  SUBFWB 00,W
01D08:  MOVWF  xDE
01D0A:  MOVLW  FF
01D0C:  SUBFWB 01,W
01D0E:  MOVWF  xDF
01D10:  MOVLW  00
01D12:  SUBFWB 02,W
01D14:  MOVLW  00
01D16:  SUBFWB 03,W
01D18:  MOVFF  3DF,FB3
01D1C:  MOVFF  3DE,FB2
....................     } 
01D20:  BRA    1F34
....................     else if (atual_frequencia_z == vel_z) { 
01D22:  MOVF   xA9,W
01D24:  SUBWF  xA8,W
01D26:  BTFSS  FD8.2
01D28:  BRA    1E6A
....................         if (step_no_z == (step_down_z + StepbyF_z[atual_frequencia_z])) { 
01D2A:  MOVF   xA8,W
01D2C:  MULLW  04
01D2E:  MOVF   FF3,W
01D30:  CLRF   03
01D32:  ADDLW  48
01D34:  MOVWF  FE9
01D36:  MOVLW  03
01D38:  ADDWFC 03,W
01D3A:  MOVWF  FEA
01D3C:  MOVFF  FEF,00
01D40:  MOVFF  FEC,01
01D44:  MOVFF  FEC,02
01D48:  MOVFF  FEC,03
01D4C:  MOVF   x9E,W
01D4E:  ADDWF  00,F
01D50:  MOVF   x9F,W
01D52:  ADDWFC 01,F
01D54:  MOVLW  00
01D56:  ADDWFC 02,F
01D58:  ADDWFC 03,F
01D5A:  MOVF   00,W
01D5C:  SUBWF  x9C,W
01D5E:  BNZ   1E28
01D60:  MOVF   01,W
01D62:  SUBWF  x9D,W
01D64:  BNZ   1E28
01D66:  MOVF   02,F
01D68:  BNZ   1E28
01D6A:  MOVF   03,F
01D6C:  BNZ   1E28
....................             step_acumulado_z = step_down_z + StepbyF_z[atual_frequencia_z] + StepbyF_z[atual_frequencia_z - 1]; 
01D6E:  MOVF   xA8,W
01D70:  MULLW  04
01D72:  MOVF   FF3,W
01D74:  CLRF   03
01D76:  ADDLW  48
01D78:  MOVWF  FE9
01D7A:  MOVLW  03
01D7C:  ADDWFC 03,W
01D7E:  MOVWF  FEA
01D80:  MOVFF  FEF,00
01D84:  MOVFF  FEC,01
01D88:  MOVFF  FEC,02
01D8C:  MOVFF  FEC,03
01D90:  MOVF   00,W
01D92:  ADDWF  x9E,W
01D94:  MOVWF  xDE
01D96:  MOVF   01,W
01D98:  ADDWFC x9F,W
01D9A:  MOVWF  xDF
01D9C:  MOVLW  00
01D9E:  ADDWFC 02,W
01DA0:  MOVWF  xE0
01DA2:  MOVLW  00
01DA4:  ADDWFC 03,W
01DA6:  MOVWF  xE1
01DA8:  MOVLW  01
01DAA:  SUBWF  xA8,W
01DAC:  MULLW  04
01DAE:  MOVF   FF3,W
01DB0:  CLRF   03
01DB2:  ADDLW  48
01DB4:  MOVWF  FE9
01DB6:  MOVLW  03
01DB8:  ADDWFC 03,W
01DBA:  MOVWF  FEA
01DBC:  MOVFF  FEF,00
01DC0:  MOVFF  FEC,01
01DC4:  MOVFF  FEC,02
01DC8:  MOVFF  FEC,03
01DCC:  MOVF   00,W
01DCE:  ADDWF  xDE,W
01DD0:  MOVWF  xA4
01DD2:  MOVF   01,W
01DD4:  ADDWFC xDF,W
01DD6:  MOVWF  xA5
01DD8:  MOVF   02,W
01DDA:  ADDWFC xE0,W
01DDC:  MOVWF  xA6
01DDE:  MOVF   03,W
01DE0:  ADDWFC xE1,W
01DE2:  MOVWF  xA7
....................             atual_frequencia_z--; 
01DE4:  DECF   xA8,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01DE6:  MOVF   xA8,W
01DE8:  MULLW  04
01DEA:  MOVF   FF3,W
01DEC:  CLRF   03
01DEE:  ADDLW  F8
01DF0:  MOVWF  FE9
01DF2:  MOVLW  02
01DF4:  ADDWFC 03,W
01DF6:  MOVWF  FEA
01DF8:  MOVFF  FEF,00
01DFC:  MOVFF  FEC,01
01E00:  MOVFF  FEC,02
01E04:  MOVFF  FEC,03
01E08:  MOVLW  FF
01E0A:  BSF    FD8.0
01E0C:  SUBFWB 00,W
01E0E:  MOVWF  xDE
01E10:  MOVLW  FF
01E12:  SUBFWB 01,W
01E14:  MOVWF  xDF
01E16:  MOVLW  00
01E18:  SUBFWB 02,W
01E1A:  MOVLW  00
01E1C:  SUBFWB 03,W
01E1E:  MOVFF  3DF,FB3
01E22:  MOVFF  3DE,FB2
....................         } else { 
01E26:  BRA    1E68
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01E28:  MOVF   xA8,W
01E2A:  MULLW  04
01E2C:  MOVF   FF3,W
01E2E:  CLRF   03
01E30:  ADDLW  F8
01E32:  MOVWF  FE9
01E34:  MOVLW  02
01E36:  ADDWFC 03,W
01E38:  MOVWF  FEA
01E3A:  MOVFF  FEF,00
01E3E:  MOVFF  FEC,01
01E42:  MOVFF  FEC,02
01E46:  MOVFF  FEC,03
01E4A:  MOVLW  FF
01E4C:  BSF    FD8.0
01E4E:  SUBFWB 00,W
01E50:  MOVWF  xDE
01E52:  MOVLW  FF
01E54:  SUBFWB 01,W
01E56:  MOVWF  xDF
01E58:  MOVLW  00
01E5A:  SUBFWB 02,W
01E5C:  MOVLW  00
01E5E:  SUBFWB 03,W
01E60:  MOVFF  3DF,FB3
01E64:  MOVFF  3DE,FB2
....................         } 
....................     } else { 
01E68:  BRA    1F34
....................         if (step_no_z == step_acumulado_z) { 
01E6A:  MOVF   xA4,W
01E6C:  SUBWF  x9C,W
01E6E:  BNZ   1EF4
01E70:  MOVF   xA5,W
01E72:  SUBWF  x9D,W
01E74:  BNZ   1EF4
01E76:  MOVF   xA6,F
01E78:  BNZ   1EF4
01E7A:  MOVF   xA7,F
01E7C:  BNZ   1EF4
....................             atual_frequencia_z--; 
01E7E:  DECF   xA8,F
....................             step_acumulado_z += StepbyF_z[atual_frequencia_z]; 
01E80:  MOVF   xA8,W
01E82:  MULLW  04
01E84:  MOVF   FF3,W
01E86:  CLRF   03
01E88:  ADDLW  48
01E8A:  MOVWF  FE9
01E8C:  MOVLW  03
01E8E:  ADDWFC 03,W
01E90:  MOVWF  FEA
01E92:  MOVFF  FEF,00
01E96:  MOVFF  FEC,01
01E9A:  MOVFF  FEC,02
01E9E:  MOVFF  FEC,03
01EA2:  MOVF   00,W
01EA4:  ADDWF  xA4,F
01EA6:  MOVF   01,W
01EA8:  ADDWFC xA5,F
01EAA:  MOVF   02,W
01EAC:  ADDWFC xA6,F
01EAE:  MOVF   03,W
01EB0:  ADDWFC xA7,F
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01EB2:  MOVF   xA8,W
01EB4:  MULLW  04
01EB6:  MOVF   FF3,W
01EB8:  CLRF   03
01EBA:  ADDLW  F8
01EBC:  MOVWF  FE9
01EBE:  MOVLW  02
01EC0:  ADDWFC 03,W
01EC2:  MOVWF  FEA
01EC4:  MOVFF  FEF,00
01EC8:  MOVFF  FEC,01
01ECC:  MOVFF  FEC,02
01ED0:  MOVFF  FEC,03
01ED4:  MOVLW  FF
01ED6:  BSF    FD8.0
01ED8:  SUBFWB 00,W
01EDA:  MOVWF  xDE
01EDC:  MOVLW  FF
01EDE:  SUBFWB 01,W
01EE0:  MOVWF  xDF
01EE2:  MOVLW  00
01EE4:  SUBFWB 02,W
01EE6:  MOVLW  00
01EE8:  SUBFWB 03,W
01EEA:  MOVFF  3DF,FB3
01EEE:  MOVFF  3DE,FB2
....................         } else { 
01EF2:  BRA    1F34
....................             set_timer3(65535 - Ts_z[atual_frequencia_z]); 
01EF4:  MOVF   xA8,W
01EF6:  MULLW  04
01EF8:  MOVF   FF3,W
01EFA:  CLRF   03
01EFC:  ADDLW  F8
01EFE:  MOVWF  FE9
01F00:  MOVLW  02
01F02:  ADDWFC 03,W
01F04:  MOVWF  FEA
01F06:  MOVFF  FEF,00
01F0A:  MOVFF  FEC,01
01F0E:  MOVFF  FEC,02
01F12:  MOVFF  FEC,03
01F16:  MOVLW  FF
01F18:  BSF    FD8.0
01F1A:  SUBFWB 00,W
01F1C:  MOVWF  xDE
01F1E:  MOVLW  FF
01F20:  SUBFWB 01,W
01F22:  MOVWF  xDF
01F24:  MOVLW  00
01F26:  SUBFWB 02,W
01F28:  MOVLW  00
01F2A:  SUBFWB 03,W
01F2C:  MOVFF  3DF,FB3
01F30:  MOVFF  3DE,FB2
....................         } 
....................     } 
01F34:  MOVLB  0
01F36:  GOTO   1F9C (RETURN)
.................... } 
....................  
.................... void movimenta_eixo_z() { 
....................  
....................     switch (ramp_sts_z) { 
01F3A:  MOVLB  3
01F3C:  MOVF   x9B,W
01F3E:  XORLW  01
01F40:  MOVLB  0
01F42:  BZ    1F4E
01F44:  XORLW  02
01F46:  BZ    1F90
01F48:  XORLW  01
01F4A:  BZ    1FB0
01F4C:  BRA    1FD2
....................         case ramp_up: // accel 
....................             output_toggle(step_z); 
01F4E:  BCF    F92.5
01F50:  BTG    F89.5
....................             rest_z = ~rest_z; 
01F52:  MOVLB  2
01F54:  BTG    xC6.2
....................             proximo_valor_subida_z(); 
01F56:  MOVLB  0
01F58:  RCALL  1A9A
....................             if (step_no_z == midpt_z) { // midpoint: decel 
01F5A:  MOVLB  3
01F5C:  MOVF   xA2,W
01F5E:  SUBWF  x9C,W
01F60:  BNZ   1F8E
01F62:  MOVF   xA3,W
01F64:  SUBWF  x9D,W
01F66:  BNZ   1F8E
....................                 if (move_z > 2 * total_acc_step_z) 
01F68:  BCF    FD8.0
01F6A:  RLCF   x98,W
01F6C:  MOVWF  02
01F6E:  RLCF   x99,W
01F70:  MOVWF  03
01F72:  MOVFF  02,01
01F76:  MOVF   03,W
01F78:  SUBWF  xA1,W
01F7A:  BNC   1F8A
01F7C:  BNZ   1F84
01F7E:  MOVF   xA0,W
01F80:  SUBWF  01,W
01F82:  BC    1F8A
....................                     ramp_sts_z = ramp_max; 
01F84:  MOVLW  02
01F86:  MOVWF  x9B
01F88:  BRA    1F8E
....................                 else 
....................                     ramp_sts_z = ramp_down; 
01F8A:  MOVLW  03
01F8C:  MOVWF  x9B
....................             } 
....................             break; 
01F8E:  BRA    1FDE
....................  
....................         case ramp_down: // decel 
....................             output_toggle(step_z); 
01F90:  BCF    F92.5
01F92:  BTG    F89.5
....................             rest_z = ~rest_z; 
01F94:  MOVLB  2
01F96:  BTG    xC6.2
....................             proximo_valor_descida_z(); 
01F98:  MOVLB  0
01F9A:  BRA    1CDA
....................             if (step_no_z == move_z) 
01F9C:  MOVLB  3
01F9E:  MOVF   xA0,W
01FA0:  SUBWF  x9C,W
01FA2:  BNZ   1FAE
01FA4:  MOVF   xA1,W
01FA6:  SUBWF  x9D,W
01FA8:  BNZ   1FAE
....................                 ramp_sts_z = ramp_last; 
01FAA:  MOVLW  04
01FAC:  MOVWF  x9B
....................             break; 
01FAE:  BRA    1FDE
....................  
....................         case ramp_max: // constant speed 
....................             output_toggle(step_z); 
01FB0:  BCF    F92.5
01FB2:  BTG    F89.5
....................             rest_z = ~rest_z; 
01FB4:  MOVLB  2
01FB6:  BTG    xC6.2
....................             proximo_valor_subida_z(); 
01FB8:  MOVLB  0
01FBA:  RCALL  1A9A
....................             if (step_no_z == step_down_z) // start decel 
01FBC:  MOVLB  3
01FBE:  MOVF   x9E,W
01FC0:  SUBWF  x9C,W
01FC2:  BNZ   1FCE
01FC4:  MOVF   x9F,W
01FC6:  SUBWF  x9D,W
01FC8:  BNZ   1FCE
....................                 ramp_sts_z = ramp_down; 
01FCA:  MOVLW  03
01FCC:  MOVWF  x9B
....................             break; 
01FCE:  BRA    1FDE
01FD0:  MOVLB  0
....................  
....................         default: // last step: cleanup 
....................             ramp_sts_z = ramp_idle; 
01FD2:  MOVLB  3
01FD4:  CLRF   x9B
....................             disable_interrupts(INT_TIMER3); 
01FD6:  BCF    FA0.1
....................             run_flg_z = FALSE; // move_z complete 
01FD8:  MOVLB  2
01FDA:  BCF    xC6.1
....................             break; 
01FDC:  MOVLB  3
....................     } // switch (ramp_sts_z) 
....................     if (ramp_sts_z != ramp_idle) { 
01FDE:  MOVF   x9B,F
01FE0:  BZ    200C
....................         if (rest_z) { 
01FE2:  MOVLB  2
01FE4:  BTFSS  xC6.2
01FE6:  BRA    200E
....................             motor_pos_z += pos_inc_z; 
01FE8:  CLRF   03
01FEA:  MOVLB  3
01FEC:  MOVF   x9A,W
01FEE:  BTFSC  FE8.7
01FF0:  DECF   03,F
01FF2:  MOVLB  1
01FF4:  ADDWF  x18,W
01FF6:  MOVWF  01
01FF8:  MOVF   x19,W
01FFA:  ADDWFC 03,F
01FFC:  MOVFF  01,118
02000:  MOVFF  03,119
....................             ++step_no_z; 
02004:  MOVLB  3
02006:  INCF   x9C,F
02008:  BTFSC  FD8.2
0200A:  INCF   x9D,F
0200C:  MOVLB  2
....................         } 
....................     } 
0200E:  MOVLB  0
02010:  GOTO   2016 (RETURN)
.................... } 
....................  
.................... void umpasso_z(int16 descanco, short dir) { 
....................     output_low(enable_z); 
....................     if (dir) { 
....................         output_high(dir_z); 
....................         motor_pos_z--; 
....................     } else { 
....................         output_low(dir_z); 
....................         motor_pos_z++; 
....................     } 
....................     output_high(step_z); 
....................     delay_us(descanco); 
....................     output_low(step_z); 
....................     delay_us(descanco); 
....................  
.................... } 
....................  
.................... void zerar_z() { 
....................  
....................     while (le_Input(s_limite_z) == 1) { 
....................         delay_us(200); 
....................         umpasso_z(600, FALSE);//600 
....................     } 
....................     while (le_Input(s_limite_z) == 0) { 
....................         delay_us(200); 
....................         umpasso_z(900, TRUE);//900 
....................     } 
....................     while (le_Input(s_limite_z) == 1) { 
....................         delay_us(200); 
....................         umpasso_z(1000, FALSE);//1000 
....................     } 
....................    // output_high(enable_z); 
....................     motor_pos_z = 0; 
.................... } 
....................  
.................... void medir_z() { 
....................     while (le_Input(i_limite_z) == 0) { 
....................         umpasso_z(900, FALSE); 
....................         delay_us(200); 
....................     } 
....................     while (le_Input(i_limite_z) == 1) { 
....................         umpasso_z(900, TRUE); 
....................         delay_us(200); 
....................     } 
....................     max_posicao_z = motor_pos_z; 
....................     output_high(enable_z); 
....................     printf(lcd_putc, "%04Lu", max_posicao_z); 
.................... } 
.................... // </editor-fold> 
....................  
.................... #include "movimentos_maq_1.c" 
.................... void go_flip(long int flip_posicao) { 
....................     sentido_horario_flag = false; 
*
05988:  MOVLB  1
0598A:  BCF    x1A.2
....................     sentido_antihorario_flag = false; 
0598C:  BCF    x1A.3
....................     if (flip_posicao > contador_step_flip) {  
0598E:  MOVF   x17,W
05990:  MOVLB  3
05992:  SUBWF  xB1,W
05994:  BNC   59B2
05996:  BNZ   59A8
05998:  MOVF   xB0,W
0599A:  MOVLB  1
0599C:  SUBWF  x16,W
0599E:  BTFSS  FD8.0
059A0:  BRA    59A6
059A2:  MOVLB  3
059A4:  BRA    59B2
059A6:  MOVLB  3
....................         sentido_horario(); 
059A8:  MOVLB  0
059AA:  CALL   492A
.................... 	}else{ 
059AE:  BRA    59B8
059B0:  MOVLB  3
....................         sentido_antihorario(); 
059B2:  MOVLB  0
059B4:  CALL   496C
.................... 	} 
....................     while(flip_posicao != contador_step_flip) { 
059B8:  MOVLB  1
059BA:  MOVF   x16,W
059BC:  MOVLB  3
059BE:  SUBWF  xB0,W
059C0:  BNZ   59CC
059C2:  MOVLB  1
059C4:  MOVF   x17,W
059C6:  MOVLB  3
059C8:  SUBWF  xB1,W
059CA:  BZ    59E2
....................         one_step_flip(); 
059CC:  MOVLB  0
059CE:  CALL   4938
....................         delay_us(velocidade_motor); 
059D2:  MOVLW  02
059D4:  MOVLB  3
059D6:  MOVWF  xBE
059D8:  MOVLB  0
059DA:  CALL   206E
059DE:  BRA    59B8
059E0:  MOVLB  3
....................     } 
059E2:  MOVLB  0
059E4:  RETURN 0
.................... } 
....................  
.................... int   flip_home(void) { 
*
0497A:  MOVLB  3
0497C:  CLRF   xB1
.................... 	int i; 
....................     int erro=0; 
.................... 	chopper_flip(); 
0497E:  MOVLB  0
04980:  BRA    4922
.................... 	delay_ms(50);	 
04982:  MOVLW  32
04984:  MOVLB  3
04986:  MOVWF  xBE
04988:  MOVLB  0
0498A:  CALL   206E
.................... 	if(le_Input(S_ROTACAO_LS1) == true) { 
0498E:  MOVLW  0B
04990:  MOVLB  3
04992:  MOVWF  xB2
04994:  MOVLB  0
04996:  CALL   409A
0499A:  DECFSZ 01,W
0499C:  BRA    4A2E
.................... 		sentido_horario(); 
0499E:  RCALL  492A
.................... 		delay_ms(50); 
049A0:  MOVLW  32
049A2:  MOVLB  3
049A4:  MOVWF  xBE
049A6:  MOVLB  0
049A8:  CALL   206E
.................... 	    for(i=0;i<=140;i++) {							 
049AC:  MOVLB  3
049AE:  CLRF   xB0
049B0:  MOVF   xB0,W
049B2:  SUBLW  8C
049B4:  BNC   49CC
.................... 		    one_step_flip(); 
049B6:  MOVLB  0
049B8:  RCALL  4938
.................... 			delay_us(4000); 
049BA:  MOVLW  04
049BC:  MOVLB  3
049BE:  MOVWF  xBE
049C0:  MOVLB  0
049C2:  CALL   206E
049C6:  MOVLB  3
049C8:  INCF   xB0,F
049CA:  BRA    49B0
.................... 		} 
.................... 		sentido_antihorario(); 
049CC:  MOVLB  0
049CE:  RCALL  496C
.................... 		delay_ms(100); 
049D0:  MOVLW  64
049D2:  MOVLB  3
049D4:  MOVWF  xBE
049D6:  MOVLB  0
049D8:  CALL   206E
.................... 	    while(le_Input(S_ROTACAO_LS1) == false) {				 
049DC:  MOVLW  0B
049DE:  MOVLB  3
049E0:  MOVWF  xB2
049E2:  MOVLB  0
049E4:  CALL   409A
049E8:  MOVF   01,F
049EA:  BNZ   49FC
....................             one_step_flip(); 
049EC:  RCALL  4938
....................             delay_us(4000); 
049EE:  MOVLW  04
049F0:  MOVLB  3
049F2:  MOVWF  xBE
049F4:  MOVLB  0
049F6:  CALL   206E
049FA:  BRA    49DC
.................... 		}				 
....................         for(i=0;i<=36;i++) { 
049FC:  MOVLB  3
049FE:  CLRF   xB0
04A00:  MOVF   xB0,W
04A02:  SUBLW  24
04A04:  BNC   4A1C
....................             one_step_flip(); 
04A06:  MOVLB  0
04A08:  RCALL  4938
....................             delay_us(4000); 
04A0A:  MOVLW  04
04A0C:  MOVLB  3
04A0E:  MOVWF  xBE
04A10:  MOVLB  0
04A12:  CALL   206E
04A16:  MOVLB  3
04A18:  INCF   xB0,F
04A1A:  BRA    4A00
....................         } 
....................         sentido_horario(); 
04A1C:  MOVLB  0
04A1E:  RCALL  492A
....................         delay_ms(50);		 
04A20:  MOVLW  32
04A22:  MOVLB  3
04A24:  MOVWF  xBE
04A26:  MOVLB  0
04A28:  CALL   206E
.................... 	}else{			 
04A2C:  BRA    4A7E
....................         sentido_antihorario(); 
04A2E:  RCALL  496C
....................         delay_ms(50); 
04A30:  MOVLW  32
04A32:  MOVLB  3
04A34:  MOVWF  xBE
04A36:  MOVLB  0
04A38:  CALL   206E
....................         while(le_Input(S_ROTACAO_LS1) == false){				 
04A3C:  MOVLW  0B
04A3E:  MOVLB  3
04A40:  MOVWF  xB2
04A42:  MOVLB  0
04A44:  CALL   409A
04A48:  MOVF   01,F
04A4A:  BNZ   4A5C
....................             one_step_flip(); 
04A4C:  RCALL  4938
....................             delay_us(2000); 
04A4E:  MOVLW  02
04A50:  MOVLB  3
04A52:  MOVWF  xBE
04A54:  MOVLB  0
04A56:  CALL   206E
04A5A:  BRA    4A3C
....................         }				 
....................         for(i=0;i<=36;i++) { 
04A5C:  MOVLB  3
04A5E:  CLRF   xB0
04A60:  MOVF   xB0,W
04A62:  SUBLW  24
04A64:  BNC   4A7C
....................             one_step_flip(); 
04A66:  MOVLB  0
04A68:  RCALL  4938
....................             delay_us(4000); 
04A6A:  MOVLW  04
04A6C:  MOVLB  3
04A6E:  MOVWF  xBE
04A70:  MOVLB  0
04A72:  CALL   206E
04A76:  MOVLB  3
04A78:  INCF   xB0,F
04A7A:  BRA    4A60
04A7C:  MOVLB  0
....................         } 
.................... 	}	  
....................     sentido_horario(); 
04A7E:  RCALL  492A
....................     delay_ms(50); 
04A80:  MOVLW  32
04A82:  MOVLB  3
04A84:  MOVWF  xBE
04A86:  MOVLB  0
04A88:  CALL   206E
....................     for(i=0;i<=71;i++) { 
04A8C:  MOVLB  3
04A8E:  CLRF   xB0
04A90:  MOVF   xB0,W
04A92:  SUBLW  47
04A94:  BNC   4AAC
....................         one_step_flip(); 
04A96:  MOVLB  0
04A98:  RCALL  4938
....................         delay_us(4000); 
04A9A:  MOVLW  04
04A9C:  MOVLB  3
04A9E:  MOVWF  xBE
04AA0:  MOVLB  0
04AA2:  CALL   206E
04AA6:  MOVLB  3
04AA8:  INCF   xB0,F
04AAA:  BRA    4A90
....................     } 
....................     contador_step_flip = 0;			 
04AAC:  MOVLB  1
04AAE:  CLRF   x17
04AB0:  CLRF   x16
....................     return erro; 
04AB2:  MOVLB  3
04AB4:  MOVFF  3B1,01
04AB8:  MOVLB  0
04ABA:  RETURN 0
.................... } 
.................... void  x_home_esquerda() { 
.................... 	int i; 
.................... 	chopper_x(); 
*
045E8:  RCALL  4590
.................... 	delay_ms(50);	 
045EA:  MOVLW  32
045EC:  MOVLB  3
045EE:  MOVWF  xBE
045F0:  MOVLB  0
045F2:  CALL   206E
.................... 	if(le_Input(S_X_ESQUERDA) == true) { 
045F6:  MOVLW  06
045F8:  MOVLB  3
045FA:  MOVWF  xB2
045FC:  MOVLB  0
045FE:  RCALL  409A
04600:  DECFSZ 01,W
04602:  BRA    46A2
.................... 		direita(); 
04604:  RCALL  4596
.................... 		delay_ms(50); 
04606:  MOVLW  32
04608:  MOVLB  3
0460A:  MOVWF  xBE
0460C:  MOVLB  0
0460E:  CALL   206E
....................         while(le_Input(S_X_ESQUERDA) == true) { 
04612:  MOVLW  06
04614:  MOVLB  3
04616:  MOVWF  xB2
04618:  MOVLB  0
0461A:  RCALL  409A
0461C:  DECFSZ 01,W
0461E:  BRA    4630
....................             one_step_x(); 
04620:  RCALL  45A0
....................             delay_us(2000); 
04622:  MOVLW  02
04624:  MOVLB  3
04626:  MOVWF  xBE
04628:  MOVLB  0
0462A:  CALL   206E
0462E:  BRA    4612
....................         } 
....................         for(i=0;i<=40;i++) { 
04630:  MOVLB  3
04632:  CLRF   xB0
04634:  MOVF   xB0,W
04636:  SUBLW  28
04638:  BNC   4650
....................             one_step_x(); 
0463A:  MOVLB  0
0463C:  RCALL  45A0
....................             delay_us(2000); 
0463E:  MOVLW  02
04640:  MOVLB  3
04642:  MOVWF  xBE
04644:  MOVLB  0
04646:  CALL   206E
0464A:  MOVLB  3
0464C:  INCF   xB0,F
0464E:  BRA    4634
....................         } 
.................... 		esquerda(); 
04650:  MOVLB  0
04652:  RCALL  45D8
.................... 		delay_ms(50); 
04654:  MOVLW  32
04656:  MOVLB  3
04658:  MOVWF  xBE
0465A:  MOVLB  0
0465C:  CALL   206E
....................         while(le_Input(S_X_ESQUERDA) == false) {				 
04660:  MOVLW  06
04662:  MOVLB  3
04664:  MOVWF  xB2
04666:  MOVLB  0
04668:  RCALL  409A
0466A:  MOVF   01,F
0466C:  BNZ   467E
....................             one_step_x(); 
0466E:  RCALL  45A0
....................             delay_us(2000); 
04670:  MOVLW  02
04672:  MOVLB  3
04674:  MOVWF  xBE
04676:  MOVLB  0
04678:  CALL   206E
0467C:  BRA    4660
.................... 		}			 
....................         for(i=0;i<=40;i++) { 
0467E:  MOVLB  3
04680:  CLRF   xB0
04682:  MOVF   xB0,W
04684:  SUBLW  28
04686:  BNC   469E
....................             one_step_x(); 
04688:  MOVLB  0
0468A:  RCALL  45A0
....................             delay_us(2000); 
0468C:  MOVLW  02
0468E:  MOVLB  3
04690:  MOVWF  xBE
04692:  MOVLB  0
04694:  CALL   206E
04698:  MOVLB  3
0469A:  INCF   xB0,F
0469C:  BRA    4682
....................         } 
.................... 	}else{ 
0469E:  BRA    46EE
046A0:  MOVLB  0
....................         esquerda(); 
046A2:  RCALL  45D8
....................         delay_ms(50); 
046A4:  MOVLW  32
046A6:  MOVLB  3
046A8:  MOVWF  xBE
046AA:  MOVLB  0
046AC:  CALL   206E
....................         while(le_Input(S_X_ESQUERDA) == false) { 
046B0:  MOVLW  06
046B2:  MOVLB  3
046B4:  MOVWF  xB2
046B6:  MOVLB  0
046B8:  RCALL  409A
046BA:  MOVF   01,F
046BC:  BNZ   46CE
....................             one_step_x(); 
046BE:  RCALL  45A0
....................             delay_us(2000); 
046C0:  MOVLW  02
046C2:  MOVLB  3
046C4:  MOVWF  xBE
046C6:  MOVLB  0
046C8:  CALL   206E
046CC:  BRA    46B0
....................         }				 
....................         for(i=0;i<=40;i++) { 
046CE:  MOVLB  3
046D0:  CLRF   xB0
046D2:  MOVF   xB0,W
046D4:  SUBLW  28
046D6:  BNC   46EE
....................             one_step_x(); 
046D8:  MOVLB  0
046DA:  RCALL  45A0
....................             delay_us(2000); 
046DC:  MOVLW  02
046DE:  MOVLB  3
046E0:  MOVWF  xBE
046E2:  MOVLB  0
046E4:  CALL   206E
046E8:  MOVLB  3
046EA:  INCF   xB0,F
046EC:  BRA    46D2
....................         } 
.................... 	}	 
....................     motor_pos_x = 0;  
046EE:  MOVLB  1
046F0:  CLRF   x13
046F2:  CLRF   x12
....................     stop_x();			 
046F4:  MOVLB  0
046F6:  RCALL  45E2
046F8:  RETURN 0
.................... } 
.................... void  y_home_frente(){ 
.................... 	int i; 
.................... 	chopper_y(); 
046FA:  RCALL  4424
.................... 	delay_ms(50);	 
046FC:  MOVLW  32
046FE:  MOVLB  3
04700:  MOVWF  xBE
04702:  MOVLB  0
04704:  CALL   206E
.................... 	if(le_Input(S_Y_FRENTE) == true) { 
04708:  MOVLW  07
0470A:  MOVLB  3
0470C:  MOVWF  xB2
0470E:  MOVLB  0
04710:  RCALL  409A
04712:  DECFSZ 01,W
04714:  BRA    47B4
.................... 		atras(); 
04716:  RCALL  446C
.................... 		delay_ms(50); 
04718:  MOVLW  32
0471A:  MOVLB  3
0471C:  MOVWF  xBE
0471E:  MOVLB  0
04720:  CALL   206E
....................         while(le_Input(S_Y_FRENTE) == true) { 
04724:  MOVLW  07
04726:  MOVLB  3
04728:  MOVWF  xB2
0472A:  MOVLB  0
0472C:  RCALL  409A
0472E:  DECFSZ 01,W
04730:  BRA    4742
....................             one_step_y(); 
04732:  RCALL  4434
....................             delay_us(2000); 
04734:  MOVLW  02
04736:  MOVLB  3
04738:  MOVWF  xBE
0473A:  MOVLB  0
0473C:  CALL   206E
04740:  BRA    4724
....................         } 
....................         for(i=0;i<=40;i++) { //para sair do histerese do sensor dando maior precisao 
04742:  MOVLB  3
04744:  CLRF   xB0
04746:  MOVF   xB0,W
04748:  SUBLW  28
0474A:  BNC   4762
....................             one_step_y(); 
0474C:  MOVLB  0
0474E:  RCALL  4434
....................             delay_us(2000); 
04750:  MOVLW  02
04752:  MOVLB  3
04754:  MOVWF  xBE
04756:  MOVLB  0
04758:  CALL   206E
0475C:  MOVLB  3
0475E:  INCF   xB0,F
04760:  BRA    4746
....................         } 
.................... 		frente(); 
04762:  MOVLB  0
04764:  RCALL  442A
.................... 		delay_ms(50); 
04766:  MOVLW  32
04768:  MOVLB  3
0476A:  MOVWF  xBE
0476C:  MOVLB  0
0476E:  CALL   206E
....................         while(le_Input(S_Y_FRENTE) == false){				 
04772:  MOVLW  07
04774:  MOVLB  3
04776:  MOVWF  xB2
04778:  MOVLB  0
0477A:  RCALL  409A
0477C:  MOVF   01,F
0477E:  BNZ   4790
....................             one_step_y(); 
04780:  RCALL  4434
....................             delay_us(2000); 
04782:  MOVLW  02
04784:  MOVLB  3
04786:  MOVWF  xBE
04788:  MOVLB  0
0478A:  CALL   206E
0478E:  BRA    4772
....................         }				 
....................         for(i=0;i<=40;i++){ 
04790:  MOVLB  3
04792:  CLRF   xB0
04794:  MOVF   xB0,W
04796:  SUBLW  28
04798:  BNC   47B0
....................             one_step_y(); 
0479A:  MOVLB  0
0479C:  RCALL  4434
....................             delay_us(2000); 
0479E:  MOVLW  02
047A0:  MOVLB  3
047A2:  MOVWF  xBE
047A4:  MOVLB  0
047A6:  CALL   206E
047AA:  MOVLB  3
047AC:  INCF   xB0,F
047AE:  BRA    4794
....................         } 
.................... 	}else{ 
047B0:  BRA    4800
047B2:  MOVLB  0
....................         frente(); 
047B4:  RCALL  442A
....................         delay_ms(50); 
047B6:  MOVLW  32
047B8:  MOVLB  3
047BA:  MOVWF  xBE
047BC:  MOVLB  0
047BE:  CALL   206E
....................         while(le_Input(S_Y_FRENTE) == false) { 
047C2:  MOVLW  07
047C4:  MOVLB  3
047C6:  MOVWF  xB2
047C8:  MOVLB  0
047CA:  RCALL  409A
047CC:  MOVF   01,F
047CE:  BNZ   47E0
....................             one_step_y(); 
047D0:  RCALL  4434
....................             delay_us(2000); 
047D2:  MOVLW  02
047D4:  MOVLB  3
047D6:  MOVWF  xBE
047D8:  MOVLB  0
047DA:  CALL   206E
047DE:  BRA    47C2
....................         }				 
....................         for(i=0;i<=40;i++) { 
047E0:  MOVLB  3
047E2:  CLRF   xB0
047E4:  MOVF   xB0,W
047E6:  SUBLW  28
047E8:  BNC   4800
....................             one_step_y(); 
047EA:  MOVLB  0
047EC:  RCALL  4434
....................             delay_us(2000); 
047EE:  MOVLW  02
047F0:  MOVLB  3
047F2:  MOVWF  xBE
047F4:  MOVLB  0
047F6:  CALL   206E
047FA:  MOVLB  3
047FC:  INCF   xB0,F
047FE:  BRA    47E4
....................         } 
.................... 	}	 
....................     motor_pos_y = 0;   
04800:  MOVLB  1
04802:  CLRF   x15
04804:  CLRF   x14
....................     stop_y();			 
04806:  MOVLB  0
04808:  RCALL  4476
0480A:  RETURN 0
.................... } 
.................... void  y_home_atras() { 
.................... 	int i; 
.................... 	chopper_y(); 
*
0447C:  RCALL  4424
.................... 	delay_ms(50);	 
0447E:  MOVLW  32
04480:  MOVLB  3
04482:  MOVWF  xBE
04484:  MOVLB  0
04486:  CALL   206E
.................... 	if(le_Input(S_Y_ATRAS) == true) { 
0448A:  MOVLW  08
0448C:  MOVLB  3
0448E:  MOVWF  xB2
04490:  MOVLB  0
04492:  RCALL  409A
04494:  DECFSZ 01,W
04496:  BRA    4536
.................... 		frente(); 
04498:  RCALL  442A
.................... 		delay_ms(50); 
0449A:  MOVLW  32
0449C:  MOVLB  3
0449E:  MOVWF  xBE
044A0:  MOVLB  0
044A2:  CALL   206E
....................         while(le_Input(S_Y_ATRAS) == true){ 
044A6:  MOVLW  08
044A8:  MOVLB  3
044AA:  MOVWF  xB2
044AC:  MOVLB  0
044AE:  RCALL  409A
044B0:  DECFSZ 01,W
044B2:  BRA    44C4
....................             one_step_y(); 
044B4:  RCALL  4434
....................             delay_us(2000); 
044B6:  MOVLW  02
044B8:  MOVLB  3
044BA:  MOVWF  xBE
044BC:  MOVLB  0
044BE:  CALL   206E
044C2:  BRA    44A6
....................         } 
....................         for(i=0;i<=40;i++){ //para sair do histerese do sensor dando maior precisao 
044C4:  MOVLB  3
044C6:  CLRF   xB0
044C8:  MOVF   xB0,W
044CA:  SUBLW  28
044CC:  BNC   44E4
....................             one_step_y(); 
044CE:  MOVLB  0
044D0:  RCALL  4434
....................             delay_us(2000); 
044D2:  MOVLW  02
044D4:  MOVLB  3
044D6:  MOVWF  xBE
044D8:  MOVLB  0
044DA:  CALL   206E
044DE:  MOVLB  3
044E0:  INCF   xB0,F
044E2:  BRA    44C8
....................         } 
.................... 		atras(); 
044E4:  MOVLB  0
044E6:  RCALL  446C
.................... 		delay_ms(50); 
044E8:  MOVLW  32
044EA:  MOVLB  3
044EC:  MOVWF  xBE
044EE:  MOVLB  0
044F0:  CALL   206E
....................         while(le_Input(S_Y_ATRAS) == false) {				 
044F4:  MOVLW  08
044F6:  MOVLB  3
044F8:  MOVWF  xB2
044FA:  MOVLB  0
044FC:  RCALL  409A
044FE:  MOVF   01,F
04500:  BNZ   4512
....................             one_step_y(); 
04502:  RCALL  4434
....................             delay_us(2000); 
04504:  MOVLW  02
04506:  MOVLB  3
04508:  MOVWF  xBE
0450A:  MOVLB  0
0450C:  CALL   206E
04510:  BRA    44F4
....................         }				 
....................         for(i=0;i<=40;i++){ 
04512:  MOVLB  3
04514:  CLRF   xB0
04516:  MOVF   xB0,W
04518:  SUBLW  28
0451A:  BNC   4532
....................             one_step_y(); 
0451C:  MOVLB  0
0451E:  RCALL  4434
....................             delay_us(2000); 
04520:  MOVLW  02
04522:  MOVLB  3
04524:  MOVWF  xBE
04526:  MOVLB  0
04528:  CALL   206E
0452C:  MOVLB  3
0452E:  INCF   xB0,F
04530:  BRA    4516
....................         } 
.................... 	}else{ 
04532:  BRA    4582
04534:  MOVLB  0
....................         atras(); 
04536:  RCALL  446C
....................         delay_ms(50); 
04538:  MOVLW  32
0453A:  MOVLB  3
0453C:  MOVWF  xBE
0453E:  MOVLB  0
04540:  CALL   206E
....................         while(le_Input(S_Y_ATRAS) == false) { 
04544:  MOVLW  08
04546:  MOVLB  3
04548:  MOVWF  xB2
0454A:  MOVLB  0
0454C:  RCALL  409A
0454E:  MOVF   01,F
04550:  BNZ   4562
....................             one_step_y(); 
04552:  RCALL  4434
....................             delay_us(2000); 
04554:  MOVLW  02
04556:  MOVLB  3
04558:  MOVWF  xBE
0455A:  MOVLB  0
0455C:  CALL   206E
04560:  BRA    4544
....................         } 
....................         for(i=0;i<=40;i++) { 
04562:  MOVLB  3
04564:  CLRF   xB0
04566:  MOVF   xB0,W
04568:  SUBLW  28
0456A:  BNC   4582
....................             one_step_y(); 
0456C:  MOVLB  0
0456E:  RCALL  4434
....................             delay_us(2000); 
04570:  MOVLW  02
04572:  MOVLB  3
04574:  MOVWF  xBE
04576:  MOVLB  0
04578:  CALL   206E
0457C:  MOVLB  3
0457E:  INCF   xB0,F
04580:  BRA    4566
....................         } 
.................... 	}	 
....................     motor_pos_y = 0;    
04582:  MOVLB  1
04584:  CLRF   x15
04586:  CLRF   x14
....................     stop_y();			 
04588:  MOVLB  0
0458A:  RCALL  4476
0458C:  GOTO   4D48 (RETURN)
.................... } 
.................... void  x_home_direita() {  
.................... 	int i; 
.................... 	chopper_x(); 
*
0480C:  RCALL  4590
.................... 	delay_ms(50);	 
0480E:  MOVLW  32
04810:  MOVLB  3
04812:  MOVWF  xBE
04814:  MOVLB  0
04816:  CALL   206E
.................... 	if(le_Input(S_X_DIREITA) == true) { 
0481A:  MOVLW  05
0481C:  MOVLB  3
0481E:  MOVWF  xB2
04820:  MOVLB  0
04822:  RCALL  409A
04824:  DECFSZ 01,W
04826:  BRA    48C6
.................... 		esquerda(); 
04828:  RCALL  45D8
.................... 		delay_ms(50); 
0482A:  MOVLW  32
0482C:  MOVLB  3
0482E:  MOVWF  xBE
04830:  MOVLB  0
04832:  CALL   206E
....................         while(le_Input(S_X_DIREITA) == true) { 
04836:  MOVLW  05
04838:  MOVLB  3
0483A:  MOVWF  xB2
0483C:  MOVLB  0
0483E:  RCALL  409A
04840:  DECFSZ 01,W
04842:  BRA    4854
....................             one_step_x(); 
04844:  RCALL  45A0
....................             delay_us(2000); 
04846:  MOVLW  02
04848:  MOVLB  3
0484A:  MOVWF  xBE
0484C:  MOVLB  0
0484E:  CALL   206E
04852:  BRA    4836
....................         } 
....................         for(i=0;i<=40;i++){ //para sair do histerese do sensor dando maior precisao 
04854:  MOVLB  3
04856:  CLRF   xB0
04858:  MOVF   xB0,W
0485A:  SUBLW  28
0485C:  BNC   4874
....................             one_step_x(); 
0485E:  MOVLB  0
04860:  RCALL  45A0
....................             delay_us(2000); 
04862:  MOVLW  02
04864:  MOVLB  3
04866:  MOVWF  xBE
04868:  MOVLB  0
0486A:  CALL   206E
0486E:  MOVLB  3
04870:  INCF   xB0,F
04872:  BRA    4858
....................         } 
.................... 		direita(); 
04874:  MOVLB  0
04876:  RCALL  4596
.................... 		delay_ms(50); 
04878:  MOVLW  32
0487A:  MOVLB  3
0487C:  MOVWF  xBE
0487E:  MOVLB  0
04880:  CALL   206E
....................         while(le_Input(S_X_DIREITA) == false) {				 
04884:  MOVLW  05
04886:  MOVLB  3
04888:  MOVWF  xB2
0488A:  MOVLB  0
0488C:  RCALL  409A
0488E:  MOVF   01,F
04890:  BNZ   48A2
....................             one_step_x(); 
04892:  RCALL  45A0
....................             delay_us(2000); 
04894:  MOVLW  02
04896:  MOVLB  3
04898:  MOVWF  xBE
0489A:  MOVLB  0
0489C:  CALL   206E
048A0:  BRA    4884
....................         }				 
....................         for(i=0;i<=40;i++) { 
048A2:  MOVLB  3
048A4:  CLRF   xB0
048A6:  MOVF   xB0,W
048A8:  SUBLW  28
048AA:  BNC   48C2
....................             one_step_x(); 
048AC:  MOVLB  0
048AE:  RCALL  45A0
....................             delay_us(2000); 
048B0:  MOVLW  02
048B2:  MOVLB  3
048B4:  MOVWF  xBE
048B6:  MOVLB  0
048B8:  CALL   206E
048BC:  MOVLB  3
048BE:  INCF   xB0,F
048C0:  BRA    48A6
....................         } 
.................... 	}else{			 
048C2:  BRA    4914
048C4:  MOVLB  0
....................         direita(); 
048C6:  RCALL  4596
....................         delay_ms(50); 
048C8:  MOVLW  32
048CA:  MOVLB  3
048CC:  MOVWF  xBE
048CE:  MOVLB  0
048D0:  CALL   206E
....................         while(le_Input(S_X_DIREITA) == false) { 
048D4:  MOVLW  05
048D6:  MOVLB  3
048D8:  MOVWF  xB2
048DA:  MOVLB  0
048DC:  CALL   409A
048E0:  MOVF   01,F
048E2:  BNZ   48F4
....................             one_step_x(); 
048E4:  RCALL  45A0
....................             delay_us(2000); 
048E6:  MOVLW  02
048E8:  MOVLB  3
048EA:  MOVWF  xBE
048EC:  MOVLB  0
048EE:  CALL   206E
048F2:  BRA    48D4
....................         } 
....................         for(i=0;i<=40;i++) { 
048F4:  MOVLB  3
048F6:  CLRF   xB0
048F8:  MOVF   xB0,W
048FA:  SUBLW  28
048FC:  BNC   4914
....................             one_step_x(); 
048FE:  MOVLB  0
04900:  RCALL  45A0
....................             delay_us(2000); 
04902:  MOVLW  02
04904:  MOVLB  3
04906:  MOVWF  xBE
04908:  MOVLB  0
0490A:  CALL   206E
0490E:  MOVLB  3
04910:  INCF   xB0,F
04912:  BRA    48F8
....................         } 
.................... 	} 
....................     motor_pos_x = 0;    
04914:  MOVLB  1
04916:  CLRF   x13
04918:  CLRF   x12
....................     stop_x();			 
0491A:  MOVLB  0
0491C:  RCALL  45E2
0491E:  GOTO   4D6A (RETURN)
.................... } 
.................... void  z_home() { 
.................... 	int i; 
.................... 	chopper_z(); 
*
0432E:  BRA    3FD4
.................... 	delay_ms(50);	 
04330:  MOVLW  32
04332:  MOVLB  3
04334:  MOVWF  xBE
04336:  MOVLB  0
04338:  CALL   206E
.................... 	if(le_Input(S_Z_TOP) == true) { 
0433C:  MOVLW  0D
0433E:  MOVLB  3
04340:  MOVWF  xB2
04342:  MOVLB  0
04344:  RCALL  409A
04346:  DECFSZ 01,W
04348:  BRA    43CA
.................... 		desce(); 
0434A:  RCALL  42D6
.................... 		delay_ms(50); 
0434C:  MOVLW  32
0434E:  MOVLB  3
04350:  MOVWF  xBE
04352:  MOVLB  0
04354:  CALL   206E
....................         for(i=0;i<=50;i++){ 
04358:  MOVLB  3
0435A:  CLRF   xB0
0435C:  MOVF   xB0,W
0435E:  SUBLW  32
04360:  BNC   4378
....................             one_step_z(); 
04362:  MOVLB  0
04364:  RCALL  42E4
....................             delay_us(2000); 
04366:  MOVLW  02
04368:  MOVLB  3
0436A:  MOVWF  xBE
0436C:  MOVLB  0
0436E:  CALL   206E
04372:  MOVLB  3
04374:  INCF   xB0,F
04376:  BRA    435C
....................         } 
....................         sobe(); 
04378:  MOVLB  0
0437A:  RCALL  4318
....................         delay_ms(50); 
0437C:  MOVLW  32
0437E:  MOVLB  3
04380:  MOVWF  xBE
04382:  MOVLB  0
04384:  CALL   206E
....................         while(le_Input(S_Z_TOP) == false) {				 
04388:  MOVLW  0D
0438A:  MOVLB  3
0438C:  MOVWF  xB2
0438E:  MOVLB  0
04390:  RCALL  409A
04392:  MOVF   01,F
04394:  BNZ   43A6
....................             one_step_z(); 
04396:  RCALL  42E4
....................             delay_us(2000); 
04398:  MOVLW  02
0439A:  MOVLB  3
0439C:  MOVWF  xBE
0439E:  MOVLB  0
043A0:  CALL   206E
043A4:  BRA    4388
....................         }				 
....................         for(i=0;i<=18;i++){ 
043A6:  MOVLB  3
043A8:  CLRF   xB0
043AA:  MOVF   xB0,W
043AC:  SUBLW  12
043AE:  BNC   43C6
....................             one_step_z(); 
043B0:  MOVLB  0
043B2:  RCALL  42E4
....................             delay_us(2000); 
043B4:  MOVLW  02
043B6:  MOVLB  3
043B8:  MOVWF  xBE
043BA:  MOVLB  0
043BC:  CALL   206E
043C0:  MOVLB  3
043C2:  INCF   xB0,F
043C4:  BRA    43AA
....................         } 
.................... 	}else{ 
043C6:  BRA    4416
043C8:  MOVLB  0
....................         sobe(); 
043CA:  RCALL  4318
....................         delay_ms(50); 
043CC:  MOVLW  32
043CE:  MOVLB  3
043D0:  MOVWF  xBE
043D2:  MOVLB  0
043D4:  CALL   206E
....................         while(le_Input(S_Z_TOP) == false) { 
043D8:  MOVLW  0D
043DA:  MOVLB  3
043DC:  MOVWF  xB2
043DE:  MOVLB  0
043E0:  RCALL  409A
043E2:  MOVF   01,F
043E4:  BNZ   43F6
....................             one_step_z(); 
043E6:  RCALL  42E4
....................             delay_us(2000); 
043E8:  MOVLW  02
043EA:  MOVLB  3
043EC:  MOVWF  xBE
043EE:  MOVLB  0
043F0:  CALL   206E
043F4:  BRA    43D8
....................         } 
....................         for(i=0;i<=18;i++) { 
043F6:  MOVLB  3
043F8:  CLRF   xB0
043FA:  MOVF   xB0,W
043FC:  SUBLW  12
043FE:  BNC   4416
....................             one_step_z(); 
04400:  MOVLB  0
04402:  RCALL  42E4
....................             delay_us(2000); 
04404:  MOVLW  02
04406:  MOVLB  3
04408:  MOVWF  xBE
0440A:  MOVLB  0
0440C:  CALL   206E
04410:  MOVLB  3
04412:  INCF   xB0,F
04414:  BRA    43FA
....................         } 
.................... 	} 
....................     motor_pos_z = 0;    
04416:  MOVLB  1
04418:  CLRF   x19
0441A:  CLRF   x18
.................... 	stop_z();			 
0441C:  MOVLB  0
0441E:  BRA    4326
04420:  GOTO   4D34 (RETURN)
.................... } 
....................  
.................... void posicao_maquina_1_default(void) { 
*
04CFA:  CALL   3B1E
04CFE:  MOVFF  01,3AD
....................     int posicao_outra_maquina = le_posicao_outra_maquina(); 
....................     while (posicao_outra_maquina != HOME1){ 
04D02:  MOVLB  3
04D04:  DECFSZ xAD,W
04D06:  BRA    4D0A
04D08:  BRA    4D20
....................         tela_esperando_mov_outra_maquina(HOME1); 
04D0A:  MOVLW  01
04D0C:  MOVWF  xB0
04D0E:  MOVLB  0
04D10:  GOTO   3C12
....................         posicao_outra_maquina = le_posicao_outra_maquina(); 
04D14:  CALL   3B1E
04D18:  MOVFF  01,3AD
04D1C:  BRA    4D02
04D1E:  MOVLB  3
....................     } 
....................     tela_movimentando_maquina(ALIMENTADOR); 
04D20:  CLRF   xB0
04D22:  MOVLB  0
04D24:  CALL   3E1C
....................     long int i = 0; 
04D28:  MOVLB  3
04D2A:  CLRF   xAF
04D2C:  CLRF   xAE
....................     z_home(); 
04D2E:  MOVLB  0
04D30:  GOTO   432E
....................     if (le_Input(S_Y_ATRAS) == true) { 
04D34:  MOVLW  08
04D36:  MOVLB  3
04D38:  MOVWF  xB2
04D3A:  MOVLB  0
04D3C:  CALL   409A
04D40:  DECFSZ 01,W
04D42:  BRA    4D4E
....................         y_home_atras(); 
04D44:  GOTO   447C
....................         x_home_esquerda(); 
04D48:  RCALL  45E8
....................         y_home_frente(); 
04D4A:  RCALL  46FA
....................          
....................     } else { 
04D4C:  BRA    4D68
....................         if (le_Input(S_Y_FRENTE) == true) { 
04D4E:  MOVLW  07
04D50:  MOVLB  3
04D52:  MOVWF  xB2
04D54:  MOVLB  0
04D56:  CALL   409A
04D5A:  DECFSZ 01,W
04D5C:  BRA    4D64
....................  
....................             y_home_frente(); 
04D5E:  RCALL  46FA
....................             x_home_esquerda(); 
04D60:  RCALL  45E8
....................         } else { 
04D62:  BRA    4D68
....................             x_home_esquerda(); 
04D64:  RCALL  45E8
....................             y_home_frente(); 
04D66:  RCALL  46FA
....................         } 
....................     } 
....................     x_home_direita(); 
04D68:  BRA    480C
....................     flip_home(); 
04D6A:  RCALL  497A
....................     chopper_y(); 
04D6C:  CALL   4424
....................     frente(); 
04D70:  CALL   442A
....................     delay_ms(50); 
04D74:  MOVLW  32
04D76:  MOVLB  3
04D78:  MOVWF  xBE
04D7A:  MOVLB  0
04D7C:  CALL   206E
....................     for (i = 0; i < 700; i++) { 
04D80:  MOVLB  3
04D82:  CLRF   xAF
04D84:  CLRF   xAE
04D86:  MOVF   xAF,W
04D88:  SUBLW  02
04D8A:  BNC   4DB0
04D8C:  BNZ   4D94
04D8E:  MOVF   xAE,W
04D90:  SUBLW  BB
04D92:  BNC   4DB0
....................         one_step_y(); 
04D94:  MOVLB  0
04D96:  CALL   4434
....................         delay_us(2000); 
04D9A:  MOVLW  02
04D9C:  MOVLB  3
04D9E:  MOVWF  xBE
04DA0:  MOVLB  0
04DA2:  CALL   206E
04DA6:  MOVLB  3
04DA8:  INCF   xAE,F
04DAA:  BTFSC  FD8.2
04DAC:  INCF   xAF,F
04DAE:  BRA    4D86
....................     } 
....................     chopper_x(); 
04DB0:  MOVLB  0
04DB2:  CALL   4590
....................     esquerda(); 
04DB6:  RCALL  45D8
....................     delay_ms(50);     
04DB8:  MOVLW  32
04DBA:  MOVLB  3
04DBC:  MOVWF  xBE
04DBE:  MOVLB  0
04DC0:  CALL   206E
....................     motor_pos_x = 0x0000; 
04DC4:  MOVLB  1
04DC6:  CLRF   x13
04DC8:  CLRF   x12
....................     motor_pos_y = 0x0000; 
04DCA:  CLRF   x15
04DCC:  CLRF   x14
....................     contador_step_flip = 0x0000; 
04DCE:  CLRF   x17
04DD0:  CLRF   x16
....................     motor_pos_z = 0x0000; 
04DD2:  CLRF   x19
04DD4:  CLRF   x18
....................     motor_run_x(50, 19); 
04DD6:  MOVLB  3
04DD8:  CLRF   xB7
04DDA:  CLRF   xB6
04DDC:  CLRF   xB5
04DDE:  MOVLW  32
04DE0:  MOVWF  xB4
04DE2:  MOVLW  13
04DE4:  MOVWF  xB8
04DE6:  MOVLB  0
04DE8:  RCALL  4ABC
....................     posicao_atual = ALIMENTADOR; 
04DEA:  CLRF   25
....................     envia_posicao_para_outra_maquina(ALIMENTADOR); 
04DEC:  MOVLB  3
04DEE:  CLRF   xB0
04DF0:  MOVLB  0
04DF2:  RCALL  4C2E
04DF4:  RETURN 0
.................... } 
.................... void envia_maquina_para_posicao(int posicao_futura){ 
....................     motor_run_z(0, 19); 
*
059E6:  MOVLB  3
059E8:  CLRF   xB7
059EA:  CLRF   xB6
059EC:  CLRF   xB5
059EE:  CLRF   xB4
059F0:  MOVLW  13
059F2:  MOVWF  xB8
059F4:  MOVLB  0
059F6:  RCALL  5642
....................     while ((run_flg_z)); 
059F8:  MOVLB  2
059FA:  BTFSC  xC6.1
059FC:  BRA    59FA
....................     switch (posicao_futura){ 
059FE:  MOVLB  3
05A00:  MOVF   xAF,W
05A02:  ADDLW  F8
05A04:  BTFSC  FD8.0
05A06:  GOTO   639A
05A0A:  ADDLW  08
05A0C:  MOVLB  0
05A0E:  GOTO   639E
....................         case ALIMENTADOR: 
....................             if(posicao_atual != ALIMENTADOR){ 
05A12:  MOVF   25,F
05A14:  BZ    5AB2
....................                 while (posicao_atual != HOME1){ 
05A16:  DECFSZ 25,W
05A18:  BRA    5A1C
05A1A:  BRA    5A20
....................                     tela_esperando_mov_maquina();                 
05A1C:  RCALL  579C
05A1E:  BRA    5A16
....................                 } 
....................                 posicao_outra_maquina = le_posicao_outra_maquina(); 
05A20:  CALL   3B1E
05A24:  MOVFF  01,27
....................                 while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)||(posicao_outra_maquina == ALIMENTADOR)){ 
05A28:  MOVF   27,W
05A2A:  SUBLW  06
05A2C:  BZ    5A38
05A2E:  MOVF   27,W
05A30:  SUBLW  07
05A32:  BZ    5A38
05A34:  MOVF   27,F
05A36:  BNZ   5A44
....................                     tela_esperando_sair_posicao_outra_maquina(); 
05A38:  RCALL  57CE
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
05A3A:  CALL   3B1E
05A3E:  MOVFF  01,27
05A42:  BRA    5A28
....................                 } 
....................                 envia_posicao_para_outra_maquina(ALIMENTADOR); 
05A44:  MOVLB  3
05A46:  CLRF   xB0
05A48:  MOVLB  0
05A4A:  CALL   4C2E
....................                 tela_movimentando_maquina(ALIMENTADOR); 
05A4E:  MOVLB  3
05A50:  CLRF   xB0
05A52:  MOVLB  0
05A54:  CALL   3E1C
....................                 motor_run_x(0, 19); 
05A58:  MOVLB  3
05A5A:  CLRF   xB7
05A5C:  CLRF   xB6
05A5E:  CLRF   xB5
05A60:  CLRF   xB4
05A62:  MOVLW  13
05A64:  MOVWF  xB8
05A66:  MOVLB  0
05A68:  CALL   4ABC
....................                 while ((run_flg_x)); 
05A6C:  MOVLB  1
05A6E:  BTFSC  x1A.4
05A70:  BRA    5A6E
....................                 flip_home(); 
05A72:  MOVLB  0
05A74:  CALL   497A
....................                 motor_run_y(0, 19); 
05A78:  MOVLB  3
05A7A:  CLRF   xB7
05A7C:  CLRF   xB6
05A7E:  CLRF   xB5
05A80:  CLRF   xB4
05A82:  MOVLW  13
05A84:  MOVWF  xB8
05A86:  MOVLB  0
05A88:  RCALL  580C
....................                 while ((run_flg_y)); 
05A8A:  MOVLB  1
05A8C:  BTFSC  x1A.6
05A8E:  BRA    5A8C
....................                 motor_run_x(50, 19); 
05A90:  MOVLB  3
05A92:  CLRF   xB7
05A94:  CLRF   xB6
05A96:  CLRF   xB5
05A98:  MOVLW  32
05A9A:  MOVWF  xB4
05A9C:  MOVLW  13
05A9E:  MOVWF  xB8
05AA0:  MOVLB  0
05AA2:  CALL   4ABC
....................                 while ((run_flg_x)); 
05AA6:  MOVLB  1
05AA8:  BTFSC  x1A.4
05AAA:  BRA    5AA8
....................                 posicao_atual = ALIMENTADOR; 
05AAC:  CLRF   25
....................             } else { 
05AAE:  BRA    5ACA
05AB0:  MOVLB  0
....................                 delay_ms(300); 
05AB2:  MOVLW  02
05AB4:  MOVLB  3
05AB6:  MOVWF  xB0
05AB8:  MOVLW  96
05ABA:  MOVWF  xBE
05ABC:  MOVLB  0
05ABE:  CALL   206E
05AC2:  MOVLB  3
05AC4:  DECFSZ xB0,F
05AC6:  BRA    5AB8
05AC8:  MOVLB  1
....................             } 
....................         break; 
05ACA:  MOVLB  3
05ACC:  GOTO   639A
....................         case HOME1: 
....................             if(posicao_atual != HOME1){             
05AD0:  DECFSZ 25,W
05AD2:  BRA    5AD6
05AD4:  BRA    5DA0
....................                 while (posicao_atual == DISPENSADOR){ 
05AD6:  MOVF   25,W
05AD8:  SUBLW  05
05ADA:  BNZ   5AE0
....................                     tela_esperando_mov_maquina();                 
05ADC:  RCALL  579C
05ADE:  BRA    5AD6
....................                 } 
....................                 if (posicao_atual == SOLDAGEM){ 
05AE0:  MOVF   25,W
05AE2:  SUBLW  03
05AE4:  BNZ   5B58
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
05AE6:  CALL   3B1E
05AEA:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
05AEE:  MOVF   27,W
05AF0:  SUBLW  06
05AF2:  BZ    5AFA
05AF4:  MOVF   27,W
05AF6:  SUBLW  07
05AF8:  BNZ   5B06
....................                         tela_esperando_sair_posicao_outra_maquina(); 
05AFA:  RCALL  57CE
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
05AFC:  CALL   3B1E
05B00:  MOVFF  01,27
05B04:  BRA    5AEE
....................                     } 
....................                     tela_movimentando_maquina(HOME1); 
05B06:  MOVLW  01
05B08:  MOVLB  3
05B0A:  MOVWF  xB0
05B0C:  MOVLB  0
05B0E:  CALL   3E1C
....................                     motor_run_y(800, 19); 
05B12:  MOVLB  3
05B14:  CLRF   xB7
05B16:  CLRF   xB6
05B18:  MOVLW  03
05B1A:  MOVWF  xB5
05B1C:  MOVLW  20
05B1E:  MOVWF  xB4
05B20:  MOVLW  13
05B22:  MOVWF  xB8
05B24:  MOVLB  0
05B26:  RCALL  580C
....................                     while ((run_flg_y)); 
05B28:  MOVLB  1
05B2A:  BTFSC  x1A.6
05B2C:  BRA    5B2A
....................                     motor_run_x(4250, 19); 
05B2E:  MOVLB  3
05B30:  CLRF   xB7
05B32:  CLRF   xB6
05B34:  MOVLW  10
05B36:  MOVWF  xB5
05B38:  MOVLW  9A
05B3A:  MOVWF  xB4
05B3C:  MOVLW  13
05B3E:  MOVWF  xB8
05B40:  MOVLB  0
05B42:  CALL   4ABC
....................                     while ((run_flg_x)); 
05B46:  MOVLB  1
05B48:  BTFSC  x1A.4
05B4A:  BRA    5B48
....................                     envia_posicao_para_outra_maquina(HOME1);                    
05B4C:  MOVLW  01
05B4E:  MOVLB  3
05B50:  MOVWF  xB0
05B52:  MOVLB  0
05B54:  CALL   4C2E
....................                 } 
....................                 if (posicao_atual == HOME2){ 
05B58:  MOVF   25,W
05B5A:  SUBLW  04
05B5C:  BNZ   5BE6
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
05B5E:  MOVF   27,W
05B60:  SUBLW  06
05B62:  BZ    5B6A
05B64:  MOVF   27,W
05B66:  SUBLW  07
05B68:  BNZ   5B76
....................                         tela_esperando_sair_posicao_outra_maquina(); 
05B6A:  RCALL  57CE
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
05B6C:  CALL   3B1E
05B70:  MOVFF  01,27
05B74:  BRA    5B5E
....................                     } 
....................                     tela_movimentando_maquina(HOME1); 
05B76:  MOVLW  01
05B78:  MOVLB  3
05B7A:  MOVWF  xB0
05B7C:  MOVLB  0
05B7E:  CALL   3E1C
....................                     motor_run_x(3835, 19); 
05B82:  MOVLB  3
05B84:  CLRF   xB7
05B86:  CLRF   xB6
05B88:  MOVLW  0E
05B8A:  MOVWF  xB5
05B8C:  MOVLW  FB
05B8E:  MOVWF  xB4
05B90:  MOVLW  13
05B92:  MOVWF  xB8
05B94:  MOVLB  0
05B96:  CALL   4ABC
....................                     while ((run_flg_x)); 
05B9A:  MOVLB  1
05B9C:  BTFSC  x1A.4
05B9E:  BRA    5B9C
....................                     motor_run_y(800, 19); 
05BA0:  MOVLB  3
05BA2:  CLRF   xB7
05BA4:  CLRF   xB6
05BA6:  MOVLW  03
05BA8:  MOVWF  xB5
05BAA:  MOVLW  20
05BAC:  MOVWF  xB4
05BAE:  MOVLW  13
05BB0:  MOVWF  xB8
05BB2:  MOVLB  0
05BB4:  RCALL  580C
....................                     while ((run_flg_y)); 
05BB6:  MOVLB  1
05BB8:  BTFSC  x1A.6
05BBA:  BRA    5BB8
....................                     motor_run_x(4250, 19); 
05BBC:  MOVLB  3
05BBE:  CLRF   xB7
05BC0:  CLRF   xB6
05BC2:  MOVLW  10
05BC4:  MOVWF  xB5
05BC6:  MOVLW  9A
05BC8:  MOVWF  xB4
05BCA:  MOVLW  13
05BCC:  MOVWF  xB8
05BCE:  MOVLB  0
05BD0:  CALL   4ABC
....................                     while ((run_flg_x)); 
05BD4:  MOVLB  1
05BD6:  BTFSC  x1A.4
05BD8:  BRA    5BD6
....................                     envia_posicao_para_outra_maquina(HOME1);                    
05BDA:  MOVLW  01
05BDC:  MOVLB  3
05BDE:  MOVWF  xB0
05BE0:  MOVLB  0
05BE2:  CALL   4C2E
....................                 } 
....................                 if (posicao_atual == ALIMENTADOR){ 
05BE6:  MOVF   25,F
05BE8:  BNZ   5C62
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
05BEA:  MOVF   27,W
05BEC:  SUBLW  06
05BEE:  BZ    5BF6
05BF0:  MOVF   27,W
05BF2:  SUBLW  07
05BF4:  BNZ   5C02
....................                         tela_esperando_sair_posicao_outra_maquina(); 
05BF6:  RCALL  57CE
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
05BF8:  CALL   3B1E
05BFC:  MOVFF  01,27
05C00:  BRA    5BEA
....................                     } 
....................                     tela_movimentando_maquina(HOME1); 
05C02:  MOVLW  01
05C04:  MOVLB  3
05C06:  MOVWF  xB0
05C08:  MOVLB  0
05C0A:  CALL   3E1C
....................                     motor_run_y(800, 19); 
05C0E:  MOVLB  3
05C10:  CLRF   xB7
05C12:  CLRF   xB6
05C14:  MOVLW  03
05C16:  MOVWF  xB5
05C18:  MOVLW  20
05C1A:  MOVWF  xB4
05C1C:  MOVLW  13
05C1E:  MOVWF  xB8
05C20:  MOVLB  0
05C22:  RCALL  580C
....................                     while ((run_flg_y)); 
05C24:  MOVLB  1
05C26:  BTFSC  x1A.6
05C28:  BRA    5C26
....................                     go_flip(1866); 
05C2A:  MOVLW  07
05C2C:  MOVLB  3
05C2E:  MOVWF  xB1
05C30:  MOVLW  4A
05C32:  MOVWF  xB0
05C34:  MOVLB  0
05C36:  RCALL  5988
....................                     motor_run_x(4250, 19); 
05C38:  MOVLB  3
05C3A:  CLRF   xB7
05C3C:  CLRF   xB6
05C3E:  MOVLW  10
05C40:  MOVWF  xB5
05C42:  MOVLW  9A
05C44:  MOVWF  xB4
05C46:  MOVLW  13
05C48:  MOVWF  xB8
05C4A:  MOVLB  0
05C4C:  CALL   4ABC
....................                     while ((run_flg_x)); 
05C50:  MOVLB  1
05C52:  BTFSC  x1A.4
05C54:  BRA    5C52
....................                     envia_posicao_para_outra_maquina(HOME1);                    
05C56:  MOVLW  01
05C58:  MOVLB  3
05C5A:  MOVWF  xB0
05C5C:  MOVLB  0
05C5E:  CALL   4C2E
....................                 } 
....................                 if (posicao_atual == LIMPEZA){ 
05C62:  MOVF   25,W
05C64:  SUBLW  06
05C66:  BNZ   5CFE
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
05C68:  MOVF   27,W
05C6A:  SUBLW  06
05C6C:  BZ    5C74
05C6E:  MOVF   27,W
05C70:  SUBLW  07
05C72:  BNZ   5C80
....................                         tela_esperando_sair_posicao_outra_maquina(); 
05C74:  RCALL  57CE
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
05C76:  CALL   3B1E
05C7A:  MOVFF  01,27
05C7E:  BRA    5C68
....................                     } 
....................                     tela_movimentando_maquina(HOME1); 
05C80:  MOVLW  01
05C82:  MOVLB  3
05C84:  MOVWF  xB0
05C86:  MOVLB  0
05C88:  CALL   3E1C
....................                     motor_run_x(3825, 19); 
05C8C:  MOVLB  3
05C8E:  CLRF   xB7
05C90:  CLRF   xB6
05C92:  MOVLW  0E
05C94:  MOVWF  xB5
05C96:  MOVLW  F1
05C98:  MOVWF  xB4
05C9A:  MOVLW  13
05C9C:  MOVWF  xB8
05C9E:  MOVLB  0
05CA0:  CALL   4ABC
....................                     while ((run_flg_x)); 
05CA4:  MOVLB  1
05CA6:  BTFSC  x1A.4
05CA8:  BRA    5CA6
....................                     go_flip(1866); 
05CAA:  MOVLW  07
05CAC:  MOVLB  3
05CAE:  MOVWF  xB1
05CB0:  MOVLW  4A
05CB2:  MOVWF  xB0
05CB4:  MOVLB  0
05CB6:  RCALL  5988
....................                     motor_run_y(800, 19); 
05CB8:  MOVLB  3
05CBA:  CLRF   xB7
05CBC:  CLRF   xB6
05CBE:  MOVLW  03
05CC0:  MOVWF  xB5
05CC2:  MOVLW  20
05CC4:  MOVWF  xB4
05CC6:  MOVLW  13
05CC8:  MOVWF  xB8
05CCA:  MOVLB  0
05CCC:  RCALL  580C
....................                     while ((run_flg_y)); 
05CCE:  MOVLB  1
05CD0:  BTFSC  x1A.6
05CD2:  BRA    5CD0
....................                     motor_run_x(4250, 19); 
05CD4:  MOVLB  3
05CD6:  CLRF   xB7
05CD8:  CLRF   xB6
05CDA:  MOVLW  10
05CDC:  MOVWF  xB5
05CDE:  MOVLW  9A
05CE0:  MOVWF  xB4
05CE2:  MOVLW  13
05CE4:  MOVWF  xB8
05CE6:  MOVLB  0
05CE8:  CALL   4ABC
....................                     while ((run_flg_x)); 
05CEC:  MOVLB  1
05CEE:  BTFSC  x1A.4
05CF0:  BRA    5CEE
....................                     envia_posicao_para_outra_maquina(HOME1);                    
05CF2:  MOVLW  01
05CF4:  MOVLB  3
05CF6:  MOVWF  xB0
05CF8:  MOVLB  0
05CFA:  CALL   4C2E
....................                 } 
....................                 if (posicao_atual == LIMPEZA_2){ 
05CFE:  MOVF   25,W
05D00:  SUBLW  07
05D02:  BNZ   5D9A
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
05D04:  MOVF   27,W
05D06:  SUBLW  06
05D08:  BZ    5D10
05D0A:  MOVF   27,W
05D0C:  SUBLW  07
05D0E:  BNZ   5D1C
....................                         tela_esperando_sair_posicao_outra_maquina(); 
05D10:  RCALL  57CE
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
05D12:  CALL   3B1E
05D16:  MOVFF  01,27
05D1A:  BRA    5D04
....................                     } 
....................                     tela_movimentando_maquina(HOME1); 
05D1C:  MOVLW  01
05D1E:  MOVLB  3
05D20:  MOVWF  xB0
05D22:  MOVLB  0
05D24:  CALL   3E1C
....................                     motor_run_x(3825, 19); 
05D28:  MOVLB  3
05D2A:  CLRF   xB7
05D2C:  CLRF   xB6
05D2E:  MOVLW  0E
05D30:  MOVWF  xB5
05D32:  MOVLW  F1
05D34:  MOVWF  xB4
05D36:  MOVLW  13
05D38:  MOVWF  xB8
05D3A:  MOVLB  0
05D3C:  CALL   4ABC
....................                     while ((run_flg_x)); 
05D40:  MOVLB  1
05D42:  BTFSC  x1A.4
05D44:  BRA    5D42
....................                     go_flip(1866); 
05D46:  MOVLW  07
05D48:  MOVLB  3
05D4A:  MOVWF  xB1
05D4C:  MOVLW  4A
05D4E:  MOVWF  xB0
05D50:  MOVLB  0
05D52:  RCALL  5988
....................                     motor_run_y(800, 19); 
05D54:  MOVLB  3
05D56:  CLRF   xB7
05D58:  CLRF   xB6
05D5A:  MOVLW  03
05D5C:  MOVWF  xB5
05D5E:  MOVLW  20
05D60:  MOVWF  xB4
05D62:  MOVLW  13
05D64:  MOVWF  xB8
05D66:  MOVLB  0
05D68:  RCALL  580C
....................                     while ((run_flg_y)); 
05D6A:  MOVLB  1
05D6C:  BTFSC  x1A.6
05D6E:  BRA    5D6C
....................                     motor_run_x(4250, 19); 
05D70:  MOVLB  3
05D72:  CLRF   xB7
05D74:  CLRF   xB6
05D76:  MOVLW  10
05D78:  MOVWF  xB5
05D7A:  MOVLW  9A
05D7C:  MOVWF  xB4
05D7E:  MOVLW  13
05D80:  MOVWF  xB8
05D82:  MOVLB  0
05D84:  CALL   4ABC
....................                     while ((run_flg_x)); 
05D88:  MOVLB  1
05D8A:  BTFSC  x1A.4
05D8C:  BRA    5D8A
....................                     envia_posicao_para_outra_maquina(HOME1);                    
05D8E:  MOVLW  01
05D90:  MOVLB  3
05D92:  MOVWF  xB0
05D94:  MOVLB  0
05D96:  CALL   4C2E
....................                 } 
....................                 posicao_atual = HOME1; 
05D9A:  MOVLW  01
05D9C:  MOVWF  25
....................             }else { 
05D9E:  BRA    5DB8
....................                 delay_ms(300); 
05DA0:  MOVLW  02
05DA2:  MOVLB  3
05DA4:  MOVWF  xB0
05DA6:  MOVLW  96
05DA8:  MOVWF  xBE
05DAA:  MOVLB  0
05DAC:  CALL   206E
05DB0:  MOVLB  3
05DB2:  DECFSZ xB0,F
05DB4:  BRA    5DA6
05DB6:  MOVLB  0
....................             } 
....................         break; 
05DB8:  MOVLB  3
05DBA:  BRA    639A
....................         case SOLDAGEM: 
....................             if(posicao_atual != SOLDAGEM){ 
05DBC:  MOVF   25,W
05DBE:  SUBLW  03
05DC0:  BTFSC  FD8.2
05DC2:  BRA    5EF0
....................                 while ((posicao_atual == DISPENSADOR)||(posicao_atual == HOME2)){ 
05DC4:  MOVF   25,W
05DC6:  SUBLW  05
05DC8:  BZ    5DD0
05DCA:  MOVF   25,W
05DCC:  SUBLW  04
05DCE:  BNZ   5DD4
....................                     tela_esperando_mov_maquina();                 
05DD0:  RCALL  579C
05DD2:  BRA    5DC4
....................                 } 
....................                 if (posicao_atual == HOME1){ 
05DD4:  DECFSZ 25,W
05DD6:  BRA    5E4A
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
05DD8:  CALL   3B1E
05DDC:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
05DE0:  MOVF   27,W
05DE2:  SUBLW  06
05DE4:  BZ    5DEC
05DE6:  MOVF   27,W
05DE8:  SUBLW  07
05DEA:  BNZ   5DF8
....................                         tela_esperando_sair_posicao_outra_maquina(); 
05DEC:  RCALL  57CE
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
05DEE:  CALL   3B1E
05DF2:  MOVFF  01,27
05DF6:  BRA    5DE0
....................                     } 
....................                     tela_movimentando_maquina(SOLDAGEM); 
05DF8:  MOVLW  03
05DFA:  MOVLB  3
05DFC:  MOVWF  xB0
05DFE:  MOVLB  0
05E00:  CALL   3E1C
....................                     motor_run_x(3835, 19); 
05E04:  MOVLB  3
05E06:  CLRF   xB7
05E08:  CLRF   xB6
05E0A:  MOVLW  0E
05E0C:  MOVWF  xB5
05E0E:  MOVLW  FB
05E10:  MOVWF  xB4
05E12:  MOVLW  13
05E14:  MOVWF  xB8
05E16:  MOVLB  0
05E18:  CALL   4ABC
....................                     while ((run_flg_x)); 
05E1C:  MOVLB  1
05E1E:  BTFSC  x1A.4
05E20:  BRA    5E1E
....................                     motor_run_y(2540, 19); 
05E22:  MOVLB  3
05E24:  CLRF   xB7
05E26:  CLRF   xB6
05E28:  MOVLW  09
05E2A:  MOVWF  xB5
05E2C:  MOVLW  EC
05E2E:  MOVWF  xB4
05E30:  MOVLW  13
05E32:  MOVWF  xB8
05E34:  MOVLB  0
05E36:  RCALL  580C
....................                     while ((run_flg_y)); 
05E38:  MOVLB  1
05E3A:  BTFSC  x1A.6
05E3C:  BRA    5E3A
....................                     envia_posicao_para_outra_maquina(SOLDAGEM);                    
05E3E:  MOVLW  03
05E40:  MOVLB  3
05E42:  MOVWF  xB0
05E44:  MOVLB  0
05E46:  CALL   4C2E
....................                 } 
....................                 if (posicao_atual == ALIMENTADOR){ 
05E4A:  MOVF   25,F
05E4C:  BNZ   5EEA
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
05E4E:  CALL   3B1E
05E52:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
05E56:  MOVF   27,W
05E58:  SUBLW  06
05E5A:  BZ    5E62
05E5C:  MOVF   27,W
05E5E:  SUBLW  07
05E60:  BNZ   5E6E
....................                         tela_esperando_sair_posicao_outra_maquina(); 
05E62:  RCALL  57CE
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
05E64:  CALL   3B1E
05E68:  MOVFF  01,27
05E6C:  BRA    5E56
....................                     } 
....................                     tela_movimentando_maquina(SOLDAGEM); 
05E6E:  MOVLW  03
05E70:  MOVLB  3
05E72:  MOVWF  xB0
05E74:  MOVLB  0
05E76:  CALL   3E1C
....................                     motor_run_y(800, 19); 
05E7A:  MOVLB  3
05E7C:  CLRF   xB7
05E7E:  CLRF   xB6
05E80:  MOVLW  03
05E82:  MOVWF  xB5
05E84:  MOVLW  20
05E86:  MOVWF  xB4
05E88:  MOVLW  13
05E8A:  MOVWF  xB8
05E8C:  MOVLB  0
05E8E:  RCALL  580C
....................                     while ((run_flg_y)); 
05E90:  MOVLB  1
05E92:  BTFSC  x1A.6
05E94:  BRA    5E92
....................                     go_flip(1866); 
05E96:  MOVLW  07
05E98:  MOVLB  3
05E9A:  MOVWF  xB1
05E9C:  MOVLW  4A
05E9E:  MOVWF  xB0
05EA0:  MOVLB  0
05EA2:  RCALL  5988
....................                     motor_run_x(3835, 19); 
05EA4:  MOVLB  3
05EA6:  CLRF   xB7
05EA8:  CLRF   xB6
05EAA:  MOVLW  0E
05EAC:  MOVWF  xB5
05EAE:  MOVLW  FB
05EB0:  MOVWF  xB4
05EB2:  MOVLW  13
05EB4:  MOVWF  xB8
05EB6:  MOVLB  0
05EB8:  CALL   4ABC
....................                     while ((run_flg_x)); 
05EBC:  MOVLB  1
05EBE:  BTFSC  x1A.4
05EC0:  BRA    5EBE
....................                     motor_run_y(2540, 19); 
05EC2:  MOVLB  3
05EC4:  CLRF   xB7
05EC6:  CLRF   xB6
05EC8:  MOVLW  09
05ECA:  MOVWF  xB5
05ECC:  MOVLW  EC
05ECE:  MOVWF  xB4
05ED0:  MOVLW  13
05ED2:  MOVWF  xB8
05ED4:  MOVLB  0
05ED6:  RCALL  580C
....................                     while ((run_flg_y)); 
05ED8:  MOVLB  1
05EDA:  BTFSC  x1A.6
05EDC:  BRA    5EDA
....................                     envia_posicao_para_outra_maquina(SOLDAGEM);                    
05EDE:  MOVLW  03
05EE0:  MOVLB  3
05EE2:  MOVWF  xB0
05EE4:  MOVLB  0
05EE6:  CALL   4C2E
....................                 } 
....................                 posicao_atual = SOLDAGEM; 
05EEA:  MOVLW  03
05EEC:  MOVWF  25
....................             } else { 
05EEE:  BRA    5F08
....................                 delay_ms(300); 
05EF0:  MOVLW  02
05EF2:  MOVLB  3
05EF4:  MOVWF  xB0
05EF6:  MOVLW  96
05EF8:  MOVWF  xBE
05EFA:  MOVLB  0
05EFC:  CALL   206E
05F00:  MOVLB  3
05F02:  DECFSZ xB0,F
05F04:  BRA    5EF6
05F06:  MOVLB  0
....................             } 
....................         break; 
05F08:  MOVLB  3
05F0A:  BRA    639A
....................         case HOME2: 
....................             if(posicao_atual != HOME2){ 
05F0C:  MOVF   25,W
05F0E:  SUBLW  04
05F10:  BTFSC  FD8.2
05F12:  BRA    60A6
....................                 while ((posicao_atual == ALIMENTADOR)||(posicao_atual == LIMPEZA)||(posicao_atual == LIMPEZA_2)){ 
05F14:  MOVF   25,F
05F16:  BZ    5F24
05F18:  MOVF   25,W
05F1A:  SUBLW  06
05F1C:  BZ    5F24
05F1E:  MOVF   25,W
05F20:  SUBLW  07
05F22:  BNZ   5F28
....................                     tela_esperando_mov_maquina();                 
05F24:  RCALL  579C
05F26:  BRA    5F14
....................                 } 
....................                 if (posicao_atual == DISPENSADOR){ 
05F28:  MOVF   25,W
05F2A:  SUBLW  05
05F2C:  BNZ   5FA0
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
05F2E:  CALL   3B1E
05F32:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
05F36:  MOVF   27,W
05F38:  SUBLW  06
05F3A:  BZ    5F42
05F3C:  MOVF   27,W
05F3E:  SUBLW  07
05F40:  BNZ   5F4E
....................                         tela_esperando_sair_posicao_outra_maquina(); 
05F42:  RCALL  57CE
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
05F44:  CALL   3B1E
05F48:  MOVFF  01,27
05F4C:  BRA    5F36
....................                     } 
....................                     tela_movimentando_maquina(HOME2); 
05F4E:  MOVLW  04
05F50:  MOVLB  3
05F52:  MOVWF  xB0
05F54:  MOVLB  0
05F56:  CALL   3E1C
....................                     motor_run_y(5500, 19); 
05F5A:  MOVLB  3
05F5C:  CLRF   xB7
05F5E:  CLRF   xB6
05F60:  MOVLW  15
05F62:  MOVWF  xB5
05F64:  MOVLW  7C
05F66:  MOVWF  xB4
05F68:  MOVLW  13
05F6A:  MOVWF  xB8
05F6C:  MOVLB  0
05F6E:  RCALL  580C
....................                     while ((run_flg_y)); 
05F70:  MOVLB  1
05F72:  BTFSC  x1A.6
05F74:  BRA    5F72
....................                     motor_run_x(4250, 19); 
05F76:  MOVLB  3
05F78:  CLRF   xB7
05F7A:  CLRF   xB6
05F7C:  MOVLW  10
05F7E:  MOVWF  xB5
05F80:  MOVLW  9A
05F82:  MOVWF  xB4
05F84:  MOVLW  13
05F86:  MOVWF  xB8
05F88:  MOVLB  0
05F8A:  CALL   4ABC
....................                     while ((run_flg_x)); 
05F8E:  MOVLB  1
05F90:  BTFSC  x1A.4
05F92:  BRA    5F90
....................                     envia_posicao_para_outra_maquina(HOME2);                    
05F94:  MOVLW  04
05F96:  MOVLB  3
05F98:  MOVWF  xB0
05F9A:  MOVLB  0
05F9C:  CALL   4C2E
....................                 } 
....................                 if (posicao_atual == SOLDAGEM){ 
05FA0:  MOVF   25,W
05FA2:  SUBLW  03
05FA4:  BNZ   6010
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
05FA6:  MOVF   27,W
05FA8:  SUBLW  06
05FAA:  BZ    5FB2
05FAC:  MOVF   27,W
05FAE:  SUBLW  07
05FB0:  BNZ   5FBE
....................                         tela_esperando_sair_posicao_outra_maquina(); 
05FB2:  RCALL  57CE
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
05FB4:  CALL   3B1E
05FB8:  MOVFF  01,27
05FBC:  BRA    5FA6
....................                     } 
....................                     tela_movimentando_maquina(HOME2); 
05FBE:  MOVLW  04
05FC0:  MOVLB  3
05FC2:  MOVWF  xB0
05FC4:  MOVLB  0
05FC6:  CALL   3E1C
....................                     motor_run_y(5500, 19); 
05FCA:  MOVLB  3
05FCC:  CLRF   xB7
05FCE:  CLRF   xB6
05FD0:  MOVLW  15
05FD2:  MOVWF  xB5
05FD4:  MOVLW  7C
05FD6:  MOVWF  xB4
05FD8:  MOVLW  13
05FDA:  MOVWF  xB8
05FDC:  MOVLB  0
05FDE:  RCALL  580C
....................                     while ((run_flg_y)); 
05FE0:  MOVLB  1
05FE2:  BTFSC  x1A.6
05FE4:  BRA    5FE2
....................                     motor_run_x(4250, 19); 
05FE6:  MOVLB  3
05FE8:  CLRF   xB7
05FEA:  CLRF   xB6
05FEC:  MOVLW  10
05FEE:  MOVWF  xB5
05FF0:  MOVLW  9A
05FF2:  MOVWF  xB4
05FF4:  MOVLW  13
05FF6:  MOVWF  xB8
05FF8:  MOVLB  0
05FFA:  CALL   4ABC
....................                     while ((run_flg_x)); 
05FFE:  MOVLB  1
06000:  BTFSC  x1A.4
06002:  BRA    6000
....................                     envia_posicao_para_outra_maquina(HOME2);                    
06004:  MOVLW  04
06006:  MOVLB  3
06008:  MOVWF  xB0
0600A:  MOVLB  0
0600C:  CALL   4C2E
....................                 } 
....................                 if (posicao_atual == HOME1){ 
06010:  DECFSZ 25,W
06012:  BRA    60A0
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)){ 
06014:  MOVF   27,W
06016:  SUBLW  06
06018:  BZ    6020
0601A:  MOVF   27,W
0601C:  SUBLW  07
0601E:  BNZ   602E
....................                         tela_esperando_sair_posicao_outra_maquina(); 
06020:  CALL   57CE
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
06024:  CALL   3B1E
06028:  MOVFF  01,27
0602C:  BRA    6014
....................                     } 
....................                     tela_movimentando_maquina(HOME2); 
0602E:  MOVLW  04
06030:  MOVLB  3
06032:  MOVWF  xB0
06034:  MOVLB  0
06036:  CALL   3E1C
....................                     motor_run_x(3835, 19); 
0603A:  MOVLB  3
0603C:  CLRF   xB7
0603E:  CLRF   xB6
06040:  MOVLW  0E
06042:  MOVWF  xB5
06044:  MOVLW  FB
06046:  MOVWF  xB4
06048:  MOVLW  13
0604A:  MOVWF  xB8
0604C:  MOVLB  0
0604E:  CALL   4ABC
....................                     while ((run_flg_x)); 
06052:  MOVLB  1
06054:  BTFSC  x1A.4
06056:  BRA    6054
....................                     motor_run_y(5500, 19); 
06058:  MOVLB  3
0605A:  CLRF   xB7
0605C:  CLRF   xB6
0605E:  MOVLW  15
06060:  MOVWF  xB5
06062:  MOVLW  7C
06064:  MOVWF  xB4
06066:  MOVLW  13
06068:  MOVWF  xB8
0606A:  MOVLB  0
0606C:  CALL   580C
....................                     while ((run_flg_y)); 
06070:  MOVLB  1
06072:  BTFSC  x1A.6
06074:  BRA    6072
....................                     motor_run_x(4250, 19); 
06076:  MOVLB  3
06078:  CLRF   xB7
0607A:  CLRF   xB6
0607C:  MOVLW  10
0607E:  MOVWF  xB5
06080:  MOVLW  9A
06082:  MOVWF  xB4
06084:  MOVLW  13
06086:  MOVWF  xB8
06088:  MOVLB  0
0608A:  CALL   4ABC
....................                     while ((run_flg_x)); 
0608E:  MOVLB  1
06090:  BTFSC  x1A.4
06092:  BRA    6090
....................                     envia_posicao_para_outra_maquina(HOME2);                    
06094:  MOVLW  04
06096:  MOVLB  3
06098:  MOVWF  xB0
0609A:  MOVLB  0
0609C:  CALL   4C2E
....................                 } 
....................                 posicao_atual = HOME2; 
060A0:  MOVLW  04
060A2:  MOVWF  25
....................             }else { 
060A4:  BRA    60BE
....................                 delay_ms(300); 
060A6:  MOVLW  02
060A8:  MOVLB  3
060AA:  MOVWF  xB0
060AC:  MOVLW  96
060AE:  MOVWF  xBE
060B0:  MOVLB  0
060B2:  CALL   206E
060B6:  MOVLB  3
060B8:  DECFSZ xB0,F
060BA:  BRA    60AC
060BC:  MOVLB  0
....................             } 
....................         break; 
060BE:  MOVLB  3
060C0:  BRA    639A
....................         case DISPENSADOR: 
....................             if(posicao_atual != DISPENSADOR){ 
060C2:  MOVF   25,W
060C4:  SUBLW  05
060C6:  BZ    616C
....................                 while (posicao_atual != HOME2){ 
060C8:  MOVF   25,W
060CA:  SUBLW  04
060CC:  BZ    60D4
....................                     tela_esperando_mov_maquina();                 
060CE:  CALL   579C
060D2:  BRA    60C8
....................                 } 
....................                 envia_posicao_para_outra_maquina(DISPENSADOR); 
060D4:  MOVLW  05
060D6:  MOVLB  3
060D8:  MOVWF  xB0
060DA:  MOVLB  0
060DC:  CALL   4C2E
....................                 if (posicao_atual == HOME2){    
060E0:  MOVF   25,W
060E2:  SUBLW  04
060E4:  BNZ   6166
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
060E6:  CALL   3B1E
060EA:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)||(posicao_outra_maquina == DISPENSADOR)||(posicao_atual == SOLDAGEM)){ 
060EE:  MOVF   27,W
060F0:  SUBLW  06
060F2:  BZ    6106
060F4:  MOVF   27,W
060F6:  SUBLW  07
060F8:  BZ    6106
060FA:  MOVF   27,W
060FC:  SUBLW  05
060FE:  BZ    6106
06100:  MOVF   25,W
06102:  SUBLW  03
06104:  BNZ   6114
....................                         tela_esperando_sair_posicao_outra_maquina(); 
06106:  CALL   57CE
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
0610A:  CALL   3B1E
0610E:  MOVFF  01,27
06112:  BRA    60EE
....................                     } 
....................                     tela_movimentando_maquina(DISPENSADOR); 
06114:  MOVLW  05
06116:  MOVLB  3
06118:  MOVWF  xB0
0611A:  MOVLB  0
0611C:  CALL   3E1C
....................                     envia_posicao_para_outra_maquina(DISPENSADOR); 
06120:  MOVLW  05
06122:  MOVLB  3
06124:  MOVWF  xB0
06126:  MOVLB  0
06128:  CALL   4C2E
....................                     motor_run_x(0, 19); 
0612C:  MOVLB  3
0612E:  CLRF   xB7
06130:  CLRF   xB6
06132:  CLRF   xB5
06134:  CLRF   xB4
06136:  MOVLW  13
06138:  MOVWF  xB8
0613A:  MOVLB  0
0613C:  CALL   4ABC
....................                     while ((run_flg_x)); 
06140:  MOVLB  1
06142:  BTFSC  x1A.4
06144:  BRA    6142
....................                     motor_run_y(6110, 19); 
06146:  MOVLB  3
06148:  CLRF   xB7
0614A:  CLRF   xB6
0614C:  MOVLW  17
0614E:  MOVWF  xB5
06150:  MOVLW  DE
06152:  MOVWF  xB4
06154:  MOVLW  13
06156:  MOVWF  xB8
06158:  MOVLB  0
0615A:  CALL   580C
....................                     while ((run_flg_y));                    
0615E:  MOVLB  1
06160:  BTFSC  x1A.6
06162:  BRA    6160
06164:  MOVLB  0
....................                 } 
....................                 posicao_atual = DISPENSADOR; 
06166:  MOVLW  05
06168:  MOVWF  25
....................             }else { 
0616A:  BRA    6184
....................                 delay_ms(300); 
0616C:  MOVLW  02
0616E:  MOVLB  3
06170:  MOVWF  xB0
06172:  MOVLW  96
06174:  MOVWF  xBE
06176:  MOVLB  0
06178:  CALL   206E
0617C:  MOVLB  3
0617E:  DECFSZ xB0,F
06180:  BRA    6172
06182:  MOVLB  0
....................             } 
....................         break; 
06184:  MOVLB  3
06186:  BRA    639A
....................         case LIMPEZA: 
....................             if(posicao_atual != LIMPEZA){ 
06188:  MOVF   25,W
0618A:  SUBLW  06
0618C:  BTFSC  FD8.2
0618E:  BRA    62DC
....................                 while ((posicao_atual == DISPENSADOR)||(posicao_atual == SOLDAGEM)||(posicao_atual == HOME1)||(posicao_atual == ALIMENTADOR)){ 
06190:  MOVF   25,W
06192:  SUBLW  05
06194:  BZ    61A6
06196:  MOVF   25,W
06198:  SUBLW  03
0619A:  BZ    61A6
0619C:  DECFSZ 25,W
0619E:  BRA    61A2
061A0:  BRA    61A6
061A2:  MOVF   25,F
061A4:  BNZ   61AC
....................                     tela_esperando_mov_maquina();                 
061A6:  CALL   579C
061AA:  BRA    6190
....................                 } 
....................                 if (posicao_atual == HOME2){ 
061AC:  MOVF   25,W
061AE:  SUBLW  04
061B0:  BNZ   6268
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
061B2:  CALL   3B1E
061B6:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == ALIMENTADOR)||(posicao_outra_maquina == DISPENSADOR)||(posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)||(posicao_outra_maquina == SOLDAGEM)){ 
061BA:  MOVF   27,F
061BC:  BZ    61D6
061BE:  MOVF   27,W
061C0:  SUBLW  05
061C2:  BZ    61D6
061C4:  MOVF   27,W
061C6:  SUBLW  06
061C8:  BZ    61D6
061CA:  MOVF   27,W
061CC:  SUBLW  07
061CE:  BZ    61D6
061D0:  MOVF   27,W
061D2:  SUBLW  03
061D4:  BNZ   61E4
....................                         tela_esperando_sair_posicao_outra_maquina(); 
061D6:  CALL   57CE
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
061DA:  CALL   3B1E
061DE:  MOVFF  01,27
061E2:  BRA    61BA
....................                     } 
....................                     envia_posicao_para_outra_maquina(LIMPEZA);  
061E4:  MOVLW  06
061E6:  MOVLB  3
061E8:  MOVWF  xB0
061EA:  MOVLB  0
061EC:  CALL   4C2E
....................                     tela_movimentando_maquina(LIMPEZA); 
061F0:  MOVLW  06
061F2:  MOVLB  3
061F4:  MOVWF  xB0
061F6:  MOVLB  0
061F8:  CALL   3E1C
....................                     motor_run_x(3835, 19); 
061FC:  MOVLB  3
061FE:  CLRF   xB7
06200:  CLRF   xB6
06202:  MOVLW  0E
06204:  MOVWF  xB5
06206:  MOVLW  FB
06208:  MOVWF  xB4
0620A:  MOVLW  13
0620C:  MOVWF  xB8
0620E:  MOVLB  0
06210:  CALL   4ABC
....................                     while ((run_flg_x)); 
06214:  MOVLB  1
06216:  BTFSC  x1A.4
06218:  BRA    6216
....................                     motor_run_y(2920, 19); 
0621A:  MOVLB  3
0621C:  CLRF   xB7
0621E:  CLRF   xB6
06220:  MOVLW  0B
06222:  MOVWF  xB5
06224:  MOVLW  68
06226:  MOVWF  xB4
06228:  MOVLW  13
0622A:  MOVWF  xB8
0622C:  MOVLB  0
0622E:  CALL   580C
....................                     while ((run_flg_y)); 
06232:  MOVLB  1
06234:  BTFSC  x1A.6
06236:  BRA    6234
....................                     go_flip(2000); 
06238:  MOVLW  07
0623A:  MOVLB  3
0623C:  MOVWF  xB1
0623E:  MOVLW  D0
06240:  MOVWF  xB0
06242:  MOVLB  0
06244:  CALL   5988
....................                     motor_run_x(1540, 19); 
06248:  MOVLB  3
0624A:  CLRF   xB7
0624C:  CLRF   xB6
0624E:  MOVLW  06
06250:  MOVWF  xB5
06252:  MOVLW  04
06254:  MOVWF  xB4
06256:  MOVLW  13
06258:  MOVWF  xB8
0625A:  MOVLB  0
0625C:  CALL   4ABC
....................                     while ((run_flg_x)); 
06260:  MOVLB  1
06262:  BTFSC  x1A.4
06264:  BRA    6262
06266:  MOVLB  0
....................                 } 
....................                 if (posicao_atual == LIMPEZA_2){ 
06268:  MOVF   25,W
0626A:  SUBLW  07
0626C:  BNZ   62D6
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
0626E:  CALL   3B1E
06272:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == ALIMENTADOR)||(posicao_outra_maquina == DISPENSADOR)||(posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)||(posicao_outra_maquina == SOLDAGEM)){ 
06276:  MOVF   27,F
06278:  BZ    6292
0627A:  MOVF   27,W
0627C:  SUBLW  05
0627E:  BZ    6292
06280:  MOVF   27,W
06282:  SUBLW  06
06284:  BZ    6292
06286:  MOVF   27,W
06288:  SUBLW  07
0628A:  BZ    6292
0628C:  MOVF   27,W
0628E:  SUBLW  03
06290:  BNZ   62A0
....................                         tela_esperando_sair_posicao_outra_maquina(); 
06292:  CALL   57CE
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
06296:  CALL   3B1E
0629A:  MOVFF  01,27
0629E:  BRA    6276
....................                          
....................                     } 
....................                     tela_movimentando_maquina(LIMPEZA); 
062A0:  MOVLW  06
062A2:  MOVLB  3
062A4:  MOVWF  xB0
062A6:  MOVLB  0
062A8:  CALL   3E1C
....................                     motor_run_x(1540, 19); 
062AC:  MOVLB  3
062AE:  CLRF   xB7
062B0:  CLRF   xB6
062B2:  MOVLW  06
062B4:  MOVWF  xB5
062B6:  MOVLW  04
062B8:  MOVWF  xB4
062BA:  MOVLW  13
062BC:  MOVWF  xB8
062BE:  MOVLB  0
062C0:  CALL   4ABC
....................                     while ((run_flg_x)); 
062C4:  MOVLB  1
062C6:  BTFSC  x1A.4
062C8:  BRA    62C6
....................                     envia_posicao_para_outra_maquina(LIMPEZA); 
062CA:  MOVLW  06
062CC:  MOVLB  3
062CE:  MOVWF  xB0
062D0:  MOVLB  0
062D2:  CALL   4C2E
....................                 } 
....................                 posicao_atual = LIMPEZA; 
062D6:  MOVLW  06
062D8:  MOVWF  25
....................             }else { 
062DA:  BRA    62F4
....................                 delay_ms(300); 
062DC:  MOVLW  02
062DE:  MOVLB  3
062E0:  MOVWF  xB0
062E2:  MOVLW  96
062E4:  MOVWF  xBE
062E6:  MOVLB  0
062E8:  CALL   206E
062EC:  MOVLB  3
062EE:  DECFSZ xB0,F
062F0:  BRA    62E2
062F2:  MOVLB  0
....................             } 
....................         break; 
062F4:  MOVLB  3
062F6:  BRA    639A
....................         case LIMPEZA_2: 
....................             if(posicao_atual != LIMPEZA_2){ 
062F8:  MOVF   25,W
062FA:  SUBLW  07
062FC:  BZ    637C
....................                 while (posicao_atual != LIMPEZA){ 
062FE:  MOVF   25,W
06300:  SUBLW  06
06302:  BZ    630A
....................                     tela_esperando_mov_maquina();                 
06304:  CALL   579C
06308:  BRA    62FE
....................                 } 
....................                 if (posicao_atual == LIMPEZA){ 
0630A:  MOVF   25,W
0630C:  SUBLW  06
0630E:  BNZ   6376
....................                     posicao_outra_maquina = le_posicao_outra_maquina(); 
06310:  CALL   3B1E
06314:  MOVFF  01,27
....................                     while ((posicao_outra_maquina == ALIMENTADOR)||(posicao_outra_maquina == DISPENSADOR)||(posicao_outra_maquina == LIMPEZA)||(posicao_outra_maquina == LIMPEZA_2)||(posicao_outra_maquina == SOLDAGEM)){ 
06318:  MOVF   27,F
0631A:  BZ    6334
0631C:  MOVF   27,W
0631E:  SUBLW  05
06320:  BZ    6334
06322:  MOVF   27,W
06324:  SUBLW  06
06326:  BZ    6334
06328:  MOVF   27,W
0632A:  SUBLW  07
0632C:  BZ    6334
0632E:  MOVF   27,W
06330:  SUBLW  03
06332:  BNZ   6342
....................                         tela_esperando_sair_posicao_outra_maquina(); 
06334:  CALL   57CE
....................                         posicao_outra_maquina = le_posicao_outra_maquina(); 
06338:  CALL   3B1E
0633C:  MOVFF  01,27
06340:  BRA    6318
....................                     } 
....................                     tela_movimentando_maquina(LIMPEZA_2); 
06342:  MOVLW  07
06344:  MOVLB  3
06346:  MOVWF  xB0
06348:  MOVLB  0
0634A:  CALL   3E1C
....................                     motor_run_x(50, 19); 
0634E:  MOVLB  3
06350:  CLRF   xB7
06352:  CLRF   xB6
06354:  CLRF   xB5
06356:  MOVLW  32
06358:  MOVWF  xB4
0635A:  MOVLW  13
0635C:  MOVWF  xB8
0635E:  MOVLB  0
06360:  CALL   4ABC
....................                     while ((run_flg_x));    
06364:  MOVLB  1
06366:  BTFSC  x1A.4
06368:  BRA    6366
....................                     envia_posicao_para_outra_maquina(LIMPEZA_2);   
0636A:  MOVLW  07
0636C:  MOVLB  3
0636E:  MOVWF  xB0
06370:  MOVLB  0
06372:  CALL   4C2E
....................                 } 
....................                 posicao_atual = LIMPEZA_2; 
06376:  MOVLW  07
06378:  MOVWF  25
....................             }else { 
0637A:  BRA    6394
....................                 delay_ms(300); 
0637C:  MOVLW  02
0637E:  MOVLB  3
06380:  MOVWF  xB0
06382:  MOVLW  96
06384:  MOVWF  xBE
06386:  MOVLB  0
06388:  CALL   206E
0638C:  MOVLB  3
0638E:  DECFSZ xB0,F
06390:  BRA    6382
06392:  MOVLB  0
....................             } 
....................         break;         
06394:  MOVLB  3
06396:  BRA    639A
06398:  MOVLB  3
....................     } 
0639A:  MOVLB  0
0639C:  RETURN 0
.................... } 
....................  
.................... #include "maquinas_maq_1.c" 
.................... void liga_pressor (void){ 
....................     aciona_saida(PRESSOR); 
*
0651E:  MOVLB  3
06520:  CLRF   xB8
06522:  MOVLW  04
06524:  MOVWF  xB7
06526:  MOVLB  0
06528:  CALL   252C
0652C:  RETURN 0
.................... } 
.................... void desliga_pressor (void){ 
....................     desaciona_saida(PRESSOR); 
*
06AB0:  MOVLB  3
06AB2:  CLRF   xB8
06AB4:  MOVLW  04
06AB6:  MOVWF  xB7
06AB8:  MOVLB  0
06ABA:  CALL   24EA
06ABE:  RETURN 0
.................... } 
.................... void empurra_placa(void){ 
....................     aciona_saida(DEDO_ENTRADA); 
*
095FA:  MOVLB  3
095FC:  CLRF   xB8
095FE:  MOVLW  07
09600:  MOVWF  xB7
09602:  MOVLB  0
09604:  CALL   252C
....................     aciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
09608:  MOVLB  3
0960A:  CLRF   xB8
0960C:  MOVLW  06
0960E:  MOVWF  xB7
09610:  MOVLB  0
09612:  CALL   252C
....................     delay_ms(2500); 
09616:  MOVLW  0A
09618:  MOVLB  3
0961A:  MOVWF  xAF
0961C:  MOVLW  FA
0961E:  MOVWF  xBE
09620:  MOVLB  0
09622:  CALL   206E
09626:  MOVLB  3
09628:  DECFSZ xAF,F
0962A:  BRA    961C
....................     desaciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
0962C:  CLRF   xB8
0962E:  MOVLW  06
09630:  MOVWF  xB7
09632:  MOVLB  0
09634:  CALL   24EA
....................     aciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
09638:  MOVLB  3
0963A:  CLRF   xB8
0963C:  MOVLW  05
0963E:  MOVWF  xB7
09640:  MOVLB  0
09642:  CALL   252C
....................     delay_ms(2500); 
09646:  MOVLW  0A
09648:  MOVLB  3
0964A:  MOVWF  xAF
0964C:  MOVLW  FA
0964E:  MOVWF  xBE
09650:  MOVLB  0
09652:  CALL   206E
09656:  MOVLB  3
09658:  DECFSZ xAF,F
0965A:  BRA    964C
....................     desaciona_saida(DEDO_ENTRADA); 
0965C:  CLRF   xB8
0965E:  MOVLW  07
09660:  MOVWF  xB7
09662:  MOVLB  0
09664:  CALL   24EA
....................     desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
09668:  MOVLB  3
0966A:  CLRF   xB8
0966C:  MOVLW  05
0966E:  MOVWF  xB7
09670:  MOVLB  0
09672:  CALL   24EA
09676:  GOTO   A3F6 (RETURN)
.................... } 
.................... void dispensa_placa(void){ 
....................     aciona_saida(DEDO_SAIDA); 
*
0A28A:  MOVLB  3
0A28C:  CLRF   xB8
0A28E:  MOVLW  01
0A290:  MOVWF  xB7
0A292:  MOVLB  0
0A294:  CALL   252C
....................     aciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
0A298:  MOVLB  3
0A29A:  CLRF   xB8
0A29C:  CLRF   xB7
0A29E:  MOVLB  0
0A2A0:  CALL   252C
....................     delay_ms(2500); 
0A2A4:  MOVLW  0A
0A2A6:  MOVLB  3
0A2A8:  MOVWF  xAF
0A2AA:  MOVLW  FA
0A2AC:  MOVWF  xBE
0A2AE:  MOVLB  0
0A2B0:  CALL   206E
0A2B4:  MOVLB  3
0A2B6:  DECFSZ xAF,F
0A2B8:  BRA    A2AA
....................     desaciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
0A2BA:  CLRF   xB8
0A2BC:  CLRF   xB7
0A2BE:  MOVLB  0
0A2C0:  CALL   24EA
....................     aciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
0A2C4:  MOVLB  3
0A2C6:  CLRF   xB8
0A2C8:  MOVLW  0F
0A2CA:  MOVWF  xB7
0A2CC:  MOVLB  0
0A2CE:  CALL   252C
....................     delay_ms(2500); 
0A2D2:  MOVLW  0A
0A2D4:  MOVLB  3
0A2D6:  MOVWF  xAF
0A2D8:  MOVLW  FA
0A2DA:  MOVWF  xBE
0A2DC:  MOVLB  0
0A2DE:  CALL   206E
0A2E2:  MOVLB  3
0A2E4:  DECFSZ xAF,F
0A2E6:  BRA    A2D8
....................     desaciona_saida(DEDO_SAIDA); 
0A2E8:  CLRF   xB8
0A2EA:  MOVLW  01
0A2EC:  MOVWF  xB7
0A2EE:  MOVLB  0
0A2F0:  CALL   24EA
....................     desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
0A2F4:  MOVLB  3
0A2F6:  CLRF   xB8
0A2F8:  MOVLW  0F
0A2FA:  MOVWF  xB7
0A2FC:  MOVLB  0
0A2FE:  CALL   24EA
0A302:  GOTO   A542 (RETURN)
.................... } 
.................... void ligar_alimentador_solda(int quantidade, long int tempo){ 
....................     if (quantidade == 2){ 
*
07088:  MOVLB  3
0708A:  MOVF   xB4,W
0708C:  SUBLW  02
0708E:  BNZ   70EC
....................         aciona_saida(ALIMENTADOR2); 
07090:  CLRF   xB8
07092:  MOVLW  0D
07094:  MOVWF  xB7
07096:  MOVLB  0
07098:  CALL   252C
....................         aciona_saida(ALIMENTADOR3); 
0709C:  MOVLB  3
0709E:  CLRF   xB8
070A0:  MOVLW  0C
070A2:  MOVWF  xB7
070A4:  MOVLB  0
070A6:  CALL   252C
....................         delay_ms(tempo); 
070AA:  MOVFF  3B6,3B7
070AE:  MOVLB  3
070B0:  INCF   xB7,F
070B2:  DECF   xB7,F
070B4:  BTFSC  FD8.2
070B6:  BRA    70C4
070B8:  SETF   xBE
070BA:  MOVLB  0
070BC:  CALL   206E
070C0:  MOVLB  3
070C2:  BRA    70B2
070C4:  MOVFF  3B5,3BE
070C8:  MOVLB  0
070CA:  CALL   206E
....................         desaciona_saida(ALIMENTADOR2); 
070CE:  MOVLB  3
070D0:  CLRF   xB8
070D2:  MOVLW  0D
070D4:  MOVWF  xB7
070D6:  MOVLB  0
070D8:  CALL   24EA
....................         desaciona_saida(ALIMENTADOR3); 
070DC:  MOVLB  3
070DE:  CLRF   xB8
070E0:  MOVLW  0C
070E2:  MOVWF  xB7
070E4:  MOVLB  0
070E6:  CALL   24EA
070EA:  MOVLB  3
....................     } 
....................     if (quantidade == 3){ 
070EC:  MOVF   xB4,W
070EE:  SUBLW  03
070F0:  BNZ   716A
....................         aciona_saida(ALIMENTADOR1); 
070F2:  CLRF   xB8
070F4:  MOVLW  0E
070F6:  MOVWF  xB7
070F8:  MOVLB  0
070FA:  CALL   252C
....................         aciona_saida(ALIMENTADOR2); 
070FE:  MOVLB  3
07100:  CLRF   xB8
07102:  MOVLW  0D
07104:  MOVWF  xB7
07106:  MOVLB  0
07108:  CALL   252C
....................         aciona_saida(ALIMENTADOR3); 
0710C:  MOVLB  3
0710E:  CLRF   xB8
07110:  MOVLW  0C
07112:  MOVWF  xB7
07114:  MOVLB  0
07116:  CALL   252C
....................         delay_ms(tempo); 
0711A:  MOVFF  3B6,3B7
0711E:  MOVLB  3
07120:  INCF   xB7,F
07122:  DECF   xB7,F
07124:  BTFSC  FD8.2
07126:  BRA    7134
07128:  SETF   xBE
0712A:  MOVLB  0
0712C:  CALL   206E
07130:  MOVLB  3
07132:  BRA    7122
07134:  MOVFF  3B5,3BE
07138:  MOVLB  0
0713A:  CALL   206E
....................         desaciona_saida(ALIMENTADOR1); 
0713E:  MOVLB  3
07140:  CLRF   xB8
07142:  MOVLW  0E
07144:  MOVWF  xB7
07146:  MOVLB  0
07148:  CALL   24EA
....................         desaciona_saida(ALIMENTADOR2); 
0714C:  MOVLB  3
0714E:  CLRF   xB8
07150:  MOVLW  0D
07152:  MOVWF  xB7
07154:  MOVLB  0
07156:  CALL   24EA
....................         desaciona_saida(ALIMENTADOR3); 
0715A:  MOVLB  3
0715C:  CLRF   xB8
0715E:  MOVLW  0C
07160:  MOVWF  xB7
07162:  MOVLB  0
07164:  CALL   24EA
07168:  MOVLB  3
....................     } 
0716A:  MOVLB  0
0716C:  RETURN 0
.................... } 
.................... void desce_ferros(int quantidade){ 
....................     if (quantidade == 2){ 
*
06D6C:  MOVLB  3
06D6E:  MOVF   xB2,W
06D70:  SUBLW  02
06D72:  BNZ   6D82
....................         aciona_saida(FERRO_SOLDA2); 
06D74:  CLRF   xB8
06D76:  MOVLW  02
06D78:  MOVWF  xB7
06D7A:  MOVLB  0
06D7C:  CALL   252C
06D80:  MOVLB  3
....................     } 
....................     if (quantidade == 3){ 
06D82:  MOVF   xB2,W
06D84:  SUBLW  03
06D86:  BNZ   6DA4
....................         aciona_saida(FERRO_SOLDA1); 
06D88:  CLRF   xB8
06D8A:  MOVLW  03
06D8C:  MOVWF  xB7
06D8E:  MOVLB  0
06D90:  CALL   252C
....................         aciona_saida(FERRO_SOLDA2); 
06D94:  MOVLB  3
06D96:  CLRF   xB8
06D98:  MOVLW  02
06D9A:  MOVWF  xB7
06D9C:  MOVLB  0
06D9E:  CALL   252C
06DA2:  MOVLB  3
....................     } 
06DA4:  MOVLB  0
06DA6:  RETURN 0
.................... } 
.................... void sobe_ferros(int quantidade){ 
....................     if (quantidade == 2){ 
*
06D30:  MOVLB  3
06D32:  MOVF   xB2,W
06D34:  SUBLW  02
06D36:  BNZ   6D46
....................         desaciona_saida(FERRO_SOLDA2); 
06D38:  CLRF   xB8
06D3A:  MOVLW  02
06D3C:  MOVWF  xB7
06D3E:  MOVLB  0
06D40:  CALL   24EA
06D44:  MOVLB  3
....................     } 
....................     if (quantidade == 3){ 
06D46:  MOVF   xB2,W
06D48:  SUBLW  03
06D4A:  BNZ   6D68
....................         desaciona_saida(FERRO_SOLDA1); 
06D4C:  CLRF   xB8
06D4E:  MOVLW  03
06D50:  MOVWF  xB7
06D52:  MOVLB  0
06D54:  CALL   24EA
....................         desaciona_saida(FERRO_SOLDA2); 
06D58:  MOVLB  3
06D5A:  CLRF   xB8
06D5C:  MOVLW  02
06D5E:  MOVWF  xB7
06D60:  MOVLB  0
06D62:  CALL   24EA
06D66:  MOVLB  3
....................     } 
06D68:  MOVLB  0
06D6A:  RETURN 0
.................... } 
.................... void liga_esteira(void){ 
....................     aciona_saida(RELE_ESTEIRA); 
*
095D6:  MOVLB  3
095D8:  CLRF   xB8
095DA:  MOVLW  0A
095DC:  MOVWF  xB7
095DE:  MOVLB  0
095E0:  CALL   252C
095E4:  GOTO   A388 (RETURN)
.................... } 
.................... void desliga_esteira(void){ 
....................     desaciona_saida(RELE_ESTEIRA); 
095E8:  MOVLB  3
095EA:  CLRF   xB8
095EC:  MOVLW  0A
095EE:  MOVWF  xB7
095F0:  MOVLB  0
095F2:  CALL   24EA
095F6:  GOTO   A3F2 (RETURN)
.................... } 
.................... void limpa_bicos(long int tempo){ 
....................     aciona_saida(LIMPA_BICO1); 
*
0A306:  MOVLB  3
0A308:  CLRF   xB8
0A30A:  MOVLW  08
0A30C:  MOVWF  xB7
0A30E:  MOVLB  0
0A310:  CALL   252C
....................     aciona_saida(LIMPA_BICO2); 
0A314:  MOVLB  3
0A316:  CLRF   xB8
0A318:  MOVLW  09
0A31A:  MOVWF  xB7
0A31C:  MOVLB  0
0A31E:  CALL   252C
....................     delay_ms(tempo); 
0A322:  MOVFF  3B0,3B1
0A326:  MOVLB  3
0A328:  INCF   xB1,F
0A32A:  DECF   xB1,F
0A32C:  BTFSC  FD8.2
0A32E:  BRA    A33C
0A330:  SETF   xBE
0A332:  MOVLB  0
0A334:  CALL   206E
0A338:  MOVLB  3
0A33A:  BRA    A32A
0A33C:  MOVFF  3AF,3BE
0A340:  MOVLB  0
0A342:  CALL   206E
....................     desaciona_saida(LIMPA_BICO1); 
0A346:  MOVLB  3
0A348:  CLRF   xB8
0A34A:  MOVLW  08
0A34C:  MOVWF  xB7
0A34E:  MOVLB  0
0A350:  CALL   24EA
....................     desaciona_saida(LIMPA_BICO2);     
0A354:  MOVLB  3
0A356:  CLRF   xB8
0A358:  MOVLW  09
0A35A:  MOVWF  xB7
0A35C:  MOVLB  0
0A35E:  CALL   24EA
0A362:  RETURN 0
.................... } 
.................... void home_solenoides(void){ 
....................     desaciona_saida(DEDO_ENTRADA); 
*
02578:  MOVLB  3
0257A:  CLRF   xB8
0257C:  MOVLW  07
0257E:  MOVWF  xB7
02580:  MOVLB  0
02582:  RCALL  24EA
....................     desaciona_saida(DEDO_SAIDA); 
02584:  MOVLB  3
02586:  CLRF   xB8
02588:  MOVLW  01
0258A:  MOVWF  xB7
0258C:  MOVLB  0
0258E:  RCALL  24EA
....................     desaciona_saida(FERRO_SOLDA1); 
02590:  MOVLB  3
02592:  CLRF   xB8
02594:  MOVLW  03
02596:  MOVWF  xB7
02598:  MOVLB  0
0259A:  RCALL  24EA
....................     desaciona_saida(FERRO_SOLDA2); 
0259C:  MOVLB  3
0259E:  CLRF   xB8
025A0:  MOVLW  02
025A2:  MOVWF  xB7
025A4:  MOVLB  0
025A6:  RCALL  24EA
....................     desaciona_saida(PRESSOR); 
025A8:  MOVLB  3
025AA:  CLRF   xB8
025AC:  MOVLW  04
025AE:  MOVWF  xB7
025B0:  MOVLB  0
025B2:  RCALL  24EA
....................     desaciona_saida(LIMPA_BICO1); 
025B4:  MOVLB  3
025B6:  CLRF   xB8
025B8:  MOVLW  08
025BA:  MOVWF  xB7
025BC:  MOVLB  0
025BE:  RCALL  24EA
....................     desaciona_saida(LIMPA_BICO2); 
025C0:  MOVLB  3
025C2:  CLRF   xB8
025C4:  MOVLW  09
025C6:  MOVWF  xB7
025C8:  MOVLB  0
025CA:  RCALL  24EA
....................      
....................     aciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
025CC:  MOVLB  3
025CE:  CLRF   xB8
025D0:  MOVLW  05
025D2:  MOVWF  xB7
025D4:  MOVLB  0
025D6:  RCALL  252C
....................     aciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
025D8:  MOVLB  3
025DA:  CLRF   xB8
025DC:  MOVLW  0F
025DE:  MOVWF  xB7
025E0:  MOVLB  0
025E2:  RCALL  252C
....................     delay_ms(2500); 
025E4:  MOVLW  0A
025E6:  MOVLB  3
025E8:  MOVWF  xAD
025EA:  MOVLW  FA
025EC:  MOVWF  xBE
025EE:  MOVLB  0
025F0:  RCALL  206E
025F2:  MOVLB  3
025F4:  DECFSZ xAD,F
025F6:  BRA    25EA
....................     desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
025F8:  CLRF   xB8
025FA:  MOVLW  05
025FC:  MOVWF  xB7
025FE:  MOVLB  0
02600:  RCALL  24EA
....................     desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
02602:  MOVLB  3
02604:  CLRF   xB8
02606:  MOVLW  0F
02608:  MOVWF  xB7
0260A:  MOVLB  0
0260C:  RCALL  24EA
0260E:  RETURN 0
.................... } 
....................  
.................... void soldar_teste(int componente, int local){ 
....................     int q; 
....................     int ferros; 
....................     q = (pontos_no_modelo/2); 
*
0716E:  BCF    FD8.0
07170:  MOVLB  1
07172:  RRCF   x0A,W
07174:  MOVLB  3
07176:  MOVWF  xB0
....................     if (local < q){ 
07178:  MOVF   xB0,W
0717A:  SUBWF  xAF,W
0717C:  BC    7184
....................         ferros = 3; 
0717E:  MOVLW  03
07180:  MOVWF  xB1
....................     } else { 
07182:  BRA    7188
....................         ferros = 2; 
07184:  MOVLW  02
07186:  MOVWF  xB1
....................     } 
....................     liga_pressor(); 
07188:  MOVLB  0
0718A:  CALL   651E
....................     ligar_alimentador_solda(ferros,700); 
0718E:  MOVFF  3B1,3B4
07192:  MOVLW  02
07194:  MOVLB  3
07196:  MOVWF  xB6
07198:  MOVLW  BC
0719A:  MOVWF  xB5
0719C:  MOVLB  0
0719E:  RCALL  7088
....................     if ((y[local] > 700)&&(x[local] > 0)){ 
071A0:  BCF    FD8.0
071A2:  MOVLB  3
071A4:  RLCF   xAF,W
071A6:  CLRF   03
071A8:  ADDLW  56
071AA:  MOVWF  FE9
071AC:  MOVLW  00
071AE:  ADDWFC 03,W
071B0:  MOVWF  FEA
071B2:  MOVFF  FEC,3B3
071B6:  MOVF   FED,F
071B8:  MOVFF  FEF,3B2
071BC:  MOVF   xB3,W
071BE:  SUBLW  01
071C0:  BTFSC  FD8.0
071C2:  GOTO   7C48
071C6:  XORLW  FF
071C8:  BNZ   71D4
071CA:  MOVF   xB2,W
071CC:  SUBLW  BC
071CE:  BTFSC  FD8.0
071D0:  GOTO   7C48
071D4:  BCF    FD8.0
071D6:  RLCF   xAF,W
071D8:  CLRF   03
071DA:  ADDLW  2E
071DC:  MOVWF  FE9
071DE:  MOVLW  00
071E0:  ADDWFC 03,W
071E2:  MOVWF  FEA
071E4:  MOVFF  FEC,3B3
071E8:  MOVF   FED,F
071EA:  MOVFF  FEF,3B2
071EE:  MOVF   xB2,F
071F0:  BNZ   71FA
071F2:  MOVF   xB3,F
071F4:  BTFSC  FD8.2
071F6:  GOTO   7C48
....................         desce_ferros(ferros); 
071FA:  MOVFF  3B1,3B2
071FE:  MOVLB  0
07200:  RCALL  6D6C
....................         switch (componente){ 
07202:  MOVLB  3
07204:  MOVF   xAE,W
07206:  ADDLW  FC
07208:  BTFSC  FD8.0
0720A:  GOTO   7C46
0720E:  ADDLW  04
07210:  MOVLB  0
07212:  GOTO   7C9A
....................             case 0: 
....................                 motor_run_y(y[local], 19); 
07216:  BCF    FD8.0
07218:  MOVLB  3
0721A:  RLCF   xAF,W
0721C:  CLRF   03
0721E:  ADDLW  56
07220:  MOVWF  FE9
07222:  MOVLW  00
07224:  ADDWFC 03,W
07226:  MOVWF  FEA
07228:  MOVFF  FEC,3B3
0722C:  MOVF   FED,F
0722E:  MOVFF  FEF,3B2
07232:  CLRF   xB7
07234:  CLRF   xB6
07236:  MOVFF  3B3,3B5
0723A:  MOVFF  3B2,3B4
0723E:  MOVLW  13
07240:  MOVWF  xB8
07242:  MOVLB  0
07244:  CALL   580C
....................                 motor_run_x(x[local], 19); 
07248:  BCF    FD8.0
0724A:  MOVLB  3
0724C:  RLCF   xAF,W
0724E:  CLRF   03
07250:  ADDLW  2E
07252:  MOVWF  FE9
07254:  MOVLW  00
07256:  ADDWFC 03,W
07258:  MOVWF  FEA
0725A:  MOVFF  FEC,3B3
0725E:  MOVF   FED,F
07260:  MOVFF  FEF,3B2
07264:  CLRF   xB7
07266:  CLRF   xB6
07268:  MOVFF  3B3,3B5
0726C:  MOVFF  3B2,3B4
07270:  MOVLW  13
07272:  MOVWF  xB8
07274:  MOVLB  0
07276:  CALL   4ABC
....................                 while ((run_flg_x || run_flg_y)); 
0727A:  MOVLB  1
0727C:  BTFSC  x1A.4
0727E:  BRA    727C
07280:  BTFSC  x1A.6
07282:  BRA    727C
....................                 ligar_alimentador_solda(ferros,t_solda[local]); 
07284:  BCF    FD8.0
07286:  MOVLB  3
07288:  RLCF   xAF,W
0728A:  CLRF   03
0728C:  ADDLW  A6
0728E:  MOVWF  FE9
07290:  MOVLW  00
07292:  ADDWFC 03,W
07294:  MOVWF  FEA
07296:  MOVFF  FEC,3B3
0729A:  MOVF   FED,F
0729C:  MOVFF  FEF,3B2
072A0:  MOVFF  3B1,3B4
072A4:  MOVFF  3B3,3B6
072A8:  MOVFF  3B2,3B5
072AC:  MOVLB  0
072AE:  RCALL  7088
....................                 motor_run_z(z[local], 19); 
072B0:  BCF    FD8.0
072B2:  MOVLB  3
072B4:  RLCF   xAF,W
072B6:  CLRF   03
072B8:  ADDLW  7E
072BA:  MOVWF  FE9
072BC:  MOVLW  00
072BE:  ADDWFC 03,W
072C0:  MOVWF  FEA
072C2:  MOVFF  FEC,3B3
072C6:  MOVF   FED,F
072C8:  MOVFF  FEF,3B2
072CC:  CLRF   xB7
072CE:  CLRF   xB6
072D0:  MOVFF  3B3,3B5
072D4:  MOVFF  3B2,3B4
072D8:  MOVLW  13
072DA:  MOVWF  xB8
072DC:  MOVLB  0
072DE:  CALL   5642
....................                 while ((run_flg_z)); 
072E2:  MOVLB  2
072E4:  BTFSC  xC6.1
072E6:  BRA    72E4
....................                 delay_ms(t_wait[local]);  
072E8:  BCF    FD8.0
072EA:  MOVLB  3
072EC:  RLCF   xAF,W
072EE:  CLRF   03
072F0:  ADDLW  CE
072F2:  MOVWF  FE9
072F4:  MOVLW  00
072F6:  ADDWFC 03,W
072F8:  MOVWF  FEA
072FA:  MOVFF  FEC,3B3
072FE:  MOVF   FED,F
07300:  MOVFF  FEF,3B2
07304:  MOVFF  3B3,3B4
07308:  INCF   xB4,F
0730A:  DECF   xB4,F
0730C:  BTFSC  FD8.2
0730E:  BRA    731C
07310:  SETF   xBE
07312:  MOVLB  0
07314:  CALL   206E
07318:  MOVLB  3
0731A:  BRA    730A
0731C:  MOVFF  3B2,3BE
07320:  MOVLB  0
07322:  CALL   206E
....................                 motor_run_z(0, 19); 
07326:  MOVLB  3
07328:  CLRF   xB7
0732A:  CLRF   xB6
0732C:  CLRF   xB5
0732E:  CLRF   xB4
07330:  MOVLW  13
07332:  MOVWF  xB8
07334:  MOVLB  0
07336:  CALL   5642
....................                 while ((run_flg_z)); 
0733A:  MOVLB  2
0733C:  BTFSC  xC6.1
0733E:  BRA    733C
....................             break; 
07340:  MOVLB  3
07342:  GOTO   7C46
....................             case 1: 
....................                 motor_run_y(y[local], 19); 
07346:  BCF    FD8.0
07348:  MOVLB  3
0734A:  RLCF   xAF,W
0734C:  CLRF   03
0734E:  ADDLW  56
07350:  MOVWF  FE9
07352:  MOVLW  00
07354:  ADDWFC 03,W
07356:  MOVWF  FEA
07358:  MOVFF  FEC,3B3
0735C:  MOVF   FED,F
0735E:  MOVFF  FEF,3B2
07362:  CLRF   xB7
07364:  CLRF   xB6
07366:  MOVFF  3B3,3B5
0736A:  MOVFF  3B2,3B4
0736E:  MOVLW  13
07370:  MOVWF  xB8
07372:  MOVLB  0
07374:  CALL   580C
....................                 motor_run_x(x[local], 19); 
07378:  BCF    FD8.0
0737A:  MOVLB  3
0737C:  RLCF   xAF,W
0737E:  CLRF   03
07380:  ADDLW  2E
07382:  MOVWF  FE9
07384:  MOVLW  00
07386:  ADDWFC 03,W
07388:  MOVWF  FEA
0738A:  MOVFF  FEC,3B3
0738E:  MOVF   FED,F
07390:  MOVFF  FEF,3B2
07394:  CLRF   xB7
07396:  CLRF   xB6
07398:  MOVFF  3B3,3B5
0739C:  MOVFF  3B2,3B4
073A0:  MOVLW  13
073A2:  MOVWF  xB8
073A4:  MOVLB  0
073A6:  CALL   4ABC
....................                 while ((run_flg_x || run_flg_y)); 
073AA:  MOVLB  1
073AC:  BTFSC  x1A.4
073AE:  BRA    73AC
073B0:  BTFSC  x1A.6
073B2:  BRA    73AC
....................                 ligar_alimentador_solda(ferros,t_solda[local]); 
073B4:  BCF    FD8.0
073B6:  MOVLB  3
073B8:  RLCF   xAF,W
073BA:  CLRF   03
073BC:  ADDLW  A6
073BE:  MOVWF  FE9
073C0:  MOVLW  00
073C2:  ADDWFC 03,W
073C4:  MOVWF  FEA
073C6:  MOVFF  FEC,3B3
073CA:  MOVF   FED,F
073CC:  MOVFF  FEF,3B2
073D0:  MOVFF  3B1,3B4
073D4:  MOVFF  3B3,3B6
073D8:  MOVFF  3B2,3B5
073DC:  MOVLB  0
073DE:  RCALL  7088
....................                 motor_run_z(z[local]-20, 19); 
073E0:  BCF    FD8.0
073E2:  MOVLB  3
073E4:  RLCF   xAF,W
073E6:  CLRF   03
073E8:  ADDLW  7E
073EA:  MOVWF  FE9
073EC:  MOVLW  00
073EE:  ADDWFC 03,W
073F0:  MOVWF  FEA
073F2:  MOVFF  FEC,3B3
073F6:  MOVF   FED,F
073F8:  MOVFF  FEF,3B2
073FC:  MOVLW  14
073FE:  SUBWF  xB2,F
07400:  MOVLW  00
07402:  SUBWFB xB3,F
07404:  CLRF   xB7
07406:  CLRF   xB6
07408:  MOVFF  3B3,3B5
0740C:  MOVFF  3B2,3B4
07410:  MOVLW  13
07412:  MOVWF  xB8
07414:  MOVLB  0
07416:  CALL   5642
....................                 motor_run_y(y[local]-30, 19); 
0741A:  BCF    FD8.0
0741C:  MOVLB  3
0741E:  RLCF   xAF,W
07420:  CLRF   03
07422:  ADDLW  56
07424:  MOVWF  FE9
07426:  MOVLW  00
07428:  ADDWFC 03,W
0742A:  MOVWF  FEA
0742C:  MOVFF  FEC,3B3
07430:  MOVF   FED,F
07432:  MOVFF  FEF,3B2
07436:  MOVLW  1E
07438:  SUBWF  xB2,F
0743A:  MOVLW  00
0743C:  SUBWFB xB3,F
0743E:  CLRF   xB7
07440:  CLRF   xB6
07442:  MOVFF  3B3,3B5
07446:  MOVFF  3B2,3B4
0744A:  MOVLW  13
0744C:  MOVWF  xB8
0744E:  MOVLB  0
07450:  CALL   580C
....................                 motor_run_y(y[local], 19); 
07454:  BCF    FD8.0
07456:  MOVLB  3
07458:  RLCF   xAF,W
0745A:  CLRF   03
0745C:  ADDLW  56
0745E:  MOVWF  FE9
07460:  MOVLW  00
07462:  ADDWFC 03,W
07464:  MOVWF  FEA
07466:  MOVFF  FEC,3B3
0746A:  MOVF   FED,F
0746C:  MOVFF  FEF,3B2
07470:  CLRF   xB7
07472:  CLRF   xB6
07474:  MOVFF  3B3,3B5
07478:  MOVFF  3B2,3B4
0747C:  MOVLW  13
0747E:  MOVWF  xB8
07480:  MOVLB  0
07482:  CALL   580C
....................                 motor_run_x(x[local]+10, 19); 
07486:  BCF    FD8.0
07488:  MOVLB  3
0748A:  RLCF   xAF,W
0748C:  CLRF   03
0748E:  ADDLW  2E
07490:  MOVWF  FE9
07492:  MOVLW  00
07494:  ADDWFC 03,W
07496:  MOVWF  FEA
07498:  MOVFF  FEC,3B3
0749C:  MOVF   FED,F
0749E:  MOVFF  FEF,3B2
074A2:  MOVLW  0A
074A4:  ADDWF  xB2,F
074A6:  MOVLW  00
074A8:  ADDWFC xB3,F
074AA:  CLRF   xB7
074AC:  CLRF   xB6
074AE:  MOVFF  3B3,3B5
074B2:  MOVFF  3B2,3B4
074B6:  MOVLW  13
074B8:  MOVWF  xB8
074BA:  MOVLB  0
074BC:  CALL   4ABC
....................                 motor_run_z(z[local], 19); 
074C0:  BCF    FD8.0
074C2:  MOVLB  3
074C4:  RLCF   xAF,W
074C6:  CLRF   03
074C8:  ADDLW  7E
074CA:  MOVWF  FE9
074CC:  MOVLW  00
074CE:  ADDWFC 03,W
074D0:  MOVWF  FEA
074D2:  MOVFF  FEC,3B3
074D6:  MOVF   FED,F
074D8:  MOVFF  FEF,3B2
074DC:  CLRF   xB7
074DE:  CLRF   xB6
074E0:  MOVFF  3B3,3B5
074E4:  MOVFF  3B2,3B4
074E8:  MOVLW  13
074EA:  MOVWF  xB8
074EC:  MOVLB  0
074EE:  CALL   5642
....................                 motor_run_x(x[local], 19); 
074F2:  BCF    FD8.0
074F4:  MOVLB  3
074F6:  RLCF   xAF,W
074F8:  CLRF   03
074FA:  ADDLW  2E
074FC:  MOVWF  FE9
074FE:  MOVLW  00
07500:  ADDWFC 03,W
07502:  MOVWF  FEA
07504:  MOVFF  FEC,3B3
07508:  MOVF   FED,F
0750A:  MOVFF  FEF,3B2
0750E:  CLRF   xB7
07510:  CLRF   xB6
07512:  MOVFF  3B3,3B5
07516:  MOVFF  3B2,3B4
0751A:  MOVLW  13
0751C:  MOVWF  xB8
0751E:  MOVLB  0
07520:  CALL   4ABC
....................                 while ((run_flg_x || run_flg_y || run_flg_z)); 
07524:  MOVLB  1
07526:  BTFSC  x1A.4
07528:  BRA    7526
0752A:  BTFSC  x1A.6
0752C:  BRA    7526
0752E:  MOVLB  2
07530:  BTFSS  xC6.1
07532:  BRA    7538
07534:  MOVLB  0
07536:  BRA    7524
....................                 delay_ms(t_wait[local]);              
07538:  BCF    FD8.0
0753A:  MOVLB  3
0753C:  RLCF   xAF,W
0753E:  CLRF   03
07540:  ADDLW  CE
07542:  MOVWF  FE9
07544:  MOVLW  00
07546:  ADDWFC 03,W
07548:  MOVWF  FEA
0754A:  MOVFF  FEC,3B3
0754E:  MOVF   FED,F
07550:  MOVFF  FEF,3B2
07554:  MOVFF  3B3,3B4
07558:  INCF   xB4,F
0755A:  DECF   xB4,F
0755C:  BTFSC  FD8.2
0755E:  BRA    756C
07560:  SETF   xBE
07562:  MOVLB  0
07564:  CALL   206E
07568:  MOVLB  3
0756A:  BRA    755A
0756C:  MOVFF  3B2,3BE
07570:  MOVLB  0
07572:  CALL   206E
....................                 motor_run_z(0, 19); 
07576:  MOVLB  3
07578:  CLRF   xB7
0757A:  CLRF   xB6
0757C:  CLRF   xB5
0757E:  CLRF   xB4
07580:  MOVLW  13
07582:  MOVWF  xB8
07584:  MOVLB  0
07586:  CALL   5642
....................                 while ((run_flg_z)); 
0758A:  MOVLB  2
0758C:  BTFSC  xC6.1
0758E:  BRA    758C
....................             break; 
07590:  MOVLB  3
07592:  BRA    7C46
....................             case 2: 
....................                 motor_run_y(y[local], 19); 
07594:  BCF    FD8.0
07596:  MOVLB  3
07598:  RLCF   xAF,W
0759A:  CLRF   03
0759C:  ADDLW  56
0759E:  MOVWF  FE9
075A0:  MOVLW  00
075A2:  ADDWFC 03,W
075A4:  MOVWF  FEA
075A6:  MOVFF  FEC,3B3
075AA:  MOVF   FED,F
075AC:  MOVFF  FEF,3B2
075B0:  CLRF   xB7
075B2:  CLRF   xB6
075B4:  MOVFF  3B3,3B5
075B8:  MOVFF  3B2,3B4
075BC:  MOVLW  13
075BE:  MOVWF  xB8
075C0:  MOVLB  0
075C2:  CALL   580C
....................                 motor_run_x(x[local], 19); 
075C6:  BCF    FD8.0
075C8:  MOVLB  3
075CA:  RLCF   xAF,W
075CC:  CLRF   03
075CE:  ADDLW  2E
075D0:  MOVWF  FE9
075D2:  MOVLW  00
075D4:  ADDWFC 03,W
075D6:  MOVWF  FEA
075D8:  MOVFF  FEC,3B3
075DC:  MOVF   FED,F
075DE:  MOVFF  FEF,3B2
075E2:  CLRF   xB7
075E4:  CLRF   xB6
075E6:  MOVFF  3B3,3B5
075EA:  MOVFF  3B2,3B4
075EE:  MOVLW  13
075F0:  MOVWF  xB8
075F2:  MOVLB  0
075F4:  CALL   4ABC
....................                 while ((run_flg_x || run_flg_y)); 
075F8:  MOVLB  1
075FA:  BTFSC  x1A.4
075FC:  BRA    75FA
075FE:  BTFSC  x1A.6
07600:  BRA    75FA
....................                 ligar_alimentador_solda(ferros,t_solda[local]); 
07602:  BCF    FD8.0
07604:  MOVLB  3
07606:  RLCF   xAF,W
07608:  CLRF   03
0760A:  ADDLW  A6
0760C:  MOVWF  FE9
0760E:  MOVLW  00
07610:  ADDWFC 03,W
07612:  MOVWF  FEA
07614:  MOVFF  FEC,3B3
07618:  MOVF   FED,F
0761A:  MOVFF  FEF,3B2
0761E:  MOVFF  3B1,3B4
07622:  MOVFF  3B3,3B6
07626:  MOVFF  3B2,3B5
0762A:  MOVLB  0
0762C:  RCALL  7088
....................                 motor_run_z(z[local], 19); 
0762E:  BCF    FD8.0
07630:  MOVLB  3
07632:  RLCF   xAF,W
07634:  CLRF   03
07636:  ADDLW  7E
07638:  MOVWF  FE9
0763A:  MOVLW  00
0763C:  ADDWFC 03,W
0763E:  MOVWF  FEA
07640:  MOVFF  FEC,3B3
07644:  MOVF   FED,F
07646:  MOVFF  FEF,3B2
0764A:  CLRF   xB7
0764C:  CLRF   xB6
0764E:  MOVFF  3B3,3B5
07652:  MOVFF  3B2,3B4
07656:  MOVLW  13
07658:  MOVWF  xB8
0765A:  MOVLB  0
0765C:  CALL   5642
....................                 while ((run_flg_z)); 
07660:  MOVLB  2
07662:  BTFSC  xC6.1
07664:  BRA    7662
....................                 delay_ms(t_wait[local]); 
07666:  BCF    FD8.0
07668:  MOVLB  3
0766A:  RLCF   xAF,W
0766C:  CLRF   03
0766E:  ADDLW  CE
07670:  MOVWF  FE9
07672:  MOVLW  00
07674:  ADDWFC 03,W
07676:  MOVWF  FEA
07678:  MOVFF  FEC,3B3
0767C:  MOVF   FED,F
0767E:  MOVFF  FEF,3B2
07682:  MOVFF  3B3,3B4
07686:  INCF   xB4,F
07688:  DECF   xB4,F
0768A:  BTFSC  FD8.2
0768C:  BRA    769A
0768E:  SETF   xBE
07690:  MOVLB  0
07692:  CALL   206E
07696:  MOVLB  3
07698:  BRA    7688
0769A:  MOVFF  3B2,3BE
0769E:  MOVLB  0
076A0:  CALL   206E
....................                 motor_run_z(z[local]-3, 19); 
076A4:  BCF    FD8.0
076A6:  MOVLB  3
076A8:  RLCF   xAF,W
076AA:  CLRF   03
076AC:  ADDLW  7E
076AE:  MOVWF  FE9
076B0:  MOVLW  00
076B2:  ADDWFC 03,W
076B4:  MOVWF  FEA
076B6:  MOVFF  FEC,3B3
076BA:  MOVF   FED,F
076BC:  MOVFF  FEF,3B2
076C0:  MOVLW  03
076C2:  SUBWF  xB2,F
076C4:  MOVLW  00
076C6:  SUBWFB xB3,F
076C8:  CLRF   xB7
076CA:  CLRF   xB6
076CC:  MOVFF  3B3,3B5
076D0:  MOVFF  3B2,3B4
076D4:  MOVLW  13
076D6:  MOVWF  xB8
076D8:  MOVLB  0
076DA:  CALL   5642
....................                 motor_run_x(x[local]-10, 19); 
076DE:  BCF    FD8.0
076E0:  MOVLB  3
076E2:  RLCF   xAF,W
076E4:  CLRF   03
076E6:  ADDLW  2E
076E8:  MOVWF  FE9
076EA:  MOVLW  00
076EC:  ADDWFC 03,W
076EE:  MOVWF  FEA
076F0:  MOVFF  FEC,3B3
076F4:  MOVF   FED,F
076F6:  MOVFF  FEF,3B2
076FA:  MOVLW  0A
076FC:  SUBWF  xB2,F
076FE:  MOVLW  00
07700:  SUBWFB xB3,F
07702:  CLRF   xB7
07704:  CLRF   xB6
07706:  MOVFF  3B3,3B5
0770A:  MOVFF  3B2,3B4
0770E:  MOVLW  13
07710:  MOVWF  xB8
07712:  MOVLB  0
07714:  CALL   4ABC
....................                 motor_run_z(z[local], 19); 
07718:  BCF    FD8.0
0771A:  MOVLB  3
0771C:  RLCF   xAF,W
0771E:  CLRF   03
07720:  ADDLW  7E
07722:  MOVWF  FE9
07724:  MOVLW  00
07726:  ADDWFC 03,W
07728:  MOVWF  FEA
0772A:  MOVFF  FEC,3B3
0772E:  MOVF   FED,F
07730:  MOVFF  FEF,3B2
07734:  CLRF   xB7
07736:  CLRF   xB6
07738:  MOVFF  3B3,3B5
0773C:  MOVFF  3B2,3B4
07740:  MOVLW  13
07742:  MOVWF  xB8
07744:  MOVLB  0
07746:  CALL   5642
....................                 while ((run_flg_x || run_flg_y || run_flg_z)); 
0774A:  MOVLB  1
0774C:  BTFSC  x1A.4
0774E:  BRA    774C
07750:  BTFSC  x1A.6
07752:  BRA    774C
07754:  MOVLB  2
07756:  BTFSS  xC6.1
07758:  BRA    775E
0775A:  MOVLB  0
0775C:  BRA    774A
....................                 delay_ms(t_wait[local]);   
0775E:  BCF    FD8.0
07760:  MOVLB  3
07762:  RLCF   xAF,W
07764:  CLRF   03
07766:  ADDLW  CE
07768:  MOVWF  FE9
0776A:  MOVLW  00
0776C:  ADDWFC 03,W
0776E:  MOVWF  FEA
07770:  MOVFF  FEC,3B3
07774:  MOVF   FED,F
07776:  MOVFF  FEF,3B2
0777A:  MOVFF  3B3,3B4
0777E:  INCF   xB4,F
07780:  DECF   xB4,F
07782:  BTFSC  FD8.2
07784:  BRA    7792
07786:  SETF   xBE
07788:  MOVLB  0
0778A:  CALL   206E
0778E:  MOVLB  3
07790:  BRA    7780
07792:  MOVFF  3B2,3BE
07796:  MOVLB  0
07798:  CALL   206E
....................                 motor_run_z(z[local]-3, 19); 
0779C:  BCF    FD8.0
0779E:  MOVLB  3
077A0:  RLCF   xAF,W
077A2:  CLRF   03
077A4:  ADDLW  7E
077A6:  MOVWF  FE9
077A8:  MOVLW  00
077AA:  ADDWFC 03,W
077AC:  MOVWF  FEA
077AE:  MOVFF  FEC,3B3
077B2:  MOVF   FED,F
077B4:  MOVFF  FEF,3B2
077B8:  MOVLW  03
077BA:  SUBWF  xB2,F
077BC:  MOVLW  00
077BE:  SUBWFB xB3,F
077C0:  CLRF   xB7
077C2:  CLRF   xB6
077C4:  MOVFF  3B3,3B5
077C8:  MOVFF  3B2,3B4
077CC:  MOVLW  13
077CE:  MOVWF  xB8
077D0:  MOVLB  0
077D2:  CALL   5642
....................                 motor_run_x(x[local]+10, 19); 
077D6:  BCF    FD8.0
077D8:  MOVLB  3
077DA:  RLCF   xAF,W
077DC:  CLRF   03
077DE:  ADDLW  2E
077E0:  MOVWF  FE9
077E2:  MOVLW  00
077E4:  ADDWFC 03,W
077E6:  MOVWF  FEA
077E8:  MOVFF  FEC,3B3
077EC:  MOVF   FED,F
077EE:  MOVFF  FEF,3B2
077F2:  MOVLW  0A
077F4:  ADDWF  xB2,F
077F6:  MOVLW  00
077F8:  ADDWFC xB3,F
077FA:  CLRF   xB7
077FC:  CLRF   xB6
077FE:  MOVFF  3B3,3B5
07802:  MOVFF  3B2,3B4
07806:  MOVLW  13
07808:  MOVWF  xB8
0780A:  MOVLB  0
0780C:  CALL   4ABC
....................                 motor_run_z(z[local], 19); 
07810:  BCF    FD8.0
07812:  MOVLB  3
07814:  RLCF   xAF,W
07816:  CLRF   03
07818:  ADDLW  7E
0781A:  MOVWF  FE9
0781C:  MOVLW  00
0781E:  ADDWFC 03,W
07820:  MOVWF  FEA
07822:  MOVFF  FEC,3B3
07826:  MOVF   FED,F
07828:  MOVFF  FEF,3B2
0782C:  CLRF   xB7
0782E:  CLRF   xB6
07830:  MOVFF  3B3,3B5
07834:  MOVFF  3B2,3B4
07838:  MOVLW  13
0783A:  MOVWF  xB8
0783C:  MOVLB  0
0783E:  CALL   5642
....................                 while ((run_flg_x || run_flg_z)); 
07842:  MOVLB  1
07844:  BTFSC  x1A.4
07846:  BRA    7844
07848:  MOVLB  2
0784A:  BTFSS  xC6.1
0784C:  BRA    7852
0784E:  MOVLB  0
07850:  BRA    7842
....................                 delay_ms(t_wait[local]); 
07852:  BCF    FD8.0
07854:  MOVLB  3
07856:  RLCF   xAF,W
07858:  CLRF   03
0785A:  ADDLW  CE
0785C:  MOVWF  FE9
0785E:  MOVLW  00
07860:  ADDWFC 03,W
07862:  MOVWF  FEA
07864:  MOVFF  FEC,3B3
07868:  MOVF   FED,F
0786A:  MOVFF  FEF,3B2
0786E:  MOVFF  3B3,3B4
07872:  INCF   xB4,F
07874:  DECF   xB4,F
07876:  BTFSC  FD8.2
07878:  BRA    7886
0787A:  SETF   xBE
0787C:  MOVLB  0
0787E:  CALL   206E
07882:  MOVLB  3
07884:  BRA    7874
07886:  MOVFF  3B2,3BE
0788A:  MOVLB  0
0788C:  CALL   206E
....................                 motor_run_z(0, 19); 
07890:  MOVLB  3
07892:  CLRF   xB7
07894:  CLRF   xB6
07896:  CLRF   xB5
07898:  CLRF   xB4
0789A:  MOVLW  13
0789C:  MOVWF  xB8
0789E:  MOVLB  0
078A0:  CALL   5642
....................                 while ((run_flg_z)); 
078A4:  MOVLB  2
078A6:  BTFSC  xC6.1
078A8:  BRA    78A6
....................             break; 
078AA:  MOVLB  3
078AC:  BRA    7C46
....................             case 3: 
....................                 motor_run_y(y[local], 19); 
078AE:  BCF    FD8.0
078B0:  MOVLB  3
078B2:  RLCF   xAF,W
078B4:  CLRF   03
078B6:  ADDLW  56
078B8:  MOVWF  FE9
078BA:  MOVLW  00
078BC:  ADDWFC 03,W
078BE:  MOVWF  FEA
078C0:  MOVFF  FEC,3B3
078C4:  MOVF   FED,F
078C6:  MOVFF  FEF,3B2
078CA:  CLRF   xB7
078CC:  CLRF   xB6
078CE:  MOVFF  3B3,3B5
078D2:  MOVFF  3B2,3B4
078D6:  MOVLW  13
078D8:  MOVWF  xB8
078DA:  MOVLB  0
078DC:  CALL   580C
....................                 motor_run_x(x[local], 19); 
078E0:  BCF    FD8.0
078E2:  MOVLB  3
078E4:  RLCF   xAF,W
078E6:  CLRF   03
078E8:  ADDLW  2E
078EA:  MOVWF  FE9
078EC:  MOVLW  00
078EE:  ADDWFC 03,W
078F0:  MOVWF  FEA
078F2:  MOVFF  FEC,3B3
078F6:  MOVF   FED,F
078F8:  MOVFF  FEF,3B2
078FC:  CLRF   xB7
078FE:  CLRF   xB6
07900:  MOVFF  3B3,3B5
07904:  MOVFF  3B2,3B4
07908:  MOVLW  13
0790A:  MOVWF  xB8
0790C:  MOVLB  0
0790E:  CALL   4ABC
....................                 while ((run_flg_x || run_flg_y)); 
07912:  MOVLB  1
07914:  BTFSC  x1A.4
07916:  BRA    7914
07918:  BTFSC  x1A.6
0791A:  BRA    7914
....................                 ligar_alimentador_solda(ferros,t_solda[local]); 
0791C:  BCF    FD8.0
0791E:  MOVLB  3
07920:  RLCF   xAF,W
07922:  CLRF   03
07924:  ADDLW  A6
07926:  MOVWF  FE9
07928:  MOVLW  00
0792A:  ADDWFC 03,W
0792C:  MOVWF  FEA
0792E:  MOVFF  FEC,3B3
07932:  MOVF   FED,F
07934:  MOVFF  FEF,3B2
07938:  MOVFF  3B1,3B4
0793C:  MOVFF  3B3,3B6
07940:  MOVFF  3B2,3B5
07944:  MOVLB  0
07946:  CALL   7088
....................                 motor_run_z(z[local], 19); 
0794A:  BCF    FD8.0
0794C:  MOVLB  3
0794E:  RLCF   xAF,W
07950:  CLRF   03
07952:  ADDLW  7E
07954:  MOVWF  FE9
07956:  MOVLW  00
07958:  ADDWFC 03,W
0795A:  MOVWF  FEA
0795C:  MOVFF  FEC,3B3
07960:  MOVF   FED,F
07962:  MOVFF  FEF,3B2
07966:  CLRF   xB7
07968:  CLRF   xB6
0796A:  MOVFF  3B3,3B5
0796E:  MOVFF  3B2,3B4
07972:  MOVLW  13
07974:  MOVWF  xB8
07976:  MOVLB  0
07978:  CALL   5642
....................                 while ((run_flg_z)); 
0797C:  MOVLB  2
0797E:  BTFSC  xC6.1
07980:  BRA    797E
....................                 delay_ms(t_wait[local]); 
07982:  BCF    FD8.0
07984:  MOVLB  3
07986:  RLCF   xAF,W
07988:  CLRF   03
0798A:  ADDLW  CE
0798C:  MOVWF  FE9
0798E:  MOVLW  00
07990:  ADDWFC 03,W
07992:  MOVWF  FEA
07994:  MOVFF  FEC,3B3
07998:  MOVF   FED,F
0799A:  MOVFF  FEF,3B2
0799E:  MOVFF  3B3,3B4
079A2:  INCF   xB4,F
079A4:  DECF   xB4,F
079A6:  BTFSC  FD8.2
079A8:  BRA    79B6
079AA:  SETF   xBE
079AC:  MOVLB  0
079AE:  CALL   206E
079B2:  MOVLB  3
079B4:  BRA    79A4
079B6:  MOVFF  3B2,3BE
079BA:  MOVLB  0
079BC:  CALL   206E
....................                 motor_run_z(z[local]-3, 19); 
079C0:  BCF    FD8.0
079C2:  MOVLB  3
079C4:  RLCF   xAF,W
079C6:  CLRF   03
079C8:  ADDLW  7E
079CA:  MOVWF  FE9
079CC:  MOVLW  00
079CE:  ADDWFC 03,W
079D0:  MOVWF  FEA
079D2:  MOVFF  FEC,3B3
079D6:  MOVF   FED,F
079D8:  MOVFF  FEF,3B2
079DC:  MOVLW  03
079DE:  SUBWF  xB2,F
079E0:  MOVLW  00
079E2:  SUBWFB xB3,F
079E4:  CLRF   xB7
079E6:  CLRF   xB6
079E8:  MOVFF  3B3,3B5
079EC:  MOVFF  3B2,3B4
079F0:  MOVLW  13
079F2:  MOVWF  xB8
079F4:  MOVLB  0
079F6:  CALL   5642
....................                 motor_run_x(x[local]-21, 19); 
079FA:  BCF    FD8.0
079FC:  MOVLB  3
079FE:  RLCF   xAF,W
07A00:  CLRF   03
07A02:  ADDLW  2E
07A04:  MOVWF  FE9
07A06:  MOVLW  00
07A08:  ADDWFC 03,W
07A0A:  MOVWF  FEA
07A0C:  MOVFF  FEC,3B3
07A10:  MOVF   FED,F
07A12:  MOVFF  FEF,3B2
07A16:  MOVLW  15
07A18:  SUBWF  xB2,F
07A1A:  MOVLW  00
07A1C:  SUBWFB xB3,F
07A1E:  CLRF   xB7
07A20:  CLRF   xB6
07A22:  MOVFF  3B3,3B5
07A26:  MOVFF  3B2,3B4
07A2A:  MOVLW  13
07A2C:  MOVWF  xB8
07A2E:  MOVLB  0
07A30:  CALL   4ABC
....................                 motor_run_z(z[local], 19); 
07A34:  BCF    FD8.0
07A36:  MOVLB  3
07A38:  RLCF   xAF,W
07A3A:  CLRF   03
07A3C:  ADDLW  7E
07A3E:  MOVWF  FE9
07A40:  MOVLW  00
07A42:  ADDWFC 03,W
07A44:  MOVWF  FEA
07A46:  MOVFF  FEC,3B3
07A4A:  MOVF   FED,F
07A4C:  MOVFF  FEF,3B2
07A50:  CLRF   xB7
07A52:  CLRF   xB6
07A54:  MOVFF  3B3,3B5
07A58:  MOVFF  3B2,3B4
07A5C:  MOVLW  13
07A5E:  MOVWF  xB8
07A60:  MOVLB  0
07A62:  CALL   5642
....................                 while ((run_flg_x || run_flg_z)); 
07A66:  MOVLB  1
07A68:  BTFSC  x1A.4
07A6A:  BRA    7A68
07A6C:  MOVLB  2
07A6E:  BTFSS  xC6.1
07A70:  BRA    7A76
07A72:  MOVLB  0
07A74:  BRA    7A66
....................                 delay_ms(t_wait[local]);   
07A76:  BCF    FD8.0
07A78:  MOVLB  3
07A7A:  RLCF   xAF,W
07A7C:  CLRF   03
07A7E:  ADDLW  CE
07A80:  MOVWF  FE9
07A82:  MOVLW  00
07A84:  ADDWFC 03,W
07A86:  MOVWF  FEA
07A88:  MOVFF  FEC,3B3
07A8C:  MOVF   FED,F
07A8E:  MOVFF  FEF,3B2
07A92:  MOVFF  3B3,3B4
07A96:  INCF   xB4,F
07A98:  DECF   xB4,F
07A9A:  BTFSC  FD8.2
07A9C:  BRA    7AAA
07A9E:  SETF   xBE
07AA0:  MOVLB  0
07AA2:  CALL   206E
07AA6:  MOVLB  3
07AA8:  BRA    7A98
07AAA:  MOVFF  3B2,3BE
07AAE:  MOVLB  0
07AB0:  CALL   206E
....................                 motor_run_z(z[local]-3, 19); 
07AB4:  BCF    FD8.0
07AB6:  MOVLB  3
07AB8:  RLCF   xAF,W
07ABA:  CLRF   03
07ABC:  ADDLW  7E
07ABE:  MOVWF  FE9
07AC0:  MOVLW  00
07AC2:  ADDWFC 03,W
07AC4:  MOVWF  FEA
07AC6:  MOVFF  FEC,3B3
07ACA:  MOVF   FED,F
07ACC:  MOVFF  FEF,3B2
07AD0:  MOVLW  03
07AD2:  SUBWF  xB2,F
07AD4:  MOVLW  00
07AD6:  SUBWFB xB3,F
07AD8:  CLRF   xB7
07ADA:  CLRF   xB6
07ADC:  MOVFF  3B3,3B5
07AE0:  MOVFF  3B2,3B4
07AE4:  MOVLW  13
07AE6:  MOVWF  xB8
07AE8:  MOVLB  0
07AEA:  CALL   5642
....................                 motor_run_x(x[local]-42, 19); 
07AEE:  BCF    FD8.0
07AF0:  MOVLB  3
07AF2:  RLCF   xAF,W
07AF4:  CLRF   03
07AF6:  ADDLW  2E
07AF8:  MOVWF  FE9
07AFA:  MOVLW  00
07AFC:  ADDWFC 03,W
07AFE:  MOVWF  FEA
07B00:  MOVFF  FEC,3B3
07B04:  MOVF   FED,F
07B06:  MOVFF  FEF,3B2
07B0A:  MOVLW  2A
07B0C:  SUBWF  xB2,F
07B0E:  MOVLW  00
07B10:  SUBWFB xB3,F
07B12:  CLRF   xB7
07B14:  CLRF   xB6
07B16:  MOVFF  3B3,3B5
07B1A:  MOVFF  3B2,3B4
07B1E:  MOVLW  13
07B20:  MOVWF  xB8
07B22:  MOVLB  0
07B24:  CALL   4ABC
....................                 motor_run_z(z[local], 19); 
07B28:  BCF    FD8.0
07B2A:  MOVLB  3
07B2C:  RLCF   xAF,W
07B2E:  CLRF   03
07B30:  ADDLW  7E
07B32:  MOVWF  FE9
07B34:  MOVLW  00
07B36:  ADDWFC 03,W
07B38:  MOVWF  FEA
07B3A:  MOVFF  FEC,3B3
07B3E:  MOVF   FED,F
07B40:  MOVFF  FEF,3B2
07B44:  CLRF   xB7
07B46:  CLRF   xB6
07B48:  MOVFF  3B3,3B5
07B4C:  MOVFF  3B2,3B4
07B50:  MOVLW  13
07B52:  MOVWF  xB8
07B54:  MOVLB  0
07B56:  CALL   5642
....................                 while ((run_flg_x || run_flg_z)); 
07B5A:  MOVLB  1
07B5C:  BTFSC  x1A.4
07B5E:  BRA    7B5C
07B60:  MOVLB  2
07B62:  BTFSS  xC6.1
07B64:  BRA    7B6A
07B66:  MOVLB  0
07B68:  BRA    7B5A
....................                 delay_ms(t_wait[local]); 
07B6A:  BCF    FD8.0
07B6C:  MOVLB  3
07B6E:  RLCF   xAF,W
07B70:  CLRF   03
07B72:  ADDLW  CE
07B74:  MOVWF  FE9
07B76:  MOVLW  00
07B78:  ADDWFC 03,W
07B7A:  MOVWF  FEA
07B7C:  MOVFF  FEC,3B3
07B80:  MOVF   FED,F
07B82:  MOVFF  FEF,3B2
07B86:  MOVFF  3B3,3B4
07B8A:  INCF   xB4,F
07B8C:  DECF   xB4,F
07B8E:  BTFSC  FD8.2
07B90:  BRA    7B9E
07B92:  SETF   xBE
07B94:  MOVLB  0
07B96:  CALL   206E
07B9A:  MOVLB  3
07B9C:  BRA    7B8C
07B9E:  MOVFF  3B2,3BE
07BA2:  MOVLB  0
07BA4:  CALL   206E
....................                 motor_run_z(z[local]-3, 19); 
07BA8:  BCF    FD8.0
07BAA:  MOVLB  3
07BAC:  RLCF   xAF,W
07BAE:  CLRF   03
07BB0:  ADDLW  7E
07BB2:  MOVWF  FE9
07BB4:  MOVLW  00
07BB6:  ADDWFC 03,W
07BB8:  MOVWF  FEA
07BBA:  MOVFF  FEC,3B3
07BBE:  MOVF   FED,F
07BC0:  MOVFF  FEF,3B2
07BC4:  MOVLW  03
07BC6:  SUBWF  xB2,F
07BC8:  MOVLW  00
07BCA:  SUBWFB xB3,F
07BCC:  CLRF   xB7
07BCE:  CLRF   xB6
07BD0:  MOVFF  3B3,3B5
07BD4:  MOVFF  3B2,3B4
07BD8:  MOVLW  13
07BDA:  MOVWF  xB8
07BDC:  MOVLB  0
07BDE:  CALL   5642
....................                 motor_run_z(z[local]+40, 19); 
07BE2:  BCF    FD8.0
07BE4:  MOVLB  3
07BE6:  RLCF   xAF,W
07BE8:  CLRF   03
07BEA:  ADDLW  7E
07BEC:  MOVWF  FE9
07BEE:  MOVLW  00
07BF0:  ADDWFC 03,W
07BF2:  MOVWF  FEA
07BF4:  MOVFF  FEC,3B3
07BF8:  MOVF   FED,F
07BFA:  MOVFF  FEF,3B2
07BFE:  MOVLW  28
07C00:  ADDWF  xB2,F
07C02:  MOVLW  00
07C04:  ADDWFC xB3,F
07C06:  CLRF   xB7
07C08:  CLRF   xB6
07C0A:  MOVFF  3B3,3B5
07C0E:  MOVFF  3B2,3B4
07C12:  MOVLW  13
07C14:  MOVWF  xB8
07C16:  MOVLB  0
07C18:  CALL   5642
....................                 motor_run_z(0, 19); 
07C1C:  MOVLB  3
07C1E:  CLRF   xB7
07C20:  CLRF   xB6
07C22:  CLRF   xB5
07C24:  CLRF   xB4
07C26:  MOVLW  13
07C28:  MOVWF  xB8
07C2A:  MOVLB  0
07C2C:  CALL   5642
....................                 while ((run_flg_x || run_flg_z)); 
07C30:  MOVLB  1
07C32:  BTFSC  x1A.4
07C34:  BRA    7C32
07C36:  MOVLB  2
07C38:  BTFSS  xC6.1
07C3A:  BRA    7C40
07C3C:  MOVLB  0
07C3E:  BRA    7C30
....................             break; 
07C40:  MOVLB  3
07C42:  BRA    7C46
07C44:  MOVLB  3
....................         } 
....................     } 
07C46:  BRA    7C8C
....................     else { 
....................         printf(lcd_putc, "\f"); //limpa display 
07C48:  MOVLW  0C
07C4A:  MOVWF  xBD
07C4C:  MOVLB  0
07C4E:  CALL   2440
....................         printf(lcd_putc, "  POSICAO IRREGULAR \n\r"); 
07C52:  MOVLW  D2
07C54:  MOVWF  FF6
07C56:  MOVLW  0D
07C58:  MOVWF  FF7
07C5A:  CALL   2494
....................         printf(lcd_putc, "   X DEVE SER > 0   \n\r"); 
07C5E:  MOVLW  EA
07C60:  MOVWF  FF6
07C62:  MOVLW  0D
07C64:  MOVWF  FF7
07C66:  CALL   2494
....................         printf(lcd_putc, "  Y DEVE SER > 700  \n\r"); 
07C6A:  MOVLW  02
07C6C:  MOVWF  FF6
07C6E:  MOVLW  0E
07C70:  MOVWF  FF7
07C72:  CALL   2494
....................         delay_ms(5000); 
07C76:  MOVLW  14
07C78:  MOVLB  3
07C7A:  MOVWF  xB2
07C7C:  MOVLW  FA
07C7E:  MOVWF  xBE
07C80:  MOVLB  0
07C82:  CALL   206E
07C86:  MOVLB  3
07C88:  DECFSZ xB2,F
07C8A:  BRA    7C7C
....................     } 
....................     sobe_ferros(ferros); 
07C8C:  MOVFF  3B1,3B2
07C90:  MOVLB  0
07C92:  CALL   6D30
07C96:  GOTO   8466 (RETURN)
.................... } //void soldar_teste(tipo[contador_lcd], contador_lcd) 
.................... void soldar(void){ 
....................     int q; 
....................     int ferros; 
....................     q = (pontos_no_modelo/2); 
*
0967A:  BCF    FD8.0
0967C:  MOVLB  1
0967E:  RRCF   x0A,W
09680:  MOVLB  3
09682:  MOVWF  xAF
....................     for(int i=0; i < pontos_no_modelo; i++){ 
09684:  CLRF   xB1
09686:  MOVLB  1
09688:  MOVF   x0A,W
0968A:  MOVLB  3
0968C:  SUBWF  xB1,W
0968E:  BTFSC  FD8.0
09690:  GOTO   A258
....................         if (i<q){ 
09694:  MOVF   xAF,W
09696:  SUBWF  xB1,W
09698:  BC    96A0
....................             ferros = 3; 
0969A:  MOVLW  03
0969C:  MOVWF  xB0
....................         } else { 
0969E:  BRA    96A4
....................             ferros = 2; 
096A0:  MOVLW  02
096A2:  MOVWF  xB0
....................         } 
....................         desce_ferros(ferros); 
096A4:  MOVFF  3B0,3B2
096A8:  MOVLB  0
096AA:  CALL   6D6C
....................         if (i == 0){ 
096AE:  MOVLB  3
096B0:  MOVF   xB1,F
096B2:  BNZ   96C8
....................             ligar_alimentador_solda(ferros,700); 
096B4:  MOVFF  3B0,3B4
096B8:  MOVLW  02
096BA:  MOVWF  xB6
096BC:  MOVLW  BC
096BE:  MOVWF  xB5
096C0:  MOVLB  0
096C2:  CALL   7088
096C6:  MOVLB  3
....................         } 
....................         if (habilitado[i] == TRUE) { 
096C8:  MOVFF  3B1,3B5
096CC:  MOVLW  01
096CE:  MOVWF  xB7
096D0:  MOVLW  0B
096D2:  MOVWF  xB6
096D4:  MOVLB  0
096D6:  CALL   3A66
096DA:  MOVF   01,W
096DC:  ANDLW  01
096DE:  SUBLW  01
096E0:  BTFSS  FD8.2
096E2:  GOTO   A244
....................             switch (tipo[i]){ 
096E6:  CLRF   03
096E8:  MOVLB  3
096EA:  MOVF   xB1,W
096EC:  ADDLW  F6
096EE:  MOVWF  FE9
096F0:  MOVLW  00
096F2:  ADDWFC 03,W
096F4:  MOVWF  FEA
096F6:  MOVF   FEF,W
096F8:  ADDLW  FC
096FA:  BTFSC  FD8.0
096FC:  GOTO   A246
09700:  ADDLW  04
09702:  MOVLB  0
09704:  GOTO   A25E
....................                 case 0: 
....................                     motor_run_y(y[i], 19); 
09708:  BCF    FD8.0
0970A:  MOVLB  3
0970C:  RLCF   xB1,W
0970E:  CLRF   03
09710:  ADDLW  56
09712:  MOVWF  FE9
09714:  MOVLW  00
09716:  ADDWFC 03,W
09718:  MOVWF  FEA
0971A:  MOVFF  FEC,3B3
0971E:  MOVF   FED,F
09720:  MOVFF  FEF,3B2
09724:  CLRF   xB7
09726:  CLRF   xB6
09728:  MOVFF  3B3,3B5
0972C:  MOVFF  3B2,3B4
09730:  MOVLW  13
09732:  MOVWF  xB8
09734:  MOVLB  0
09736:  CALL   580C
....................                     motor_run_x(x[i], 19); 
0973A:  BCF    FD8.0
0973C:  MOVLB  3
0973E:  RLCF   xB1,W
09740:  CLRF   03
09742:  ADDLW  2E
09744:  MOVWF  FE9
09746:  MOVLW  00
09748:  ADDWFC 03,W
0974A:  MOVWF  FEA
0974C:  MOVFF  FEC,3B3
09750:  MOVF   FED,F
09752:  MOVFF  FEF,3B2
09756:  CLRF   xB7
09758:  CLRF   xB6
0975A:  MOVFF  3B3,3B5
0975E:  MOVFF  3B2,3B4
09762:  MOVLW  13
09764:  MOVWF  xB8
09766:  MOVLB  0
09768:  CALL   4ABC
....................                     while ((run_flg_x || run_flg_y)); 
0976C:  MOVLB  1
0976E:  BTFSC  x1A.4
09770:  BRA    976E
09772:  BTFSC  x1A.6
09774:  BRA    976E
....................                     if (habilitado[0] == 0){ 
09776:  BTFSC  x0B.0
09778:  BRA    979A
....................                         if (i == q){ 
0977A:  MOVLB  3
0977C:  MOVF   xAF,W
0977E:  SUBWF  xB1,W
09780:  BNZ   9796
....................                             ligar_alimentador_solda(ferros,700); 
09782:  MOVFF  3B0,3B4
09786:  MOVLW  02
09788:  MOVWF  xB6
0978A:  MOVLW  BC
0978C:  MOVWF  xB5
0978E:  MOVLB  0
09790:  CALL   7088
09794:  MOVLB  3
....................                         } 
....................                     } else { 
09796:  BRA    97B4
09798:  MOVLB  1
....................                         if(i == 0){ 
0979A:  MOVLB  3
0979C:  MOVF   xB1,F
0979E:  BNZ   97B4
....................                             ligar_alimentador_solda(ferros,700); 
097A0:  MOVFF  3B0,3B4
097A4:  MOVLW  02
097A6:  MOVWF  xB6
097A8:  MOVLW  BC
097AA:  MOVWF  xB5
097AC:  MOVLB  0
097AE:  CALL   7088
097B2:  MOVLB  3
....................                         } 
....................                     } 
....................                     ligar_alimentador_solda(ferros,t_solda[i]); 
097B4:  BCF    FD8.0
097B6:  RLCF   xB1,W
097B8:  CLRF   03
097BA:  ADDLW  A6
097BC:  MOVWF  FE9
097BE:  MOVLW  00
097C0:  ADDWFC 03,W
097C2:  MOVWF  FEA
097C4:  MOVFF  FEC,3B3
097C8:  MOVF   FED,F
097CA:  MOVFF  FEF,3B2
097CE:  MOVFF  3B0,3B4
097D2:  MOVFF  3B3,3B6
097D6:  MOVFF  3B2,3B5
097DA:  MOVLB  0
097DC:  CALL   7088
....................                     motor_run_z(z[i], 19); 
097E0:  BCF    FD8.0
097E2:  MOVLB  3
097E4:  RLCF   xB1,W
097E6:  CLRF   03
097E8:  ADDLW  7E
097EA:  MOVWF  FE9
097EC:  MOVLW  00
097EE:  ADDWFC 03,W
097F0:  MOVWF  FEA
097F2:  MOVFF  FEC,3B3
097F6:  MOVF   FED,F
097F8:  MOVFF  FEF,3B2
097FC:  CLRF   xB7
097FE:  CLRF   xB6
09800:  MOVFF  3B3,3B5
09804:  MOVFF  3B2,3B4
09808:  MOVLW  13
0980A:  MOVWF  xB8
0980C:  MOVLB  0
0980E:  CALL   5642
....................                     while ((run_flg_z)); 
09812:  MOVLB  2
09814:  BTFSC  xC6.1
09816:  BRA    9814
....................                     delay_ms(t_wait[i]);  
09818:  BCF    FD8.0
0981A:  MOVLB  3
0981C:  RLCF   xB1,W
0981E:  CLRF   03
09820:  ADDLW  CE
09822:  MOVWF  FE9
09824:  MOVLW  00
09826:  ADDWFC 03,W
09828:  MOVWF  FEA
0982A:  MOVFF  FEC,3B3
0982E:  MOVF   FED,F
09830:  MOVFF  FEF,3B2
09834:  MOVFF  3B3,3B4
09838:  INCF   xB4,F
0983A:  DECF   xB4,F
0983C:  BTFSC  FD8.2
0983E:  BRA    984C
09840:  SETF   xBE
09842:  MOVLB  0
09844:  CALL   206E
09848:  MOVLB  3
0984A:  BRA    983A
0984C:  MOVFF  3B2,3BE
09850:  MOVLB  0
09852:  CALL   206E
....................                     motor_run_z(0, 19); 
09856:  MOVLB  3
09858:  CLRF   xB7
0985A:  CLRF   xB6
0985C:  CLRF   xB5
0985E:  CLRF   xB4
09860:  MOVLW  13
09862:  MOVWF  xB8
09864:  MOVLB  0
09866:  CALL   5642
....................                     while ((run_flg_z)); 
0986A:  MOVLB  2
0986C:  BTFSC  xC6.1
0986E:  BRA    986C
....................                 break; 
09870:  MOVLB  3
09872:  GOTO   A246
....................                 case 1: 
....................                     motor_run_y(y[i], 19); 
09876:  BCF    FD8.0
09878:  MOVLB  3
0987A:  RLCF   xB1,W
0987C:  CLRF   03
0987E:  ADDLW  56
09880:  MOVWF  FE9
09882:  MOVLW  00
09884:  ADDWFC 03,W
09886:  MOVWF  FEA
09888:  MOVFF  FEC,3B3
0988C:  MOVF   FED,F
0988E:  MOVFF  FEF,3B2
09892:  CLRF   xB7
09894:  CLRF   xB6
09896:  MOVFF  3B3,3B5
0989A:  MOVFF  3B2,3B4
0989E:  MOVLW  13
098A0:  MOVWF  xB8
098A2:  MOVLB  0
098A4:  CALL   580C
....................                     motor_run_x(x[i], 19); 
098A8:  BCF    FD8.0
098AA:  MOVLB  3
098AC:  RLCF   xB1,W
098AE:  CLRF   03
098B0:  ADDLW  2E
098B2:  MOVWF  FE9
098B4:  MOVLW  00
098B6:  ADDWFC 03,W
098B8:  MOVWF  FEA
098BA:  MOVFF  FEC,3B3
098BE:  MOVF   FED,F
098C0:  MOVFF  FEF,3B2
098C4:  CLRF   xB7
098C6:  CLRF   xB6
098C8:  MOVFF  3B3,3B5
098CC:  MOVFF  3B2,3B4
098D0:  MOVLW  13
098D2:  MOVWF  xB8
098D4:  MOVLB  0
098D6:  CALL   4ABC
....................                     while ((run_flg_x || run_flg_y)); 
098DA:  MOVLB  1
098DC:  BTFSC  x1A.4
098DE:  BRA    98DC
098E0:  BTFSC  x1A.6
098E2:  BRA    98DC
....................                     if (habilitado[0] == 0){ 
098E4:  BTFSC  x0B.0
098E6:  BRA    9914
....................                         if (i == q){ 
098E8:  MOVLB  3
098EA:  MOVF   xAF,W
098EC:  SUBWF  xB1,W
098EE:  BNZ   9910
....................                             ligar_alimentador_solda(ferros,700); 
098F0:  MOVFF  3B0,3B4
098F4:  MOVLW  02
098F6:  MOVWF  xB6
098F8:  MOVLW  BC
098FA:  MOVWF  xB5
098FC:  MOVLB  0
098FE:  CALL   7088
....................                             delay_ms(200); 
09902:  MOVLW  C8
09904:  MOVLB  3
09906:  MOVWF  xBE
09908:  MOVLB  0
0990A:  CALL   206E
0990E:  MOVLB  3
....................                         } 
....................                     } else { 
09910:  BRA    993A
09912:  MOVLB  1
....................                         if(i == 0){ 
09914:  MOVLB  3
09916:  MOVF   xB1,F
09918:  BNZ   993A
....................                             ligar_alimentador_solda(ferros,700); 
0991A:  MOVFF  3B0,3B4
0991E:  MOVLW  02
09920:  MOVWF  xB6
09922:  MOVLW  BC
09924:  MOVWF  xB5
09926:  MOVLB  0
09928:  CALL   7088
....................                             delay_ms(200); 
0992C:  MOVLW  C8
0992E:  MOVLB  3
09930:  MOVWF  xBE
09932:  MOVLB  0
09934:  CALL   206E
09938:  MOVLB  3
....................                         } 
....................                     } 
....................                     ligar_alimentador_solda(ferros,t_solda[i]); 
0993A:  BCF    FD8.0
0993C:  RLCF   xB1,W
0993E:  CLRF   03
09940:  ADDLW  A6
09942:  MOVWF  FE9
09944:  MOVLW  00
09946:  ADDWFC 03,W
09948:  MOVWF  FEA
0994A:  MOVFF  FEC,3B3
0994E:  MOVF   FED,F
09950:  MOVFF  FEF,3B2
09954:  MOVFF  3B0,3B4
09958:  MOVFF  3B3,3B6
0995C:  MOVFF  3B2,3B5
09960:  MOVLB  0
09962:  CALL   7088
....................                     motor_run_z(z[i]-20, 19); 
09966:  BCF    FD8.0
09968:  MOVLB  3
0996A:  RLCF   xB1,W
0996C:  CLRF   03
0996E:  ADDLW  7E
09970:  MOVWF  FE9
09972:  MOVLW  00
09974:  ADDWFC 03,W
09976:  MOVWF  FEA
09978:  MOVFF  FEC,3B3
0997C:  MOVF   FED,F
0997E:  MOVFF  FEF,3B2
09982:  MOVLW  14
09984:  SUBWF  xB2,F
09986:  MOVLW  00
09988:  SUBWFB xB3,F
0998A:  CLRF   xB7
0998C:  CLRF   xB6
0998E:  MOVFF  3B3,3B5
09992:  MOVFF  3B2,3B4
09996:  MOVLW  13
09998:  MOVWF  xB8
0999A:  MOVLB  0
0999C:  CALL   5642
....................                     motor_run_y(y[i]-30, 19); 
099A0:  BCF    FD8.0
099A2:  MOVLB  3
099A4:  RLCF   xB1,W
099A6:  CLRF   03
099A8:  ADDLW  56
099AA:  MOVWF  FE9
099AC:  MOVLW  00
099AE:  ADDWFC 03,W
099B0:  MOVWF  FEA
099B2:  MOVFF  FEC,3B3
099B6:  MOVF   FED,F
099B8:  MOVFF  FEF,3B2
099BC:  MOVLW  1E
099BE:  SUBWF  xB2,F
099C0:  MOVLW  00
099C2:  SUBWFB xB3,F
099C4:  CLRF   xB7
099C6:  CLRF   xB6
099C8:  MOVFF  3B3,3B5
099CC:  MOVFF  3B2,3B4
099D0:  MOVLW  13
099D2:  MOVWF  xB8
099D4:  MOVLB  0
099D6:  CALL   580C
....................                     motor_run_y(y[i], 19); 
099DA:  BCF    FD8.0
099DC:  MOVLB  3
099DE:  RLCF   xB1,W
099E0:  CLRF   03
099E2:  ADDLW  56
099E4:  MOVWF  FE9
099E6:  MOVLW  00
099E8:  ADDWFC 03,W
099EA:  MOVWF  FEA
099EC:  MOVFF  FEC,3B3
099F0:  MOVF   FED,F
099F2:  MOVFF  FEF,3B2
099F6:  CLRF   xB7
099F8:  CLRF   xB6
099FA:  MOVFF  3B3,3B5
099FE:  MOVFF  3B2,3B4
09A02:  MOVLW  13
09A04:  MOVWF  xB8
09A06:  MOVLB  0
09A08:  CALL   580C
....................                     motor_run_x(x[i]+10, 19); 
09A0C:  BCF    FD8.0
09A0E:  MOVLB  3
09A10:  RLCF   xB1,W
09A12:  CLRF   03
09A14:  ADDLW  2E
09A16:  MOVWF  FE9
09A18:  MOVLW  00
09A1A:  ADDWFC 03,W
09A1C:  MOVWF  FEA
09A1E:  MOVFF  FEC,3B3
09A22:  MOVF   FED,F
09A24:  MOVFF  FEF,3B2
09A28:  MOVLW  0A
09A2A:  ADDWF  xB2,F
09A2C:  MOVLW  00
09A2E:  ADDWFC xB3,F
09A30:  CLRF   xB7
09A32:  CLRF   xB6
09A34:  MOVFF  3B3,3B5
09A38:  MOVFF  3B2,3B4
09A3C:  MOVLW  13
09A3E:  MOVWF  xB8
09A40:  MOVLB  0
09A42:  CALL   4ABC
....................                     motor_run_z(z[i], 19); 
09A46:  BCF    FD8.0
09A48:  MOVLB  3
09A4A:  RLCF   xB1,W
09A4C:  CLRF   03
09A4E:  ADDLW  7E
09A50:  MOVWF  FE9
09A52:  MOVLW  00
09A54:  ADDWFC 03,W
09A56:  MOVWF  FEA
09A58:  MOVFF  FEC,3B3
09A5C:  MOVF   FED,F
09A5E:  MOVFF  FEF,3B2
09A62:  CLRF   xB7
09A64:  CLRF   xB6
09A66:  MOVFF  3B3,3B5
09A6A:  MOVFF  3B2,3B4
09A6E:  MOVLW  13
09A70:  MOVWF  xB8
09A72:  MOVLB  0
09A74:  CALL   5642
....................                     motor_run_x(x[i], 19); 
09A78:  BCF    FD8.0
09A7A:  MOVLB  3
09A7C:  RLCF   xB1,W
09A7E:  CLRF   03
09A80:  ADDLW  2E
09A82:  MOVWF  FE9
09A84:  MOVLW  00
09A86:  ADDWFC 03,W
09A88:  MOVWF  FEA
09A8A:  MOVFF  FEC,3B3
09A8E:  MOVF   FED,F
09A90:  MOVFF  FEF,3B2
09A94:  CLRF   xB7
09A96:  CLRF   xB6
09A98:  MOVFF  3B3,3B5
09A9C:  MOVFF  3B2,3B4
09AA0:  MOVLW  13
09AA2:  MOVWF  xB8
09AA4:  MOVLB  0
09AA6:  CALL   4ABC
....................                     while ((run_flg_x || run_flg_y || run_flg_z)); 
09AAA:  MOVLB  1
09AAC:  BTFSC  x1A.4
09AAE:  BRA    9AAC
09AB0:  BTFSC  x1A.6
09AB2:  BRA    9AAC
09AB4:  MOVLB  2
09AB6:  BTFSS  xC6.1
09AB8:  BRA    9ABE
09ABA:  MOVLB  0
09ABC:  BRA    9AAA
....................                     delay_ms(t_wait[i]);              
09ABE:  BCF    FD8.0
09AC0:  MOVLB  3
09AC2:  RLCF   xB1,W
09AC4:  CLRF   03
09AC6:  ADDLW  CE
09AC8:  MOVWF  FE9
09ACA:  MOVLW  00
09ACC:  ADDWFC 03,W
09ACE:  MOVWF  FEA
09AD0:  MOVFF  FEC,3B3
09AD4:  MOVF   FED,F
09AD6:  MOVFF  FEF,3B2
09ADA:  MOVFF  3B3,3B4
09ADE:  INCF   xB4,F
09AE0:  DECF   xB4,F
09AE2:  BTFSC  FD8.2
09AE4:  BRA    9AF2
09AE6:  SETF   xBE
09AE8:  MOVLB  0
09AEA:  CALL   206E
09AEE:  MOVLB  3
09AF0:  BRA    9AE0
09AF2:  MOVFF  3B2,3BE
09AF6:  MOVLB  0
09AF8:  CALL   206E
....................                     motor_run_z(0, 19); 
09AFC:  MOVLB  3
09AFE:  CLRF   xB7
09B00:  CLRF   xB6
09B02:  CLRF   xB5
09B04:  CLRF   xB4
09B06:  MOVLW  13
09B08:  MOVWF  xB8
09B0A:  MOVLB  0
09B0C:  CALL   5642
....................                     while ((run_flg_z)); 
09B10:  MOVLB  2
09B12:  BTFSC  xC6.1
09B14:  BRA    9B12
....................                 break; 
09B16:  MOVLB  3
09B18:  BRA    A246
....................                 case 2: 
....................                     motor_run_y(y[i], 19); 
09B1A:  BCF    FD8.0
09B1C:  MOVLB  3
09B1E:  RLCF   xB1,W
09B20:  CLRF   03
09B22:  ADDLW  56
09B24:  MOVWF  FE9
09B26:  MOVLW  00
09B28:  ADDWFC 03,W
09B2A:  MOVWF  FEA
09B2C:  MOVFF  FEC,3B3
09B30:  MOVF   FED,F
09B32:  MOVFF  FEF,3B2
09B36:  CLRF   xB7
09B38:  CLRF   xB6
09B3A:  MOVFF  3B3,3B5
09B3E:  MOVFF  3B2,3B4
09B42:  MOVLW  13
09B44:  MOVWF  xB8
09B46:  MOVLB  0
09B48:  CALL   580C
....................                     motor_run_x(x[i], 19); 
09B4C:  BCF    FD8.0
09B4E:  MOVLB  3
09B50:  RLCF   xB1,W
09B52:  CLRF   03
09B54:  ADDLW  2E
09B56:  MOVWF  FE9
09B58:  MOVLW  00
09B5A:  ADDWFC 03,W
09B5C:  MOVWF  FEA
09B5E:  MOVFF  FEC,3B3
09B62:  MOVF   FED,F
09B64:  MOVFF  FEF,3B2
09B68:  CLRF   xB7
09B6A:  CLRF   xB6
09B6C:  MOVFF  3B3,3B5
09B70:  MOVFF  3B2,3B4
09B74:  MOVLW  13
09B76:  MOVWF  xB8
09B78:  MOVLB  0
09B7A:  CALL   4ABC
....................                     while ((run_flg_x || run_flg_y)); 
09B7E:  MOVLB  1
09B80:  BTFSC  x1A.4
09B82:  BRA    9B80
09B84:  BTFSC  x1A.6
09B86:  BRA    9B80
....................                     if (habilitado[0] == 0){ 
09B88:  BTFSC  x0B.0
09B8A:  BRA    9BAC
....................                         if (i == q){ 
09B8C:  MOVLB  3
09B8E:  MOVF   xAF,W
09B90:  SUBWF  xB1,W
09B92:  BNZ   9BA8
....................                             ligar_alimentador_solda(ferros,700); 
09B94:  MOVFF  3B0,3B4
09B98:  MOVLW  02
09B9A:  MOVWF  xB6
09B9C:  MOVLW  BC
09B9E:  MOVWF  xB5
09BA0:  MOVLB  0
09BA2:  CALL   7088
09BA6:  MOVLB  3
....................                         } 
....................                     } else { 
09BA8:  BRA    9BC6
09BAA:  MOVLB  1
....................                         if(i == 0){ 
09BAC:  MOVLB  3
09BAE:  MOVF   xB1,F
09BB0:  BNZ   9BC6
....................                             ligar_alimentador_solda(ferros,700); 
09BB2:  MOVFF  3B0,3B4
09BB6:  MOVLW  02
09BB8:  MOVWF  xB6
09BBA:  MOVLW  BC
09BBC:  MOVWF  xB5
09BBE:  MOVLB  0
09BC0:  CALL   7088
09BC4:  MOVLB  3
....................                         } 
....................                     } 
....................                     ligar_alimentador_solda(ferros,t_solda[i]); 
09BC6:  BCF    FD8.0
09BC8:  RLCF   xB1,W
09BCA:  CLRF   03
09BCC:  ADDLW  A6
09BCE:  MOVWF  FE9
09BD0:  MOVLW  00
09BD2:  ADDWFC 03,W
09BD4:  MOVWF  FEA
09BD6:  MOVFF  FEC,3B3
09BDA:  MOVF   FED,F
09BDC:  MOVFF  FEF,3B2
09BE0:  MOVFF  3B0,3B4
09BE4:  MOVFF  3B3,3B6
09BE8:  MOVFF  3B2,3B5
09BEC:  MOVLB  0
09BEE:  CALL   7088
....................                     motor_run_z(z[i], 19); 
09BF2:  BCF    FD8.0
09BF4:  MOVLB  3
09BF6:  RLCF   xB1,W
09BF8:  CLRF   03
09BFA:  ADDLW  7E
09BFC:  MOVWF  FE9
09BFE:  MOVLW  00
09C00:  ADDWFC 03,W
09C02:  MOVWF  FEA
09C04:  MOVFF  FEC,3B3
09C08:  MOVF   FED,F
09C0A:  MOVFF  FEF,3B2
09C0E:  CLRF   xB7
09C10:  CLRF   xB6
09C12:  MOVFF  3B3,3B5
09C16:  MOVFF  3B2,3B4
09C1A:  MOVLW  13
09C1C:  MOVWF  xB8
09C1E:  MOVLB  0
09C20:  CALL   5642
....................                     while ((run_flg_z)); 
09C24:  MOVLB  2
09C26:  BTFSC  xC6.1
09C28:  BRA    9C26
....................                     delay_ms(t_wait[i]); 
09C2A:  BCF    FD8.0
09C2C:  MOVLB  3
09C2E:  RLCF   xB1,W
09C30:  CLRF   03
09C32:  ADDLW  CE
09C34:  MOVWF  FE9
09C36:  MOVLW  00
09C38:  ADDWFC 03,W
09C3A:  MOVWF  FEA
09C3C:  MOVFF  FEC,3B3
09C40:  MOVF   FED,F
09C42:  MOVFF  FEF,3B2
09C46:  MOVFF  3B3,3B4
09C4A:  INCF   xB4,F
09C4C:  DECF   xB4,F
09C4E:  BTFSC  FD8.2
09C50:  BRA    9C5E
09C52:  SETF   xBE
09C54:  MOVLB  0
09C56:  CALL   206E
09C5A:  MOVLB  3
09C5C:  BRA    9C4C
09C5E:  MOVFF  3B2,3BE
09C62:  MOVLB  0
09C64:  CALL   206E
....................                     motor_run_z(z[i]-3, 19); 
09C68:  BCF    FD8.0
09C6A:  MOVLB  3
09C6C:  RLCF   xB1,W
09C6E:  CLRF   03
09C70:  ADDLW  7E
09C72:  MOVWF  FE9
09C74:  MOVLW  00
09C76:  ADDWFC 03,W
09C78:  MOVWF  FEA
09C7A:  MOVFF  FEC,3B3
09C7E:  MOVF   FED,F
09C80:  MOVFF  FEF,3B2
09C84:  MOVLW  03
09C86:  SUBWF  xB2,F
09C88:  MOVLW  00
09C8A:  SUBWFB xB3,F
09C8C:  CLRF   xB7
09C8E:  CLRF   xB6
09C90:  MOVFF  3B3,3B5
09C94:  MOVFF  3B2,3B4
09C98:  MOVLW  13
09C9A:  MOVWF  xB8
09C9C:  MOVLB  0
09C9E:  CALL   5642
....................                     motor_run_x(x[i]-10, 19); 
09CA2:  BCF    FD8.0
09CA4:  MOVLB  3
09CA6:  RLCF   xB1,W
09CA8:  CLRF   03
09CAA:  ADDLW  2E
09CAC:  MOVWF  FE9
09CAE:  MOVLW  00
09CB0:  ADDWFC 03,W
09CB2:  MOVWF  FEA
09CB4:  MOVFF  FEC,3B3
09CB8:  MOVF   FED,F
09CBA:  MOVFF  FEF,3B2
09CBE:  MOVLW  0A
09CC0:  SUBWF  xB2,F
09CC2:  MOVLW  00
09CC4:  SUBWFB xB3,F
09CC6:  CLRF   xB7
09CC8:  CLRF   xB6
09CCA:  MOVFF  3B3,3B5
09CCE:  MOVFF  3B2,3B4
09CD2:  MOVLW  13
09CD4:  MOVWF  xB8
09CD6:  MOVLB  0
09CD8:  CALL   4ABC
....................                     motor_run_z(z[i], 19); 
09CDC:  BCF    FD8.0
09CDE:  MOVLB  3
09CE0:  RLCF   xB1,W
09CE2:  CLRF   03
09CE4:  ADDLW  7E
09CE6:  MOVWF  FE9
09CE8:  MOVLW  00
09CEA:  ADDWFC 03,W
09CEC:  MOVWF  FEA
09CEE:  MOVFF  FEC,3B3
09CF2:  MOVF   FED,F
09CF4:  MOVFF  FEF,3B2
09CF8:  CLRF   xB7
09CFA:  CLRF   xB6
09CFC:  MOVFF  3B3,3B5
09D00:  MOVFF  3B2,3B4
09D04:  MOVLW  13
09D06:  MOVWF  xB8
09D08:  MOVLB  0
09D0A:  CALL   5642
....................                     while ((run_flg_x || run_flg_y || run_flg_z)); 
09D0E:  MOVLB  1
09D10:  BTFSC  x1A.4
09D12:  BRA    9D10
09D14:  BTFSC  x1A.6
09D16:  BRA    9D10
09D18:  MOVLB  2
09D1A:  BTFSS  xC6.1
09D1C:  BRA    9D22
09D1E:  MOVLB  0
09D20:  BRA    9D0E
....................                     delay_ms(t_wait[i]);   
09D22:  BCF    FD8.0
09D24:  MOVLB  3
09D26:  RLCF   xB1,W
09D28:  CLRF   03
09D2A:  ADDLW  CE
09D2C:  MOVWF  FE9
09D2E:  MOVLW  00
09D30:  ADDWFC 03,W
09D32:  MOVWF  FEA
09D34:  MOVFF  FEC,3B3
09D38:  MOVF   FED,F
09D3A:  MOVFF  FEF,3B2
09D3E:  MOVFF  3B3,3B4
09D42:  INCF   xB4,F
09D44:  DECF   xB4,F
09D46:  BTFSC  FD8.2
09D48:  BRA    9D56
09D4A:  SETF   xBE
09D4C:  MOVLB  0
09D4E:  CALL   206E
09D52:  MOVLB  3
09D54:  BRA    9D44
09D56:  MOVFF  3B2,3BE
09D5A:  MOVLB  0
09D5C:  CALL   206E
....................                     motor_run_z(z[i]-3, 19); 
09D60:  BCF    FD8.0
09D62:  MOVLB  3
09D64:  RLCF   xB1,W
09D66:  CLRF   03
09D68:  ADDLW  7E
09D6A:  MOVWF  FE9
09D6C:  MOVLW  00
09D6E:  ADDWFC 03,W
09D70:  MOVWF  FEA
09D72:  MOVFF  FEC,3B3
09D76:  MOVF   FED,F
09D78:  MOVFF  FEF,3B2
09D7C:  MOVLW  03
09D7E:  SUBWF  xB2,F
09D80:  MOVLW  00
09D82:  SUBWFB xB3,F
09D84:  CLRF   xB7
09D86:  CLRF   xB6
09D88:  MOVFF  3B3,3B5
09D8C:  MOVFF  3B2,3B4
09D90:  MOVLW  13
09D92:  MOVWF  xB8
09D94:  MOVLB  0
09D96:  CALL   5642
....................                     motor_run_x(x[i]+10, 19); 
09D9A:  BCF    FD8.0
09D9C:  MOVLB  3
09D9E:  RLCF   xB1,W
09DA0:  CLRF   03
09DA2:  ADDLW  2E
09DA4:  MOVWF  FE9
09DA6:  MOVLW  00
09DA8:  ADDWFC 03,W
09DAA:  MOVWF  FEA
09DAC:  MOVFF  FEC,3B3
09DB0:  MOVF   FED,F
09DB2:  MOVFF  FEF,3B2
09DB6:  MOVLW  0A
09DB8:  ADDWF  xB2,F
09DBA:  MOVLW  00
09DBC:  ADDWFC xB3,F
09DBE:  CLRF   xB7
09DC0:  CLRF   xB6
09DC2:  MOVFF  3B3,3B5
09DC6:  MOVFF  3B2,3B4
09DCA:  MOVLW  13
09DCC:  MOVWF  xB8
09DCE:  MOVLB  0
09DD0:  CALL   4ABC
....................                     motor_run_z(z[i], 19); 
09DD4:  BCF    FD8.0
09DD6:  MOVLB  3
09DD8:  RLCF   xB1,W
09DDA:  CLRF   03
09DDC:  ADDLW  7E
09DDE:  MOVWF  FE9
09DE0:  MOVLW  00
09DE2:  ADDWFC 03,W
09DE4:  MOVWF  FEA
09DE6:  MOVFF  FEC,3B3
09DEA:  MOVF   FED,F
09DEC:  MOVFF  FEF,3B2
09DF0:  CLRF   xB7
09DF2:  CLRF   xB6
09DF4:  MOVFF  3B3,3B5
09DF8:  MOVFF  3B2,3B4
09DFC:  MOVLW  13
09DFE:  MOVWF  xB8
09E00:  MOVLB  0
09E02:  CALL   5642
....................                     while ((run_flg_x || run_flg_z)); 
09E06:  MOVLB  1
09E08:  BTFSC  x1A.4
09E0A:  BRA    9E08
09E0C:  MOVLB  2
09E0E:  BTFSS  xC6.1
09E10:  BRA    9E16
09E12:  MOVLB  0
09E14:  BRA    9E06
....................                     delay_ms(t_wait[i]); 
09E16:  BCF    FD8.0
09E18:  MOVLB  3
09E1A:  RLCF   xB1,W
09E1C:  CLRF   03
09E1E:  ADDLW  CE
09E20:  MOVWF  FE9
09E22:  MOVLW  00
09E24:  ADDWFC 03,W
09E26:  MOVWF  FEA
09E28:  MOVFF  FEC,3B3
09E2C:  MOVF   FED,F
09E2E:  MOVFF  FEF,3B2
09E32:  MOVFF  3B3,3B4
09E36:  INCF   xB4,F
09E38:  DECF   xB4,F
09E3A:  BTFSC  FD8.2
09E3C:  BRA    9E4A
09E3E:  SETF   xBE
09E40:  MOVLB  0
09E42:  CALL   206E
09E46:  MOVLB  3
09E48:  BRA    9E38
09E4A:  MOVFF  3B2,3BE
09E4E:  MOVLB  0
09E50:  CALL   206E
....................                     motor_run_z(0, 19); 
09E54:  MOVLB  3
09E56:  CLRF   xB7
09E58:  CLRF   xB6
09E5A:  CLRF   xB5
09E5C:  CLRF   xB4
09E5E:  MOVLW  13
09E60:  MOVWF  xB8
09E62:  MOVLB  0
09E64:  CALL   5642
....................                     while ((run_flg_z));                     
09E68:  MOVLB  2
09E6A:  BTFSC  xC6.1
09E6C:  BRA    9E6A
....................                 break; 
09E6E:  MOVLB  3
09E70:  BRA    A246
....................                 case 3:                     
....................                     motor_run_y(y[i], 19); 
09E72:  BCF    FD8.0
09E74:  MOVLB  3
09E76:  RLCF   xB1,W
09E78:  CLRF   03
09E7A:  ADDLW  56
09E7C:  MOVWF  FE9
09E7E:  MOVLW  00
09E80:  ADDWFC 03,W
09E82:  MOVWF  FEA
09E84:  MOVFF  FEC,3B3
09E88:  MOVF   FED,F
09E8A:  MOVFF  FEF,3B2
09E8E:  CLRF   xB7
09E90:  CLRF   xB6
09E92:  MOVFF  3B3,3B5
09E96:  MOVFF  3B2,3B4
09E9A:  MOVLW  13
09E9C:  MOVWF  xB8
09E9E:  MOVLB  0
09EA0:  CALL   580C
....................                     motor_run_x(x[i], 19); 
09EA4:  BCF    FD8.0
09EA6:  MOVLB  3
09EA8:  RLCF   xB1,W
09EAA:  CLRF   03
09EAC:  ADDLW  2E
09EAE:  MOVWF  FE9
09EB0:  MOVLW  00
09EB2:  ADDWFC 03,W
09EB4:  MOVWF  FEA
09EB6:  MOVFF  FEC,3B3
09EBA:  MOVF   FED,F
09EBC:  MOVFF  FEF,3B2
09EC0:  CLRF   xB7
09EC2:  CLRF   xB6
09EC4:  MOVFF  3B3,3B5
09EC8:  MOVFF  3B2,3B4
09ECC:  MOVLW  13
09ECE:  MOVWF  xB8
09ED0:  MOVLB  0
09ED2:  CALL   4ABC
....................                     while ((run_flg_x || run_flg_y)); 
09ED6:  MOVLB  1
09ED8:  BTFSC  x1A.4
09EDA:  BRA    9ED8
09EDC:  BTFSC  x1A.6
09EDE:  BRA    9ED8
....................                     if (habilitado[0] == 0){ 
09EE0:  BTFSC  x0B.0
09EE2:  BRA    9F04
....................                         if (i == q){ 
09EE4:  MOVLB  3
09EE6:  MOVF   xAF,W
09EE8:  SUBWF  xB1,W
09EEA:  BNZ   9F00
....................                             ligar_alimentador_solda(ferros,700); 
09EEC:  MOVFF  3B0,3B4
09EF0:  MOVLW  02
09EF2:  MOVWF  xB6
09EF4:  MOVLW  BC
09EF6:  MOVWF  xB5
09EF8:  MOVLB  0
09EFA:  CALL   7088
09EFE:  MOVLB  3
....................                         } 
....................                     } else { 
09F00:  BRA    9F1E
09F02:  MOVLB  1
....................                         if(i == 0){ 
09F04:  MOVLB  3
09F06:  MOVF   xB1,F
09F08:  BNZ   9F1E
....................                             ligar_alimentador_solda(ferros,700); 
09F0A:  MOVFF  3B0,3B4
09F0E:  MOVLW  02
09F10:  MOVWF  xB6
09F12:  MOVLW  BC
09F14:  MOVWF  xB5
09F16:  MOVLB  0
09F18:  CALL   7088
09F1C:  MOVLB  3
....................                         } 
....................                     } 
....................                     ligar_alimentador_solda(ferros,t_solda[i]); 
09F1E:  BCF    FD8.0
09F20:  RLCF   xB1,W
09F22:  CLRF   03
09F24:  ADDLW  A6
09F26:  MOVWF  FE9
09F28:  MOVLW  00
09F2A:  ADDWFC 03,W
09F2C:  MOVWF  FEA
09F2E:  MOVFF  FEC,3B3
09F32:  MOVF   FED,F
09F34:  MOVFF  FEF,3B2
09F38:  MOVFF  3B0,3B4
09F3C:  MOVFF  3B3,3B6
09F40:  MOVFF  3B2,3B5
09F44:  MOVLB  0
09F46:  CALL   7088
....................                     motor_run_z(z[i], 19); 
09F4A:  BCF    FD8.0
09F4C:  MOVLB  3
09F4E:  RLCF   xB1,W
09F50:  CLRF   03
09F52:  ADDLW  7E
09F54:  MOVWF  FE9
09F56:  MOVLW  00
09F58:  ADDWFC 03,W
09F5A:  MOVWF  FEA
09F5C:  MOVFF  FEC,3B3
09F60:  MOVF   FED,F
09F62:  MOVFF  FEF,3B2
09F66:  CLRF   xB7
09F68:  CLRF   xB6
09F6A:  MOVFF  3B3,3B5
09F6E:  MOVFF  3B2,3B4
09F72:  MOVLW  13
09F74:  MOVWF  xB8
09F76:  MOVLB  0
09F78:  CALL   5642
....................                     while ((run_flg_z)); 
09F7C:  MOVLB  2
09F7E:  BTFSC  xC6.1
09F80:  BRA    9F7E
....................                     delay_ms(t_wait[i]); 
09F82:  BCF    FD8.0
09F84:  MOVLB  3
09F86:  RLCF   xB1,W
09F88:  CLRF   03
09F8A:  ADDLW  CE
09F8C:  MOVWF  FE9
09F8E:  MOVLW  00
09F90:  ADDWFC 03,W
09F92:  MOVWF  FEA
09F94:  MOVFF  FEC,3B3
09F98:  MOVF   FED,F
09F9A:  MOVFF  FEF,3B2
09F9E:  MOVFF  3B3,3B4
09FA2:  INCF   xB4,F
09FA4:  DECF   xB4,F
09FA6:  BTFSC  FD8.2
09FA8:  BRA    9FB6
09FAA:  SETF   xBE
09FAC:  MOVLB  0
09FAE:  CALL   206E
09FB2:  MOVLB  3
09FB4:  BRA    9FA4
09FB6:  MOVFF  3B2,3BE
09FBA:  MOVLB  0
09FBC:  CALL   206E
....................                     motor_run_z(z[i]-3, 19); 
09FC0:  BCF    FD8.0
09FC2:  MOVLB  3
09FC4:  RLCF   xB1,W
09FC6:  CLRF   03
09FC8:  ADDLW  7E
09FCA:  MOVWF  FE9
09FCC:  MOVLW  00
09FCE:  ADDWFC 03,W
09FD0:  MOVWF  FEA
09FD2:  MOVFF  FEC,3B3
09FD6:  MOVF   FED,F
09FD8:  MOVFF  FEF,3B2
09FDC:  MOVLW  03
09FDE:  SUBWF  xB2,F
09FE0:  MOVLW  00
09FE2:  SUBWFB xB3,F
09FE4:  CLRF   xB7
09FE6:  CLRF   xB6
09FE8:  MOVFF  3B3,3B5
09FEC:  MOVFF  3B2,3B4
09FF0:  MOVLW  13
09FF2:  MOVWF  xB8
09FF4:  MOVLB  0
09FF6:  CALL   5642
....................                     motor_run_x(x[i]-21, 19); 
09FFA:  BCF    FD8.0
09FFC:  MOVLB  3
09FFE:  RLCF   xB1,W
0A000:  CLRF   03
0A002:  ADDLW  2E
0A004:  MOVWF  FE9
0A006:  MOVLW  00
0A008:  ADDWFC 03,W
0A00A:  MOVWF  FEA
0A00C:  MOVFF  FEC,3B3
0A010:  MOVF   FED,F
0A012:  MOVFF  FEF,3B2
0A016:  MOVLW  15
0A018:  SUBWF  xB2,F
0A01A:  MOVLW  00
0A01C:  SUBWFB xB3,F
0A01E:  CLRF   xB7
0A020:  CLRF   xB6
0A022:  MOVFF  3B3,3B5
0A026:  MOVFF  3B2,3B4
0A02A:  MOVLW  13
0A02C:  MOVWF  xB8
0A02E:  MOVLB  0
0A030:  CALL   4ABC
....................                     motor_run_z(z[i], 19); 
0A034:  BCF    FD8.0
0A036:  MOVLB  3
0A038:  RLCF   xB1,W
0A03A:  CLRF   03
0A03C:  ADDLW  7E
0A03E:  MOVWF  FE9
0A040:  MOVLW  00
0A042:  ADDWFC 03,W
0A044:  MOVWF  FEA
0A046:  MOVFF  FEC,3B3
0A04A:  MOVF   FED,F
0A04C:  MOVFF  FEF,3B2
0A050:  CLRF   xB7
0A052:  CLRF   xB6
0A054:  MOVFF  3B3,3B5
0A058:  MOVFF  3B2,3B4
0A05C:  MOVLW  13
0A05E:  MOVWF  xB8
0A060:  MOVLB  0
0A062:  CALL   5642
....................                     while ((run_flg_x || run_flg_z)); 
0A066:  MOVLB  1
0A068:  BTFSC  x1A.4
0A06A:  BRA    A068
0A06C:  MOVLB  2
0A06E:  BTFSS  xC6.1
0A070:  BRA    A076
0A072:  MOVLB  0
0A074:  BRA    A066
....................                     delay_ms(t_wait[i]);   
0A076:  BCF    FD8.0
0A078:  MOVLB  3
0A07A:  RLCF   xB1,W
0A07C:  CLRF   03
0A07E:  ADDLW  CE
0A080:  MOVWF  FE9
0A082:  MOVLW  00
0A084:  ADDWFC 03,W
0A086:  MOVWF  FEA
0A088:  MOVFF  FEC,3B3
0A08C:  MOVF   FED,F
0A08E:  MOVFF  FEF,3B2
0A092:  MOVFF  3B3,3B4
0A096:  INCF   xB4,F
0A098:  DECF   xB4,F
0A09A:  BTFSC  FD8.2
0A09C:  BRA    A0AA
0A09E:  SETF   xBE
0A0A0:  MOVLB  0
0A0A2:  CALL   206E
0A0A6:  MOVLB  3
0A0A8:  BRA    A098
0A0AA:  MOVFF  3B2,3BE
0A0AE:  MOVLB  0
0A0B0:  CALL   206E
....................                     motor_run_z(z[i]-3, 19); 
0A0B4:  BCF    FD8.0
0A0B6:  MOVLB  3
0A0B8:  RLCF   xB1,W
0A0BA:  CLRF   03
0A0BC:  ADDLW  7E
0A0BE:  MOVWF  FE9
0A0C0:  MOVLW  00
0A0C2:  ADDWFC 03,W
0A0C4:  MOVWF  FEA
0A0C6:  MOVFF  FEC,3B3
0A0CA:  MOVF   FED,F
0A0CC:  MOVFF  FEF,3B2
0A0D0:  MOVLW  03
0A0D2:  SUBWF  xB2,F
0A0D4:  MOVLW  00
0A0D6:  SUBWFB xB3,F
0A0D8:  CLRF   xB7
0A0DA:  CLRF   xB6
0A0DC:  MOVFF  3B3,3B5
0A0E0:  MOVFF  3B2,3B4
0A0E4:  MOVLW  13
0A0E6:  MOVWF  xB8
0A0E8:  MOVLB  0
0A0EA:  CALL   5642
....................                     motor_run_x(x[i]-42, 19); 
0A0EE:  BCF    FD8.0
0A0F0:  MOVLB  3
0A0F2:  RLCF   xB1,W
0A0F4:  CLRF   03
0A0F6:  ADDLW  2E
0A0F8:  MOVWF  FE9
0A0FA:  MOVLW  00
0A0FC:  ADDWFC 03,W
0A0FE:  MOVWF  FEA
0A100:  MOVFF  FEC,3B3
0A104:  MOVF   FED,F
0A106:  MOVFF  FEF,3B2
0A10A:  MOVLW  2A
0A10C:  SUBWF  xB2,F
0A10E:  MOVLW  00
0A110:  SUBWFB xB3,F
0A112:  CLRF   xB7
0A114:  CLRF   xB6
0A116:  MOVFF  3B3,3B5
0A11A:  MOVFF  3B2,3B4
0A11E:  MOVLW  13
0A120:  MOVWF  xB8
0A122:  MOVLB  0
0A124:  CALL   4ABC
....................                     motor_run_z(z[i], 19); 
0A128:  BCF    FD8.0
0A12A:  MOVLB  3
0A12C:  RLCF   xB1,W
0A12E:  CLRF   03
0A130:  ADDLW  7E
0A132:  MOVWF  FE9
0A134:  MOVLW  00
0A136:  ADDWFC 03,W
0A138:  MOVWF  FEA
0A13A:  MOVFF  FEC,3B3
0A13E:  MOVF   FED,F
0A140:  MOVFF  FEF,3B2
0A144:  CLRF   xB7
0A146:  CLRF   xB6
0A148:  MOVFF  3B3,3B5
0A14C:  MOVFF  3B2,3B4
0A150:  MOVLW  13
0A152:  MOVWF  xB8
0A154:  MOVLB  0
0A156:  CALL   5642
....................                     while ((run_flg_x || run_flg_z)); 
0A15A:  MOVLB  1
0A15C:  BTFSC  x1A.4
0A15E:  BRA    A15C
0A160:  MOVLB  2
0A162:  BTFSS  xC6.1
0A164:  BRA    A16A
0A166:  MOVLB  0
0A168:  BRA    A15A
....................                     delay_ms(t_wait[i]); 
0A16A:  BCF    FD8.0
0A16C:  MOVLB  3
0A16E:  RLCF   xB1,W
0A170:  CLRF   03
0A172:  ADDLW  CE
0A174:  MOVWF  FE9
0A176:  MOVLW  00
0A178:  ADDWFC 03,W
0A17A:  MOVWF  FEA
0A17C:  MOVFF  FEC,3B3
0A180:  MOVF   FED,F
0A182:  MOVFF  FEF,3B2
0A186:  MOVFF  3B3,3B4
0A18A:  INCF   xB4,F
0A18C:  DECF   xB4,F
0A18E:  BTFSC  FD8.2
0A190:  BRA    A19E
0A192:  SETF   xBE
0A194:  MOVLB  0
0A196:  CALL   206E
0A19A:  MOVLB  3
0A19C:  BRA    A18C
0A19E:  MOVFF  3B2,3BE
0A1A2:  MOVLB  0
0A1A4:  CALL   206E
....................                     motor_run_z(z[i]-3, 19); 
0A1A8:  BCF    FD8.0
0A1AA:  MOVLB  3
0A1AC:  RLCF   xB1,W
0A1AE:  CLRF   03
0A1B0:  ADDLW  7E
0A1B2:  MOVWF  FE9
0A1B4:  MOVLW  00
0A1B6:  ADDWFC 03,W
0A1B8:  MOVWF  FEA
0A1BA:  MOVFF  FEC,3B3
0A1BE:  MOVF   FED,F
0A1C0:  MOVFF  FEF,3B2
0A1C4:  MOVLW  03
0A1C6:  SUBWF  xB2,F
0A1C8:  MOVLW  00
0A1CA:  SUBWFB xB3,F
0A1CC:  CLRF   xB7
0A1CE:  CLRF   xB6
0A1D0:  MOVFF  3B3,3B5
0A1D4:  MOVFF  3B2,3B4
0A1D8:  MOVLW  13
0A1DA:  MOVWF  xB8
0A1DC:  MOVLB  0
0A1DE:  CALL   5642
....................                     motor_run_z(z[i]+40, 19); 
0A1E2:  BCF    FD8.0
0A1E4:  MOVLB  3
0A1E6:  RLCF   xB1,W
0A1E8:  CLRF   03
0A1EA:  ADDLW  7E
0A1EC:  MOVWF  FE9
0A1EE:  MOVLW  00
0A1F0:  ADDWFC 03,W
0A1F2:  MOVWF  FEA
0A1F4:  MOVFF  FEC,3B3
0A1F8:  MOVF   FED,F
0A1FA:  MOVFF  FEF,3B2
0A1FE:  MOVLW  28
0A200:  ADDWF  xB2,F
0A202:  MOVLW  00
0A204:  ADDWFC xB3,F
0A206:  CLRF   xB7
0A208:  CLRF   xB6
0A20A:  MOVFF  3B3,3B5
0A20E:  MOVFF  3B2,3B4
0A212:  MOVLW  13
0A214:  MOVWF  xB8
0A216:  MOVLB  0
0A218:  CALL   5642
....................                     motor_run_z(0, 19); 
0A21C:  MOVLB  3
0A21E:  CLRF   xB7
0A220:  CLRF   xB6
0A222:  CLRF   xB5
0A224:  CLRF   xB4
0A226:  MOVLW  13
0A228:  MOVWF  xB8
0A22A:  MOVLB  0
0A22C:  CALL   5642
....................                     while ((run_flg_x || run_flg_z));                     
0A230:  MOVLB  1
0A232:  BTFSC  x1A.4
0A234:  BRA    A232
0A236:  MOVLB  2
0A238:  BTFSS  xC6.1
0A23A:  BRA    A240
0A23C:  MOVLB  0
0A23E:  BRA    A230
....................                 break; 
0A240:  MOVLB  3
0A242:  BRA    A246
0A244:  MOVLB  3
....................             } 
....................         } 
....................         sobe_ferros(ferros); 
0A246:  MOVFF  3B0,3B2
0A24A:  MOVLB  0
0A24C:  CALL   6D30
0A250:  MOVLB  3
0A252:  INCF   xB1,F
0A254:  GOTO   9686
....................     } 
0A258:  MOVLB  0
0A25A:  GOTO   A4B8 (RETURN)
.................... } 
....................  
.................... #include "Modelos_maq_1.c" 
.................... int tamPrograma = 221; 
....................  
.................... void ler_modelo_memoria(int modeloSelecionado){ 
*
052A0:  MOVLB  3
052A2:  CLRF   xAE
052A4:  CLRF   xAF
052A6:  MOVLW  01
052A8:  SUBWF  xAD,W
052AA:  MULWF  xAC
052AC:  MOVF   FF3,W
052AE:  CLRF   xB1
052B0:  MOVWF  xB0
....................     int i = 0; 
....................     int j = 0; 
....................     long int endInicial = (modeloSelecionado - 1)* tamPrograma; 
....................     pontos_no_modelo = read_ext_eeprom(endInicial); 
052B2:  MOVFF  3B1,3B8
052B6:  MOVFF  3B0,3B7
052BA:  MOVLB  0
052BC:  CALL   2336
052C0:  MOVFF  01,10A
....................     endInicial++; 
052C4:  MOVLB  3
052C6:  INCF   xB0,F
052C8:  BTFSC  FD8.2
052CA:  INCF   xB1,F
....................     for(i = endInicial; i < (endInicial + tamPrograma) -1; i = i + 11) 
052CC:  MOVFF  3B0,3AE
052D0:  MOVF   xAC,W
052D2:  ADDWF  xB0,W
052D4:  MOVWF  xB3
052D6:  MOVLW  00
052D8:  ADDWFC xB1,W
052DA:  MOVWF  xB4
052DC:  MOVLW  01
052DE:  SUBWF  xB3,W
052E0:  MOVWF  00
052E2:  MOVLW  00
052E4:  SUBWFB xB4,W
052E6:  MOVWF  03
052E8:  MOVFF  00,01
052EC:  MOVF   03,F
052EE:  BNZ   52F8
052F0:  MOVF   01,W
052F2:  SUBWF  xAE,W
052F4:  BTFSC  FD8.0
052F6:  BRA    54DA
....................     { 
....................         x[j] = make16(read_ext_eeprom(i),read_ext_eeprom(i+1)); 
052F8:  BCF    FD8.0
052FA:  RLCF   xAF,W
052FC:  CLRF   03
052FE:  ADDLW  2E
05300:  MOVWF  01
05302:  MOVLW  00
05304:  ADDWFC 03,F
05306:  MOVFF  01,3B3
0530A:  MOVFF  03,3B4
0530E:  CLRF   xB8
05310:  MOVFF  3AE,3B7
05314:  MOVLB  0
05316:  CALL   2336
0531A:  MOVFF  01,3B5
0531E:  MOVLW  01
05320:  MOVLB  3
05322:  ADDWF  xAE,W
05324:  MOVWF  xB6
05326:  CLRF   xB8
05328:  MOVWF  xB7
0532A:  MOVLB  0
0532C:  CALL   2336
05330:  MOVFF  3B4,FEA
05334:  MOVFF  3B3,FE9
05338:  MOVFF  3B5,FEC
0533C:  MOVF   FED,F
0533E:  MOVFF  01,FEF
....................         y[j] = make16(read_ext_eeprom(i+2),read_ext_eeprom(i+3)); 
05342:  BCF    FD8.0
05344:  MOVLB  3
05346:  RLCF   xAF,W
05348:  CLRF   03
0534A:  ADDLW  56
0534C:  MOVWF  01
0534E:  MOVLW  00
05350:  ADDWFC 03,F
05352:  MOVFF  01,3B3
05356:  MOVFF  03,3B4
0535A:  MOVLW  02
0535C:  ADDWF  xAE,W
0535E:  MOVWF  xB5
05360:  CLRF   xB8
05362:  MOVWF  xB7
05364:  MOVLB  0
05366:  CALL   2336
0536A:  MOVFF  01,3B5
0536E:  MOVLW  03
05370:  MOVLB  3
05372:  ADDWF  xAE,W
05374:  MOVWF  xB6
05376:  CLRF   xB8
05378:  MOVWF  xB7
0537A:  MOVLB  0
0537C:  CALL   2336
05380:  MOVFF  3B4,FEA
05384:  MOVFF  3B3,FE9
05388:  MOVFF  3B5,FEC
0538C:  MOVF   FED,F
0538E:  MOVFF  01,FEF
....................         z[j] = make16(read_ext_eeprom(i+4),read_ext_eeprom(i+5)); 
05392:  BCF    FD8.0
05394:  MOVLB  3
05396:  RLCF   xAF,W
05398:  CLRF   03
0539A:  ADDLW  7E
0539C:  MOVWF  01
0539E:  MOVLW  00
053A0:  ADDWFC 03,F
053A2:  MOVFF  01,3B3
053A6:  MOVFF  03,3B4
053AA:  MOVLW  04
053AC:  ADDWF  xAE,W
053AE:  MOVWF  xB5
053B0:  CLRF   xB8
053B2:  MOVWF  xB7
053B4:  MOVLB  0
053B6:  CALL   2336
053BA:  MOVFF  01,3B5
053BE:  MOVLW  05
053C0:  MOVLB  3
053C2:  ADDWF  xAE,W
053C4:  MOVWF  xB6
053C6:  CLRF   xB8
053C8:  MOVWF  xB7
053CA:  MOVLB  0
053CC:  CALL   2336
053D0:  MOVFF  3B4,FEA
053D4:  MOVFF  3B3,FE9
053D8:  MOVFF  3B5,FEC
053DC:  MOVF   FED,F
053DE:  MOVFF  01,FEF
....................         t_solda[j] = make16(read_ext_eeprom(i+6),read_ext_eeprom(i+7)); 
053E2:  BCF    FD8.0
053E4:  MOVLB  3
053E6:  RLCF   xAF,W
053E8:  CLRF   03
053EA:  ADDLW  A6
053EC:  MOVWF  01
053EE:  MOVLW  00
053F0:  ADDWFC 03,F
053F2:  MOVFF  01,3B3
053F6:  MOVFF  03,3B4
053FA:  MOVLW  06
053FC:  ADDWF  xAE,W
053FE:  MOVWF  xB5
05400:  CLRF   xB8
05402:  MOVWF  xB7
05404:  MOVLB  0
05406:  CALL   2336
0540A:  MOVFF  01,3B5
0540E:  MOVLW  07
05410:  MOVLB  3
05412:  ADDWF  xAE,W
05414:  MOVWF  xB6
05416:  CLRF   xB8
05418:  MOVWF  xB7
0541A:  MOVLB  0
0541C:  CALL   2336
05420:  MOVFF  3B4,FEA
05424:  MOVFF  3B3,FE9
05428:  MOVFF  3B5,FEC
0542C:  MOVF   FED,F
0542E:  MOVFF  01,FEF
....................         t_wait[j] = make16(read_ext_eeprom(i+8),read_ext_eeprom(i+9)); 
05432:  BCF    FD8.0
05434:  MOVLB  3
05436:  RLCF   xAF,W
05438:  CLRF   03
0543A:  ADDLW  CE
0543C:  MOVWF  01
0543E:  MOVLW  00
05440:  ADDWFC 03,F
05442:  MOVFF  01,3B3
05446:  MOVFF  03,3B4
0544A:  MOVLW  08
0544C:  ADDWF  xAE,W
0544E:  MOVWF  xB5
05450:  CLRF   xB8
05452:  MOVWF  xB7
05454:  MOVLB  0
05456:  CALL   2336
0545A:  MOVFF  01,3B5
0545E:  MOVLW  09
05460:  MOVLB  3
05462:  ADDWF  xAE,W
05464:  MOVWF  xB6
05466:  CLRF   xB8
05468:  MOVWF  xB7
0546A:  MOVLB  0
0546C:  CALL   2336
05470:  MOVFF  3B4,FEA
05474:  MOVFF  3B3,FE9
05478:  MOVFF  3B5,FEC
0547C:  MOVF   FED,F
0547E:  MOVFF  01,FEF
....................         int tipoHabilitado = read_ext_eeprom(i+10); 
05482:  MOVLW  0A
05484:  MOVLB  3
05486:  ADDWF  xAE,W
05488:  MOVWF  xB3
0548A:  CLRF   xB8
0548C:  MOVWF  xB7
0548E:  MOVLB  0
05490:  CALL   2336
05494:  MOVFF  01,3B2
....................         tipo[j] = (tipoHabilitado & 0x06)>>1; 
05498:  CLRF   03
0549A:  MOVLB  3
0549C:  MOVF   xAF,W
0549E:  ADDLW  F6
054A0:  MOVWF  FE9
054A2:  MOVLW  00
054A4:  ADDWFC 03,W
054A6:  MOVWF  FEA
054A8:  MOVF   xB2,W
054AA:  ANDLW  06
054AC:  MOVWF  00
054AE:  BCF    FD8.0
054B0:  RRCF   00,F
054B2:  MOVFF  00,FEF
....................         habilitado[j] = tipoHabilitado & 0x01; 
054B6:  MOVF   xB2,W
054B8:  ANDLW  01
054BA:  MOVWF  xB3
054BC:  MOVFF  3AF,3B5
054C0:  MOVWF  xB6
054C2:  MOVLW  01
054C4:  MOVWF  xB8
054C6:  MOVLW  0B
054C8:  MOVWF  xB7
054CA:  MOVLB  0
054CC:  CALL   3A24
....................         j++; 
054D0:  MOVLB  3
054D2:  INCF   xAF,F
054D4:  MOVLW  0B
054D6:  ADDWF  xAE,F
054D8:  BRA    52D0
....................     } 
054DA:  MOVLB  0
054DC:  RETURN 0
.................... } //ler_modelo_memoria(modelo)) 
.................... void escrever_ponto_memoria(int modeloSelecionado, int pontoSelecionado){ 
*
06DA8:  MOVLW  01
06DAA:  MOVLB  3
06DAC:  SUBWF  xAD,W
06DAE:  MULWF  xAC
06DB0:  MOVFF  FF3,3B1
06DB4:  MOVF   xAE,W
06DB6:  MULLW  0B
06DB8:  MOVF   FF3,W
06DBA:  ADDWF  xB1,W
06DBC:  MOVWF  xAF
06DBE:  CLRF   xB0
....................     long int endInicial = ((modeloSelecionado - 1)*tamPrograma) + (pontoSelecionado*11); 
....................     write_ext_eeprom(endInicial+1,((x[pontoSelecionado]&0xff00)>>8));\ 
06DC0:  MOVLW  01
06DC2:  ADDWF  xAF,W
06DC4:  MOVWF  xB1
06DC6:  MOVLW  00
06DC8:  ADDWFC xB0,W
06DCA:  MOVWF  xB2
06DCC:  BCF    FD8.0
06DCE:  RLCF   xAE,W
06DD0:  CLRF   03
06DD2:  ADDLW  2E
06DD4:  MOVWF  FE9
06DD6:  MOVLW  00
06DD8:  ADDWFC 03,W
06DDA:  MOVWF  FEA
06DDC:  MOVFF  FEC,3B4
06DE0:  MOVF   FED,F
06DE2:  MOVFF  FEF,3B3
06DE6:  CLRF   xB3
06DE8:  MOVFF  3B4,3B3
06DEC:  CLRF   xB4
06DEE:  MOVFF  3B2,3B6
06DF2:  MOVFF  3B1,3B5
06DF6:  MOVFF  3B3,3B7
06DFA:  MOVLB  0
06DFC:  CALL   2218
....................     write_ext_eeprom(endInicial+2,(x[pontoSelecionado]&0x00ff)); 
06E00:  MOVLW  02
06E02:  MOVLB  3
06E04:  ADDWF  xAF,W
06E06:  MOVWF  xB1
06E08:  MOVLW  00
06E0A:  ADDWFC xB0,W
06E0C:  MOVWF  xB2
06E0E:  BCF    FD8.0
06E10:  RLCF   xAE,W
06E12:  CLRF   03
06E14:  ADDLW  2E
06E16:  MOVWF  FE9
06E18:  MOVLW  00
06E1A:  ADDWFC 03,W
06E1C:  MOVWF  FEA
06E1E:  MOVFF  FEC,3B4
06E22:  MOVF   FED,F
06E24:  MOVFF  FEF,3B3
06E28:  CLRF   xB4
06E2A:  MOVFF  3B2,3B6
06E2E:  MOVFF  3B1,3B5
06E32:  MOVFF  3B3,3B7
06E36:  MOVLB  0
06E38:  CALL   2218
....................     write_ext_eeprom(endInicial+3,((y[pontoSelecionado]&0xff00)>>8)); 
06E3C:  MOVLW  03
06E3E:  MOVLB  3
06E40:  ADDWF  xAF,W
06E42:  MOVWF  xB1
06E44:  MOVLW  00
06E46:  ADDWFC xB0,W
06E48:  MOVWF  xB2
06E4A:  BCF    FD8.0
06E4C:  RLCF   xAE,W
06E4E:  CLRF   03
06E50:  ADDLW  56
06E52:  MOVWF  FE9
06E54:  MOVLW  00
06E56:  ADDWFC 03,W
06E58:  MOVWF  FEA
06E5A:  MOVFF  FEC,3B4
06E5E:  MOVF   FED,F
06E60:  MOVFF  FEF,3B3
06E64:  CLRF   xB3
06E66:  MOVFF  3B4,3B3
06E6A:  CLRF   xB4
06E6C:  MOVFF  3B2,3B6
06E70:  MOVFF  3B1,3B5
06E74:  MOVFF  3B3,3B7
06E78:  MOVLB  0
06E7A:  CALL   2218
....................     write_ext_eeprom(endInicial+4,(y[pontoSelecionado]&0x00ff)); 
06E7E:  MOVLW  04
06E80:  MOVLB  3
06E82:  ADDWF  xAF,W
06E84:  MOVWF  xB1
06E86:  MOVLW  00
06E88:  ADDWFC xB0,W
06E8A:  MOVWF  xB2
06E8C:  BCF    FD8.0
06E8E:  RLCF   xAE,W
06E90:  CLRF   03
06E92:  ADDLW  56
06E94:  MOVWF  FE9
06E96:  MOVLW  00
06E98:  ADDWFC 03,W
06E9A:  MOVWF  FEA
06E9C:  MOVFF  FEC,3B4
06EA0:  MOVF   FED,F
06EA2:  MOVFF  FEF,3B3
06EA6:  CLRF   xB4
06EA8:  MOVFF  3B2,3B6
06EAC:  MOVFF  3B1,3B5
06EB0:  MOVFF  3B3,3B7
06EB4:  MOVLB  0
06EB6:  CALL   2218
....................     write_ext_eeprom(endInicial+5,((z[pontoSelecionado]&0xff00)>>8)); 
06EBA:  MOVLW  05
06EBC:  MOVLB  3
06EBE:  ADDWF  xAF,W
06EC0:  MOVWF  xB1
06EC2:  MOVLW  00
06EC4:  ADDWFC xB0,W
06EC6:  MOVWF  xB2
06EC8:  BCF    FD8.0
06ECA:  RLCF   xAE,W
06ECC:  CLRF   03
06ECE:  ADDLW  7E
06ED0:  MOVWF  FE9
06ED2:  MOVLW  00
06ED4:  ADDWFC 03,W
06ED6:  MOVWF  FEA
06ED8:  MOVFF  FEC,3B4
06EDC:  MOVF   FED,F
06EDE:  MOVFF  FEF,3B3
06EE2:  CLRF   xB3
06EE4:  MOVFF  3B4,3B3
06EE8:  CLRF   xB4
06EEA:  MOVFF  3B2,3B6
06EEE:  MOVFF  3B1,3B5
06EF2:  MOVFF  3B3,3B7
06EF6:  MOVLB  0
06EF8:  CALL   2218
....................     write_ext_eeprom(endInicial+6,(z[pontoSelecionado]&0x00ff)); 
06EFC:  MOVLW  06
06EFE:  MOVLB  3
06F00:  ADDWF  xAF,W
06F02:  MOVWF  xB1
06F04:  MOVLW  00
06F06:  ADDWFC xB0,W
06F08:  MOVWF  xB2
06F0A:  BCF    FD8.0
06F0C:  RLCF   xAE,W
06F0E:  CLRF   03
06F10:  ADDLW  7E
06F12:  MOVWF  FE9
06F14:  MOVLW  00
06F16:  ADDWFC 03,W
06F18:  MOVWF  FEA
06F1A:  MOVFF  FEC,3B4
06F1E:  MOVF   FED,F
06F20:  MOVFF  FEF,3B3
06F24:  CLRF   xB4
06F26:  MOVFF  3B2,3B6
06F2A:  MOVFF  3B1,3B5
06F2E:  MOVFF  3B3,3B7
06F32:  MOVLB  0
06F34:  CALL   2218
....................     write_ext_eeprom(endInicial+7,((t_solda[pontoSelecionado]&0xff00)>>8)); 
06F38:  MOVLW  07
06F3A:  MOVLB  3
06F3C:  ADDWF  xAF,W
06F3E:  MOVWF  xB1
06F40:  MOVLW  00
06F42:  ADDWFC xB0,W
06F44:  MOVWF  xB2
06F46:  BCF    FD8.0
06F48:  RLCF   xAE,W
06F4A:  CLRF   03
06F4C:  ADDLW  A6
06F4E:  MOVWF  FE9
06F50:  MOVLW  00
06F52:  ADDWFC 03,W
06F54:  MOVWF  FEA
06F56:  MOVFF  FEC,3B4
06F5A:  MOVF   FED,F
06F5C:  MOVFF  FEF,3B3
06F60:  CLRF   xB3
06F62:  MOVFF  3B4,3B3
06F66:  CLRF   xB4
06F68:  MOVFF  3B2,3B6
06F6C:  MOVFF  3B1,3B5
06F70:  MOVFF  3B3,3B7
06F74:  MOVLB  0
06F76:  CALL   2218
....................     write_ext_eeprom(endInicial+8,(t_solda[pontoSelecionado]&0x00ff)); 
06F7A:  MOVLW  08
06F7C:  MOVLB  3
06F7E:  ADDWF  xAF,W
06F80:  MOVWF  xB1
06F82:  MOVLW  00
06F84:  ADDWFC xB0,W
06F86:  MOVWF  xB2
06F88:  BCF    FD8.0
06F8A:  RLCF   xAE,W
06F8C:  CLRF   03
06F8E:  ADDLW  A6
06F90:  MOVWF  FE9
06F92:  MOVLW  00
06F94:  ADDWFC 03,W
06F96:  MOVWF  FEA
06F98:  MOVFF  FEC,3B4
06F9C:  MOVF   FED,F
06F9E:  MOVFF  FEF,3B3
06FA2:  CLRF   xB4
06FA4:  MOVFF  3B2,3B6
06FA8:  MOVFF  3B1,3B5
06FAC:  MOVFF  3B3,3B7
06FB0:  MOVLB  0
06FB2:  CALL   2218
....................     write_ext_eeprom(endInicial+9,((t_wait[pontoSelecionado]&0xff00)>>8)); 
06FB6:  MOVLW  09
06FB8:  MOVLB  3
06FBA:  ADDWF  xAF,W
06FBC:  MOVWF  xB1
06FBE:  MOVLW  00
06FC0:  ADDWFC xB0,W
06FC2:  MOVWF  xB2
06FC4:  BCF    FD8.0
06FC6:  RLCF   xAE,W
06FC8:  CLRF   03
06FCA:  ADDLW  CE
06FCC:  MOVWF  FE9
06FCE:  MOVLW  00
06FD0:  ADDWFC 03,W
06FD2:  MOVWF  FEA
06FD4:  MOVFF  FEC,3B4
06FD8:  MOVF   FED,F
06FDA:  MOVFF  FEF,3B3
06FDE:  CLRF   xB3
06FE0:  MOVFF  3B4,3B3
06FE4:  CLRF   xB4
06FE6:  MOVFF  3B2,3B6
06FEA:  MOVFF  3B1,3B5
06FEE:  MOVFF  3B3,3B7
06FF2:  MOVLB  0
06FF4:  CALL   2218
....................     write_ext_eeprom(endInicial+10,(t_wait[pontoSelecionado]&0x00ff)); 
06FF8:  MOVLW  0A
06FFA:  MOVLB  3
06FFC:  ADDWF  xAF,W
06FFE:  MOVWF  xB1
07000:  MOVLW  00
07002:  ADDWFC xB0,W
07004:  MOVWF  xB2
07006:  BCF    FD8.0
07008:  RLCF   xAE,W
0700A:  CLRF   03
0700C:  ADDLW  CE
0700E:  MOVWF  FE9
07010:  MOVLW  00
07012:  ADDWFC 03,W
07014:  MOVWF  FEA
07016:  MOVFF  FEC,3B4
0701A:  MOVF   FED,F
0701C:  MOVFF  FEF,3B3
07020:  CLRF   xB4
07022:  MOVFF  3B2,3B6
07026:  MOVFF  3B1,3B5
0702A:  MOVFF  3B3,3B7
0702E:  MOVLB  0
07030:  CALL   2218
....................     write_ext_eeprom(endInicial+11,(tipo[pontoSelecionado]<<1)+habilitado[pontoSelecionado]); 
07034:  MOVLW  0B
07036:  MOVLB  3
07038:  ADDWF  xAF,W
0703A:  MOVWF  xB1
0703C:  MOVLW  00
0703E:  ADDWFC xB0,W
07040:  MOVWF  xB2
07042:  CLRF   03
07044:  MOVF   xAE,W
07046:  ADDLW  F6
07048:  MOVWF  FE9
0704A:  MOVLW  00
0704C:  ADDWFC 03,W
0704E:  MOVWF  FEA
07050:  BCF    FD8.0
07052:  RLCF   FEF,W
07054:  MOVWF  xB3
07056:  MOVFF  3AE,3B5
0705A:  MOVLW  01
0705C:  MOVWF  xB7
0705E:  MOVLW  0B
07060:  MOVWF  xB6
07062:  MOVLB  0
07064:  CALL   3A66
07068:  MOVLW  00
0706A:  BTFSC  01.0
0706C:  MOVLW  01
0706E:  MOVLB  3
07070:  ADDWF  xB3,F
07072:  MOVFF  3B2,3B6
07076:  MOVFF  3B1,3B5
0707A:  MOVFF  3B3,3B7
0707E:  MOVLB  0
07080:  CALL   2218
07084:  GOTO   83B4 (RETURN)
.................... } //escrever_ponto_memoria(modelo,contador_lcd) 
.................... void excluir_modelo_memoria(int modeloSelecionado){ 
*
084C2:  MOVLB  3
084C4:  CLRF   xAE
084C6:  MOVLW  01
084C8:  SUBWF  xAD,W
084CA:  MULWF  xAC
084CC:  MOVF   FF3,W
084CE:  ADDLW  01
084D0:  MOVWF  xAF
084D2:  CLRF   xB0
....................     int i = 0; 
....................     long int endInicial = ((modeloSelecionado - 1)* tamPrograma)+1;         
....................     for (i = endInicial; i< ((endInicial-1)  + tamPrograma); i++){ 
084D4:  MOVFF  3AF,3AE
084D8:  MOVLW  01
084DA:  SUBWF  xAF,W
084DC:  MOVWF  xB1
084DE:  MOVLW  00
084E0:  SUBWFB xB0,W
084E2:  MOVWF  xB2
084E4:  MOVF   xAC,W
084E6:  ADDWF  xB1,W
084E8:  MOVWF  01
084EA:  MOVLW  00
084EC:  ADDWFC xB2,W
084EE:  MOVWF  03
084F0:  MOVF   01,W
084F2:  MOVF   03,F
084F4:  BNZ   84FC
084F6:  MOVF   01,W
084F8:  SUBWF  xAE,W
084FA:  BC    8510
....................         write_ext_eeprom(i,0);        
084FC:  CLRF   xB6
084FE:  MOVFF  3AE,3B5
08502:  CLRF   xB7
08504:  MOVLB  0
08506:  CALL   2218
0850A:  MOVLB  3
0850C:  INCF   xAE,F
0850E:  BRA    84D8
....................     } 
08510:  MOVLB  0
08512:  GOTO   855C (RETURN)
.................... } //excluir_modelo_memoria(modelo) 
.................... void escrever_pontos_no_modelo(int modeloSelecionado, int quantidade_pontos){ 
*
0671C:  MOVLW  01
0671E:  MOVLB  3
06720:  SUBWF  xAD,W
06722:  MULWF  xAC
06724:  MOVF   FF3,W
06726:  CLRF   xB0
06728:  MOVWF  xAF
....................     long int endInicial = ((modeloSelecionado - 1)*tamPrograma); 
....................     write_ext_eeprom(endInicial,pontos_no_modelo); 
0672A:  MOVFF  3B0,3B6
0672E:  MOVFF  3AF,3B5
06732:  MOVFF  10A,3B7
06736:  MOVLB  0
06738:  CALL   2218
0673C:  GOTO   6788 (RETURN)
.................... } //escrever_pontos_no_modelo(modelo,pontos_no_modelo) 
....................  
.................... #include "att_telas_1.c" 
.................... #include "att_telas_1.h" 
.................... void atualiza_tela_principal(void); //atualizacao de tela principal: F1 para degub F2 para main 
....................  
.................... void atualiza_tela_seleciona_maquina(void); //atualiza tela de selecao de maquina f1 para maquina 1 e f2 para maquina 2 
.................... void atualiza_tela_manutencao_outra_maquina(void); //atualizacao de tela enquanto esta sendo feita manutencao na outra maquina 
.................... void atualiza_tela_edita_modelo(void); //atualizacao de tela para editar ou excluir modelo 
.................... void atualiza_tela_seleciona_debug(void); // atualizacao de tela que escolhe f1 para editar ponto e f2 para manutencao 
.................... void atualiza_tela_edita_pontos_no_modelo(void);// atualizacao de tela da edicao de pontos do modelo 
.................... void atualiza_tela_excluir_modelo(void); //atualizacao de tela que exclui o modelo 
.................... void atualiza_tela_seleciona_pontos(void); //atualizacao de tela da escolha de ponto a ser editado 
.................... void atualiza_tela_dados_ponto (void); //atualizacao de tela que age em cima da tela de dados ponto, alterando x, y, z, tempo de solda, tempo de espera, tipo e habilitado 
....................  
.................... void atualiza_tela_seleciona_manutencao (void); //atualizacao de tela de manutencao, escolhe entre entradas e saidas 
.................... void atualiza_tela_debug_entrada_1 (void); //atualizacao de tela que ao passar pro lado mostra a tela 2 de sensores ou sai ao dar esc 
.................... void atualiza_tela_debug_entrada_2 (void); ///atualizacao de tela que ao passar pro lado mostra a tela 1 ou 3 de sensores ou sai ao dar esc 
.................... void atualiza_tela_debug_entrada_3 (void); //atualizacao de tela que ao passar pro lado mostra a tela 2 de sensores ou sai ao dar esc 
.................... void atualiza_tela_debug_saida_1(void); //atualizacao de tela que podemos acionar a esteira, pinos de entrada, e o alimentador de placa 
.................... void atualiza_tela_debug_saida_2(void); //atualizacao de tela que podemos acionar o pressor da placa, pinos de saida e dispensador de placa 
.................... void atualiza_tela_debug_saida_3(void); //atualizacao de tela que podemos acionar os alimentadores de solda, limpar os bicos e acionar os ferros 
.................... void atualiza_tela_debug_saida_4(void); //atualizacao de tela que podemos realizar a movimentacao do eixo x, y, z e o flip individualmenta 
....................  
.................... void programa_principal(void); // atualizacao de tela programa principal 
....................  
....................  
.................... void atualiza_tela_principal(){ 
....................     switch (Teclado()){ 
*
05582:  RCALL  505E
05584:  MOVF   01,W
05586:  XORLW  14
05588:  BZ    5598
0558A:  XORLW  07
0558C:  BZ    55BE
0558E:  XORLW  1D
05590:  BZ    55E6
05592:  XORLW  01
05594:  BZ    55F4
05596:  BRA    5600
....................         case MENU: 
....................             printf(lcd_putc, "\f"); // limpa display 
05598:  MOVLW  0C
0559A:  MOVLB  3
0559C:  MOVWF  xBD
0559E:  MOVLB  0
055A0:  CALL   2440
....................             printf(lcd_putc, "  CARREGANDO MODELO \n\r"); 
055A4:  MOVLW  1A
055A6:  MOVWF  FF6
055A8:  MOVLW  0E
055AA:  MOVWF  FF7
055AC:  CALL   2494
....................             ler_modelo_memoria(modelo); 
055B0:  MOVFF  2D,3AD
055B4:  RCALL  52A0
....................             menu_atual = menu_seleciona_maquina; 
055B6:  MOVLW  01
055B8:  MOVWF  1C
....................             tela_seleciona_maquina();             
055BA:  RCALL  54DE
....................         break; 
055BC:  BRA    5600
....................         case ENTER: 
....................             printf(lcd_putc, "\f"); // limpa display 
055BE:  MOVLW  0C
055C0:  MOVLB  3
055C2:  MOVWF  xBD
055C4:  MOVLB  0
055C6:  CALL   2440
....................             printf(lcd_putc, "  CARREGANDO MODELO \n\r"); 
055CA:  MOVLW  32
055CC:  MOVWF  FF6
055CE:  MOVLW  0E
055D0:  MOVWF  FF7
055D2:  CALL   2494
....................             ler_modelo_memoria(modelo); 
055D6:  MOVFF  2D,3AD
055DA:  RCALL  52A0
....................             exit = TRUE; 
055DC:  BSF    2C.1
....................             menu_atual = menu_programa_principal; 
055DE:  MOVLW  0C
055E0:  MOVWF  1C
....................             tela_programa_principal(); 
055E2:  BRA    551C
....................         break; 
055E4:  BRA    5600
....................         case SETA_SUPERIOR: 
....................             if (modelo < 4){ 
055E6:  MOVF   2D,W
055E8:  SUBLW  03
055EA:  BNC   55EE
....................                 modelo ++; 
055EC:  INCF   2D,F
....................             } 
....................             menu_atual = menu_principal; 
055EE:  CLRF   1C
....................             tela_principal(); 
055F0:  RCALL  4ECE
....................         break; 
055F2:  BRA    5600
....................         case SETA_INFERIOR: 
....................             if (modelo > 1){ 
055F4:  MOVF   2D,W
055F6:  SUBLW  01
055F8:  BC    55FC
....................                 modelo --; 
055FA:  DECF   2D,F
....................             } 
....................             menu_atual = menu_principal; 
055FC:  CLRF   1C
....................             tela_principal(); 
055FE:  RCALL  4ECE
....................         break; 
....................     } 
05600:  GOTO   A96A (RETURN)
.................... } 
....................  
.................... void atualiza_tela_seleciona_maquina(){ 
....................     switch (Teclado()){ 
*
06412:  CALL   505E
06416:  MOVF   01,W
06418:  XORLW  0A
0641A:  BZ    6426
0641C:  XORLW  01
0641E:  BZ    6430
06420:  XORLW  19
06422:  BZ    6444
06424:  BRA    644A
....................         case F1: 
....................             menu_atual = menu_edita_modelo; 
06426:  MOVLW  0D
06428:  MOVWF  1C
....................             tela_edita_modelo();  
0642A:  CALL   5604
....................         break; 
0642E:  BRA    644A
....................         case F2: 
....................             envia_maquina_para_posicao(HOME1); 
06430:  MOVLW  01
06432:  MOVLB  3
06434:  MOVWF  xAF
06436:  MOVLB  0
06438:  CALL   59E6
....................             tela_manutencao_outra_maquina(); 
0643C:  BRA    63D2
....................             menu_atual = menu_manutencao_outra_maquina; 
0643E:  MOVLW  07
06440:  MOVWF  1C
....................         break; 
06442:  BRA    644A
....................         case ESC: 
....................             menu_atual = menu_principal; 
06444:  CLRF   1C
....................             tela_principal(); 
06446:  CALL   4ECE
....................         break; 
....................     } 
0644A:  GOTO   A972 (RETURN)
.................... } 
.................... void atualiza_tela_manutencao_outra_maquina(){ 
....................     switch(Teclado()){ 
0644E:  CALL   505E
06452:  MOVF   01,W
06454:  XORLW  12
06456:  BZ    645A
06458:  BRA    646C
....................         case ESC: 
....................             envia_maquina_para_posicao(ALIMENTADOR); 
0645A:  MOVLB  3
0645C:  CLRF   xAF
0645E:  MOVLB  0
06460:  CALL   59E6
....................             menu_atual = menu_seleciona_maquina; 
06464:  MOVLW  01
06466:  MOVWF  1C
....................             tela_seleciona_maquina(); 
06468:  CALL   54DE
....................         break; 
....................     } 
0646C:  GOTO   A97A (RETURN)
.................... } 
.................... void atualiza_tela_edita_modelo(){ 
....................     switch (Teclado()){ 
*
064EE:  CALL   505E
064F2:  MOVF   01,W
064F4:  XORLW  0A
064F6:  BZ    6502
064F8:  XORLW  01
064FA:  BZ    650A
064FC:  XORLW  19
064FE:  BZ    6512
06500:  BRA    651A
....................         case F1: 
....................             menu_atual = menu_seleciona_debug; 
06502:  MOVLW  02
06504:  MOVWF  1C
....................             tela_seleciona_debug(); 
06506:  RCALL  6470
....................         break; 
06508:  BRA    651A
....................         case F2: 
....................             menu_atual = menu_excluir_modelo; 
0650A:  MOVLW  0E
0650C:  MOVWF  1C
....................             tela_excluir_modelo(); 
0650E:  BRA    64AE
....................         break; 
06510:  BRA    651A
....................         case ESC: 
....................             menu_atual = menu_seleciona_maquina; 
06512:  MOVLW  01
06514:  MOVWF  1C
....................             tela_seleciona_maquina(); 
06516:  CALL   54DE
....................         break; 
....................     } 
0651A:  GOTO   A982 (RETURN)
.................... } 
.................... void atualiza_tela_seleciona_debug (){ 
....................     switch(Teclado()){ 
*
066D2:  CALL   505E
066D6:  MOVF   01,W
066D8:  XORLW  0A
066DA:  BZ    66EA
066DC:  XORLW  01
066DE:  BZ    6700
066E0:  XORLW  07
066E2:  BZ    6708
066E4:  XORLW  1E
066E6:  BZ    6710
066E8:  BRA    6718
....................         case F1: 
....................             liga_pressor(); 
066EA:  RCALL  651E
....................             envia_maquina_para_posicao(HOME1); 
066EC:  MOVLW  01
066EE:  MOVLB  3
066F0:  MOVWF  xAF
066F2:  MOVLB  0
066F4:  CALL   59E6
....................             menu_atual = menu_seleciona_pontos; 
066F8:  MOVLW  0F
066FA:  MOVWF  1C
....................             tela_seleciona_pontos(); 
066FC:  RCALL  652E
....................         break; 
066FE:  BRA    6718
....................         case F2: 
....................             menu_atual = menu_seleciona_manutencao; 
06700:  MOVLW  03
06702:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
06704:  RCALL  662A
....................         break; 
06706:  BRA    6718
....................         case F3: 
....................             menu_atual = menu_edita_pontos_no_modelo; 
06708:  MOVLW  11
0670A:  MOVWF  1C
....................             tela_edita_pontos_no_modelo(); 
0670C:  RCALL  6668
....................         break; 
0670E:  BRA    6718
....................         case ESC: 
....................             menu_atual = menu_edita_modelo; 
06710:  MOVLW  0D
06712:  MOVWF  1C
....................             tela_edita_modelo(); 
06714:  CALL   5604
....................         break; 
....................     } 
06718:  GOTO   A98A (RETURN)
.................... } 
.................... void atualiza_tela_edita_pontos_no_modelo(){ 
....................     switch(Teclado()){ 
*
06740:  CALL   505E
06744:  MOVLW  0E
06746:  SUBWF  01,W
06748:  ADDLW  FA
0674A:  BC    67BE
0674C:  ADDLW  06
0674E:  GOTO   67C2
....................         case SETA_SUPERIOR: 
....................             pontos_no_modelo = pontos_no_modelo + 1; 
06752:  MOVLW  01
06754:  MOVLB  1
06756:  ADDWF  x0A,F
....................             menu_atual = menu_edita_pontos_no_modelo; 
06758:  MOVLW  11
0675A:  MOVWF  1C
....................             tela_edita_pontos_no_modelo(); 
0675C:  MOVLB  0
0675E:  RCALL  6668
....................         break; 
06760:  BRA    67BE
....................         case SETA_INFERIOR: 
....................             if (pontos_no_modelo > 0){ 
06762:  MOVLB  1
06764:  MOVF   x0A,F
06766:  BZ    676C
....................                 pontos_no_modelo = pontos_no_modelo -1; 
06768:  MOVLW  01
0676A:  SUBWF  x0A,F
....................             } 
....................             menu_atual = menu_edita_pontos_no_modelo; 
0676C:  MOVLW  11
0676E:  MOVWF  1C
....................             tela_edita_pontos_no_modelo(); 
06770:  MOVLB  0
06772:  RCALL  6668
....................         break; 
06774:  BRA    67BE
....................         case ESC: 
....................             menu_atual = menu_seleciona_debug; 
06776:  MOVLW  02
06778:  MOVWF  1C
....................             tela_seleciona_debug(); 
0677A:  RCALL  6470
....................         break; 
0677C:  BRA    67BE
....................         case ENTER: 
....................             escrever_pontos_no_modelo(modelo,pontos_no_modelo); 
0677E:  MOVFF  2D,3AD
06782:  MOVFF  10A,3AE
06786:  BRA    671C
....................             printf(lcd_putc, "\f"); // limpa display 
06788:  MOVLW  0C
0678A:  MOVLB  3
0678C:  MOVWF  xBD
0678E:  MOVLB  0
06790:  CALL   2440
....................             printf(lcd_putc, "PONTOS ATUALIZADOS\n\r"); 
06794:  MOVLW  4A
06796:  MOVWF  FF6
06798:  MOVLW  0E
0679A:  MOVWF  FF7
0679C:  CALL   2494
....................             delay_ms(3000); 
067A0:  MOVLW  0C
067A2:  MOVLB  3
067A4:  MOVWF  xAD
067A6:  MOVLW  FA
067A8:  MOVWF  xBE
067AA:  MOVLB  0
067AC:  CALL   206E
067B0:  MOVLB  3
067B2:  DECFSZ xAD,F
067B4:  BRA    67A6
....................             menu_atual = menu_seleciona_debug; 
067B6:  MOVLW  02
067B8:  MOVWF  1C
....................             tela_seleciona_debug(); 
067BA:  MOVLB  0
067BC:  RCALL  6470
....................         break; 
....................     } 
067BE:  GOTO   A992 (RETURN)
.................... } 
.................... void atualiza_tela_excluir_modelo(){ 
....................     switch (Teclado()){ 
*
08516:  CALL   505E
0851A:  MOVF   01,W
0851C:  XORLW  13
0851E:  BZ    8526
08520:  XORLW  01
08522:  BZ    8596
08524:  BRA    859E
....................         case ENTER: 
....................             printf(lcd_putc, "\f"); // limpa display 
08526:  MOVLW  0C
08528:  MOVLB  3
0852A:  MOVWF  xBD
0852C:  MOVLB  0
0852E:  CALL   2440
....................             printf(lcd_putc, "  EXCLUINDO MODELO  \n\r"); 
08532:  MOVLW  60
08534:  MOVWF  FF6
08536:  MOVLW  0E
08538:  MOVWF  FF7
0853A:  CALL   2494
....................             delay_ms(3000); 
0853E:  MOVLW  0C
08540:  MOVLB  3
08542:  MOVWF  xAD
08544:  MOVLW  FA
08546:  MOVWF  xBE
08548:  MOVLB  0
0854A:  CALL   206E
0854E:  MOVLB  3
08550:  DECFSZ xAD,F
08552:  BRA    8544
....................             excluir_modelo_memoria(modelo); 
08554:  MOVFF  2D,3AD
08558:  MOVLB  0
0855A:  BRA    84C2
....................             printf(lcd_putc, "\f"); // limpa display 
0855C:  MOVLW  0C
0855E:  MOVLB  3
08560:  MOVWF  xBD
08562:  MOVLB  0
08564:  CALL   2440
....................             printf(lcd_putc, "   MODELO EXCUIDO   \n\r"); 
08568:  MOVLW  78
0856A:  MOVWF  FF6
0856C:  MOVLW  0E
0856E:  MOVWF  FF7
08570:  CALL   2494
....................             delay_ms(3000); 
08574:  MOVLW  0C
08576:  MOVLB  3
08578:  MOVWF  xAD
0857A:  MOVLW  FA
0857C:  MOVWF  xBE
0857E:  MOVLB  0
08580:  CALL   206E
08584:  MOVLB  3
08586:  DECFSZ xAD,F
08588:  BRA    857A
....................             menu_atual = menu_edita_modelo; 
0858A:  MOVLW  0D
0858C:  MOVWF  1C
....................             tela_edita_modelo(); 
0858E:  MOVLB  0
08590:  CALL   5604
....................         break; 
08594:  BRA    859E
....................         case ESC: 
....................             menu_atual = menu_edita_modelo; 
08596:  MOVLW  0D
08598:  MOVWF  1C
....................             tela_edita_modelo(); 
0859A:  CALL   5604
....................         break; 
....................     } 
0859E:  GOTO   A9AA (RETURN)
.................... } 
.................... void atualiza_tela_seleciona_pontos(){ 
....................     switch(Teclado()){ 
*
06AC0:  CALL   505E
06AC4:  MOVLW  0E
06AC6:  SUBWF  01,W
06AC8:  ADDLW  FA
06ACA:  BTFSC  FD8.0
06ACC:  BRA    6CFC
06ACE:  ADDLW  06
06AD0:  GOTO   6D00
....................         case SETA_SUPERIOR: 
....................             contador_lcd --; 
06AD4:  DECF   24,F
....................             if  ((contador_lcd > 0)&&(contador_lcd < pontos_no_modelo)){ 
06AD6:  MOVF   24,F
06AD8:  BZ    6AFC
06ADA:  MOVLB  1
06ADC:  MOVF   x0A,W
06ADE:  SUBWF  24,W
06AE0:  BTFSS  FD8.0
06AE2:  BRA    6AE8
06AE4:  MOVLB  0
06AE6:  BRA    6AFC
....................                 if (ponteiro_lcd == 1){ 
06AE8:  DECFSZ 21,W
06AEA:  BRA    6AF6
....................                     inicial_lcd --; 
06AEC:  DECF   22,F
....................                     final_lcd --; 
06AEE:  DECF   23,F
....................                     ponteiro_lcd = 1; 
06AF0:  MOVLW  01
06AF2:  MOVWF  21
....................                 } else { 
06AF4:  BRA    6AF8
....................                     ponteiro_lcd --; 
06AF6:  DECF   21,F
....................                 }                 
....................             } else { 
06AF8:  BRA    6B0A
06AFA:  MOVLB  0
....................                 contador_lcd = 0; 
06AFC:  CLRF   24
....................                 inicial_lcd = 0; 
06AFE:  CLRF   22
....................                 final_lcd = 3; 
06B00:  MOVLW  03
06B02:  MOVWF  23
....................                 ponteiro_lcd = 1; 
06B04:  MOVLW  01
06B06:  MOVWF  21
06B08:  MOVLB  1
....................             } 
....................             menu_atual = menu_seleciona_pontos; 
06B0A:  MOVLW  0F
06B0C:  MOVWF  1C
....................             tela_seleciona_pontos(); 
06B0E:  MOVLB  0
06B10:  RCALL  652E
....................         break; 
06B12:  BRA    6CFC
....................         case SETA_INFERIOR: 
....................             contador_lcd ++; 
06B14:  INCF   24,F
....................             if (contador_lcd < pontos_no_modelo){ 
06B16:  MOVLB  1
06B18:  MOVF   x0A,W
06B1A:  SUBWF  24,W
06B1C:  BC    6B32
....................                 if (ponteiro_lcd == 4){ 
06B1E:  MOVF   21,W
06B20:  SUBLW  04
06B22:  BNZ   6B2E
....................                     inicial_lcd ++; 
06B24:  INCF   22,F
....................                     final_lcd ++; 
06B26:  INCF   23,F
....................                     ponteiro_lcd = 4; 
06B28:  MOVLW  04
06B2A:  MOVWF  21
....................                 } else { 
06B2C:  BRA    6B30
....................                     ponteiro_lcd ++; 
06B2E:  INCF   21,F
....................                 } 
....................             } else { 
06B30:  BRA    6B36
....................                 contador_lcd = pontos_no_modelo; 
06B32:  MOVFF  10A,24
....................             } 
....................             menu_atual = menu_seleciona_pontos; 
06B36:  MOVLW  0F
06B38:  MOVWF  1C
....................             tela_seleciona_pontos(); 
06B3A:  MOVLB  0
06B3C:  RCALL  652E
....................         break; 
06B3E:  BRA    6CFC
....................         case ENTER: 
....................             ponteiro_lcd = 1; 
06B40:  MOVLW  01
06B42:  MOVWF  21
....................             inicial_lcd = 0; 
06B44:  CLRF   22
....................             final_lcd = 3; 
06B46:  MOVLW  03
06B48:  MOVWF  23
....................             motor_run_z(0, 19); 
06B4A:  MOVLB  3
06B4C:  CLRF   xB7
06B4E:  CLRF   xB6
06B50:  CLRF   xB5
06B52:  CLRF   xB4
06B54:  MOVLW  13
06B56:  MOVWF  xB8
06B58:  MOVLB  0
06B5A:  CALL   5642
....................             while ((run_flg_z)); 
06B5E:  MOVLB  2
06B60:  BTFSC  xC6.1
06B62:  BRA    6B60
....................             if ((y[contador_lcd] > 0) && (x[contador_lcd]> 0)){                 
06B64:  BCF    FD8.0
06B66:  RLCF   24,W
06B68:  CLRF   03
06B6A:  ADDLW  56
06B6C:  MOVWF  FE9
06B6E:  MOVLW  00
06B70:  ADDWFC 03,W
06B72:  MOVWF  FEA
06B74:  MOVFF  FEC,3AE
06B78:  MOVF   FED,F
06B7A:  MOVFF  FEF,3AD
06B7E:  MOVLB  3
06B80:  MOVF   xAD,F
06B82:  BNZ   6B88
06B84:  MOVF   xAE,F
06B86:  BZ    6C50
06B88:  BCF    FD8.0
06B8A:  RLCF   24,W
06B8C:  CLRF   03
06B8E:  ADDLW  2E
06B90:  MOVWF  FE9
06B92:  MOVLW  00
06B94:  ADDWFC 03,W
06B96:  MOVWF  FEA
06B98:  MOVFF  FEC,3AE
06B9C:  MOVF   FED,F
06B9E:  MOVFF  FEF,3AD
06BA2:  MOVF   xAD,F
06BA4:  BNZ   6BAA
06BA6:  MOVF   xAE,F
06BA8:  BZ    6C50
....................                 motor_run_x(x[contador_lcd],19); 
06BAA:  BCF    FD8.0
06BAC:  RLCF   24,W
06BAE:  CLRF   03
06BB0:  ADDLW  2E
06BB2:  MOVWF  FE9
06BB4:  MOVLW  00
06BB6:  ADDWFC 03,W
06BB8:  MOVWF  FEA
06BBA:  MOVFF  FEC,3AE
06BBE:  MOVF   FED,F
06BC0:  MOVFF  FEF,3AD
06BC4:  CLRF   xB7
06BC6:  CLRF   xB6
06BC8:  MOVFF  3AE,3B5
06BCC:  MOVFF  3AD,3B4
06BD0:  MOVLW  13
06BD2:  MOVWF  xB8
06BD4:  MOVLB  0
06BD6:  CALL   4ABC
....................                 motor_run_y(y[contador_lcd],19); 
06BDA:  BCF    FD8.0
06BDC:  RLCF   24,W
06BDE:  CLRF   03
06BE0:  ADDLW  56
06BE2:  MOVWF  FE9
06BE4:  MOVLW  00
06BE6:  ADDWFC 03,W
06BE8:  MOVWF  FEA
06BEA:  MOVFF  FEC,3AE
06BEE:  MOVF   FED,F
06BF0:  MOVFF  FEF,3AD
06BF4:  MOVLB  3
06BF6:  CLRF   xB7
06BF8:  CLRF   xB6
06BFA:  MOVFF  3AE,3B5
06BFE:  MOVFF  3AD,3B4
06C02:  MOVLW  13
06C04:  MOVWF  xB8
06C06:  MOVLB  0
06C08:  CALL   580C
....................                 motor_run_z(z[contador_lcd],19); 
06C0C:  BCF    FD8.0
06C0E:  RLCF   24,W
06C10:  CLRF   03
06C12:  ADDLW  7E
06C14:  MOVWF  FE9
06C16:  MOVLW  00
06C18:  ADDWFC 03,W
06C1A:  MOVWF  FEA
06C1C:  MOVFF  FEC,3AE
06C20:  MOVF   FED,F
06C22:  MOVFF  FEF,3AD
06C26:  MOVLB  3
06C28:  CLRF   xB7
06C2A:  CLRF   xB6
06C2C:  MOVFF  3AE,3B5
06C30:  MOVFF  3AD,3B4
06C34:  MOVLW  13
06C36:  MOVWF  xB8
06C38:  MOVLB  0
06C3A:  CALL   5642
....................                 posicao_atual = SOLDAGEM; 
06C3E:  MOVLW  03
06C40:  MOVWF  25
....................                 envia_posicao_para_outra_maquina(SOLDAGEM); 
06C42:  MOVLB  3
06C44:  MOVWF  xB0
06C46:  MOVLB  0
06C48:  CALL   4C2E
....................             } else { 
06C4C:  BRA    6CA8
06C4E:  MOVLB  3
....................                 envia_maquina_para_posicao(SOLDAGEM); 
06C50:  MOVLW  03
06C52:  MOVWF  xAF
06C54:  MOVLB  0
06C56:  CALL   59E6
....................                 x[contador_lcd] = motor_pos_x; 
06C5A:  BCF    FD8.0
06C5C:  RLCF   24,W
06C5E:  CLRF   03
06C60:  ADDLW  2E
06C62:  MOVWF  FE9
06C64:  MOVLW  00
06C66:  ADDWFC 03,W
06C68:  MOVWF  FEA
06C6A:  MOVFF  113,FEC
06C6E:  MOVF   FED,F
06C70:  MOVFF  112,FEF
....................                 y[contador_lcd] = motor_pos_y; 
06C74:  BCF    FD8.0
06C76:  RLCF   24,W
06C78:  CLRF   03
06C7A:  ADDLW  56
06C7C:  MOVWF  FE9
06C7E:  MOVLW  00
06C80:  ADDWFC 03,W
06C82:  MOVWF  FEA
06C84:  MOVFF  115,FEC
06C88:  MOVF   FED,F
06C8A:  MOVFF  114,FEF
....................                 z[contador_lcd] = motor_pos_z; 
06C8E:  BCF    FD8.0
06C90:  RLCF   24,W
06C92:  CLRF   03
06C94:  ADDLW  7E
06C96:  MOVWF  FE9
06C98:  MOVLW  00
06C9A:  ADDWFC 03,W
06C9C:  MOVWF  FEA
06C9E:  MOVFF  119,FEC
06CA2:  MOVF   FED,F
06CA4:  MOVFF  118,FEF
....................             } 
....................             menu_atual = menu_dados_ponto; 
06CA8:  MOVLW  10
06CAA:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
06CAC:  MOVFF  24,3AD
06CB0:  RCALL  68B0
....................         break; 
06CB2:  BRA    6CFC
....................         case ESC: 
....................             envia_maquina_para_posicao(HOME1); 
06CB4:  MOVLW  01
06CB6:  MOVLB  3
06CB8:  MOVWF  xAF
06CBA:  MOVLB  0
06CBC:  CALL   59E6
....................             envia_maquina_para_posicao(ALIMENTADOR); 
06CC0:  MOVLB  3
06CC2:  CLRF   xAF
06CC4:  MOVLB  0
06CC6:  CALL   59E6
....................             desliga_pressor(); 
06CCA:  RCALL  6AB0
....................             menu_atual = menu_seleciona_debug; 
06CCC:  MOVLW  02
06CCE:  MOVWF  1C
....................             tela_seleciona_debug(); 
06CD0:  CALL   6470
....................             motor_run_z(0, 19); 
06CD4:  MOVLB  3
06CD6:  CLRF   xB7
06CD8:  CLRF   xB6
06CDA:  CLRF   xB5
06CDC:  CLRF   xB4
06CDE:  MOVLW  13
06CE0:  MOVWF  xB8
06CE2:  MOVLB  0
06CE4:  CALL   5642
....................             while ((run_flg_z)); 
06CE8:  MOVLB  2
06CEA:  BTFSC  xC6.1
06CEC:  BRA    6CEA
....................             ponteiro_lcd = 1; 
06CEE:  MOVLW  01
06CF0:  MOVWF  21
....................             inicial_lcd = 0; 
06CF2:  CLRF   22
....................             final_lcd = 3; 
06CF4:  MOVLW  03
06CF6:  MOVWF  23
....................             contador_lcd = 0; 
06CF8:  CLRF   24
....................         break; 
06CFA:  MOVLB  3
....................     } 
06CFC:  GOTO   A9F6 (RETURN)
.................... } 
.................... void atualiza_tela_dados_ponto(){ 
....................     switch (Teclado()){ 
*
07CC6:  CALL   505E
07CCA:  MOVF   01,W
07CCC:  ADDLW  EC
07CCE:  BTFSC  FD8.0
07CD0:  GOTO   8472
07CD4:  ADDLW  14
07CD6:  GOTO   8476
....................         case SETA_SUPERIOR: 
....................             if (y[contador_lcd] > 0){ 
07CDA:  BCF    FD8.0
07CDC:  RLCF   24,W
07CDE:  CLRF   03
07CE0:  ADDLW  56
07CE2:  MOVWF  FE9
07CE4:  MOVLW  00
07CE6:  ADDWFC 03,W
07CE8:  MOVWF  FEA
07CEA:  MOVFF  FEC,3AE
07CEE:  MOVF   FED,F
07CF0:  MOVFF  FEF,3AD
07CF4:  MOVLB  3
07CF6:  MOVF   xAD,F
07CF8:  BNZ   7CFE
07CFA:  MOVF   xAE,F
07CFC:  BZ    7D7C
....................                 y[contador_lcd] = y[contador_lcd] - 1; 
07CFE:  BCF    FD8.0
07D00:  RLCF   24,W
07D02:  CLRF   03
07D04:  ADDLW  56
07D06:  MOVWF  01
07D08:  MOVLW  00
07D0A:  ADDWFC 03,F
07D0C:  MOVFF  03,3AE
07D10:  BCF    FD8.0
07D12:  RLCF   24,W
07D14:  CLRF   03
07D16:  ADDLW  56
07D18:  MOVWF  FE9
07D1A:  MOVLW  00
07D1C:  ADDWFC 03,W
07D1E:  MOVWF  FEA
07D20:  MOVFF  FEC,3B0
07D24:  MOVF   FED,F
07D26:  MOVFF  FEF,3AF
07D2A:  MOVLW  01
07D2C:  SUBWF  xAF,W
07D2E:  MOVWF  00
07D30:  MOVLW  00
07D32:  SUBWFB xB0,W
07D34:  MOVFF  3AE,FEA
07D38:  MOVFF  01,FE9
07D3C:  MOVWF  FEC
07D3E:  MOVF   FED,F
07D40:  MOVFF  00,FEF
....................                 motor_run_y(y[contador_lcd],19); 
07D44:  BCF    FD8.0
07D46:  RLCF   24,W
07D48:  CLRF   03
07D4A:  ADDLW  56
07D4C:  MOVWF  FE9
07D4E:  MOVLW  00
07D50:  ADDWFC 03,W
07D52:  MOVWF  FEA
07D54:  MOVFF  FEC,3AE
07D58:  MOVF   FED,F
07D5A:  MOVFF  FEF,3AD
07D5E:  CLRF   xB7
07D60:  CLRF   xB6
07D62:  MOVFF  3AE,3B5
07D66:  MOVFF  3AD,3B4
07D6A:  MOVLW  13
07D6C:  MOVWF  xB8
07D6E:  MOVLB  0
07D70:  CALL   580C
....................                 while ((run_flg_y)); 
07D74:  MOVLB  1
07D76:  BTFSC  x1A.6
07D78:  BRA    7D76
07D7A:  MOVLB  3
....................             } 
....................             menu_atual = menu_dados_ponto; 
07D7C:  MOVLW  10
07D7E:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
07D80:  MOVFF  24,3AD
07D84:  MOVLB  0
07D86:  CALL   68B0
....................         break; 
07D8A:  BRA    8472
....................         case SETA_INFERIOR: 
....................             y[contador_lcd] = y[contador_lcd] + 1; 
07D8C:  BCF    FD8.0
07D8E:  RLCF   24,W
07D90:  CLRF   03
07D92:  ADDLW  56
07D94:  MOVWF  01
07D96:  MOVLW  00
07D98:  ADDWFC 03,F
07D9A:  MOVFF  01,3AD
07D9E:  MOVLB  3
07DA0:  MOVFF  03,3AE
07DA4:  BCF    FD8.0
07DA6:  RLCF   24,W
07DA8:  CLRF   03
07DAA:  ADDLW  56
07DAC:  MOVWF  FE9
07DAE:  MOVLW  00
07DB0:  ADDWFC 03,W
07DB2:  MOVWF  FEA
07DB4:  MOVFF  FEC,3B0
07DB8:  MOVF   FED,F
07DBA:  MOVFF  FEF,3AF
07DBE:  MOVLW  01
07DC0:  ADDWF  xAF,W
07DC2:  MOVWF  01
07DC4:  MOVLW  00
07DC6:  ADDWFC xB0,W
07DC8:  MOVFF  3AE,FEA
07DCC:  MOVFF  3AD,FE9
07DD0:  MOVWF  FEC
07DD2:  MOVF   FED,F
07DD4:  MOVFF  01,FEF
....................             motor_run_y(y[contador_lcd],19); 
07DD8:  BCF    FD8.0
07DDA:  RLCF   24,W
07DDC:  CLRF   03
07DDE:  ADDLW  56
07DE0:  MOVWF  FE9
07DE2:  MOVLW  00
07DE4:  ADDWFC 03,W
07DE6:  MOVWF  FEA
07DE8:  MOVFF  FEC,3AE
07DEC:  MOVF   FED,F
07DEE:  MOVFF  FEF,3AD
07DF2:  CLRF   xB7
07DF4:  CLRF   xB6
07DF6:  MOVFF  3AE,3B5
07DFA:  MOVFF  3AD,3B4
07DFE:  MOVLW  13
07E00:  MOVWF  xB8
07E02:  MOVLB  0
07E04:  CALL   580C
....................             while ((run_flg_y)); 
07E08:  MOVLB  1
07E0A:  BTFSC  x1A.6
07E0C:  BRA    7E0A
....................             menu_atual = menu_dados_ponto; 
07E0E:  MOVLW  10
07E10:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
07E12:  MOVFF  24,3AD
07E16:  MOVLB  0
07E18:  CALL   68B0
....................         break; 
07E1C:  BRA    8472
....................         case SETA_DIREITA: 
....................             x[contador_lcd] = x[contador_lcd] + 1; 
07E1E:  BCF    FD8.0
07E20:  RLCF   24,W
07E22:  CLRF   03
07E24:  ADDLW  2E
07E26:  MOVWF  01
07E28:  MOVLW  00
07E2A:  ADDWFC 03,F
07E2C:  MOVFF  01,3AD
07E30:  MOVLB  3
07E32:  MOVFF  03,3AE
07E36:  BCF    FD8.0
07E38:  RLCF   24,W
07E3A:  CLRF   03
07E3C:  ADDLW  2E
07E3E:  MOVWF  FE9
07E40:  MOVLW  00
07E42:  ADDWFC 03,W
07E44:  MOVWF  FEA
07E46:  MOVFF  FEC,3B0
07E4A:  MOVF   FED,F
07E4C:  MOVFF  FEF,3AF
07E50:  MOVLW  01
07E52:  ADDWF  xAF,W
07E54:  MOVWF  01
07E56:  MOVLW  00
07E58:  ADDWFC xB0,W
07E5A:  MOVFF  3AE,FEA
07E5E:  MOVFF  3AD,FE9
07E62:  MOVWF  FEC
07E64:  MOVF   FED,F
07E66:  MOVFF  01,FEF
....................             motor_run_x(x[contador_lcd],19); 
07E6A:  BCF    FD8.0
07E6C:  RLCF   24,W
07E6E:  CLRF   03
07E70:  ADDLW  2E
07E72:  MOVWF  FE9
07E74:  MOVLW  00
07E76:  ADDWFC 03,W
07E78:  MOVWF  FEA
07E7A:  MOVFF  FEC,3AE
07E7E:  MOVF   FED,F
07E80:  MOVFF  FEF,3AD
07E84:  CLRF   xB7
07E86:  CLRF   xB6
07E88:  MOVFF  3AE,3B5
07E8C:  MOVFF  3AD,3B4
07E90:  MOVLW  13
07E92:  MOVWF  xB8
07E94:  MOVLB  0
07E96:  CALL   4ABC
....................             while ((run_flg_x)); 
07E9A:  MOVLB  1
07E9C:  BTFSC  x1A.4
07E9E:  BRA    7E9C
....................             menu_atual = menu_dados_ponto; 
07EA0:  MOVLW  10
07EA2:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
07EA4:  MOVFF  24,3AD
07EA8:  MOVLB  0
07EAA:  CALL   68B0
....................         break; 
07EAE:  BRA    8472
....................         case SETA_ESQUERDA: 
....................             if (x[contador_lcd] > 0){ 
07EB0:  BCF    FD8.0
07EB2:  RLCF   24,W
07EB4:  CLRF   03
07EB6:  ADDLW  2E
07EB8:  MOVWF  FE9
07EBA:  MOVLW  00
07EBC:  ADDWFC 03,W
07EBE:  MOVWF  FEA
07EC0:  MOVFF  FEC,3AE
07EC4:  MOVF   FED,F
07EC6:  MOVFF  FEF,3AD
07ECA:  MOVLB  3
07ECC:  MOVF   xAD,F
07ECE:  BNZ   7ED4
07ED0:  MOVF   xAE,F
07ED2:  BZ    7F52
....................                 x[contador_lcd] = x[contador_lcd] - 1; 
07ED4:  BCF    FD8.0
07ED6:  RLCF   24,W
07ED8:  CLRF   03
07EDA:  ADDLW  2E
07EDC:  MOVWF  01
07EDE:  MOVLW  00
07EE0:  ADDWFC 03,F
07EE2:  MOVFF  03,3AE
07EE6:  BCF    FD8.0
07EE8:  RLCF   24,W
07EEA:  CLRF   03
07EEC:  ADDLW  2E
07EEE:  MOVWF  FE9
07EF0:  MOVLW  00
07EF2:  ADDWFC 03,W
07EF4:  MOVWF  FEA
07EF6:  MOVFF  FEC,3B0
07EFA:  MOVF   FED,F
07EFC:  MOVFF  FEF,3AF
07F00:  MOVLW  01
07F02:  SUBWF  xAF,W
07F04:  MOVWF  00
07F06:  MOVLW  00
07F08:  SUBWFB xB0,W
07F0A:  MOVFF  3AE,FEA
07F0E:  MOVFF  01,FE9
07F12:  MOVWF  FEC
07F14:  MOVF   FED,F
07F16:  MOVFF  00,FEF
....................                 motor_run_x(x[contador_lcd],19); 
07F1A:  BCF    FD8.0
07F1C:  RLCF   24,W
07F1E:  CLRF   03
07F20:  ADDLW  2E
07F22:  MOVWF  FE9
07F24:  MOVLW  00
07F26:  ADDWFC 03,W
07F28:  MOVWF  FEA
07F2A:  MOVFF  FEC,3AE
07F2E:  MOVF   FED,F
07F30:  MOVFF  FEF,3AD
07F34:  CLRF   xB7
07F36:  CLRF   xB6
07F38:  MOVFF  3AE,3B5
07F3C:  MOVFF  3AD,3B4
07F40:  MOVLW  13
07F42:  MOVWF  xB8
07F44:  MOVLB  0
07F46:  CALL   4ABC
....................                 while ((run_flg_x)); 
07F4A:  MOVLB  1
07F4C:  BTFSC  x1A.4
07F4E:  BRA    7F4C
07F50:  MOVLB  3
....................             } 
....................             menu_atual = menu_dados_ponto; 
07F52:  MOVLW  10
07F54:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
07F56:  MOVFF  24,3AD
07F5A:  MOVLB  0
07F5C:  CALL   68B0
....................         break; 
07F60:  BRA    8472
....................         case F2: 
....................             if (z[contador_lcd] > 0){ 
07F62:  BCF    FD8.0
07F64:  RLCF   24,W
07F66:  CLRF   03
07F68:  ADDLW  7E
07F6A:  MOVWF  FE9
07F6C:  MOVLW  00
07F6E:  ADDWFC 03,W
07F70:  MOVWF  FEA
07F72:  MOVFF  FEC,3AE
07F76:  MOVF   FED,F
07F78:  MOVFF  FEF,3AD
07F7C:  MOVLB  3
07F7E:  MOVF   xAD,F
07F80:  BNZ   7F86
07F82:  MOVF   xAE,F
07F84:  BZ    8004
....................                 z[contador_lcd] = z[contador_lcd] -1; 
07F86:  BCF    FD8.0
07F88:  RLCF   24,W
07F8A:  CLRF   03
07F8C:  ADDLW  7E
07F8E:  MOVWF  01
07F90:  MOVLW  00
07F92:  ADDWFC 03,F
07F94:  MOVFF  03,3AE
07F98:  BCF    FD8.0
07F9A:  RLCF   24,W
07F9C:  CLRF   03
07F9E:  ADDLW  7E
07FA0:  MOVWF  FE9
07FA2:  MOVLW  00
07FA4:  ADDWFC 03,W
07FA6:  MOVWF  FEA
07FA8:  MOVFF  FEC,3B0
07FAC:  MOVF   FED,F
07FAE:  MOVFF  FEF,3AF
07FB2:  MOVLW  01
07FB4:  SUBWF  xAF,W
07FB6:  MOVWF  00
07FB8:  MOVLW  00
07FBA:  SUBWFB xB0,W
07FBC:  MOVFF  3AE,FEA
07FC0:  MOVFF  01,FE9
07FC4:  MOVWF  FEC
07FC6:  MOVF   FED,F
07FC8:  MOVFF  00,FEF
....................                 motor_run_z(z[contador_lcd],19); 
07FCC:  BCF    FD8.0
07FCE:  RLCF   24,W
07FD0:  CLRF   03
07FD2:  ADDLW  7E
07FD4:  MOVWF  FE9
07FD6:  MOVLW  00
07FD8:  ADDWFC 03,W
07FDA:  MOVWF  FEA
07FDC:  MOVFF  FEC,3AE
07FE0:  MOVF   FED,F
07FE2:  MOVFF  FEF,3AD
07FE6:  CLRF   xB7
07FE8:  CLRF   xB6
07FEA:  MOVFF  3AE,3B5
07FEE:  MOVFF  3AD,3B4
07FF2:  MOVLW  13
07FF4:  MOVWF  xB8
07FF6:  MOVLB  0
07FF8:  CALL   5642
....................                 while ((run_flg_z)); 
07FFC:  MOVLB  2
07FFE:  BTFSC  xC6.1
08000:  BRA    7FFE
08002:  MOVLB  3
....................             } 
....................             menu_atual = menu_dados_ponto; 
08004:  MOVLW  10
08006:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
08008:  MOVFF  24,3AD
0800C:  MOVLB  0
0800E:  CALL   68B0
....................         break; 
08012:  BRA    8472
....................         case F4: 
....................             z[contador_lcd] = z[contador_lcd] +1; 
08014:  BCF    FD8.0
08016:  RLCF   24,W
08018:  CLRF   03
0801A:  ADDLW  7E
0801C:  MOVWF  01
0801E:  MOVLW  00
08020:  ADDWFC 03,F
08022:  MOVFF  01,3AD
08026:  MOVLB  3
08028:  MOVFF  03,3AE
0802C:  BCF    FD8.0
0802E:  RLCF   24,W
08030:  CLRF   03
08032:  ADDLW  7E
08034:  MOVWF  FE9
08036:  MOVLW  00
08038:  ADDWFC 03,W
0803A:  MOVWF  FEA
0803C:  MOVFF  FEC,3B0
08040:  MOVF   FED,F
08042:  MOVFF  FEF,3AF
08046:  MOVLW  01
08048:  ADDWF  xAF,W
0804A:  MOVWF  01
0804C:  MOVLW  00
0804E:  ADDWFC xB0,W
08050:  MOVFF  3AE,FEA
08054:  MOVFF  3AD,FE9
08058:  MOVWF  FEC
0805A:  MOVF   FED,F
0805C:  MOVFF  01,FEF
....................             motor_run_z(z[contador_lcd],19); 
08060:  BCF    FD8.0
08062:  RLCF   24,W
08064:  CLRF   03
08066:  ADDLW  7E
08068:  MOVWF  FE9
0806A:  MOVLW  00
0806C:  ADDWFC 03,W
0806E:  MOVWF  FEA
08070:  MOVFF  FEC,3AE
08074:  MOVF   FED,F
08076:  MOVFF  FEF,3AD
0807A:  CLRF   xB7
0807C:  CLRF   xB6
0807E:  MOVFF  3AE,3B5
08082:  MOVFF  3AD,3B4
08086:  MOVLW  13
08088:  MOVWF  xB8
0808A:  MOVLB  0
0808C:  CALL   5642
....................             while ((run_flg_z)); 
08090:  MOVLB  2
08092:  BTFSC  xC6.1
08094:  BRA    8092
....................             menu_atual = menu_dados_ponto; 
08096:  MOVLW  10
08098:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
0809A:  MOVFF  24,3AD
0809E:  MOVLB  0
080A0:  CALL   68B0
....................         break; 
080A4:  BRA    8472
....................         case 1: 
....................             t_solda[contador_lcd] = t_solda[contador_lcd] + 10; 
080A6:  BCF    FD8.0
080A8:  RLCF   24,W
080AA:  CLRF   03
080AC:  ADDLW  A6
080AE:  MOVWF  01
080B0:  MOVLW  00
080B2:  ADDWFC 03,F
080B4:  MOVFF  01,3AD
080B8:  MOVLB  3
080BA:  MOVFF  03,3AE
080BE:  BCF    FD8.0
080C0:  RLCF   24,W
080C2:  CLRF   03
080C4:  ADDLW  A6
080C6:  MOVWF  FE9
080C8:  MOVLW  00
080CA:  ADDWFC 03,W
080CC:  MOVWF  FEA
080CE:  MOVFF  FEC,3B0
080D2:  MOVF   FED,F
080D4:  MOVFF  FEF,3AF
080D8:  MOVLW  0A
080DA:  ADDWF  xAF,W
080DC:  MOVWF  01
080DE:  MOVLW  00
080E0:  ADDWFC xB0,W
080E2:  MOVFF  3AE,FEA
080E6:  MOVFF  3AD,FE9
080EA:  MOVWF  FEC
080EC:  MOVF   FED,F
080EE:  MOVFF  01,FEF
....................             menu_atual = menu_dados_ponto; 
080F2:  MOVLW  10
080F4:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
080F6:  MOVFF  24,3AD
080FA:  MOVLB  0
080FC:  CALL   68B0
....................         break; 
08100:  BRA    8472
....................         case 4: 
....................             if (t_solda[contador_lcd] > 0){ 
08102:  BCF    FD8.0
08104:  RLCF   24,W
08106:  CLRF   03
08108:  ADDLW  A6
0810A:  MOVWF  FE9
0810C:  MOVLW  00
0810E:  ADDWFC 03,W
08110:  MOVWF  FEA
08112:  MOVFF  FEC,3AE
08116:  MOVF   FED,F
08118:  MOVFF  FEF,3AD
0811C:  MOVLB  3
0811E:  MOVF   xAD,F
08120:  BNZ   8126
08122:  MOVF   xAE,F
08124:  BZ    816C
....................                 t_solda[contador_lcd] = t_solda[contador_lcd] - 10; 
08126:  BCF    FD8.0
08128:  RLCF   24,W
0812A:  CLRF   03
0812C:  ADDLW  A6
0812E:  MOVWF  01
08130:  MOVLW  00
08132:  ADDWFC 03,F
08134:  MOVFF  03,3AE
08138:  BCF    FD8.0
0813A:  RLCF   24,W
0813C:  CLRF   03
0813E:  ADDLW  A6
08140:  MOVWF  FE9
08142:  MOVLW  00
08144:  ADDWFC 03,W
08146:  MOVWF  FEA
08148:  MOVFF  FEC,3B0
0814C:  MOVF   FED,F
0814E:  MOVFF  FEF,3AF
08152:  MOVLW  0A
08154:  SUBWF  xAF,W
08156:  MOVWF  00
08158:  MOVLW  00
0815A:  SUBWFB xB0,W
0815C:  MOVFF  3AE,FEA
08160:  MOVFF  01,FE9
08164:  MOVWF  FEC
08166:  MOVF   FED,F
08168:  MOVFF  00,FEF
....................             } 
....................             menu_atual = menu_dados_ponto; 
0816C:  MOVLW  10
0816E:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
08170:  MOVFF  24,3AD
08174:  MOVLB  0
08176:  CALL   68B0
....................         break; 
0817A:  BRA    8472
....................         case 3: 
....................             t_wait[contador_lcd] = t_wait[contador_lcd] + 10; 
0817C:  BCF    FD8.0
0817E:  RLCF   24,W
08180:  CLRF   03
08182:  ADDLW  CE
08184:  MOVWF  01
08186:  MOVLW  00
08188:  ADDWFC 03,F
0818A:  MOVFF  01,3AD
0818E:  MOVLB  3
08190:  MOVFF  03,3AE
08194:  BCF    FD8.0
08196:  RLCF   24,W
08198:  CLRF   03
0819A:  ADDLW  CE
0819C:  MOVWF  FE9
0819E:  MOVLW  00
081A0:  ADDWFC 03,W
081A2:  MOVWF  FEA
081A4:  MOVFF  FEC,3B0
081A8:  MOVF   FED,F
081AA:  MOVFF  FEF,3AF
081AE:  MOVLW  0A
081B0:  ADDWF  xAF,W
081B2:  MOVWF  01
081B4:  MOVLW  00
081B6:  ADDWFC xB0,W
081B8:  MOVFF  3AE,FEA
081BC:  MOVFF  3AD,FE9
081C0:  MOVWF  FEC
081C2:  MOVF   FED,F
081C4:  MOVFF  01,FEF
....................             menu_atual = menu_dados_ponto; 
081C8:  MOVLW  10
081CA:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
081CC:  MOVFF  24,3AD
081D0:  MOVLB  0
081D2:  CALL   68B0
....................         break; 
081D6:  BRA    8472
....................         case 6: 
....................             if (t_wait[contador_lcd] > 0){ 
081D8:  BCF    FD8.0
081DA:  RLCF   24,W
081DC:  CLRF   03
081DE:  ADDLW  CE
081E0:  MOVWF  FE9
081E2:  MOVLW  00
081E4:  ADDWFC 03,W
081E6:  MOVWF  FEA
081E8:  MOVFF  FEC,3AE
081EC:  MOVF   FED,F
081EE:  MOVFF  FEF,3AD
081F2:  MOVLB  3
081F4:  MOVF   xAD,F
081F6:  BNZ   81FC
081F8:  MOVF   xAE,F
081FA:  BZ    8242
....................                 t_wait[contador_lcd] = t_wait[contador_lcd] - 10; 
081FC:  BCF    FD8.0
081FE:  RLCF   24,W
08200:  CLRF   03
08202:  ADDLW  CE
08204:  MOVWF  01
08206:  MOVLW  00
08208:  ADDWFC 03,F
0820A:  MOVFF  03,3AE
0820E:  BCF    FD8.0
08210:  RLCF   24,W
08212:  CLRF   03
08214:  ADDLW  CE
08216:  MOVWF  FE9
08218:  MOVLW  00
0821A:  ADDWFC 03,W
0821C:  MOVWF  FEA
0821E:  MOVFF  FEC,3B0
08222:  MOVF   FED,F
08224:  MOVFF  FEF,3AF
08228:  MOVLW  0A
0822A:  SUBWF  xAF,W
0822C:  MOVWF  00
0822E:  MOVLW  00
08230:  SUBWFB xB0,W
08232:  MOVFF  3AE,FEA
08236:  MOVFF  01,FE9
0823A:  MOVWF  FEC
0823C:  MOVF   FED,F
0823E:  MOVFF  00,FEF
....................             } 
....................             menu_atual = menu_dados_ponto; 
08242:  MOVLW  10
08244:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
08246:  MOVFF  24,3AD
0824A:  MOVLB  0
0824C:  CALL   68B0
....................         break; 
08250:  BRA    8472
....................         case 2: 
....................             if (tipo[contador_lcd] <= 3){ 
08252:  CLRF   03
08254:  MOVF   24,W
08256:  ADDLW  F6
08258:  MOVWF  FE9
0825A:  MOVLW  00
0825C:  ADDWFC 03,W
0825E:  MOVWF  FEA
08260:  MOVF   FEF,W
08262:  SUBLW  03
08264:  BNC   8296
....................                 tipo[contador_lcd] = tipo[contador_lcd] +1; 
08266:  CLRF   03
08268:  MOVF   24,W
0826A:  ADDLW  F6
0826C:  MOVWF  01
0826E:  MOVLW  00
08270:  ADDWFC 03,F
08272:  MOVLB  3
08274:  MOVFF  03,3AE
08278:  CLRF   03
0827A:  MOVF   24,W
0827C:  ADDLW  F6
0827E:  MOVWF  FE9
08280:  MOVLW  00
08282:  ADDWFC 03,W
08284:  MOVWF  FEA
08286:  MOVLW  01
08288:  ADDWF  FEF,W
0828A:  MOVFF  3AE,FEA
0828E:  MOVFF  01,FE9
08292:  MOVWF  FEF
08294:  MOVLB  0
....................             } 
....................             if (tipo[contador_lcd] > 3){ 
08296:  CLRF   03
08298:  MOVF   24,W
0829A:  ADDLW  F6
0829C:  MOVWF  FE9
0829E:  MOVLW  00
082A0:  ADDWFC 03,W
082A2:  MOVWF  FEA
082A4:  MOVF   FEF,W
082A6:  SUBLW  03
082A8:  BC    82BA
....................                 tipo[contador_lcd] = 0; 
082AA:  CLRF   03
082AC:  MOVF   24,W
082AE:  ADDLW  F6
082B0:  MOVWF  FE9
082B2:  MOVLW  00
082B4:  ADDWFC 03,W
082B6:  MOVWF  FEA
082B8:  CLRF   FEF
....................             }             
....................             menu_atual = menu_dados_ponto; 
082BA:  MOVLW  10
082BC:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
082BE:  MOVFF  24,3AD
082C2:  CALL   68B0
....................         break; 
082C6:  BRA    8472
....................         case 5: 
....................             if (habilitado[contador_lcd] == TRUE){ 
082C8:  MOVFF  24,3B5
082CC:  MOVLW  01
082CE:  MOVLB  3
082D0:  MOVWF  xB7
082D2:  MOVLW  0B
082D4:  MOVWF  xB6
082D6:  MOVLB  0
082D8:  CALL   3A66
082DC:  MOVF   01,W
082DE:  ANDLW  01
082E0:  SUBLW  01
082E2:  BNZ   82FC
....................                 habilitado[contador_lcd] = FALSE; 
082E4:  MOVFF  24,3B5
082E8:  MOVLB  3
082EA:  CLRF   xB6
082EC:  MOVLW  01
082EE:  MOVWF  xB8
082F0:  MOVLW  0B
082F2:  MOVWF  xB7
082F4:  MOVLB  0
082F6:  CALL   3A24
....................             } else { 
082FA:  BRA    8312
....................                 habilitado[contador_lcd] = TRUE; 
082FC:  MOVFF  24,3B5
08300:  MOVLW  01
08302:  MOVLB  3
08304:  MOVWF  xB6
08306:  MOVWF  xB8
08308:  MOVLW  0B
0830A:  MOVWF  xB7
0830C:  MOVLB  0
0830E:  CALL   3A24
....................             }             
....................             menu_atual = menu_dados_ponto; 
08312:  MOVLW  10
08314:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
08316:  MOVFF  24,3AD
0831A:  CALL   68B0
....................         break; 
0831E:  BRA    8472
....................         case 8: 
....................            if (contador_lcd < (pontos_no_modelo/2)){ 
08320:  BCF    FD8.0
08322:  MOVLB  1
08324:  RRCF   x0A,W
08326:  SUBWF  24,W
08328:  BC    833A
....................                 sobe_ferros(3); 
0832A:  MOVLW  03
0832C:  MOVLB  3
0832E:  MOVWF  xB2
08330:  MOVLB  0
08332:  CALL   6D30
....................             } else { 
08336:  BRA    8346
08338:  MOVLB  1
....................                 sobe_ferros(2); 
0833A:  MOVLW  02
0833C:  MOVLB  3
0833E:  MOVWF  xB2
08340:  MOVLB  0
08342:  CALL   6D30
....................             } 
....................             desliga_pressor(); 
08346:  CALL   6AB0
....................         break; 
0834A:  BRA    8472
....................         case 0: 
....................             if (contador_lcd < (pontos_no_modelo/2)){ 
0834C:  BCF    FD8.0
0834E:  MOVLB  1
08350:  RRCF   x0A,W
08352:  SUBWF  24,W
08354:  BC    8366
....................                 desce_ferros(3); 
08356:  MOVLW  03
08358:  MOVLB  3
0835A:  MOVWF  xB2
0835C:  MOVLB  0
0835E:  CALL   6D6C
....................             } else { 
08362:  BRA    8372
08364:  MOVLB  1
....................                 desce_ferros(2); 
08366:  MOVLW  02
08368:  MOVLB  3
0836A:  MOVWF  xB2
0836C:  MOVLB  0
0836E:  CALL   6D6C
....................             } 
....................             liga_pressor(); 
08372:  CALL   651E
....................         break; 
08376:  BRA    8472
....................         case F1: 
....................             printf(lcd_putc, "\f"); // limpa display 
08378:  MOVLW  0C
0837A:  MOVLB  3
0837C:  MOVWF  xBD
0837E:  MOVLB  0
08380:  CALL   2440
....................             printf(lcd_putc, "GRAVANDO PONTO\n\r"); 
08384:  MOVLW  90
08386:  MOVWF  FF6
08388:  MOVLW  0E
0838A:  MOVWF  FF7
0838C:  CALL   2494
....................             delay_ms(2000); 
08390:  MOVLW  08
08392:  MOVLB  3
08394:  MOVWF  xAD
08396:  MOVLW  FA
08398:  MOVWF  xBE
0839A:  MOVLB  0
0839C:  CALL   206E
083A0:  MOVLB  3
083A2:  DECFSZ xAD,F
083A4:  BRA    8396
....................             escrever_ponto_memoria(modelo,contador_lcd); 
083A6:  MOVFF  2D,3AD
083AA:  MOVFF  24,3AE
083AE:  MOVLB  0
083B0:  GOTO   6DA8
....................             printf(lcd_putc, "\f"); // limpa display 
083B4:  MOVLW  0C
083B6:  MOVLB  3
083B8:  MOVWF  xBD
083BA:  MOVLB  0
083BC:  CALL   2440
....................             printf(lcd_putc, "PONTO GRAVADO\n\r"); 
083C0:  MOVLW  A2
083C2:  MOVWF  FF6
083C4:  MOVLW  0E
083C6:  MOVWF  FF7
083C8:  CALL   2494
....................             delay_ms(2000); 
083CC:  MOVLW  08
083CE:  MOVLB  3
083D0:  MOVWF  xAD
083D2:  MOVLW  FA
083D4:  MOVWF  xBE
083D6:  MOVLB  0
083D8:  CALL   206E
083DC:  MOVLB  3
083DE:  DECFSZ xAD,F
083E0:  BRA    83D2
....................             menu_atual = menu_seleciona_pontos; 
083E2:  MOVLW  0F
083E4:  MOVWF  1C
....................             tela_seleciona_pontos(); 
083E6:  MOVLB  0
083E8:  CALL   652E
....................             contador_lcd = 0; 
083EC:  CLRF   24
....................             motor_run_z(0, 19); 
083EE:  MOVLB  3
083F0:  CLRF   xB7
083F2:  CLRF   xB6
083F4:  CLRF   xB5
083F6:  CLRF   xB4
083F8:  MOVLW  13
083FA:  MOVWF  xB8
083FC:  MOVLB  0
083FE:  CALL   5642
....................             while ((run_flg_z)); 
08402:  MOVLB  2
08404:  BTFSC  xC6.1
08406:  BRA    8404
....................             sobe_ferros(3); 
08408:  MOVLW  03
0840A:  MOVLB  3
0840C:  MOVWF  xB2
0840E:  MOVLB  0
08410:  CALL   6D30
....................         break; 
08414:  BRA    8472
....................         case ESC: 
....................             menu_atual = menu_seleciona_pontos; 
08416:  MOVLW  0F
08418:  MOVWF  1C
....................             tela_seleciona_pontos(); 
0841A:  CALL   652E
....................             contador_lcd = 0; 
0841E:  CLRF   24
....................             motor_run_z(0, 19); 
08420:  MOVLB  3
08422:  CLRF   xB7
08424:  CLRF   xB6
08426:  CLRF   xB5
08428:  CLRF   xB4
0842A:  MOVLW  13
0842C:  MOVWF  xB8
0842E:  MOVLB  0
08430:  CALL   5642
....................             while ((run_flg_z)); 
08434:  MOVLB  2
08436:  BTFSC  xC6.1
08438:  BRA    8436
....................             sobe_ferros(3); 
0843A:  MOVLW  03
0843C:  MOVLB  3
0843E:  MOVWF  xB2
08440:  MOVLB  0
08442:  CALL   6D30
....................         break; 
08446:  BRA    8472
....................         case ENTER: 
....................             soldar_teste(tipo[contador_lcd],contador_lcd); 
08448:  CLRF   03
0844A:  MOVF   24,W
0844C:  ADDLW  F6
0844E:  MOVWF  FE9
08450:  MOVLW  00
08452:  ADDWFC 03,W
08454:  MOVWF  FEA
08456:  MOVFF  FEF,3AD
0845A:  MOVFF  3AD,3AE
0845E:  MOVFF  24,3AF
08462:  GOTO   716E
....................             menu_atual = menu_dados_ponto; 
08466:  MOVLW  10
08468:  MOVWF  1C
....................             tela_dados_ponto(contador_lcd); 
0846A:  MOVFF  24,3AD
0846E:  CALL   68B0
....................         break;  
....................     } 
08472:  GOTO   A9A2 (RETURN)
.................... } 
....................  
.................... void atualiza_tela_seleciona_manutencao(){ 
....................     switch(Teclado())    { 
*
087EA:  CALL   505E
087EE:  MOVF   01,W
087F0:  XORLW  0A
087F2:  BZ    87FE
087F4:  XORLW  01
087F6:  BZ    8806
087F8:  XORLW  19
087FA:  BZ    880E
087FC:  BRA    8816
....................         case F1:  
....................             menu_atual = menu_debug_entrada_1; 
087FE:  MOVLW  04
08800:  MOVWF  1C
....................             tela_debug_entrada_1(); 
08802:  RCALL  85A2
....................         break; 
08804:  BRA    8816
....................         case F2: 
....................             menu_atual = menu_debug_saida_1; 
08806:  MOVLW  08
08808:  MOVWF  1C
....................             tela_debug_saida_1(); 
0880A:  RCALL  8790
....................         break; 
0880C:  BRA    8816
....................         case ESC: 
....................             menu_atual = menu_seleciona_debug; 
0880E:  MOVLW  02
08810:  MOVWF  1C
....................             tela_seleciona_debug(); 
08812:  CALL   6470
....................         break; 
....................     } 
08816:  GOTO   A9B2 (RETURN)
.................... } 
.................... void atualiza_tela_debug_entrada_1(){ 
....................     while (Teclado() == 0xff ){ 
*
08A08:  CALL   505E
08A0C:  INCFSZ 01,W
08A0E:  BRA    8A60
....................         for (int i=0; i<9; i++){ 
08A10:  MOVLB  3
08A12:  CLRF   xAD
08A14:  MOVF   xAD,W
08A16:  SUBLW  08
08A18:  BNC   8A5A
....................             if (le_Input(i) == true){ 
08A1A:  MOVFF  3AD,3B2
08A1E:  MOVLB  0
08A20:  CALL   409A
08A24:  DECFSZ 01,W
08A26:  BRA    8A40
....................                 entradas [i] = 1; 
08A28:  MOVFF  3AD,3B5
08A2C:  MOVLW  01
08A2E:  MOVLB  3
08A30:  MOVWF  xB6
08A32:  CLRF   xB8
08A34:  MOVLW  1D
08A36:  MOVWF  xB7
08A38:  MOVLB  0
08A3A:  CALL   3A24
....................             } else { 
08A3E:  BRA    8A54
....................                 entradas [i] = 0; 
08A40:  MOVFF  3AD,3B5
08A44:  MOVLB  3
08A46:  CLRF   xB6
08A48:  CLRF   xB8
08A4A:  MOVLW  1D
08A4C:  MOVWF  xB7
08A4E:  MOVLB  0
08A50:  CALL   3A24
....................             } 
08A54:  MOVLB  3
08A56:  INCF   xAD,F
08A58:  BRA    8A14
....................         } 
....................         tela_debug_entrada_1(); 
08A5A:  MOVLB  0
08A5C:  RCALL  85A2
08A5E:  BRA    8A08
....................     } 
....................     switch(Teclado()){ 
08A60:  CALL   505E
08A64:  MOVF   01,W
08A66:  XORLW  10
08A68:  BZ    8A70
08A6A:  XORLW  02
08A6C:  BZ    8A78
08A6E:  BRA    8A80
....................         case SETA_DIREITA:  
....................             menu_atual = menu_debug_entrada_2; 
08A70:  MOVLW  05
08A72:  MOVWF  1C
....................             tela_debug_entrada_2(); 
08A74:  RCALL  881A
....................             break;         
08A76:  BRA    8A80
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
08A78:  MOVLW  03
08A7A:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
08A7C:  CALL   662A
....................         break; 
....................     } 
08A80:  GOTO   A9BA (RETURN)
.................... } 
.................... void atualiza_tela_debug_entrada_2 () { 
....................     while (Teclado () == 0xff ){ 
*
08CA6:  CALL   505E
08CAA:  INCFSZ 01,W
08CAC:  BRA    8D00
....................         for (int i=9; i<18; i++){ 
08CAE:  MOVLW  09
08CB0:  MOVLB  3
08CB2:  MOVWF  xAD
08CB4:  MOVF   xAD,W
08CB6:  SUBLW  11
08CB8:  BNC   8CFC
....................             if (le_Input(i) == true){ 
08CBA:  MOVFF  3AD,3B2
08CBE:  MOVLB  0
08CC0:  CALL   409A
08CC4:  DECFSZ 01,W
08CC6:  BRA    8CE0
....................                 entradas [i] = 1; 
08CC8:  MOVFF  3AD,3B5
08CCC:  MOVLW  01
08CCE:  MOVLB  3
08CD0:  MOVWF  xB6
08CD2:  CLRF   xB8
08CD4:  MOVLW  1D
08CD6:  MOVWF  xB7
08CD8:  MOVLB  0
08CDA:  CALL   3A24
....................             } else { 
08CDE:  BRA    8CF4
....................                 entradas [i] = 0; 
08CE0:  MOVFF  3AD,3B5
08CE4:  MOVLB  3
08CE6:  CLRF   xB6
08CE8:  CLRF   xB8
08CEA:  MOVLW  1D
08CEC:  MOVWF  xB7
08CEE:  MOVLB  0
08CF0:  CALL   3A24
....................             } 
....................             tela_debug_entrada_2(); 
08CF4:  RCALL  881A
08CF6:  MOVLB  3
08CF8:  INCF   xAD,F
08CFA:  BRA    8CB4
....................         } 
08CFC:  MOVLB  0
08CFE:  BRA    8CA6
....................     } 
....................     switch(Teclado()){ 
08D00:  CALL   505E
08D04:  MOVF   01,W
08D06:  XORLW  11
08D08:  BZ    8D14
08D0A:  XORLW  01
08D0C:  BZ    8D1C
08D0E:  XORLW  02
08D10:  BZ    8D24
08D12:  BRA    8D2C
....................         case SETA_ESQUERDA:  
....................             menu_atual = menu_debug_entrada_1; 
08D14:  MOVLW  04
08D16:  MOVWF  1C
....................             tela_debug_entrada_1(); 
08D18:  RCALL  85A2
....................             break; 
08D1A:  BRA    8D2C
....................         case SETA_DIREITA:  
....................             menu_atual = menu_debug_entrada_3; 
08D1C:  MOVLW  06
08D1E:  MOVWF  1C
....................             tela_debug_entrada_3(); 
08D20:  RCALL  8A84
....................             break; 
08D22:  BRA    8D2C
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
08D24:  MOVLW  03
08D26:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
08D28:  CALL   662A
....................         break; 
....................     } 
08D2C:  GOTO   A9C2 (RETURN)
.................... } 
.................... void atualiza_tela_debug_entrada_3 (){ 
....................     while (Teclado() == 0xff){ 
08D30:  CALL   505E
08D34:  INCFSZ 01,W
08D36:  BRA    8D8A
....................         for (int i=18; i<28; i++){ 
08D38:  MOVLW  12
08D3A:  MOVLB  3
08D3C:  MOVWF  xAD
08D3E:  MOVF   xAD,W
08D40:  SUBLW  1B
08D42:  BNC   8D84
....................             if (le_Input(i) == true){ 
08D44:  MOVFF  3AD,3B2
08D48:  MOVLB  0
08D4A:  CALL   409A
08D4E:  DECFSZ 01,W
08D50:  BRA    8D6A
....................                 entradas [i] = 1; 
08D52:  MOVFF  3AD,3B5
08D56:  MOVLW  01
08D58:  MOVLB  3
08D5A:  MOVWF  xB6
08D5C:  CLRF   xB8
08D5E:  MOVLW  1D
08D60:  MOVWF  xB7
08D62:  MOVLB  0
08D64:  CALL   3A24
....................             } else { 
08D68:  BRA    8D7E
....................                 entradas [i] = 0; 
08D6A:  MOVFF  3AD,3B5
08D6E:  MOVLB  3
08D70:  CLRF   xB6
08D72:  CLRF   xB8
08D74:  MOVLW  1D
08D76:  MOVWF  xB7
08D78:  MOVLB  0
08D7A:  CALL   3A24
....................             } 
08D7E:  MOVLB  3
08D80:  INCF   xAD,F
08D82:  BRA    8D3E
....................         } 
....................         tela_debug_entrada_3(); 
08D84:  MOVLB  0
08D86:  RCALL  8A84
08D88:  BRA    8D30
....................     } 
....................     switch(Teclado()){ 
08D8A:  CALL   505E
08D8E:  MOVF   01,W
08D90:  XORLW  11
08D92:  BZ    8D9A
08D94:  XORLW  03
08D96:  BZ    8DA2
08D98:  BRA    8DAA
....................         case SETA_ESQUERDA:  
....................             menu_atual = menu_debug_entrada_2; 
08D9A:  MOVLW  05
08D9C:  MOVWF  1C
....................             tela_debug_entrada_2(); 
08D9E:  RCALL  881A
....................             break; 
08DA0:  BRA    8DAA
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
08DA2:  MOVLW  03
08DA4:  MOVWF  1C
....................             tela_seleciona_manutencao(); 
08DA6:  CALL   662A
....................         break; 
....................     } 
08DAA:  GOTO   A9CA (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_1(){ 
....................     switch(Teclado()){ 
*
08E08:  CALL   505E
08E0C:  MOVLW  0A
08E0E:  SUBWF  01,W
08E10:  ADDLW  F7
08E12:  BTFSC  FD8.0
08E14:  BRA    8F24
08E16:  ADDLW  09
08E18:  GOTO   8F28
....................         case F1: 
....................             switch(ponteiro_lcd){ 
08E1C:  MOVF   21,W
08E1E:  XORLW  01
08E20:  BZ    8E2C
08E22:  XORLW  03
08E24:  BZ    8E3C
08E26:  XORLW  01
08E28:  BZ    8E4C
08E2A:  BRA    8E7C
....................                 case 1: 
....................                     aciona_saida(RELE_ESTEIRA); 
08E2C:  MOVLB  3
08E2E:  CLRF   xB8
08E30:  MOVLW  0A
08E32:  MOVWF  xB7
08E34:  MOVLB  0
08E36:  CALL   252C
....................                 break; 
08E3A:  BRA    8E7C
....................                 case 2: 
....................                     aciona_saida(DEDO_ENTRADA); 
08E3C:  MOVLB  3
08E3E:  CLRF   xB8
08E40:  MOVLW  07
08E42:  MOVWF  xB7
08E44:  MOVLB  0
08E46:  CALL   252C
....................                 break; 
08E4A:  BRA    8E7C
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
08E4C:  MOVLB  3
08E4E:  CLRF   xB8
08E50:  MOVLW  06
08E52:  MOVWF  xB7
08E54:  MOVLB  0
08E56:  CALL   252C
....................                     delay_ms(3000); 
08E5A:  MOVLW  0C
08E5C:  MOVLB  3
08E5E:  MOVWF  xAD
08E60:  MOVLW  FA
08E62:  MOVWF  xBE
08E64:  MOVLB  0
08E66:  CALL   206E
08E6A:  MOVLB  3
08E6C:  DECFSZ xAD,F
08E6E:  BRA    8E60
....................                     desaciona_saida(EMPURRADOR_ENTRADA_SOL_EMPURRA); 
08E70:  CLRF   xB8
08E72:  MOVLW  06
08E74:  MOVWF  xB7
08E76:  MOVLB  0
08E78:  CALL   24EA
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_1; 
08E7C:  MOVLW  08
08E7E:  MOVWF  1C
....................             tela_debug_saida_1(); 
08E80:  RCALL  8790
....................         break; 
08E82:  BRA    8F24
....................         case F2:             
....................             switch(ponteiro_lcd){ 
08E84:  MOVF   21,W
08E86:  XORLW  01
08E88:  BZ    8E94
08E8A:  XORLW  03
08E8C:  BZ    8EA4
08E8E:  XORLW  01
08E90:  BZ    8EB4
08E92:  BRA    8EE4
....................                 case 1: 
....................                     desaciona_saida(RELE_ESTEIRA); 
08E94:  MOVLB  3
08E96:  CLRF   xB8
08E98:  MOVLW  0A
08E9A:  MOVWF  xB7
08E9C:  MOVLB  0
08E9E:  CALL   24EA
....................                 break; 
08EA2:  BRA    8EE4
....................                 case 2: 
....................                     desaciona_saida(DEDO_ENTRADA); 
08EA4:  MOVLB  3
08EA6:  CLRF   xB8
08EA8:  MOVLW  07
08EAA:  MOVWF  xB7
08EAC:  MOVLB  0
08EAE:  CALL   24EA
....................                 break; 
08EB2:  BRA    8EE4
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
08EB4:  MOVLB  3
08EB6:  CLRF   xB8
08EB8:  MOVLW  05
08EBA:  MOVWF  xB7
08EBC:  MOVLB  0
08EBE:  CALL   252C
....................                     delay_ms(3000); 
08EC2:  MOVLW  0C
08EC4:  MOVLB  3
08EC6:  MOVWF  xAD
08EC8:  MOVLW  FA
08ECA:  MOVWF  xBE
08ECC:  MOVLB  0
08ECE:  CALL   206E
08ED2:  MOVLB  3
08ED4:  DECFSZ xAD,F
08ED6:  BRA    8EC8
....................                     desaciona_saida(EMPURRADOR_ENTRADA_SOL_RETORNA); 
08ED8:  CLRF   xB8
08EDA:  MOVLW  05
08EDC:  MOVWF  xB7
08EDE:  MOVLB  0
08EE0:  CALL   24EA
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_1; 
08EE4:  MOVLW  08
08EE6:  MOVWF  1C
....................             tela_debug_saida_1(); 
08EE8:  RCALL  8790
....................         break; 
08EEA:  BRA    8F24
....................         case SETA_DIREITA: 
....................             ponteiro_lcd = 1; 
08EEC:  MOVLW  01
08EEE:  MOVWF  21
....................             menu_atual = menu_debug_saida_2; 
08EF0:  MOVLW  09
08EF2:  MOVWF  1C
....................             tela_debug_saida_2(); 
08EF4:  RCALL  8DAE
....................         break; 
08EF6:  BRA    8F24
....................         case SETA_SUPERIOR: 
....................             if (ponteiro_lcd > 1){ 
08EF8:  MOVF   21,W
08EFA:  SUBLW  01
08EFC:  BC    8F00
....................                 ponteiro_lcd --; 
08EFE:  DECF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_1; 
08F00:  MOVLW  08
08F02:  MOVWF  1C
....................             tela_debug_saida_1(); 
08F04:  RCALL  8790
....................         break; 
08F06:  BRA    8F24
....................         case SETA_INFERIOR: 
....................             if (ponteiro_lcd < 3){ 
08F08:  MOVF   21,W
08F0A:  SUBLW  02
08F0C:  BNC   8F10
....................                 ponteiro_lcd ++; 
08F0E:  INCF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_1; 
08F10:  MOVLW  08
08F12:  MOVWF  1C
....................             tela_debug_saida_1(); 
08F14:  RCALL  8790
....................         break; 
08F16:  BRA    8F24
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
08F18:  MOVLW  03
08F1A:  MOVWF  1C
....................             tela_seleciona_manutencao();   
08F1C:  CALL   662A
....................             ponteiro_lcd = 1; 
08F20:  MOVLW  01
08F22:  MOVWF  21
....................         break; 
....................     } 
08F24:  GOTO   A9D2 (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_2(){ 
....................     switch(Teclado()){ 
*
08FB8:  CALL   505E
08FBC:  MOVLW  0A
08FBE:  SUBWF  01,W
08FC0:  ADDLW  F7
08FC2:  BTFSC  FD8.0
08FC4:  BRA    90DE
08FC6:  ADDLW  09
08FC8:  GOTO   90E2
....................         case F1: 
....................             switch(ponteiro_lcd){ 
08FCC:  MOVF   21,W
08FCE:  XORLW  01
08FD0:  BZ    8FDC
08FD2:  XORLW  03
08FD4:  BZ    8FEC
08FD6:  XORLW  01
08FD8:  BZ    8FFC
08FDA:  BRA    9028
....................                 case 1: 
....................                     aciona_saida(PRESSOR); 
08FDC:  MOVLB  3
08FDE:  CLRF   xB8
08FE0:  MOVLW  04
08FE2:  MOVWF  xB7
08FE4:  MOVLB  0
08FE6:  CALL   252C
....................                 break; 
08FEA:  BRA    9028
....................                 case 2: 
....................                     aciona_saida(DEDO_SAIDA); 
08FEC:  MOVLB  3
08FEE:  CLRF   xB8
08FF0:  MOVLW  01
08FF2:  MOVWF  xB7
08FF4:  MOVLB  0
08FF6:  CALL   252C
....................                 break; 
08FFA:  BRA    9028
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
08FFC:  MOVLB  3
08FFE:  CLRF   xB8
09000:  CLRF   xB7
09002:  MOVLB  0
09004:  CALL   252C
....................                     delay_ms(3000); 
09008:  MOVLW  0C
0900A:  MOVLB  3
0900C:  MOVWF  xAD
0900E:  MOVLW  FA
09010:  MOVWF  xBE
09012:  MOVLB  0
09014:  CALL   206E
09018:  MOVLB  3
0901A:  DECFSZ xAD,F
0901C:  BRA    900E
....................                     desaciona_saida(EMPURRADOR_SAIDA_SOL_EMPURRA); 
0901E:  CLRF   xB8
09020:  CLRF   xB7
09022:  MOVLB  0
09024:  CALL   24EA
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_2; 
09028:  MOVLW  09
0902A:  MOVWF  1C
....................             tela_debug_saida_2(); 
0902C:  RCALL  8DAE
....................         break; 
0902E:  BRA    90DE
....................         case F2:             
....................             switch(ponteiro_lcd){ 
09030:  MOVF   21,W
09032:  XORLW  01
09034:  BZ    9040
09036:  XORLW  03
09038:  BZ    9050
0903A:  XORLW  01
0903C:  BZ    9060
0903E:  BRA    9090
....................                 case 1: 
....................                     desaciona_saida(PRESSOR); 
09040:  MOVLB  3
09042:  CLRF   xB8
09044:  MOVLW  04
09046:  MOVWF  xB7
09048:  MOVLB  0
0904A:  CALL   24EA
....................                 break; 
0904E:  BRA    9090
....................                 case 2: 
....................                     desaciona_saida(DEDO_SAIDA); 
09050:  MOVLB  3
09052:  CLRF   xB8
09054:  MOVLW  01
09056:  MOVWF  xB7
09058:  MOVLB  0
0905A:  CALL   24EA
....................                 break; 
0905E:  BRA    9090
....................                 case 3: 
....................                     aciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
09060:  MOVLB  3
09062:  CLRF   xB8
09064:  MOVLW  0F
09066:  MOVWF  xB7
09068:  MOVLB  0
0906A:  CALL   252C
....................                     delay_ms(3000); 
0906E:  MOVLW  0C
09070:  MOVLB  3
09072:  MOVWF  xAD
09074:  MOVLW  FA
09076:  MOVWF  xBE
09078:  MOVLB  0
0907A:  CALL   206E
0907E:  MOVLB  3
09080:  DECFSZ xAD,F
09082:  BRA    9074
....................                     desaciona_saida(EMPURRADOR_SAIDA_SOL_RETORNA); 
09084:  CLRF   xB8
09086:  MOVLW  0F
09088:  MOVWF  xB7
0908A:  MOVLB  0
0908C:  CALL   24EA
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_2; 
09090:  MOVLW  09
09092:  MOVWF  1C
....................             tela_debug_saida_2(); 
09094:  RCALL  8DAE
....................         break; 
09096:  BRA    90DE
....................         case SETA_DIREITA: 
....................             ponteiro_lcd = 1; 
09098:  MOVLW  01
0909A:  MOVWF  21
....................             menu_atual = menu_debug_saida_3; 
0909C:  MOVLW  0A
0909E:  MOVWF  1C
....................             tela_debug_saida_3(); 
090A0:  RCALL  8F5E
....................         break; 
090A2:  BRA    90DE
....................         case SETA_ESQUERDA: 
....................             ponteiro_lcd = 1; 
090A4:  MOVLW  01
090A6:  MOVWF  21
....................             menu_atual = menu_debug_saida_1; 
090A8:  MOVLW  08
090AA:  MOVWF  1C
....................             tela_debug_saida_1(); 
090AC:  CALL   8790
....................         break; 
090B0:  BRA    90DE
....................         case SETA_SUPERIOR: 
....................             if (ponteiro_lcd > 1){ 
090B2:  MOVF   21,W
090B4:  SUBLW  01
090B6:  BC    90BA
....................                 ponteiro_lcd --; 
090B8:  DECF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_2; 
090BA:  MOVLW  09
090BC:  MOVWF  1C
....................             tela_debug_saida_2(); 
090BE:  RCALL  8DAE
....................         break; 
090C0:  BRA    90DE
....................         case SETA_INFERIOR: 
....................             if (ponteiro_lcd < 3){ 
090C2:  MOVF   21,W
090C4:  SUBLW  02
090C6:  BNC   90CA
....................                 ponteiro_lcd ++; 
090C8:  INCF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_2; 
090CA:  MOVLW  09
090CC:  MOVWF  1C
....................             tela_debug_saida_2(); 
090CE:  RCALL  8DAE
....................         break; 
090D0:  BRA    90DE
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
090D2:  MOVLW  03
090D4:  MOVWF  1C
....................             tela_seleciona_manutencao();   
090D6:  CALL   662A
....................             ponteiro_lcd = 1; 
090DA:  MOVLW  01
090DC:  MOVWF  21
....................         break; 
....................     } 
090DE:  GOTO   A9DA (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_3(){ 
....................     switch(Teclado()){ 
*
091F6:  CALL   505E
091FA:  MOVLW  0A
091FC:  SUBWF  01,W
091FE:  ADDLW  F7
09200:  BTFSC  FD8.0
09202:  BRA    934A
09204:  ADDLW  09
09206:  GOTO   934E
....................         case F1: 
....................             switch(ponteiro_lcd){ 
0920A:  MOVF   21,W
0920C:  XORLW  01
0920E:  BZ    921A
09210:  XORLW  03
09212:  BZ    9246
09214:  XORLW  01
09216:  BZ    9264
09218:  BRA    9280
....................                 case 1: 
....................                     aciona_saida(ALIMENTADOR1); 
0921A:  MOVLB  3
0921C:  CLRF   xB8
0921E:  MOVLW  0E
09220:  MOVWF  xB7
09222:  MOVLB  0
09224:  CALL   252C
....................                     aciona_saida(ALIMENTADOR2); 
09228:  MOVLB  3
0922A:  CLRF   xB8
0922C:  MOVLW  0D
0922E:  MOVWF  xB7
09230:  MOVLB  0
09232:  CALL   252C
....................                     aciona_saida(ALIMENTADOR3); 
09236:  MOVLB  3
09238:  CLRF   xB8
0923A:  MOVLW  0C
0923C:  MOVWF  xB7
0923E:  MOVLB  0
09240:  CALL   252C
....................                 break; 
09244:  BRA    9280
....................                 case 2: 
....................                     aciona_saida(LIMPA_BICO1); 
09246:  MOVLB  3
09248:  CLRF   xB8
0924A:  MOVLW  08
0924C:  MOVWF  xB7
0924E:  MOVLB  0
09250:  CALL   252C
....................                     aciona_saida(LIMPA_BICO2); 
09254:  MOVLB  3
09256:  CLRF   xB8
09258:  MOVLW  09
0925A:  MOVWF  xB7
0925C:  MOVLB  0
0925E:  CALL   252C
....................                 break; 
09262:  BRA    9280
....................                 case 3: 
....................                     aciona_saida(FERRO_SOLDA1); 
09264:  MOVLB  3
09266:  CLRF   xB8
09268:  MOVLW  03
0926A:  MOVWF  xB7
0926C:  MOVLB  0
0926E:  CALL   252C
....................                     aciona_saida(FERRO_SOLDA2); 
09272:  MOVLB  3
09274:  CLRF   xB8
09276:  MOVLW  02
09278:  MOVWF  xB7
0927A:  MOVLB  0
0927C:  CALL   252C
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_3; 
09280:  MOVLW  0A
09282:  MOVWF  1C
....................             tela_debug_saida_3(); 
09284:  RCALL  8F5E
....................         break; 
09286:  BRA    934A
....................         case F2:             
....................             switch(ponteiro_lcd){ 
09288:  MOVF   21,W
0928A:  XORLW  01
0928C:  BZ    9298
0928E:  XORLW  03
09290:  BZ    92C4
09292:  XORLW  01
09294:  BZ    92E2
09296:  BRA    92FE
....................                 case 1: 
....................                     desaciona_saida(ALIMENTADOR1); 
09298:  MOVLB  3
0929A:  CLRF   xB8
0929C:  MOVLW  0E
0929E:  MOVWF  xB7
092A0:  MOVLB  0
092A2:  CALL   24EA
....................                     desaciona_saida(ALIMENTADOR2); 
092A6:  MOVLB  3
092A8:  CLRF   xB8
092AA:  MOVLW  0D
092AC:  MOVWF  xB7
092AE:  MOVLB  0
092B0:  CALL   24EA
....................                     desaciona_saida(ALIMENTADOR3); 
092B4:  MOVLB  3
092B6:  CLRF   xB8
092B8:  MOVLW  0C
092BA:  MOVWF  xB7
092BC:  MOVLB  0
092BE:  CALL   24EA
....................                 break; 
092C2:  BRA    92FE
....................                 case 2: 
....................                     desaciona_saida(LIMPA_BICO1); 
092C4:  MOVLB  3
092C6:  CLRF   xB8
092C8:  MOVLW  08
092CA:  MOVWF  xB7
092CC:  MOVLB  0
092CE:  CALL   24EA
....................                     desaciona_saida(LIMPA_BICO2); 
092D2:  MOVLB  3
092D4:  CLRF   xB8
092D6:  MOVLW  09
092D8:  MOVWF  xB7
092DA:  MOVLB  0
092DC:  CALL   24EA
....................                 break; 
092E0:  BRA    92FE
....................                 case 3: 
....................                     desaciona_saida(FERRO_SOLDA1); 
092E2:  MOVLB  3
092E4:  CLRF   xB8
092E6:  MOVLW  03
092E8:  MOVWF  xB7
092EA:  MOVLB  0
092EC:  CALL   24EA
....................                     desaciona_saida(FERRO_SOLDA2); 
092F0:  MOVLB  3
092F2:  CLRF   xB8
092F4:  MOVLW  02
092F6:  MOVWF  xB7
092F8:  MOVLB  0
092FA:  CALL   24EA
....................                 break; 
....................             } 
....................             menu_atual = menu_debug_saida_3; 
092FE:  MOVLW  0A
09300:  MOVWF  1C
....................             tela_debug_saida_3(); 
09302:  RCALL  8F5E
....................         break; 
09304:  BRA    934A
....................         case SETA_DIREITA: 
....................             ponteiro_lcd = 1; 
09306:  MOVLW  01
09308:  MOVWF  21
....................             menu_atual = menu_debug_saida_4; 
0930A:  MOVLW  0B
0930C:  MOVWF  1C
....................             tela_debug_saida_4(); 
0930E:  RCALL  9118
....................         break; 
09310:  BRA    934A
....................         case SETA_ESQUERDA: 
....................             ponteiro_lcd = 1; 
09312:  MOVLW  01
09314:  MOVWF  21
....................             menu_atual = menu_debug_saida_2; 
09316:  MOVLW  09
09318:  MOVWF  1C
....................             tela_debug_saida_2(); 
0931A:  RCALL  8DAE
....................         break; 
0931C:  BRA    934A
....................         case SETA_SUPERIOR: 
....................             if (ponteiro_lcd > 1){ 
0931E:  MOVF   21,W
09320:  SUBLW  01
09322:  BC    9326
....................                 ponteiro_lcd --; 
09324:  DECF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_3; 
09326:  MOVLW  0A
09328:  MOVWF  1C
....................             tela_debug_saida_3(); 
0932A:  RCALL  8F5E
....................         break; 
0932C:  BRA    934A
....................         case SETA_INFERIOR: 
....................             if (ponteiro_lcd < 3){ 
0932E:  MOVF   21,W
09330:  SUBLW  02
09332:  BNC   9336
....................                 ponteiro_lcd ++; 
09334:  INCF   21,F
....................             } 
....................             menu_atual = menu_debug_saida_3; 
09336:  MOVLW  0A
09338:  MOVWF  1C
....................             tela_debug_saida_3(); 
0933A:  RCALL  8F5E
....................         break; 
0933C:  BRA    934A
....................         case ESC: 
....................             menu_atual = menu_seleciona_manutencao; 
0933E:  MOVLW  03
09340:  MOVWF  1C
....................             tela_seleciona_manutencao();   
09342:  CALL   662A
....................             ponteiro_lcd = 1; 
09346:  MOVLW  01
09348:  MOVWF  21
....................         break; 
....................     } 
0934A:  GOTO   A9E2 (RETURN)
.................... } 
.................... void atualiza_tela_debug_saida_4(){ 
....................     switch(Teclado()){ 
*
09384:  CALL   505E
09388:  MOVF   01,W
0938A:  ADDLW  ED
0938C:  BTFSC  FD8.0
0938E:  BRA    9588
09390:  ADDLW  13
09392:  GOTO   958C
....................         case SETA_SUPERIOR: 
....................             atras(); 
09396:  CALL   446C
....................             if (motor_pos_y < 6110){ 
0939A:  MOVLB  1
0939C:  MOVF   x15,W
0939E:  SUBLW  17
093A0:  BNC   93D6
093A2:  BNZ   93AA
093A4:  MOVF   x14,W
093A6:  SUBLW  DD
093A8:  BNC   93D6
....................                 motor_run_y(motor_pos_y+10, 19); 
093AA:  MOVLW  0A
093AC:  ADDWF  x14,W
093AE:  MOVLB  3
093B0:  MOVWF  xAD
093B2:  MOVLW  00
093B4:  MOVLB  1
093B6:  ADDWFC x15,W
093B8:  MOVLB  3
093BA:  MOVWF  xAE
093BC:  CLRF   xB7
093BE:  CLRF   xB6
093C0:  MOVWF  xB5
093C2:  MOVFF  3AD,3B4
093C6:  MOVLW  13
093C8:  MOVWF  xB8
093CA:  MOVLB  0
093CC:  CALL   580C
....................                 while ((run_flg_y)); 
093D0:  MOVLB  1
093D2:  BTFSC  x1A.6
093D4:  BRA    93D2
....................             } 
....................             menu_atual = menu_debug_saida_4; 
093D6:  MOVLW  0B
093D8:  MOVWF  1C
....................             tela_debug_saida_4(); 
093DA:  MOVLB  0
093DC:  RCALL  9118
....................         break; 
093DE:  BRA    9588
....................         case SETA_INFERIOR: 
....................             frente(); 
093E0:  CALL   442A
....................             if (motor_pos_y > 0){ 
093E4:  MOVLB  1
093E6:  MOVF   x14,F
093E8:  BNZ   93EE
093EA:  MOVF   x15,F
093EC:  BZ    941A
....................                 motor_run_y(motor_pos_y-10, 19); 
093EE:  MOVLW  0A
093F0:  SUBWF  x14,W
093F2:  MOVLB  3
093F4:  MOVWF  xAD
093F6:  MOVLW  00
093F8:  MOVLB  1
093FA:  SUBWFB x15,W
093FC:  MOVLB  3
093FE:  MOVWF  xAE
09400:  CLRF   xB7
09402:  CLRF   xB6
09404:  MOVWF  xB5
09406:  MOVFF  3AD,3B4
0940A:  MOVLW  13
0940C:  MOVWF  xB8
0940E:  MOVLB  0
09410:  CALL   580C
....................                 while ((run_flg_y)); 
09414:  MOVLB  1
09416:  BTFSC  x1A.6
09418:  BRA    9416
....................             } 
....................             menu_atual = menu_debug_saida_4; 
0941A:  MOVLW  0B
0941C:  MOVWF  1C
....................             tela_debug_saida_4(); 
0941E:  MOVLB  0
09420:  RCALL  9118
....................         break; 
09422:  BRA    9588
....................         case SETA_DIREITA: 
....................             direita(); 
09424:  CALL   4596
....................             if (motor_pos_x > 0){ 
09428:  MOVLB  1
0942A:  MOVF   x12,F
0942C:  BNZ   9432
0942E:  MOVF   x13,F
09430:  BZ    945E
....................                 motor_run_x(motor_pos_x-10, 19); 
09432:  MOVLW  0A
09434:  SUBWF  x12,W
09436:  MOVLB  3
09438:  MOVWF  xAD
0943A:  MOVLW  00
0943C:  MOVLB  1
0943E:  SUBWFB x13,W
09440:  MOVLB  3
09442:  MOVWF  xAE
09444:  CLRF   xB7
09446:  CLRF   xB6
09448:  MOVWF  xB5
0944A:  MOVFF  3AD,3B4
0944E:  MOVLW  13
09450:  MOVWF  xB8
09452:  MOVLB  0
09454:  CALL   4ABC
....................                 while ((run_flg_x)); 
09458:  MOVLB  1
0945A:  BTFSC  x1A.4
0945C:  BRA    945A
....................             } 
....................             menu_atual = menu_debug_saida_4; 
0945E:  MOVLW  0B
09460:  MOVWF  1C
....................             tela_debug_saida_4(); 
09462:  MOVLB  0
09464:  RCALL  9118
....................         break; 
09466:  BRA    9588
....................         case SETA_ESQUERDA: 
....................             esquerda(); 
09468:  CALL   45D8
....................             if (motor_pos_x < 4250){ 
0946C:  MOVLB  1
0946E:  MOVF   x13,W
09470:  SUBLW  10
09472:  BNC   94A8
09474:  BNZ   947C
09476:  MOVF   x12,W
09478:  SUBLW  99
0947A:  BNC   94A8
....................                 motor_run_x(motor_pos_x+10, 19); 
0947C:  MOVLW  0A
0947E:  ADDWF  x12,W
09480:  MOVLB  3
09482:  MOVWF  xAD
09484:  MOVLW  00
09486:  MOVLB  1
09488:  ADDWFC x13,W
0948A:  MOVLB  3
0948C:  MOVWF  xAE
0948E:  CLRF   xB7
09490:  CLRF   xB6
09492:  MOVWF  xB5
09494:  MOVFF  3AD,3B4
09498:  MOVLW  13
0949A:  MOVWF  xB8
0949C:  MOVLB  0
0949E:  CALL   4ABC
....................                 while ((run_flg_x)); 
094A2:  MOVLB  1
094A4:  BTFSC  x1A.4
094A6:  BRA    94A4
....................             } 
....................             menu_atual = menu_debug_saida_4; 
094A8:  MOVLW  0B
094AA:  MOVWF  1C
....................             tela_debug_saida_4(); 
094AC:  MOVLB  0
094AE:  RCALL  9118
....................         break; 
094B0:  BRA    9588
....................         case F2: 
....................             sobe(); 
094B2:  CALL   4318
....................             if (motor_pos_z > 0){ 
094B6:  MOVLB  1
094B8:  MOVF   x18,F
094BA:  BNZ   94C0
094BC:  MOVF   x19,F
094BE:  BZ    94EE
....................                  motor_run_z(motor_pos_z-10, 19); 
094C0:  MOVLW  0A
094C2:  SUBWF  x18,W
094C4:  MOVLB  3
094C6:  MOVWF  xAD
094C8:  MOVLW  00
094CA:  MOVLB  1
094CC:  SUBWFB x19,W
094CE:  MOVLB  3
094D0:  MOVWF  xAE
094D2:  CLRF   xB7
094D4:  CLRF   xB6
094D6:  MOVWF  xB5
094D8:  MOVFF  3AD,3B4
094DC:  MOVLW  13
094DE:  MOVWF  xB8
094E0:  MOVLB  0
094E2:  CALL   5642
....................                  while ((run_flg_z)); 
094E6:  MOVLB  2
094E8:  BTFSC  xC6.1
094EA:  BRA    94E8
094EC:  MOVLB  1
....................             } 
....................             menu_atual = menu_debug_saida_4; 
094EE:  MOVLW  0B
094F0:  MOVWF  1C
....................             tela_debug_saida_4(); 
094F2:  MOVLB  0
094F4:  RCALL  9118
....................         break; 
094F6:  BRA    9588
....................         case F4: 
....................             desce(); 
094F8:  CALL   42D6
....................             if (motor_pos_z < 1000){ 
094FC:  MOVLB  1
094FE:  MOVF   x19,W
09500:  SUBLW  03
09502:  BNC   953A
09504:  BNZ   950C
09506:  MOVF   x18,W
09508:  SUBLW  E7
0950A:  BNC   953A
....................                 motor_run_z(motor_pos_z+10, 19); 
0950C:  MOVLW  0A
0950E:  ADDWF  x18,W
09510:  MOVLB  3
09512:  MOVWF  xAD
09514:  MOVLW  00
09516:  MOVLB  1
09518:  ADDWFC x19,W
0951A:  MOVLB  3
0951C:  MOVWF  xAE
0951E:  CLRF   xB7
09520:  CLRF   xB6
09522:  MOVWF  xB5
09524:  MOVFF  3AD,3B4
09528:  MOVLW  13
0952A:  MOVWF  xB8
0952C:  MOVLB  0
0952E:  CALL   5642
....................                 while ((run_flg_z)); 
09532:  MOVLB  2
09534:  BTFSC  xC6.1
09536:  BRA    9534
09538:  MOVLB  1
....................             }     
....................             menu_atual = menu_debug_saida_4; 
0953A:  MOVLW  0B
0953C:  MOVWF  1C
....................             tela_debug_saida_4(); 
0953E:  MOVLB  0
09540:  RCALL  9118
....................         break; 
09542:  BRA    9588
....................         case 8: 
....................             sentido_horario(); 
09544:  CALL   492A
....................             go_flip(1866); 
09548:  MOVLW  07
0954A:  MOVLB  3
0954C:  MOVWF  xB1
0954E:  MOVLW  4A
09550:  MOVWF  xB0
09552:  MOVLB  0
09554:  CALL   5988
....................             menu_atual = menu_debug_saida_4; 
09558:  MOVLW  0B
0955A:  MOVWF  1C
....................             tela_debug_saida_4(); 
0955C:  RCALL  9118
....................         break; 
0955E:  BRA    9588
....................         case 0: 
....................             sentido_antihorario(); 
09560:  CALL   496C
....................             go_flip(0); 
09564:  MOVLB  3
09566:  CLRF   xB1
09568:  CLRF   xB0
0956A:  MOVLB  0
0956C:  CALL   5988
....................             menu_atual = menu_debug_saida_4; 
09570:  MOVLW  0B
09572:  MOVWF  1C
....................             tela_debug_saida_4(); 
09574:  RCALL  9118
....................         break; 
09576:  BRA    9588
....................         case ESC: 
....................             home_solenoides(); 
09578:  CALL   2578
....................             posicao_maquina_1_default();  
0957C:  CALL   4CFA
....................             menu_atual = menu_seleciona_manutencao; 
09580:  MOVLW  03
09582:  MOVWF  1C
....................             tela_seleciona_manutencao();   
09584:  CALL   662A
....................         break; 
....................     } 
09588:  GOTO   A9EA (RETURN)
.................... } 
....................  
.................... void programa_principal(){ 
....................     int i; 
....................     short x; 
....................     short y; 
....................     while (exit){ 
*
0A364:  BTFSS  2C.1
0A366:  BRA    A61A
....................         for (i=0; i<14; i++){ 
0A368:  MOVLB  3
0A36A:  CLRF   xAD
0A36C:  MOVF   xAD,W
0A36E:  SUBLW  0D
0A370:  BTFSS  FD8.0
0A372:  BRA    A616
....................             switch (i){ 
0A374:  MOVF   xAD,W
0A376:  ADDLW  F2
0A378:  BTFSC  FD8.0
0A37A:  BRA    A612
0A37C:  ADDLW  0E
0A37E:  MOVLB  0
0A380:  GOTO   A624
....................                 case 0: 
....................                     liga_esteira(); 
0A384:  GOTO   95D6
....................                     if (Teclado() == ESC){ 
0A388:  CALL   505E
0A38C:  MOVF   01,W
0A38E:  SUBLW  12
0A390:  BNZ   A396
....................                         exit = FALSE; 
0A392:  BCF    2C.1
....................                     } else { 
0A394:  BRA    A398
....................                         exit = TRUE; 
0A396:  BSF    2C.1
....................                     } 
....................                 break; 
0A398:  MOVLB  3
0A39A:  BRA    A612
....................                 case 1: 
....................                     x = le_Input(S_ESTEIRA); 
0A39C:  MOVLW  19
0A39E:  MOVLB  3
0A3A0:  MOVWF  xB2
0A3A2:  MOVLB  0
0A3A4:  CALL   409A
0A3A8:  MOVLB  3
0A3AA:  BCF    xAE.0
0A3AC:  BTFSC  01.0
0A3AE:  BSF    xAE.0
....................                     while (x == 0){ 
0A3B0:  BTFSC  xAE.0
0A3B2:  BRA    A3EC
....................                         printf(lcd_putc, "\f"); //limpa display 
0A3B4:  MOVLW  0C
0A3B6:  MOVWF  xBD
0A3B8:  MOVLB  0
0A3BA:  CALL   2440
....................                         printf(lcd_putc, "   ESPERANDO PLACA   \n\r"); 
0A3BE:  MOVLW  B2
0A3C0:  MOVWF  FF6
0A3C2:  MOVLW  0E
0A3C4:  MOVWF  FF7
0A3C6:  CALL   2494
....................                         printf(lcd_putc, "     NA ESTEIRA     \n\r"); 
0A3CA:  MOVLW  CA
0A3CC:  MOVWF  FF6
0A3CE:  MOVLW  0E
0A3D0:  MOVWF  FF7
0A3D2:  CALL   2494
....................                         x = le_Input(S_ESTEIRA); 
0A3D6:  MOVLW  19
0A3D8:  MOVLB  3
0A3DA:  MOVWF  xB2
0A3DC:  MOVLB  0
0A3DE:  CALL   409A
0A3E2:  MOVLB  3
0A3E4:  BCF    xAE.0
0A3E6:  BTFSC  01.0
0A3E8:  BSF    xAE.0
0A3EA:  BRA    A3B0
....................                     } 
....................                     desliga_esteira(); 
0A3EC:  MOVLB  0
0A3EE:  GOTO   95E8
....................                     empurra_placa();                     
0A3F2:  GOTO   95FA
....................                     if (Teclado() == ESC){ 
0A3F6:  CALL   505E
0A3FA:  MOVF   01,W
0A3FC:  SUBLW  12
0A3FE:  BNZ   A404
....................                         exit = FALSE; 
0A400:  BCF    2C.1
....................                     } else { 
0A402:  BRA    A406
....................                         exit = TRUE; 
0A404:  BSF    2C.1
....................                     } 
....................                 break; 
0A406:  MOVLB  3
0A408:  BRA    A612
....................                 case 2: 
....................                     y = le_Input(S_BANDEJA); 
0A40A:  MOVLW  15
0A40C:  MOVLB  3
0A40E:  MOVWF  xB2
0A410:  MOVLB  0
0A412:  CALL   409A
0A416:  MOVLB  3
0A418:  BCF    xAE.1
0A41A:  BTFSC  01.0
0A41C:  BSF    xAE.1
....................                     while (y == 0){ 
0A41E:  BTFSC  xAE.1
0A420:  BRA    A45A
....................                         printf(lcd_putc, "\f"); //limpa display 
0A422:  MOVLW  0C
0A424:  MOVWF  xBD
0A426:  MOVLB  0
0A428:  CALL   2440
....................                         printf(lcd_putc, "      SEM PLACA     \n\r"); 
0A42C:  MOVLW  E2
0A42E:  MOVWF  FF6
0A430:  MOVLW  0E
0A432:  MOVWF  FF7
0A434:  CALL   2494
....................                         printf(lcd_putc, "     NA BANDEJA     \n\r"); 
0A438:  MOVLW  FA
0A43A:  MOVWF  FF6
0A43C:  MOVLW  0E
0A43E:  MOVWF  FF7
0A440:  CALL   2494
....................                         y = le_Input(S_BANDEJA); 
0A444:  MOVLW  15
0A446:  MOVLB  3
0A448:  MOVWF  xB2
0A44A:  MOVLB  0
0A44C:  CALL   409A
0A450:  MOVLB  3
0A452:  BCF    xAE.1
0A454:  BTFSC  01.0
0A456:  BSF    xAE.1
0A458:  BRA    A41E
....................                     } 
....................                     liga_pressor(); 
0A45A:  MOVLB  0
0A45C:  CALL   651E
....................                 if (Teclado() == ESC){ 
0A460:  CALL   505E
0A464:  MOVF   01,W
0A466:  SUBLW  12
0A468:  BNZ   A46E
....................                         exit = FALSE; 
0A46A:  BCF    2C.1
....................                     } else { 
0A46C:  BRA    A470
....................                         exit = TRUE; 
0A46E:  BSF    2C.1
....................                     } 
....................                 break; 
0A470:  MOVLB  3
0A472:  BRA    A612
....................                 case 3: 
....................                     envia_maquina_para_posicao(HOME1); 
0A474:  MOVLW  01
0A476:  MOVLB  3
0A478:  MOVWF  xAF
0A47A:  MOVLB  0
0A47C:  CALL   59E6
....................                     if (Teclado() == ESC){ 
0A480:  CALL   505E
0A484:  MOVF   01,W
0A486:  SUBLW  12
0A488:  BNZ   A48E
....................                         exit = FALSE; 
0A48A:  BCF    2C.1
....................                     } else { 
0A48C:  BRA    A490
....................                         exit = TRUE; 
0A48E:  BSF    2C.1
....................                     } 
....................                 break;  
0A490:  MOVLB  3
0A492:  BRA    A612
....................                 case 4: 
....................                     envia_maquina_para_posicao(SOLDAGEM); 
0A494:  MOVLW  03
0A496:  MOVLB  3
0A498:  MOVWF  xAF
0A49A:  MOVLB  0
0A49C:  CALL   59E6
....................                     if (Teclado() == ESC){ 
0A4A0:  CALL   505E
0A4A4:  MOVF   01,W
0A4A6:  SUBLW  12
0A4A8:  BNZ   A4AE
....................                         exit = FALSE; 
0A4AA:  BCF    2C.1
....................                     } else { 
0A4AC:  BRA    A4B0
....................                         exit = TRUE; 
0A4AE:  BSF    2C.1
....................                     } 
....................                 break; 
0A4B0:  MOVLB  3
0A4B2:  BRA    A612
....................                 case 5: 
....................                     soldar(); 
0A4B4:  GOTO   967A
....................                     motor_run_x(3835, 19); 
0A4B8:  MOVLB  3
0A4BA:  CLRF   xB7
0A4BC:  CLRF   xB6
0A4BE:  MOVLW  0E
0A4C0:  MOVWF  xB5
0A4C2:  MOVLW  FB
0A4C4:  MOVWF  xB4
0A4C6:  MOVLW  13
0A4C8:  MOVWF  xB8
0A4CA:  MOVLB  0
0A4CC:  CALL   4ABC
....................                     motor_run_y(2540, 19); 
0A4D0:  MOVLB  3
0A4D2:  CLRF   xB7
0A4D4:  CLRF   xB6
0A4D6:  MOVLW  09
0A4D8:  MOVWF  xB5
0A4DA:  MOVLW  EC
0A4DC:  MOVWF  xB4
0A4DE:  MOVLW  13
0A4E0:  MOVWF  xB8
0A4E2:  MOVLB  0
0A4E4:  CALL   580C
....................                     //go_x(3835); 
....................                     //go_y(2540); 
....................                     if (Teclado() == ESC){ 
0A4E8:  CALL   505E
0A4EC:  MOVF   01,W
0A4EE:  SUBLW  12
0A4F0:  BNZ   A4F6
....................                         exit = FALSE; 
0A4F2:  BCF    2C.1
....................                     } else { 
0A4F4:  BRA    A4F8
....................                         exit = TRUE; 
0A4F6:  BSF    2C.1
....................                     } 
....................                 break; 
0A4F8:  MOVLB  3
0A4FA:  BRA    A612
....................                 case 6: 
....................                     envia_maquina_para_posicao(HOME2); 
0A4FC:  MOVLW  04
0A4FE:  MOVLB  3
0A500:  MOVWF  xAF
0A502:  MOVLB  0
0A504:  CALL   59E6
....................                     if (Teclado() == ESC){ 
0A508:  CALL   505E
0A50C:  MOVF   01,W
0A50E:  SUBLW  12
0A510:  BNZ   A516
....................                         exit = FALSE; 
0A512:  BCF    2C.1
....................                     } else { 
0A514:  BRA    A518
....................                         exit = TRUE; 
0A516:  BSF    2C.1
....................                     } 
....................                 break; 
0A518:  MOVLB  3
0A51A:  BRA    A612
....................                 case 7: 
....................                     envia_maquina_para_posicao(DISPENSADOR); 
0A51C:  MOVLW  05
0A51E:  MOVLB  3
0A520:  MOVWF  xAF
0A522:  MOVLB  0
0A524:  CALL   59E6
....................                     if (Teclado() == ESC){ 
0A528:  CALL   505E
0A52C:  MOVF   01,W
0A52E:  SUBLW  12
0A530:  BNZ   A536
....................                         exit = FALSE; 
0A532:  BCF    2C.1
....................                     } else { 
0A534:  BRA    A538
....................                         exit = TRUE; 
0A536:  BSF    2C.1
....................                     } 
....................                 break; 
0A538:  MOVLB  3
0A53A:  BRA    A612
....................                 case 8: 
....................                     desliga_pressor(); 
0A53C:  CALL   6AB0
....................                     dispensa_placa(); 
0A540:  BRA    A28A
....................                     if (Teclado() == ESC){ 
0A542:  CALL   505E
0A546:  MOVF   01,W
0A548:  SUBLW  12
0A54A:  BNZ   A550
....................                         exit = FALSE; 
0A54C:  BCF    2C.1
....................                     } else { 
0A54E:  BRA    A552
....................                         exit = TRUE; 
0A550:  BSF    2C.1
....................                     } 
....................                 break; 
0A552:  MOVLB  3
0A554:  BRA    A612
....................                 case 9: 
....................                     envia_maquina_para_posicao(HOME2); 
0A556:  MOVLW  04
0A558:  MOVLB  3
0A55A:  MOVWF  xAF
0A55C:  MOVLB  0
0A55E:  CALL   59E6
....................                     if (Teclado() == ESC){ 
0A562:  CALL   505E
0A566:  MOVF   01,W
0A568:  SUBLW  12
0A56A:  BNZ   A570
....................                         exit = FALSE; 
0A56C:  BCF    2C.1
....................                     } else { 
0A56E:  BRA    A572
....................                         exit = TRUE; 
0A570:  BSF    2C.1
....................                     } 
....................                 break; 
0A572:  MOVLB  3
0A574:  BRA    A612
....................                 case 10: 
....................                     envia_maquina_para_posicao(LIMPEZA); 
0A576:  MOVLW  06
0A578:  MOVLB  3
0A57A:  MOVWF  xAF
0A57C:  MOVLB  0
0A57E:  CALL   59E6
....................                     limpa_bicos(2000); 
0A582:  MOVLW  07
0A584:  MOVLB  3
0A586:  MOVWF  xB0
0A588:  MOVLW  D0
0A58A:  MOVWF  xAF
0A58C:  MOVLB  0
0A58E:  RCALL  A306
....................                     if (Teclado() == ESC){ 
0A590:  CALL   505E
0A594:  MOVF   01,W
0A596:  SUBLW  12
0A598:  BNZ   A59E
....................                         exit = FALSE; 
0A59A:  BCF    2C.1
....................                     } else { 
0A59C:  BRA    A5A0
....................                         exit = TRUE; 
0A59E:  BSF    2C.1
....................                     } 
....................                 break; 
0A5A0:  MOVLB  3
0A5A2:  BRA    A612
....................                 case 11: 
....................                     envia_maquina_para_posicao(LIMPEZA_2); 
0A5A4:  MOVLW  07
0A5A6:  MOVLB  3
0A5A8:  MOVWF  xAF
0A5AA:  MOVLB  0
0A5AC:  CALL   59E6
....................                     limpa_bicos(2000); 
0A5B0:  MOVLW  07
0A5B2:  MOVLB  3
0A5B4:  MOVWF  xB0
0A5B6:  MOVLW  D0
0A5B8:  MOVWF  xAF
0A5BA:  MOVLB  0
0A5BC:  RCALL  A306
....................                     if (Teclado() == ESC){ 
0A5BE:  CALL   505E
0A5C2:  MOVF   01,W
0A5C4:  SUBLW  12
0A5C6:  BNZ   A5CC
....................                         exit = FALSE; 
0A5C8:  BCF    2C.1
....................                     } else { 
0A5CA:  BRA    A5CE
....................                         exit = TRUE; 
0A5CC:  BSF    2C.1
....................                     } 
....................                 break; 
0A5CE:  MOVLB  3
0A5D0:  BRA    A612
....................                 case 12: 
....................                     envia_maquina_para_posicao(HOME1); 
0A5D2:  MOVLW  01
0A5D4:  MOVLB  3
0A5D6:  MOVWF  xAF
0A5D8:  MOVLB  0
0A5DA:  CALL   59E6
....................                     if (Teclado() == ESC){ 
0A5DE:  CALL   505E
0A5E2:  MOVF   01,W
0A5E4:  SUBLW  12
0A5E6:  BNZ   A5EC
....................                         exit = FALSE; 
0A5E8:  BCF    2C.1
....................                     } else { 
0A5EA:  BRA    A5EE
....................                         exit = TRUE; 
0A5EC:  BSF    2C.1
....................                     } 
....................                 break; 
0A5EE:  MOVLB  3
0A5F0:  BRA    A612
....................                 case 13: 
....................                     envia_maquina_para_posicao(ALIMENTADOR); 
0A5F2:  MOVLB  3
0A5F4:  CLRF   xAF
0A5F6:  MOVLB  0
0A5F8:  CALL   59E6
....................                     if (Teclado() == ESC){ 
0A5FC:  CALL   505E
0A600:  MOVF   01,W
0A602:  SUBLW  12
0A604:  BNZ   A60A
....................                         exit = FALSE; 
0A606:  BCF    2C.1
....................                     } else { 
0A608:  BRA    A60C
....................                         exit = TRUE; 
0A60A:  BSF    2C.1
....................                     } 
....................                 break; 
0A60C:  MOVLB  3
0A60E:  BRA    A612
0A610:  MOVLB  3
....................             } 
0A612:  INCF   xAD,F
0A614:  BRA    A36C
....................         } 
0A616:  MOVLB  0
0A618:  BRA    A364
....................     } 
....................     menu_atual = menu_principal; 
0A61A:  CLRF   1C
....................     tela_principal(); 
0A61C:  CALL   4ECE
0A620:  GOTO   A9F0 (RETURN)
.................... } 
....................  
....................  
.................... // <editor-fold defaultstate="collapsed" desc="Interrupoes de Tempo"> 
....................  
.................... #int_timer0 
....................  
.................... void trata_timer0(void) { 
....................     movimenta_eixo_x(); 
*
014B8:  BRA    13F2
.................... } 
014BA:  BCF    FF2.2
014BC:  GOTO   0078
.................... #int_timer1 
....................  
.................... void trata_timer1(void) { 
....................     movimenta_eixo_y(); 
*
01A7C:  BRA    19A0
.................... } 
01A7E:  BCF    F9E.0
01A80:  GOTO   0078
.................... #int_timer2 
....................  
.................... void trata_timer2(void) {//Timer responsavel por contar tempo de execuo 
....................     ciclo++; 
01A84:  MOVLW  01
01A86:  ADDWF  28,F
01A88:  BTFSC  FD8.0
01A8A:  INCF   29,F
01A8C:  BTFSC  FD8.2
01A8E:  INCF   2A,F
01A90:  BTFSC  FD8.2
01A92:  INCF   2B,F
.................... } 
01A94:  BCF    F9E.1
01A96:  GOTO   0078
.................... #int_timer3 
....................  
.................... void trata_timer3(void) { 
....................     movimenta_eixo_z(); 
*
02014:  BRA    1F3A
02016:  BCF    FA1.1
02018:  GOTO   0078
.................... } 
.................... // </editor-fold> 
....................  
.................... void main() {     
*
0A664:  CLRF   FF8
0A666:  BCF    FD0.7
0A668:  BSF    07.7
0A66A:  BSF    F94.3
0A66C:  BSF    F94.4
0A66E:  MOVLW  31
0A670:  MOVWF  FC8
0A672:  MOVLW  28
0A674:  MOVWF  FC6
0A676:  BSF    FC7.7
0A678:  BCF    FC7.6
0A67A:  CLRF   1C
0A67C:  MOVLW  01
0A67E:  MOVWF  21
0A680:  CLRF   22
0A682:  MOVLW  03
0A684:  MOVWF  23
0A686:  CLRF   24
0A688:  BSF    2C.0
0A68A:  BSF    2C.1
0A68C:  BSF    2C.2
0A68E:  MOVLW  01
0A690:  MOVWF  2D
0A692:  MOVLB  1
0A694:  MOVWF  x0E
0A696:  MOVWF  x0F
0A698:  CLRF   x21
0A69A:  CLRF   x20
0A69C:  MOVLW  48
0A69E:  MOVWF  x1F
0A6A0:  MOVLW  86
0A6A2:  MOVWF  x1E
0A6A4:  CLRF   x25
0A6A6:  CLRF   x24
0A6A8:  CLRF   x23
0A6AA:  MOVLW  7F
0A6AC:  MOVWF  x22
0A6AE:  CLRF   x29
0A6B0:  CLRF   x28
0A6B2:  MOVLW  10
0A6B4:  MOVWF  x27
0A6B6:  MOVLW  82
0A6B8:  MOVWF  x26
0A6BA:  CLRF   x2D
0A6BC:  CLRF   x2C
0A6BE:  MOVLW  16
0A6C0:  MOVWF  x2B
0A6C2:  MOVLW  86
0A6C4:  MOVWF  x2A
0A6C6:  CLRF   x31
0A6C8:  CLRF   x30
0A6CA:  MOVLW  16
0A6CC:  MOVWF  x2F
0A6CE:  MOVLW  88
0A6D0:  MOVWF  x2E
0A6D2:  CLRF   x35
0A6D4:  CLRF   x34
0A6D6:  MOVLW  48
0A6D8:  MOVWF  x33
0A6DA:  MOVLW  86
0A6DC:  MOVWF  x32
0A6DE:  CLRF   x39
0A6E0:  CLRF   x38
0A6E2:  MOVLW  7A
0A6E4:  MOVWF  x37
0A6E6:  MOVLW  87
0A6E8:  MOVWF  x36
0A6EA:  CLRF   x3D
0A6EC:  CLRF   x3C
0A6EE:  CLRF   x3B
0A6F0:  CLRF   x3A
0A6F2:  MOVLW  14
0A6F4:  MOVWF  x3E
0A6F6:  CLRF   x42
0A6F8:  CLRF   x41
0A6FA:  CLRF   x40
0A6FC:  CLRF   x3F
0A6FE:  CLRF   x46
0A700:  CLRF   x45
0A702:  MOVLW  48
0A704:  MOVWF  x44
0A706:  MOVLW  85
0A708:  MOVWF  x43
0A70A:  CLRF   xE8
0A70C:  CLRF   xE7
0A70E:  CLRF   xE9
0A710:  CLRF   xEA
0A712:  BCF    x1A.4
0A714:  BCF    x1A.5
0A716:  CLRF   xEC
0A718:  CLRF   xEB
0A71A:  CLRF   xEE
0A71C:  CLRF   xED
0A71E:  CLRF   xF0
0A720:  CLRF   xEF
0A722:  CLRF   xF2
0A724:  CLRF   xF1
0A726:  CLRF   xF6
0A728:  CLRF   xF5
0A72A:  CLRF   xF4
0A72C:  CLRF   xF3
0A72E:  CLRF   xF7
0A730:  MOVLW  13
0A732:  MOVWF  xF8
0A734:  CLRF   xFC
0A736:  CLRF   xFB
0A738:  MOVLW  48
0A73A:  MOVWF  xFA
0A73C:  MOVLW  86
0A73E:  MOVWF  xF9
0A740:  MOVLB  2
0A742:  CLRF   x00
0A744:  MOVLB  1
0A746:  CLRF   xFF
0A748:  CLRF   xFE
0A74A:  MOVLW  7F
0A74C:  MOVWF  xFD
0A74E:  MOVLB  2
0A750:  CLRF   x04
0A752:  CLRF   x03
0A754:  MOVLW  10
0A756:  MOVWF  x02
0A758:  MOVLW  82
0A75A:  MOVWF  x01
0A75C:  CLRF   x08
0A75E:  CLRF   x07
0A760:  MOVLW  16
0A762:  MOVWF  x06
0A764:  MOVLW  86
0A766:  MOVWF  x05
0A768:  CLRF   x0C
0A76A:  CLRF   x0B
0A76C:  MOVLW  16
0A76E:  MOVWF  x0A
0A770:  MOVLW  88
0A772:  MOVWF  x09
0A774:  CLRF   x10
0A776:  CLRF   x0F
0A778:  MOVLW  48
0A77A:  MOVWF  x0E
0A77C:  MOVLW  86
0A77E:  MOVWF  x0D
0A780:  CLRF   x14
0A782:  CLRF   x13
0A784:  MOVLW  7A
0A786:  MOVWF  x12
0A788:  MOVLW  87
0A78A:  MOVWF  x11
0A78C:  CLRF   x18
0A78E:  CLRF   x17
0A790:  CLRF   x16
0A792:  CLRF   x15
0A794:  MOVLW  14
0A796:  MOVWF  x19
0A798:  CLRF   x1D
0A79A:  CLRF   x1C
0A79C:  CLRF   x1B
0A79E:  CLRF   x1A
0A7A0:  CLRF   x21
0A7A2:  CLRF   x20
0A7A4:  MOVLW  48
0A7A6:  MOVWF  x1F
0A7A8:  MOVLW  85
0A7AA:  MOVWF  x1E
0A7AC:  CLRF   xC3
0A7AE:  CLRF   xC2
0A7B0:  CLRF   xC4
0A7B2:  CLRF   xC5
0A7B4:  MOVLB  1
0A7B6:  BCF    x1A.6
0A7B8:  BCF    x1A.7
0A7BA:  MOVLB  2
0A7BC:  BCF    xC6.0
0A7BE:  CLRF   xC8
0A7C0:  CLRF   xC7
0A7C2:  CLRF   xCA
0A7C4:  CLRF   xC9
0A7C6:  CLRF   xCC
0A7C8:  CLRF   xCB
0A7CA:  CLRF   xCE
0A7CC:  CLRF   xCD
0A7CE:  CLRF   xD2
0A7D0:  CLRF   xD1
0A7D2:  CLRF   xD0
0A7D4:  CLRF   xCF
0A7D6:  CLRF   xD3
0A7D8:  MOVLW  13
0A7DA:  MOVWF  xD4
0A7DC:  CLRF   xD6
0A7DE:  CLRF   xD5
0A7E0:  CLRF   xDA
0A7E2:  CLRF   xD9
0A7E4:  MOVLW  48
0A7E6:  MOVWF  xD8
0A7E8:  MOVLW  86
0A7EA:  MOVWF  xD7
0A7EC:  CLRF   xDE
0A7EE:  CLRF   xDD
0A7F0:  CLRF   xDC
0A7F2:  MOVLW  7F
0A7F4:  MOVWF  xDB
0A7F6:  CLRF   xE2
0A7F8:  CLRF   xE1
0A7FA:  MOVLW  10
0A7FC:  MOVWF  xE0
0A7FE:  MOVLW  82
0A800:  MOVWF  xDF
0A802:  CLRF   xE6
0A804:  CLRF   xE5
0A806:  MOVLW  16
0A808:  MOVWF  xE4
0A80A:  MOVLW  86
0A80C:  MOVWF  xE3
0A80E:  CLRF   xEA
0A810:  CLRF   xE9
0A812:  MOVLW  48
0A814:  MOVWF  xE8
0A816:  MOVLW  87
0A818:  MOVWF  xE7
0A81A:  CLRF   xEE
0A81C:  CLRF   xED
0A81E:  MOVLW  7A
0A820:  MOVWF  xEC
0A822:  MOVLW  86
0A824:  MOVWF  xEB
0A826:  CLRF   xF2
0A828:  CLRF   xF1
0A82A:  CLRF   xF0
0A82C:  CLRF   xEF
0A82E:  MOVLW  14
0A830:  MOVWF  xF3
0A832:  CLRF   xF7
0A834:  CLRF   xF6
0A836:  CLRF   xF5
0A838:  CLRF   xF4
0A83A:  MOVLB  3
0A83C:  CLRF   x99
0A83E:  CLRF   x98
0A840:  CLRF   x9A
0A842:  CLRF   x9B
0A844:  MOVLB  2
0A846:  BCF    xC6.1
0A848:  BCF    xC6.2
0A84A:  MOVLB  3
0A84C:  CLRF   x9D
0A84E:  CLRF   x9C
0A850:  CLRF   x9F
0A852:  CLRF   x9E
0A854:  CLRF   xA1
0A856:  CLRF   xA0
0A858:  CLRF   xA3
0A85A:  CLRF   xA2
0A85C:  CLRF   xA7
0A85E:  CLRF   xA6
0A860:  CLRF   xA5
0A862:  CLRF   xA4
0A864:  CLRF   xA8
0A866:  MOVLW  13
0A868:  MOVWF  xA9
0A86A:  CLRF   xAB
0A86C:  CLRF   xAA
0A86E:  MOVLW  DD
0A870:  MOVWF  xAC
0A872:  MOVF   FC1,W
0A874:  ANDLW  C0
0A876:  IORLW  0F
0A878:  MOVWF  FC1
0A87A:  MOVLW  07
0A87C:  MOVWF  FB4
0A87E:  CLRF   16
0A880:  CLRF   17
....................     // <editor-fold defaultstate="collapsed" desc="Inicializao saidas e entradas"> 
....................     setup_adc(ADC_OFF); 
0A882:  BCF    FC2.0
....................     setup_ccp1(CCP_OFF); 
0A884:  MOVLW  F0
0A886:  ANDWF  FBD,F
....................     setup_ccp2(CCP_OFF); 
0A888:  ANDWF  FBA,F
....................     enable_interrupts(GLOBAL); 
0A88A:  MOVLW  C0
0A88C:  IORWF  FF2,F
....................     setup_psp(PSP_DISABLED); 
0A88E:  BCF    F96.4
....................     output_low(step_y); 
0A890:  BCF    F94.2
0A892:  BCF    F8B.2
....................     output_low(dir_y); 
0A894:  BCF    F94.1
0A896:  BCF    F8B.1
....................     output_high(enable_y); 
0A898:  BCF    F94.0
0A89A:  BSF    F8B.0
....................     output_low(step_x); 
0A89C:  BCF    F95.2
0A89E:  BCF    F8C.2
....................     output_low(dir_x); 
0A8A0:  BCF    F95.1
0A8A2:  BCF    F8C.1
....................     output_high(enable_x); 
0A8A4:  BCF    F95.0
0A8A6:  BSF    F8C.0
....................     output_low(step_z); 
0A8A8:  BCF    F92.5
0A8AA:  BCF    F89.5
....................     output_low(dir_z); 
0A8AC:  BCF    F92.4
0A8AE:  BCF    F89.4
....................     output_high(enable_z); 
0A8B0:  BCF    F92.3
0A8B2:  BSF    F89.3
....................     output_low(step_flip); 
0A8B4:  BCF    F96.2
0A8B6:  BCF    F8D.2
....................     output_low(dir_flip); 
0A8B8:  BCF    F96.1
0A8BA:  BCF    F8D.1
....................     output_high(enable_flip); 
0A8BC:  BCF    F96.0
0A8BE:  BSF    F8D.0
....................     setup_timer_2(T2_DIV_BY_16, 255, 16); 
0A8C0:  MOVLW  78
0A8C2:  IORLW  06
0A8C4:  MOVWF  FCA
0A8C6:  MOVLW  FF
0A8C8:  MOVWF  FCB
....................     enable_interrupts(INT_TIMER2); 
0A8CA:  BSF    F9D.1
....................     inicializa_display(); 
0A8CC:  MOVLB  0
0A8CE:  GOTO   20E0
....................     Init_Keyboard(); 
0A8D2:  GOTO   2198
....................     Init_Sensores_porta1(); 
0A8D6:  GOTO   21C4
....................     Init_saidas(); 
0A8DA:  GOTO   21DA
....................     desaciona_todas_saidas(); 
0A8DE:  GOTO   21F0
....................     init_ext_eeprom(); 
0A8E2:  GOTO   239C
....................     // </editor-fold> 
....................     tela_apresentacao(); 
0A8E6:  GOTO   24B4
....................     home_solenoides(); 
0A8EA:  CALL   2578
....................     tela_iniciando_maquina(); 
0A8EE:  GOTO   2610
....................     init_axis_x(); 
0A8F2:  GOTO   2C0A
....................     init_axis_y(); 
0A8F6:  GOTO   30E8
....................     init_axis_z(); 
0A8FA:  GOTO   35E8
....................     posicao_maquina_1_default(); 
0A8FE:  CALL   4CFA
....................     tela_principal(); 
0A902:  CALL   4ECE
....................      
....................     while(run_ok){ 
0A906:  BTFSS  2C.0
0A908:  BRA    A9FA
....................         if (ciclo % 10 == 0){ 
0A90A:  BSF    FD8.1
0A90C:  MOVLW  03
0A90E:  MOVWF  FEA
0A910:  MOVLW  AD
0A912:  MOVWF  FE9
0A914:  MOVFF  2B,3B4
0A918:  MOVFF  2A,3B3
0A91C:  MOVFF  29,3B2
0A920:  MOVFF  28,3B1
0A924:  MOVLB  3
0A926:  CLRF   xB8
0A928:  CLRF   xB7
0A92A:  CLRF   xB6
0A92C:  MOVLW  0A
0A92E:  MOVWF  xB5
0A930:  MOVLB  0
0A932:  GOTO   4F32
0A936:  MOVFF  3B0,3B4
0A93A:  MOVFF  3AF,3B3
0A93E:  MOVFF  3AE,3B2
0A942:  MOVFF  3AD,3B1
0A946:  MOVLB  3
0A948:  MOVF   xB1,F
0A94A:  BNZ   A9F6
0A94C:  MOVF   xB2,F
0A94E:  BNZ   A9F6
0A950:  MOVF   xB3,F
0A952:  BNZ   A9F6
0A954:  MOVF   xB4,F
0A956:  BNZ   A9F6
....................             switch(menu_atual){ 
0A958:  MOVF   1C,W
0A95A:  ADDLW  EE
0A95C:  BC    A9F6
0A95E:  ADDLW  12
0A960:  MOVLB  0
0A962:  GOTO   A9FC
....................                 case menu_principal: //menu_principal = 0 
....................                     atualiza_tela_principal(); //essa funao gera uma tela e depois espera interaoes 
0A966:  GOTO   5582
....................                 break;  
0A96A:  MOVLB  3
0A96C:  BRA    A9F6
....................                 case menu_seleciona_maquina: 
....................                     atualiza_tela_seleciona_maquina(); 
0A96E:  GOTO   6412
....................                 break; 
0A972:  MOVLB  3
0A974:  BRA    A9F6
....................                 case menu_manutencao_outra_maquina: 
....................                     atualiza_tela_manutencao_outra_maquina(); 
0A976:  GOTO   644E
....................                 break; 
0A97A:  MOVLB  3
0A97C:  BRA    A9F6
....................  
....................                 case menu_edita_modelo: 
....................                     atualiza_tela_edita_modelo(); 
0A97E:  GOTO   64EE
....................                 break; 
0A982:  MOVLB  3
0A984:  BRA    A9F6
....................                 case menu_seleciona_debug: 
....................                     atualiza_tela_seleciona_debug(); 
0A986:  GOTO   66D2
....................                 break;                 
0A98A:  MOVLB  3
0A98C:  BRA    A9F6
....................                 case menu_edita_pontos_no_modelo: 
....................                     atualiza_tela_edita_pontos_no_modelo(); 
0A98E:  GOTO   6740
....................                 break;                 
0A992:  MOVLB  3
0A994:  BRA    A9F6
....................                 case menu_seleciona_pontos: 
....................                     atualiza_tela_seleciona_pontos(); 
0A996:  GOTO   6AC0
....................                 break; 
0A99A:  MOVLB  3
0A99C:  BRA    A9F6
....................                 case menu_dados_ponto: 
....................                     atualiza_tela_dados_ponto(); 
0A99E:  GOTO   7CC6
....................                 break; 
0A9A2:  MOVLB  3
0A9A4:  BRA    A9F6
....................                 case menu_excluir_modelo: 
....................                     atualiza_tela_excluir_modelo(); 
0A9A6:  GOTO   8516
....................                 break;          
0A9AA:  MOVLB  3
0A9AC:  BRA    A9F6
....................                  
....................  
....................                 case menu_seleciona_manutencao: 
....................                     atualiza_tela_seleciona_manutencao(); 
0A9AE:  GOTO   87EA
....................                 break;                 
0A9B2:  MOVLB  3
0A9B4:  BRA    A9F6
....................                 case menu_debug_entrada_1: 
....................                     atualiza_tela_debug_entrada_1(); 
0A9B6:  GOTO   8A08
....................                 break; 
0A9BA:  MOVLB  3
0A9BC:  BRA    A9F6
....................                 case menu_debug_entrada_2: 
....................                     atualiza_tela_debug_entrada_2(); 
0A9BE:  GOTO   8CA6
....................                 break; 
0A9C2:  MOVLB  3
0A9C4:  BRA    A9F6
....................                 case menu_debug_entrada_3: 
....................                     atualiza_tela_debug_entrada_3(); 
0A9C6:  GOTO   8D30
....................                 break; 
0A9CA:  MOVLB  3
0A9CC:  BRA    A9F6
....................                 case menu_debug_saida_1: 
....................                     atualiza_tela_debug_saida_1(); 
0A9CE:  GOTO   8E08
....................                 break; 
0A9D2:  MOVLB  3
0A9D4:  BRA    A9F6
....................                 case menu_debug_saida_2: 
....................                     atualiza_tela_debug_saida_2(); 
0A9D6:  GOTO   8FB8
....................                 break; 
0A9DA:  MOVLB  3
0A9DC:  BRA    A9F6
....................                 case menu_debug_saida_3: 
....................                     atualiza_tela_debug_saida_3(); 
0A9DE:  GOTO   91F6
....................                 break; 
0A9E2:  MOVLB  3
0A9E4:  BRA    A9F6
....................                 case menu_debug_saida_4: 
....................                     atualiza_tela_debug_saida_4(); 
0A9E6:  GOTO   9384
....................                 break; 
0A9EA:  MOVLB  3
0A9EC:  BRA    A9F6
....................  
....................  
....................                 case menu_programa_principal: 
....................                     programa_principal(); 
0A9EE:  BRA    A364
....................                 break; 
0A9F0:  MOVLB  3
0A9F2:  BRA    A9F6
0A9F4:  MOVLB  3
....................             } 
....................         } 
0A9F6:  MOVLB  0
0A9F8:  BRA    A906
....................     }    
.................... } 
0A9FA:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C000   PROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
